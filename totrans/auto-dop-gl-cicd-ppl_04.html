<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer043">
			<h1 id="_idParaDest-80" class="chapter-number"><a id="_idTextAnchor084"/>4</h1>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor085"/>Understanding GitLab’s CI/CD Pipeline Structure</h1>
			<p>By now, you have enough knowledge of Git and GitLab concepts to understand how developers <a id="_idIndexMarker236"/>can use those tools within the <strong class="bold">Create</strong> stage of the <strong class="bold">software development life cycle</strong> (<strong class="bold">SDLC</strong>) to create, review, and store code. You’ve also been introduced to some of the problems presented by the <strong class="bold">Verify</strong>, <strong class="bold">Package</strong>, and <strong class="bold">Release</strong> stages that come immediately after the <strong class="bold">Create</strong> stage. Now, it’s time to get to the meat (or tofu, if you prefer) of this book: how GitLab’s CI/CD pipelines can help solve those Verify, Package, and <span class="No-Break">Release problems.</span></p>
			<p>In this chapter, you’ll <a id="_idIndexMarker237"/>learn what <strong class="bold">continuous integration</strong> (<strong class="bold">CI</strong>) and <strong class="bold">continuous delivery</strong> (<strong class="bold">CD</strong>) mean, and how they fit into GitLab Flow. You’ll learn <a id="_idIndexMarker238"/>how to describe the different parts of a pipeline, including stages and jobs. You’ll see how those parts fit together, and how code flows through them. You’ll be shown how to view the overall status of a pipeline, and the status of the individual stages and jobs that make them up. You’ll learn about the different ways GitLab can trigger pipelines, and why you might want to limit how often your pipelines run. Finally, you’ll learn how to configure a simple Hello World-style pipeline <a id="_idIndexMarker239"/>for your Hats for Cats software. </p>
			<p>Once you’re comfortable with these concepts and practices, you will have opened the door to powerful GitLab features that are enabled and configured through pipelines. And when you hit that point, odds are you’ll become a devout and committed GitLab user who can’t imagine going back to other <span class="No-Break">DevOps tools.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Defining the terms “pipeline”, “CI”, <span class="No-Break">and “CD”</span></li>
				<li>Parts of a pipeline – stages, jobs, <span class="No-Break">and commands</span></li>
				<li>Running GitLab <span class="No-Break">CI/CD pipelines</span></li>
				<li>Reading GitLab CI/CD <span class="No-Break">pipeline statuses</span></li>
				<li>Configuring GitLab <span class="No-Break">CI/CD pipelines</span></li>
			</ul>
			<h1 id="_idParaDest-82"><a id="_idTextAnchor086"/>Technical requirements</h1>
			<p>As with the previous chapter, you’ll get the most out of this chapter if you’ve got an account on <a id="_idIndexMarker240"/>a GitLab instance (self-managed or <strong class="bold">Software-as-a-Service</strong> (<strong class="bold">SaaS</strong>)) that you can log in to and use to practice and experiment with the <span class="No-Break">concepts discussed.</span></p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor087"/>Defining the terms pipeline, CI, and CD</h1>
			<p>Since much <a id="_idIndexMarker241"/>of the power of GitLab comes from configuring CI/CD pipelines to do various things to and with your code, it’s critical to understand what a pipeline even is. So, an obvious place to start a discussion of this topic is to figure out exactly what we mean by pipeline, CI, and CD. We won’t start creating pipelines yet—that will come in a <span class="No-Break">later chapter.</span></p>
			<h2 id="_idParaDest-84"><a id="_idTextAnchor088"/>Understanding what a pipeline is</h2>
			<p><em class="italic">A GitLab CI/CD pipeline is a series of steps that are performed on your files whenever you commit edits to the GitLab-hosted copy of a repository</em>. A lot is going on in that sentence, so let’s take a more careful look at each part <span class="No-Break">of it.</span></p>
			<p>What do we mean by “a series of steps”? You can think of these steps as <em class="italic">tasks that are performed on your files</em>. For example, you may want to run various tests or scanners on your files to make sure your code is well-written, is free from security vulnerabilities, uses appropriately licensed dependencies, and satisfies all functional or performance requirements. You may also want to package your code into some deployable format, whether that’s a Ruby Gem, installable Red Hat package, Docker image, or any other package type. Of course, you may also need a step that deploys your code into an appropriate environment, whether that be a test environment, a pre-production environment, or your project’s actual <span class="No-Break">production environment.</span></p>
			<p>What do we mean by “your files”? Technically, a GitLab CI/CD pipeline can perform the steps we just described on any files included in a GitLab project’s repository: source code files, configuration files, README files, and test data files. In short, <em class="italic">you can configure a pipeline to inspect, test, package, deploy, or otherwise manipulate any files in your project</em>. By far the most common type of files that are targeted by pipeline steps are source code files, but it’s important to remember that you can configure pipelines to perform almost any task on almost any file in a GitLab <span class="No-Break">project’s repository.</span></p>
			<p>Why did we <a id="_idIndexMarker242"/>specify that pipelines run “whenever you commit edits”? Because in the vast majority of cases, <em class="italic">adding a Git commit is exactly what causes a pipeline to run against your files</em>. Many of the advantages that GitLab brings to the SDLC can only happen if the pipelines run often, against small collections of file changes. To make this happen, the default behavior for GitLab is to run a complete pipeline every time you commit edited files to the GitLab-hosted copy of your project’s repository. Committing is not the only way to trigger a pipeline, even if it is by far the most common way. Later in this chapter, you’ll learn about starting pipeline runs manually, and also how to prevent a pipeline from running after <span class="No-Break">a commit.</span></p>
			<p>Finally, why is it important to specify that pipelines only work on the GitLab-hosted copy of a repository? That’s because pipelines are a GitLab concept, not a Git concept. This means that pipelines can only access files that GitLab knows about, and that means files that are in the copy of your project’s repository that is stored on the GitLab instance. In other words, if you edit files on a local copy of your project’s repository, GitLab cannot see those versions of the files (at least, not until you sync them with GitLab using <strong class="source-inline">git push</strong>), so it can’t run pipelines on those versions of the files. Again: <em class="italic">pipelines can only target the versions of your files that live on your </em><span class="No-Break"><em class="italic">GitLab instance.</em></span></p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor089"/>Defining one pipeline per project</h2>
			<p>Each project defines only one GitLab CI/CD pipeline. However, exactly what happens in that pipeline – the tasks that it includes – might depend on various factors, leading one run of the <a id="_idIndexMarker243"/>pipeline to “look different” from other runs of the project’s pipeline. For example, the pipeline that runs against edited source code may include many automated tests and packaging the code into a Docker image, whereas the pipeline that runs against edited documentation may involve spelling checks and deployment to a web server. But it’s still the same pipeline in both cases. It’s just that certain “features” of the single pipeline can be turned on or off, depending on which features make sense for which types of code changes. It’s easy to see two pipeline runs from the same project give wildly different outputs and think that they are two completely different pipelines, but that’s not the case. <em class="italic">Every GitLab project has just one CI/CD pipeline</em>. It’s just that what that pipeline does can vary from run <span class="No-Break">to run.</span></p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor090"/>Understanding different uses of the term “pipeline”</h2>
			<p>The term “pipeline” is sometimes used loosely. The most accurate way of thinking about it is to say that a project’s pipeline is just a blueprint or recipe for the series of steps that will be <a id="_idIndexMarker244"/>applied to the project’s file. Performing those steps is not technically a pipeline and is instead called a “pipeline run” or “pipeline instance.” But people often refer to individual runs as pipelines. We’ll do the same thing in this chapter: we’ll often use the shorter term “pipeline” when “pipeline run” or “pipeline instance” would technically be more accurate. Whether we’re talking about the blueprint for the pipeline or an individual instance of a pipeline should be clear from <span class="No-Break">the context.</span></p>
			<p>A project can run more than one pipeline instance at a time. If you make two commits just a few seconds apart, and if the pipeline steps take several minutes to complete, then you could have two pipeline instances running at the same time, on the two different commits. Each pipeline run would be performing the same steps but against different versions of <span class="No-Break">your files.</span></p>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor091"/>Viewing a list of pipelines</h2>
			<p>One of the most common things you’ll do when using GitLab to build software is look at a list of running <a id="_idIndexMarker245"/>and completed pipeline instances. Following the pattern established in previous chapters, we’ll focus less on how to do this (since the GUI may change and the official GitLab documentation will always have up-to-date instructions) and more on why you may want to do so. </p>
			<p>GitLab’s list of pipelines not only tells you the pass/fail status of all of your pipeline runs, but also lets you know if any pipelines are “stuck” or unable to run for some reason. It shows you which version of the code each pipeline is running against, the commit message for the commit or Git tag that triggered the pipeline, who made the commit or tag, when the pipeline started, and how long it took to run (if it completed). </p>
			<p>The list of pipelines also provides a GUI control for canceling a pipeline mid-run. Some complicated pipelines can take several minutes (or possibly even hours) to run, and if you have a limited number of pipeline minutes available to your project, you may want to cancel a pipeline that was triggered by some trivial file change to conserve your minutes. </p>
			<p>Finally, the list of pipelines also provides GUI controls to rerun any pipeline. You may want to do this if a pipeline failed for what you suspect was an intermittent network problem, <span class="No-Break">for example.</span></p>
			<p>Here’s a list <a id="_idIndexMarker246"/>of pipelines – both running and completed – for the Hats for Cats project. The table lists pipelines in reverse chronological order, with the most recent pipelines at the top. You can see that two pipeline runs have finished with a “passed” status, one has finished with a “failed” status, and the two most recent pipelines are still running. Don’t worry about the icons in each row that depict the status of the different parts of each pipeline; we’ll go over those later in <span class="No-Break">this chapter:</span></p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/Figure_4.1_B18073.jpg" alt="Figure 4.1 – A list of Hats for Cats pipeline runs" width="1263" height="626"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – A list of Hats for Cats pipeline runs</p>
			<p>You’ve seen what pipelines are, how the term can be used loosely, how each project has just one pipeline defined, and what sorts of information you can get from a list of pipelines. Now, let’s pull apart the terms CI and CD and look at what they mean when applied <span class="No-Break">to pipelines.</span></p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor092"/>CI – finding out if your code is good</h2>
			<p>Although every GitLab project defines, at most, one pipeline, almost every pipeline consists <a id="_idIndexMarker247"/>of two halves: a CI half and a CD half. The CI portion of a pipeline consists of steps dedicated to answering the question, <em class="italic">Is your </em><span class="No-Break"><em class="italic">code good?</em></span></p>
			<p>The term <strong class="bold">CI</strong> stands for <strong class="bold">continuous integration</strong>. This is not just a GitLab term – it’s a standard term whose definition is understood and agreed on by most software companies. You can think of it as the portion of the pipeline that makes sure any file edits you are working on will integrate well with your project’s stable code base. In other words, when you merge your feature or bugfix branch into the default branch, will any new problems crop up? Spotting these problems early on, as you’re working on your code but before you merge it, increases your odds of fixing them easily and cheaply. </p>
			<p>The CI portion of a pipeline does this by running tests, scans, and other checks on your code whenever you commit it to the GitLab-hosted copy of your project’s Git repository. At least, that’s the default behavior for GitLab pipelines. You can override that behavior so that pipelines don’t run on <em class="italic">every</em> commit, and there are some good reasons you might want to do that, but we’ll discuss those later. </p>
			<p>You’ve already seen some references to some of the kinds of tests and scans that are run by a pipeline’s CI-related steps, but as a refresher, here’s a <em class="italic">partial</em> list of possible CI-focused <span class="No-Break">pipeline steps:</span></p>
			<ul>
				<li><strong class="bold">Functional tests</strong>: Does <a id="_idIndexMarker248"/>your software <a id="_idIndexMarker249"/>do what it’s supposed to? This category includes the regression tests that <strong class="bold">Quality Assurance</strong> (<strong class="bold">QA</strong>) teams spend much of their <span class="No-Break">time writing.</span></li>
				<li><strong class="bold">Security scans</strong>: Does <a id="_idIndexMarker250"/>your code introduce any <span class="No-Break">security vulnerabilities?</span></li>
				<li><strong class="bold">Code quality scans</strong>: Does <a id="_idIndexMarker251"/>your code adhere to best practices for class length, white space usage, and other <span class="No-Break">style-related considerations?</span></li>
				<li><strong class="bold">Performance tests</strong>: Does <a id="_idIndexMarker252"/>your code meet <span class="No-Break">performance expectations?</span></li>
				<li><strong class="bold">License scanning</strong>: Do all <a id="_idIndexMarker253"/>of your code’s dependencies use software licenses that are compatible with your main <span class="No-Break">project’s license?</span></li>
				<li><strong class="bold">Fuzz testing</strong>: Can <a id="_idIndexMarker254"/>you trigger crashes or unexpected errors in your code by passing it unusually long strings, numbers that are outside the expected ranges, or other strange or extreme data <span class="No-Break">as input?</span></li>
			</ul>
			<p>Because GitLab <a id="_idIndexMarker255"/>provides first-class support for these types of checks, they are simple to enable within CI pipelines. But <em class="italic">you can integrate almost any tool, scan, or check into a GitLab pipeline</em>. We’ll learn how to do this later, but for now, all you need to know is that any tool that can be run from the command line – whether commercial, open source, or home-grown – can be added to a <span class="No-Break">GitLab pipeline.</span></p>
			<h3>Benefits of CI</h3>
			<p>As you can see, one of the big advantages of CI is that it enables the “shifting left” philosophy <a id="_idIndexMarker256"/>that we’ve discussed previously. The earlier you run tests, the sooner you find problems. And the sooner you find problems, the less of a burden they are to fix. Shifting as many software development tasks as far left as you can on the timeline pays <span class="No-Break">huge dividends.</span></p>
			<p>The other advantage of CI, especially when combined with GitLab’s transparent “single pane of glass” approach to monitoring your development life cycle, is that it promotes collaboration. For example, when security tests run frequently, that lets the entire team get a handle on the state of the project’s security. Are we adding unanticipated vulnerabilities that we should budget time and people to fix? Do developers need to adjust their coding approach or architecture to reduce the chance of introducing more vulnerabilities when they add new features next month? If the entire team – managers, developers, QA, UX, technical writers, and anyone else involved with the product – can see the state of the project’s security, they can all either help directly or adjust their work in whatever way makes sense to either remediate existing security problems or prevent future <span class="No-Break">security problems.</span></p>
			<p>This collaboration principle applies not just to security issues, but also to functional problems, performance problems, usability problems, or any other metric by which you measure your software. CI gives everyone on the team an understanding of the state of your software <a id="_idIndexMarker257"/>so that everyone can pitch in to help build or fix the software in whatever ways make sense for <span class="No-Break">their roles.</span></p>
			<p class="callout-heading">Understanding the Phrases CI Pipeline and CD Pipeline</p>
			<p class="callout">Throughout this book. we’ll sometimes refer to a <em class="italic">CI pipeline</em> or a <em class="italic">CD pipeline</em>, but remember that a GitLab project doesn’t have separate CI and CD pipelines – it has just one pipeline that contains some CI-related steps and some CD-related steps. The expressions “CI pipeline” and “CD pipeline” are just shortcuts for the more cumbersome (but more accurate) phrases “CI portion of a project’s single pipeline” and “CD portion of a project’s single <span class="No-Break">pipeline,” respectively.</span></p>
			<h2 id="_idParaDest-89"><a id="_idTextAnchor093"/>CD – finding out where your code should go (and putting it there)</h2>
			<p>Whereas <a id="_idIndexMarker258"/>the term <strong class="bold">CI</strong> has a standard definition that all companies use, the term <strong class="bold">CD</strong> is more <a id="_idIndexMarker259"/>ambiguous. GitLab uses the term to mean either <strong class="bold">continuous delivery</strong> or <strong class="bold">continuous deployment</strong>. We’ll get to the difference between these two terms later, but both have to do with deciding what environment your code should be deployed to, and then actually performing <span class="No-Break">that deployment.</span></p>
			<p>This will make more sense if we talk a little about environments. Most software development teams have several environments set up for deploying code. These environments serve different purposes: some are used for conducting functional tests on your software, some are used for performance tests, and some mimic the production environment so that you can spot and fix any integration errors before they show up in production. And of course, every project will have a production environment that hosts the code that real users <span class="No-Break">interact with.</span></p>
			<p>Software developed with GitLab also uses environments, and the CD portion of a GitLab CI/CD pipeline is responsible for deciding which environment code should be deployed to, and then putting it there. Depending on how you’ve configured your project’s pipeline, the tasks that perform this work look at a variety of factors when deciding where to put your code. The most common factor pipelines use is whether they’re running against a Git branch or a Git tag, and if the former, what the branch’s <span class="No-Break">name is.</span></p>
			<p>Different companies use different naming schemes for their Git branches, but here’s a typical example of how the CD portion of a GitLab pipeline may decide where to deploy a project’s code. Remember that although this is realistic, it’s by no means the only way to configure your <span class="No-Break">CD pipeline:</span></p>
			<ul>
				<li>If a pipeline runs against a branch with a name such as <strong class="source-inline">add-login-feature</strong>, <strong class="source-inline">fix-password-bug</strong>, or <strong class="source-inline">remediate-cross-site-scripting-vuln</strong>, deploy the code to a <strong class="bold">review environment</strong> for testing (more about these in the next section). </li>
				<li>If a pipeline runs against the <strong class="source-inline">main</strong> branch, deploy that code to the <strong class="bold">staging</strong> (sometimes <a id="_idIndexMarker260"/>called <span class="No-Break"><strong class="bold">pre-production</strong></span><span class="No-Break">) environment.</span></li>
				<li>If a pipeline runs against a Git tag in the <strong class="source-inline">production</strong> branch, deploy the code to the <strong class="bold">production</strong> environment. This assumes that your team adds a version tag such as <strong class="source-inline">version-1-0</strong> or <strong class="source-inline">version-12-2</strong> to every commit that it intends to deploy <span class="No-Break">to users.</span></li>
			</ul>
			<h3>Understanding review environments</h3>
			<p>Any non-trivial software project needs at least one test environment. This is a machine that the <a id="_idIndexMarker261"/>software can be deployed to as it’s being developed so that the QA team can use the software in a safe, sandboxed <a id="_idIndexMarker262"/>place to make sure it satisfies functional requirements. Some teams have additional, specialized test environments dedicated to performance testing, load testing, scalability testing, or other types of testing. GitLab has a special name for all of these test environments: <strong class="bold">review environments</strong>. Every non-default Git branch has a review environment dedicated to just that branch. As soon as that branch is merged into the default branch that holds the stable code base, GitLab destroys the no-longer-needed <span class="No-Break">review environment.</span></p>
			<p>Review environments are one of the most amazing features of GitLab. You don’t have to set these environments up yourself. Any time you create a branch in the GitLab-hosted copy of your project’s repository, a review environment magically appears, ready for your CI/CD pipeline to deploy to. And when you’re done with your branch and either delete it or merge it into your stable code base, the review environment magically disappears. It’s truly one of GitLab’s very best and most <span class="No-Break">helpful features.</span></p>
			<h3>Continuous delivery</h3>
			<p>We’ve already <a id="_idIndexMarker263"/>said that one of GitLab’s meanings for the term <strong class="bold">CD</strong> is <strong class="bold">continuous delivery</strong>. This means that a GitLab CI/CD pipeline will automatically deploy your code to the right environment, based on whatever factors you configure the pipeline to pay attention to. But there’s one important exception: with continuous delivery, GitLab will <em class="italic">not</em> automatically deploy your code to the production environment. Instead, <em class="italic">it presents a GUI control that asks a human (generally, a release engineer) to manually approve and trigger the deployment to production</em>. This is a final failsafe that prevents your team from deploying faulty code, or the wrong version of your code, to actual users. This is the most common form of CD for <span class="No-Break">GitLab users.</span></p>
			<h3>Continuous deployment</h3>
			<p>The other thing that <strong class="bold">CD</strong> can mean is <strong class="bold">continuous deployment</strong>. This is the same as continuous delivery, with one exception: it does away with the final, manual failsafe. Continuous <a id="_idIndexMarker264"/>deployment sends your code to the production environment completely automatically, just like it deploys code to any other environment. Getting rid of the human element could be seen as risky by some organizations, but if you have a mature, proven, trusted CI portion of your pipeline, you may feel confident that any code that passes through the gauntlet of tests, scans, and other checks is good enough to deploy directly to customers. This can be a good time- saver for companies with a high level of trust in their <span class="No-Break">CI pipeline.</span></p>
			<h3>Packaging and deploying code with CD</h3>
			<p>A CD pipeline – whether it implements continuous delivery or continuous deployment – sometimes <a id="_idIndexMarker265"/>needs to package your project’s <a id="_idIndexMarker266"/>code into a deployable form before it can be deployed. We’ll talk about this more concretely later. For now, just know that the CD phase of your pipeline may involve packaging Java code into a WAR or EAR, packaging Ruby code into a Gem, packaging C code into a Docker image, collecting all of your project’s files into a <em class="italic">tarball</em>, or bundling up your project’s code in whatever form makes the most sense for your project’s language and <span class="No-Break">deployment strategy.</span></p>
			<p>Of course, there are some cases where no packaging is required. Some projects with simple deployment strategies can deploy a collection of loose, <span class="No-Break">unpackaged files.</span></p>
			<p>Whether or not your CD pipeline packages your project’s code, it will always need to send your software somewhere. This could take the form of pushing a Docker image to a repository (either public or hosted by Gitlab, as we’ll learn more about later), using a command-line <a id="_idIndexMarker267"/>tool to deploy code to an AWS <a id="_idIndexMarker268"/>environment, or any of countless other environment-specific deployment techniques. Generally, this is the last task (and sometimes the only task) of the CD part of your <span class="No-Break">project’s pipeline.</span></p>
			<h3>Benefits of CD</h3>
			<p>To review, the purpose of CD is to “make releases boring.” If your CD pipeline deploys code every <a id="_idIndexMarker269"/>time you commit – whether it’s deploying code to a review environment, a staging environment, or the production environment – that helps you release code to customers more frequently, with fewer changes, and less risk. </p>
			<p>Of course, customers won’t see code that your CD pipeline deploys to a review or staging environment, but by deploying to those environments and testing your software there, your team can feel more confident about releasing the code to production when it makes business sense to do so. These non-production deployments can be thought of as trial runs for the real thing, and can help you send your customers frequent, small releases. This approach lets you get features to your customers sooner, allows customers to provide feedback on those features sooner, and reduces the risk that your deployments will need to be rolled back due to <span class="No-Break">unforeseen problems.</span></p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor094"/>GitLab Runners</h2>
			<p>Now that you understand the high-level concepts of pipelines, continuous integration, and continuous <a id="_idIndexMarker270"/>delivery, it’s time to briefly introduce a new, critically important concept that makes pipelines possible: <span class="No-Break">GitLab Runners.</span></p>
			<p>As you’ll learn in the next section, pipelines ultimately boil down to a series of shell commands that are run automatically, with little or no human intervention. This is a crucial concept to grasp when learning about CI/CD pipelines, so we’ll repeat it in different words: a CI/CD pipeline is just a series of commands that are run by a robot, where those commands perform tasks related to building, verifying, and <span class="No-Break">deploying software.</span></p>
			<p>GitLab Runners are the robots that execute those commands. Technically speaking, a GitLab Runner is a small program that is sent commands to execute by the GitLab instance. We’ll discuss the role of GitLab Runners in CI/CD pipelines and explain how to install and configure them – and how to tell if you even need to – in the next chapter. We won’t go into any further detail here, but it’s important to understand that GitLab Runners are where the rubber meets the road for a pipeline: they are what convert your CI/CD configuration code into actual, executing tasks for building, verifying, securing, and deploying your code. </p>
			<p>To whet your appetite, here’s a quick glimpse into how GitLab Runners fit into the GitLab CI/CD architecture. Think of a pipeline as relying on three components: the CI/CD configuration <a id="_idIndexMarker271"/>file that defines the pipeline’s tasks, the GitLab Runner that executes those tasks in some environment, and the GitLab instance that manages and coordinates all aspects of the pipeline and ultimately displays the results of the pipeline’s tasks. You can picture it all fitting together <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/Figure_4.2_B18073.jpg" alt="Figure 4.2 – GitLab CI/CD pipeline architectural diagram" width="449" height="504"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – GitLab CI/CD pipeline architectural diagram</p>
			<p>You’ll learn much more about many aspects of GitLab Runners in the next chapter, but this quick introduction should be sufficient to help you understand the rest of the material in <span class="No-Break">this chapter.</span></p>
			<p>With that, we can conclude our definitions and discussion of the concepts of pipelines, CI, CD, and GitLab Runners. As you’ve seen, CI/CD pipelines are a series of steps that are automatically <a id="_idIndexMarker272"/>performed against the files in your project’s Git repository, any time you edit any of those files. By running these pipelines often, and against small file changes, GitLab makes it easy to find problems early, fix them cheaply, and deploy new code to customers frequently and in a low-risk fashion. Other than taking a little time to churn through, pipelines are pretty much all upside, with no real reason not to run them. They’re a critical part of your GitLab workflow, and a big reason that developing software with GitLab is so much easier and more efficient than developing software <span class="No-Break">without it.</span></p>
			<p>Now, let’s move on to investigate the anatomy of pipelines. What are the components that make up pipelines, how do they fit together, and how does GitLab show you what happens in <span class="No-Break">a pipeline?</span></p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor095"/>Parts of a pipeline – stages, jobs, and commands</h1>
			<p>That’s the big picture of what a GitLab CI/CD pipeline is – how the CI portion of a pipeline differs from the CD portion of the same pipeline and why pipelines are such an important part of the SDLC. Let’s zoom in a little and take a look at the structure of a pipeline in more detail. In particular, <em class="italic">how is a pipeline put together from stages </em><span class="No-Break"><em class="italic">and jobs?</em></span></p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor096"/>Stages</h2>
			<p>Every pipeline <a id="_idIndexMarker273"/>consists of one or more <strong class="bold">stages</strong>. A stage is a collection <a id="_idIndexMarker274"/>of pipeline tasks that are thematically related. For example, these are probably the three most commonly <span class="No-Break">used stages:</span></p>
			<ul>
				<li><strong class="bold">Build</strong>: This stage <a id="_idIndexMarker275"/>holds tasks that compile and/or package your source code into a <span class="No-Break">deployable format.</span></li>
				<li><strong class="bold">Test</strong>: This stage <a id="_idIndexMarker276"/>holds tasks that run automated tests, code quality scans and linters, and possibly <span class="No-Break">security scans.</span></li>
				<li><strong class="bold">Deploy</strong>: This stage <a id="_idIndexMarker277"/>sends your code to the appropriate environment, depending on what Git branch or Git tag the pipeline is running against (among other <span class="No-Break">possible factors).</span></li>
			</ul>
			<p>These three stages are so commonly used that GitLab adds them to your pipeline by default. You can, of course, override this default setting by adding, removing, or replacing stages. Regardless of what stages you end up with, we recommend that you always define <a id="_idIndexMarker278"/>your stages explicitly, even if you’re using the three default stages. This may seem unnecessarily verbose, but we’ve found that it aids readability, assists with troubleshooting, and prevents confusion down <span class="No-Break">the road.</span></p>
			<p>You can define <a id="_idIndexMarker279"/>as many stages as you want. For exceptionally simple projects, you could even make a stripped-down pipeline with just one stage. You can call them whatever you want, and you can include spaces and several other punctuation symbols in stage names. Because long stage names can sometimes be truncated by GitLab’s GUI, we recommend keeping them as short as you can without <span class="No-Break">sacrificing clarity.</span></p>
			<p>GitLab has no way of checking that the tasks included within a stage are thematically connected. That’s your responsibility. This means you can create truly horrible, messy stages if you want to. For example, you could run automated regression tests in a stage called <em class="italic">Deploy Documentation</em>, and you could deploy documentation in a stage called <em class="italic">prepare-test-environment</em>. How you divide your pipelines into stages, and what tasks you put in each stage, is entirely up to you. This freedom is not without cost, however: it’s considered a best practice to occasionally review your stage structure and refactor it as needed for clarity <span class="No-Break">and consistency.</span></p>
			<h3>Viewing stages in the GitLab GUI</h3>
			<p>Remember <a id="_idIndexMarker280"/>the list of pipeline runs we saw in <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.1</em>? If you flip back to that screenshot, you‘ll notice that each row in the list of pipeline <a id="_idIndexMarker281"/>runs includes icons that give the pass/fail status for each stage within the pipeline. Here’s a zoomed-in view of the status of the Build, Test, and Deploy stages in the Hats for <span class="No-Break">Cats pipeline:</span></p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/Figure_4.3_B18073.jpg" alt="Figure 4.3 – Status icons for a pipeline instance’s stages" width="1028" height="169"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Status icons for a pipeline instance’s stages</p>
			<p>In this pipeline instance, the first two stages passed, and the third stage failed. You can’t see the names of the stages from this view, but if you hover over a stage’s status icon, the stage name <span class="No-Break">will appear.</span></p>
			<p>If <em class="italic">all</em> the stages in the pipeline pass, the pipeline will have an overall status of <strong class="bold">passed</strong>. In this case, because the final stage failed, the overall status of the pipeline is <strong class="bold">failed</strong>. </p>
			<p>If you need <a id="_idIndexMarker282"/>more details about what happened in each stage, click on <a id="_idIndexMarker283"/>the status icon at the left of the row for a pipeline instance (in this case, the red <strong class="bold">failed</strong> icon). That brings you to a zoomed-in view of the pipeline, which gives you more details about each stage. Here’s what that view <span class="No-Break">looks like:</span></p>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/Figure_4.4_B18073.jpg" alt="Figure 4.4 – Details of three pipeline stages" width="1100" height="484"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Details of three pipeline stages</p>
			<p>You can see the <strong class="bold">Build</strong>, <strong class="bold">Test</strong>, and <strong class="bold">Deploy</strong> stages depicted as columns, with the tasks that occur within each stage listed within the stage’s column. But what are those tasks exactly? That’s a perfect segue to the next <span class="No-Break">topic: jobs.</span></p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor097"/>Jobs</h2>
			<p>Throughout <a id="_idIndexMarker284"/>this chapter, we’ve been talking about the “tasks” that happen <a id="_idIndexMarker285"/>within a pipeline. Now, it’s time to introduce you to the formal name for those tasks: GitLab calls them <strong class="bold">jobs</strong>. Each job must have a name that describes the task <span class="No-Break">it performs.</span></p>
			<p>You can think of jobs as the next level down (down from stages, that is) when it comes to the building blocks that make up a GitLab CI/CD pipeline. Each stage contains one or more jobs, and each job is contained by some stage. </p>
			<p>If you look at the preceding screenshot again, you’ll see that the <strong class="bold">Build</strong> stage contains a job called <strong class="bold">build-job</strong>, the <strong class="bold">Test</strong> stage contains a job called <strong class="bold">test-job</strong>, and the <strong class="bold">Deploy</strong> stage contains a job <span class="No-Break">called </span><span class="No-Break"><strong class="bold">deploy-job</strong></span><span class="No-Break">.</span></p>
			<p>As you may <a id="_idIndexMarker286"/>have guessed from these job names, each job typically performs one task. For example, a job may compile all of your Java source code into classes. Another <a id="_idIndexMarker287"/>job may reset the data in a test database. Another job may push a Docker image to a registry. But in the same way that GitLab doesn’t validate that your stages contain thematically similar jobs, it also doesn’t validate that your jobs perform the task that the job’s name suggests. In other words, you could make a job called <em class="italic">compile-java</em> that deletes stray files generated by your automated tests, or a job called <em class="italic">deploy-to-production</em> that runs a security scanner. So, be careful to name your jobs carefully, and periodically review them to make sure the names are still accurate <span class="No-Break">and readable.</span></p>
			<p>Another thing that GitLab can’t validate is whether each job performs a single task. This means there’s nothing to prevent you from creating a job called <strong class="source-inline">test</strong> that runs nine different automated test suites, three performance tests, and five security scanners. Of course, that would violate the best practice of having each job perform only one task, so GitLab will let you create jobs that are as broad or narrow in scope as <span class="No-Break">you want.</span></p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor098"/>Commands</h2>
			<p>Let’s address <a id="_idIndexMarker288"/>a topic we’ve only danced around so far: how exactly <a id="_idIndexMarker289"/>does a job perform a task? The answer to this is the final building block in GitLab CI/CD pipelines: <strong class="bold">commands</strong>. Each job contains one or more commands that let the job <span class="No-Break"><em class="italic">do</em></span><span class="No-Break"> something.</span></p>
			<p>A command contained by a job is, well, the same thing as a command that a human may type into a terminal. It is just that: think of a job as a robot that types a command into a Linux bash shell, a macOS Zsh shell, or Windows PowerShell, just like a real person would. Here are some examples of commands that might be included in a GitLab CI/CD <span class="No-Break">pipeline job:</span></p>
			<ul>
				<li>The <strong class="source-inline">javac *.java</strong> command to compile <span class="No-Break">Java classes</span></li>
				<li>The <strong class="source-inline">docker build --tag my_app:1.2</strong> command to create a <span class="No-Break">Docker image</span></li>
				<li>The <strong class="source-inline">mvn test</strong> command to use the Maven build tool to trigger automated Java <span class="No-Break">unit tests</span></li>
			</ul>
			<p>Once again, these commands <a id="_idIndexMarker290"/>could be typed in by a person or by a GitLab CI/CD pipeline job; the result is the same. If a person used all of the same commands that <a id="_idIndexMarker291"/>are included in a pipeline’s jobs, you’d end up with an identical pipeline. The only difference is that the human-run pipeline would be much slower (and possibly <span class="No-Break">more error-prone).</span></p>
			<p>A job can contain as many commands as it needs to perform its task. For example, if a job is in charge of cleaning up an environment by deleting temporary files produced by tests, it may contain three <span class="No-Break">separate commands:</span></p>
			<ul>
				<li><strong class="source-inline">rm -</strong><span class="No-Break"><strong class="source-inline">f tmp/</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">rm *.tmp</strong></span></li>
				<li><strong class="source-inline">rm -</strong><span class="No-Break"><strong class="source-inline">f /tmp/test_files/</strong></span></li>
			</ul>
			<p>Instead, you could create three separate jobs called, perhaps, <strong class="source-inline">remove-files-1</strong>, <strong class="source-inline">remove-files-2</strong>, and <strong class="source-inline">remove-files-3</strong>, but since these are all closely related commands that you would always run together, most GitLab users would prefer to include all three commands in a <span class="No-Break">single job.</span></p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor099"/>Fitting the pipeline pieces together</h2>
			<p>Now that <a id="_idIndexMarker292"/>you’ve been introduced to stages, jobs, and commands, let’s review how they all <span class="No-Break">fit together:</span></p>
			<ul>
				<li>Each GitLab CI/CD <strong class="bold">pipeline</strong> consists of at least one <strong class="bold">stage</strong>. A stage represents a category of task that the pipeline <span class="No-Break">must perform.</span></li>
				<li>Each <strong class="bold">stage</strong> consists of at least one <strong class="bold">job</strong>. A job represents a single task that the pipeline <span class="No-Break">must perform.</span></li>
				<li>Each <strong class="bold">job</strong> consists of at least one <strong class="bold">command</strong>, where a command is exactly what a human would type into a shell to perform a <span class="No-Break">pipeline task.</span></li>
			</ul>
			<p>It’s probably obvious that different projects will likely define very different pipeline stages, jobs, and commands. But if you look at enough project pipelines, you’ll notice certain recurring patterns. As we’ve already mentioned, most pipelines contain at least the <strong class="bold">Build</strong>, <strong class="bold">Test</strong>, and <strong class="bold">Deploy</strong> stages, and the jobs within each of those stages are often pretty similar (at least for projects that use the same languages and build tools). While these core <a id="_idIndexMarker293"/>stages and jobs are fairly common, most non-trivial software projects will define plenty of jobs and sometimes stages that are unique to them. Other projects will have similar or identical needs but accomplish them either using different commands or the same commands organized into different jobs and/or stages. Seeing the variety of ways that teams set up their CI/CD pipelines is part of the fun of <span class="No-Break">using GitLab.</span></p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor100"/>Running GitLab CI/CD pipelines</h1>
			<p>Whenever a project’s pipeline runs, <em class="italic">it’s running on some version of that project’s files</em>. This means that in the CI portion of the pipeline, it runs automated tests and scans on just <a id="_idIndexMarker294"/>one version of your files. Then, in the CD portion, it deploys that same version of the files to the appropriate environment. You will also see this described as a pipeline running “against” a version of your <span class="No-Break">project’s files.</span></p>
			<p>The point of pipelines is to check the status of your code – and then deploy that code – every time you make changes to it. So, running a project’s pipeline on yesterday’s version of your code may produce one set of results, while running the pipeline against today’s version of the code may generate very different results, even though the pipeline consists of the same stages, jobs, and commands. Between yesterday and today, you may have added new automated tests, introduced new test failures by adding buggy product code, or added a dependency with security vulnerabilities. If any of those are the case, the two pipeline runs would produce different reports about the quality of <span class="No-Break">your code.</span></p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor101"/>Branch pipelines</h2>
			<p>The most <a id="_idIndexMarker295"/>common way to run a pipeline is to <em class="italic">commit a change to a branch</em>. Whenever <a id="_idIndexMarker296"/>you do that, GitLab automatically runs a pipeline against whatever version of your project’s files exist in that commit. In the list of pipeline instances, you’ll see an entry for that pipeline instance that shows (among other information) the branch name and the SHA of the most recent commit in the branch. Here’s <span class="No-Break">an example:</span></p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/Figure_4.5_B18073.jpg" alt="Figure 4.5 – Pipelines running against different branches, with different results  (branch names are highlighted)" width="997" height="297"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Pipelines running against different branches, with different results (branch names are highlighted)</p>
			<p>In this example, the most recent pipeline ran against the <strong class="bold">add-login-feature</strong> branch and the <a id="_idIndexMarker297"/>second most recent ran against the <strong class="bold">fix-password-bug</strong> branch. These <a id="_idIndexMarker298"/>branches may contain very different contents inside the same files, or one branch may contain new files that the other branch doesn’t have yet. That explains why the test stage failed in the pipeline that ran against <strong class="bold">add-login-feature</strong> but not in the pipeline that ran <span class="No-Break">against </span><span class="No-Break"><strong class="bold">fix-password-bug</strong></span><span class="No-Break">.</span></p>
			<p>GitLab also lets you manually run a pipeline against any Git branch you want, even if it wasn’t the last branch you committed to. Triggering a pipeline against an arbitrary branch is easy: visit the list of pipelines, click the <strong class="bold">Run pipeline</strong> button, select the branch you want the pipeline to run against, and click the next <strong class="bold">Run pipeline</strong> button, as shown in the following screenshot. In this example, we are about to run the pipeline against the <strong class="bold">add-login-feature</strong> branch, but if we were to expand the drop-down box with the branch’s name, you would see that it lists all the branches that exist in the GitLab-hosted copy of the <span class="No-Break">project’s repository:</span></p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/Figure_4.6_B18073.jpg" alt="Figure 4.6 – Manually running a pipeline against a specific branch (the branch’s name and trigger button are highlighted)" width="851" height="410"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – Manually running a pipeline against a specific branch (the branch’s name and trigger button are highlighted)</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor102"/>Git tag pipelines</h2>
			<p>Remember learning in <a href="B18073_02.xhtml#_idTextAnchor035"><span class="No-Break"><em class="italic">Chapter 2</em></span></a> that you can add a Git tag called <strong class="source-inline">version-3-1</strong> to the commit <a id="_idIndexMarker299"/>that you released to customers <a id="_idIndexMarker300"/>as version 3.1 of your product? GitLab also lets you run pipelines against arbitrary Git tags such as that one, even if the tag doesn’t point to the last commit on a branch. Just tell GitLab to run a pipeline against any tag using the same manual trigger process that you used to point a pipeline at a specific branch. The dropdown that lists available branches includes entries for all Git tags as well, as <span class="No-Break">shown here:</span></p>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/Figure_4.7_B18073.jpg" alt=" Figure 4.7 – Manually running a pipeline against a specific tag (the tag’s name is highlighted)" width="733" height="459"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> Figure 4.7 – Manually running a pipeline against a specific tag (the tag’s name is highlighted)</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor103"/>Other types of pipelines</h2>
			<p>You’ve just <a id="_idIndexMarker301"/>seen how to run pipelines against a branch or a Git tag. There are three other types of pipelines that you should be aware of, although they are used less frequently than the branch or <span class="No-Break">tag pipelines:</span></p>
			<ul>
				<li><strong class="bold">Merge request pipelines</strong> run against the source branch of a merge request, whenever <a id="_idIndexMarker302"/>commits are made to <span class="No-Break">that branch.</span></li>
				<li><strong class="bold">Merged result pipelines</strong> are special kinds of merge request pipelines. Merged <a id="_idIndexMarker303"/>result pipelines run against a <em class="italic">temporary merge</em> of a merge request’s source branch into its target branch, whenever commits are made to the source branch. Note that this kind of pipeline doesn’t <em class="italic">actually</em> merge the two branches; it just runs a pipeline against the collection of files that would have resulted if you <em class="italic">had</em> merged them. This is a great way to make extra sure that your branch will integrate well into your stable <span class="No-Break">code base.</span></li>
				<li><strong class="bold">Merge trains</strong> are a special kind of merged result pipeline. Merge trains queue up several <a id="_idIndexMarker304"/>merge requests and then perform separate, concurrent merged result pipelines on each merge request in the queue. But instead of performing a temporary merge of just the source and target branches of one merge request, the merge train performs a temporary merge of the source branches from <em class="italic">every merge request that’s ahead of the current merge request in the queue</em>. This is a good way to make sure that multiple branches will integrate well into a rapidly changing target branch when they <span class="No-Break">are merged.</span></li>
			</ul>
			<p>These alternative <a id="_idIndexMarker305"/>pipeline types aren’t used as often as the standard branch and tag pipelines. Because they are conceptually more difficult to understand, and because they require some extra configuration on your part, we’ll refer you to the official GitLab documentation to learn more about whether they might be useful for your projects, and if so, how to get <span class="No-Break">them running.</span></p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor104"/>Skipping pipelines</h2>
			<p>Even though GitLab’s CI/CD pipelines are amazing, powerful, and an enormous help to anyone <a id="_idIndexMarker306"/>who builds software, there are times when <a id="_idIndexMarker307"/>it makes more sense <em class="italic">not</em> to run a pipeline. The following are <span class="No-Break">some examples:</span></p>
			<ul>
				<li>Teams using the SaaS version of GitLab (that is, the instance hosted on <strong class="source-inline">gitlab.com</strong>) have a limited number of monthly minutes of compute time for running pipelines. If they are running low on minutes, they may want to run pipelines only on the most <span class="No-Break">important commits.</span></li>
				<li>If you make a trivial change that you know won’t affect any of the pipeline tests or scans, and you don’t need it deployed immediately, you may not need a pipeline for that commit. Examples of this situation include adding a comment to your code, lightly editing a README file, or fixing a tiny typo in the <span class="No-Break">GUI’s text.</span></li>
				<li>When you’re about to make several small commits to the same branch, and you consider all the commits to be low risk, you may want to wait until all the commits are submitted before running a pipeline against all of them. But this should be used sparingly: by increasing the scope of changes, you’re giving up some of the benefits of “shifting left” that <span class="No-Break">GitLab provides.</span></li>
			</ul>
			<p>Fortunately, it’s easy to prevent a commit from triggering a pipeline run. Just include one of these <a id="_idIndexMarker308"/>two phrases anywhere within a commit message, and GitLab <a id="_idIndexMarker309"/>will make the commit without running a pipeline <span class="No-Break">against it:</span></p>
			<ul>
				<li><strong class="source-inline">[</strong><span class="No-Break"><strong class="source-inline">skip ci]</strong></span></li>
				<li><strong class="source-inline">[</strong><span class="No-Break"><strong class="source-inline">ci skip]</strong></span></li>
			</ul>
			<p>This pipeline pause applies just to a single commit. The next time you commit to that branch without including one of the two skip messages, the pipeline will resume on the new commit (which, of course, will include any edits you made on the <span class="No-Break">pipeline-less commit).</span></p>
			<p>You’ve now seen how pipelines can run against Git branches or Git tags, and you’ve learned about other, more specialized, and less frequently used pipelines that run against temporarily merged branches. You also understand how pipelines can be triggered automatically when you commit edited files, or manually whenever you want to rerun your scans and checks against any version of your code. You even know how to tell GitLab to skip a pipeline for a particular commit, saving time and compute resources. You may not use all of these triggering techniques and pipeline variations in your work, but it’s good to know what options are available when special <span class="No-Break">needs arise.</span></p>
			<p>Of course, a pipeline doesn’t do you any good if you can’t find its results or don’t understand what it’s reporting. So, in the next section, we’ll investigate how to view and interpret the information that a completed <span class="No-Break">pipeline provides.</span></p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor105"/>Reading GitLab CI/CD pipeline statuses</h1>
			<p>Not only <a id="_idIndexMarker310"/>does each pipeline instance have a pass/fail status, but each stage within the pipeline instance has a pass/fail status, and each job within any stage has a pass/fail status as well. There are more statuses available than just <strong class="bold">passed</strong> or <strong class="bold">failed</strong>. Here are some of the most commonly <span class="No-Break">seen values:</span></p>
			<ul>
				<li><strong class="bold">running</strong>: The pipeline, stage, or job is <span class="No-Break">in progress.</span></li>
				<li><strong class="bold">pending</strong>: Waiting for resources to become available to start <span class="No-Break">a job.</span></li>
				<li><strong class="bold">skipped</strong>: When an earlier stage fails, all later stages are skipped <span class="No-Break">by default.</span></li>
				<li><strong class="bold">canceled</strong>: Users can cancel any job or pipeline while <span class="No-Break">it’s running.</span></li>
			</ul>
			<p>In <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.3</em>, you saw how the list of pipeline instances shows the status not only of each pipeline instance but also of the stages within each pipeline. In <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.4</em>, you saw how <a id="_idIndexMarker311"/>you can zoom in on an individual pipeline instance to see the status of all the jobs within each of the pipeline’s stages. GitLab lets you zoom in even further to see the output of the individual commands that are contained within a job, by clicking on one of the job icons shown in <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.4</em>. This view shows you what commands GitLab types into a shell while executing that job, and what output is generated by those commands. </p>
			<p>For example, the following screenshot shows the command and output for a job that runs a series of Python unit tests. You can see from the output that two tests passed and one failed. Normally, we’d add more logic to the job so that it uploads the unit test results, which would let GitLab display those results within its GUI. But for the sake of simplicity, this example omits <span class="No-Break">that step:</span></p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/Figure_4.8_B18073.jpg" alt="Figure 4.8 – Job for running Python unit tests (the job’s command and output are highlighted)" width="1101" height="580"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8 – Job for running Python unit tests (the job’s command and output are highlighted)</p>
			<p>There are several places within the GUI where GitLab displays the status of pipelines, stages, and jobs. Also, there are several different graphical representations of the project’s pipeline structure and the status of each element within the structure. These icons and diagrams are easy to spot as you navigate around GitLab, and most of them can either be hovered over or clicked on to reveal more information about <span class="No-Break">that element.</span></p>
			<p>So far in <a id="_idIndexMarker312"/>this chapter, we’ve covered what pipelines are, how they benefit software development teams, how they are structured, how to run them, and how to interpret their results. But you may have noticed that we haven’t explained how to create and configure them yet. That’s a big topic that much of the rest of this book is concerned with. However, we realize you might be getting antsy at this point: now that you know so much about pipelines, you’re probably itching to try them out in your <span class="No-Break">GitLab instance!</span></p>
			<p>Never fear. We’ve found that learning GitLab is easiest if you’re introduced to its features and components multiple times, in different contexts, and with different sets of background knowledge each time. With that in mind, this is a great opportunity to give you a lightning-fast introduction to setting up a simple CI/CD pipeline for Hats for Cats. We’ll go through the material quickly, but don’t worry – you’ll see these concepts again, repeatedly, in <span class="No-Break">future chapters.</span></p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor106"/>Configuring GitLab CI/CD pipelines</h1>
			<p>We’ve mentioned that you can configure your project’s CI/CD pipeline to define its stages, jobs, and commands. But how do you do that? All CI/CD pipeline configuration happens <a id="_idIndexMarker313"/>within a file called <strong class="source-inline">.gitlab-ci.yml</strong>, which lives <a id="_idIndexMarker314"/>in the root of your project’s repository. Look through any public GitLab project, and you’re sure to see a file with that name that determines what happens in that <span class="No-Break">project’s pipeline.</span></p>
			<p>Every <strong class="source-inline">.gitlab-ci.yml</strong> file uses a domain-specific language that consists of keywords, values, and some syntactical glue. Some keywords define stages and jobs within those stages. Other keywords configure jobs to do different things within the pipeline. Still, other keywords set variables, specify Docker images for jobs, or affect the overall pipeline in various ways. This domain-specific language is rich enough to let you do just about anything you’d like in your CI/CD pipelines, but not so rich as to be overwhelming (at least, once you’ve had some experience writing and reading these CI/CD <span class="No-Break">configuration files).</span></p>
			<p>There are about 30 keywords available to use in a <strong class="source-inline">.gitlab-ci.yml</strong> file. Rather than trying to memorize the details and configuration options available for each, we recommend <a id="_idIndexMarker315"/>that you concentrate on the big picture of what’s possible with CI/CD pipelines, and then learn the nuances of the relevant keywords as needed. The official GitLab documentation is the best source of information on these keywords, especially since they change from time <span class="No-Break">to time.</span></p>
			<p>We’ll spend much of the rest of this book demonstrating some of the key CI/CD pipeline tasks you can accomplish with these keywords, so this is a good time to dip your toe into the CI/CD pipeline configuration water by looking at a bare-bones <strong class="source-inline">.gitlab-ci.yml</strong> file. The contents of this file will drive an actual pipeline, albeit a simple one. Let’s walk through it, explaining each line as <span class="No-Break">we go.</span></p>
			<p>Since <strong class="source-inline">.gitlab-ci.yml</strong> files use the YAML format for structured data, this would be a good time to learn or review the extremely simple YAML syntax. The Wikipedia article on YAML is a good place to find that information. We’ll wait for you here until you feel confident <span class="No-Break">using YAML.</span></p>
			<p>Now that that’s out of the way, let’s get started. Most CI/CD configuration files begin by defining the pipeline’s stages. If you don’t define any stages, your pipeline will have <strong class="source-inline">build</strong>, <strong class="source-inline">test</strong>, and <strong class="source-inline">deploy</strong> stages by default. If you do define stages, these will replace – not augment – the three default stages. For this simple pipeline, we only need the <strong class="source-inline">build</strong> and <strong class="source-inline">test</strong> stages, so let’s define those explicitly in a new file called <strong class="source-inline">.gitlab-ci.yml</strong> at the root level of the <strong class="source-inline">hats-for-cats</strong> <span class="No-Break">project repository:</span></p>
			<pre class="source-code">
stages:  - build   - test</pre>
			<p>We’re going to have two jobs in this pipeline, with one job in each of the two stages we just defined. Let’s say that this project is Python-based, so both jobs will use Python-related tools. In the next chapter, we’ll explain more about how GitLab Runners can run jobs within Docker containers. For now, all you need to know is that we can specify a Docker image within our CI/CD configuration file for jobs to run within. In this case, both of our jobs will need access to Python tools, so we’ll tell the pipeline to use a Python Docker image for <span class="No-Break">all jobs:</span></p>
			<pre class="source-code">
image: python:3.10</pre>
			<p>Our first job will run <strong class="source-inline">mypy</strong>, which is a tool that makes sure Python source code uses the right data types in its functions and variables. This task could reasonably be put in either the <strong class="source-inline">build</strong> or <strong class="source-inline">test</strong> stage, but let’s put it in the <strong class="source-inline">build</strong> stage just so we can have at least one job in that stage. Here’s how we define <span class="No-Break">the job:</span></p>
			<pre class="source-code">
data-type-check:  stage: build   script:    - pip install mypy     - mypy src/hats-for-cats.py</pre>
			<p>Since the first <a id="_idIndexMarker316"/>word on the first line is not a keyword that GitLab recognizes, GitLab assumes it’s the name of a new job to be defined. This name can contain spaces instead of hyphens if you prefer, but sometimes, that can be harder to <span class="No-Break">parse visually.</span></p>
			<p>The next line assigns this job to the <strong class="source-inline">build</strong> stage. </p>
			<p>The third line starts with the <strong class="source-inline">script</strong> keyword, which tells GitLab that we’re about to list the commands for this job. And the following two lines do exactly that: the first runs a command to use the <strong class="source-inline">pip</strong> package manager to install the <strong class="source-inline">mypy</strong> package into the Python Docker container that the job is running in. The second command runs the <strong class="source-inline">mypy</strong> command that was just installed on any files that are in the <strong class="source-inline">src/</strong> directory. If <strong class="source-inline">mypy</strong> finds any problems with how our code uses data types, it will fail this job, which will fail the <strong class="source-inline">build</strong> stage that the job lives in, which, in turn, will fail the entire <span class="No-Break">pipeline instance.</span></p>
			<p>Now, let’s define a job for running automated <span class="No-Break">unit tests:</span></p>
			<pre class="source-code">
unit-tests:  stage: test   script:    - pip install pytest     - pytest test/ --junitxml=unit_test_results.xml   artifacts:    reports:      junit: unit_test_results.xml     when: always</pre>
			<p>Since the first line is not a recognized keyword, GitLab knows that this is the name of a new job that <span class="No-Break">we’re defining.</span></p>
			<p>The second line assigns the job to the <span class="No-Break"><strong class="source-inline">test</strong></span><span class="No-Break"> stage.</span></p>
			<p>Following the <strong class="source-inline">script</strong> keyword, we define two commands for the job. The first installs the <strong class="source-inline">pytest</strong> package, while the second runs the newly installed <strong class="source-inline">pytest</strong> tool on any unit tests that live in the <strong class="source-inline">test/</strong> directory. Furthermore, it specifies that <strong class="source-inline">pytest</strong> should output the results of the unit tests to a file called <strong class="source-inline">unit_test_results.xml</strong>, which will be in JUnit <span class="No-Break">XML format.</span></p>
			<p>The section <a id="_idIndexMarker317"/>that begins with the <strong class="source-inline">artifacts</strong> keyword allows GitLab to preserve the unit test results file when the job finishes, instead of throwing it away. In GitLab terminology, any files that are generated by a job and then preserved are called <strong class="bold">artifacts</strong>. <em class="italic">It’s important to understand that any files that were generated by a job but not declared to be artifacts are deleted as soon as the job finishes. </em></p>
			<p>The exact syntax that’s used in this example <strong class="source-inline">artifacts</strong> section isn’t too important because it can easily be looked up in the GitLab documentation when needed, but here, we are telling GitLab that this artifact contains unit test results in the JUnit XML format, which is an industry-standard format that GitLab requires to ingest and display the test results in the <strong class="bold">test</strong> tab on the pipeline <span class="No-Break">details page.</span></p>
			<p>The last line in the <strong class="source-inline">artifacts</strong> section tells GitLab to preserve the results file as an artifact, even if the <strong class="source-inline">unit-tests</strong> job fails. The job will have a <strong class="bold">failed</strong> status if there are any test failures, but we want to display the test results every time this job runs, even if (or especially if!) there are any <span class="No-Break">test failures.</span></p>
			<p>Combining all of the configuration code listed previously, the complete<strong class="source-inline">.gitlab-ci.yml</strong> file looks <span class="No-Break">like this:</span></p>
			<pre class="console">
stages:  - build   - test image: python:3.10 data-type-check:  stage: build   script:    - pip install mypy     - mypy src/hats-for-cats.py unit-tests:  stage: test   script:    - pip install pytest     - pytest test/ --junitxml=unit_test_results.xml   artifacts:    reports:      junit: unit_test_results.xml     when: always</pre>
			<p>The following <a id="_idIndexMarker318"/>screenshot shows the pipeline details page after this pipeline has finished. Don’t worry about the <strong class="bold">unit-tests</strong> job’s <strong class="bold">failed</strong> status. That’s expected whenever any of the tests that it <span class="No-Break">runs fail:</span></p>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/Figure_4.9_B18073.jpg" alt="Figure 4.9 – Details page for the completed pipeline that validates Python data types and runs unit tests" width="793" height="570"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9 – Details page for the completed pipeline that validates Python data types and runs unit tests</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor107"/>Summary</h1>
			<p>Now that you have a good grasp of the purpose and structure of GitLab CI/CD pipelines, let’s review the concepts we covered in <span class="No-Break">this chapter.</span></p>
			<p>Pipelines are a series of steps that are performed against code in your project’s Git repository. Each project has just one pipeline, although the various steps that make up a project’s pipeline can be run or suppressed, depending on which Git branch or Git tag the pipeline is running against. The term “pipeline” is sometimes used to mean the overall set of tasks that will be run on a project’s code, while other times, it’s used to mean a single instance or run of that pipeline against a particular version of the <span class="No-Break">repository’s files.</span></p>
			<p>The CI, or continuous integration, portion of a pipeline answers the question, <em class="italic">is the code good? </em>It typically consists of some combination of automated tests, security scans, license compliance checks, and code quality checks. The CI steps of a pipeline enable the <em class="italic">shift left</em> philosophy, which ensures that problems are found when they are still easy and cheap to fix. It also promotes collaboration among all members of the software <span class="No-Break">development team.</span></p>
			<p>The CD, or continuous delivery/deployment, portion of a pipeline, answers the question, <em class="italic">which environment should the code be deployed to?</em> It’s also responsible for actually deploying the code to that environment. The process of packaging up the code into a deployable format can be considered part of the CD portion pipeline as well. The CD steps of a pipeline promote frequent, predictable, low-risk feature and bugfix releases <span class="No-Break">to customers.</span></p>
			<p>Each project’s pipeline consists of one or more stages, where a stage is a collection of tasks that share a similar theme, such as building, testing, or deploying your code. Each stage consists of one or more jobs, where each job consists of a single unit of work, such as compiling Java classes, running automated unit tests, or packaging your application into a Docker image. Each job consists of one or more commands, which are shell commands that a human would type into a terminal if they were to manually perform the same work as a pipeline job. A pipeline ultimately consists of GitLab automatically typing in a series of terminal commands, recording the output of those jobs, and displaying the results to <span class="No-Break">the user.</span></p>
			<p>A pipeline typically runs every time you commit code to your repository, so you always have an up-to-date picture of the state of your code, whether it be on a feature branch, a bugfix branch, or the default branch. Pipelines can run against Git branches or Git tags and can be triggered automatically or manually. More exotic forms of pipelines are available, such as running a pipeline against the code that would result if you were to merge one branch <span class="No-Break">into another.</span></p>
			<p>Each pipeline instance has a pass/fail status (or one of several less-common statuses). Each stage within the pipeline also has a pass/fail status, as does each job within the stages. The status of any pipeline, stage, or job can be viewed within the <span class="No-Break">GitLab GUI.</span></p>
			<p>Pipelines can perform virtually any tasks that a human typing into a terminal could. Each project configures the tasks that make up its pipeline using a special domain-specific language in a file <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">.gitlab-ci.yml</strong></span><span class="No-Break">.</span></p>
			<p>Much of the rest of this book is dedicated to explaining what sorts of tasks you can configure a pipeline to perform, and what syntax and keywords you can use to do so. But first, we need to introduce you to the tool that performs the work of a pipeline, or that serves as the “robot” that types in the terminal commands defined in your CI/CD pipeline configuration file. In other words, it’s time to learn more about <span class="No-Break">GitLab Runners.</span></p>
		</div>
	</div>
</div>


<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer044" class="Content">
			<h1 id="_idParaDest-104"><a id="_idTextAnchor108"/>Part 2 Automating DevOps Stages with GitLab CI/CD Pipelines</h1>
		</div>
		<div id="_idContainer045">
			<p>This part is the core of the book: you will learn how to replace the most common manual steps in the software development life cycle with automated equivalents using GitLab CI/CD pipelines. By the end of this part, you will know how to set up your infrastructure to support pipelines. You will also feel confident about configuring pipelines to perform several critical tasks: verifying your code by running quality scans and functional tests, securing your code and its dependencies by running security scans, packaging your code by automatically running the standard build and packaging tools, and automatically deploying your code to the <span class="No-Break">appropriate environments.</span></p>
			<p>This section comprises the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><em class="italic"><a id="_idTextAnchor109"/></em><a href="B18073_05.xhtml#_idTextAnchor110"><em class="italic">Chapter 5</em></a>, <em class="italic">Installing and Configuring GitLab Runners</em></li>
				<li><a href="B18073_06.xhtml#_idTextAnchor133"><em class="italic">Chapter 6</em></a>, <em class="italic">Verifying Your Code</em></li>
				<li><a href="B18073_07.xhtml#_idTextAnchor162"><em class="italic">Chapter 7</em></a>, <em class="italic">Securing Your Code</em></li>
				<li><a href="B18073_08.xhtml#_idTextAnchor205"><em class="italic">Chapter 8</em></a>, <em class="italic">Packaging and Deploying Your Code</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer046">
			</div>
		</div>
		<div>
			<div id="_idContainer047">
			</div>
		</div>
	</div>
</div>
</body></html>