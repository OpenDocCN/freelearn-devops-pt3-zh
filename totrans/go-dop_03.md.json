["```\ntype error interface {\n     Error() string\n}\n```", "```\nerr := errors.New(\"this is an error\")\nerr := fmt.Errorf(\"user %s had an error: %s\", user, msg)\n```", "```\nfunc Divide(num int, div int) (int, error) {\n\tif div == 0 {\n\t\t// We return the zero value of int (0) and an error.\n\t\treturn 0, errors.New(\"cannot divide by 0\")\n\t}\n\treturn num / div, nil\n}\nfunc main() {\n\tdivideBy := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}\n\tfor _, div := range divideBy {\n\t\tres, err := Divide(100, div)\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"100 by %d error: %s\\n\", div, err)\n\t\t\tcontinue\n\t\t}\n\t\tfmt.Printf(\"100 divided by %d = %d\\n\", div, res)\n\t}\n}\n```", "```\nvar (\n     ErrNetwork = errors.New(\"network error\")\n     ErrInput = errors.New(\"input error\")\n)\n```", "```\n// The loop is for retrying if we have an ErrNetwork.\nfor {\n     err := someFunc(\"data\")\n     if err == nil {\n          // Success so exit the loop\n          break\n     }\n     if errors.Is(err, ErrNetwork) {\n          log.Println(\"recoverable network error\")\n          time.Sleep(1 * time.Second)\n          continue\n     }\n     log.Println(\"unrecoverable error\")\n     break // exit loop, as retrying is useless\n}\n```", "```\nconst (\n     UnknownCode = 0\n     UnreachableCode = 1\n     AuthFailureCode = 2\n)\ntype ErrNetwork struct {\n     Code int\n     Msg string\n}\nfunc (e ErrNetwork) Error() string { \n    return fmt.Sprintf(\"network error(%d): %s\", e.Code, e.msg)\n} \n```", "```\nreturn ErrNetwork{\n     Code: AuthFailureCode, \n     Msg: \"user unrecognized\",\n}\n```", "```\nvar netErr ErrNetwork\nif errors.As(err, &netErr) {\n     if netErr.Code == AuthFailureCode {\n          log.Println(\"unrecoverable auth failure: \", err)\n          break\n     }\n     log.Println(\"recoverable error: %s\", netErr)\n}\nlog.Println(\"unrecoverable error: %s\", err)\nbreak\n```", "```\nfunc restCall(data) error {\n     if err := someFunc(data); err != nil {\n          return fmt.Errorf(\"restCall(%s) had an error: %w\", data, err)\n     }\n     return nil\n}\n```", "```\nfor {\n     if err := restCall(data); err != nil {\n          var netErr ErrNetwork\n          if errors.As(err, &netErr) {\n               log.Println(\"network error: \", err)\n               time.Sleep(1 * time.Second)\n               continue\n          }\n          log.Println(\"unrecoverable: \", err)\n     }\n}\n```", "```\nconst str = \"hello world\"\nconst num = 3\nconst num64 int64 = 3\n```", "```\nfunc add(x, y int8) int8 {\n     return x + y\n}\nfunc main() {\n     fmt.Println(add(num, num))  // Print: 6\n}\n```", "```\ntype specialStr string\nfunc printSpecial(str specialStr)\n     fmt.Println(string(str))\n}\nfunc main() { \n    const constHelloWorld = \"hello world\" \n    var varHelloWorld = \"hello world\" \n    printSpecial(varHelloWorld) // Won't compile \n    printSpecial(constHelloWorld) // Will compile \n    printSpecial(\"hello world\") // Will compile \n} \n```", "```\n./prog.go:18:14: cannot use varHelloWorld (type string) as type specialStr in argument to printSpecial\n```", "```\nconst (\n     a = iota // 0\n     b = iota // 1\n     d = iota // 2\n)\n```", "```\nconst (\n     a = iota *2 // 0\n     b // 2\n     d // 4\n)\n```", "```\nconst (\n     a = iota // 0\n     b        // 1\n     c        // 2\n     d        // 3\n)\n```", "```\n//go:generate stringer -type=Pill\ntype Pill int\nconst (\n    Placebo Pill = iota\n    Aspirin\n    Ibuprofen\n    Paracetamol\n    Acetaminophen = Paracetamol\n)\n```", "```\nfunc printStuff() (value string) {\n     defer fmt.Println(\"exiting\")\n     defer func() {\n          value = \"we returned this\"\n     }()\n     fmt.Println(\"I am printing stuff\")\n     return \"\"\n}\nfunc main() {\n     v := printStuff()\n     fmt.Println(v)\n}\n```", "```\nI am printing stuff\nexiting\nwe returned this\n```", "```\npanic(\"ran into some bug\")\n```", "```\nfunc someFunc() {\n     defer func() {\n        if r := recover(); r != nil {\n            log.Printf(\"called recover, panic was: %q\", r)\n        }\n    }()\n    panic(\"oh no!!!\")\n}\n```", "```\nfor i := 0; i < 10; i++ {     \n     go fmt.Println(x) // This happens concurrently\n}\nfmt.Println(\"hello\")\n// This is used to prevent the program from exiting\n// before our goroutines above run. We will talk about\n// this later in the chapter.\nselect{} \n```", "```\nHello\n2\n0\n5\n3\n...\nfatal error: all goroutines are asleep - deadlock!\n```", "```\nfunc main() {\n     wg := sync.WaitGroup{}\n     for i := 0; i < 10; i++ {\n          wg.Add(1)\n          go func(n int) {\n               defer wg.Done()\n               fmt.Println(n)\n          }(i)\n     }\n     wg.Wait()\n     fmt.Println(\"All work done\")\n}\n```", "```\nch := make(chan string, 1)\n```", "```\nfor val := range ch { // Acts like a <-ch\n     fmt.Println(val)\n}\n```", "```\nfunc main() { \n    ch := make(chan string, 1) \n    go func() { \n        for _, word := range []string{\"hello\", \"world\"} { \n            ch <- word\n            close(ch) \n        } \n    }() \n    for word := range ch { \n        fmt.Println(word) \n    } \n} \n```", "```\nfor {\n     select {\n     case v := <-inCh1:\n          go fmt.Println(\"received(inCh1): \", v)\n     case v := <-inCh2:\n          go fmt.Println(\"received(inCh2): \", v)\n     }\n}\n```", "```\nselect {\ncase s := <-ch:\n     fmt.Printf(\"had a string(%s) on the channel\\n\", s)\ndefault:\n     fmt.Println(\"channel was empty\")\n}\n```", "```\nfunc printWords(in1, in2 chan string, exit chan struct{}, wg *sync.WaitGroup) {\n     defer wg.Done()\n     for {\n          select{\n          case <-exit:\n               fmt.Println(\"exiting\")\n               return\n          case str := <-in1:\n               fmt.Println(\"in1: \", str)\n          case str := <-in2:\n               fmt.Println(\"in2: \", str)\n          }\n     }\n}\n```", "```\nfunc main() { \n    in1 := make(chan string) \n    in2 := make(chan string) \n    wg := &sync.WaitGroup{} \n    exit := make(chan struct{}) \n    wg.Add(1) \n    go printWords(in1, in2, exit, wg) \n    in1 <- \"hello\" \n    in2 <- \"world\" \n    close(exit) \n\n    wg.Wait() \n} \n```", "```\nin1:  hello\nin2:  world\nexiting\n```", "```\ntype sum struct {\n     mu  sync.Mutex\n     sum int\n}\nfunc (s *sum) get() int {\n     s.mu.Lock()\n     defer s.mu.Unlock()\n     return s.sum\n}\nfunc (s *sum) add(n int) {\n     s.mu.Lock()\n     defer s.mu.Unlock()\n     s.sum += n\n}\nfunc main() {\n     mySum := &sum{}\n     wg := sync.WaitGroup{}\n     for i := 0; i < 100; i++ {\n          wg.Add(1)\n          go func(x int) {\n               defer wg.Done()\n               mySum.add(x)\n          }(i)\n     }\n     wg.Wait()\n     fmt.Println(\"final sum: \", mySum.get())\n}\n```", "```\nimport \"context\" \nfunc main() { \n     ctx := context.Background()\n}\n```", "```\nctx, cancel := context.WithTimeout(context.Background(), 5 * time.Second)\ndata, err := GatherData(ctx, args)\ncancel()\nif err != nil {\n     return err\n}\n```", "```\nfunc GatherData(ctx context.Context, args Args) ([]file, error) { \n    if ctx.Err() != nil { \n        return nil, err \n    } \n    localCtx, localCancel := context.WithTimeout(ctx, 2 * time.Second) \n    local, err := getFilesLocal(localCtx, args.local) \n    localCancel() \n    if err != nil { \n        return nil, err \n    } \n    remoteCtx, remoteCancel := context.WithTimeout(ctx, 3 * time.Second) \n    remote, err := getFilesRemote(remoteCtx, args.remote) \n    remoteCancel() \n    if err != nil { \n        return nil, err \n    } \n    return append(local, remote), nil \n} \n```", "```\nselect {\ncase <-ctx.Done():\n     return ctx.Err()\ncase data := <-ch:\n     return date, nil\n}\n```", "```\nclient := &http.Client{}\nreq, err := http.NewRequest(\"GET\", \"http://www.golang.org\", nil)\nif err != nil {\n        fmt.Println(\"error: \", err)\n        return\n}\nctx, cancel := context.WithTimeout(context.Background(), 3 * time.Second)\n// Attach it to our request.\nreq = req.WithContext(ctx)\n// Get our resp.\nresp, err := client.Do(req)\ncancel() \nif err != nil {\n        fmt.Println(\"error: \", err)\n        return\n}\n// Print the page to stdout\nio.Copy(os.Stdout, resp.Body)\n```", "```\ntype key int\nconst claimsKey key = 0 \nfunc NewContext(ctx context.Context, claims Claims)\ncontext.Context {\n    return context.WithValue(ctx, claimsKey, claims)\n}\nfunc ClaimsFromContext(ctx context.Context) (Claims, bool) \n{\n    // ctx.Value returns nil if ctx has no value for the key;\n    // the Claims type assertion returns ok=false for nil.\n    claims, ok := ctx.Value(userIPKey).(Claims)\n    return claims, ok\n}\n```", "```\nfunc TestFuncName(t *testing.T) {\n}\n```", "```\npackage greetings \nimport ( \n\"testing\" \n)\nfunc TestGreet(t *testing.T) { \n     name := \"Bob\"\n     want := \"Hello Bob\"\n     got, err := Greet(name)\n     if got != want || err != nil {\n          t.Fatalf(\"TestGreet(%s): got %q/%v, want %q/nil\", name, got, err, want)\n     }\n}\n```", "```\n=== RUN   TestGreet\n--- PASS: TestGreet (0.00s)\nPASS\n```", "```\n=== RUN   TestGreet\n    prog.go:21: TestGreet(Bob): got \"Hello Bob\"/<nil>, want \"Hello Sarah\"/nil\n--- FAIL: TestGreet (0.00s)\nFAIL\n```", "```\nfunc TestGreet(t *testing.T) {\n     tests := []struct{\n          desc string // What we are testing\n          name string // The name we will pass\n          want string // What we expect to be returned\n          expectErr bool // Do we expect an error\n     }{\n          {\n               desc: \"Error: name is an empty string\",\n               expectErr: true,\n               // name and want are \"\", the zero value for string\n          },\n          {\n               desc: \"Success\",\n               name: \"John\",\n               want: \"Hello John\",\n               // expectErr is set to the zero value, false\n          },\n     }\n     // Executes each test.\n     for _, test := range tests {\n          got, err := Greet(test.name)\n          switch {\n          // We did not get an error, but expected one\n          case err == nil && test.expectErr:\n               t.Errorf(\"TestGreet(%s): got err == nil, want err != nil\", test.desc)\n               continue\n          // We got an error but did not expect one\n          case err != nil && !test.expectErr:\n               t.Errorf(\"TestGreet(%s): got err == %s, want err == nil\", test.desc, err)\n               continue\n          // We got an error we expected, so just go to the next test\n          case err != nil:\n               continue\n          }\n          // We did not get the result we expected\n          if got != test.want {\n               t.Errorf(\"TestGreet(%s): got result %q, want %q\", test.desc, got, test.want)\n          }\n     }\n}\n```", "```\ntype Fetch struct{\n     // Some internals, like an http.Client\n}\nfunc (f *Fetch) Record(name string) (Record, error){\n     // Some code to talk to the server\n}\n```", "```\nfunc Greeter(name string, fetch *client.Fetch) (string, error) { \n    rec, err := fetch.Record(name) \n    if err != nil { \n        return \"\", err \n    } \n    if rec.Name != name {\n          return \"\", fmt.Errorf(\"server returned record for %s, not %s\", rec.Name, name)\n     }\n     if rec.Age < 18 {\n          return \"Greetings young one\", nil\n     }\n     return fmt.Sprintf(\"Greetings %s\", name), nil\n}\n```", "```\ntype recorder interface {\n     Record(name string) (Record, error)\n}\nfunc Greeter(name string, fetch recorder) (string, error) {\n```", "```\ntype fakeRecorder struct {\n     data Record\n     err bool\n}\nfunc (f fakeRecorder) Record(name string) (Record, error) {\n     if f.err  {\n          return \"\", errors.New(\"error\")\n     }\n     return f.data, nil\n}\n```", "```\nfunc TestGreeter(t *testing.T) {\n     tests := []struct{\n          desc string\n          name string\n          recorder recorder\n          want string\n          expectErr bool\n     }{\n          {\n               desc: \"Error: recorder had some server error\",\n               name: \"John\",\n               recorder: fakeRecorder{err: true},\n               expectErr: true,\n          },\n          {\n               desc: \"Error: server returned wrong name\",\n               name: \"John\",\n               recorder: fakeRecorder{\n                    Record: Record{Name: \"Bob\", Age: 20},\n               },\n               expectErr: true,\n          },\n          {\n               desc: \"Success\",\n               name: \"John\",\n               recorder: fakeRecorder{\n                    Record: Record{Name: \"John\", Age: 20},\n               },\n               want: \"Greetings John\",\n          },\n     }\n     for _, test := range tests {\n          got, err := Greeter(test.name)\n          switch {\n          case err == nil && test.expectErr:\n               t.Errorf(\"TestGreet(%s): got err == nil, want err != nil\", test.desc)\n               continue\n          case err != nil && !test.expectErr:\n               t.Errorf(\"TestGreet(%s): got err == %s, want err == nil\", test.desc, err)\n               continue\n          case err != nil:\n               continue\n          }\n          if got != test.want {\n               t.Errorf(\"TestGreet(%s): got result %q, want %q\", test.desc, got, want)\n          }\n     }\n}\n```", "```\nif diff := pretty.Compare(want, got); diff != \"\" {\n     t.Errorf(\"TestSomeFunc(%s): -want/+got:\\n%s\", diff)\n}\n```", "```\nfunc sortInts[I int8 |int16 |int32 |int64](slice []I) {\n```", "```\nfunc sortInts[I int8 |int16 |int32 |int64](slice []I) {\n     sorted := false\n     for !sorted {\n          sorted = true\n          for i := range slice[:len(slice)-1] {\n               if slice[i] > slice[i+1] {\n                    sorted = false\n                    slice[i], slice[i+1] = slice[i+1], slice[i]\n               }\n          }\n     }\n}\n```", "```\ntype SignedInt interface {\n     int8 |int16 |int32 |int64\n}\n```", "```\nfunc sortInts[I SignedInt](slice []I) {\n```", "```\nfunc sortInts[I SignedInt](slice[]SignedInt) {\n```", "```\ntype myInt8 int8\n```", "```\ntype SignedInt interface {\n     ~int8 |~int16 |~int32 |~int64\n}\n```", "```\ntype Ordered interface {\n     ~int | ~int8 | ~int16 | ~int32 | ~int64 |\n          ~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr |\n          ~float32 | ~float64 |\n          ~string\n}\n```", "```\nfunc sortSlice[O constraints.Ordered](slice[]O) {\n```", "```\nfunc ExtractMapKeys[K comparable, V any](m map[K]V) []K {\n    var keys = make([]K, 0, len(m))\n    for k := range m {\n        keys = append(keys, k)\n    }\n    return keys\n}\n```", "```\ntype StringPrinter interface {\n     ~string\n     Print()\n}\n```", "```\nfunc PrintStrings[S StringPrinter](slice []S) {\n     for _, s := range slice {\n          s.Print()\n     }\n}\n```", "```\ntype Record struct {\n     First, Last string\n}\n```", "```\ntype Interface interface {\n     Len() int\n     Less(i, j int) bool\n     Swap(i, j int)\n}\n```", "```\ntype intAdapter struct {\n     sl []int\n}\nfunc (in intAdapter) Len() int {\n     return len(in.sl)\n}\nfunc (in intAdapter) Swap(i, j int) {\n     in.sl[i], in.sl[j] = in.sl[j], in.sl[i]\n}\nfunc (in intAdapter) Less(i, j int) bool {\n     return in.sl[i] < in.sl[j]\n}\n```", "```\nints := []int{5, 3, 7, 1}\nsort.Sort(intAdapter{ints})\n```", "```\ntype sortableSlice[T any] struct { \n    slice []T \n    less func(T, T) bool \n}\nfunc (s sortableSlice[T]) Len() int { \n    return len(s.slice) \n}\nfunc (s sortableSlice[T]) Swap(i, j int) { \n    s.slice[i], s.slice[j] = s.slice[j], s.slice[i] \n}\nfunc (s sortableSlice[T]) Less(i, j int) bool { \n    return s.less(s.slice[i], s.slice[j]) \n} \n```", "```\nfunc recordLess(a, b Record) bool {\n     aCmp := a.Last + a.First\n     bCmp := b.Last + b.First\n     return aCmp < bCmp\n}\n```", "```\nfunc SortSlice[T any](slice []T, less func(T, T) bool) {\n     sort.Sort(sortableSlice[T]{slice: slice, less: less})\n}\n```", "```\ncannot use generic type sortableSlice[T any] without instantiation\n```", "```\nfunc orderedCmp[O constraints.Ordered](a O, b O) bool {\n     return a < b\n}\n```", "```\nstrings := []string{\"hello\", \"I\", \"must\", \"be\", \"going\"}\nSortSlice(strings, orderedCmp)\n```", "```\ncannot use generic function orderedCmp without instantiation\n```", "```\nSortSlice(strings, orderedCmp[string])\n```", "```\nSortSlice[string](strings, orderedCmp[string])\n```", "```\ntype Values interface {\n     int8 | int16 | int32 |int64\n     string | []byte\n}\nfunc Print[V Values](v V) {\n     fmt.Println(v)\n}\nfunc main() {\n     Print[string](\"hello\")\n}\n```", "```\ncannot implement Values (empty type set)\n```", "```\ntype ValueType interface {\n     string | bool | int\n}\ntype Value[T ValueType] struct {\n     val T\n}\nfunc New[T ValueType](v T) Value { \n     return Value[T]{val: v}\n}\nfunc (v Value[T]) Value() T {\n     return v.val\n}\n```", "```\ncannot use generic type Value[T ValueType] without instantiation\n```", "```\nfunc New[T ValueType](v T) Value[T] {\n```"]