<html><head></head><body>
		<div id="_idContainer201">
			<h1 id="_idParaDest-296"><em class="italic"><a id="_idTextAnchor296"/>Chapter 14</em>: Securing Your Code</h1>
			<p>In 2016, a dispute about the name <em class="italic">Kik</em> between the<a id="_idIndexMarker927"/> messenger service Kik (<a href="https://www.kik.com/">https://www.kik.com/</a>) and open source contributor <em class="italic">Azer Koçulu</em>, who maintained a project with the same name, led to a complete outage of the internet. At least everybody noticed that day that something was wrong. What happened? Because of the dispute and npm siding with the messenger service, Azer retracted all his packages from the npm registry. Among the packages was a package called <strong class="source-inline">left-pad</strong>. Its purpose was to add characters to the beginning of a string of text. <strong class="source-inline">left-pad</strong> was a simple module with only 11 lines of code:</p>
			<pre class="source-code">module.exports = leftpad;</pre>
			<pre class="source-code">function leftpad (str, len, ch) {</pre>
			<pre class="source-code">  str = String(str);</pre>
			<pre class="source-code">  var i = -1;</pre>
			<pre class="source-code">  if (!ch &amp;&amp; ch !== 0) ch = ' ';</pre>
			<pre class="source-code">  len = len - str.length;</pre>
			<pre class="source-code">  while (++i &lt; len) {</pre>
			<pre class="source-code">    str = ch + str;</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">  return str;</pre>
			<pre class="source-code">}</pre>
			<p>This is a simple, single-purpose function that every developer should be able to write on their own. And yet the package made it into globally used frameworks such as <em class="italic">React</em>. React<a id="_idIndexMarker928"/> didn't require these 11 lines of code directly, of course. But it depended on packages that depend on other packages – and one package in this tree depended on <strong class="source-inline">left-pad</strong>. And that package missing basically broke the internet (see <em class="italic">Keith Collins 2016</em> and <em class="italic">Tyler Eon 2016</em>).</p>
			<p>Software today depends on a lot of different software – tools, packages, frameworks, compilers, and languages – and each of these has its own dependency tree. It's important to ensure security and license compliance not just for your code but for your entire software supply chain.</p>
			<p>In this chapter, you'll learn how GitHub Actions and Advanced Security can help you to eliminate bugs and security issues in your code and successfully manage your software supply chain.</p>
			<p>The key topics in this chapter are as follows:</p>
			<ul>
				<li>Dependency management and Dependabot</li>
				<li>Secret scanning</li>
				<li>Code scanning</li>
				<li>Writing your own CodeQL queries<p class="callout-heading">GitHub Advanced Security</p><p class="callout">Many features discussed in this chapter are only available for GitHub Enterprise if you acquire the <strong class="bold">Advanced Security License</strong>. Some of them are free for open source – but if some are not available in your organization, then you probably have not acquired the corresponding license.</p></li>
			</ul>
			<h1 id="_idParaDest-297"><a id="_idTextAnchor297"/>Dependency management and Dependabot</h1>
			<p>To<a id="_idIndexMarker929"/> manage <a id="_idIndexMarker930"/>your dependencies, you can use <strong class="bold">Software Composition Analysis</strong> (<strong class="bold">SCA</strong>) tools. GitHub offers <strong class="bold">Dependency graphs</strong>, <strong class="bold">Dependabot alerts</strong>, and <strong class="bold">Dependabot security updates</strong> to <a id="_idIndexMarker931"/>manage your<a id="_idIndexMarker932"/> software dependencies.</p>
			<p><strong class="bold">Dependency graph</strong> helps<a id="_idIndexMarker933"/> you to understand your dependency tree. <strong class="bold">Dependabot alerts</strong> check <a id="_idIndexMarker934"/>your dependencies for known vulnerabilities and alert you in case Dependabot finds any. If you <a id="_idIndexMarker935"/>enable <strong class="bold">Dependabot security updates</strong>, Dependabot will automatically create pull requests that update your dependencies if the author of the dependent package releases a fix for a vulnerability.</p>
			<p>The dependency graph<a id="_idIndexMarker936"/> is enabled by default for public repositories but not for private<a id="_idIndexMarker937"/> ones. Dependabot alerts and updates must be enabled for all <a id="_idIndexMarker938"/>repositories. You can do this under <strong class="bold">Settings</strong> | <strong class="bold">Security &amp; Analysis</strong> (see <em class="italic">Figure 14.1</em>):</p>
			<div>
				<div id="_idContainer172" class="IMG---Figure">
					<img src="image/B17827_14_001.jpg" alt="Figure 14.1 – Enable the dependency graph and Dependabot&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.1 – Enable the dependency graph and Dependabot</p>
			<p>On the organizational level, you can enable these options for all repositories and make them the default for new repositories.</p>
			<h2 id="_idParaDest-298"><a id="_idTextAnchor298"/>Exploring your dependencies</h2>
			<p>If you enable <a id="_idIndexMarker939"/>the dependency graph, it will start looking for dependencies. The following package ecosystems are supported (see <em class="italic">Table 14.1</em>):</p>
			<div>
				<div id="_idContainer173" class="IMG---Figure">
					<img src="image/B17827_table_14.1.jpg" alt="Table 14.1 – Supported formats for the dependency graph and Dependabot&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 14.1 – Supported formats for the dependency graph and Dependabot</p>
			<p>To explore your <a id="_idIndexMarker940"/>dependencies, you can navigate to <strong class="bold">Insights</strong> | <strong class="bold">Dependency graph</strong>. On the <strong class="bold">Dependencies</strong> tab, you can find all the dependencies for the manifest files that were found in your repository. You can open the dependencies for each dependency and navigate the tree. If the dependency has a known vulnerability, you can see it on the right side. The vulnerability has an assigned severity and <a id="_idIndexMarker941"/>a <strong class="bold">Common Vulnerabilities and Exposures</strong> (<strong class="bold">CVE</strong>) identifier. With this identifier, you can look up the details for the vulnerability in<a id="_idIndexMarker942"/> the <strong class="bold">National Vulnerability Database</strong> (<a href="http://nvd.nist.gov">nvd.nist.gov</a>). Click on the link, and it will direct you to the entry in the database (<a href="https://nvd.nist.gov/vuln/detail/CVE-2021-3749">https://nvd.nist.gov/vuln/detail/CVE-2021-3749</a>) or to <a id="_idIndexMarker943"/>the <strong class="bold">GitHub Advisory Database</strong> (<a href="https://github.com/advisories">https://github.com/advisories</a>). If there is a fix for the vulnerability, the dependency graph suggests the version you should upgrade the dependency to (see <em class="italic">Figure 14.2</em>):</p>
			<p class="figure-caption">`</p>
			<div>
				<div id="_idContainer174" class="IMG---Figure">
					<img src="image/B17827_14_002.jpg" alt="Figure 14.2 – Exploring your dependencies with the dependency graph&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.2 – Exploring your dependencies with the dependency graph</p>
			<p>On <a id="_idIndexMarker944"/>the <em class="italic">organization level</em>, under <strong class="bold">Insights</strong> | <strong class="bold">Dependencies</strong>, you can find all dependencies from all repositories that have turned on the dependency graph. In addition to the repository insights, you can find all the used licenses here. This can help you to check the license compliance of your products (see <em class="italic">Figure 14.3</em>):</p>
			<div>
				<div id="_idContainer175" class="IMG---Figure">
					<img src="image/B17827_14_003.jpg" alt="Figure 14.3 – Dependency insights on the organization level&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.3 – Dependency insights on the organization level</p>
			<p>If you <a id="_idIndexMarker945"/>want to leverage GitHub to inform others that depend on your packages, you can draft a<a id="_idIndexMarker946"/> new <strong class="bold">security advisory</strong> under <strong class="bold">Security</strong> | <strong class="bold">Security Advisories</strong> | <strong class="bold">New draft security advisory</strong>. The security advisor contains a title, description, the ecosystem, the package name, the affected versions (that is, &lt; 1.2.3), the patched versions (1.2.3), and the severity. You can optionally add<a id="_idIndexMarker947"/> multiple <strong class="bold">Common Weakness Enumerators</strong> (<strong class="bold">CWEs</strong>) (see <a href="https://cwe.mitre.org/">https://cwe.mitre.org/</a>). If you already have a CVE ID, you can add it here; if not, you can select to add it later.</p>
			<p>The draft is only visible to repository owners until it is published. Once published, security advisories on <a id="_idIndexMarker948"/>public repositories are visible to everyone and are added to the <strong class="bold">GitHub Advisory Database</strong> (<a href="https://github.com/advisories">https://github.com/advisories</a>). For private repositories, they are only visible to everyone that has access to the repository, and they do not get added to the advisory database until you request an official CVE identifier.</p>
			<h2 id="_idParaDest-299"><a id="_idTextAnchor299"/>Dependabot</h2>
			<p><strong class="bold">Dependabot</strong> is a<a id="_idIndexMarker949"/> bot in GitHub that can check your dependencies for known vulnerabilities. It can also automatically create pull requests to keep your dependencies up to date.</p>
			<p>Dependabot <a id="_idIndexMarker950"/>supports npm, GitHub Actions, Docker, git submodules, .NET (NuGet), pip, Terraform, Bundler, Maven, and many other ecosystems. For a complete list, see <a href="https://docs.github.com/en/code-security/supply-chain-security/keeping-your-dependencies-updated-automatically/about-dependabot-version-updates#supported-repositories-and-ecosystems">https://docs.github.com/en/code-security/supply-chain-security/keeping-your-dependencies-updated-automatically/about-dependabot-version-updates#supported-repositories-and-ecosystems</a>.</p>
			<p>To enable<a id="_idIndexMarker951"/> Dependabot, create a <strong class="source-inline">dependabot.yml</strong> file in the <strong class="source-inline">.github</strong> directory. You select the package ecosystem and the directory that contains the package file (that is, the <strong class="source-inline">package.json</strong> file). You have to specify whether Dependabot should check for updates <strong class="source-inline">daily</strong>, <strong class="source-inline">weekly</strong>, or <strong class="source-inline">monthly</strong>:</p>
			<pre class="source-code">version: 2</pre>
			<pre class="source-code">updates:</pre>
			<pre class="source-code">  - package-ecosystem: "<strong class="bold">npm</strong>"</pre>
			<pre class="source-code">    directory: "<strong class="bold">/</strong>"</pre>
			<pre class="source-code">    schedule:</pre>
			<pre class="source-code">      interval: "<strong class="bold">daily</strong>"</pre>
			<p>You can <a id="_idIndexMarker952"/>authenticate to private registries using <strong class="bold">Dependabot secrets</strong>. Add a <a id="_idIndexMarker953"/>new secret under <strong class="bold">Settings</strong> | <strong class="bold">Secrets</strong> | <strong class="bold">Dependabot</strong> (see Figure 14.4<strong class="bold">)</strong>:</p>
			<div>
				<div id="_idContainer176" class="IMG---Figure">
					<img src="image/B17827_14_004.jpg" alt="Figure 14.4 – Adding a Dependabot secret&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.4 – Adding a Dependabot secret</p>
			<p>Then, add the registry to the <strong class="source-inline">dependabot.yml</strong> file and access the secret from the <strong class="source-inline">secret</strong> context:</p>
			<pre class="source-code">version: 2</pre>
			<pre class="source-code">registries:</pre>
			<pre class="source-code">  <strong class="bold">my-npm-pkg</strong>:</pre>
			<pre class="source-code">    type: npm-registry</pre>
			<pre class="source-code">    url: https://npm.pkg.github.com</pre>
			<pre class="source-code">    token: ${{<strong class="bold">secrets.PAT</strong>}}</pre>
			<pre class="source-code">updates:</pre>
			<pre class="source-code">  - package-ecosystem: "npm"</pre>
			<pre class="source-code">    directory: "/"</pre>
			<pre class="source-code">    registries: </pre>
			<pre class="source-code">      - <strong class="bold">my-npm-pkg</strong></pre>
			<pre class="source-code">    schedule:</pre>
			<pre class="source-code">      interval: "daily"</pre>
			<p>There are many more options to configure <a id="_idIndexMarker954"/>Dependabot – you can allow or deny certain packages, apply metadata to pull requests (such as labels, milestones, and reviewers), customize the commit message, or you can change the merge strategy. For a complete list of options, see <a href="https://docs.github.com/en/code-security/supply-chain-security/keeping-your-dependencies-updated-automatically/configuration-options-for-dependency-updates">https://docs.github.com/en/code-security/supply-chain-security/keeping-your-dependencies-updated-automatically/configuration-options-for-dependency-updates</a>.</p>
			<p>You can check the status of Dependabot <a id="_idIndexMarker955"/>updates under <strong class="bold">Insights</strong> | <strong class="bold">Dependency graph</strong> | <strong class="bold">Dependabot</strong>. Each update entry has a row with a status and warning icons if something is wrong. Click the status to see the complete log (see <em class="italic">Figure 14.5</em>):</p>
			<div>
				<div id="_idContainer177" class="IMG---Figure">
					<img src="image/B17827_14_005.jpg" alt="Figure 14.5 – Viewing Dependabot status and log files&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.5 – Viewing Dependabot status and log files</p>
			<p>You can find all the <a id="_idIndexMarker956"/>Dependabot alerts under <strong class="bold">Security</strong> | <strong class="bold">Dependabot alerts</strong>. You can click on each item to see details. If Dependabot has already created a pull request to fix the vulnerability, you can see a link with a fly-out menu in the list (see <em class="italic">Figure 14.6</em>):</p>
			<div>
				<div id="_idContainer178" class="IMG---Figure">
					<img src="image/B17827_14_006.jpg" alt="Figure 14.6 – Viewing Dependabot alerts&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.6 – Viewing Dependabot alerts</p>
			<p>Note that only the <a id="_idIndexMarker957"/>security alerts are in this list – not all the pull requests that get created to update your dependencies. There are also a lot of security alerts here that don't have a fix yet. Sometimes, the only fix is a downgrade, and if one of your dependents states a minimum higher version, there is no automated fix (see <em class="italic">Figure 14.7</em>):</p>
			<div>
				<div id="_idContainer179" class="IMG---Figure">
					<img src="image/B17827_14_007.jpg" alt="Figure 14.7 – Details of a vulnerability that has no fix&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.7 – Details of a vulnerability that has no fix</p>
			<p>If you have a closer look at the <a id="_idIndexMarker958"/>pull requests of Dependabot, you'll notice a lot of additional information. Of course, the changes themselves are only updated version numbers in a manifest file. But in the description, it adds the release notes from the package – if there are any – and a complete list of the commits that are in the new release. Dependabot also adds a compatibility score that indicates how likely it is that this update will be compatible with your code (see <em class="italic">Figure 14.8</em>):</p>
			<div>
				<div id="_idContainer180" class="IMG---Figure">
					<img src="image/B17827_14_008.jpg" alt="Figure 14.8 – Details of a Dependabot pull request&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.8 – Details of a Dependabot pull request</p>
			<p>In the description, you will also find a list of commands that you can send to the bot by commenting on the pull request. You can use <a id="_idIndexMarker959"/>any of the following commands:</p>
			<ul>
				<li><strong class="source-inline">@dependabot cancel merge</strong>: Cancels a previously requested merge.</li>
				<li><strong class="source-inline">@dependabot close</strong>: Closes the pull request and prevents Dependabot from recreating it. You can achieve the same result by closing the pull request manually.</li>
				<li><strong class="source-inline">@dependabot ignore this dependency</strong>: Closes the pull request and prevents Dependabot from creating any more pull requests for this dependency (unless you reopen the pull request or upgrade to the suggested version of the dependency yourself).</li>
				<li><strong class="source-inline">@dependabot ignore this major version</strong>: Closes the pull request and prevents Dependabot from creating any more pull requests for this major version (unless you reopen the pull request or upgrade to this major version yourself).</li>
				<li><strong class="source-inline">@dependabot ignore this minor version</strong>: Closes the pull request and prevents Dependabot from creating any more pull requests for this minor version (unless you reopen the pull request or upgrade to this minor version yourself).</li>
				<li><strong class="source-inline">@dependabot merge</strong>: Merges the pull request once your CI tests have passed.</li>
				<li><strong class="source-inline">@dependabot rebase</strong>: Rebases<a id="_idIndexMarker960"/> the pull request.</li>
				<li><strong class="source-inline">@dependabot recreate</strong>: Recreates the pull request, overwriting any edits that have been made to the pull request.</li>
				<li><strong class="source-inline">@dependabot reopen</strong>: Reopens the pull request if the pull request is closed.</li>
				<li><strong class="source-inline">@dependabot squash and merge</strong>: Squashes and merges the pull request once your CI tests have<a id="_idIndexMarker961"/> passed.</li>
			</ul>
			<p>Just comment on one of the commands in the pull request, and Dependabot will do the rest for you.</p>
			<h2 id="_idParaDest-300"><a id="_idTextAnchor300"/>Automate Dependabot updates with GitHub Actions</h2>
			<p>You <a id="_idIndexMarker962"/>can use GitHub Actions to <a id="_idIndexMarker963"/>add even more automation to Dependabot updates, but there are some things you have to be aware of. If Dependabot triggers a workflow, the GitHub actor is Dependabot (<strong class="source-inline">github.actor == "Dependabot[bot]"</strong>). This means that <strong class="source-inline">GITHUB_TOKEN</strong> has only read-only permissions by default, and you must grant write permissions if necessary. The secrets that are populated in the secret context are the Dependabot secrets! GitHub Actions secrets are not available to the workflow. </p>
			<p>The following is an example of a workflow that only gets triggered by Dependabot pull requests and gets granted write permissions to pull requests, issues, and projects:</p>
			<pre class="source-code">name: Dependabot automation</pre>
			<pre class="source-code">on: pull_request</pre>
			<pre class="source-code">permissions:</pre>
			<pre class="source-code">  pull-requests: write</pre>
			<pre class="source-code">  issues: write</pre>
			<pre class="source-code">  repository-projects: write</pre>
			<pre class="source-code">jobs:</pre>
			<pre class="source-code">  Dependabot:</pre>
			<pre class="source-code">    runs-on: ubuntu-latest</pre>
			<pre class="source-code">    if: ${{ <strong class="bold">github.actor == 'Dependabot[bot]'</strong> }}</pre>
			<p>You can <a id="_idIndexMarker964"/>use the <strong class="source-inline">Dependabot/fetch-metadata</strong> action to extract information about the dependencies being updated. Here is<a id="_idIndexMarker965"/> an example that uses the information to apply a label to the pull request:</p>
			<pre class="source-code">steps:</pre>
			<pre class="source-code">  - name: Dependabot metadata</pre>
			<pre class="source-code">    id: <strong class="bold">md</strong></pre>
			<pre class="source-code">    uses: Dependabot/fetch-metadata@v1.1.1</pre>
			<pre class="source-code">    with:</pre>
			<pre class="source-code">      github-token: "${{ secrets.GITHUB_TOKEN }}"</pre>
			<pre class="source-code">  - name: Add label for production dependencies</pre>
			<pre class="source-code">    if: ${{ steps.<strong class="bold">md</strong>.outputs.dependency-type == 'direct:production' }}</pre>
			<pre class="source-code">    run: gh pr edit "<strong class="bold">$PR_URL</strong>" --add-label "production"</pre>
			<pre class="source-code">    env:</pre>
			<pre class="source-code">      <strong class="bold">PR_URL</strong>: ${{ <strong class="bold">github.event.pull_request.html_url</strong> }}</pre>
			<p>Using the GitHub CLI, it's really easy to add automation. You can, for example, auto-approve and auto-merge all new patches: </p>
			<pre class="source-code">- name: Enable auto-merge for Dependabot PRs</pre>
			<pre class="source-code">  if: ${{ steps.<strong class="bold">md</strong>.outputs.update-type == 'version-update:semver-patch' }}</pre>
			<pre class="source-code">  run: |</pre>
			<pre class="source-code">    gh pr review --approve "<strong class="bold">$PR_URL</strong>"</pre>
			<pre class="source-code">    gh pr merge --auto --merge "<strong class="bold">$PR_URL</strong>"</pre>
			<pre class="source-code">  env:</pre>
			<pre class="source-code">    PR_URL: ${{github.event.pull_request.html_url}}</pre>
			<pre class="source-code">    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}</pre>
			<p>The<a id="_idIndexMarker966"/> combination of GitHub <a id="_idIndexMarker967"/>Actions and Dependabot is very powerful and can remove nearly all manual tasks to keep your software up to date. In combination with a good CI build and a test suite you trust, you can basically auto-merge all the Dependabot pull requests that pass the tests.</p>
			<h2 id="_idParaDest-301"><a id="_idTextAnchor301"/>Use Dependabot to keep your GitHub actions up to date</h2>
			<p>GitHub actions<a id="_idIndexMarker968"/> are also dependencies you must manage. Each action is pinned to a version (the part behind <strong class="source-inline">@</strong>, such as <strong class="source-inline">uses: Dependabot/fetch-metadata@v1.1.1</strong>). The version can also be a branch name – but this would result in flaky workflows, as your actions would change without you knowing. It's better to pin the versions to a tag or an individual commit SHA. You can let Dependabot check for updates and create pull requests for you as with any other ecosystem. Add the following section to your <strong class="source-inline">Dependabot.yml</strong> file:</p>
			<pre class="source-code">version: 2</pre>
			<pre class="source-code">updates:</pre>
			<pre class="source-code">  - package-ecosystem: "github-actions"</pre>
			<pre class="source-code">    directory: "/"</pre>
			<pre class="source-code">    schedule:</pre>
			<pre class="source-code">      interval: "daily"</pre>
			<p>Dependabot will <a id="_idIndexMarker969"/>create pull requests if new versions of your actions are available.</p>
			<h1 id="_idParaDest-302"><a id="_idTextAnchor302"/>Secret scanning</h1>
			<p>One of the most common<a id="_idIndexMarker970"/> attack vectors is secrets in plain text files. Secrets should never be stored unencrypted and unprotected. GitHub helps you with this by constantly scanning all your public repositories for secrets. You can also enable this for private repositories that belong to an organization where <strong class="bold">GitHub Advanced Security</strong> is enabled.</p>
			<p>Currently, there are nearly 100 secrets in public and 145 in private repositories that get detected – Adobe, Alibaba, Amazon, Atlassian, Azure, and so on. For a complete list, see <a href="https://docs.github.com/en/code-security/secret-scanning/about-secret-scanning">https://docs.github.com/en/code-security/secret-scanning/about-secret-scanning</a>.</p>
			<p>As a service provider, you can sign up for the <strong class="bold">secret scanning partner program</strong> (see <a href="https://docs.github.com/en/developers/overview/secret-scanning-partner-program">https://docs.github.com/en/developers/overview/secret-scanning-partner-program</a>). Your secrets get detected by a regular expression and are then sent to an endpoint, where you can verify whether the secret is real or whether it is a false positive. It is the decision of the partner to revoke the secret or just inform the customer that the secret is compromised.</p>
			<p>You can enable secret scanning for private repositories in <strong class="bold">Settings</strong> | <strong class="bold">Security &amp; analysis</strong> | <strong class="bold">GitHub Advanced Security</strong>. Here, you can also define custom patterns by clicking <strong class="bold">New pattern</strong> (see <em class="italic">Figure 14.9</em>):</p>
			<div>
				<div id="_idContainer181" class="IMG---Figure">
					<img src="image/B17827_14_009.jpg" alt="Figure 14.9 – Enabling secret scanning and adding custom patterns&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.9 – Enabling secret scanning and adding custom patterns</p>
			<p>A custom <a id="_idIndexMarker971"/>pattern is a regular expression that matches the secrets you want to detect. You have to provide some test strings to see whether your pattern works. GitHub marks the secrets found in the test strings yellow (see <em class="italic">Figure 14.10</em>):</p>
			<div>
				<div id="_idContainer182" class="IMG---Figure">
					<img src="image/B17827_14_010.jpg" alt="Figure 14.10 – Adding a custom secret pattern&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.10 – Adding a custom secret pattern</p>
			<p>You can also customize the patterns before and after the secret, and you can add patterns that must match or must not patch – for example, you can enforce with the additional pattern (<strong class="source-inline">[A-Z]</strong>) that the string must at least contain one uppercase letter (see <em class="italic">Figure 14.11</em>):</p>
			<div>
				<div id="_idContainer183" class="IMG---Figure">
					<img src="image/B17827_14_011.jpg" alt="Figure 14.11 – Advanced options for custom patterns&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.11 – Advanced options for custom patterns</p>
			<p>Custom patterns <a id="_idIndexMarker972"/>can also be defined on the organization and enterprise level, and GitHub will scan all repositories in the enterprise or organization with GitHub Advanced Security enabled.</p>
			<p>When a new secret is detected, GitHub notifies all users with access to security alerts for the repository according to their notification preferences. You will receive alerts if you are watching the repository, have enabled notifications for security alerts or all activity on the repository, are the author of the commit that contains the secret, and are not ignoring the repository.</p>
			<p>You can manage the alerts under <strong class="bold">Security</strong> | <strong class="bold">Secret scanning alerts</strong> (see <em class="italic">Figure 14.12</em>):</p>
			<div>
				<div id="_idContainer184" class="IMG---Figure">
					<img src="image/B17827_14_012.jpg" alt="Figure 14.12 – Managing secret scanning alerts&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.12 – Managing secret scanning alerts</p>
			<p>You should consider a secret that has been committed to GitHub compromised – even if it has only been to a private repository. Rotate and revoke the secret. Some service providers will revoke it for you.</p>
			<p>You can close an alert with the <strong class="source-inline">Revoked</strong>, <strong class="source-inline">False positive</strong>, <strong class="source-inline">Used in tests</strong>, or <strong class="source-inline">Won't fix</strong> status (see <em class="italic">Figure 14.13</em>):</p>
			<div>
				<div id="_idContainer185" class="IMG---Figure">
					<img src="image/B17827_14_013.jpg" alt="Figure 14.13 – Managing the status for a secret scanning alert&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.13 – Managing the status for a secret scanning alert</p>
			<p>You can also<a id="_idIndexMarker973"/> exclude paths in your source code from secret scanning by adding a <strong class="source-inline">secret_scanning.yml</strong> file to the <strong class="source-inline">.github</strong> folder. The file supports multiple path patterns with wildcard support:</p>
			<pre class="source-code">paths-ignore:</pre>
			<pre class="source-code">  - "tests/data/**/*.secret"</pre>
			<p>But be careful! This should not be used to store real secrets in source files, even for testing – store secrets as GitHub encrypted secrets or in a secure vault.</p>
			<p>Secret scanning is easy – you basically just have to turn it on. But the value of security should not be underestimated.</p>
			<h1 id="_idParaDest-303"><a id="_idTextAnchor303"/>Code scanning</h1>
			<p>To find<a id="_idIndexMarker974"/> vulnerabilities in your own code, you can use <strong class="bold">Static </strong><strong class="bold">Application Security Testing</strong> (<strong class="bold">SAST</strong>). SAST<a id="_idIndexMarker975"/> is considered white-box testing, as it has full access to the source code. It is not a pure static code analysis, as that <a id="_idIndexMarker976"/>normally includes building software. But unlike <strong class="bold">Dynamic Application Security Testing</strong> (<strong class="bold">DAST</strong>) – we will learn more about that in <a href="B17827_15_Epub.xhtml#_idTextAnchor313"><em class="italic">Chapter 15</em></a>, <em class="italic">Securing Your Deployments</em> – it is not executed at runtime but at compile time.</p>
			<h2 id="_idParaDest-304"><a id="_idTextAnchor304"/>Code scanning in GitHub</h2>
			<p>In <a id="_idIndexMarker977"/>GitHub, SAST is called <strong class="bold">code scanning</strong>, and it is available for all public repositories <a id="_idIndexMarker978"/>and for private repositories that have GitHub Advanced Security enabled. You can use code scanning with all tools that support the <strong class="bold">Static Analysis Results Interchange Format</strong> (<strong class="bold">SARIF</strong>). <a id="_idIndexMarker979"/>SARIF is an <strong class="bold">OASIS Standard</strong> based upon JSON that defines the output format for static analysis tools. GitHub code scanning currently supports <strong class="bold">SARIF 2.1.0</strong>, which is the newest version of the standard (see https://docs.github.com/en/code-security/code-scanning/integrating-with-code-scanning/sarif-support-for-code-scanning). So, any tool that supports SARIF 2.1.0 can integrate into code scanning. </p>
			<h2 id="_idParaDest-305"><a id="_idTextAnchor305"/>Running your code scans</h2>
			<p>Code scanning <a id="_idIndexMarker980"/>uses GitHub Actions to execute the analysis. Most code scanning tools automatically upload the results to GitHub – but if your code scanning tool does not, you can upload any SARIF file using the following action:</p>
			<pre class="source-code">- name: Upload SARIF file</pre>
			<pre class="source-code">  uses: github/codeql-action/upload-sarif@v1</pre>
			<pre class="source-code">  with:</pre>
			<pre class="source-code">    sarif_file: results.sarif</pre>
			<p>The action accepts individual <strong class="source-inline">.sarif</strong> (or <strong class="source-inline">.sarif.json</strong>) files or a folder with multiple files. This is useful if your scanning tool does not support SARIF, but the results can be converted. An example would be <strong class="source-inline">ESLint</strong>. You can use <strong class="source-inline">@microsoft/eslint-formatter-sarif</strong> to convert the output to SARIF and upload the results:</p>
			<pre class="source-code">jobs:</pre>
			<pre class="source-code">  build:</pre>
			<pre class="source-code">    runs-on: ubuntu-latest</pre>
			<pre class="source-code">    permissions:</pre>
			<pre class="source-code">      security-events: write</pre>
			<pre class="source-code">    steps:</pre>
			<pre class="source-code">      - uses: actions/checkout@v2</pre>
			<pre class="source-code">      - name: Run npm install</pre>
			<pre class="source-code">        run: npm install</pre>
			<pre class="source-code">      - name: Run ESLint</pre>
			<pre class="source-code">        run: node_modules/.bin/eslint build docs lib script spec-main -f node_modules/@microsoft/eslint-formatter-sarif/sarif.js -o results.sarif || true</pre>
			<pre class="source-code">      - uses: github/codeql-action/upload-sarif@v1</pre>
			<pre class="source-code">        with:</pre>
			<pre class="source-code">          sarif_file: results.sarif</pre>
			<p>However, most<a id="_idIndexMarker981"/> code scanning tools integrate natively into GitHub.</p>
			<h2 id="_idParaDest-306"><a id="_idTextAnchor306"/>Getting started</h2>
			<p>To get started with<a id="_idIndexMarker982"/> code scanning, go to <strong class="bold">Settings</strong> | <strong class="bold">Security &amp; analysis</strong> | <strong class="bold">Code scanning</strong> | <strong class="bold">Set up</strong> or <strong class="bold">Security</strong> | <strong class="bold">Code scanning alerts</strong>. Both take you to <strong class="source-inline">/security/code-scanning/setup</strong>, which shows you a list of code scanning options. On top, you can see the native GitHub code scanning tool – <strong class="bold">CodeQL Analysis</strong>. But GitHub analyses your repository and also shows you all the other tools it can find in the marketplace that fit the languages that were detected in your repository – <strong class="bold">42Crunch</strong>, <strong class="bold">Anchore</strong>, <strong class="bold">CxSAST</strong>, <strong class="bold">Veracode</strong>, and many more. In this book, we'll focus on <strong class="bold">CodeQL</strong> – but the integration of the other tools works the same way. If you click <strong class="bold">Set up this workflow</strong>, GitHub will create a workflow for you (see <em class="italic">Figure 14.14</em>):</p>
			<div>
				<div id="_idContainer186" class="IMG---Figure">
					<img src="image/B17827_14_014.jpg" alt="Figure 14.14 – Setting up code scanning&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.14 – Setting up code scanning</p>
			<p>If you have<a id="_idIndexMarker983"/> already set up code scanning, you can add additional tools from the results page by clicking <strong class="bold">Add more scanning tools</strong> (see <em class="italic">Figure 14.15</em>):</p>
			<div>
				<div id="_idContainer187" class="IMG---Figure">
					<img src="image/B17827_14_015.jpg" alt="Figure 14.15 – Code scanning alerts in a repository&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.15 – Code scanning alerts in a repository</p>
			<p>The workflow template has a trigger for <strong class="source-inline">push</strong>, <strong class="source-inline">pull_request</strong>, and <strong class="source-inline">schedule</strong>. The schedule might surprise you, but it has a simple explanation – there might be new rules that detect vulnerabilities in your codebase that have not been recognized before. So, it is a good idea to run the build also on a scheduled basis. The trigger runs once per week on a random day and to a random time. Of course, GitHub does not want all code scans to run at the same time. Adjust the schedule to your needs:</p>
			<pre class="source-code">on:</pre>
			<pre class="source-code">  push:</pre>
			<pre class="source-code">    branches: [ main ]</pre>
			<pre class="source-code">  pull_request:</pre>
			<pre class="source-code">    branches: [ main ]</pre>
			<pre class="source-code">  schedule:</pre>
			<pre class="source-code">    - cron: '42 16 * * 2'</pre>
			<p>The workflow needs write permissions for security events:</p>
			<pre class="source-code">jobs:</pre>
			<pre class="source-code">  analyze:</pre>
			<pre class="source-code">    name: Analyze</pre>
			<pre class="source-code">    runs-on: ubuntu-latest</pre>
			<pre class="source-code">    permissions:</pre>
			<pre class="source-code">      actions: read</pre>
			<pre class="source-code">      contents: read</pre>
			<pre class="source-code">      security-events: write</pre>
			<p>CodeQL<a id="_idIndexMarker984"/> supports C++ (<strong class="source-inline">cpp</strong>), C# (<strong class="source-inline">csharp</strong>), Go, Java, JavaScript, Python, and Ruby. GitHub tries to detect the languages used in your repository and sets up the matrix so that each language gets built independently. Add additional languages if necessary:</p>
			<pre class="source-code">strategy:</pre>
			<pre class="source-code">  fail-fast: false</pre>
			<pre class="source-code">  matrix:</pre>
			<pre class="source-code">    language: [ 'csharp', 'javascript' ]</pre>
			<p>The analysis itself is quite simple – check out the repository, initialize the analysis for the given language, run <strong class="source-inline">autobuild</strong>, and perform the analysis:</p>
			<pre class="source-code">steps:</pre>
			<pre class="source-code">- name: Checkout repository</pre>
			<pre class="source-code">  uses: actions/checkout@v2</pre>
			<pre class="source-code">- name: Initialize CodeQL</pre>
			<pre class="source-code">  uses: github/codeql-action/init@v1</pre>
			<pre class="source-code">  with:</pre>
			<pre class="source-code">    languages: ${{ matrix.language }}</pre>
			<pre class="source-code">- name: Autobuild</pre>
			<pre class="source-code">  uses: github/codeql-action/autobuild@v1</pre>
			<pre class="source-code">- name: Perform CodeQL Analysis</pre>
			<pre class="source-code">  uses: github/codeql-action/analyze@v1</pre>
			<p>The <strong class="source-inline">autobuild</strong> step<a id="_idIndexMarker985"/> tries to build your source code. If it fails, you have to change the workflow and build the code yourself. Sometimes, it is enough to set up the right version in the environment – for example, the version of Node.js or .NET:</p>
			<pre class="source-code">- name: Setup Node</pre>
			<pre class="source-code">  uses: actions/setup-node@v2.5.0</pre>
			<pre class="source-code">  with:</pre>
			<pre class="source-code">    node-version: 10.16.3  </pre>
			<h2 id="_idParaDest-307"><a id="_idTextAnchor307"/>Code scanning alerts</h2>
			<p>You <a id="_idIndexMarker986"/>can manage your<a id="_idIndexMarker987"/> code scanning alerts in each repository under <strong class="bold">Settings</strong> | <strong class="bold">Security &amp; analysis</strong> | <strong class="bold">Code scanning</strong> – as you saw in <em class="italic">Figure 14.15</em>. On the organization level, you get an overview of all repositories, and you can jump to the individual results page (see <em class="italic">Figure 14.16</em>):</p>
			<div>
				<div id="_idContainer188" class="IMG---Figure">
					<img src="image/B17827_14_016.jpg" alt="Figure 14.16 – The security overview for an organization&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.16 – The security overview for an organization</p>
			<p>You<a id="_idIndexMarker988"/> can filter, sort, and <a id="_idIndexMarker989"/>search alerts the same way you can with issues.</p>
			<h3>Severity</h3>
			<p>Every code <a id="_idIndexMarker990"/>scanning alert has a severity assigned. The severity is calculated using the <strong class="bold">Common Vulnerability Scoring System</strong> (<strong class="bold">CVSS</strong>). The CVSS is <a id="_idIndexMarker991"/>an open framework for communicating the characteristics and severity of software vulnerabilities (see <em class="italic">GitHub Blog 2021</em> for more information).</p>
			<p>The severity helps you to triage your alerts.</p>
			<h3>Tracking alerts in issues</h3>
			<p>The best way to<a id="_idIndexMarker992"/> track a code scanning alert is in an issue. You can create one by clicking <strong class="bold">Create issue</strong> inside the alert (see <em class="italic">Figure 14.17</em>):</p>
			<div>
				<div id="_idContainer189" class="IMG---Figure">
					<img src="image/B17827_14_017.jpg" alt="Figure 14.17 – Creating an issue from a code scanning alert&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.17 – Creating an issue from a code scanning alert</p>
			<p>But it is just opening a new issue and adding the link to the alert into a Markdown task list (see <em class="italic">Figure 14.18</em>):</p>
			<div>
				<div id="_idContainer190" class="IMG---Figure">
					<img src="image/B17827_14_018.jpg" alt="Figure 14.18 – Linking an issue to a code scanning alert&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.18 – Linking an issue to a code scanning alert</p>
			<p>The alert will have <a id="_idIndexMarker993"/>an indicator that it is being tracked in an issue – like nested issues do (see <em class="italic">Figure 14.19</em> in the next).</p>
			<h3>Data-flow analysis</h3>
			<p>In the area under <a id="_idIndexMarker994"/>the code, you can see the details of the alert in your code. CodeQL supports <strong class="bold">data-flow analysis</strong> and can detect issues that arise from the flow of data through your application. Click on <strong class="bold">Show paths</strong> to see how the data flows through your application (see <em class="italic">Figure 14.19</em>):</p>
			<div>
				<div id="_idContainer191" class="IMG---Figure">
					<img src="image/B17827_14_019.jpg" alt="Figure 14.19 – Details of the code scanning alert&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.19 – Details of the code scanning alert</p>
			<p>You can follow the data through your entire application. In the example here, you can see 12 steps where the data is assigned and passed along until it is logged (see <em class="italic">Figure 14.20</em>):</p>
			<div>
				<div id="_idContainer192" class="IMG---Figure">
					<img src="image/B17827_14_020.jpg" alt="Figure 14.20 – An example data flow&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.20 – An example data flow</p>
			<p>This is the real power of CodeQL. It is not just a semantic analysis of your source code. </p>
			<h3>CodeQL queries</h3>
			<p>In the code scanning alert, you<a id="_idIndexMarker995"/> can find a reference to the query that detected the issue. Click on <strong class="bold">View source</strong> to see the query on GitHub (see <em class="italic">Figure 14.21</em>):</p>
			<div>
				<div id="_idContainer193" class="IMG---Figure">
					<img src="image/B17827_14_021.jpg" alt="Figure 14.21 – The CodeQL queries are open source&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.21 – The CodeQL queries are open source</p>
			<p>The queries are<a id="_idIndexMarker996"/> open source, and you'll find them under <a href="https://github.com/github/codeql">https://github.com/github/codeql</a>. Every language has a folder here, and inside the CodeQL folder, you'll find the queries under <strong class="source-inline">ql/src</strong>. The queries have the <strong class="source-inline">.ql</strong> file extension. </p>
			<h3>Timeline </h3>
			<p>The code scanning alert also contains a concrete timeline<a id="_idIndexMarker997"/> with git blame information – when and in what commit was the issue first detected? When and where was it fixed? Did it reappear? This can help you to triage the alerts (see <em class="italic">Figure 14.22</em>):</p>
			<div>
				<div id="_idContainer194" class="IMG---Figure">
					<img src="image/B17827_14_022.jpg" alt="Figure 14.22 – A timeline of a code scanning alert&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.22 – A timeline of a code scanning alert</p>
			<h2 id="_idParaDest-308"><a id="_idTextAnchor308"/>Pull request integration</h2>
			<p>Code scanning integrates well with <a id="_idIndexMarker998"/>pull requests. Code scanning results are integrated into the pull request checks, and the details page shows you the overview of the results (see <em class="italic">Figure 14.23</em>):</p>
			<div>
				<div id="_idContainer195" class="IMG---Figure">
					<img src="image/B17827_14_023.jpg" alt="Figure 14.23 – Code scanning results in a pull request&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.23 – Code scanning results in a pull request</p>
			<p>Code scanning also adds comments for the alerts in the code, and you can directly triage the findings there, changing the status to <strong class="bold">False positive</strong>, <strong class="bold">Used in tests</strong>, or <strong class="bold">Won't fix</strong> (see <em class="italic">Figure 14.24</em>):</p>
			<div>
				<div id="_idContainer196" class="IMG---Figure">
					<img src="image/B17827_14_024.jpg" alt="Figure 14.24 – Code scanning comment in the source of a pull request&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.24 – Code scanning comment in the source of a pull request</p>
			<p>You can define <a id="_idIndexMarker999"/>which alert severity should cause the pull request to fail for security issues and other findings under <strong class="bold">Settings</strong> | <strong class="bold">Security &amp; analysis</strong> | <strong class="bold">Code scanning</strong> (see <em class="italic">Figure 14.25</em>):</p>
			<div>
				<div id="_idContainer197" class="IMG---Figure">
					<img src="image/B17827_14_025.jpg" alt="Figure 14.25 – Configure which level of severity causes pull requests to fail&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.25 – Configure which level of severity causes pull requests to fail</p>
			<p>The pull request integration helps you to keep your main branch clean and detect issues before merging and making the code analysis part of the review process.</p>
			<h2 id="_idParaDest-309"><a id="_idTextAnchor309"/>Code scanning configuration</h2>
			<p>There are many options to<a id="_idIndexMarker1000"/> configure code scanning. The <strong class="source-inline">init</strong> CodeQL action in your workflow has a parameter called <strong class="source-inline">queries</strong>. You can use it to pick one of the default query suits:</p>
			<ul>
				<li><strong class="source-inline">security-extended</strong>: More queries of lower severity than the default</li>
				<li><strong class="source-inline">security-and-quality</strong>: Queries from <strong class="source-inline">security-extended</strong>, plus maintainability and reliability queries</li>
			</ul>
			<pre class="source-code">- name: Initialize CodeQL</pre>
			<pre class="source-code">  uses: github/codeql-action/init@v1</pre>
			<pre class="source-code">  with:</pre>
			<pre class="source-code">    languages: ${{ matrix.language }}</pre>
			<pre class="source-code">    queries:  security-and-quality</pre>
			<p>You can also use the <strong class="source-inline">queries</strong> parameter to add custom queries. The parameter accepts local paths or references to other repositories, including a git reference (<strong class="source-inline">branch</strong>, <strong class="source-inline">tag</strong>, or <strong class="source-inline">SHA</strong>). Add a <a id="_idIndexMarker1001"/>plus sign to add the queries on top of the default:</p>
			<pre class="source-code">  with:</pre>
			<pre class="source-code">    queries: +.github/codeql/custom.ql,<strong class="bold">org</strong>/<strong class="bold">repo</strong>/query.ql@v1</pre>
			<p><strong class="bold">CodeQL packs</strong> are<a id="_idIndexMarker1002"/> YAML-based query suits that are used to create, share, depend on, and run CodeQL queries. They can be set using the <strong class="source-inline">packs</strong> parameter:</p>
			<pre class="source-code">  with:</pre>
			<pre class="source-code">    packs: +.github/codeql/pack1.yml,<strong class="bold">org</strong>/<strong class="bold">repo</strong>/pack2.yml@v1</pre>
			<p class="callout-heading">Important Note</p>
			<p class="callout"><strong class="bold">CodeQL packs</strong> are still in beta at the <a id="_idIndexMarker1003"/>time of writing. See <a href="https://codeql.github.com/docs/codeql-cli/about-codeql-packs/">https://codeql.github.com/docs/codeql-cli/about-codeql-packs/</a> for more information about packs. </p>
			<p>You can also use a <a id="_idIndexMarker1004"/>configuration file – for example, <strong class="source-inline">./.github/codeql/codeql-config.yml</strong>:</p>
			<pre class="source-code">- uses: github/codeql-action/init@v1</pre>
			<pre class="source-code">  with:</pre>
			<pre class="source-code">    config-file: ./.github/codeql/codeql-config.yml</pre>
			<p>If any of the preceding is located in another private repository, then you can add an access token that is used to load queries, packs, or the config file:</p>
			<pre class="source-code">    external-repository-token: ${{ secrets.ACCESS_TOKEN }}</pre>
			<p>In the config file, you normally disable the default queries and specify your own. You can also exclude specific paths. Here is an example – <strong class="source-inline">codeql-config.yml</strong>:</p>
			<pre class="source-code">name: "Custom CodeQL Configuration"</pre>
			<pre class="source-code">disable-default-queries: true</pre>
			<pre class="source-code">queries:</pre>
			<pre class="source-code">  - uses: ./.github/codeql/<strong class="bold">custom-javascript.qls</strong></pre>
			<pre class="source-code">paths-ignore:</pre>
			<pre class="source-code">  - '**/node_modules'</pre>
			<pre class="source-code">  - '**/test'</pre>
			<p>Your custom query suit (<strong class="source-inline">custom-javascript.qls</strong>) can then import other query suites (<strong class="source-inline">javascript-security-extended.qls</strong>) from <em class="italic">CodeQL packs</em> ( <strong class="source-inline">codeql-javascript</strong>) and exclude specific rules:</p>
			<pre class="source-code">- description: "Custom JavaScript Suite"</pre>
			<pre class="source-code">- import: codeql-suites/javascript-security-extended.qls</pre>
			<pre class="source-code">  from: codeql-javascript</pre>
			<pre class="source-code">- exclude:</pre>
			<pre class="source-code">    id:</pre>
			<pre class="source-code">      - js/missing-rate-limiting</pre>
			<p>You can also add <a id="_idIndexMarker1005"/>individual queries (<strong class="source-inline">- query : &lt;path to query&gt;</strong>), multiple queries (<strong class="source-inline">-queries: &lt;path to folder&gt;</strong>), or packs (<strong class="source-inline">- qlpack: &lt;name of pack&gt;</strong>).</p>
			<p>CodeQL is very powerful, and you have many options to finetune the configuration. See <a href="https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning">https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning</a> for more details.</p>
			<h1 id="_idParaDest-310"><a id="_idTextAnchor310"/>Writing your own CodeQL queries</h1>
			<p>CodeQL comes with <a id="_idIndexMarker1006"/>a lot of out-of-the-box queries – especially if you use the <strong class="source-inline">security-and-quality</strong> suite. But the full power of CodeQL comes if you start to write your own queries. Of course, this is not trivial. CodeQL is a complex query language, and if you look at some of the queries at <a href="https://github.com/github/codeql">https://github.com/github/codeql</a>, you'll see that they can get quite complex. But if you know your coding language, it should be quite easy to create some simple queries.</p>
			<p>To write CodeQL queries, you need <strong class="bold">Visual Studio Code</strong> (<strong class="bold">VS Code</strong>) and the <strong class="bold">GitHub CodeQL extension</strong> (<a href="https://marketplace.visualstudio.com/items?itemName=GitHub.vscode-codeql">https://marketplace.visualstudio.com/items?itemName=GitHub.vscode-codeql</a>). </p>
			<p>If you have both installed, clone the starter workspace:</p>
			<p class="source-code">$ git clone --recursive https://github.com/github/vscode-codeql-starter.git</p>
			<p>Note the <strong class="source-inline">--recursive</strong> parameter! If you forget it, you have to load the submodules manually:</p>
			<p class="source-code">$ git submodule update --remote</p>
			<p>In VSCode, select <strong class="bold">File</strong> | <strong class="bold">Open Workspace from File…</strong> and select the <strong class="source-inline">vscode-codeql-starter.code-workspace</strong> file from the starter workspace. </p>
			<p>To create a<a id="_idIndexMarker1007"/> database from your source code, you need the <strong class="bold">CodeQL CLI</strong>. On a <a id="_idIndexMarker1008"/>Mac, you can install it using Homebrew:</p>
			<p class="source-code">$ brew install codeql</p>
			<p>For other platforms, you can download the binaries here: <a href="https://github.com/github/codeql-cli-binaries/releases/latest">https://github.com/github/codeql-cli-binaries/releases/latest.</a></p>
			<p>Extract them to a folder and add them to the <strong class="source-inline">$PATH</strong> variable (<strong class="source-inline">%PATH%</strong> on windows).</p>
			<p>Now, go into the folder where you want to store the database and run the following command:</p>
			<p class="source-code">$ codeql database create &lt;database name&gt; \</p>
			<p class="source-code">  --language=&lt;language&gt; \</p>
			<p class="source-code">  --source-root=&lt;path to source code&gt;</p>
			<p>This will create a database for the language in your repository. Repeat the step for all the languages in your repository.</p>
			<p>Now, open the QL extension in VSCode and click <strong class="bold">Databases</strong> | <strong class="bold">From a folder</strong>. Select the database that you've created in the previous step. You can attach multiple databases and switch between them (see <em class="italic">Figure 14.26</em>):</p>
			<div>
				<div id="_idContainer198" class="IMG---Figure">
					<img src="image/B17827_14_026.jpg" alt="Figure 14.26 – Attaching databases to the VSCode CodeQL extension&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.26 – Attaching databases to the VSCode CodeQL extension</p>
			<p>You can find sample <a id="_idIndexMarker1009"/>queries for all supported languages in the starter workspace (<strong class="source-inline">codeql-custom-queries-&lt;language&gt;/example.ql</strong>). The queries have a comment header with metadata:</p>
			<pre class="source-code">/**</pre>
			<pre class="source-code"> * @name Empty block</pre>
			<pre class="source-code"> * @kind problem</pre>
			<pre class="source-code"> * @problem.severity warning</pre>
			<pre class="source-code"> * @id javascript/example/empty-block</pre>
			<pre class="source-code"> */ </pre>
			<p>Then, they import the necessary modules. They are normally named after the language (<strong class="source-inline">javascript</strong>, <strong class="source-inline">csharp</strong>, <strong class="source-inline">java</strong>, and so on), but they could also be something like <strong class="source-inline">DataFlow::PathGraph</strong>:</p>
			<pre class="source-code">import javascript</pre>
			<p>The query itself has a variable declaration, an optional <strong class="source-inline">where</strong> block to limit the results, and the <strong class="source-inline">select</strong> statement:</p>
			<pre class="source-code">from BlockStmt b</pre>
			<pre class="source-code">where </pre>
			<pre class="source-code">  b.getNumStmt() = 0</pre>
			<pre class="source-code">select b, "This is an empty block."</pre>
			<p>Look at the CodeQL samples on GitHub to get an idea of how to start. The better you know a language, the easier it is to write the queries. The following query would search for empty catch blocks in C#:</p>
			<pre class="source-code">import csharp</pre>
			<pre class="source-code">from CatchClause cc</pre>
			<pre class="source-code">where</pre>
			<pre class="source-code">  cc.getBlock().isEmpty()</pre>
			<pre class="source-code">select cc, "Poor error handling: empty catch block."</pre>
			<p>You have full<a id="_idIndexMarker1010"/> IntelliSense support in VSCode (see <em class="italic">Figure 14.27</em>), which helps a lot when writing the queries:</p>
			<div>
				<div id="_idContainer199" class="IMG---Figure">
					<img src="image/B17827_14_027.jpg" alt="Figure 14.27 – IntelliSense in VSCode&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.27 – IntelliSense in VSCode</p>
			<p>If you run a query from the context menu (<strong class="bold">CodeQL: Run query</strong>), it will display the results in the results window (see <em class="italic">Figure 14.28</em>):</p>
			<div>
				<div id="_idContainer200" class="IMG---Figure">
					<img src="image/B17827_14_028.jpg" alt="Figure 14.28 – CodeQL query results&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.28 – CodeQL query results</p>
			<p>Every element in the <strong class="source-inline">select</strong> clause has a column. You can click on code elements and VSCode will open the corresponding source file at the exact location.</p>
			<p>You could <a id="_idIndexMarker1011"/>easily fill an entire book just about CodeQL. This is just a very brief introduction, but I see a lot of value in being able to extend code scanning with your own rules.</p>
			<p>See the CodeQL documentation and language reference for further information.</p>
			<h1 id="_idParaDest-311"><a id="_idTextAnchor311"/>Summary</h1>
			<p>In this chapter, you've learned how to secure your code and control your dependencies:</p>
			<ul>
				<li>You've learned about SCA, and you know how to use dependency graphs, Dependabot alerts, and Dependabot security updates to manage your software dependencies.</li>
				<li>You've learned about secret scanning, which prevents secrets from being leaked in your source code.</li>
				<li>You've learned about SAST, and you know how to use code scanning with CodeQL or other tools that support SARIF to find problems already during development. You can now write your own queries to enforce quality and coding standards.</li>
			</ul>
			<p>In the next chapter, we'll have a look into how we can secure our release pipeline and our deployments. </p>
			<h1 id="_idParaDest-312"><a id="_idTextAnchor312"/>Further reading</h1>
			<p>These are the references from this chapter that you can also use to get more information on the topics:</p>
			<ul>
				<li><em class="italic">How one programmer broke the internet by deleting a tiny piece of code</em>, <em class="italic">Keith Collins</em> (2016): <a href="https://qz.com/646467/how-one-programmer-broke-the-internet-by-deleting-a-tiny-piece-of-code/">https://qz.com/646467/how-one-programmer-broke-the-internet-by-deleting-a-tiny-piece-of-code/</a></li>
				<li><em class="italic">Kik, Left-Pad, and NPM – Oh My!</em>, <em class="italic">Tyler Eon</em> (2016): <a href="https://medium.com/@kolorahl/kik-left-pad-and-npm-oh-my-e6f216a22766">https://medium.com/@kolorahl/kik-left-pad-and-npm-oh-my-e6f216a22766</a></li>
				<li><em class="italic">Secure at every step: What is software supply chain security and why does it matter?</em>, <em class="italic">Maya Kaczorowski</em> (2020): <a href="https://github.blog/2020-09-02-secure-your-software-supply-chain-and-protect-against-supply-chain-threats-github-blog/&#13;">https://github.blog/2020-09-02-secure-your-software-supply-chain-and-protect-against-supply-chain-threats-github-blog/</a></li>
				<li><em class="italic">About the dependency graph</em>: <a href="https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph&#13;">https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph</a></li>
				<li><em class="italic">About Dependabot version updates</em>: <a href="https://docs.github.com/en/code-security/supply-chain-security/keeping-your-dependencies-updated-automatically/about-Dependabot-version-updates&#13;">https://docs.github.com/en/code-security/supply-chain-security/keeping-your-dependencies-updated-automatically/about-Dependabot-version-updates</a></li>
				<li><em class="italic">About secret scanning</em>: <a href="https://docs.github.com/en/code-security/secret-scanning/about-secret-scanning ">https://docs.github.com/en/code-security/secret-scanning/about-secret-scanning</a></li>
				<li><em class="italic">About GitHub Advanced Security</em>: <a href="https://docs.github.com/en/get-started/learning-about-github/about-github-advanced-security&#13;">https://docs.github.com/en/get-started/learning-about-github/about-github-advanced-security</a></li>
				<li><em class="italic">About code scanning</em>: <a href="https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/about-code-scanning">https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/about-code-scanning</a></li>
				<li><em class="italic">CodeQL code scanning: new severity levels for security alerts</em>, GitHub Blog (2021): <a href="https://github.blog/changelog/2021-07-19-codeql-code-scanning-new-severity-levels-for-security-alerts/&#13;">https://github.blog/changelog/2021-07-19-codeql-code-scanning-new-severity-levels-for-security-alerts/</a></li>
				<li><em class="italic">Common Vulnerability Scoring System (CVSS)</em>: <a href="https://www.first.org/cvss/v3.1/specification-document">https://www.first.org/cvss/v3.1/specification-document</a></li>
				<li><em class="italic">CodeQL documentation</em>: https://codeql.github.com/docs/</li>
				<li><em class="italic">QL language reference</em>: <a href="https://codeql.github.com/docs/ql-language-reference">https://codeql.github.com/docs/ql-language-reference</a></li>
			</ul>
		</div>
	</body></html>