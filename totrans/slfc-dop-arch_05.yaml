- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Day-to-Day Delivery with SFDX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ll see how we can apply what we’ve learned so far, using
    the SFDX suite of tools together with Visual Studio Code and Git, to manage our
    change delivery. It will by no means be the definitive way to do Salesforce DevOps
    and assumes starting a brand-new project from scratch, but it will show some common
    tasks and principles.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the tools and your project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The change lifecycle with Git and SFDX
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sandboxes versus scratch orgs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you should be able to replicate a simple workflow
    in your own Salesforce orgs for picking up an item of work from a ticketing system
    such as Jira or Asana, creating a new feature branch for it, using SFDX and VS
    Code to make your changes, and checking the code back in again. This is the most
    straightforward approach to DevOps and will give you the solid practical foundations
    you need.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to follow along with the examples in this chapter, as a minimum,
    you will need to have the following installed:'
  prefs: []
  type: TYPE_NORMAL
- en: The Salesforce CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VS Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Salesforce extensions for VS Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will also need a GitHub account ([https://github.com/](https://github.com/))
    in which to create a new Git repository and Git installed on your local machine
    ([https://git-scm.com/](https://git-scm.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the tools and your project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While in most real-world scenarios, it’s highly likely that both your tools
    and your project would already be set up and ready for development on an existing
    implementation, we’re going to cover setting up everything from scratch so that
    if you want to follow along with the example workflow, you could potentially do
    so from a fresh Developer Edition Salesforce org.
  prefs: []
  type: TYPE_NORMAL
- en: The Salesforce CLI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Salesforce CLI is the primary tool for interacting with your Salesforce
    org from your development tools and is fundamental to automating processes for
    CI/CD as well.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Overview of the Salesforce CLI download page](img/Figure_5.1_B19436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Overview of the Salesforce CLI download page
  prefs: []
  type: TYPE_NORMAL
- en: To install the Salesforce CLI on Windows, macOS, or Linux, follow the instructions
    for the required operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Go to the Salesforce CLI download page: [https://developer.salesforce.com/tools/sfdxcli](https://developer.salesforce.com/tools/sfdxcli).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Windows Installer** link to download the installer for Windows.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the downloaded executable file (`.exe`) to start the installation process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the installation wizard, accept the license agreement, and choose the
    desired settings. The default settings are usually sufficient for most users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Complete the installation process by clicking **Install** and then **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open Command Prompt or PowerShell and type `sfdx --version` to verify the installation.
    If the installation was successful, you should see the installed Salesforce CLI
    version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Checking the installation of the Salesforce CLI on Windows](img/Figure_5.2_B19436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Checking the installation of the Salesforce CLI on Windows
  prefs: []
  type: TYPE_NORMAL
- en: macOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Go to the Salesforce CLI download page: [https://developer.salesforce.com/tools/sfdxcli](https://developer.salesforce.com/tools/sfdxcli).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **MacOS Installer** link to download the installer for macOS that’s
    appropriate for the type of Mac you have.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the downloaded `.pkg` file to start the installation process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the installation wizard, accept the license agreement, and choose the
    desired settings. The default settings are usually sufficient for most users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Complete the installation process by clicking **Install** and then **Close**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open Terminal and type `sfdx --version` to verify the installation. If the installation
    was successful, you should see the installed Salesforce CLI version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Checking the successful installation of the Salesforce CLI on
    macOS](img/Figure_5.3_B19436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Checking the successful installation of the Salesforce CLI on macOS
  prefs: []
  type: TYPE_NORMAL
- en: Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Salesforce CLI for Linux is available as a tarball. You can find the download
    URL for the tarball that matches your system architecture here.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Architecture** | **Manifest file** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| x64 | [https://developer.salesforce.com/media/salesforce-cli/sfdx/channels/stable/sfdx-linux-x64.tar.xz](https://developer.salesforce.com/media/salesforce-cli/sfdx/channels/stable/sfdx-linux-x64.tar.xz)
    |'
  prefs: []
  type: TYPE_TB
- en: '| Arm | [https://developer.salesforce.com/media/salesforce-cli/sfdx/channels/stable/sfdx-linux-arm.tar.xz](https://developer.salesforce.com/media/salesforce-cli/sfdx/channels/stable/sfdx-linux-arm.tar.xz)
    |'
  prefs: []
  type: TYPE_TB
- en: Table 5.1 – Manifest files for the Linux installation packages
  prefs: []
  type: TYPE_NORMAL
- en: 'To download one of these tarballs, use the `wget` command. For example, for
    the x64 platform, use this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: mkdir ~/sfdx
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Extract the contents of the tarball version you downloaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`tar xJf sfdx-linux-x64.tar.xz -C ~/sfdx --``strip-components 1`'
  prefs: []
  type: TYPE_NORMAL
- en: The `-C` flag extracts the contents into the `sfdx` directory, while `--strip-components
    1` removes the root path component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify your PATH environment variable to incorporate the Salesforce CLI `bin`
    directory. For instance, to configure it for your ongoing Terminal session, use
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: sfdx --version to verify the installation. If the installation was successful,
    you should see the installed Salesforce CLI version.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 5.4 – Verifying the installation of the CLI](img/Figure_5.4_B19436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Verifying the installation of the CLI
  prefs: []
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To install Git on Windows, macOS, or Ubuntu Linux, follow the instructions here
    for the appropriate operating system. For other Linux distributions, you may need
    to search for the appropriate documentation for your package management system.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – The Git client download page](img/Figure_5.5_B19436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – The Git client download page
  prefs: []
  type: TYPE_NORMAL
- en: Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Download the Git for Windows installer from the official website:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[https://git-scm.com/download/win](https://git-scm.com/download/win)'
  prefs: []
  type: TYPE_NORMAL
- en: Run the downloaded executable file (`.exe`) to start the installation process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the installation wizard, choosing the desired settings. The default settings
    are usually sufficient for most users.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Complete the installation process by clicking **Install** and then **Finish**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To verify the installation, open the Git Bash terminal by searching for it in
    the **Start** menu or using the context menu in a folder by right-clicking and
    selecting **Git** **Bash Here**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Git Bash terminal, type `git --version` and press *Enter*. If the installation
    was successful, you should see the installed Git version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Confirming the successful installation of Git for Windows](img/Figure_5.6_B19436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Confirming the successful installation of Git for Windows
  prefs: []
  type: TYPE_NORMAL
- en: macOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Check whether Git is already installed by opening the Terminal app and typing
    `git --version`. If Git is installed, you’ll see the version number. If not, proceed
    to the next step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install **Homebrew**, a package manager for macOS, by following the instructions
    on the official website: [https://brew.sh/](https://brew.sh/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once Homebrew is installed, open Terminal and type `brew` `install git`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for the installation process to complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify the installation by typing `git --version` in Terminal. If the installation
    was successful, you should see the installed Git version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Confirming the successful installation of Git on macOS](img/Figure_5.7_B19436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – Confirming the successful installation of Git on macOS
  prefs: []
  type: TYPE_NORMAL
- en: Ubuntu Linux
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open Terminal (*Ctrl + Alt +* *T*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the package list by typing `sudo apt update` and pressing *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install Git by typing `sudo apt install git` and pressing *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Confirm the installation by typing `Y` when prompted and pressing *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for the installation process to complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify the installation by typing `git --version` in the Terminal. If the installation
    was successful, you should see the installed Git version.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Confirming the successful installation of Git on Linux](img/Figure_5.8_B19436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – Confirming the successful installation of Git on Linux
  prefs: []
  type: TYPE_NORMAL
- en: VS Code and extensions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microsoft VS Code is available for Windows, macOS, and Linux systems. The installer
    can be obtained from [https://code.visualstudio.com/download](https://code.visualstudio.com/download)
    – simply follow the instructions for your operating system.
  prefs: []
  type: TYPE_NORMAL
- en: 'More important to Salesforce development using VS Code are the extensions that
    allow integration with both Git and SFDX right from within the IDE:'
  prefs: []
  type: TYPE_NORMAL
- en: Open VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the extensions view icon on the sidebar or press *Ctrl + Shift + X* (Windows/Linux)
    or *Cmd + Shift + X* (Mac) to open the **Extensions** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for `Salesforce Extension Pack` in the search bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Install** button on **Salesforce Extension Pack** by Salesforce.
    This will install a collection of extensions, including Salesforce CLI Integration,
    Apex, Aura Components, Lightning Web Components, and more.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a new SFDX project and connecting it to your Salesforce org
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have all the required tools installed, we can start getting a project
    together on which to work. We will create a new SFDX project from within VS Code
    and connect it to our Salesforce environment. We’ll also connect it to our Git
    source control so that we can truly work in a source-driven way. Let’s look at
    the steps needed to connect everything together:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set up an SFDX project using the Command Palette:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Command Palette with *Ctrl + Shift + P* (Windows/Linux) or *Cmd + Shift
    +* *P* (Mac).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type `SFDX: Create Project` and press *Enter*.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose **Standard** as the project template and press *Enter*.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter a desired name for your project and press *Enter*.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose a folder to store your SFDX project and press *Enter*. This will generate
    a new SFDX project structure in the specified folder.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Set the default org for your project using the Command Palette:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Command Palette with *Ctrl + Shift + P* (Windows/Linux) or *Cmd + Shift
    +* *P* (Mac).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `SFDX`, then set a default org and press *Enter*.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose an alias to use when authenticating with your Salesforce org.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Now you have installed and set up the VS Code extensions for Salesforce using
    the Command Palette and are ready to start developing Salesforce applications.
  prefs: []
  type: TYPE_NORMAL
- en: The change lifecycle with Git and SFDX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many organizations, teams make use of workflow management systems such as
    Jira or Asana to capture, refine, and assign work items for development teams.
    In this example, we’re going to assume that Jira is in use, but this is purely
    for illustrative purposes to replicate a reasonably typical real-world scenario.
    It is definitely not essential to use Jira, or any equivalent system, to follow
    these examples. We will be looking at ticketing systems in more detail in [*Chapter
    8*](B19436_08.xhtml#_idTextAnchor177).
  prefs: []
  type: TYPE_NORMAL
- en: Getting a Git repository to work with
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In [*Chapter 3*](B19436_03.xhtml#_idTextAnchor046), we looked at some of the
    most common Git operations and their corresponding commands. In most real-world
    scenarios, you are likely to have a pre-existing repository to work with. However,
    there may be scenarios where you are starting a project with Git for the first
    time, so let’s look at the main ways to prepare Git for work:'
  prefs: []
  type: TYPE_NORMAL
- en: '`git init` will create a brand-new local repository on your machine to work
    with. At this point, there is no equivalent remote repository. You can refer back
    to [*Chapter 3*](B19436_03.xhtml#_idTextAnchor046) if you need a reminder of how
    to connect one, for example, on GitHub.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`git clone` will create a copy of a remote repository on your local machine
    – including the version history and all the branches and commits it contains.
    It will create the correct directory structure for you, ready to work with.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`git checkout` is used to switch branches within an existing repository. When
    you use this command, your local working folder will be updated to reflect the
    contents of that branch.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting the latest changes from the main branch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Obtaining the latest main branch changes before development ensures a current
    code base, minimizes merge conflicts, and streamlines the integration of new features
    or fixes:'
  prefs: []
  type: TYPE_NORMAL
- en: In VS Code, click the **Source Control** icon in the left sidebar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **...** (ellipsis) button at the top and choose **Pull** to fetch
    and merge the latest changes from the main branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a new feature branch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The feature branch model is a simple Git-based development approach, ideal for
    beginners. It maintains up-to-date metadata on the main branch, which should always
    be release-ready. Definitions of what constitutes “release-ready” or “production-ready”
    can vary wildly and largely depend on the level of testing applied, both of individual
    changes and the overall holistic view of your production system and any integrations
    it may have. For the purposes of demonstrating a workflow here, we shall significantly
    simplify our definition to mean that changes have had functional testing in your
    development org, any code reviews (both automated and manual) have been carried
    out, and a pull request has been approved.
  prefs: []
  type: TYPE_NORMAL
- en: 'Developers create new branches from the main for features or fixes, merging
    them back upon completion. Short-lived feature branches minimize merge conflicts
    and promote tidiness. Smaller deliverables reduce feedback cycle length. To create
    the feature branch from within VS Code, complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Source Control** panel, click the branch icon at the bottom-left corner
    of the window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type in the name of the new feature branch (e.g., `feature/JIRA-1234`) and press
    *Enter* to create and switch to the new branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Working on your changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should now be able to start your development work against your feature branch.
    This can be a combination of configuration work in the connected Salesforce org
    or code-based development in the Salesforce IDE.
  prefs: []
  type: TYPE_NORMAL
- en: The Salesforce extensions for VS Code simplify moving your metadata changes
    back and forth between your local machine and your development org. Many of the
    underlying Salesforce CLI commands are available in either the Org Browser, the
    Command Palette, or as context-sensitive menu options when right-clicking on files.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving metadata
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Open the Org Browser in the side panel in VS Code (you can find it with an icon
    that resembles a cloud).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it’s your first time using the Org Browser, or if the metadata for your org
    has changed, click the refresh icon to retrieve the metadata from your org.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Org Browser displays a list of metadata types. You can click the arrow next
    to a metadata type to expand it and see the individual components of that type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To retrieve a metadata component, click the cloud download icon next to the
    component’s name. This retrieves the component and adds it to your local project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploying metadata
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Navigate to the files or folders you want to deploy in your local project structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the selected items.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the context menu, choose the **SFDX: Deploy Source to Org** command. This
    deploys the metadata to your org.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the Org Browser does not directly facilitate deployment, but the standard
    deployment commands in the Salesforce extensions for VS Code are used instead.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once your development is complete, test your changes in Salesforce using scratch
    orgs or sandboxes, as appropriate. We will be looking at the differences between
    the two types of Salesforce development environments later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Committing your changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The two-step process of committing changes involves first staging the alterations
    and then executing the commit. Staging selects modifications for a commit while
    committing records the staged changes as a new snapshot in the local repository,
    maintaining development history. You can complete the staging and committing of
    your changes like so:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Source Control** panel, review the changes you have made.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stage the changes by clicking the **+** icon next to each changed file or by
    clicking the **+** icon next to **CHANGES** to stage all changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter a meaningful commit message describing the changes related to the Jira
    ticket (e.g., “`JIRA-1234: Implemented` `new feature`”).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the checkmark icon at the top to commit the changes to your feature branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pushing your feature branch to the remote repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once our changes are added to Git locally, we can then move those changes up
    to the remote repository as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the **Source Control** panel, click the **...** (ellipsis) button at the
    top and choose **Push**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If prompted, select your feature branch (e.g., “`feature/JIRA-1234`”) to push
    it to the remote repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating a pull request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a pull request in Git is a collaborative process where a developer
    proposes merging their changes from one branch into another, often from a feature
    branch into the main branch. This allows for code review, discussion, and potential
    modifications before integrating the changes. This is also the stage in which
    automated checks are carried out, such as running tests and static analysis, and
    this makes pull requests a useful tool for solo developers, not just multi-person
    teams.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the pull request via GitHub, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your browser and navigate to your repository on GitHub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Compare & pull request** button next to your recently pushed branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review the changes, and add any additional information or context related to
    the Jira ticket.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assign the appropriate reviewers and click **Create** **pull request**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Alternatively, if you have the `GitHub Pull Requests and Issues` extension
    installed in VS Code, you can create your new pull request from within the VS
    Code IDE as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the VS Code Command Palette by pressing *Ctrl + Shift + P* (Windows or
    Linux) or *Cmd + Shift +* *P* (macOS).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Type `Github: Create Pull Request` and select the option from the list that
    appears.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the base and compare branches for your pull request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter a title and description for your pull request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Review your changes and make any necessary adjustments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Create Pull Request** button to submit your pull request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Addressing feedback and updating the pull request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Quite often, there can be feedback and changes required to your pull request
    during the review process. This is a normal part of the review process and helps
    to deliver quality releases to production by capturing changes early. Thankfully,
    addressing these changes is as easy as your original commits to Git were – let’s
    look at the steps required:'
  prefs: []
  type: TYPE_NORMAL
- en: If changes are requested during the review process, make the necessary updates
    in VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Commit and push the changes to the feature branch in the same way as you did
    for the original commit of your changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The pull request will automatically update with your new changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Merging the pull request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we reach the stage where our pull request has been approved and any required
    changes are complete, we can safely merge it into our upstream branch, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: Once the pull request has been approved, click the **Merge pull request** button
    in GitHub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the feature branch if it is no longer needed, either on GitHub or in
    VS Code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updating your local main branch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'All that remains for us to do now is to refresh our local copy of the main
    branch to ensure we have all the latest changes and everything is correctly in
    sync. The following steps will achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: In VS Code, switch back to the main branch by clicking the branch icon at the
    bottom-left corner and selecting **main**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pull the latest changes exactly as you did at the start of the process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have now completed a typical lifecycle of developing a Salesforce feature
    using SFDX and Git. This represents the most basic DevOps workflow – and in many
    teams, it can remain as simple as that.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’re going to look at some subtle differences between
    the most common Salesforce development environments – sandboxes and scratch orgs
    – and see the use cases for each.
  prefs: []
  type: TYPE_NORMAL
- en: Sandboxes versus scratch orgs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scratch orgs and Salesforce developer sandboxes serve similar purposes in providing
    environments for development and testing; however, they differ in several key
    aspects, which we will discuss here.
  prefs: []
  type: TYPE_NORMAL
- en: Sandboxes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Salesforce sandboxes are a copy of your Salesforce environment, including metadata
    and customizations. Sandboxes are typically used for testing and development purposes
    such as creating and testing new features, integrating with other systems, or
    replicating production issues. Developers can use sandboxes to test new features
    or customizations without affecting the production environment. Sandboxes can
    also be used for training and **user acceptance testing** (**UAT**) to ensure
    that changes are thoroughly tested before deployment. Additionally, sandboxes
    can be used for integration testing, disaster recovery, and as a backup in case
    of data loss or system failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Salesforce sandboxes are used for development and testing, and four different
    types are available, each with different features, purposes, refresh cycles, and
    storage limits:'
  prefs: []
  type: TYPE_NORMAL
- en: The Full Copy sandbox is a complete copy of your production environment, including
    all metadata and data. It is typically used for testing and development purposes
    that require a full replica of the production environment, such as performance
    testing, **UAT**, and training. However, you should be aware that these sandboxes
    can only be refreshed from production every 29 days. Full Copy sandboxes also
    don’t support source tracking, so they are not suited for being your primary development
    environment for SFDX.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Partial Copy sandbox includes a subset of your production environment data,
    as well as all metadata. It is typically used for testing and development purposes
    that require a smaller dataset than a Full Copy, such as feature development or
    regression testing. This type of sandbox is not provided as standard and is an
    additional license cost from Salesforce. Unlike the Full Copy sandbox, Partial
    Copy sandboxes can be refreshed every five days, but like the Full Copy sandboxes,
    they don’t support source tracking.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Developer sandbox is a dedicated environment for individual developers or
    small teams. It includes all metadata but no data. It is typically used for individual
    feature development or testing. Most orgs will have far more Developer sandboxes
    available than the Full Copy or Partial Copy ones (usually limited to one of each
    unless you purchase additional ones). They can be refreshed daily but don’t bring
    across any data, and have a much smaller data capacity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Developer Pro sandbox is similar to a Developer sandbox but has a larger
    storage capacity. It is typically used for more complex development and testing
    tasks, such as integrations or app development.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scratch orgs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scratch orgs are disposable, temporary environments that can be quickly created
    and deleted. They are primarily used for agile development, such as building and
    testing new features in a short amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: The lifespan of a scratch org is inherently temporary, with a maximum duration
    of 30 days. This ephemeral nature encourages developers to follow a source-driven
    development approach, where the version control system serves as the single source
    of truth. In contrast, Developer sandboxes are more persistent environments that
    may exist for extended periods, making it easier for developers to unintentionally
    accumulate outdated or unused code and configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Scratch orgs are designed to be lightweight and rapidly configurable. They can
    be created and customized with specific features, settings, and data needed for
    a particular project by adjusting the scratch org definition file. This makes
    it easy for developers to create multiple scratch orgs tailored to different projects
    or tasks. On the other hand, Developer sandboxes are created as a copy of the
    production environment, including all customizations and a subset of the data,
    which can make them less cumbersome and time-consuming to set up and configure.
  prefs: []
  type: TYPE_NORMAL
- en: By default, when a scratch org is created, it doesn’t have any connection to
    the features or metadata enabled in your production org. It’s created according
    to a generic template with a base set of features. This means that the newly created
    scratch org won’t reflect your production org’s specific characteristics or customization,
    which can be challenging if you’re developing and testing features tied to those
    specific settings or metadata.
  prefs: []
  type: TYPE_NORMAL
- en: To overcome this, Salesforce introduced the concept of a definition file. A
    definition file is a JSON file that specifies the shape of the scratch org or
    the characteristics that you want the scratch org to have. It can define preferences
    for features, settings, and editions. For example, the definition file might include
    instructions to enable certain Salesforce features, such as Einstein Analytics
    or person accounts.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a definition file manually allows you to tailor your scratch org to
    match your production environment. However, manually creating a definition file
    that exactly matches a complex production org can be time-consuming and potentially
    error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: To help with this, Salesforce has introduced the concept of an org shape. An
    org shape is essentially a snapshot of your production org’s features and settings,
    which you can use as a template when creating scratch orgs. By using an org shape,
    you can quickly and accurately recreate the environment of your production org
    in a scratch org without having to manually specify all the settings in a definition
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding combination of being short-lived, lightweight, and configurable
    means that scratch orgs are more conducive to supporting **continuous integration
    and continuous delivery** (**CI/CD**) processes. The disposable nature of scratch
    orgs allows developers to rapidly create, test, and destroy environments as needed,
    enabling seamless integration into CI/CD pipelines. Developer sandboxes, with
    their longer lifespan and more complex setup, may not be as well suited for such
    automated workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered an end-to-end lifecycle of using the standard stack
    of Salesforce and source control tools. Let’s recap what that process entailed.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at how to initialize or clone a Git repository to the local machine,
    ensuring we had the latest version of the code base. Using VS Code, we were able
    to easily access and manage the source code, as well as run SFDX commands within
    the integrated terminal or from the built-in Command Palette within VS Code and
    the Salesforce extensions pack.
  prefs: []
  type: TYPE_NORMAL
- en: Before starting the development process, we created a new branch in the Git
    repository to represent the specific feature or task we were working on. This
    branch is typically named according to the associated Jira ticket to maintain
    traceability and organization. Once the feature branch was created, we switched
    to the new branch and started implementing the required changes.
  prefs: []
  type: TYPE_NORMAL
- en: As part of the development process, we made use of SFDX tools to create, retrieve,
    and deploy metadata components. Although we used a sandbox environment in our
    example, we could also have leveraged scratch orgs – temporary Salesforce environments
    – to test and iterate on our changes before finalizing the code. Throughout this
    process, we committed our changes to the feature branch, providing clear and concise
    commit messages to maintain a comprehensive history.
  prefs: []
  type: TYPE_NORMAL
- en: Once the development was complete and the changes were thoroughly tested, we
    pushed the feature branch to the remote Git repository. At this point, we were
    then ready to create a pull request to merge the feature branch into the main
    branch. The pull request serves as an opportunity for team members to review the
    changes, provide feedback, and suggest improvements. It also acts as a quality
    assurance measure to ensure that the code base remains stable and maintains the
    desired level of quality.
  prefs: []
  type: TYPE_NORMAL
- en: Upon receiving approval from the team, we could then merge the feature branch
    into the main branch using the pull request. The main branch was then ready to
    be deployed to a staging or production environment for further testing and validation.
  prefs: []
  type: TYPE_NORMAL
- en: Once the deployment was successful, the feature branch could be deleted, both
    locally and on the remote repository, to maintain a clean and organized code base.
  prefs: []
  type: TYPE_NORMAL
- en: The use of pull requests, Jira ticket-based feature branches, and the collaborative
    review process ensures a high-quality, traceable, and maintainable code base throughout
    the Salesforce development lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: This entire workflow was achieved with freely available tools and provided the
    simplest entry point to a Salesforce DevOps process. As your needs grow, it will
    become more important to look at the power of automation, especially in the context
    of CI/CD.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at CI/CD in more detail in [*Chapter 7*](B19436_07.xhtml#_idTextAnchor159).
    Ahead of that, though, in the next chapter, we’ll take another approach to Salesforce
    change management by looking at packaging.
  prefs: []
  type: TYPE_NORMAL
