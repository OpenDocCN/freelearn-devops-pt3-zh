- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Talking about Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Language is the key to world peace. If we all spoke each other’s tongues, perhaps
    the scourge of war would be ended forever.
  prefs: []
  type: TYPE_NORMAL
- en: – Batman
  prefs: []
  type: TYPE_NORMAL
- en: The Python programming language was built on a set of principles that was meant
    to simplify coding in it. This simplification came at the cost of a lot of speed
    and performance compared to other programming languages but also produced a popular
    language that was accessible and easy to build in, with a massive library of built-in
    functions. All of these made Python very versatile and capable of being used in
    a myriad of situations, a programming Swiss army knife if you will. A perfect
    tool for a diverse discipline such as **DevOps**.
  prefs: []
  type: TYPE_NORMAL
- en: Beginners are recommended Python as a learning language because it is fairly
    simple, easy to pick up, and also used a fair amount in the industry (if it wasn’t,
    why would I be writing this book?). Python is also a great flexible programming
    language for hobbyists because of the same reasons as before, as well as the library
    support that it has for things such as OS automation, the internet of things,
    machine learning, and other specific areas of interest. At the professional level,
    Python has a lot of competition for market space, but this is largely because
    – at that level – smaller differences, legacy systems, and available skills count
    for something.
  prefs: []
  type: TYPE_NORMAL
- en: And that’s perfectly fine. We don’t need the entire market share for Python
    – that would be very boring and counterintuitive to innovation. In fact, I encourage
    you to try other languages and their concepts before returning to Python because
    that will help you find out a lot of things that Python makes easier for you and
    help you appreciate the abstraction that Python provides.
  prefs: []
  type: TYPE_NORMAL
- en: Python is the language of simplicity, and it is the language of conciseness.
    Often, you can write a piece of code in Python in one line that would have otherwise
    taken 10 lines in another language.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the things that I have stated are not the only reasons that Python is so
    popular in development and DevOps. In fact, one of the most important reasons
    for Python’s popularity is this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*{}*'
  prefs: []
  type: TYPE_NORMAL
- en: Yes, that. That is not a print error. That represents the JSON/dictionary format
    that carries data across the internet on practically every major modern system.
    Python handles that better than any other language and makes it easier to operate
    on than any other language. The base Python libraries are usually enough to fully
    unleash the power of JSON whereas in many other languages, it would require additional
    libraries or custom functions.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you might ask, “Can’t I install those libraries? What’s the big deal?”
    Well, understanding the big deal comes from working with this type of data and
    understanding that not every programming language that you use has grown to emphasize
    the importance of these two brackets and how much of a problem that can become
    in modern DevOps/the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I will provide a basic refresher for Python and give you some
    Python knowledge that is practical, hands-on, and useful in the DevOps field.
    It will not be all of the Python programming language, because that is a massive
    topic and not the focus of this book. We will only focus on the aspects of the
    Python programming language that are useful for our work.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s list out what we are going to cover here:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of Python through the philosophical ideas of its creators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How Python can support DevOps practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some examples to support these points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python 101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is – as I have said before – a simple language to pick up. It is meant
    to be readable by the layperson and the logic of its code is meant to be easily
    understandable. It is because of this fact that everything from installing Python
    to configuring it in your OS is probably the smoothest installation process out
    of any of the major programming languages. The barrier of entry is next to zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if you want to declare a variable and other basic stuff, start from the
    following figure and figure it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Declaring and manipulating variables](img/B21320_02_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Declaring and manipulating variables
  prefs: []
  type: TYPE_NORMAL
- en: This section will be focused on the philosophy of Python because that is what
    will be important in your journey toward using Python in DevOps. Once you understand
    the underlying philosophies, you will understand why Python and DevOps are such
    a perfect match.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, we can find that similarity in the `import this`, you’ll see the 19
    lines of Zen. Odd number, you say? It’s an interesting story.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if you haven’t seen it before, I’m going to list it out here for posterity:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Beautiful is better* *than ugly.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Explicit is better* *than implicit.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Simple is better* *than complex.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Complex is better* *than complicated.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Flat is better* *than nested.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Sparse is better* *than dense.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Readability counts.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Special cases aren’t special enough to break* *the rules.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Although practicality* *beats purity.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Errors should never* *pass silently.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Unless* *explicitly silenced.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*In the face of ambiguity, refuse the temptation* *to guess.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*There should be one-- and preferably only one --obvious way to* *do it.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Although that way may not be obvious at first unless* *you’re Dutch.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Now is better* *than never.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Although never is often better than ***right* now.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*If the implementation is hard to explain, it’s a* *bad idea.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*If the implementation is easy to explain, it may be a* *good idea.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*Namespaces are one honking great idea -- let’s do more* *of those!*'
  prefs: []
  type: TYPE_NORMAL
- en: (*Tim Peters, 1999, The Zen of* *Python,* [https://peps.python.org/pep-0020/#the-zen-of-python](https://peps.python.org/pep-0020/#the-zen-of-python))
  prefs: []
  type: TYPE_NORMAL
- en: The reason I’m laying this out for you right now is so that I can give you examples
    of how these principles have become a part of the fully evolved Python language.
    I am going to do this in pairs. Except for that last one. These rules and their
    implementations will provide you with the appropriate boundaries that you need
    to write decent Python code.
  prefs: []
  type: TYPE_NORMAL
- en: Beautiful-ugly/explicit-implicit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start with beauty. They say beauty is in the eye of the beholder. And
    this is why, when you behold improperly indented code, you begin to understand
    the beauty of actually indented code. Here is the same code written correctly
    in JavaScript and Python:'
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Python:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The JavaScript code works, by the way. It does the same thing that the Python
    code does. You could write all of the scripts for JavaScript on a single line
    if you wanted to (and when you build JS frontends, sometimes you do to save space).
    But which one can you read better? Which one breaks down the information in a
    better way for you? Python forces this syntax due to its removal of semi-colons
    in favor of indentations as a way to separate code lines, making the code more
    objectively *beautiful*.
  prefs: []
  type: TYPE_NORMAL
- en: 'But something is missing. You may understand the fact that the code is clear
    and concise, but you might not understand the code. This is where we must be explicit,
    in the definition of the code and its variables. Python encourages comments describing
    every code block as well as a defined structure when it comes to assigning variables.
    `snake_case`) is used for variables and uppercase snake case is used for constants.
    Let’s re-write our Python code following these guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You don’t need to do this for every line; I’m just being a little more explicit
    than usual for posterity. But this is the basic way to define variables and comments.
    No more of that *i*, *j*, and *k* stuff. Be kind and be defined.
  prefs: []
  type: TYPE_NORMAL
- en: Definition simplifies things, which is what we are going to discuss in this
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Simple-complex-complicated
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Simplicity must be maintained wherever possible. That is the rule because, well,
    it’s easier that way. Keeping things simple, however, is hard. It’s impossible
    sometimes. As an application or a solution becomes greater in size, the complexity
    becomes greater too. What we do not want is for the code to become complicated.
  prefs: []
  type: TYPE_NORMAL
- en: What’s the difference between complex and complicated? Code is complex when
    it is written to sustainably deal with all the scenarios presented before it dynamically
    and understandably. Code is complicated when (in a complex solution) it is written
    in a way that handles every possible case based on static, very specific parameters
    (hard coding) and in a way that becomes difficult to understand, even for the
    person who wrote it.
  prefs: []
  type: TYPE_NORMAL
- en: I have seen a lot of it over my career; I wrote a lot of it at the beginning,
    too. It’s a learning process and if you don’t build good habits, you will fall
    into bad habits or fall back to a simpler solution for a more complex problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once, when reviewing an old `JSONResponse` function. It was baffling, and I
    couldn’t help but think about why someone would write the code this way, until
    I found out that the person who had written it had had no previous web development
    expertise and was instead a data engineer. So, they reverted to what their vision
    of simplicity was: data science libraries, even for backend development.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, this slowed down the application immensely and, of course, had to be refactored,
    but – since we are blameless on individuals in this book – we couldn’t blame the
    developer. We have to blame the habits that they fall back on and the simplicity
    they seek that eventually results in complicated code, when a slightly more complex
    yet concise solution would have resulted in better code.
  prefs: []
  type: TYPE_NORMAL
- en: Flat-nested/sparse-dense
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The part about flat being better than nested, in particular, is a reason for
    those famous one-line Python codes that you see. Simple code shouldn’t have to
    span across 20-30 lines when it can be done in a few. In a lot of languages, it
    cannot be done in a few lines, but in Python, it can.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s test out this concept when printing each value for this array: `my_list
    = [``1,2,3,4,5]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Flat** **and sparse** | **Nested** **and dense** |'
  prefs: []
  type: TYPE_TB
- en: '| `print(*my_list)` | `for element in` `my_list: print(element)` |'
  prefs: []
  type: TYPE_TB
- en: Table 2.1 – Flat and sparse versus nested and dense
  prefs: []
  type: TYPE_NORMAL
- en: Again, a very small example, but one of many present in the Python language.
    I recommend going through the list of libraries that Python comes pre-installed
    with; it is a very interesting read and will help you come up with a lot of ideas.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of the time, this flat and sparse concept reduces the amount of code written
    by a significant amount. In turn, this makes the code more readable just from
    the reduced time it takes to read the code.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dive into readability and the purity of the concept.
  prefs: []
  type: TYPE_NORMAL
- en: Readability-special cases-practicality-purity-errors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Python is meant to be a language that can be read and understood at some level
    by the layperson. It doesn’t require any particularly special syntax and even
    the one-liners can be interpreted quite easily. Readability counts, and there
    are no special cases that are special enough to violate this credo. I have already
    expressed both philosophies through the previous examples, so there is no need
    to reiterate them here.
  prefs: []
  type: TYPE_NORMAL
- en: Practicality over purity is a fairly simple concept. Often, trying to follow
    best practices too strictly simply results in a waste of time. Sometimes, the
    best way to do something is to do it and then explain it later. However, in such
    cases, make sure that your boldness doesn’t result in something that might break
    the system. In that case, **try-catch error handling** is your best friend. It
    also helps to pass errors silently when you need it to.
  prefs: []
  type: TYPE_NORMAL
- en: Balance between the two – progress and verification – results in code that has
    been verified and tested, but also code that is actually shipped to the end user.
    This balance is integral to any successful project. You have to be pragmatic when
    you are doing actual work, but you also have to realize that other people may
    not be so pragmatic in their actions and their estimates.
  prefs: []
  type: TYPE_NORMAL
- en: To take action in either direction, pragmatism or purity requires a sense of
    direction. It requires deciding something or some way and sticking to it.
  prefs: []
  type: TYPE_NORMAL
- en: Ambiguity/one way/Dutch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Anyone who has ever worked with clients knows how demoralizing and frustrating
    a vague requirement is. “*Do this, do that, we need this*” – that’s all you hear,
    without any understanding from the other side or respect for how the process works.
    They have a certain goal in mind, and they don’t care how you get there. That’s
    fine for machines (and we’ll learn how to do some of that), but for work done
    by people (and especially for coding work), that is not the way. You need to know
    exactly what is required so that you can do it precisely.
  prefs: []
  type: TYPE_NORMAL
- en: A lot of the time, even the clients don’t know what they want; they have a vague
    idea that they want to act upon, but nothing beyond that. This ambiguity needs
    to be sorted out at the beginning of the project and it certainly should never
    spread to the code. Once something has been defined, then there is a way to do
    it that is the fastest, most secure, or most convenient (depending on requirements).
    This is the way that you need to find.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, again, how do you find this way? It is not obvious to anyone who is not
    Dutch (a reference to the Dutch programmer Guido Van Rossum, the original author
    of Python). So, if you’re Dutch, you’re fine. If you’re not, read this story (it’s
    a much better fit for these principles than regular code):'
  prefs: []
  type: TYPE_NORMAL
- en: '*Three friends were stranded on a boat with no food or water. These friends
    only had in their possession a lamp that seemed to be empty. One of the friends
    decided to rub the lamp, which caused a genie to appear. The genie granted each
    of the friends one wish since they had all summoned* *him together.*'
  prefs: []
  type: TYPE_NORMAL
- en: '*The first friend made his wish: “I wish to be sent to my wife and children.”
    The wish was granted, and the friend disappeared, having been sent back to his
    family. The second friend wished to be sent back to his house in his hometown.
    This wish was similarly granted. The third friend, a loner, had nowhere he could
    think to go nor no one he could think to go to, so when his turn came, he said:
    “I wish I had my friends* *with me.”*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, this is an old story, but the way most people interpret it is that the
    friends were forcibly put back onto the boat by the third friend’s wish: a classic
    tale of *be careful what you wish for*. However, an engineer can read the story
    and come up with some other possible scenarios. Maybe the third wish brought back
    more than those two people (if he had more than two friends); maybe it brought
    back no one (if the other two weren’t considered friends, that would be a sad
    turn to the story), or it could even lead to an argument over what a friend is.'
  prefs: []
  type: TYPE_NORMAL
- en: But most programming languages are like the genie. It does exactly what you
    tell it to do. If you’re vague, the room you give it for interpretation can cost
    you, so be careful and only wish for the exact thing you want. And people (such
    as our previous clients) are like, well, the people. They sometimes know what
    they want, they sometimes do not. But, to succeed, they need to know precisely
    what they want in both the context of the goal (getting home) and the context
    of the rules that govern them (they could’ve let the third friend go first if
    they doubted his intentions). This is quite a conundrum, isn’t it?
  prefs: []
  type: TYPE_NORMAL
- en: The key here – and this is something DevOps and **Agile methodologies** preach
    as well – is continuous improvement. Trying to continually find that one way.
    And if the scenario changes, tweaking the way to that scenario. This strategy
    is essential in coding, DevOps, machine learning, and practically every technology
    field. Iterative methodology helps turn even the vaguest goal into a bold mission
    statement and can provide unified direction.
  prefs: []
  type: TYPE_NORMAL
- en: The Dutch are a very direct people; only they could have invented a language
    as head-first as Python. Speaking of direct, you should probably read the next
    section now … or never, if you don’t have the time right now (see what I did there?).
  prefs: []
  type: TYPE_NORMAL
- en: Now or never
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is another one of those principle pairs that is more about the method of
    writing than the writing itself. The statements of *now* being better than *never*
    but *never* being better than *right now* may seem somewhat paradoxical, but they
    describe the nature of writing code and delivering value through it.
  prefs: []
  type: TYPE_NORMAL
- en: '*Now* doesn’t mean *right this second*. It is meant to represent the near future
    and in that near future, the code we have written has delivered value. This is
    opposed to never releasing the code at all or releasing it in an unrealistically
    long timeframe, by the end of which the written code might become irrelevant.
    As Steve Jobs used to say:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Real* *artists ship*.'
  prefs: []
  type: TYPE_NORMAL
- en: However, *right now* is also never a good time. To release something too early,
    with no thought put into it, no understanding, and no game plan, can result in
    disaster. The basic lesson there is to look before you leap. And if you leap into
    a volcano, you probably didn’t do your due diligence.
  prefs: []
  type: TYPE_NORMAL
- en: One of the reasons that *right now* is looked at as not a good time is because
    right now, there are no good ideas. There are never any good ideas right now;
    you kind of have to wait for your brain to come up with one. You push too hard
    trying to get something through that is hard to explain – that is a bad idea.
    That is how we can explain all the stupid trades that general managers make in
    sports at the trade deadline.
  prefs: []
  type: TYPE_NORMAL
- en: Hard-bad/easy-good
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you’re having a hard time explaining something, it is probably a bad idea.
    There’s not much to explain there – that’s just common sense. A complex vision
    is no vision at all. It needs to be reduced, simplified, and shaped into something
    that most people can understand (or at least work toward).
  prefs: []
  type: TYPE_NORMAL
- en: An idea that is complicated is simply an idea that hasn’t been reduced to its
    most useful, simplest component yet. As the old adage goes, there is always a
    ratio of 20% of the effort producing 80% of the output. To create the good idea,
    we just need to bring out and work on that 20%.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The lone zen, `lib1` and `lib2`, both containing methods named `example`. What
    would be the solution that allows both of the methods to be imported into one
    Python file? You can just change one or both of their names to unique namespaces:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Code without namespaces:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Code with namespaces:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A honking great idea indeed.
  prefs: []
  type: TYPE_NORMAL
- en: Through these principles, you can observe how Python has evolved into the language
    that it is and how it has distinguished itself from all the other programming
    languages. These changes have also helped make Python a language that aligns itself
    with DevOps principles. So, let’s now observe the marriage between the principles
    behind Python and DevOps and how they are mutually beneficial to each other.
  prefs: []
  type: TYPE_NORMAL
- en: What Python offers DevOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we focused on the principles of Python. Now, we are
    going to look into what following those principles offers DevOps as a practice
    and DevOps engineers in general. The principles behind DevOps and Python are more
    similar than they are different. They both share an emphasis on flexibility, automation,
    and conciseness. This makes Python and DevOps a perfect pairing in the field of
    DevOps. Even for DevOps professionals who may not have the sharpest coding skills,
    Python is easy to pick up, easy to use, and can be integrated with practically
    every tool and platform because almost all these platforms have native support
    and libraries in Python.
  prefs: []
  type: TYPE_NORMAL
- en: I previously stated that the reason that Python is so pervasive in DevOps is
    that it handles data that resides between curly brackets (*{}*) better than almost
    any other language. The offerings of Python for DevOps are numerous and will be
    covered in further detail in future chapters. Right now, we will go over some
    of these offerings in brief.
  prefs: []
  type: TYPE_NORMAL
- en: Operating systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Python has native libraries that interact with the OS of any server that it
    is currently working on. These libraries allow for programmatic access to various
    OS processes. This is especially useful when you work with virtual machines on
    the cloud (such as with **Amazon EC2**). You can do things such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Set environment variables in the OS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get information about files or directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulate, create, or delete files and directories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kill or spawn processes and threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create temporary files and file locations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run Bash scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OSs are nice and all, but they can be difficult to maintain in a desired state
    with ideal resource usage. For this challenge, we have a common solution in containerization.
  prefs: []
  type: TYPE_NORMAL
- en: Containerization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Containers** are made using the **Docker** library. The creation, destruction,
    and modification of containers can be automated and orchestrated using Python.
    It provides a way to programmatically maintain and modify container states. Some
    applications include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Interaction with Docker API for commands, such as getting a list of Docker containers
    or images present in the OS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatically generating **Docker Compose files** from a list of Docker images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building Docker images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Orchestrating containers using the **Kubernetes library**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing and verifying Docker images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may be wondering what the point of containers is, and that may be because
    you’ve never gotten tired of the constant online discourse over OSs and frameworks
    and which ones are superior (in fact, you may have even encouraged such malarkey).
    But, containers exist for those who tire of such debate and instead want isolated
    environments for all their specific operating needs. So they made one with containers,
    and someone had the bright idea to call them microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, containers and **microservices** are used interchangeably, but in
    modern DevOps that is not necessarily the case. Yes, it is containers that make
    microservices possible, but t the overall writing of microservices on top of those
    containers is efficient code that has the most bang for its buck. Some reasons
    for Python use in microservices are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Strong native library support inside of a Python container – libraries such
    as **json**, **asyncio**, and **subprocess**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Excellent native code modules that simplify certain iterative and manipulative
    operations on data such as the `collection` module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ability to properly natively handle semi-structured and varied JSON data that
    is usually used in microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To have these microservices interact with each other effectively and consistently,
    we need some repetition, some consistent repetition. What’s the word I’m looking
    for ... automaton ... no, that’s a robot ... autograph ... no, that’ll be what
    I do once this book becomes a bestseller ... automation, yes, that’s the word.
    Automation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Automation** is probably the primary selling point for DevOps engineers when
    it comes to Python because of its incredible **automation library** and support
    features. Most systems guys who transition to DevOps prefer their precious **Bash
    scripting**, and that does have a place in environments such as these, but Python
    is more powerful and more flexible, and it is better supported by the community
    and the companies in the industry overall. Some applications of Python for automation
    in this case would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Various **Software Development Kits** (**SDKs**) for cloud-based deployments
    in **AWS**, **Azure**, **Google Cloud**, and other providers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for automated building and testing of applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for monitoring applications and sending notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for parsing and scraping necessary data from web pages, databases, and
    various other sources of data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have talked the talk, let’s walk a little. A light jog to combine
    Python and DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: A couple of simple DevOps tasks in Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have so far preached to you the virtues of DevOps and the virtues of Python
    but so far, I have shown you very little of how the two work together. Now, we
    get to that part. Here, I will demonstrate a couple of examples of how to use
    Python to automate some regular DevOps tasks that some engineers may have to perform
    on a daily basis. These two examples will be from AWS, though they are applicable
    in other big clouds as well and can be applied on most data center servers if
    you have the right APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this chapter and all future chapters are stored in this repository:
    [https://github.com/PacktPublishing/Hands-On-Python-for-DevOps](https://github.com/PacktPublishing/Hands-On-Python-for-DevOps)'
  prefs: []
  type: TYPE_NORMAL
- en: Automated shutdown of a server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Oftentimes, there is the case of certain servers that only need to be up during
    working hours and then need to be switched off afterward. Now, this particular
    scenario has a lot of caveats, which include the platform used, the accounts where
    the servers are running, and how working hours are measured…but for this scenario,
    we are simply going to shut our EC2 servers down in an AWS account using an **AWS
    Lambda** function microservice that runs a Python script that leverages the **boto3
    library**. That sounds like a lot? Let’s break it down.
  prefs: []
  type: TYPE_NORMAL
- en: 'In my AWS account, I have two EC2 instances running. Every second that they
    run costs me money. However, I need them during business hours. Here they are:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Running instances](img/B21320_02_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Running instances
  prefs: []
  type: TYPE_NORMAL
- en: Creatively named, I know. But they are running, and there will come a point
    in time when I want them to not be running. So, to achieve that, I need to find
    some way to stop them. I could stop them one by one, but that’s tedious. And would
    I still do that if these 2 instances were 1,000 instances? No. So, we need to
    find another way.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could try the **command-line interface** (**CLI**), but this is a coding
    book and not a CLI book, so we won’t. Though, keep it in mind if you want to try
    it. So, let’s look to our old friend Python, and also to a service that allows
    you to deploy a function that you can call at any time, called AWS Lambda. Here
    are the steps to create a Lambda function and use it to start and stop an EC2
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a function called `stopper` with the latest available Python runtime
    (3.10 for this book):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Creating a Lambda function](img/B21320_02_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Creating a Lambda function
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will either have to create an execution role for the Lambda function
    or give it an existing one. This will be important later. But for now, do the
    one you prefer. Click `boto3` library by default, which is very useful for resource
    interaction.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before we can start or stop any instance, we need to list them out. You have
    to load and dump the return function once to handle the `datetime` data type.
    For now, let’s just initialize the `boto3` client for EC2 and try and list all
    of the instances that are currently available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Initial code to describe instances](img/B21320_02_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Initial code to describe instances
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this with a test will get you an exception thrown similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Authorization exception](img/B21320_02_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Authorization exception
  prefs: []
  type: TYPE_NORMAL
- en: That is because the Lambda function also has an **identity and access management**
    (**IAM**) role, and that role does not have the required permissions to describe
    the instances. So, let’s set the permissions that we may need.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following figure, under **Configuration** | **Permissions**,
    you will find the role assigned to the Lambda function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Finding the role for permissions](img/B21320_02_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – Finding the role for permissions
  prefs: []
  type: TYPE_NORMAL
- en: 'On the page for the role, go to **Add permissions** and then **Attach policies**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Attaching a permission](img/B21320_02_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Attaching a permission
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s give the Lambda function full access to the EC2 services since we will
    need it to stop the instance as well. If you prefer or if you feel that’s too
    much access, you can make a custom role:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Attaching the appropriate permission](img/B21320_02_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – Attaching the appropriate permission
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run this again and see the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Successful code run](img/B21320_02_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – Successful code run
  prefs: []
  type: TYPE_NORMAL
- en: You’ll see the display of instances as well as information regarding whether
    they are running or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s get to the part where we shut down the running instances. Add code
    to filter among the instances for ones that are running and get a list of their
    IDs, which we will use to reference the instances we want to stop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Adding code that stops the instances](img/B21320_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – Adding code that stops the instances
  prefs: []
  type: TYPE_NORMAL
- en: Simple enough to understand, especially if we are following the principle of
    readability and explicitness.
  prefs: []
  type: TYPE_NORMAL
- en: 'The instances are now in a state where they are shutting down. And soon, they
    will be stopped:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – Shut down instances](img/B21320_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – Shut down instances
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have done it once, let’s automate it further by using a service
    called EventBridge, which can trigger that function every day. Navigate to **Amazon
    EventBridge** and make an EventBridge schedule:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.12 – Setting up a cron job on EventBridge](img/B21320_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – Setting up a cron job on EventBridge
  prefs: []
  type: TYPE_NORMAL
- en: 'Select our Lambda function as the event target:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.13 – Selecting Lambda to invoke for EventBridge](img/B21320_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 – Selecting Lambda to invoke for EventBridge
  prefs: []
  type: TYPE_NORMAL
- en: You can now create the EventBridge scheduled event, which will trigger at 8
    P.M. every day and list and shut down your EC2 instances.
  prefs: []
  type: TYPE_NORMAL
- en: So, in following these steps, you now have the tools necessary to schedule the
    shutdown of instances based on the timed schedule that you want.
  prefs: []
  type: TYPE_NORMAL
- en: Autopull a list of Docker images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Grabbing Docker images can be tedious. Especially grabbing multiple images.
    So now, we are going to see how we can pull a number of Docker images at the same
    time using the Python library for Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install the Docker Python library in a virtual environment using the
    following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, write a script in a file called `docker_pull.py` to loop through a list
    of image names and pull them by leveraging the Docker library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.14 – Code to pull Docker images](img/B21320_02_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.14 – Code to pull Docker images
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, run the file using this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 2.15 – List of Docker images](img/B21320_02_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.15 – List of Docker images
  prefs: []
  type: TYPE_NORMAL
- en: So, this gives you a pretty nifty way to get the Docker containers you want
    with the tags that you want on them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is not just about writing code; it is about a coding philosophy – a philosophy
    that has made Python incredibly popular among DevOps engineers. The writing of
    the Zen of Python affected the way that the language was developed, and we still
    see the consequences today in both Python and DevOps. Python’s philosophy offers
    the DevOps realm the programming language that fits its philosophy.
  prefs: []
  type: TYPE_NORMAL
- en: Python has numerous uses that facilitate a lot of DevOps tasks. So, hopefully,
    this chapter has given you some insights into what makes Python such a good companion
    for DevOps. In the next chapter, you will see that companionship in action and
    learn how to use your knowledge in a truly hands-on way.
  prefs: []
  type: TYPE_NORMAL
