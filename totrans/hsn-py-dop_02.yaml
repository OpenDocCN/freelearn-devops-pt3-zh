- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Talking about Python
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 说到 Python
- en: Language is the key to world peace. If we all spoke each other’s tongues, perhaps
    the scourge of war would be ended forever.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 语言是世界和平的关键。如果我们都能说彼此的语言，也许战争的祸害将永远结束。
- en: – Batman
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: – 蝙蝠侠
- en: The Python programming language was built on a set of principles that was meant
    to simplify coding in it. This simplification came at the cost of a lot of speed
    and performance compared to other programming languages but also produced a popular
    language that was accessible and easy to build in, with a massive library of built-in
    functions. All of these made Python very versatile and capable of being used in
    a myriad of situations, a programming Swiss army knife if you will. A perfect
    tool for a diverse discipline such as **DevOps**.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Python 编程语言是基于一套原则构建的，这些原则旨在简化编程。与其他编程语言相比，这种简化的代价是牺牲了许多速度和性能，但也因此产生了一种易于访问和构建的流行语言，拥有庞大的内置函数库。所有这些都使得
    Python 非常多才多艺，能够在多种情况下使用，堪称编程界的瑞士军刀。如果你愿意，可以说它是 **DevOps** 这样的多样化学科的完美工具。
- en: Beginners are recommended Python as a learning language because it is fairly
    simple, easy to pick up, and also used a fair amount in the industry (if it wasn’t,
    why would I be writing this book?). Python is also a great flexible programming
    language for hobbyists because of the same reasons as before, as well as the library
    support that it has for things such as OS automation, the internet of things,
    machine learning, and other specific areas of interest. At the professional level,
    Python has a lot of competition for market space, but this is largely because
    – at that level – smaller differences, legacy systems, and available skills count
    for something.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 初学者推荐 Python 作为学习语言，因为它相对简单，容易上手，并且在行业中使用广泛（如果不是，为什么我要写这本书呢？）。Python 还是一个非常适合爱好者的灵活编程语言，原因和之前一样，还有它在操作系统自动化、物联网、机器学习以及其他特定兴趣领域中的库支持。在专业领域，Python
    面临着很多市场竞争，但这在很大程度上是因为——在那个层次上——较小的差异、遗留系统和可用技能都很重要。
- en: And that’s perfectly fine. We don’t need the entire market share for Python
    – that would be very boring and counterintuitive to innovation. In fact, I encourage
    you to try other languages and their concepts before returning to Python because
    that will help you find out a lot of things that Python makes easier for you and
    help you appreciate the abstraction that Python provides.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 而且这完全没问题。我们不需要 Python 占据整个市场份额——那样会非常无聊且不符合创新的直觉。事实上，我鼓励你在回到 Python 之前，尝试其他语言及其概念，因为那样能帮助你发现
    Python 带给你的许多便利，并帮助你更好地理解 Python 提供的抽象。
- en: Python is the language of simplicity, and it is the language of conciseness.
    Often, you can write a piece of code in Python in one line that would have otherwise
    taken 10 lines in another language.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Python 是简单的语言，它也是简洁的语言。通常，你可以用一行 Python 代码完成其他语言中需要 10 行的代码。
- en: 'All the things that I have stated are not the only reasons that Python is so
    popular in development and DevOps. In fact, one of the most important reasons
    for Python’s popularity is this:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我所陈述的所有理由并不是 Python 在开发和 DevOps 中如此受欢迎的唯一原因。事实上，Python 流行的最重要原因之一是：
- en: '*{}*'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '*{}*'
- en: Yes, that. That is not a print error. That represents the JSON/dictionary format
    that carries data across the internet on practically every major modern system.
    Python handles that better than any other language and makes it easier to operate
    on than any other language. The base Python libraries are usually enough to fully
    unleash the power of JSON whereas in many other languages, it would require additional
    libraries or custom functions.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对，就是那个。那不是打印错误。它代表了 JSON/字典格式，用于在几乎所有现代主要系统上跨越互联网传递数据。Python 处理它比任何其他语言都要好，并且使得操作起来比其他语言更简单。基础的
    Python 库通常足以充分释放 JSON 的潜力，而在许多其他语言中，可能需要额外的库或自定义函数。
- en: Now, you might ask, “Can’t I install those libraries? What’s the big deal?”
    Well, understanding the big deal comes from working with this type of data and
    understanding that not every programming language that you use has grown to emphasize
    the importance of these two brackets and how much of a problem that can become
    in modern DevOps/the cloud.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可能会问：“我不能安装那些库吗？这有什么大不了的？”嗯，理解其中的重要性来自于与这类数据打交道，并且理解并非每一种编程语言都会特别强调这两个括号的重要性，以及它们在现代
    DevOps/云计算中可能带来的问题。
- en: In this chapter, I will provide a basic refresher for Python and give you some
    Python knowledge that is practical, hands-on, and useful in the DevOps field.
    It will not be all of the Python programming language, because that is a massive
    topic and not the focus of this book. We will only focus on the aspects of the
    Python programming language that are useful for our work.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将提供Python的基础复习，并给你一些在DevOps领域实用的Python知识。这里不会涵盖所有Python编程语言的内容，因为那是一个庞大的话题，并且不是本书的重点。我们将只关注Python编程语言中对我们工作有用的部分。
- en: 'So, let’s list out what we are going to cover here:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们列出我们在这里将要涵盖的内容：
- en: The basics of Python through the philosophical ideas of its creators
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过其创造者的哲学思想来理解Python的基础
- en: How Python can support DevOps practices
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python如何支持DevOps实践
- en: Some examples to support these points
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些支持这些观点的例子
- en: Python 101
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 101
- en: Python is – as I have said before – a simple language to pick up. It is meant
    to be readable by the layperson and the logic of its code is meant to be easily
    understandable. It is because of this fact that everything from installing Python
    to configuring it in your OS is probably the smoothest installation process out
    of any of the major programming languages. The barrier of entry is next to zero.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Python是——正如我之前所说——一种很容易上手的语言。它的设计旨在让普通人也能阅读，而且其代码逻辑也容易理解。正是因为这个事实，从安装Python到在操作系统中配置它，可能是所有主要编程语言中最顺利的安装过程。入门的门槛几乎为零。
- en: 'So, if you want to declare a variable and other basic stuff, start from the
    following figure and figure it out:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你想声明一个变量和做其他基本操作，从下图开始并搞清楚：
- en: '![Figure 2.1 – Declaring and manipulating variables](img/B21320_02_1.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – 声明和操作变量](img/B21320_02_1.jpg)'
- en: Figure 2.1 – Declaring and manipulating variables
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – 声明和操作变量
- en: This section will be focused on the philosophy of Python because that is what
    will be important in your journey toward using Python in DevOps. Once you understand
    the underlying philosophies, you will understand why Python and DevOps are such
    a perfect match.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将专注于Python的哲学，因为这将是你在DevOps中使用Python旅程中的关键。理解了这些基本哲学后，你将明白为什么Python和DevOps是如此完美的搭配。
- en: In fact, we can find that similarity in the `import this`, you’ll see the 19
    lines of Zen. Odd number, you say? It’s an interesting story.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们可以在`import this`中找到这种相似性，你会看到19行“Python之禅”。你说是奇数行？这是一个有趣的故事。
- en: 'So, if you haven’t seen it before, I’m going to list it out here for posterity:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你以前没见过，我将把它列出来，以便后代留存：
- en: '*Beautiful is better* *than ugly.*'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '*美丽总比丑陋* *更好。*'
- en: '*Explicit is better* *than implicit.*'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*显式优于隐式。*'
- en: '*Simple is better* *than complex.*'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*简单优于复杂。*'
- en: '*Complex is better* *than complicated.*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*复杂优于复杂化。*'
- en: '*Flat is better* *than nested.*'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '*平坦优于嵌套。*'
- en: '*Sparse is better* *than dense.*'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '*稀疏总比密集* *更好。*'
- en: '*Readability counts.*'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*可读性很重要。*'
- en: '*Special cases aren’t special enough to break* *the rules.*'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '*特例不足以打破* *规则。*'
- en: '*Although practicality* *beats purity.*'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管实用性* *胜过纯粹性。*'
- en: '*Errors should never* *pass silently.*'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*错误不应该* *默默地通过。*'
- en: '*Unless* *explicitly silenced.*'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*除非* *明确禁止。*'
- en: '*In the face of ambiguity, refuse the temptation* *to guess.*'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*面对模糊时，拒绝* *猜测的诱惑。*'
- en: '*There should be one-- and preferably only one --obvious way to* *do it.*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*应该有一种——最好只有一种——明显的方式* *去做这件事。*'
- en: '*Although that way may not be obvious at first unless* *you’re Dutch.*'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '*虽然那条路一开始可能不明显，除非* *你是荷兰人。*'
- en: '*Now is better* *than never.*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*现在比永远* *更好。*'
- en: '*Although never is often better than ***right* now.*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*尽管“永远”通常比***现在就*做*更好。*'
- en: '*If the implementation is hard to explain, it’s a* *bad idea.*'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果实现很难解释，那就是* *一个坏主意。*'
- en: '*If the implementation is easy to explain, it may be a* *good idea.*'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果实现容易解释，那可能是* *一个好主意。*'
- en: '*Namespaces are one honking great idea -- let’s do more* *of those!*'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '*命名空间是一个非常棒的主意——让我们做更多* *这样的事情！*'
- en: (*Tim Peters, 1999, The Zen of* *Python,* [https://peps.python.org/pep-0020/#the-zen-of-python](https://peps.python.org/pep-0020/#the-zen-of-python))
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: (*Tim Peters, 1999，《Python之禅》，* [https://peps.python.org/pep-0020/#the-zen-of-python](https://peps.python.org/pep-0020/#the-zen-of-python))
- en: The reason I’m laying this out for you right now is so that I can give you examples
    of how these principles have become a part of the fully evolved Python language.
    I am going to do this in pairs. Except for that last one. These rules and their
    implementations will provide you with the appropriate boundaries that you need
    to write decent Python code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我现在给你讲这些，是为了举例说明这些原则是如何成为成熟的 Python 语言的一部分的。我将以一对一对的形式来做这件事。除了最后一条。这些规则及其实现将为你提供编写良好
    Python 代码所需的适当界限。
- en: Beautiful-ugly/explicit-implicit
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 美丑/显式隐式
- en: 'Let’s start with beauty. They say beauty is in the eye of the beholder. And
    this is why, when you behold improperly indented code, you begin to understand
    the beauty of actually indented code. Here is the same code written correctly
    in JavaScript and Python:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从美开始。人们说美在于观者的眼中。这也是为什么，当你看到缩进不当的代码时，你就开始理解正确缩进代码的美感。下面是用 JavaScript 和 Python
    正确写的相同代码：
- en: 'JavaScript:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'JavaScript:'
- en: '[PRE0]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Python:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Python:'
- en: '[PRE1]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The JavaScript code works, by the way. It does the same thing that the Python
    code does. You could write all of the scripts for JavaScript on a single line
    if you wanted to (and when you build JS frontends, sometimes you do to save space).
    But which one can you read better? Which one breaks down the information in a
    better way for you? Python forces this syntax due to its removal of semi-colons
    in favor of indentations as a way to separate code lines, making the code more
    objectively *beautiful*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一下，JavaScript 代码是有效的。它和 Python 代码做的是一样的事情。如果你愿意，你可以把所有的 JavaScript 脚本写在一行中（而且在构建
    JS 前端时，有时为了节省空间你确实会这么做）。但是，哪一个你能读得更好？哪一个将信息更好地呈现给你？Python 强制使用这种语法，去掉了分号，取而代之的是通过缩进来分隔代码行，这使得代码在客观上更
    *优美*。
- en: 'But something is missing. You may understand the fact that the code is clear
    and concise, but you might not understand the code. This is where we must be explicit,
    in the definition of the code and its variables. Python encourages comments describing
    every code block as well as a defined structure when it comes to assigning variables.
    `snake_case`) is used for variables and uppercase snake case is used for constants.
    Let’s re-write our Python code following these guidelines:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，有些东西缺失了。你可能理解了代码是清晰和简洁的，但你可能不理解代码。这时我们必须在代码的定义及其变量的定义上变得显式。Python 鼓励在每个代码块中使用注释，并且在给变量赋值时采用明确的结构。`snake_case`
    用于变量，且大写蛇形命名法（UPPER_SNAKE_CASE）用于常量。让我们按照这些指导原则重新编写我们的 Python 代码：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You don’t need to do this for every line; I’m just being a little more explicit
    than usual for posterity. But this is the basic way to define variables and comments.
    No more of that *i*, *j*, and *k* stuff. Be kind and be defined.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要为每一行都这样做；我只是比平常更明确一些，为了以后参考。但这是定义变量和注释的基本方式。不再使用那种 *i*、*j* 和 *k* 的做法。要友善，并且要定义清晰。
- en: Definition simplifies things, which is what we are going to discuss in this
    next section.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 定义简化事物，这就是我们在下一节将要讨论的内容。
- en: Simple-complex-complicated
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单-复杂-复杂化
- en: Simplicity must be maintained wherever possible. That is the rule because, well,
    it’s easier that way. Keeping things simple, however, is hard. It’s impossible
    sometimes. As an application or a solution becomes greater in size, the complexity
    becomes greater too. What we do not want is for the code to become complicated.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 必须尽可能保持简洁。这是规则，因为……那样更容易。然而，保持简洁是困难的。有时几乎不可能。随着应用或解决方案的规模变大，复杂性也会增加。我们不希望的是让代码变得复杂化。
- en: What’s the difference between complex and complicated? Code is complex when
    it is written to sustainably deal with all the scenarios presented before it dynamically
    and understandably. Code is complicated when (in a complex solution) it is written
    in a way that handles every possible case based on static, very specific parameters
    (hard coding) and in a way that becomes difficult to understand, even for the
    person who wrote it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂和复杂化有什么区别？当代码是为了可持续地动态且可理解地处理所有可能的场景时，它是复杂的。当（在一个复杂的解决方案中）代码是以一种根据静态、非常具体的参数（硬编码）来处理所有可能的情况的方式编写时，它就是复杂化的，且即使是写代码的人，也会觉得它很难理解。
- en: I have seen a lot of it over my career; I wrote a lot of it at the beginning,
    too. It’s a learning process and if you don’t build good habits, you will fall
    into bad habits or fall back to a simpler solution for a more complex problem.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的职业生涯中，我看过很多这样的代码；我刚开始时也写过很多。这是一个学习过程，如果你没有培养好的习惯，你就会陷入坏习惯，或者会退回到为更复杂问题找到一个更简单的解决方案。
- en: 'Once, when reviewing an old `JSONResponse` function. It was baffling, and I
    couldn’t help but think about why someone would write the code this way, until
    I found out that the person who had written it had had no previous web development
    expertise and was instead a data engineer. So, they reverted to what their vision
    of simplicity was: data science libraries, even for backend development.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 曾经，在回顾一个旧的`JSONResponse`函数时，我感到困惑，忍不住想，为什么有人会以这种方式编写代码，直到我发现编写此代码的人并没有之前的网页开发经验，而是一名数据工程师。于是，他们回归了自己对简洁性的理解：使用数据科学库，即便是用于后端开发。
- en: Now, this slowed down the application immensely and, of course, had to be refactored,
    but – since we are blameless on individuals in this book – we couldn’t blame the
    developer. We have to blame the habits that they fall back on and the simplicity
    they seek that eventually results in complicated code, when a slightly more complex
    yet concise solution would have resulted in better code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这大大拖慢了应用程序的速度，当然，必须进行重构，但是——因为本书中我们不指责任何个人——我们不能怪罪开发者。我们必须责怪他们依赖的习惯和他们追求的简洁性，这最终导致了复杂的代码，而稍微复杂一点但简洁的解决方案本可以生成更好的代码。
- en: Flat-nested/sparse-dense
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平坦—嵌套/稀疏—密集
- en: The part about flat being better than nested, in particular, is a reason for
    those famous one-line Python codes that you see. Simple code shouldn’t have to
    span across 20-30 lines when it can be done in a few. In a lot of languages, it
    cannot be done in a few lines, but in Python, it can.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 特别是关于“平坦优于嵌套”的部分，是那些著名的单行Python代码背后的原因。简单的代码不应该需要跨越20到30行，尤其是当它能在几行内完成时。在许多语言中，做不到几行代码，但在Python中可以。
- en: 'Let’s test out this concept when printing each value for this array: `my_list
    = [``1,2,3,4,5]`:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下这个概念，打印这个数组的每个值：`my_list = [1,2,3,4,5]`：
- en: '| **Flat** **and sparse** | **Nested** **and dense** |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| **平坦稀疏** | **嵌套密集** |'
- en: '| `print(*my_list)` | `for element in` `my_list: print(element)` |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| `print(*my_list)` | `for element in` `my_list: print(element)` |'
- en: Table 2.1 – Flat and sparse versus nested and dense
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 表格2.1 – 平坦稀疏与嵌套密集
- en: Again, a very small example, but one of many present in the Python language.
    I recommend going through the list of libraries that Python comes pre-installed
    with; it is a very interesting read and will help you come up with a lot of ideas.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常小的例子，但它是Python语言中许多类似例子中的一个。我建议你浏览Python自带的库列表；这是一份非常有趣的读物，能够帮助你产生很多想法。
- en: A lot of the time, this flat and sparse concept reduces the amount of code written
    by a significant amount. In turn, this makes the code more readable just from
    the reduced time it takes to read the code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，这种平坦稀疏的概念大大减少了编写代码的量。反过来，这使得代码变得更具可读性，仅仅是因为减少了阅读代码所需的时间。
- en: Let’s dive into readability and the purity of the concept.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入探讨可读性和概念的纯粹性。
- en: Readability-special cases-practicality-purity-errors
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可读性—特例—实用性—纯粹性—错误
- en: Python is meant to be a language that can be read and understood at some level
    by the layperson. It doesn’t require any particularly special syntax and even
    the one-liners can be interpreted quite easily. Readability counts, and there
    are no special cases that are special enough to violate this credo. I have already
    expressed both philosophies through the previous examples, so there is no need
    to reiterate them here.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Python旨在成为一种普通人也能在某种程度上阅读和理解的语言。它不需要任何特别的语法，甚至那些单行代码也能轻松理解。可读性很重要，没有任何特殊情况足够特殊到违反这一原则。我已经通过前面的例子表达了这两种哲学，所以在这里无需重复。
- en: Practicality over purity is a fairly simple concept. Often, trying to follow
    best practices too strictly simply results in a waste of time. Sometimes, the
    best way to do something is to do it and then explain it later. However, in such
    cases, make sure that your boldness doesn’t result in something that might break
    the system. In that case, **try-catch error handling** is your best friend. It
    also helps to pass errors silently when you need it to.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 实用性优于纯粹性是一个相当简单的概念。通常，过于严格地遵循最佳实践只会浪费时间。有时候，最好的做法是先做，再解释。但是，在这种情况下，确保你的大胆做法不会导致系统崩溃。在这种情况下，**try-catch错误处理**是你最好的朋友。当你需要时，它还可以帮助你安静地传递错误。
- en: Balance between the two – progress and verification – results in code that has
    been verified and tested, but also code that is actually shipped to the end user.
    This balance is integral to any successful project. You have to be pragmatic when
    you are doing actual work, but you also have to realize that other people may
    not be so pragmatic in their actions and their estimates.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 两者之间的平衡——进展与验证——会产生经过验证和测试的代码，但也会产生实际交付给最终用户的代码。这种平衡对任何成功的项目至关重要。在实际工作中，你必须务实，但你也必须意识到其他人在行动和估算时可能不那么务实。
- en: To take action in either direction, pragmatism or purity requires a sense of
    direction. It requires deciding something or some way and sticking to it.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何方向采取行动，无论是务实还是纯粹，都需要有一个方向感。它需要决定某个事情或某种方法，并坚持下去。
- en: Ambiguity/one way/Dutch
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模糊性/单向/荷兰式
- en: Anyone who has ever worked with clients knows how demoralizing and frustrating
    a vague requirement is. “*Do this, do that, we need this*” – that’s all you hear,
    without any understanding from the other side or respect for how the process works.
    They have a certain goal in mind, and they don’t care how you get there. That’s
    fine for machines (and we’ll learn how to do some of that), but for work done
    by people (and especially for coding work), that is not the way. You need to know
    exactly what is required so that you can do it precisely.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 任何曾经和客户合作过的人都知道，模糊的需求是多么令人沮丧和气馁。“*做这个，做那个，我们需要这个*”——你只会听到这些，没有来自对方的理解，也没有尊重过程如何运作。他们心中有一个目标，而不在乎你怎么去达成。对于机器来说，这没问题（我们也会学到一些机器的做法），但是对于人类的工作（尤其是编码工作）来说，这不是方法。你需要清楚地知道需求是什么，才能精准地去完成。
- en: A lot of the time, even the clients don’t know what they want; they have a vague
    idea that they want to act upon, but nothing beyond that. This ambiguity needs
    to be sorted out at the beginning of the project and it certainly should never
    spread to the code. Once something has been defined, then there is a way to do
    it that is the fastest, most secure, or most convenient (depending on requirements).
    This is the way that you need to find.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 很多时候，即使是客户自己也不知道他们到底想要什么；他们有一个模糊的想法，想要去实现，但除此之外没有更多的内容。这种模糊性需要在项目开始时解决，并且绝对不应扩展到代码中。一旦某些东西被定义，就有一种方法可以做到最快、最安全或最方便（具体取决于需求）。这就是你需要找到的方式。
- en: 'But, again, how do you find this way? It is not obvious to anyone who is not
    Dutch (a reference to the Dutch programmer Guido Van Rossum, the original author
    of Python). So, if you’re Dutch, you’re fine. If you’re not, read this story (it’s
    a much better fit for these principles than regular code):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如何找到这种方式呢？对于非荷兰人来说并不显而易见（这是对荷兰程序员Guido Van Rossum的一个提及，他是Python的原作者）。所以，如果你是荷兰人，那就没问题。如果你不是，阅读这个故事（它比普通的代码更符合这些原则）：
- en: '*Three friends were stranded on a boat with no food or water. These friends
    only had in their possession a lamp that seemed to be empty. One of the friends
    decided to rub the lamp, which caused a genie to appear. The genie granted each
    of the friends one wish since they had all summoned* *him together.*'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '*三位朋友被困在一艘没有食物和水的船上。这些朋友身上只有一盏看似空的灯。一个朋友决定擦拭这盏灯，结果召唤出了一位神灵。神灵为每个朋友实现了一个愿望，因为他们是一起召唤*
    *他的。*'
- en: '*The first friend made his wish: “I wish to be sent to my wife and children.”
    The wish was granted, and the friend disappeared, having been sent back to his
    family. The second friend wished to be sent back to his house in his hometown.
    This wish was similarly granted. The third friend, a loner, had nowhere he could
    think to go nor no one he could think to go to, so when his turn came, he said:
    “I wish I had my friends* *with me.”*'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '*第一个朋友许下了他的愿望：“我希望被送到我的妻子和孩子那里。”愿望得到了满足，朋友消失了，被送回了他的家人身边。第二个朋友希望被送回他家乡的房子里，这个愿望同样得到了实现。第三个朋友是个孤独的人，他没有地方去，也没有人可以去找，于是当轮到他时，他说：“我希望我的朋友们*
    *在我身边。”*'
- en: 'Now, this is an old story, but the way most people interpret it is that the
    friends were forcibly put back onto the boat by the third friend’s wish: a classic
    tale of *be careful what you wish for*. However, an engineer can read the story
    and come up with some other possible scenarios. Maybe the third wish brought back
    more than those two people (if he had more than two friends); maybe it brought
    back no one (if the other two weren’t considered friends, that would be a sad
    turn to the story), or it could even lead to an argument over what a friend is.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事很老了，但大多数人理解它的方式是，朋友们被第三个朋友的愿望强行带回船上：这是一个经典的*小心你许下的愿望*的故事。然而，一个工程师可以从这个故事中得出其他可能的情境。也许第三个愿望带回了不止这两个人（如果他有超过两个朋友的话）；也许没有带回任何人（如果另外两个人不算朋友，那将是个悲伤的转折），或者它甚至可能引发一场关于什么是朋友的争论。
- en: But most programming languages are like the genie. It does exactly what you
    tell it to do. If you’re vague, the room you give it for interpretation can cost
    you, so be careful and only wish for the exact thing you want. And people (such
    as our previous clients) are like, well, the people. They sometimes know what
    they want, they sometimes do not. But, to succeed, they need to know precisely
    what they want in both the context of the goal (getting home) and the context
    of the rules that govern them (they could’ve let the third friend go first if
    they doubted his intentions). This is quite a conundrum, isn’t it?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 但大多数编程语言就像精灵。它完全按照你说的去做。如果你表达模糊，留给它解释的空间可能会让你付出代价，所以要小心，只许愿你真正想要的东西。人们（比如我们之前的客户）就像人类一样。有时他们知道自己想要什么，有时却不清楚。但为了成功，他们需要精确地知道自己想要什么，既要在目标的背景下（回家），也要在约束规则的背景下（如果他们怀疑第三个朋友的意图，他们本可以让他先走）。这真是个难题，不是吗？
- en: The key here – and this is something DevOps and **Agile methodologies** preach
    as well – is continuous improvement. Trying to continually find that one way.
    And if the scenario changes, tweaking the way to that scenario. This strategy
    is essential in coding, DevOps, machine learning, and practically every technology
    field. Iterative methodology helps turn even the vaguest goal into a bold mission
    statement and can provide unified direction.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键——而这也是DevOps和**敏捷方法论**所提倡的——就是持续改进。不断寻找那个最佳的方法。如果情况发生变化，就调整方法以适应新的情境。这种策略在编码、DevOps、机器学习以及几乎所有技术领域中都至关重要。迭代方法论有助于将即使是最模糊的目标转化为一个大胆的使命声明，并能够提供统一的方向。
- en: The Dutch are a very direct people; only they could have invented a language
    as head-first as Python. Speaking of direct, you should probably read the next
    section now … or never, if you don’t have the time right now (see what I did there?).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 荷兰人是非常直接的民族；只有他们能发明出像Python一样直截了当的语言。说到直截了当，你现在应该阅读下一部分了……或者永远不读，如果你现在没时间（看到我在这里做了什么了吗？）。
- en: Now or never
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 现在或永远
- en: This is another one of those principle pairs that is more about the method of
    writing than the writing itself. The statements of *now* being better than *never*
    but *never* being better than *right now* may seem somewhat paradoxical, but they
    describe the nature of writing code and delivering value through it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这是另一对原则，更多是关于写作方法，而不是写作本身。*现在*比*永远*更好，但*永远*又比*现在*更好，这种说法看起来有些自相矛盾，但它们描述了编写代码和通过代码传递价值的本质。
- en: '*Now* doesn’t mean *right this second*. It is meant to represent the near future
    and in that near future, the code we have written has delivered value. This is
    opposed to never releasing the code at all or releasing it in an unrealistically
    long timeframe, by the end of which the written code might become irrelevant.
    As Steve Jobs used to say:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '*现在*并不意味着*此刻*。它是指不久的将来，而在这个不久的将来，我们写的代码已经交付了价值。这与永远不发布代码，或在不现实的长期时间框架内发布代码不同，后者可能导致编写的代码变得无关紧要。正如史蒂夫·乔布斯曾经说过的：'
- en: '*Real* *artists ship*.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*真正的* *艺术家发布作品*。'
- en: However, *right now* is also never a good time. To release something too early,
    with no thought put into it, no understanding, and no game plan, can result in
    disaster. The basic lesson there is to look before you leap. And if you leap into
    a volcano, you probably didn’t do your due diligence.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，*现在*也从来不是一个好时机。过早发布某个东西，既没有考虑过它，也没有理解和规划，这可能会导致灾难。这里的基本教训是：三思而后行。如果你跳进了火山口，显然你没有做好应尽的准备。
- en: One of the reasons that *right now* is looked at as not a good time is because
    right now, there are no good ideas. There are never any good ideas right now;
    you kind of have to wait for your brain to come up with one. You push too hard
    trying to get something through that is hard to explain – that is a bad idea.
    That is how we can explain all the stupid trades that general managers make in
    sports at the trade deadline.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*现在*被视为不合时宜的原因之一是，因为现在没有什么好主意。现在永远没有什么好主意；你得等大脑想出一个来。你用力过猛，试图推动一些难以解释的东西——那就是一个坏主意。这就解释了为什么体育经理在交易截止日期时做出许多愚蠢的交易。'
- en: Hard-bad/easy-good
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 难-坏/易-好
- en: If you’re having a hard time explaining something, it is probably a bad idea.
    There’s not much to explain there – that’s just common sense. A complex vision
    is no vision at all. It needs to be reduced, simplified, and shaped into something
    that most people can understand (or at least work toward).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你很难解释某件事，那很可能是个坏主意。没有太多可以解释的——这就是常识。一个复杂的愿景其实根本算不上愿景。它需要被简化、提炼，并且形成大多数人能理解的东西（或者至少是朝着这个方向努力）。
- en: An idea that is complicated is simply an idea that hasn’t been reduced to its
    most useful, simplest component yet. As the old adage goes, there is always a
    ratio of 20% of the effort producing 80% of the output. To create the good idea,
    we just need to bring out and work on that 20%.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 一个复杂的想法其实只是一个还未简化到最有用、最简单组件的想法。正如老话所说，20%的努力通常能产生80%的结果。要创造出好的想法，我们只需要集中精力去实现那20%的部分。
- en: Namespaces
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命名空间
- en: 'The lone zen, `lib1` and `lib2`, both containing methods named `example`. What
    would be the solution that allows both of the methods to be imported into one
    Python file? You can just change one or both of their names to unique namespaces:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 孤独的 zen，`lib1` 和 `lib2`，它们都包含一个名为 `example` 的方法。如何解决这个问题，使得这两个方法都能被导入到一个 Python
    文件中？你只需要将其中一个或两个方法的名称更改为唯一的命名空间：
- en: 'Code without namespaces:'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不带命名空间的代码：
- en: '[PRE3]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Code with namespaces:'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带命名空间的代码：
- en: '[PRE4]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: A honking great idea indeed.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实是个很棒的主意。
- en: Through these principles, you can observe how Python has evolved into the language
    that it is and how it has distinguished itself from all the other programming
    languages. These changes have also helped make Python a language that aligns itself
    with DevOps principles. So, let’s now observe the marriage between the principles
    behind Python and DevOps and how they are mutually beneficial to each other.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些原理，你可以看到 Python 如何演变成今天的样子，以及它如何与其他编程语言区分开来。这些变化也帮助 Python 成为与 DevOps 原理一致的语言。那么，让我们现在来看一下
    Python 和 DevOps 原理之间的结合，以及它们如何互相促进。
- en: What Python offers DevOps
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 为 DevOps 提供的功能
- en: In the previous section, we focused on the principles of Python. Now, we are
    going to look into what following those principles offers DevOps as a practice
    and DevOps engineers in general. The principles behind DevOps and Python are more
    similar than they are different. They both share an emphasis on flexibility, automation,
    and conciseness. This makes Python and DevOps a perfect pairing in the field of
    DevOps. Even for DevOps professionals who may not have the sharpest coding skills,
    Python is easy to pick up, easy to use, and can be integrated with practically
    every tool and platform because almost all these platforms have native support
    and libraries in Python.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们重点讲解了 Python 的基本原理。现在，我们将探讨遵循这些原理对 DevOps 实践和 DevOps 工程师的意义。DevOps 和
    Python 背后的原理有更多相似之处而非差异。它们都强调灵活性、自动化和简洁性。这使得 Python 和 DevOps 在 DevOps 领域中成为完美的组合。即使是那些可能没有最强编码能力的
    DevOps 专业人士，Python 也易于学习和使用，并且几乎与所有工具和平台都可以集成，因为几乎所有这些平台都有原生的 Python 支持和库。
- en: I previously stated that the reason that Python is so pervasive in DevOps is
    that it handles data that resides between curly brackets (*{}*) better than almost
    any other language. The offerings of Python for DevOps are numerous and will be
    covered in further detail in future chapters. Right now, we will go over some
    of these offerings in brief.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，Python 在 DevOps 中如此普及的原因是它能比几乎任何其他语言更好地处理存在于大括号 (*{}*) 之间的数据。Python 为
    DevOps 提供的功能众多，未来章节中会进一步详细讲解。现在，我们将简要概述其中的一些功能。
- en: Operating systems
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作系统
- en: 'Python has native libraries that interact with the OS of any server that it
    is currently working on. These libraries allow for programmatic access to various
    OS processes. This is especially useful when you work with virtual machines on
    the cloud (such as with **Amazon EC2**). You can do things such as the following:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Python 有原生库，可以与它当前运行的任何服务器的操作系统交互。这些库允许程序化访问各种操作系统进程。当你在云端处理虚拟机时（例如使用**Amazon
    EC2**），这尤其有用。你可以做以下事情：
- en: Set environment variables in the OS
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在操作系统中设置环境变量
- en: Get information about files or directories
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取文件或目录的信息
- en: Manipulate, create, or delete files and directories
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作、创建或删除文件和目录
- en: Kill or spawn processes and threads
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终止或创建进程和线程
- en: Create temporary files and file locations
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建临时文件和文件位置
- en: Run Bash scripts
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 Bash 脚本
- en: OSs are nice and all, but they can be difficult to maintain in a desired state
    with ideal resource usage. For this challenge, we have a common solution in containerization.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 操作系统很不错，但它们在理想资源使用情况下，保持在期望状态可能会变得困难。对于这个挑战，我们有一个常见的解决方案——容器化。
- en: Containerization
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器化
- en: '**Containers** are made using the **Docker** library. The creation, destruction,
    and modification of containers can be automated and orchestrated using Python.
    It provides a way to programmatically maintain and modify container states. Some
    applications include the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器**是使用**Docker**库创建的。容器的创建、销毁和修改可以通过 Python 自动化和编排。它提供了一种程序化的方式来维护和修改容器状态。一些应用包括：'
- en: Interaction with Docker API for commands, such as getting a list of Docker containers
    or images present in the OS
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与 Docker API 交互，执行命令，比如获取操作系统中现有的 Docker 容器或镜像列表
- en: Automatically generating **Docker Compose files** from a list of Docker images
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 Docker 镜像列表自动生成**Docker Compose 文件**
- en: Building Docker images
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建 Docker 镜像
- en: Orchestrating containers using the **Kubernetes library**
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**Kubernetes 库**编排容器
- en: Testing and verifying Docker images
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试和验证 Docker 镜像
- en: You may be wondering what the point of containers is, and that may be because
    you’ve never gotten tired of the constant online discourse over OSs and frameworks
    and which ones are superior (in fact, you may have even encouraged such malarkey).
    But, containers exist for those who tire of such debate and instead want isolated
    environments for all their specific operating needs. So they made one with containers,
    and someone had the bright idea to call them microservices.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，容器的意义何在？可能是因为你从未厌倦过关于操作系统和框架的不断讨论，以及哪些更优（事实上，你甚至可能鼓励过这种废话）。但容器的存在，是为了那些厌倦了这种辩论，想要为所有特定操作需求提供隔离环境的人。所以他们用容器创建了一个，且有人聪明地将它们称为微服务。
- en: Microservices
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务
- en: 'Sometimes, containers and **microservices** are used interchangeably, but in
    modern DevOps that is not necessarily the case. Yes, it is containers that make
    microservices possible, but t the overall writing of microservices on top of those
    containers is efficient code that has the most bang for its buck. Some reasons
    for Python use in microservices are as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，容器和**微服务**可以互换使用，但在现代 DevOps 中，这不一定是这样。是的，正是容器让微服务成为可能，但在这些容器上编写微服务的整体代码是高效的，它在性能上最大化了投入产出比。以下是
    Python 在微服务中使用的一些原因：
- en: Strong native library support inside of a Python container – libraries such
    as **json**, **asyncio**, and **subprocess**
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Python 容器中强大的本地库支持 —— 如**json**、**asyncio**和**subprocess**等库
- en: Excellent native code modules that simplify certain iterative and manipulative
    operations on data such as the `collection` module
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 出色的本地代码模块，简化了对数据的某些迭代和操作性操作，如 `collection` 模块
- en: Ability to properly natively handle semi-structured and varied JSON data that
    is usually used in microservices
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够正确地本地处理通常用于微服务的半结构化和多样化的 JSON 数据
- en: To have these microservices interact with each other effectively and consistently,
    we need some repetition, some consistent repetition. What’s the word I’m looking
    for ... automaton ... no, that’s a robot ... autograph ... no, that’ll be what
    I do once this book becomes a bestseller ... automation, yes, that’s the word.
    Automation.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些微服务能够有效且一致地相互交互，我们需要一些重复，一些一致的重复。我要找的词是……自动化……不，那是机器人……签名……不，那是等这本书成为畅销书后的事……自动化，对，正是这个词。自动化。
- en: '**Automation** is probably the primary selling point for DevOps engineers when
    it comes to Python because of its incredible **automation library** and support
    features. Most systems guys who transition to DevOps prefer their precious **Bash
    scripting**, and that does have a place in environments such as these, but Python
    is more powerful and more flexible, and it is better supported by the community
    and the companies in the industry overall. Some applications of Python for automation
    in this case would be the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动化**可能是 Python 对于 DevOps 工程师的主要卖点，因为它拥有令人难以置信的**自动化库**和支持功能。大多数从系统管理员转型为
    DevOps 的人员更喜欢他们宝贵的**Bash 脚本**，这种脚本在某些环境中确实有其用武之地，但 Python 更加强大、更加灵活，而且得到了社区和行业中大多数公司的更好支持。在这种情况下，Python
    在自动化方面的一些应用包括：'
- en: Various **Software Development Kits** (**SDKs**) for cloud-based deployments
    in **AWS**, **Azure**, **Google Cloud**, and other providers
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 各种针对云端部署的**软件开发工具包**（**SDKs**），包括**AWS**、**Azure**、**Google Cloud**和其他云服务提供商
- en: Support for automated building and testing of applications
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持自动构建和测试应用程序
- en: Support for monitoring applications and sending notifications
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持监控应用程序并发送通知
- en: Support for parsing and scraping necessary data from web pages, databases, and
    various other sources of data
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持从网页、数据库及其他各种数据源中解析和抓取必要的数据
- en: Now that we have talked the talk, let’s walk a little. A light jog to combine
    Python and DevOps.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经谈过了，让我们做点实际的事情。轻轻跑步，结合 Python 和 DevOps。
- en: A couple of simple DevOps tasks in Python
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些简单的 Python DevOps 任务
- en: I have so far preached to you the virtues of DevOps and the virtues of Python
    but so far, I have shown you very little of how the two work together. Now, we
    get to that part. Here, I will demonstrate a couple of examples of how to use
    Python to automate some regular DevOps tasks that some engineers may have to perform
    on a daily basis. These two examples will be from AWS, though they are applicable
    in other big clouds as well and can be applied on most data center servers if
    you have the right APIs.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止，我向你们传授了 DevOps 和 Python 的优点，但到目前为止，我展示的却很少有两者如何协同工作的内容。现在，我们进入这一部分。在这里，我将展示几个如何使用
    Python 自动化一些 DevOps 常规任务的例子，这些任务是一些工程师可能每天都要执行的。这两个例子来自 AWS，尽管它们同样适用于其他大云平台，并且如果你拥有正确的
    API，也可以应用于大多数数据中心服务器。
- en: 'The code for this chapter and all future chapters are stored in this repository:
    [https://github.com/PacktPublishing/Hands-On-Python-for-DevOps](https://github.com/PacktPublishing/Hands-On-Python-for-DevOps)'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 本章及所有后续章节的代码都存储在这个仓库中：[https://github.com/PacktPublishing/Hands-On-Python-for-DevOps](https://github.com/PacktPublishing/Hands-On-Python-for-DevOps)
- en: Automated shutdown of a server
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动关闭服务器
- en: Oftentimes, there is the case of certain servers that only need to be up during
    working hours and then need to be switched off afterward. Now, this particular
    scenario has a lot of caveats, which include the platform used, the accounts where
    the servers are running, and how working hours are measured…but for this scenario,
    we are simply going to shut our EC2 servers down in an AWS account using an **AWS
    Lambda** function microservice that runs a Python script that leverages the **boto3
    library**. That sounds like a lot? Let’s break it down.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 经常会遇到某些服务器只需要在工作时间运行，工作时间过后则需要关闭的情况。现在，这种特定场景有很多前提条件，包括使用的平台、服务器运行的账户以及如何衡量工作时间……但是，对于这个场景，我们只是简单地在
    AWS 账户中通过一个运行 Python 脚本并利用 **boto3 库**的 **AWS Lambda** 函数微服务来关闭我们的 EC2 服务器。听起来很复杂吗？让我们分解一下。
- en: 'In my AWS account, I have two EC2 instances running. Every second that they
    run costs me money. However, I need them during business hours. Here they are:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的 AWS 账户中，我有两个正在运行的 EC2 实例。它们每秒钟的运行都会让我花费一些钱。然而，在工作时间我需要它们。它们是这样的：
- en: '![Figure 2.2 – Running instances](img/B21320_02_2.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – 运行中的实例](img/B21320_02_2.jpg)'
- en: Figure 2.2 – Running instances
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 运行中的实例
- en: Creatively named, I know. But they are running, and there will come a point
    in time when I want them to not be running. So, to achieve that, I need to find
    some way to stop them. I could stop them one by one, but that’s tedious. And would
    I still do that if these 2 instances were 1,000 instances? No. So, we need to
    find another way.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 起了个有创意的名字，我知道。但是它们确实在运行，并且总有一天，我希望它们不再运行。为了实现这一点，我需要找到某种方法来停止它们。我可以一个一个地停止它们，但那样很麻烦。如果这两个实例变成了
    1000 个实例，我还会这样做吗？不会。那么，我们需要找到另一种方法。
- en: 'We could try the **command-line interface** (**CLI**), but this is a coding
    book and not a CLI book, so we won’t. Though, keep it in mind if you want to try
    it. So, let’s look to our old friend Python, and also to a service that allows
    you to deploy a function that you can call at any time, called AWS Lambda. Here
    are the steps to create a Lambda function and use it to start and stop an EC2
    instance:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试**命令行界面**（**CLI**），但这是一本编码书，而不是 CLI 书，所以我们不这么做。不过，如果你有兴趣，也可以尝试。让我们看看我们的老朋友
    Python，并且也可以使用一个服务，允许你随时调用的函数，称为 AWS Lambda。下面是创建 Lambda 函数并用它来启动和停止 EC2 实例的步骤：
- en: 'Let’s create a function called `stopper` with the latest available Python runtime
    (3.10 for this book):'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`stopper`的函数，使用最新的 Python 运行时（本书中使用的是 3.10）：
- en: '![Figure 2.3 – Creating a Lambda function](img/B21320_02_3.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 创建 Lambda 函数](img/B21320_02_3.jpg)'
- en: Figure 2.3 – Creating a Lambda function
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 创建 Lambda 函数
- en: Next, you will either have to create an execution role for the Lambda function
    or give it an existing one. This will be important later. But for now, do the
    one you prefer. Click `boto3` library by default, which is very useful for resource
    interaction.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你需要为 Lambda 函数创建一个执行角色，或者为其分配一个现有的角色。这一点稍后会很重要。不过现在，你可以选择你偏好的方式。默认情况下，点击
    `boto3` 库，它非常适合资源交互。
- en: 'Before we can start or stop any instance, we need to list them out. You have
    to load and dump the return function once to handle the `datetime` data type.
    For now, let’s just initialize the `boto3` client for EC2 and try and list all
    of the instances that are currently available:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们能够启动或停止任何实例之前，我们需要列出它们。你需要先加载并转储返回函数一次，以处理`datetime`数据类型。现在，让我们先初始化 EC2 的
    `boto3` 客户端，尝试列出当前可用的所有实例：
- en: '![Figure 2.4 – Initial code to describe instances](img/B21320_02_4.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – 描述实例的初始代码](img/B21320_02_4.jpg)'
- en: Figure 2.4 – Initial code to describe instances
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 描述实例的初始代码
- en: 'Running this with a test will get you an exception thrown similar to this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码进行测试时，你会遇到类似于以下的异常：
- en: '![Figure 2.5 – Authorization exception](img/B21320_02_5.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – 授权异常](img/B21320_02_5.jpg)'
- en: Figure 2.5 – Authorization exception
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 授权异常
- en: That is because the Lambda function also has an **identity and access management**
    (**IAM**) role, and that role does not have the required permissions to describe
    the instances. So, let’s set the permissions that we may need.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为 Lambda 函数也有一个**身份与访问管理**（**IAM**）角色，而这个角色没有描述实例所需的权限。因此，我们需要设置可能需要的权限。
- en: 'As shown in the following figure, under **Configuration** | **Permissions**,
    you will find the role assigned to the Lambda function:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下图所示，在**配置**|**权限**下，你将找到分配给 Lambda 函数的角色：
- en: '![Figure 2.6 – Finding the role for permissions](img/B21320_02_6.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6 – 查找权限角色](img/B21320_02_6.jpg)'
- en: Figure 2.6 – Finding the role for permissions
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – 查找权限角色
- en: 'On the page for the role, go to **Add permissions** and then **Attach policies**:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在角色页面，转到**添加权限**，然后选择**附加策略**：
- en: '![Figure 2.7 – Attaching a permission](img/B21320_02_7.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.7 – 附加权限](img/B21320_02_7.jpg)'
- en: Figure 2.7 – Attaching a permission
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – 附加权限
- en: 'Let’s give the Lambda function full access to the EC2 services since we will
    need it to stop the instance as well. If you prefer or if you feel that’s too
    much access, you can make a custom role:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们赋予 Lambda 函数对 EC2 服务的完全访问权限，因为我们还需要它来停止实例。如果你觉得这权限过大，也可以创建自定义角色：
- en: '![Figure 2.8 – Attaching the appropriate permission](img/B21320_02_8.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8 – 附加适当的权限](img/B21320_02_8.jpg)'
- en: Figure 2.8 – Attaching the appropriate permission
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – 附加适当的权限
- en: 'Let’s run this again and see the results:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们重新运行一次，看看结果：
- en: '![Figure 2.9 – Successful code run](img/B21320_02_9.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.9 – 成功运行的代码](img/B21320_02_9.jpg)'
- en: Figure 2.9 – Successful code run
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 – 成功运行的代码
- en: You’ll see the display of instances as well as information regarding whether
    they are running or not.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到实例的展示，以及关于它们是否正在运行的信息。
- en: 'Now, let’s get to the part where we shut down the running instances. Add code
    to filter among the instances for ones that are running and get a list of their
    IDs, which we will use to reference the instances we want to stop:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们进入关闭正在运行的实例的部分。添加代码以在实例中进行筛选，找出正在运行的实例，并获取它们的 ID 列表，稍后我们将使用这些 ID 来引用我们希望停止的实例：
- en: '![Figure 2.10 – Adding code that stops the instances](img/B21320_02_10.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.10 – 添加停止实例的代码](img/B21320_02_10.jpg)'
- en: Figure 2.10 – Adding code that stops the instances
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.10 – 添加停止实例的代码
- en: Simple enough to understand, especially if we are following the principle of
    readability and explicitness.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 足够简单易懂，尤其是如果我们遵循可读性和明确性原则的话。
- en: 'The instances are now in a state where they are shutting down. And soon, they
    will be stopped:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 实例现在处于关闭状态，很快就会停止：
- en: '![Figure 2.11 – Shut down instances](img/B21320_02_11.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图2.11 – 关闭实例](img/B21320_02_11.jpg)'
- en: Figure 2.11 – Shut down instances
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 – 关闭实例
- en: 'Now that we have done it once, let’s automate it further by using a service
    called EventBridge, which can trigger that function every day. Navigate to **Amazon
    EventBridge** and make an EventBridge schedule:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经做了一次，让我们通过使用名为EventBridge的服务进一步自动化它，EventBridge可以每天触发该函数。前往**Amazon EventBridge**并创建EventBridge定时事件：
- en: '![Figure 2.12 – Setting up a cron job on EventBridge](img/B21320_02_12.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图2.12 – 在EventBridge上设置定时任务](img/B21320_02_12.jpg)'
- en: Figure 2.12 – Setting up a cron job on EventBridge
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 – 在EventBridge上设置定时任务
- en: 'Select our Lambda function as the event target:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们的Lambda函数作为事件目标：
- en: '![Figure 2.13 – Selecting Lambda to invoke for EventBridge](img/B21320_02_13.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图2.13 – 为EventBridge选择Lambda进行调用](img/B21320_02_13.jpg)'
- en: Figure 2.13 – Selecting Lambda to invoke for EventBridge
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.13 – 为EventBridge选择Lambda进行调用
- en: You can now create the EventBridge scheduled event, which will trigger at 8
    P.M. every day and list and shut down your EC2 instances.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以创建EventBridge定时事件，该事件将在每天晚上8点触发，列出并关闭你的EC2实例。
- en: So, in following these steps, you now have the tools necessary to schedule the
    shutdown of instances based on the timed schedule that you want.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，按照这些步骤，你现在拥有了必要的工具，可以根据你想要的定时计划安排实例的关闭。
- en: Autopull a list of Docker images
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动拉取Docker镜像列表
- en: 'Grabbing Docker images can be tedious. Especially grabbing multiple images.
    So now, we are going to see how we can pull a number of Docker images at the same
    time using the Python library for Docker:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 拉取Docker镜像可能会很繁琐，尤其是当需要拉取多个镜像时。那么，现在我们将看看如何使用Python库同时拉取多个Docker镜像：
- en: 'First, install the Docker Python library in a virtual environment using the
    following command:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用以下命令在虚拟环境中安装Docker Python库：
- en: '[PRE5]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, write a script in a file called `docker_pull.py` to loop through a list
    of image names and pull them by leveraging the Docker library:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，编写一个名为`docker_pull.py`的脚本，循环遍历镜像名称列表，并通过利用Docker库拉取它们：
- en: '![Figure 2.14 – Code to pull Docker images](img/B21320_02_14.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图2.14 – 拉取Docker镜像的代码](img/B21320_02_14.jpg)'
- en: Figure 2.14 – Code to pull Docker images
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14 – 拉取Docker镜像的代码
- en: 'After this, run the file using this command:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，使用以下命令运行文件：
- en: '[PRE6]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![Figure 2.15 – List of Docker images](img/B21320_02_15.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![图2.15 – Docker镜像列表](img/B21320_02_15.jpg)'
- en: Figure 2.15 – List of Docker images
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15 – Docker镜像列表
- en: So, this gives you a pretty nifty way to get the Docker containers you want
    with the tags that you want on them.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这为你提供了一种相当巧妙的方式，以你想要的标签获取Docker容器。
- en: Summary
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Python is not just about writing code; it is about a coding philosophy – a philosophy
    that has made Python incredibly popular among DevOps engineers. The writing of
    the Zen of Python affected the way that the language was developed, and we still
    see the consequences today in both Python and DevOps. Python’s philosophy offers
    the DevOps realm the programming language that fits its philosophy.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Python不仅仅是写代码；它是一种编码哲学——这哲学使得Python在DevOps工程师中变得极为流行。Python的Zen（哲学）影响了语言的开发方式，至今我们仍能在Python和DevOps中看到这种影响。Python的哲学为DevOps领域提供了符合其哲学的编程语言。
- en: Python has numerous uses that facilitate a lot of DevOps tasks. So, hopefully,
    this chapter has given you some insights into what makes Python such a good companion
    for DevOps. In the next chapter, you will see that companionship in action and
    learn how to use your knowledge in a truly hands-on way.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Python有很多用途，可以促进许多DevOps任务的完成。所以，希望本章能为你提供一些关于Python为何是DevOps好伴侣的见解。在下一章，你将看到这种伴侣关系的实际应用，并学习如何以真正实践的方式运用你的知识。
