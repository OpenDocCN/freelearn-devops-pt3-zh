["```\nqotd\n```", "```\nqotd --endpoint=\"127.0.0.1:3850\"\n```", "```\nreformat file1.json file2.json\n```", "```\nwget \"http://some.server.com\" | reformat\n```", "```\nvar endpoint = flag.String(\n     \"endpoint\", \n     \"myserver.aws.com\", \n     \"The server this app will contact\",\n)\n```", "```\nfunc main() {\n     flag.Parse()\n     fmt.Println(\"server endpoint is: \", *endpoint)\n}\n```", "```\ntype Value interface {\n     String() string\n     Set(string) error\n}\n```", "```\ntype URLValue struct {\n    URL *url.URL\n}\nfunc (v URLValue) String() string {\n    if v.URL != nil {\n        return v.URL.String()\n    }\n    return \"\"\n}\nfunc (v URLValue) Set(s string) error {\n    if u, err := url.Parse(s); err != nil {\n        return err\n    } else {\n        *v.URL = *u\n    }\n    return nil\n}\nvar u = &url.URL{}\nfunc init() {\n    flag.Var(&URLValue{u}, \"url\", \"URL to parse\")\n}\nfunc main() {\n    flag.Parse()\n    if reflect.ValueOf(*u).IsZero() {\n        panic(\"did not pass an URL\")\n    }\n    fmt.Printf(`{scheme: %q, host: %q, path: %q}`, \n                 u.Scheme, u.Host, u.Path)\n}\n```", "```\nvar (\n     useProd = flag.Bool(\"prod\", true, \"Use a production endpoint\")\n     useDev = flag.Bool(\"dev\", false, \"Use a development endpoint\")\n     help = flag.Bool(\"help\", false, \"Display help text\")\n)\nfunc main() {\n     flag.Parse()\n     if *help {\n          flag.PrintDefaults()\n          return\n     }\n     switch {\n     case *useProd && *useDev:\n          log.Println(\"Error: --prod and --dev cannot both be set\")\n          flag.PrintDefaults()\n          os.Exit(1)\n     case !(*useProd || *useDev):\n          log.Println(\"Error: either --prod or --dev must be set\")\n          flag.PrintDefaults()\n          os.Exit(1)\n     }\n}\n```", "```\nError: --prod and --dev cannot both be set\n  -dev\n         Use a development endpoint (default false)\n  -prod\n         Use a production endpoint (default true)\n```", "```\nvar (\n    useProd = flag.Bool(\"prod\", true, \n                  \"Use a production endpoint\")\n    useDev = flag.Bool(\"dev\", false, \n                  \"Use a development endpoint\")\n    help = new(bool)\n)\nfunc init() {\n    flag.BoolVar(help, \"help\", false, \"Display help text\")\n    flag.BoolVar(help, \"h\", false, \n                 \"Display help text (shorthand)\")\n}     \n```", "```\nqotd --dev \"abraham lincoln\" \"martin king\" \"mark twain\"\n```", "```\nfunc main() {\n     flag.Parse()\n     authors := flag.Args\n     if len(authors) == 0 {\n          log.Println(\"did not pass any authors\")\n          os.Exit(1)\n     }\n     ...\n```", "```\nwget http://server/log | grep -i \"error\" > only_errors.txt \n```", "```\nvar errRE = regexp.MustCompile(`(?i)error`)\nfunc main() { \n    var s *bufio.Scanner \n    switch len(os.Args) { \n  case 1:\n          log.Println(\"No file specified, using STDIN\")\n          s = bufio.NewScanner(os.Stdin)\n  case 2:\n          f, err := os.Open(os.Args[1])\n          if err != nil {\n                  log.Println(err)\n                  os.Exit(1)\n          }\n          s = bufio.NewScanner(f)\n  default:\n          log.Println(\"too many arguments provided\")\n          os.Exit(1)\n  }\n  for s.Scan() {\n          line := s.Bytes()\n          if errRE.Match(line) {\n                  fmt.Printf(\"%s\\n\", line)\n          }\n  }\n  if err := s.Err(); err != nil {\n          log.Println(\"Error: \", err)\n          os.Exit(1)\n  }\n}\n```", "```\nwget http://server/log | filter_errors | grep 401\n```", "```\nfilter_errors log.txt | grep 401\n```", "```\n appName/\n     cmd/\n          add.go\n          your.go\n          commands.go\n          here.go\n     main.go\n```", "```\npackage main\nimport (\n     \"{pathToYourApp}/cmd\"\n)\nfunc main() {\n     cmd.Execute()\n}\n```", "```\nauthor: John Doak myemail@somedomain.com\nyear: 2021\nlicense: MIT\n```", "```\ngo get github.com/spf13/cobra/cobra\ngo install github.com/spf13/cobra/cobra\n```", "```\ncobra init --pkg-name [repo path]\n```", "```\ncobra add serve\ncobra add config\ncobra add create -p 'configCmd'\n```", "```\napp/\n      cmd/\n         serve.go\n         config.go\n         create.go\n       main.go\n```", "```\ncobra init --pkg-name [repo path]\ncobra add get\n```", "```\nvar getCmd = &cobra.Command{\n        Use:   \"get\",\n        Short: \"A brief description of your command\",\n        Long: `A longer description that spans multiple lines and likely contains examples and usage of using your command.`,\n        Run: func(cmd *cobra.Command, args []string) {\n                fmt.Println(\"get called\")\n        },\n}\nfunc init() {\n        rootCmd.AddCommand(getCmd)\n}\n```", "```\n     ...\n     Run: func(cmd *cobra.Command, args []string) {\n        const devAddr = \"127.0.0.1:3450\"\n        fs := cmd.Flags()\n        addr := mustString(fs, \"addr\")\n        if mustBool(fs, \"dev\") {\n                addr = devAddr\n        }\n        c, err := client.New(addr)\n        if err != nil {\n                fmt.Println(\"error: \", err)\n                os.Exit(1)\n        }\n        a, q, err := c.QOTD(cmd.Context(), mustString(fs, \"author\"))\n        if err != nil {\n                fmt.Println(\"error: \", err)\n                os.Exit(1)\n        }\n        switch {\n        case mustBool(fs, \"json\"):\n                b, err := json.Marshal(\n                        struct{\n                                Author string\n                                Quote string\n                        }{a, q},\n                )\n                if err != nil {\n                        panic(err)\n                }\n                fmt.Printf(\"%s\\n\", b)\n        default:\n                fmt.Println(\"Author: \", a)\n                fmt.Println(\"Quote: \", q)\n        }\n     },\n}\n```", "```\nfunc init() {\n        rootCmd.AddCommand(getCmd)\n        getCmd.Flags().BoolP(\"dev\", \"d\", false, \n            \"Uses the dev server instead of prod\")\n        getCmd.Flags().String(\"addr\", \"127.0.0.1:80\", \n            \"Set the QOTD server to use, \n            defaults to production\")\n        getCmd.Flags().StringP(\"author\", \"a\", \"\", \n            \"Specify the author to \n            get a quote for\")\n        getCmd.Flags().Bool(\"json\", false, \n            \"Output is in JSON format\")\n}\n```", "```\n$ go run qotd.go --addr=127.0.0.1:3560\n$ go run main.go get --addr=127.0.0.1:3560 --author=\"Eleanor Roosevelt\" –json \n```", "```\n{\"Author\":\"Eleanor Roosevelt\",\"Quote\":\"The future belongs to\nthose who believe in the beauty of their dreams\"}\n```", "```\n$ go run main.go get --addr=127.0.0.1:3560 \nAuthor: Mark Twain \nQuote: Golf is a good walk spoiled\n```", "```\nsignals := make(chan os.Signal, 1)\nsignal.Notify(\n     signals,\n     syscall.SIGINT,\n     syscall.SIGTERM,\n     syscall.SIGQUIT,\n)\ngo func() {\n     switch <-signals {\n     case syscall.SIGINT, syscall.SIGTERM:\n          cleanup()\n          os.Exit(1)\n     case syscall.SIGQUIT:     \n          cleanup()\n          panic(\"SIGQUIT called\")\n     }\n}()\n```", "```\nfunc handleSignal(cancel context.CancelFunc) chan os.Signal {\n        out := make(chan os.Signal, 1)\n        notify := make(chan os.Signal, 10)\n        signal.Notify(\n                notify,\n                syscall.SIGINT,\n                syscall.SIGTERM,\n                syscall.SIGQUIT,\n        )\n        go func() {\n                defer close(out)\n                for {\n                        sig := <-notify\n                        switch sig {\n                        case syscall.SIGINT, syscall.SIGTERM, syscall.SIGQUIT:\n                                cancel()\n                                out <- sig\n                                return\n                        default:\n                                log.Println(\"unhandled signal: \", sig)\n                        }\n                }\n        }()\n        return out\n}\n```", "```\nfunc createFiles(ctx context.Context, tmpFiles string) error {\n        for i := 0; i < 30; i++ {\n                if err := ctx.Err(); err != nil {\n                        return ctx.Err()\n                }\n                _, err := os.Create(filepath.Join(tmpFiles, strconv.Itoa(i)))\n                if err != nil {\n                        return err\n                }\n                fmt.Println(\"Created file: \", i)\n                time.Sleep(1 * time.Second)\n        }\n        return nil\n}\n```", "```\nfunc cleanup(tmpFiles string) {\n        if err := os.RemoveAll(tmpFiles); err != nil {\n                fmt.Println(\"problem doing file cleanup: \", err)\n                return\n        }\n        fmt.Println(\"cleanup done\")\n}\n```", "```\nfunc main() {\n        tmpFiles, err := os.MkdirTemp(\"\", \"myApp_*\")\n        if err != nil {\n                log.Println(\"error creating temp file directory: \", err)\n                os.Exit(1)\n        }\n        fmt.Println(\"temp files located at: \", tmpFiles)\n        ctx, cancel := context.WithCancel(context.Background())\n        recvSig := handleSignal(cancel)\n        if err := createFiles(ctx, tmpFiles); err != nil {\n                cleanup(tmpFiles)\n                select {\n                case sig := <-recvSig:\n                        if sig == syscall.SIGQUIT {\n                                panic(\"SIGQUIT called\")\n                        }\n                default:\n                // Prevents waiting on a\n                // signal if none exists.\n                }\n                log.Println(\"error: \", err)\n                os.Exit(1)\n        }\n        fmt.Println(\"Done\")\n}\n```", "```\nfunc main() {\n\tctx, cancel := context.WithCancel(context.Background())\n\tvar sigCh chan os.Signal\n\tgo func() {\n\t\thandleSignal(ctx, cancel)\n\t}()\n\tcmd.Execute(ctx)\n\tcancel()\n\tif sig := <-sigCh; sig == syscall.SIGQUIT {\n\t\tpanic(\"SIGQUIT\")\n\t}\n}\n```", "```\nfunc Execute(ctx context.Context) {\n        cobra.CheckErr(rootCmd.ExecuteContext(ctx))\n}\n```"]