- en: 'Chapter 7: Writing Command-Line Tooling'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Visit any DevOps engineer and you will find their screens filled with terminals
    executing **Command-Line Interface** (**CLI**) applications.
  prefs: []
  type: TYPE_NORMAL
- en: As a DevOps engineer, we don't want to only use applications that others have
    made for us; we want to be able to write our own CLI applications. These applications
    might communicate to various systems via REST or gRPC, as we discussed in our
    previous chapter. Or you might want to execute various applications and run their
    output through custom processing. An application might even set up a development
    environment and kick off a test cycle for a new release.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever your use case, you will need to use some common packages to help you
    manage the application's input and output processing.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to use the `flag` and `os` packages to write
    simple CLI applications. For more complex applications, you will learn how to
    use the Cobra package. These skills, combined with the skills gained from our
    previous chapter, will let you build a wide gamut of applications for your needs
    or those of your customers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following main topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Implementing application I/O
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Cobra for advanced CLI applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling OS signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this first section, we will jump into how to use the standard library's `flag`
    package to build basic command-line programs. Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for this chapter can be downloaded from [https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/7](https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/7)
  prefs: []
  type: TYPE_NORMAL
- en: Implementing application I/O
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CLI applications require a way to understand how you want them to execute. This
    might include what files to read, what servers to contact, and what credentials
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a couple of ways to start an application with the parameters it requires:'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `flag` package to define command-line flags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `os.Args` to read arguments that are not defined
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `flag` package will help you when you have a command-line argument that
    has a strict definition. This might be an argument that defines the endpoint for
    a needed service. The program might want to have a default value for production
    , but allow an override when doing testing. This is perfect for a flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example might be a program that queries our **Quote of the Day** (**QOTD**)
    server that we created earlier. We might want to have it automatically use our
    production endpoint unless we specify it to use another address. This might look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This simply contacts our production server and gets our quote. The `--endpoint`
    flag, which defaulted to our production address, will use another address below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, application arguments will suffice. Take an application that reformats
    JSON data for human readability. We might want to just read from `STDIN` if no
    files are provided. In this case, just reading the values from the command line
    will suffice, using the `os` package. This will give us executions that look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are reading in `file1.json` and `file2.json` and outputting the reformatted
    text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we receive the output from the `wget` call and read that via STDIN to
    our `reformat` binary . This is similar to how `cat` and `grep` work. When our
    arguments are empty, they simply read from `STDIN`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: And sometimes, we may want a mix of flags and arguments. The `flag` package
    can help with that as well.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's jump into using the `flag` package.
  prefs: []
  type: TYPE_NORMAL
- en: The flag package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To help take in command-line arguments, Go has the standard library `flag` package.
    With `flag`, you can set up default values for your flags, provide descriptions
    for flags, and allow users to override defaults at the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Flags with the `flag` package are simply proceeded by `--`, similar to `--endpoint`.
    Values can simply be a contiguous string following the endpoint or a quoted string.
    While you can use a single `-` instead of `--`, there are some corner cases when
    dealing with Boolean flags. I would recommend using `--` in all cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the `flag` package documentation here: [https://pkg.go.dev/flag](https://pkg.go.dev/flag).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s show a flag in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Defines an `endpoint` variable that stores the flag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses a `String` flag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines the flag as `endpoint`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets the flag's default value as `myserver.aws.com`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets the flag's description
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we don''t pass `--endpoint`, the code will use the default value. To have
    our program read the value, we simply do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: '`flag.String()` returns `*string`, hence `*endpoint` above.'
  prefs: []
  type: TYPE_NORMAL
- en: '`flag.Parse()` is crucial to making your flags available in your application.
    This should only be called inside your `main()` package.'
  prefs: []
  type: TYPE_NORMAL
- en: Pro Tip
  prefs: []
  type: TYPE_NORMAL
- en: A best practice in Go is to never define flags outside your `main` package.
    Simply pass the values as function arguments or in object constructors.
  prefs: []
  type: TYPE_NORMAL
- en: '`flag` also defines a few other flag functions other than `String()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Bool()` for capturing `bool`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Int()` for capturing `int`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Int64()` for capturing `int64`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Uint()` for capturing `uint`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Uint64()` for capturing `uint64`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Float64()` for capturing `float64`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Duration()` for capturing `time.Duration`, such as `3m10s`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have seen the basic types, let's talk about custom flag types.
  prefs: []
  type: TYPE_NORMAL
- en: Custom flags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, we want to take values and put them in types that aren't defined
    in the `flag` package.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use a custom flag, you must define a type that implements the `flag.Value`
    interface, defined as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we are going to borrow an example from Godoc that shows a custom value
    called `URLValue`, which handles flags that represent URLs, and store it in our
    standard `*url.URL` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Defines a `flag.Value` type called `URLValue`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a flag called `-url` that reads in a valid URL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses the `URLValue` wrapper to store the URL in a `*url.URL` variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses the `reflect` package to determine whether `struct` is empty
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By defining a `Set()` method on a type, as we did previously, you can read in
    any custom value.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our flag types down, let's look at some basic error handling.
  prefs: []
  type: TYPE_NORMAL
- en: Basic flag error handling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we enter flags that are not compatible or have a bad value, often we want
    the program to print out the bad flag and the flag values.
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be accomplished with the `PrintDefaults()` option. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Defines a `--help` flag that just prints our defaults if set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defines two other flags, `--prod` and `--dev`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `--prod` and `--dev` are set, prints out an error message and the default
    flag values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If neither are set, puts out an error message and the defaults
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is an example of the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This code illustrates how we can have flags with valid default values, but if
    the values are changed to cause an error, we can detect and handle the error.
    And in the spirit of good command-line tools, we provide `--help` to allow users
    to discover the flags they can use.
  prefs: []
  type: TYPE_NORMAL
- en: Shorthand flags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous example, we had a `--help` flag. But often, you may want to
    offer a shorthand such as `-h` for the user to use. These need to have the same
    default values and both need to set the same variable, so they cannot have two
    separate values.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `flag.[Type]Var()` calls to help us accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, we store the results of `--help` and `--h` in our `help` variable. We
    use `init()` to do the setup, as `BoolVar()` does not return a variable; therefore,
    it cannot be used in a `var()` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how a shorthand flag works, let's have a look at non-flag arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing non-flag arguments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Arguments in Go are read in a few ways. You can read the raw arguments using
    `os.Args`, which will also include all the flags. This is great when no flags
    are used.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using flags, `flag.Args()` can be used to retrieve only the non-flag arguments.
    If we want to send a list of authors to a development server and retrieve QOTDs
    for each author, the command might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In this list, we use a `--dev` flag to indicate that we want to use the development
    server. Following our flag, we have a list of arguments. Let''s retrieve those:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, we do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve the non-flag arguments using `flag.Args()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test that we received at least one author or exit with an error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have seen how to retrieve input that comes as arguments or flags. This can
    be used to define how to contact a server or what files to open. Let's look at
    receiving input from a stream.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving input from STDIN
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most applications that are written today in the DevOps community tend to revolve
    around flags and arguments, as seen previously. One of the less common methods
    of input that DevOps people use daily is piping input into a program.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tools such as `cat`, `xargs`, `sed`, `awk`, and `grep` allow you to pipe the
    output of one tool into the input of the next to accomplish a task. A simple example
    might be just looking for lines in a file we retrieved from the web that contains
    the word `error`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Programs such as `cat` read input from `STDIN` when no file has been specified.
    Let''s duplicate that here for a program that looks for the word `error` on any
    input line and prints it out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Compiles a regex using the `regexp` package to look for a line containing `error`
    – the match is case-insensitive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses `os.Args()` to read our argument list. We use this instead of `flag.Args()`,
    as we haven't defined any flags.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses `os.Stdin` if we have a single argument (the program name), which is an
    `io.Reader` that we wrap in a `bufio.Scanner`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Opens the file if we have a file argument and wraps the `io.Reader` in a `bufio.Scanner`
    object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returns an error if we have more arguments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reads input line by line and prints to `os.Stdout` every line containing the
    word `error`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checks whether we had an input error – `io.EOF` is not considered an error and
    won't trip the `if` statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find this code in the repository [https://github.com/PacktPublishing/Go-for-DevOps/blob/rev0/chapter/7/filter_errors/main.go](https://github.com/PacktPublishing/Go-for-DevOps/blob/rev0/chapter/7/filter_errors/main.go).
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this code compiled as `filter_errors`, we can use this to scan `wget`
    input (or any piped input) for lines containing the word `error` and then use
    `grep` to filter for a particular error code such as `401` (unauthorized):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Or we can search a log file in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is a simplistic example that can easily be achieved with existing tools,
    but this gives a demonstration of how to build similar tooling.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have looked at how to read different input from the command
    line in the form of flags and arguments. We looked at shorthand flags that share
    state with long-form flags. You saw how to create custom types to use as flags.
    And finally, we looked at how to successfully use STDIN to read input that is
    sent via a pipe.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at how to use Cobra, a third-party package, to create more
    sophisticated command-line applications.
  prefs: []
  type: TYPE_NORMAL
- en: Using Cobra for advanced CLI applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cobra is a set of packages that allows a developer to create more complex CLI
    applications. This becomes more useful than just the standard `flag` package when
    the complexity of an application causes a list of flags to become numerous.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will talk about how to use Cobra to create structured CLI
    applications that are friendly to developers to add features and allow users to
    understand what is available in an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few features that Cobra provides are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Nested subcommands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command suggestions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aliases for commands so that you can make changes without breaking users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generation of help text from flags and commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generation of autocompletion for various shells
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Man page creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This section will borrow heavily from the Cobra documentation, which you can
    find here: [https://github.com/spf13/cobra/blob/master/user_guide.md](https://github.com/spf13/cobra/blob/master/user_guide.md).'
  prefs: []
  type: TYPE_NORMAL
- en: Code organization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make effective use of Cobra and make it easy for developers to understand
    where to add and change commands, Cobra suggests the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This structure has your main `main.go` executable at the top-level directory
    and all of your commands under `cmd/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main file for a Cobra application is primarily used to simply initialize
    Cobra and let it perform command executions. The file will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will look at using the Cobra generator application to generate boilerplate
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The optional Cobra generator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cobra provides an application that can generate boilerplate code for our application.
    To get started with the generator, we will create a configuration file for our
    application in our root directory called `~/.cobra.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This will handle printing our MIT license. You can use any of these values
    for the following built-in licenses:'
  prefs: []
  type: TYPE_NORMAL
- en: GPLv2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GPLv3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LGPL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AGPL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2-Clause BSD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 3-Clause BSD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you need a license not found here, instructions on how to provide a custom
    license can be found here: [https://github.com/spf13/cobra-cli/blob/main/README.md#configuring-the-cobra-generator](https://github.com/spf13/cobra-cli/blob/main/README.md#configuring-the-cobra-generator).'
  prefs: []
  type: TYPE_NORMAL
- en: By default, Cobra will use this configuration file from your `home` directory.
    If you need a different license, put the configuration in your repository and
    use `cobra --config="config/location.yaml` to use the alternate configuration
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To download Cobra and build with the Cobra generator, type the following on
    your command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to initialize the application, make sure that you are in the new application''s
    root directory and do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: '`[repo path]` will be something such as `github.com/spf13/newApp`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a few commands for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This will deliver us the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: You are required to use camelCase for command names. Not doing this will cause
    you to encounter errors.
  prefs: []
  type: TYPE_NORMAL
- en: The `-p` option for `create` is used to make it a subcommand of `config`. The
    string that follows is the parent's name plus `Cmd`. All other `add` calls have
    `-p` set to `rootCmd`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you `go build` the application, we can run it like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '`app`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app serve`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app config`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app config create`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`app help serve`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the boilerplate now in place, we will only need to configure the commands
    to execute.
  prefs: []
  type: TYPE_NORMAL
- en: The command package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `cmd` package that has been generated, you will find a file for each
    command that can be executed. We will need to modify each file to give the correct
    help text, use flags, and execute the command.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will look at a generated `cmd/get.go` file for an application created with
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This application will talk to the QOTD server that we created in [*Chapter 6*](B17626_06.xhtml#_idTextAnchor367),
    *Interacting with Remote Data Sources*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The generated `cmd/get.go` file will look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creates a variable called `serveCmd`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variable name is based on the command name plus `Cmd`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Use` is the argument name for the command line.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Short` is the brief description.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Long` is a longer description with examples.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Run` is the entry point for the code you want to execute.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Defines `init()`, which does the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adds this command to the `rootCmd` object.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s use this to write our QOTD CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sets up an `addr` variable to hold our server address:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If `--dev` is passed, it sets `addr` to `devAddr`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, it uses the `--addr` flag's value.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--addr` defaults to `127.0.0.1:80`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a new client for our QOTD server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Calls the QOTD server:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses `Context` passed to `*cobra.Command`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses the `--author` flag value, which defaults to an empty string
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Uses a `--json` flag to determine whether the output should be in JSON:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If JSON, it outputs an inline-defined struct as JSON.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, it just pretty prints it to the screen.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Important Note
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: You will see the `mustBool()` and `mustString()` functions. These simply return
    the value from the flag name that is passed. If the flag isn't defined, it panics.
    This removes a lot of ugly code for something that must always work for the CLI
    application to be valid. These functions are in the repository version.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The flags that you see are not from the standard library `flag` package. Instead,
    this package uses flag types from [https://github.com/spf13/pflag](https://github.com/spf13/pflag).
    This package has more built-in types and methods than the standard `flag` package.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we need to define the flags that we are using in our `Run` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Adds a flag called `--dev` that can be shortened to `-d` and defaults to `false`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adds a flag called `--addr` that defaults to `"127.0.0.1:80"`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adds a flag called `--author` that can be shortened to `-a`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adds a flag called `--json` that defaults to `false`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Methods followed by `P`, such as `BoolP()`, define shortened flags as well as
    the long flag names.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The flags we defined are only available when the `get` command is invoked. If
    we create subcommands on `get`, these will only be available on `get` with no
    sub-commands defined.
  prefs: []
  type: TYPE_NORMAL
- en: To add flags that work on all subcommands, use `.PersistentFlags()` instead
    of `.Flags()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this client can be found in the repository here: [https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/7/cobra/app/](https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/7/cobra/app/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can run our app and call this command. In these examples, you will
    need to run the QOTD server from the gRPC chapter, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This runs our application using the server at the `127.0.0.1:3560` address
    and requests a quote from Eleanor Roosevelt, with output in JSON format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This next example gets a random quote from the server at address `127.0.0.1:3560`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we have learned what the Cobra package is, how to use the Cobra
    generator tool to bootstrap a CLI application, and finally, how to build commands
    for your application using this package.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to look at handling signals to do cleanup before exiting
    your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Handling OS signals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When writing CLI applications, there are occasions when a developer wants to
    handle OS signals. The most common example is a user trying to exit a program,
    usually through a keyboard shortcut.
  prefs: []
  type: TYPE_NORMAL
- en: In these cases, you may want to do some file cleanup before exiting or cancel
    a call you made to a remote system.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will talk about how you can capture and respond to these
    events to make your applications more robust.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing an OS signal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Go deals with two types of OS signals:'
  prefs: []
  type: TYPE_NORMAL
- en: Synchronous
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronous signals generally revolve around program errors. Go treats these
    as runtime panics, and therefore, interception of these can be handled with a
    `defer` statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different asynchronous signals, depending on the platform, but for
    a Go programmer, the most relevant are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SIGHUP`: The connected terminal disconnected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGTERM`: Please quit and do cleanup (generated from a program).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGINT`: The same as `SIGTERM` (sent from the terminal).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGQUIT`: The same as `SIGTERM` plus a core dump (sent from the terminal).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SIGKILL`: The program must quit; this signal cannot be captured.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In situations where these arise, it can be useful to intercept these signals
    so that you can cancel ongoing operations and do a cleanup before exiting. It
    should be noted that `SIGKILL` cannot be intercepted, and `SIGHUP` is simply an
    indication that a process has lost its terminal, not necessarily that it was canceled.
    This could be because it was moved to the background or another similar event.
  prefs: []
  type: TYPE_NORMAL
- en: 'To capture a signal, we can use the `os/signal` package. This package allows
    a program to receive notifications of a signal from an OS and respond. Here is
    a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a channel, `signals`, on which to receive signals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subscribes to signals of the `SIGINT`, `SIGTERM`, and `SIGQUIT` types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Uses a goroutine to handle incoming signals, which does the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calls the `cleanup()` function to handle program cleanup
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Exits with the `1` code on `SIGINT` and `SIGTERM`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Panics, which gives a basic core dump on `SIGQUIT`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Signal-handling code should be done in your `main` package. The `cleanup()`
    function should contain function calls that handle outstanding items, such as
    remote call cancellations and file cleanup.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can control the amount of data and generation method of a core dump using
    an environmental variable, `GOTRACEBACK`. You can read about it here: [https://pkg.go.dev/runtime#hdr-Environment_Variables](https://pkg.go.dev/runtime#hdr-Environment_Variables).'
  prefs: []
  type: TYPE_NORMAL
- en: Using Context to cancel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key method in Go to cause operations to stop processing is to use the context
    cancellation feature of Go's `context.Context` object. This object was discussed
    in [*Chapter 2*](B17626_02.xhtml#_idTextAnchor166), *Go Language Essentials*,
    if you need a refresher.
  prefs: []
  type: TYPE_NORMAL
- en: By simply creating a `Context` object with cancellation in `main()` and passing
    it to all function calls, we can effectively cancel all ongoing work. This can
    be handy when we want to stop processing and do cleanup because a user hits *Ctrl*
    + *C*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to show an advanced signal handling method on a program that does
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a new temporary file every 1 second for 30 seconds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cleans up files if the program is canceled
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start by creating a function to handle our signals:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a new function called `handleSignal()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has an argument called `cancel`, which is used to signal a function chain to
    stop processing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates an `out` channel that we use to return with the signal received
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a `notify` channel to receive signal notifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creates a goroutine to receive signals:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the signal is for exiting, call `cancel()`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Return the signal that told us to exit.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If it is some other signal, just log it.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s create a function that creates our files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Loops 30 times, which does the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checks whether our `ctx` is canceled
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If so, returns the error
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise, creates a file in `tmpFiles`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Sleeps for 1 second between file creations
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This code will create files in `tmpFiles` named from `0` to `29` unless there
    is a problem writing the file or `Context` is canceled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need some code to clean up the files if we receive a `quit` signal.
    If we don''t, the files are left alone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Uses `os.RemoveAll()` to remove the files:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also removes the temporary directory
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Notifies the user that cleanup was done
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s tie it all together with our `main()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This code does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creates a temporary file directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creates a root `Context` object, `ctx`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ctx` can be canceled with `cancel()`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Calls our `handleSignal()` to handle any signal to quit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Executes our `createFiles()` function:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we have an error, we call `cleanup()`.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: After cleanup, we see whether we received a signal as opposed to just an error.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If it is a signal and it is `SIGQUIT`, we call `panic()`. This is because `SIGQUIT`
    should core-dump by definition.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If it was just an error, print the error and return an error code.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The full code for this can be found in the repository here: [https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/7/signals](https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/7/signals).'
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The code must be built with `go build` and run as a binary. It cannot be run
    with `go run`, as the `go` binary that forks our program will intercept the signal
    before our program can.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multiple types of core dumps can be created in Go, controlled by an environmental
    variable. This is controlled by `GOTRACEBACK`. You can read about it here: [https://pkg.go.dev/runtime#hdr-Environment_Variables](https://pkg.go.dev/runtime#hdr-Environment_Variables).'
  prefs: []
  type: TYPE_NORMAL
- en: Cancellation with Cobra
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When Cobra was initially created, the `context` package did not exist. In 2020,
    the program was patched to allow the passing of a `Context` object into `cobra.Command`.
    But unfortunately, the Cobra generator was not updated to generate the necessary
    boilerplate.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add signal handling as we did previously, we simply need to make a couple
    of modifications – first, to the `main.go` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also need to modify `handleSignal()`. You can see those changes here:
    [https://go.dev/play/p/F4SdN-xC-V_L](https://go.dev/play/p/F4SdN-xC-V_L)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you must change the `cmd/root.go` file like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We now have signal handling. When writing our `Run` function, we can use `cmd.Context()`
    to retrieve the `Context` object and look for cancelation.
  prefs: []
  type: TYPE_NORMAL
- en: Case study – a lack of cancellation leads to a death spiral
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the early Google systems to help automate the network was a system called
    Chipmunk. Chipmunk contained authoritative data on the network and would generate
    router configurations from that data.
  prefs: []
  type: TYPE_NORMAL
- en: Like most software, Chipmunk started off working fast and saving a lot of time.
    As the network continued its yearly tenfold growth, the limits of its design and
    language choice began to show.
  prefs: []
  type: TYPE_NORMAL
- en: Chipmunk was built on Django and Python and was not designed for horizontal
    scaling. As the system became busy, configuration requests would start to take
    30 minutes or longer. Timers for these requests would have limits of no more than
    30 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: The design had a fatal flaw when generation approached these limits – if a request
    was canceled, the cancellation was not signaled to the running configuration generator.
  prefs: []
  type: TYPE_NORMAL
- en: This meant that if generation took 25 minutes but was canceled 1 minute in,
    the generator would spend the next 24 minutes working, with no one to receive
    the work.
  prefs: []
  type: TYPE_NORMAL
- en: When a call reached the time limit, the callers would time out and retry. But
    the generator was still working on the previous call. This would lead to a cascade
    failure, as multiple compute-heavy calculations were running, some of which no
    longer had a receiver. This would push the new call over the time limit, as the
    Python **Global Interpreter Lock** (**GIL** [https://wiki.python.org/moin/GlobalInterpreterLock](https://wiki.python.org/moin/GlobalInterpreterLock))
    prevents true multi-threading and each call was doubling CPU usage.
  prefs: []
  type: TYPE_NORMAL
- en: One of the keys to dealing with this type of failure scenario is being able
    to cancel jobs that are no longer needed. This is why it is so important to pipe
    a `context.Context` object throughout a function call chain and look for cancellation
    at logical points. This can greatly reduce the load on a system that reaches a
    threshold and reduce the damage of **Distributed Denial of Service** (**DDoS**)
    attacks.
  prefs: []
  type: TYPE_NORMAL
- en: This section has looked at how a program can intercept OS signals and respond
    to those signals. It has provided an example of using `Context` to handle canceling
    executions that can be used in any application. We have discussed how we can integrate
    that into programs generated with the Cobra generator.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has given you the skills to write basic and advanced command-line
    applications. We discussed how you can use the `flag` package and `os` package
    to receive signals from the user in the form of flags and arguments. We also discussed
    how to read data from `os.Stdin`, which allows you to string multiple executables
    into a chain for processing.
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed more advanced applications, namely the Cobra package and its
    accompanying generator binary, to build advanced command-line tooling with help
    text, shortcuts, and sub-commands.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we have talked about dealing with signals and providing cleanup on
    cancellation from these signals. This included a case study on why cancellation
    can be critical.
  prefs: []
  type: TYPE_NORMAL
- en: The skills you have learned here will be critical in writing tooling in the
    future, from interacting with local files to interacting with services.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about how to automate interactions with the
    command line on your local device or remote devices.
  prefs: []
  type: TYPE_NORMAL
