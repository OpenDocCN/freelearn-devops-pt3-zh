- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: End-to-End Example
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端到端示例
- en: By now, you’ve seen how the different parts of GitLab help you write, review,
    verify, secure, package, and deploy software. These features have been presented
    one at a time, so let’s put them all together in a single end-to-end example so
    you can see the whole process in one fell swoop. There won’t be any new material
    in this chapter, so it will be a great chance to review what you’ve learned in
    earlier chapters and see it all consolidated in one extended workflow.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经了解了 GitLab 的各个部分如何帮助你编写、审查、验证、保护、打包和部署软件。这些功能已经一一介绍过了，现在让我们把它们全部结合起来，展示一个完整的端到端示例，让你能一次性看到整个过程。在本章中不会有任何新的内容，所以这是一个复习之前章节内容的好机会，看看它们如何在一个扩展的工作流程中整合在一起。
- en: 'This chapter is broken into many subsections, each showing how to use GitLab
    to help with a different part of the software development life cycle:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为多个子章节，每个章节展示如何使用 GitLab 来帮助软件开发生命周期中的不同部分：
- en: Setting up your environment
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置你的开发环境
- en: Writing code
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写代码
- en: Establishing the pipeline infrastructure
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立流水线基础设施
- en: Verifying your code
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证你的代码
- en: Securing your code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护你的代码
- en: Improving your pipeline
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改进你的流水线
- en: Delivering your code to the right environment
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将你的代码交付到正确的环境
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: If you’d like to follow along as we develop a piece of software with GitLab,
    all you need is an account on a GitLab instance, whether Software-as-a-Service
    (SaaS) or self-hosted.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想跟随我们一起开发一款使用 GitLab 的软件，你只需要拥有一个 GitLab 实例的账户，无论是软件即服务（SaaS）还是自托管实例。
- en: Setting up your environment
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置你的开发环境
- en: Before you start writing any code, you need to organize a few preliminary things.
    Specifically, you need to make a GitLab project for storing your code and running
    your pipelines, you need to make some GitLab issues to help plan and track your
    work, and you need to clone the project’s repository to your local computer so
    that you can write code using your favorite IDE instead of entirely within the
    GitLab GUI.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在你开始编写任何代码之前，需要整理一些初步事项。具体来说，你需要创建一个 GitLab 项目来存储你的代码并运行你的流水线，你需要创建一些 GitLab
    问题来帮助规划和跟踪你的工作，此外你还需要将项目的代码仓库克隆到本地计算机，这样你就可以使用自己喜欢的 IDE 编写代码，而不是完全依赖 GitLab 的图形界面。
- en: Making a GitLab project
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个 GitLab 项目
- en: Let’s rewind to the beginning of our journey with the Hats for Cats web app.
    We know we want to make a web app for our online feline accessories store, so
    let’s start by making a GitLab project to hold not only our web app’s code but
    also the additional GitLab components that we’ll be using as we build the app.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到创建 Hats for Cats 网页应用的初衷。我们知道我们想为我们的在线猫咪配饰商店开发一个网页应用，所以让我们首先创建一个 GitLab
    项目，既容纳网页应用的代码，也容纳我们在开发过程中将使用的其他 GitLab 组件。
- en: A note about the GUI
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 关于图形用户界面的说明
- en: Throughout this chapter, we’ll continue our practice of showing you code snippets
    but generally not showing the steps for using the GitLab GUI. This is because
    we want to avoid having the screenshots drift away from reality as the GitLab
    GUI changes in future releases.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续展示代码片段，但通常不会展示使用 GitLab 图形界面的步骤。这样做是为了避免随着 GitLab 图形界面在未来版本中发生变化，截图内容会失去实用性。
- en: 'We could make a Hats for Cats project directly within the top-level namespace
    of our GitLab account, but it seems likely that we’ll want to make more projects
    in the future—perhaps for other web apps, perhaps for other versions of the web
    app aimed at different platforms—so first, let’s make a GitLab group to hold all
    of our projects. Let’s pretend that our company is called Acme Software, so we’ll
    start with a group called, unsurprisingly, Acme Software:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以直接在 GitLab 账户的顶级命名空间中创建一个 Hats for Cats 项目，但考虑到我们未来可能会创建更多项目——也许是其他网页应用，也许是针对不同平台的同一网页应用的不同版本——因此，首先我们应该创建一个
    GitLab 组来容纳所有项目。假设我们的公司名为 Acme Software，我们将从一个名为 Acme Software 的组开始：
- en: '![Figure 11.1 – The Acme Software group](img/B18073_11_1.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1 – Acme Software 组](img/B18073_11_1.jpg)'
- en: Figure 11.1 – The Acme Software group
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – Acme Software 组
- en: 'Within this group, we can add a new project that holds the Hats for Cats web
    app. Let’s call it `Hats for Cats`, and let’s choose the `README.md` file in its
    Git repository, but nothing else. Here’s what the new project looks like immediately
    after creation:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个组内，我们可以添加一个新的项目来托管 Hats for Cats 网页应用。我们将其命名为 `Hats for Cats`，并选择其 Git 仓库中的
    `README.md` 文件，但不选择其他文件。创建后的新项目如下所示：
- en: '![Figure 11.2 – The Hats for Cats project](img/B18073_11_2.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2 – Hats for Cats 项目](img/B18073_11_2.jpg)'
- en: Figure 11.2 – The Hats for Cats project
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – **Hats for Cats** 项目
- en: 'As you already know, this project will hold not only the code for our web app
    but also the configuration file for our CI/CD pipeline, branches and **Merge Requests**
    (**MRs**) related to our code, packaged bits of code ready for deployment, and
    issues to help us plan and track our work. That leads nicely into the next step
    of our workflow: creating GitLab issues.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你已经知道的，这个项目不仅包含我们的网页应用程序的代码，还包括我们的 CI/CD 管道配置文件、与代码相关的分支和**合并请求**（**MRs**）、准备部署的代码包，以及帮助我们规划和跟踪工作的各类问题。这自然引出了我们工作流的下一步：创建
    GitLab 问题。
- en: Placing all projects within a group
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有项目放置在一个小组中
- en: For technical reasons, the screenshots in the rest of this chapter show the
    **Hats for Cats** project directly under the user’s account instead of within
    the **Acme Software** group. However, the best practice is to create all of your
    company or organization’s projects within a single master group.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 出于技术原因，本章其余部分的截图显示的是**Hats for Cats**项目直接在用户账户下，而不是在**Acme Software**小组中。然而，最佳实践是将公司或组织的所有项目都创建在一个主小组下。
- en: Planning work with GitLab issues
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 GitLab 问题规划工作
- en: Using GitLab issues to plan and track your work is an optional but highly recommended
    part of writing software with GitLab. You can, of course, use other tools such
    as Jira or Trello to map out your work, but many developers find that GitLab issues
    give them all the power they need for standard project management tasks.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 GitLab 问题来规划和跟踪工作是编写 GitLab 软件的一个可选但强烈推荐的步骤。当然，你可以使用其他工具，如 Jira 或 Trello
    来规划工作，但许多开发人员发现，GitLab 问题可以为标准项目管理任务提供所需的所有功能。
- en: 'GitLab projects for non-trivial pieces of software might contain tens, hundreds,
    or, in extreme cases, thousands of issues—for instructional purposes, let’s create
    just four issues for our project. To build the **minimum viable product** (**MVP**)
    for our web app, let’s make issues with these titles:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab 项目对于一些复杂的软件可能包含数十个、数百个，甚至在极端情况下，包含成千上万的问题——为了教学目的，让我们只为我们的项目创建四个问题。为了构建我们的网页应用程序的**最小可行产品**（**MVP**），我们将创建以下标题的问题：
- en: '`Allow user to` `log in`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`允许用户` `登录`'
- en: '`Allow user to` `search inventory`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`允许用户` `搜索库存`'
- en: '`Allow user to buy` `a hat`'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`允许用户购买` `一顶帽子`'
- en: '`Allow user to` `log out`'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`允许用户` `登出`'
- en: Once those are in place, let’s think about GitLab labels. Some teams use multiple
    labels on each issue to indicate ownership, assign priority, or perform other
    administrative functions. Let’s create and assign an unscoped **security** label
    to show that the login and log-out issues need extra scrutiny from our security
    team. Let’s also make scoped **priority::high** and **priority::low** labels to
    indicate which features should be worked on first and which came come later. For
    now, just assign **priority::high** to the login issue—we’ll decide as a team
    later what priority labels to give to the rest of the issues.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些准备好后，我们就可以考虑 GitLab 标签了。一些团队会在每个问题上使用多个标签，以指示归属、分配优先级或执行其他管理功能。让我们创建并分配一个无范围的**安全**标签，表示登录和登出的问题需要我们的安全团队额外关注。我们还将创建带有范围的**priority::high**和**priority::low**标签，指示哪些功能应优先处理，哪些可以稍后再做。目前，只需将**priority::high**分配给登录问题——我们稍后会作为团队决定其他问题的优先级标签。
- en: Next, let’s tackle the metadata for the login issue, which is the feature we
    want to develop first. We open that issue, assign it to a developer, set the **Weight**
    field to **5** (which, after some discussion, we decide is a reasonable weight
    for a medium-sized task), use a quick action to estimate that it will take 15
    hours of work to complete, and set a due date. Setting metadata at the same time
    that the issue is created is a practice that you often see among teams that use
    the Kanban workflow; if we were using the Scrum workflow, we might have saved
    assigning a due date, weight, or estimated hours until the next backlog grooming
    ceremony.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们处理登录问题的元数据，这是我们希望首先开发的功能。我们打开该问题，将其分配给开发人员，将**Weight**字段设置为**5**（经过讨论，我们认为这是一个中等大小任务的合理权重），使用快速操作估算完成它需要15小时的工作时间，并设置一个截止日期。在创建问题的同时设置元数据是许多使用看板工作流的团队的常见做法；如果我们使用的是
    Scrum 工作流，可能会等到下一次积压梳理会议时再分配截止日期、权重或估算工时。
- en: 'After creating these four issues, creating and assigning appropriate labels,
    and filling in metadata for one issue, clicking **Issues** | **List** in the left-hand
    navigation pane should show something like this. Notice that the metadata is displayed
    right in the issue list, which is handy:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建了这四个问题、为它们创建并分配了适当的标签，并填写了其中一个问题的元数据后，点击左侧导航栏中的**问题** | **列表**，应该会显示类似这样的内容。请注意，元数据直接显示在问题列表中，这非常方便：
- en: '![Figure 11.3 – Hats for Cats issues and issue metadata](img/B18073_11_3.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – Hats for Cats 问题和问题元数据](img/B18073_11_3.jpg)'
- en: Figure 11.3 – Hats for Cats issues and issue metadata
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – Hats for Cats 问题和问题元数据
- en: 'You’re done with getting your GitLab environment set up: you’ve created a GitLab
    group, made a GitLab project inside it, and made some issues to work against.
    Now, you’re ready to start writing code and storing it in that project.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经完成了GitLab环境的设置：你创建了一个GitLab组，在其中创建了一个GitLab项目，并创建了一些需要解决的问题。现在，你已经准备好开始编写代码，并将其存储在该项目中。
- en: Setting up a local Git repository
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置本地Git版本库
- en: Although we *could* do all of our development work within the GitLab instance,
    that would make writing code difficult and testing impossible. Instead, let’s
    clone the repository to a local computer so that we can develop using whatever
    desktop IDEs or other tools we’re most comfortable with.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们*可以*在GitLab实例内完成所有的开发工作，但那样会使得编写代码变得困难，测试也无法进行。相反，让我们将版本库克隆到本地计算机上，这样我们就可以使用我们最熟悉的桌面IDE或其他工具来进行开发。
- en: First, we need to make sure that we’ve generated a public/private key pair on
    our workstation and uploaded the public key to our GitLab account. This only needs
    to be done once for any GitLab instance we’re working with, so let’s assume that
    we’ve already taken care of this. The GitLab documentation has more information
    about this process.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要确保已经在工作站上生成了公钥/私钥对，并将公钥上传到GitLab帐户。这项工作对于任何我们正在使用的GitLab实例只需做一次，因此我们假设这部分已经完成。GitLab文档中有关于此过程的更多信息。
- en: 'Next, we need to grab the address that we’ll use to clone the **Hats for Cats**
    project’s repository. Since we’re using key-based security instead of manually
    entering authentication credentials with every Git command, we copy the project’s
    SSH address using the GUI, and then clone it by running this command on our local
    machine (if you’re following along at home, you’ll see a slightly different address
    based on your GitLab account name):'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要获取用于克隆**Hats for Cats**项目版本库的地址。由于我们使用基于密钥的安全性，而不是在每个Git命令中手动输入认证凭据，因此我们通过图形界面复制项目的SSH地址，然后通过在本地机器上运行以下命令来克隆它（如果你在家里跟着操作，你会看到一个略有不同的地址，基于你的GitLab帐户名）：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can then move into the directory created by the clone operation and look
    around. If everything has worked as expected, we should see local copies of the
    same files that exist in the GitLab-hosted copy of the repository—which at this
    point is just one `README.md` file:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以进入克隆操作创建的目录并查看。如果一切正常，我们应该会看到与GitLab托管版本库中相同的文件的本地副本——此时的副本只有一个`README.md`文件：
- en: '[PRE1]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, we’re all set to do local development, push any changes we make up to the
    copy of the repository on GitLab, and pull down any changes that coworkers have
    pushed up.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好进行本地开发，将任何修改推送到GitLab上版本库的副本，并拉取同事们推送上来的修改。
- en: Writing code
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写代码
- en: You’re almost at the point where you can start coding. First, you’ll need a
    Git branch to commit the code to. Then, you’ll need a MR so that you can see the
    results of pipeline tasks that run against that code, and also so that you can
    eventually merge the code into the `main` branch. Let’s go over those steps, and
    then make and push your first commit.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经接近可以开始编码的阶段。首先，你需要一个Git分支来提交代码。然后，你需要一个MR，这样你就可以看到针对这段代码运行的管道任务的结果，并且最终将代码合并到`main`分支。让我们先了解这些步骤，然后进行第一次提交并推送。
- en: Creating a Git branch to work on
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个用于开发的Git分支
- en: 'Now that we’re ready to add the login feature requested by our first assigned
    issue, we need a Git branch to commit to. We might as well name our branch after
    the title of the issue we’re working on:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好添加第一个分配问题所要求的登录功能，我们需要一个Git分支来提交代码。我们不妨将分支命名为我们正在处理的那个问题的标题：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Switch onto the new branch so any new commits end up on that branch and not
    on the `main` branch:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到新的分支，这样任何新的提交都将进入该分支，而不是`main`分支：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'At this point, we might as well push this branch up to the GitLab-hosted copy
    of the repository so that it exists in both places. For the first push, we need
    to use a slightly longer command:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们不妨将这个分支推送到 GitLab 托管的代码库副本中，这样它就能同时存在于两个地方。对于第一次推送，我们需要使用一个稍微长一些的命令：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For subsequent pushes, after we’ve added some commits, we can rely on a simpler
    command:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于后续的推送，在我们添加了一些提交之后，我们可以依赖一个更简单的命令：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If we look at the project’s repository in GitLab, we can see that it now lists
    **add-login-feature** within the dropdown of the project’s branches.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 GitLab 中项目的代码库，可以看到它现在在项目的分支下拉菜单中列出了**add-login-feature**。
- en: Creating an MR
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 MR
- en: Let’s follow GitLab best practices and immediately make an MR associated with
    the branch we just created. Navigate to **Ns** in the left-hand navigation pane
    and click on **New merge request**. Select **add-login-feature** as the source
    branch and **main** as the target branch, and click **Compare branches** **and
    continue**.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们遵循 GitLab 最佳实践，立即为我们刚创建的分支创建一个 MR。导航到左侧导航窗格中的**Ns**，点击**New merge request**。选择**add-login-feature**作为源分支，**main**作为目标分支，然后点击**Compare
    branches** **and continue**。
- en: 'Title the MR `Draft: add login feature` and add `Closes #X` in the description
    field, where `X` is replaced by the number of the `#` in the description, the
    GUI will present you with a dropdown showing all the issues you’ve created, so
    you don’t need to look up the issue number manually). Now, we’ve created the “three
    amigos” of issue, branch, and MR, so we’re ready to get to work developing our
    feature.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '给 MR 起个标题 `Draft: add login feature`，并在描述字段中添加`Closes #X`，其中`X`替换为描述中的`#`对应的数字，图形界面会为你展示一个下拉菜单，显示你创建的所有问题，这样你就不需要手动查找问题编号了）。现在，我们已经创建了问题、分支和
    MR 这“三个好朋友”，可以开始开发我们的功能了。'
- en: Committing and pushing code
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提交和推送代码
- en: 'It’s time to write some code! Instead of writing an actual login page with
    real GUI elements and logic, let’s use our local computer to make a file called
    `login.py` in the root of the `print("Welcome to Hats for Cats!")`. Since we’re
    doing this on our local computer rather than on GitLab, we need to use Git terminal
    commands or a GUI tool for Git (such as **Sourcetree** or **Tower**, or the Git
    tools built into IDEs such as **IntelliJ IDEA** or **Visual Studio Code**) to
    add our new file to the Git staging area and then commit it with an appropriate
    message. Perform these operations on the command line like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 该是写代码的时候了！我们不打算写一个包含真实 GUI 元素和逻辑的实际登录页面，而是用我们本地的计算机在`print("Welcome to Hats
    for Cats!")`的根目录下创建一个名为`login.py`的文件。因为我们是在本地计算机上操作，而不是在 GitLab 上，所以我们需要使用 Git
    终端命令或者 Git 的图形化工具（如**Sourcetree**、**Tower**，或内置于 IDE（如**IntelliJ IDEA**或**Visual
    Studio Code**）中的 Git 工具）将新文件添加到 Git 暂存区，然后提交一个适当的提交信息。可以通过命令行进行这些操作：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It’s important to reiterate at this point that the local commit will *not* trigger
    a CI/CD pipeline. The GitLab instance doesn’t know that the commit exists, and
    even if it did, it doesn’t have any way of seeing the code included in that commit.
    However, as soon as we push any local commits up to GitLab, it will detect those
    commits in its own copy of the repository and run a pipeline against whatever
    commits we pushed up.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上必须重申，本地提交*不会*触发 CI/CD 流水线。GitLab 实例并不知道这个提交的存在，即使知道，它也无法查看该提交中包含的代码。然而，一旦我们将任何本地提交推送到
    GitLab，它会在自己副本中的代码库中检测到这些提交，并针对我们推送的任何提交运行流水线。
- en: 'Let’s push the **add-login-feature** branch now:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们推送**add-login-feature**分支：
- en: '[PRE7]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Pushing frequently is important!
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 经常推送非常重要！
- en: We could have waited to push this branch until we had made several local commits
    to it, but since much of the power of GitLab’s CI/CD pipelines comes from having
    them run frequently against small code changes, it’s usually wisest to push after
    every local commit.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以等到对这个分支做了多个本地提交后再推送，但由于 GitLab CI/CD 流水线的强大功能正是来自于它们频繁地对小的代码变化进行运行，通常在每次本地提交后推送是最明智的选择。
- en: This was such a simple edit—adding a single file that contains a single line
    of code—that you might be wondering why we didn’t just make the edit and commit
    the change within the GitLab GUI instead of going through the hassle of editing
    and committing locally and then pushing that edit up to GitLab. Honestly, with
    a change this small, we could easily have gotten away with performing the edit
    right on GitLab. If this were a real-world project, that’s exactly what we would
    advise you to do, but since most development work is quite a bit more complicated
    than the placeholder code included here, we thought it would be helpful to show
    you the typical *edit-and-commit-locally-and-then-push* workflow that you’ll be
    using for most of your development work.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个如此简单的编辑——添加一个包含一行代码的文件——你可能会想，为什么我们不直接在GitLab GUI中进行编辑并提交更改，而要通过本地编辑、提交再推送到GitLab的麻烦。说实话，对于这样一个小更改，我们完全可以直接在GitLab上进行编辑。如果这是一个真实项目，那正是我们会建议你这么做，但由于大多数开发工作远比这里包含的占位符代码更为复杂，我们认为展示一下典型的*本地编辑并提交然后推送*工作流会对你有所帮助，这是你在大多数开发工作中会用到的流程。
- en: Establishing the pipeline infrastructure
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 建立管道基础设施
- en: You’ve stored some code in the repository, so now it’s time to set up a pipeline
    to run a variety of tasks to build, verify, and secure your code. In some cases,
    you might also want to set up a GitLab Runner to execute those pipeline tasks,
    although that task is usually taken care of for you by your GitLab administrator
    or the GitLab SaaS platform.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经将一些代码存储在仓库中，所以现在是时候设置一个管道，执行一系列任务来构建、验证和保护你的代码。在某些情况下，你可能还想设置一个GitLab Runner来执行这些管道任务，尽管这个任务通常由你的GitLab管理员或GitLab
    SaaS平台为你处理。
- en: Creating a pipeline
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建管道
- en: Pushing commits to GitLab so that it can run CI/CD pipelines on our new code
    won’t work unless we define what tasks we’d like our pipeline to perform. We’ll
    add several tasks to our **Hats for Cats** project’s pipeline as we go through
    the rest of this chapter, but for now, let’s get a bare-bones pipeline in place.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 向GitLab推送提交，以便它可以在我们的新代码上运行CI/CD管道，只有在我们定义了管道要执行的任务后，这一操作才会生效。我们将在本章接下来的部分中向**Hats
    for Cats**项目的管道中添加多个任务，但现在，让我们先设置一个基础的管道。
- en: Just as we did with our initial file, we could create the `.gitlab-ci.yml` pipeline
    configuration file locally, commit it, and push it up to GitLab, but since the
    GitLab GUI offers a handy editor dedicated to writing and debugging pipeline configuration
    files, it often makes more sense to edit it on GitLab. Having a local copy of
    `.gitlab-ci.yml` isn’t important since we can’t use it to run pipelines on our
    local machine anyway.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在最初的文件中所做的那样，我们可以在本地创建`.gitlab-ci.yml`管道配置文件，提交并推送到GitLab，但由于GitLab GUI提供了一个专门用于编写和调试管道配置文件的方便编辑器，通常更有意义在GitLab上进行编辑。因为我们无法在本地机器上运行管道，所以`.gitlab-ci.yml`的本地副本并不重要。
- en: 'In the left-hand navigation pane, select `.gitlab-ci.yml`. At this point, we’re
    not sure what stages we’re going to end up needing in our pipeline. It could be
    reasonably argued that there’s no point defining stages until you actually need
    them, but we’re fairly confident that we’ll need the basic trio of `build`, `test`,
    and `deploy`, so in the interest of fleshing out this example, let’s add all three
    right now:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧导航面板中，选择`.gitlab-ci.yml`。此时，我们并不确定在管道中需要哪些阶段。可以合理地认为，在你真正需要阶段之前没必要定义它们，但我们相当确信我们将需要`build`、`test`和`deploy`这三项基本任务，因此为了完整展示这个例子，我们现在就添加这三项：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Since Python is an interpreted rather than compiled language, we don’t have
    any jobs to define within the `build` stage yet. We also haven’t written any automated
    tests yet, so there’s no point in adding jobs to execute tests. We’ll want to
    run some security scans and do other verification tasks, but we’ll define those
    jobs later. We’re also going to need to deploy our code to various environments,
    but that too will be tackled down the road. For now, let’s just add a dummy job
    so that GitLab doesn’t complain about the lack of any job definitions in our pipeline
    (if we didn’t, GitLab would actually consider the pipeline configuration file
    to be malformed, and the linter that appears at the top of the dedicated editor
    would squawk at us). Paste this below the `stages:` section:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Python是一种解释型语言，而非编译型语言，我们在`build`阶段还没有任何需要定义的任务。我们也还没有编写任何自动化测试，因此没有必要添加执行测试的任务。我们希望运行一些安全扫描并进行其他验证任务，但这些任务将在稍后定义。我们还需要将代码部署到多个环境中，但这也将稍后处理。现在，让我们只添加一个虚拟任务，这样GitLab就不会因为管道中缺少任务定义而抱怨（如果我们不这样做，GitLab实际上会认为管道配置文件格式不正确，并且位于专用编辑器顶部的代码检查器会给我们警告）。将这个内容粘贴到`stages:`部分下方：
- en: '[PRE9]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: After committing this change, we navigate to `.gitlab-ci.yml`—and that it executed
    `job1` on a shared runner without any problems. Of course, if you’re working on
    a GitLab instance that doesn’t offer any shared runners, you’ll need to create
    your own runners for this project before the pipeline will run. Fortunately, that’s
    the very next step in our workflow.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在提交此更改后，我们导航到`.gitlab-ci.yml`—并且它在共享运行器上成功执行了`job1`，没有任何问题。当然，如果你使用的是没有提供共享运行器的GitLab实例，你需要为该项目创建自己的运行器，才能使管道运行。幸运的是，这正是我们工作流中的下一个步骤。
- en: Creating a runner
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个运行器
- en: As you know, users of the SaaS version of GitLab can run their pipelines on
    the GitLab Runners provided as part of their software subscription, but if you’re
    using a self-hosted version of GitLab, or if you want to run some pipelines on
    your own hardware to avoid exhausting your subscription’s GitLab Runner minutes,
    you’ll want to set up one or more of your own GitLab Runners. Let’s create some
    specific runners that are dedicated to our **Hats for** **Cats** project.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，GitLab的SaaS版本用户可以在GitLab Runners上运行他们的管道，这些Runners是软件订阅的一部分，但如果你使用的是自托管版本的GitLab，或者如果你想在自己的硬件上运行一些管道，以避免耗尽订阅中的GitLab
    Runner分钟数，你需要设置一个或多个你自己的GitLab Runners。让我们为我们的**Hats for** **Cats**项目创建一些专用的运行器。
- en: We decide to create runners on a spare Linux box that’s lying around. Remembering
    that the versions of the GitLab Runner binary that’s included in major Linux distribution
    repositories are often a few versions old, we consult the GitLab documentation
    to find out how to add the official GitLab repository to our Linux box’s package
    management system, download the latest GitLab Runner binary, install it as a service,
    and make sure it’s running. Since the exact process for this varies by the operating
    system and Linux distribution, we won’t include explicit instructions here.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定在一台闲置的Linux机器上创建运行器。考虑到GitLab Runner二进制文件在主要Linux发行版的仓库中通常是几个版本之前的版本，我们查阅了GitLab文档，了解如何将官方GitLab仓库添加到我们的Linux机器的包管理系统中，下载最新的GitLab
    Runner二进制文件，将其作为服务安装，并确保它在运行。由于这个过程因操作系统和Linux发行版而异，我们在这里不会提供详细的操作步骤。
- en: GitLab Runner versions
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab Runner版本
- en: Although GitLab Runners usually work even when they are a few minor versions
    away from the version of the GitLab instance (15.0 vs. 15.3, for example), they
    will operate most reliably if you keep the two versions in sync.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管GitLab Runners通常在与GitLab实例的版本相差几个小版本时仍然能正常工作（例如15.0对15.3），但如果你保持这两个版本同步，它们将最可靠地运行。
- en: Once the `gitlab-runner` binary is installed on the computer that will host
    the runners, we need to create runners by registering them. Before doing so, we
    need to collect some information. We’ve already decided that the runners will
    be specific to the `abc123`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`gitlab-runner`二进制文件安装在将托管运行器的计算机上，我们需要通过注册它们来创建运行器。在此之前，我们需要收集一些信息。我们已经决定运行器将专门用于`abc123`。
- en: 'We decide to register two runners. We could call them anything we want, but
    we settle on the most obvious naming scheme: **Hats for Cats 1** and **Hats for**
    **Cats 2**.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们决定注册两个运行器。我们可以随意给它们命名，但我们最终选择了最明显的命名方案：**Hats for Cats 1**和**Hats for** **Cats
    2**。
- en: 'Next, we choose to use the Docker executor with both runners since that gives
    them the most flexibility: they can handle any CI/CD pipeline job because they
    can execute jobs within a Docker image that has all of the required tools already
    installed. We decide to specify `alpine:latest` as the default Docker image that
    the runners will use for jobs that don’t specify an image since that’s the smallest
    full-featured Linux distribution and therefore the quickest to download. Finally,
    we decide not to add any tags to the runners since we don’t intend either runner
    to be special-purpose in any way.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们选择在两个运行器上都使用 Docker 执行器，因为这样可以为它们提供最大的灵活性：它们可以处理任何 CI/CD 流水线作业，因为它们可以在已经安装了所有必需工具的
    Docker 镜像中执行作业。我们决定指定 `alpine:latest` 作为运行器将用于未指定镜像的作业的默认 Docker 镜像，因为这是最小的功能完备的
    Linux 发行版，因此下载速度最快。最后，我们决定不向运行器添加任何标签，因为我们不打算使任何一个运行器成为特定用途。
- en: Of course, we can’t register runners with the Docker executor unless Docker
    is installed and running on the machine that’s hosting the runners. Installation
    instructions for Docker change occasionally and vary according to the operating
    system, so the official Docker documentation is your best source of information
    for this step.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，除非托管运行器的机器上安装并运行 Docker，否则我们无法使用 Docker 执行器注册运行器。Docker 的安装说明偶尔会有所变化，并且根据操作系统而异，因此官方
    Docker 文档是您在此步骤中的最佳信息来源。
- en: 'Once Docker is up and running on the same host machine as the runners we could
    register a single runner interactively with `gitlab-runner register`, but in this
    case, let’s register the runners non-interactively by passing in all the details
    as options to a single terminal command. We register the first runner using this
    command on the Linux box that will host the runners (changing the `--url` and
    `--registration-token` values as appropriate):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Docker 在与运行器相同的主机上启动并运行，我们可以通过 `gitlab-runner register` 以交互方式注册单个运行器，但在这种情况下，让我们通过将所有细节作为选项传递给单个终端命令来非交互式地注册运行器。我们使用这条命令在将托管运行器的
    Linux 服务器上注册第一个运行器（根据需要更改 `--url` 和 `--registration-token` 值）：
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Do I need to use sudo?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我需要使用 sudo 吗？
- en: Check the GitLab documentation to find out whether the `gitlab-runner` binary
    requires `sudo` or administrator permissions on your operating system; the command
    behaves differently on different platforms.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 检查 GitLab 文档，了解在您的操作系统上 `gitlab-runner` 二进制文件是否需要 `sudo` 或管理员权限；命令在不同平台上的行为有所不同。
- en: We can run the same command, changing the value of the `--description` option,
    to create the second runner.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以运行相同的命令，更改 `--description` 选项的值，以创建第二个运行器。
- en: 'Now that both runners have been registered, let’s double-check that they’re
    both up and running:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在两个运行器都已注册，请确保它们都已启动并运行：
- en: '[PRE11]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, let’s refresh the GitLab page that we reached via **Settings** | **CI/CD**
    | **Runners** and make sure both runners were able to check in with our GitLab
    instance and declare themselves ready to accept jobs from the **Hats for Cats**
    project. Here’s the relevant portion of that screen:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请刷新我们通过 **设置** | **CI/CD** | **Runners** 进入的 GitLab 页面，并确保两个运行器能够连接到我们的 GitLab
    实例并声明自己已准备好接受来自 **Hats for Cats** 项目的作业。这是该屏幕相关部分的内容：
- en: '![Figure 11.4 – Specific runners for the Hats for Cats project](img/B18073_11_4.jpg)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4 – Hats for Cats 项目的特定运行器](img/B18073_11_4.jpg)'
- en: Figure 11.4 – Specific runners for the Hats for Cats project
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – Hats for Cats 项目的特定运行器
- en: Before proceeding, you might want to review the GitLab documentation to learn
    more about the `concurrent` and `check_interval` options in the master configuration
    file for your registered runners. Sometimes, adjusting the values of these two
    options can help runners pick up jobs more quickly. This configuration file is
    `/etc/gitlab-runner/config.toml` on Linux systems that run the `gitlab-runner`
    binary as root, but might exist in other locations when `gitlab-runner` is not
    run as root or is run on other operating systems. Running `gitlab-runner list`
    (with or without `sudo`, depending on how you registered your runners) should
    reveal the location of this file on your system.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，您可能希望查阅 GitLab 文档，以了解注册运行器的主配置文件中 `concurrent` 和 `check_interval` 选项的更多信息。有时，调整这两个选项的值可以帮助运行器更快地接收作业。这个配置文件在将
    `gitlab-runner` 二进制文件作为 root 用户运行的 Linux 系统上是 `/etc/gitlab-runner/config.toml`，但当
    `gitlab-runner` 不作为 root 运行或在其他操作系统上运行时，可能存在其他位置。运行 `gitlab-runner list`（根据您注册运行器的方式，可能需要或不需要
    `sudo`）应该会显示该文件在您系统上的位置。
- en: 'Optional: disabling shared runners'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 可选：禁用共享运行器
- en: If you’re following along in your own GitLab account, you might want to go to
    **Settings** | **CI/CD** | **Runners** and disable all the shared runners for
    the **Hats for Cats** project. This ensures that all of the project’s CI/CD pipeline
    jobs will be assigned to one of the two runners we just registered.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在自己的 GitLab 账户中操作，可能需要前往 **Settings** | **CI/CD** | **Runners** 并禁用所有 **Hats
    for Cats** 项目的共享 Runner。这样可以确保该项目的所有 CI/CD 流水线任务会被分配到我们刚刚注册的两个 Runner 之一。
- en: With a basic CI/CD pipeline configuration file in place and two runners registered,
    we’ve completed the setup of the basic pipeline infrastructure for our project.
    Now, we need to start filling the pipeline with jobs so that it can run all the
    tests and scans that make GitLab pipelines such a powerful software development
    tool.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置好基础的 CI/CD 流水线配置文件并注册了两个 Runner 后，我们已完成项目基本流水线基础设施的设置。现在，我们需要开始向流水线中添加任务，以便它可以运行所有的测试和扫描，从而让
    GitLab 流水线成为一个强大的软件开发工具。
- en: Verifying your code
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证你的代码
- en: Let’s configure your pipeline so that it can verify your code by running functional
    tests, Code Quality scanning, and fuzz tests.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们配置你的流水线，使其能够通过运行功能测试、代码质量扫描和模糊测试来验证你的代码。
- en: Adding functional tests to the pipeline
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向流水线添加功能测试
- en: Many teams start populating their pipelines by adding tasks to run automated
    functional tests to make sure their code is behaving the way it was designed to.
    You learned in previous chapters that there are many different sorts of functional
    tests. In this example, we’ll add some basic automated unit tests written with
    the `pytest` framework. Our project’s code is not yet complicated enough to require
    real unit tests, but for the sake of this example, we can add dummy tests so that
    GitLab can run them and display their results.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 许多团队通过向流水线添加任务来运行自动化功能测试，确保他们的代码按预期的方式运行。在之前的章节中，你已经学到有许多不同种类的功能测试。在这个例子中，我们将添加一些使用
    `pytest` 框架编写的基础自动化单元测试。我们的项目代码尚不复杂到需要真正的单元测试，但为了本示例，我们可以添加一些虚拟测试，以便 GitLab 可以运行它们并显示结果。
- en: 'Before adding any tests, let’s make our login code *slightly* more complicated
    by adding a function that our tests can exercise, and a “to-do” comment that not
    only reminds us to flesh out this placeholder function later but also gives the
    Code Quality scanner something to detect when we add it to our pipeline down the
    road. Either locally (in which case you need to follow up with a commit and a
    push) or in the GitLab GUI, add this simple code to the `login.py` file:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加任何测试之前，让我们先使登录代码变得 *稍微* 复杂一点，通过添加一个函数供测试调用，并在其中加入一个“待办”注释，不仅提醒我们稍后完善这个占位符函数，还给代码质量扫描器提供了检测的目标。无论是在本地（在这种情况下，你需要进行提交并推送）还是在
    GitLab 图形界面中，都将以下简单代码添加到 `login.py` 文件中：
- en: '[PRE12]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We also need to declare a dependency on the `pytest` framework so that GitLab
    can install it before running the automated tests. Since this is a Python project,
    we declare this dependency in a new `requirements.txt` file at the top level of
    the project repository (still on the **add-login-feature** branch) with a single
    line of content:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要声明对 `pytest` 框架的依赖，这样 GitLab 才能在运行自动化测试之前安装它。由于这是一个 Python 项目，我们将在项目仓库的顶层（仍然在**add-login-feature**分支上）声明这个依赖，并创建一个新的
    `requirements.txt` 文件，文件内容为一行：
- en: '[PRE13]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There are different ways to group automated unit tests in files and directories,
    but let’s keep things simple by adding a single `test_login.py` file at the root
    level of the repository, in the same **add-login-feature** branch that we’ve been
    working in.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以在文件和目录中对自动化单元测试进行分组，但为了简单起见，我们在仓库的根目录下添加一个名为`test_login.py`的文件，放在我们一直在使用的**add-login-feature**分支中。
- en: 'We’ll put three tests in that file: one to check our login feature with good
    credentials, one to test logging in with a bad username, and one to test logging
    in with a bad password. We also need to import the function being tested so that
    it can be called by the unit tests. Add this code to `test_login.py`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这个文件中添加三个测试：一个用于检查使用正确凭据的登录功能，一个用于测试使用错误用户名登录，另一个用于测试使用错误密码登录。我们还需要导入被测试的函数，以便单元测试能够调用它。将以下代码添加到
    `test_login.py`：
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Expanding your automated tests
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展你的自动化测试
- en: These unit test examples are simpler than what you would typically use in a
    real project. Most unit test frameworks—regardless of which language they test—offer
    a wide variety of options and additional features to make your tests more comprehensive
    and powerful. We advise you to get to know your chosen test framework thoroughly
    since automated tests are such an important part of writing high-quality code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这些单元测试示例比你在真实项目中通常使用的要简单。大多数单元测试框架——无论测试的是哪种语言——都提供了多种选项和附加功能，帮助你使测试更全面、更强大。我们建议你彻底了解你选择的测试框架，因为自动化测试是编写高质量代码的重要组成部分。
- en: 'Let’s add a job to the `test` stage of our pipeline to install the `pytest`
    library (as listed in `requirements.txt`) and run the tests. The job should ask
    the runner to execute its commands in a Docker container that has a recent version
    of Python. The `pytest` test framework automatically identifies any files that
    contain tests, so we don’t need to specify which test file to execute. We do need
    to tell `pytest` to generate an output file in the `junit` format, which is a
    test results format that GitLab knows how to ingest and display. Add this job
    definition to your existing `.gitlab-ci.yml` file on the **add-login-feature**
    branch:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在流水线的`test`阶段添加一个任务，安装`pytest`库（如`requirements.txt`中列出），并运行测试。该任务应要求执行器在一个包含最新版本Python的Docker容器中执行命令。`pytest`测试框架会自动识别包含测试的文件，因此我们不需要指定执行哪个测试文件。我们需要告诉`pytest`生成一个`junit`格式的输出文件，这是GitLab能够解析和显示的测试结果格式。将此任务定义添加到你当前在**add-login-feature**分支上的`.gitlab-ci.yml`文件中：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now that we have defined a real job in our CI/CD pipeline, you can delete the
    definition for the temporary `job1` job if you want to declutter the pipeline
    configuration file.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经在CI/CD流水线中定义了一个真实的任务，如果你想简化流水线配置文件，可以删除临时`job1`任务的定义。
- en: 'After the pipeline triggered by this commit completes, you’ll notice that even
    though the `unit-tests` job ran successfully, the pipeline details page doesn’t
    show any test results. That’s because we didn’t tell GitLab to preserve the results
    as an artifact. Let’s fix that by adding this code to the end of the `unit-tests`
    job definition, making sure all lines are indented correctly so that this code
    is understood by GitLab as part of the existing job definition:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当由此提交触发的流水线完成后，你会注意到，即使`unit-tests`任务成功运行，流水线详情页面仍然没有显示任何测试结果。这是因为我们没有告诉GitLab将结果保留为构件。让我们通过将以下代码添加到`unit-tests`任务定义的末尾来修复这个问题，确保所有行都正确缩进，以便GitLab将此代码理解为现有任务定义的一部分：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This should get us to a state where our unit tests are running and passing,
    which is a huge step forward in ensuring that our code lives up to its design
    specifications. If you’ve been following along, you should see output similar
    to this on the **Tests** tab of the most recent pipeline details page, showing
    that all three of our unit tests are running and passing:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们应该能够使单元测试正常运行并通过，这是确保代码符合设计规范的一大步。如果你一直在跟进，应该可以在最新的流水线详情页面的**测试**选项卡中看到类似的输出，显示所有三个单元测试都在运行并通过：
- en: '![Figure 11.5 – Test results on a pipeline details page](img/B18073_11_5.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5 – 流水线详情页面上的测试结果](img/B18073_11_5.jpg)'
- en: Figure 11.5 – Test results on a pipeline details page
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – 流水线详情页面上的测试结果
- en: 'Once your automated tests pass, you can be confident that your code is doing
    what it was designed to do. However, just behaving correctly isn’t good enough:
    your code also needs to be written well. This helps to ensure that your code is
    readable and maintainable and will be less likely to develop bugs when you extend
    it with new features in the future, so now, let’s look at how to make sure your
    code is of high quality.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦自动化测试通过，你就可以确信你的代码做到了它应该做的事情。然而，仅仅正常运行还不够：你的代码还需要编写得很好。这有助于确保代码具有可读性和可维护性，并且在你将来为其扩展新功能时，不太可能出现bug。因此，接下来，让我们来看看如何确保你的代码质量高。
- en: Adding Code Quality scanning to the pipeline
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将代码质量扫描添加到流水线
- en: Let’s add a task to our pipeline called Code Quality scanning, which will help
    us assess the quality of our code. As with all of GitLab’s scanners, Code Quality
    only works with certain computer languages. However—as described in the GitLab
    documentation for this feature—it supports all of the usual suspects, including
    Python.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在流水线中添加一个名为代码质量扫描的任务，这将帮助我们评估代码的质量。与GitLab的所有扫描器一样，代码质量扫描仅适用于某些计算机语言。不过——如GitLab文档中对该功能的描述——它支持所有常见的编程语言，包括Python。
- en: 'We enable the scanner by including its template at the end of our project’s
    CI/CD configuration file, on the same **add-login-feature** branch where we’ve
    done all of our work:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在项目的 CI/CD 配置文件末尾包含其模板来启用扫描器，使用的分支是**add-login-feature**，这是我们完成所有工作的分支：
- en: '[PRE17]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'If you inspect the pipeline that was triggered by committing this change to
    `.gitlab-ci.yml`, you’ll notice that the Code Quality scanning job failed. Don’t
    panic! This failure stems from Code Quality being something of an odd duck among
    GitLab’s scanners. It uses a technique called `runner for code quality` by typing
    this command on the same machine that’s hosting our other runners. Just like when
    we registered those runners, you’ll need to replace the `--url` and `--registration-token`
    values with the appropriate values for your system:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你检查由提交此更改到`.gitlab-ci.yml`触发的流水线，你会注意到代码质量扫描任务失败了。别慌！这个失败源于代码质量扫描在 GitLab
    的扫描工具中有些特殊。它使用了一种名为`runner for code quality`的技术，通过在托管其他 runner 的同一台机器上输入此命令来实现。就像我们注册那些
    runner 时一样，你需要将`--url`和`--registration-token`的值替换为你系统中适当的值：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We configured this new runner with a `code-quality-capable` tag, which indicates
    that it can handle running Code Quality jobs. In order to make sure that our job
    is assigned to this specific runner, we need to override the Code Quality scanner’s
    job definition and assign it the same tag. While we tinker with the pipeline configuration
    file, let’s also disable a service that’s used by some runners to handle this
    job but that isn’t required by our runner. Add this job definition override to
    the end of your `.``gitlab-ci.yml` file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用一个`code-quality-capable`标签配置了这个新 runner，表示它能够处理代码质量任务。为了确保我们的任务分配给这个特定的 runner，我们需要覆盖代码质量扫描器的任务定义，并给它分配相同的标签。在调整流水线配置文件时，让我们同时禁用一个由某些
    runner 用于处理这个任务的服务，但我们的 runner 并不需要它。将这个任务定义覆盖添加到你的`.gitlab-ci.yml`文件末尾：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As soon as we commit this last change, GitLab kicks off a pipeline run and
    presents the Code Quality results in a new **Code Quality** tab on the pipeline
    details page:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们提交最后一次更改，GitLab 会启动流水线并在流水线详细页面的一个新**代码质量**标签页中展示代码质量结果：
- en: '![Figure 11.6 – Code Quality results on a pipeline details page](img/B18073_11_6.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.6 – 流水线详细页面上的代码质量结果](img/B18073_11_6.jpg)'
- en: Figure 11.6 – Code Quality results on a pipeline details page
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 – 流水线详细页面上的代码质量结果
- en: The Code Quality scanner reminds us to take care of the “to-do” comment we added
    to `login.py` earlier. Good advice, but let’s ignore it for now so we can move
    on to fuzz testing.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 代码质量扫描器提醒我们处理早些时候在`login.py`中添加的“待办事项”注释。这个建议不错，但现在让我们忽略它，继续进行模糊测试。
- en: Adding a fuzz test to the pipeline
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向流水线添加模糊测试
- en: Let’s set up a fuzz test to see whether the `log_user_in` function has any bugs
    that weren’t caught by our automated unit tests. [*Chapter 6*](B18073_06.xhtml#_idTextAnchor133)
    has a thorough description of the architectural elements involved in fuzz testing,
    so please refer back to that chapter if you need a refresher on what role each
    piece of code plays.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置一个模糊测试，看看`log_user_in`函数是否有任何未被自动化单元测试捕获的 bug。[*第6章*](B18073_06.xhtml#_idTextAnchor133)详细描述了模糊测试中涉及的架构元素，如果你需要回顾每个代码片段的角色，可以参考这一章。
- en: Reminder
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒
- en: Fuzz testing, like several other features discussed throughout the book, is
    only available with a GitLab Ultimate license. The GitLab documentation for each
    feature tells you which license tier that feature requires. The reason that this
    book doesn’t mention which licenses are required for which features is that GitLab
    frequently makes features available at lower tiers after they’ve been tested in
    higher tiers for a while.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 模糊测试，和本书中讨论的其他一些功能一样，仅在 GitLab Ultimate 许可下可用。每个功能的 GitLab 文档都会告知你该功能需要哪个许可等级。本书没有提及哪些功能需要哪些许可，是因为
    GitLab 在较高级别的许可测试过一段时间后，通常会将一些功能开放给较低级别的许可。
- en: The fuzz test will test the `log_user_in` function that lives in the `login.py`
    file. If you remember from [*Chapter 6*](B18073_06.xhtml#_idTextAnchor133), this
    code is called the **code under test**. As it’s written right now, this function
    is simple enough that we can tell just by looking at it that fuzz testing won’t
    find any problems. In other words, fuzz testing is overkill for such a simple
    function, but we can imagine that the function might become more complicated in
    the future, and as it becomes more complicated, it will be more likely to have
    bugs. Therefore, it’s a good idea to create a fuzz test for this simple code under
    test now so that it can find new bugs if we rewrite the function using more complicated
    and error-prone code in the future.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这次模糊测试将测试`login.py`文件中的`log_user_in`函数。如果你还记得[*第6章*](B18073_06.xhtml#_idTextAnchor133)，这段代码被称为**待测代码**。按照现在的写法，这个函数足够简单，我们通过查看代码就能知道模糊测试不会发现任何问题。换句话说，对于如此简单的函数来说，模糊测试是“杀鸡用牛刀”，但我们可以想象这个函数未来可能会变得更加复杂，随着复杂度的增加，出现
    bugs 的可能性也会增大。因此，现在就为这段简单的待测代码创建一个模糊测试是一个好主意，这样如果我们以后用更复杂、更容易出错的代码重写这个函数，它就可以发现新的
    bugs。
- en: 'Let’s put the `log_in_user_fuzz_target.py` in the root of the repository’s
    **add-login-feature** branch. The file should contain this Python code:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`log_in_user_fuzz_target.py`文件放在仓库的**add-login-feature**分支的根目录下。该文件应包含以下
    Python 代码：
- en: '[PRE20]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Most of this is boilerplate code copied from sample fuzz targets in the GitLab
    documentation. The section that requires some programming creativity on our part
    is the logic in the `fuzz()` method. This code converts the random bytes sent
    by the fuzz engine into a random string, uses the first half of the string as
    the username and the second half as the password, and passes the username and
    password to the code under test.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这些代码大部分是从 GitLab 文档中的示例模糊目标复制过来的。需要我们发挥编程创意的部分是`fuzz()`方法中的逻辑。这段代码将模糊引擎发送的随机字节转换成随机字符串，使用字符串的前半部分作为用户名，后半部分作为密码，并将用户名和密码传递给待测代码。
- en: 'Next, we need to include the GitLab fuzz testing template in the `.gitlab-ci.yml`
    file in the `add-login-feature` branch. Add the `Coverage-Fuzzing.gitlab-ci.yml`
    template within the existing `include:` section after the Code Quality template
    that we’ve already added. The complete `include:` section should end up looking
    like this:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将 GitLab 模糊测试模板包含到`add-login-feature`分支中的`.gitlab-ci.yml`文件里。在我们已经添加的代码质量模板后，在现有的`include:`部分内添加`Coverage-Fuzzing.gitlab-ci.yml`模板。完整的`include:`部分应该如下所示：
- en: '[PRE21]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Because this template declares that fuzz test jobs run in their own `fuzz`
    stage, we must add that stage under the `stages:` keyword at the top of `.gitlab-ci.yml`
    in the `add-login-feature` branch. When you’re done, the complete stage definition
    section should look like this:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这个模板声明了模糊测试任务将在它们自己的`fuzz`阶段运行，我们必须在`add-login-feature`分支的`.gitlab-ci.yml`文件顶部的`stages:`关键字下添加该阶段。完成后，完整的阶段定义部分应该如下所示：
- en: '[PRE22]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, let’s create a pipeline job to trigger the fuzz test against our code
    under test. Add this job definition to the end of `.gitlab-ci.yml` on the `add-login-feature`
    branch:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们创建一个管道任务，用来触发对待测代码的模糊测试。将此任务定义添加到`.gitlab-ci.yml`文件的末尾，位于`add-login-feature`分支中：
- en: '[PRE23]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you check the pipeline details page for the pipeline that was triggered by
    this commit, you should see jobs for unit tests, Code Quality, and now fuzz testing.
    If you click into the fuzz testing job to see its output, you’ll notice that it’s
    sending a seemingly infinite number of sets of random data to the code under test,
    with no signs of stopping. However, we know from [*Chapter 6*](B18073_06.xhtml#_idTextAnchor133)
    that it will stop as soon as it either finds a bug or times out. Because this
    pipeline is running on a non-default branch, the timeout is set to a hefty 60
    minutes (default branches have 10-minute timeouts). While that might be a reasonable
    amount of time to uncover deep bugs in complicated code, it’s overkill for our
    dead-simple login code.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看由此提交触发的管道的管道详情页面，你应该会看到单元测试、代码质量和现在的模糊测试任务。如果你点击模糊测试任务查看其输出，你会注意到它正在不断地将随机数据集发送给待测代码，看似没有停止的迹象。然而，正如我们在[*第6章*](B18073_06.xhtml#_idTextAnchor133)中知道的，它会在找到
    bug 或者超时后停止。因为这个管道是在非默认分支上运行的，所以超时时间设置为 60 分钟（默认分支有 10 分钟的超时）。虽然这对于复杂代码中深层次 bug
    的发现来说可能是合理的时间，但对于我们这段简单的登录代码来说，实在是有些过头了。
- en: Let’s speed up our pipeline by configuring the job to send 1,000 sets of random
    bytes to the function being tested, and then stop if it hasn’t found any bugs.
    Of course, we can bump up the maximum number of random data sets later if we think
    more complicated login code would benefit from more thorough fuzz testing.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过配置作业，加快管道速度，向正在测试的函数发送1,000组随机字节，并在没有发现任何错误时停止。当然，如果我们认为更复杂的登录代码会受益于更彻底的模糊测试，我们可以随时增加随机数据集的最大数量。
- en: 'To limit the number of runs performed by the fuzz test, cancel the currently
    running pipeline (there’s no need to wait for it to time out after 60 minutes),
    and add these lines anywhere within the `fuzz-test-for-log-user-in` job definition.
    Make sure they’re indented correctly so that you’re defining a job-scoped variable
    and not a global variable:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了限制模糊测试执行的次数，请取消当前正在运行的管道（无需等待其在60分钟后超时），并确保这些行被正确缩进，以便定义一个作业范围的变量而不是全局变量：
- en: '[PRE24]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Also in the `fuzz-test-for-log-user-in` job definition, replace the second
    line in the `script:` section with the following (note that this is all a single
    long line of code):'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 同样在`fuzz-test-for-log-user-in`作业定义中，用以下内容替换`script:`部分的第二行（请注意，这是一行很长的代码）：
- en: '[PRE25]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If you look at the output of a fuzz test job that runs after these changes,
    you’ll see that it stops after the first 1,000 unsuccessful attempts to find a
    bug. You’ll also notice that no **Security** tab shows up on the pipeline details
    page because the fuzz test has no findings to report (fuzz testing is considered
    by GitLab to be a type of security scanner rather than a type of code quality
    scanner, despite its aim of finding bugs rather than security vulnerabilities).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看这些更改后运行的模糊测试作业的输出，你会发现它在找到第一个 1,000 次失败尝试后停止。您还会注意到管道详细信息页面上没有显示**安全**选项卡，因为模糊测试没有发现任何问题（尽管其旨在查找错误而不是安全漏洞，但GitLab认为模糊测试是一种安全扫描器而不是代码质量扫描器）。
- en: Our pipeline is really coming along! Let’s keep the momentum going by adding
    some security scanners.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的管道真的很顺利！让我们通过添加一些安全扫描器来保持这种势头。
- en: Securing your code
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护您的代码
- en: 'For this sample use case, you’re going to add four scanners to your pipeline:
    **Static Application Security Testing** (**SAST**), Secret Detection, Dependency
    Scanning, and License Compliance. You’ll also review how to add a third-party
    scanner.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此示例用例，您将向管道添加四个扫描器：**静态应用程序安全性测试**（**SAST**）、秘密检测、依赖关系扫描和许可合规性。您还将学习如何添加第三方扫描器。
- en: Adding SAST to the pipeline
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将SAST添加到管道中
- en: 'In general, adding a GitLab-provided security scanner to a pipeline is a trivial
    process. To enable SAST and make sure our Hats for Cats source code doesn’t contain
    security vulnerabilities, we simply need to include a new template in `.gitlab-ci.yml`
    on the `add-login-feature` branch. Add this line anywhere within the existing
    `include:` section, making sure that it’s indented correctly:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，向管道添加由GitLab提供的安全扫描器是一个简单的过程。为了启用SAST并确保我们的“Hats for Cats”源代码不包含安全漏洞，我们只需要在`add-login-feature`分支的`.gitlab-ci.yml`中的现有`include:`部分包含一个新的模板。确保正确缩进，可以在现有的任何位置添加此行：
- en: '[PRE26]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This enables SAST, but we also want to configure it so that it doesn’t scan
    our automated test file or our fuzz target file. The GitLab documentation tells
    us which variable to set to accomplish this. Add a new section to the end of `.gitlab-ci.yml`
    in order to set the correct global variable:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就启用了SAST，但我们还希望配置它，以便它不扫描我们的自动化测试文件或我们的模糊目标文件。GitLab文档告诉我们设置哪个变量以实现此目的。在`.gitlab-ci.yml`的末尾添加一个新的部分，以设置正确的全局变量：
- en: '[PRE27]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'There are only two lines in this code: the second line is long enough that
    it wraps in a possibly confusing way.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码仅有两行：第二行足够长，可能会以令人困惑的方式换行。
- en: 'Wait for the pipeline to finish and check out its details page. Under the `login.py`.
    We will ignore this vulnerability for the sake of keeping the demo moving along,
    but it’s comforting to see that SAST is up and running:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 等待管道完成并查看其详细信息页面。在`login.py`下。出于演示进行时的考虑，我们将忽略此漏洞，但看到SAST已经启动运行还是令人欣慰的：
- en: '![Figure 11.7 – SAST results on a pipeline details page](img/B18073_11_7.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.7 – 管道详细信息页面上的SAST结果](img/B18073_11_7.jpg)'
- en: Figure 11.7 – SAST results on a pipeline details page
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 – 管道详细信息页面上的SAST结果
- en: Adding Secret Detection to the pipeline
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将秘密检测添加到管道中
- en: 'Let’s add SAST’s cousin, Secret Detection, to our CI/CD pipeline. On the `add-login-feature`
    branch, include a new template in the existing `include:` section of `.gitlab-ci.yml`.
    Double-check your indentation and we should be good to go:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将SAST的“表亲”秘密检测添加到我们的CI/CD流水线中。在`add-login-feature`分支，包含一个新的模板到`.gitlab-ci.yml`的现有`include:`部分。仔细检查缩进，确保一切就绪：
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We should consider some of the configuration options for Secret Detection.
    There’s no need to enable “historic” mode since our repository only has a few
    commits and we’re confident that we haven’t added any secrets to it so far. However,
    it makes sense to tell Secret Detection not to scan our test files since any secrets
    kept in them will be made-up secrets for testing purposes only. In the future,
    we might group all of our test-related code into a `tests/` directory, but since
    we don’t have that directory yet, we’ll explicitly exclude individual files. Do
    this by overriding the appropriate job definition and setting a job-scoped variable:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该考虑一些秘密检测的配置选项。由于我们的代码库只有少数几个提交，并且我们确信到目前为止没有添加任何秘密，因此不需要启用“历史”模式。然而，告诉秘密检测不要扫描我们的测试文件是有意义的，因为其中的任何秘密都是为了测试目的而虚构的秘密。将来，我们可能会把所有与测试相关的代码放入`tests/`目录，但由于我们目前还没有该目录，我们将明确排除单独的文件。通过覆盖适当的作业定义并设置作业范围的变量来做到这一点：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Note
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The last line in this code snippet is actually one line that wraps awkwardly,
    so be sure to paste it in as a single line.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的最后一行实际上是一行，因换行问题而看起来很尴尬，所以一定要作为一行粘贴进去。
- en: 'Finally, let’s give Secret Detection a secret to detect. Let’s pretend that
    our intern Carl accidentally pastes an AWS access token into `login.py`. Add this
    line to the end of that file on the `add-login-feature` branch:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们给秘密检测提供一个秘密来检测。假设我们的实习生Carl不小心将一个AWS访问令牌粘贴到了`login.py`中。在`add-login-feature`分支的文件末尾添加以下一行：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When the resulting pipeline finishes, check that the **Security** tab on its
    pipeline details page reports a security vulnerability from Secret Detection:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当结果流水线完成时，检查其流水线详情页上的**安全**标签，查看是否报告了来自秘密检测的安全漏洞：
- en: '![Figure 11.8 – Secret Detection results on a pipeline details page](img/B18073_11_8.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![图11.8 – 流水线详情页上的秘密检测结果](img/B18073_11_8.jpg)'
- en: Figure 11.8 – Secret Detection results on a pipeline details page
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8 – 流水线详情页上的秘密检测结果
- en: Adding Dependency Scanning to the pipeline
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将依赖扫描添加到流水线
- en: So far, the only dependency that our project has declared is the `pytest` automated
    testing framework. Since that dependency won’t be used in production, we probably
    don’t care if it has security vulnerabilities, but it’s smart to add Dependency
    Scanning to our pipeline so that we’ll be alerted to any security problems in
    dependencies that we might add in the future.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的项目声明的唯一依赖是`pytest`自动化测试框架。由于该依赖不会在生产中使用，我们可能不关心它是否有安全漏洞，但将依赖扫描添加到我们的流水线中是明智的，这样我们就可以在将来添加任何依赖时，及时收到安全问题的提醒。
- en: 'On the `include:` section:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在`include:`部分：
- en: '[PRE31]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now that Dependency Scanning is up and running, let’s give it something to
    find. Let’s say that the Hats for Cats web app will be built on the Django web
    app framework for Python and that we decide to use an older version of Django
    that we’re already comfortable with. Add this new line to the end of the existing
    `requirements.txt` file on the `add-login-feature` branch, noting that it should
    be flush-left rather than indented:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在依赖扫描已经启用，让我们给它一些内容来检测。假设“Cats for Cats”网页应用将基于Python的Django网页框架构建，我们决定使用一个我们已经熟悉的旧版本Django。在`add-login-feature`分支的现有`requirements.txt`文件末尾添加这一新行，并注意它应该是左对齐的，而不是缩进的：
- en: '[PRE32]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Since this version is significantly behind the current version of 4.1.1, we
    might expect Dependency Scanning to find security vulnerabilities in it. Lo and
    behold, if we trigger a pipeline and then look at the **Security** tab on the
    pipeline details page, we see at least 15 potential problems with our dependency!
    You might find it helpful to use the **Severity** and **Tool** filters above the
    results table to reduce clutter and focus on the most important vulnerabilities:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此版本显著落后于当前的4.1.1版本，我们可能会发现依赖扫描中存在安全漏洞。果不其然，如果我们触发一个流水线并查看流水线详情页上的**安全**标签，我们会看到至少15个潜在的依赖问题！你可能会觉得使用**严重性**和**工具**过滤器来减少干扰，专注于最重要的漏洞会很有帮助：
- en: '![Figure 11.9 – Critical severity Dependency Scanning results on a pipeline
    details page](img/B18073_11_9.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.9 – 管道详情页上的严重性为“关键”的依赖扫描结果](img/B18073_11_9.jpg)'
- en: Figure 11.9 – Critical severity Dependency Scanning results on a pipeline details
    page
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.9 – 管道详情页上的严重性为“关键”的依赖扫描结果
- en: Adding License Compliance to the pipeline
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将许可证合规性添加到管道中
- en: 'Since we’ve declared a few software dependencies for the `add-login-feature`
    branch, add a new template to the `include:` section, double-checking your indentation:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们为 `add-login-feature` 分支声明了一些软件依赖项，请在 `include:` 部分添加一个新模板，并仔细检查缩进：
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: On the details page for the pipeline that was triggered by this edit, click
    on the new `pytest` libraries, and also by their dependencies. Interestingly,
    the License Compliance scanner was unable to figure out what license Django itself
    uses, so it’s listed as **unknown**. Normally, you would consult with your legal
    team to decide whether to explicitly allow or deny each of these licenses by clicking
    on the **Manage licenses** button on this page, but in order to keep the demo
    moving along, we’ll skip that step.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在由此次编辑触发的管道详情页上，点击新的 `pytest` 库及其依赖项。有趣的是，许可证合规性扫描器未能确定 Django 本身使用的许可证，因此它被列为**未知**。通常，你会与法务团队协商，决定是否明确允许或拒绝这些许可证，可以通过点击页面上的**管理许可证**按钮来进行处理，但为了保持演示的连贯性，我们将跳过这一步骤。
- en: '![Figure 11.10 – Licenses used by project dependencies](img/B18073_11_10.jpg)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.10 – 项目依赖项使用的许可证](img/B18073_11_10.jpg)'
- en: Figure 11.10 – Licenses used by project dependencies
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10 – 项目依赖项使用的许可证
- en: Some scanners are excluded from this demo
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 一些扫描器被排除在本演示之外
- en: You may have noticed that we didn’t add DAST, Container Scanning, or Infrastructure
    as Code Scanning to our pipeline. We’ve excluded them partly because the Hats
    for Cats demo web app doesn’t include enough functioning code to package into
    a Docker image and interact with as a normal user would, and because we don’t
    need to use infrastructure-as-code tools to configure any new machines as part
    of the **Hats for Cats** project. Equally, we also want to show that not all scanners
    are relevant to all projects. You should enable and configure only the scanners
    that make sense for your particular project; adding unnecessary scanners complicates
    your CI/CD pipeline configuration file and bogs down your pipeline without adding
    any value.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们没有将 DAST、容器扫描或基础设施即代码扫描添加到我们的管道中。我们排除了这些扫描器，部分原因是 Hats for Cats 演示
    Web 应用没有足够的功能代码来打包成 Docker 镜像并以普通用户的方式进行交互，另一个原因是我们不需要使用基础设施即代码工具来配置任何新的机器作为 **Hats
    for Cats** 项目的一部分。同样，我们还想展示并非所有扫描器都与所有项目相关。你应该只启用和配置那些对你特定项目有意义的扫描器；添加不必要的扫描器会让你的
    CI/CD 管道配置文件变得复杂，并且拖慢管道速度，毫无益处。
- en: Integrating a third-party security scanner into the pipeline
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将第三方安全扫描器集成到管道中
- en: Imagine that there’s a third-party security scanner that we’ve used in the past
    and want to add to our `gui-proofreader` and is a form of SAST scanning that checks
    for typos in user-facing text. Let’s say that it’s available as a Docker image
    on Docker Hub and that you can run the scanner against all the code in your repository
    by cloning the repository to a `gui-proofreader` Docker container and running
    the `proofread-my-gui.sh` shell script within that container.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个我们过去使用过的第三方安全扫描器，现在我们希望将其添加到 `gui-proofreader` 中，它是一种 SAST 扫描形式，检查面向用户的文本中的拼写错误。假设它作为一个
    Docker 镜像在 Docker Hub 上提供，你可以通过将仓库克隆到 `gui-proofreader` Docker 容器中，然后在该容器内运行 `proofread-my-gui.sh`
    脚本来对仓库中的所有代码进行扫描。
- en: 'Let’s add a job to our CI/CD pipeline that does exactly that. Add this job
    definition at the end of `.gitlab-ci.yml` on the `add-login-feature` branch:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 CI/CD 管道中添加一个任务，完成这个功能。在 `add-login-feature` 分支的 `.gitlab-ci.yml` 文件末尾添加以下任务定义：
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'That’s enough to trigger the third-party scanner, but we still need to integrate
    its output into the GitLab security reports. This step is simple: declare the
    scanner’s output as an artifact that contains a SAST report (there are several
    report types we could assign it to, but this particular scanner feels like a flavor
    of SAST, so let’s use that). Add this code to the bottom of the definition of
    the `proofread` job:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经足以触发第三方扫描器，但我们仍然需要将其输出集成到 GitLab 安全报告中。这个步骤很简单：将扫描器的输出声明为包含 SAST 报告的工件（我们可以将其分配给几种报告类型，但这个特定的扫描器类似于
    SAST，所以我们选择使用 SAST）。将以下代码添加到 `proofread` 任务定义的底部：
- en: '[PRE35]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Of course, we would need to adjust the name of the results file specified in
    the job definition to match whatever file name the `gui-proofreader` scanner actually
    generates. Also, GitLab will only be able to parse and display those results if
    the file conforms to GitLab’s official JSON schema for SAST scanners (the details
    of the various security scanner results schemas are given in the GitLab documentation
    for each type of scanner). If the `gui-proofreader` scanner can’t generate output
    using that schema, we will need to write a small script that converts the scanner’s
    output into a JSON file with the appropriate schema, run that script in a separate
    job in a later pipeline stage, and move the artifact declaration from the `proofread`
    job into the new script’s job.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要调整作业定义中指定的结果文件名，以匹配`gui-proofreader`扫描器实际生成的文件名。此外，GitLab只有在文件符合GitLab的官方SAST扫描器JSON架构时，才能解析并显示这些结果（每种类型扫描器的安全扫描结果架构细节可以在GitLab文档中找到）。如果`gui-proofreader`扫描器无法使用该架构生成输出，我们需要编写一个小脚本，将扫描器的输出转换为符合适当架构的JSON文件，在后续管道阶段的独立作业中运行该脚本，并将工件声明从`proofread`作业移到新脚本的作业中。
- en: Since this job won’t work as written—as there’s no Docker image called `gui-proofeader`
    on Docker Hub—it’s best to either exclude this job definition from your `.gitlab-ci.yml`
    file or to comment it out. However, if you ever do want to integrate a third-party
    scanner, this is a model you can follow.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个作业按现有写法无法工作——因为Docker Hub上没有叫做`gui-proofeader`的Docker镜像——最好的做法是将这个作业定义从`.gitlab-ci.yml`文件中排除，或者注释掉它。然而，如果你将来确实想集成第三方扫描器，这是一个可以遵循的模型。
- en: Improving your pipeline
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改进你的管道
- en: You’ve set up a pipeline to make sure your code is of high quality and doesn’t
    have security vulnerabilities. In many cases, you can stop there. However, for
    this sample use case, you’ll go a step further and look into using a DAG to speed
    up the pipeline. You’ll also see whether it’s worth splitting the pipeline’s configuration
    code into multiple files to improve readability and maintainability.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经设置了一个管道，确保你的代码质量高且没有安全漏洞。在许多情况下，你可以到此为止。然而，对于这个示例用例，你将更进一步，探讨使用DAG来加速管道。你还将看到是否值得将管道的配置代码拆分成多个文件，以提高可读性和可维护性。
- en: Using a DAG to speed up the pipeline
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用DAG加速管道
- en: Our pipeline isn’t complicated enough to justify converting it into a DAG quite
    yet, but if we continue to add more jobs, we’ll eventually want to use DAGs for
    some or all of it for performance reasons. Let’s preview this by using the `needs`
    keyword now to add some DAG elements to our pipeline.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的管道还没有复杂到需要转换成DAG，但如果我们继续添加更多作业，最终会因为性能原因希望对其中一些或所有作业使用DAG。现在，让我们通过使用`needs`关键字来预览一下，给我们的管道添加一些DAG元素。
- en: 'First, let’s say that we want the `code_quality` job to run only after the
    `unit-tests` job passes. After all, we might think that our code needs to work
    correctly before we worry about making it pretty and maintainable. We could accomplish
    that by putting `code_quality` in a later stage than `unit-tests`, but since they
    both feel like they conceptually belong to the `code_quality` job definition:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，假设我们希望`code_quality`作业仅在`unit-tests`作业通过之后运行。毕竟，我们可能认为我们的代码在关心美观和可维护性之前，应该先确保它能正确工作。我们可以通过将`code_quality`放在比`unit-tests`晚的阶段来实现这一点，但由于它们在概念上都属于`code_quality`作业定义：
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now that one mini-DAG is set up, let’s make another. Perhaps we’re unhappy
    with the job that runs our fuzz test running after all of the other scanners are
    complete. This happens because the fuzz test job is in its own `fuzz-test-for-log-user-in`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经设置好了一个迷你DAG，让我们再创建一个。也许我们对在所有其他扫描器完成之后运行的模糊测试作业不满意。这是因为模糊测试作业在它自己的`fuzz-test-for-log-user-in`中：
- en: '[PRE37]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'When we run a pipeline that contains these edits, we see exactly the behavior
    we’d hoped for: `fuzz-test-for-log-user-in` runs immediately and `code_quality`
    is paused until `unit-tests` completes:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行包含这些编辑的管道时，我们会看到我们所期望的行为：`fuzz-test-for-log-user-in`立即运行，`code_quality`在`unit-tests`完成之前暂停：
- en: '![Figure 11.11 – DAG causing jobs to run not according to stage order](img/B18073_11_11.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图11.11 – DAG导致作业没有按照阶段顺序运行](img/B18073_11_11.jpg)'
- en: Figure 11.11 – DAG causing jobs to run not according to stage order
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.11 – DAG导致作业没有按照阶段顺序运行
- en: 'We can double-check our understanding of the pipeline’s flow by clicking on
    **Job dependencies** in the pipeline details page and toggling **Show dependencies**
    on. After the pipeline finishes, we can see which jobs ran in what order, due
    to “needs” relationships:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过点击流水线详细页面中的**作业依赖关系**，并打开**显示依赖关系**来再次检查对流水线流程的理解。流水线运行结束后，我们可以看到哪些作业按什么顺序运行，得益于“需求”关系：
- en: '![Figure 11.12 – Job dependencies view of the completed pipeline](img/B18073_11_12.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.12 – 完成的流水线作业依赖关系视图](img/B18073_11_12.jpg)'
- en: Figure 11.12 – Job dependencies view of the completed pipeline
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12 – 完成的流水线作业依赖关系视图
- en: Breaking the pipeline into several files
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将流水线拆分为多个文件
- en: Now that we’ve set up our project’s CI/CD pipeline to verify and secure our
    code, let’s see whether we can keep our pipeline configuration well organized
    and easy to read. As the file stands right now, it’s much simpler than `.gitlab-ci.yml`
    files for real-world projects tend to be, and normally we would suggest that our
    configuration file is clean enough as is and doesn’t warrant any refactoring.
    However, in order to demonstrate how we might maintain it as it becomes more complicated,
    let’s separate it into two files anyway.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经设置好了项目的 CI/CD 流水线来验证和确保代码的安全性，那么让我们看看如何保持流水线配置的整洁和易读。当前的文件比现实项目中的 `.gitlab-ci.yml`
    文件要简单得多，通常我们会建议当前的配置文件已经足够干净，不需要重构。然而，为了展示如何在配置变得更加复杂时进行维护，接下来我们还是将它分成两个文件。
- en: Say we decide to standardize our security scanning process across all of our
    team’s projects. A good way to do this is to separate our security-related job
    definitions into a different CI/CD pipeline configuration file, and then include
    it in each project’s CI/CD configuration file.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们决定在我们团队的所有项目中标准化安全扫描过程。实现这一目标的好方法是将所有与安全相关的作业定义分离到一个不同的 CI/CD 流水线配置文件中，然后将其包含到每个项目的
    CI/CD 配置文件中。
- en: 'Create a new file called `security-jobs.yml` in the root of the `add-login-feature`
    branch. Add this line to the new file:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `add-login-feature` 分支的根目录下创建一个名为 `security-jobs.yml` 的新文件。将以下行添加到新文件中：
- en: '[PRE38]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Cut these lines from the `include:` section of `.gitlab-ci.yml` and paste them
    into the `include:` section of `security-jobs.yml`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些行从 `.gitlab-ci.yml` 文件的 `include:` 部分剪切并粘贴到 `security-jobs.yml` 文件的 `include:`
    部分：
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, include the new configuration file in the original configuration file
    by adding this line anywhere within the `include:` section of `.gitlab-ci.yml`:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过在 `.gitlab-ci.yml` 的 `include:` 部分的任何位置添加此行，将新配置文件包含到原始配置文件中：
- en: '[PRE40]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: When the pipeline runs after you make these changes, you’ll see that it behaves
    exactly like it did before we refactored its configuration files. This demonstrates
    how you can break a long, complicated CI/CD pipeline configuration file into two
    or more subfiles, each of which can be reused in multiple projects if desired.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在做出这些更改后重新运行流水线时，你会发现它的行为与我们重构配置文件之前完全相同。这展示了如何将一个长而复杂的 CI/CD 流水线配置文件拆分为两个或更多的子文件，每个文件如果需要，可以在多个项目中复用。
- en: Note that because `security-jobs.yml` is in the same project as `.gitlab-ci.yml`,
    we used the `include:` keyword and `local:` sub-keyword to point to it. If we
    were including it from a different project, we’d need to use the `include:` and
    `file:` keywords instead. The GitLab documentation has more information on how
    to use different forms of `include:` in different situations, and is well worth
    reviewing.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于 `security-jobs.yml` 与 `.gitlab-ci.yml` 在同一个项目中，我们使用了 `include:` 关键字和 `local:`
    子关键字来指向它。如果我们要从其他项目中包含它，就需要使用 `include:` 和 `file:` 关键字。GitLab 文档中有更多关于如何在不同情况下使用不同形式的
    `include:` 的信息，非常值得查阅。
- en: Delivering your code to the right environment
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将你的代码部署到正确的环境
- en: Your code is written, verified, and secured. The only step left is to deploy
    it.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 你的代码已经编写、验证并确保安全。剩下的唯一步骤就是部署它。
- en: Deploying the code
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署代码
- en: The final task of our pipeline is to deploy the `rules:` and `if:` keywords
    to control which one of those three jobs should run, depending on which Git branch
    the pipeline was running on.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们流水线的最后任务是使用 `rules:` 和 `if:` 关键字来控制应该运行的三个作业中的哪一个，具体取决于流水线运行所在的 Git 分支。
- en: To keep things simple in this example, let’s just walk through how to deploy
    it to the production environment. We’ll imagine that we want this to happen whenever
    we run the pipeline on the **production** branch.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持示例简单，我们仅讲解如何将其部署到生产环境。我们假设每当我们在**生产**分支上运行流水线时，都会发生此操作。
- en: 'As you learned in [*Chapter 8*](B18073_08.xhtml#_idTextAnchor205), there are
    countless techniques you can use to deploy code. Which technique you choose depends
    largely on what sort of environment you’re deploying to: an AWS EC2 VM, a Kubernetes
    cluster, a bare-metal machine, or something else. For this example, let’s imagine
    that we’re deploying our code to a machine with an IP address of `192.168.0.1`,
    which is running an Apache web server that hosts the Hats for Cats site. Furthermore,
    let’s say that to deploy a new version of our web app, we simply need to copy
    our files to the right directory on the Apache host machine and issue a command
    to restart Apache.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[*第8章*](B18073_08.xhtml#_idTextAnchor205)中学到的那样，部署代码有无数种方法。选择哪种方法在很大程度上取决于你要部署的环境：AWS
    EC2虚拟机、Kubernetes集群、裸金属机器或其他什么东西。对于这个例子，我们假设我们正在将代码部署到一台IP地址为`192.168.0.1`的机器上，该机器运行着一个Apache
    Web服务器，托管着“Hats for Cats”网站。此外，假设要部署我们网页应用程序的新版本，我们只需要将文件复制到Apache主机上的正确目录，并发出命令重启Apache。
- en: 'This deployment process is very straightforward. Add this job definition to
    `.gitlab-ci.yml` on the `add-login-feature` branch:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这个部署过程非常简单。将这个任务定义添加到`add-login-feature`分支上的`.gitlab-ci.yml`文件中：
- en: '[PRE41]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: You might wonder about the image specified in this job definition. There are
    several ways we could set up the public/private SSH key pair that the `scp` command
    relies on, but one way to accomplish this involves making our own Docker image,
    which we store in an internal Docker container registry. Of course, we could also
    store this image within the container registry of this project or a different
    project, but for now, let’s assume we have a separate, company-wide Docker container
    registry set up. The image contains a Linux distribution with the OpenSSH library
    (which provides the `scp` command) and also has a public/private key pair that
    was generated in advance. We then configure the Apache host computer to accept
    the private key from that Docker image. With that infrastructure in place, the
    GitLab Runner can execute `scp` from within the special Docker image, and the
    key pair takes care of authenticating to the Apache host.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会对这个任务定义中指定的镜像感到疑惑。我们可以通过几种方式来设置`scp`命令所依赖的公/私钥对，其中一种方法是制作我们自己的Docker镜像，并将其存储在内部Docker容器注册表中。当然，我们也可以将这个镜像存储在这个项目或其他项目的容器注册表中，但现在假设我们已经设置了一个单独的、公司范围的Docker容器注册表。这个镜像包含一个带有OpenSSH库的Linux发行版（提供`scp`命令），并且已经生成了一个公/私钥对。然后，我们将Apache主机计算机配置为接受来自该Docker镜像的私钥。搭建好这个基础设施后，GitLab
    Runner可以在特殊的Docker镜像内执行`scp`，并通过密钥对完成对Apache主机的身份验证。
- en: The `rules:` and `if:` keywords in this job definition prevent the job from
    running unless the pipeline runs on the `deploy-to-review` and `deploy-to-staging`
    jobs, which would each use different logic to specify which branches they should
    run on.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务定义中的`rules:`和`if:`关键字会防止任务运行，除非流水线在`deploy-to-review`和`deploy-to-staging`任务上运行，这两个任务会使用不同的逻辑来指定它们应该在哪些分支上运行。
- en: Since our `deploy-to-production` job won’t run on the `add-login-feature` branch
    to which we’re committing the edited `.gitlab-ci.yml` file, we won’t see it run
    when the commit triggers a new pipeline. However, we do want to make sure it deploys
    code correctly, so how can we test this job?
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的`deploy-to-production`任务不会在我们提交已编辑的`.gitlab-ci.yml`文件的`add-login-feature`分支上运行，因此在提交触发新的流水线时我们不会看到它运行。然而，我们确实希望确保它能正确部署代码，那么我们该如何测试这个任务呢？
- en: First, we need to merge the `add-login-feature` branch into the `Draft:` from
    the beginning of its title to make it mergeable, and click on the **Merge** button.
    Since we linked this MR to the **Allow user to log in** issue, merging the MR
    will automatically close the issue as well.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要将`add-login-feature`分支合并到`Draft:`，从标题开头开始，使其可以合并，然后点击**Merge**按钮。由于我们将这个MR与**允许用户登录**问题关联，合并MR将自动关闭该问题。
- en: This merge adds all of our pipeline configuration details to the `deploy-to-production`
    job run since the pipeline isn’t running on the `deploy-to-production` job running
    in that pipeline. Of course, we shouldn’t expect it to actually pass because we
    haven’t created the Docker image specified in the job definition, and we don’t
    have an actual production environment living at `192.168.0.1`, but at least we
    can see that the job runs, which is all that we can realistically test at this
    point. Declare victory and crack open an iced beverage of your choice. This concludes
    the example workflow for the **Hats for** **Cats** project.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这个合并将我们所有的流水线配置细节添加到了`deploy-to-production`任务运行中，因为流水线并没有在该任务上运行。当然，我们不应指望它实际通过测试，因为我们还没有创建任务定义中指定的Docker镜像，而且我们也没有在`192.168.0.1`上实际运行生产环境，但至少我们可以看到任务已运行，这也是我们此时能够现实测试的全部内容。宣布胜利，并打开一杯冰饮料，庆祝一下。这标志着**Hats
    for** **Cats**项目的示例工作流结束。
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we made a group and project to hold our code and other related
    components and made issues to plan and track our work. Then, we cloned the project’s
    repository to a local workstation so that we could write code using our favorite
    desktop tools. Then, we made a branch to commit our work to and an MR for that
    branch, linked it to an associated issue, and committed and pushed code for a
    new software feature. We set up a bare-bones CI/CD pipeline to which we can add
    a variety of tasks and registered specific runners for the project’s pipeline.
    We added automated unit tests to the pipeline to make sure the code satisfies
    its design specifications, as well as Code Quality scanning, and registered a
    special runner just for that scanner. We also added a fuzz test to the pipeline
    to find bugs in critical functions, and SAST to the pipeline to find security
    vulnerabilities in our code. We added Secret Detection to the pipeline to find
    any secrets that were inadvertently committed to the repository and added Dependency
    Scanning to the pipeline to learn about any security problems in the third-party
    libraries that our project relies on. Then, we added License Compliance to the
    pipeline to exclude third-party libraries that use software licenses that are
    incompatible with our project’s own license and integrated a third-party scanner
    into the pipeline, which is triggered automatically and integrates its results
    into existing GitLab dashboards and reports. We rewrote parts of the pipeline
    as a DAG to improve its performance and separated the pipeline configuration code
    into multiple files to improve its readability and maintainability and added logic
    so that code on the correct branch is automatically deployed to the production
    environment.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个组和项目来存放我们的代码及其他相关组件，并创建了任务来规划和跟踪我们的工作。接着，我们将项目的仓库克隆到本地工作站，这样我们就可以使用自己喜欢的桌面工具编写代码。然后，我们创建了一个分支来提交我们的工作，并为该分支创建了一个合并请求（MR），将其与相关任务关联，并提交并推送了新软件功能的代码。我们设置了一个简单的CI/CD流水线，可以在其中添加各种任务，并为该项目的流水线注册了特定的执行器。我们向流水线添加了自动化单元测试，以确保代码满足设计规范，同时进行了代码质量扫描，并为该扫描器注册了一个专用执行器。我们还向流水线添加了模糊测试，以便在关键功能中查找漏洞，并加入了SAST（静态应用安全测试）以发现代码中的安全漏洞。我们还向流水线添加了秘密检测，以查找任何意外提交到仓库中的秘密信息，并加入了依赖扫描，以了解我们项目所依赖的第三方库中的任何安全问题。接着，我们将许可证合规性检查添加到流水线中，以排除使用与我们项目许可证不兼容的软件许可证的第三方库，并将一个第三方扫描器集成到流水线中，该扫描器会自动触发并将其结果整合到现有的GitLab仪表板和报告中。我们重写了流水线的一部分，将其改为DAG（有向无环图）以提升性能，并将流水线配置代码拆分为多个文件，以提高其可读性和可维护性，并添加了逻辑，使得正确分支上的代码能自动部署到生产环境。
- en: Although we covered a lot of ground, it’s important to remember that this was
    just one example workflow. We used only a portion of the countless features offered
    by GitLab CI/CD pipelines, and we barely investigated any of the different configuration
    options for those features. There are often multiple ways of accomplishing the
    same tasks in a pipeline, and there are limitless ways you can organize those
    tasks into stages and jobs, so don’t feel like this example is the *One True Way*
    to use GitLab CI/CD pipelines. Be creative, experiment, have fun figuring out
    what pipeline features are most useful for your projects, and enjoy discovering
    which configuration settings for those features make the most sense for you and
    your team.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们覆盖了很多内容，但请记住，这只是一个示例工作流。我们只使用了GitLab CI/CD流水线提供的无数功能中的一部分，而且几乎没有探讨这些功能的不同配置选项。在流水线中，通常有多种方式完成相同的任务，而且你可以将这些任务以无限种方式组织成阶段和作业，所以不要觉得这个示例是使用GitLab
    CI/CD流水线的*唯一正确方法*。要有创意，进行实验，享受探索哪些流水线功能对你的项目最有用，并发现哪些功能的配置设置最适合你和你的团队。
- en: In the next chapter, we will learn about troubleshooting and the road ahead
    with GitLab.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将学习GitLab的故障排除以及未来的发展。
