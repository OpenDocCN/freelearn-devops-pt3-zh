- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting Started with Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s dive into learning Git. This chapter will touch upon the basic usage of
    Git. However, as explained in the previous chapter, this book is not just about
    introducing concepts and methods. It emphasizes communication and collaboration.
    Thus, while you will undoubtedly be able to master the basic usage of Git, you
    will also learn about the communication aspects behind it and how Git is used
    in team development.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will first get a feel for the basics of Git by quickly going
    hands-on with the basics of file management and branching, and then we will cover
    how Git works. Then, you will get an understanding of the collaboration principles
    to be aware of when you are working with git as an engineer.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following main topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The anatomy of Git – A beginner-friendly explanation of how Git works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Becoming a guru of Git communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The configuration instructions for proceeding with this section can be found
    in the following GitHub repository link. Please make sure Git and ssh tools are
    installed. For Windows users, it is recommended to use PowerShell. I also encourage
    you to get the most up-to-date information written about the different commands
    and environments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/DevOps-Unleashed-with-Git-and-GitHub](https://github.com/PacktPublishing/DevOps-Unleashed-with-Git-and-GitHub)'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will proceed with how to use Git, assuming a scenario where
    you are working in an individual environment and simply building up a history.
  prefs: []
  type: TYPE_NORMAL
- en: Git basics – Begin with a hands-on experience
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we delve into the details, let’s start with some hands-on experience.
    It is likely easier to grasp the concept by trying it out rather than just only
    reading about it at first.
  prefs: []
  type: TYPE_NORMAL
- en: git config – Introduce yourself to Git
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, there is something you need to do before you start a project. Introduce
    yourself to Git. To introduce yourself to Git, use the `git` `config` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`git config` is a command used to set Git configurations at the levels of system,
    user, and repository. The level `system` applies to all users and all repositories.
    The level `global` applies to all repositories of a specific user. The level `local`
    applies only to a single repository.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that your introduction has been registered, you can check with the
    `git congif --``list` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, the first task is done! Let’s quickly move on to the basic operations of
    Git.
  prefs: []
  type: TYPE_NORMAL
- en: git init – Where your code journey begins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just as every great journey has its origin, in the world of Git, your code’s
    voyage starts with the `git init` command. The command is used to initialize a
    new Git repository and start tracking existing directories. When you run the command,
    it sets up a `.git` directory packed with all the goodies you need for version
    control. With that out of the way, you are all set to dive into Git’s range of
    commands and start tracking and updating your project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Another way is to pass a directory name as an argument, such as `git init handson-repo`;
    this will create the directory, so you do not need to run the `mkdir` command.
  prefs: []
  type: TYPE_NORMAL
- en: Now that the `.git/` directory has been created, changes to files are saved
    under the `.git/` directory, but Git does not automatically save files in the
    same way recent Microsoft Office products do.
  prefs: []
  type: TYPE_NORMAL
- en: In Git, saving is completed by executing the `git add` command, which consciously
    selects files to be saved from among those that have been edited, added, or deleted,
    and the `git commit` command, which registers those changes.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s add some code to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: git add – Preparing your code for the spotlight
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `git add` command is your bridge between making changes in your working
    directory and getting them ready to be permanently stored in your Git repository.
    When you make changes to your files, Git recognizes that these files have been
    changed, but these changes are not automatically slated to become a part of the
    history. This is where `git add` steps in. This is the process of saving an office
    document, so to speak.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a new file in your `handson-repo` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `git status` command shows the current state of your repository, showing
    which files have changes that are tracked and which ones are untracked. When you
    see the `Untracked files` message, it is Git’s way of informing you that there
    is a file it has not been told to keep an eye on just yet. In our example, the
    `README.md` file is new to Git and is not registered; hence, it is labeled as
    untracked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Newly added files are part of your project, but they have not been tracked
    by Git. To move them from the untracked status to a tracked status, you use the
    `git` `add` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now Git recognizes `README.md` as a new file, and it is now tracked. The state
    targeted for saving by the `git add` command is called `README.md` file from worktree
    using the `git` `add` command.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '`git add` has other options as well. You can include everything with `git add
    .`, include multiple files such as `git add file1.md file2.md file3.md`, or use
    a wildcard such as `git add *.md` to add all files with the `.``md` extension.'
  prefs: []
  type: TYPE_NORMAL
- en: Everything’s in place; it is time to log your modifications into history.
  prefs: []
  type: TYPE_NORMAL
- en: git commit – Locking in your development progress
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `git commit` command records the changes you have staged with `git add`
    into the repository’s history. This allows you to track changes over time.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine you are playing a challenging video game. As you progress, you will
    often save your game to lock in your achievements. Similarly, when developing
    software, you will save your work using `git commit`. Each commit is a save point
    to which you can return later if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To commit changes, you can typically do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `-m` flag is followed by a short, descriptive message that captures
    the essence of the changes you have made. Writing good commit messages is an art,
    as it aids in understanding the history and intent of changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s use the `git status` command again to see if all the changes in
    the current working directory have been saved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If the message `nothing to commit` appears, your changes have been incorporated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, that is it; it is very easy to save a file in Git. Let’s review it here.
    The edit, stage, and commit flow is still the same no matter how complex your
    project is:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Edit files**: Make necessary changes to your files. For example, in this
    figure, two existing files have been edited for deletions and modifications, and
    another file has been added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Edit files](img/B21203_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Edit files
  prefs: []
  type: TYPE_NORMAL
- en: '**Stage changes**: Decide which files or specific changes you would like to
    commit and stage them. For example, in this figure, out of the three edits, only
    the deletions and modifications are staged:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Stage changes](img/B21203_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Stage changes
  prefs: []
  type: TYPE_NORMAL
- en: '**Commit changes**: Once satisfied with the staged changes, perform a commit
    to register them. Remember that every commit generates a unique commit ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Commit changes](img/B21203_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Commit changes
  prefs: []
  type: TYPE_NORMAL
- en: git log – Walking through the commit tree
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once you have made a few commits, you might want to look back and see the history
    of changes made in the repository. This is where the `git log` command comes in
    handy. The command displays a list of commits made in a repository in reverse
    chronological order, meaning the most recent commit is displayed first.
  prefs: []
  type: TYPE_NORMAL
- en: 'To try this out, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This will display a list of all commits, each with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A distinct SHA-1 identifier**: This acts as a signature for the commit and
    can be employed in various Git commands to refer to that specific commit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Committer’s details**: Showcases the name and email of the individual who
    executed the commit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timestamp of the commit**: Displays when the commit was made'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Commit message**: A brief and informative note capturing the essence of the
    alterations in the commit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to the basic `git log` command, there are numerous options that
    allow you to tailor the output to your needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`git log -p`: This option shows the difference (i.e., the patch) introduced
    at each commit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git log --stat`: This provides some abbreviated stats for each commit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git log --oneline`: This gives a more compact output, displaying each commit
    as a single line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git log --graph`: This visualizes the branch and merge history in an ASCII
    graph layout'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git log --author="John Doe"`: This filters the commits to show only those
    made by a specific individual (in this case, “John Doe”)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, it can also improve the outlook as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Prettified git log](img/B21203_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Prettified git log
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s try the `git log` command with you at hand. First, update the `README.md`
    file and create a new `CONTRIBUTING.md` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once done, add a sample Python code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'When it is confirmed in the log that it is properly logged, it is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In essence, the `git log` command is a vital tool for any developer. It helps
    you easily navigate through your code’s history, whether you are searching for
    a specific change or merely revisiting previous work.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have reviewed what we have learned so far in examining the functionality
    of `git log`.
  prefs: []
  type: TYPE_NORMAL
- en: Working with branches – The cornerstone of collaboration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While the previous sections provide you with a robust understanding of how to
    initialize and manage a Git repository, the concept of branching takes this to
    a new level. While accumulating `git commit` only creates a liner history, `git
    branch` can be used to create a history of the parallel environment. Then, you
    can merge those multiple environments into one, which enables multiple people
    to work on them, giving you the flexibility to experiment with new features, bug
    fixes, or even totally *avant-garde* ideas without affecting the main codebase.
  prefs: []
  type: TYPE_NORMAL
- en: git branch – Understanding the basics of Git branch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you initialize a Git repository, it automatically creates a default branch,
    usually called `main` (formerly known as master). When you run the `git branch`
    command, it will show the list of all branches in your repository, with the current
    branch highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'It is intuitive to think of a linear main branch like the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – git branch](img/B21203_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – git branch
  prefs: []
  type: TYPE_NORMAL
- en: 'You can create a new branch with the `git branch <branch name>` command. This
    command creates a new command from the current branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you create a new branch, you can build a line with a different history and
    add commits to that branch, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Creating a new branch](img/B21203_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – Creating a new branch
  prefs: []
  type: TYPE_NORMAL
- en: Branch naming conventions are important for communication. A commonly used standard
    is to prefix the branch name with `feature/`, `bugfix/`, or `hotfix/`, followed
    by a brief description. This makes it easier for anyone to understand the purpose
    of the branch at a glance.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also create a branch from a specific branch or commit that is different
    from the one you are currently on. This is particularly useful when you need to
    create a feature or bugfix branch that should originate from a designated development
    or staging branch rather than from your current working branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: git checkout/git switch – Switching between branches
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In your daily workflow, you will often need to switch from one branch to another,
    especially when working on multiple features or fixing bugs. When you have started
    work on multiple branches, gaining an awareness of the branch you are actively
    on becomes pivotal. In Git, the term **HEAD** refers to the tip of the branch
    you are actively working with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing your current working branch is known as checking out a branch. The
    `git checkout` command facilitates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This operation switches the HEAD position, the tip of the branch, to a branch
    called `feature/new-feature`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Checking out a branch](img/B21203_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Checking out a branch
  prefs: []
  type: TYPE_NORMAL
- en: The `git checkout` command results in the current position being the tip commit
    on the `feature/new-feature` branch, that is HEAD.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recent versions of Git also offer the `git switch` command, which provides
    a more intuitive way to switch branches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Sometimes, you may find it efficient to create a new branch and switch to it
    immediately. Git provides a shorthand command for this, combining the functionality
    of `git branch` and `git checkout` or `git switch`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new branch and switch to it in one step, you can use the `git checkout
    -``b` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In recent versions of Git, you can achieve the same with `git switch` by using
    the `-``c` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now you can not only save changes linearly with `git commit`, but also create
    parallel worlds with `git branch`, and move back and forth between parallel worlds
    freely with `git checkout`. Now, it is time to merge the two worlds.
  prefs: []
  type: TYPE_NORMAL
- en: git merge <Branch Name> – Merging branches
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you have made changes in a branch and tested them thoroughly, you may
    want to integrate those changes back into the main branch or another branch. This
    operation is known as **merging**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Merging allows you to merge lines with different histories, as shown in the
    following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Merging a branch](img/B21203_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – Merging a branch
  prefs: []
  type: TYPE_NORMAL
- en: Merging can be a straightforward operation, but it can also get complicated
    if there are conflicts between the branches. In such cases, Git will require manual
    intervention to resolve the conflicts. Conflict resolution will be addressed in
    the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: git branch –d – Deleting a Branch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once a branch has been successfully merged and is no longer needed, it can
    be deleted to keep the repository clean:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: So, by this point in the hands-on tutorial, you should have understood the basics
    of Git and gotten a feel for it. You should now be aware of what is happening
    in your project and have learned how to use basic commands.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, there is still a lot to learn for you to flexibly collaborate
    within a team. Going forward, you will learn those methods, but it is also necessary
    to understand how Git actually works in order to fundamentally understand those
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the mechanisms of Git deepens your understanding of what the commands
    are fundamentally doing, not only enhancing your proficiency in Git operations
    but also improving your communication in Git and GitHub and, consequently, in
    DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at how Git works.
  prefs: []
  type: TYPE_NORMAL
- en: The anatomy of Git – A beginner-friendly explanation of how Git works
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git is incredibly powerful, especially as projects become more complex. Up until
    now, our focus was on a straightforward history. However, where Git really shines
    is in its ability to handle large projects with a large number of contributors
    and manage the dynamically evolving code within a team seamlessly. We have come
    this far intuitively, working with Git operations as commands work. It is time
    to get down to the nitty-gritty. While it is helpful to have an intuitive feel
    for Git, by understanding how Git operates behind the scenes, we can harness its
    full potential.
  prefs: []
  type: TYPE_NORMAL
- en: The file lifecycle in Git
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Git, we learned in the previous section that saving changes is a two-step
    action, staging and committing, but Git actually handles files in four states.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every file in your project can be in one of four states:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Untracked**: Files that are present in your directory but have not been added
    to Git’s control. They are new files or files that Git has been explicitly told
    to ignore.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unmodified**: These are files that have previously been added to Git and
    have not experienced any changes since the last commit. They sit quietly, monitored
    by Git but not requiring any immediate action. In other words, they are **committed**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Modified**: Once you make changes to a tracked file, Git flags it as modified.
    At this point, the file has been altered since the last commit but has not been
    prepared (or staged) for the next commit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git add` command stages your modifications. While these changes have been
    earmarked, they are not saved in the repository until you commit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure shows these status transitions. Files go back and forth
    between these states:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Four types of the file status of Git](img/B21203_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – Four types of the file status of Git
  prefs: []
  type: TYPE_NORMAL
- en: When you create or introduce new files to your project, they begin as `git add`
    command, they transition to the **unmodified**status, signifying that they are
    now under Git’s surveillance.
  prefs: []
  type: TYPE_NORMAL
- en: Subsequent changes to these tracked files will place them in the **modified**
    status. Before they can be committed, these changes need to be staged, moving
    the file to the **staged** status. Staging gives you a preview of the changes
    you are about to commit. Think of it as putting items in a box (staging area),
    and prepping them for shipment (commit). You decide which items (or changes) go
    into that box.
  prefs: []
  type: TYPE_NORMAL
- en: After staging, you can commit these changes using the `git commit` command.
    When you stage changes, especially through interfaces such as Visual Studio Code,
    it is typically as simple as clicking a button. Once you are satisfied with the
    staged changes, you commit them, permanently saving them to your project history.
  prefs: []
  type: TYPE_NORMAL
- en: Upon committing, these files revert to the **unmodified** status, waiting for
    future edits or changes. In other words, at this stage, the status can be said
    to have become **committed**. In Git, every commit you make records the current
    state of your project at that specific point in time. This recording mechanism
    is foundational to Git’s capabilities, ensuring that every change is documented.
    This allows developers to navigate back to any specific commit, providing the
    flexibility to review or revert to previous versions as required.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, if a tracked file is removed from the directory, Git recognizes
    it as **untracked** until it is explicitly deleted from the repository.
  prefs: []
  type: TYPE_NORMAL
- en: This lifecycle provides developers with precise control over their project changes,
    allowing for strategic commits and ensuring clear, organized version histories.
  prefs: []
  type: TYPE_NORMAL
- en: Behind the scenes – Git’s architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First and foremost, what is Git really? At its core, Git is a `.git` directory.
    This concealed directory contains the history of your code–commits, branches,
    configuration files, and more. You may recall from the initial stages of your
    Git journey, during the `git init` command section, that a `.git` directory is
    created.
  prefs: []
  type: TYPE_NORMAL
- en: A deeper dive – Exploring the .git directory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By running the `ls` command, you can see several sub-directory and configuration
    files. Among these, the `objects` directory is most relevant to our current discussion.
    This is the heart of Git’s key-value store, housing the blobs (actual file content),
    tree objects (directory structures), and commits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s peek into the `objects` folder. This is where the key-value store
    resides. The names of the folders, which are two alphanumeric characters, represent
    the first two characters of the commit ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Each commit or data piece in Git is uniquely identified by a key, the SHA-1
    hash. This hash, a string of 40 alphanumeric characters, is something like `b641640413035d84b272600d3419cad3b0352d70`.
    This unique identifier for each commit is generated by Git based on the commit’s
    content. These IDs you see include what you see when you run the `git log` command
    and match the changes you have made so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If we open the `b6` directory, we will recognize the structure of the key-value
    store, with the commit ID serving as the file name or the key. But what lies within
    these files? To find out, let’s next take a peek inside with the `git` `cat-file`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of this book, the first two characters of Hash are **b6**, but
    a different list should be displayed in your environment. Let’s choose an appropriate
    hash and run the **ls** command:'
  prefs: []
  type: TYPE_NORMAL
- en: '**$** **ls .git/objects/b6/**'
  prefs: []
  type: TYPE_NORMAL
- en: '**41640413035d84b272600d3419cad3b0352d70**'
  prefs: []
  type: TYPE_NORMAL
- en: git cat-file – Dissecting the inner workings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To inspect the contents of the value in the key-value store, the `git cat-file`
    command can be used. When passing the first seven letters of the commit ID as
    an argument, we get results showcasing the tree and parent, which refers to the
    ID of the parent commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with hashes in Git commands, it is not necessary to pass the 40
    characters as they are; they can be omitted. In this sample case, the first seven
    letters are passed as an argument, but a minimum requirement is four letters.
    Although it depends on the size of the project, it is relatively safe to specify
    at least seven characters to avoid key collisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Git, there are four main objects that are managed and used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`commit` object: Has a reference to the tree object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tree` object: Has references to blob and/or other tree objects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`blob` object: Has the data (like file content)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tag` object: Has information about the annotated tag'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The commit references are structured to embed the Id of the `parent` commit
    in the value. But where did the actual commit file go? In the output, we see a
    `tree` labeled Id as well as `parent`. It seems that this tree also has a SHA-1
    hash, so let’s examine its value using the `git` `cat-file` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon invoking the `git cat-file` command for the Id tagged with `tree`, we
    get a result showcasing a file type named `blob`. Let’s reference the blob ID
    for `README.md` using the `git cat-file` command. This reveals the file content,
    indicating that data stored as the blob type within the key-value store represents
    the actual file. These observations give us a clearer picture of Git’s architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now you know how Git stores value in the key-value store. You should understand
    that Git is not a black box; it is a system that manages history as value, keyed
    by a SHA-1 hash.
  prefs: []
  type: TYPE_NORMAL
- en: git show – Easier to use in your daily activities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Previously, we used the `git cat-file` command to learn how Git works, but
    there is a similar command, `git show`. Both are powerful Git commands, but they
    serve somewhat different purposes and provide different outputs. `git cat-file`
    is a low-level utility that is primarily designed to inspect Git objects, such
    as blobs, trees, commits, and tags. It can display the object’s type, its size,
    and even its raw content. On the other hand, `git show` is more user-friendly
    in nature; this command provides a readable view of various types of Git objects.
    By default, it showcases the log message and textual difference for a commit.
    However, it is versatile enough to display other object types, such as blobs,
    trees, and tags, in an easy-to-read format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If you are a developer or a Git user wanting to see the changes introduced by
    a commit or view the content of a file at a particular revision, `git show` is
    the more intuitive choice. In contrast, `git cat-file` dives deeper into the internal
    structure of Git, allowing users to directly interact with and inspect the raw
    Git objects. For someone deeply involved in the inner workings of Git or developing
    tools that interface with Git’s core system, `git cat-file` provides a granular
    level of detail. However, for the majority of everyday tasks and for those who
    are just starting their journey with Git and GitHub, `git show` offers a more
    user-friendly way to view changes and content without the need to delve into the
    intricacies of Git’s object database.
  prefs: []
  type: TYPE_NORMAL
- en: Git tree structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we know that Git is essentially a key-value store. Next, let’s look at
    how each object is connected and managed in a consistent manner as historical
    data. In the previous section, we saw the keywords `tree` and `parent`, but what
    are they really? We will now explore the relationship between commits and objects
    to which those keywords link to.
  prefs: []
  type: TYPE_NORMAL
- en: Commit, tree, and blob
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Git, the concept of a tree structure plays a vital role in maintaining the
    state of the repository. Each commit is not just a set of changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Explanation of each keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Commit**: Every commit in Git is uniquely identified by an SHA-1 hash. It
    carries with it a snapshot of the repository’s state by referencing a tree object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tree**: Trees in Git act like directories. They can reference other trees
    (subdirectories) and blobs (files). Each tree has its distinct SHA-1 hash. The
    primary tree, representing the repository’s top-tier directory, is the root tree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blob**: A blob represents the content of a file in the repository. Like commits
    and trees, each blob has its unique SHA-1 hash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parent and child
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The lineage and progression of a repository’s history are captured through the
    parent-child relationships between commits.
  prefs: []
  type: TYPE_NORMAL
- en: Most commits in Git reference a single parent commit, representing the direct
    predecessor in the repository’s timeline.
  prefs: []
  type: TYPE_NORMAL
- en: As explained in the previous page, a commit holds the ID of its parent commit,
    establishing a referential relationship. In many visual representations of commits,
    arrows often depict this relationship. It is worth noting that the direction of
    these arrows often appears inverse to the sequence of commits. Each commit has
    the relationship shown in the figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Git commit relation](img/B21203_02_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – Git commit relation
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Commits can sometimes have multiple parents, especially when two branches merge.
    This dual parentage signifies the joining of two separate lines of development.
  prefs: []
  type: TYPE_NORMAL
- en: How does Git store trees and blobs?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The marvel of Git’s efficiency is deeply rooted in how it stores its trees and
    blobs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s illustrate the relationship between each of these:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – Git tree structure](img/B21203_02_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – Git tree structure
  prefs: []
  type: TYPE_NORMAL
- en: Every commit in Git corresponds to a tree, representing the state of the repository’s
    files and directories at that specific moment. For a deeper dive, consider the
    diagram presented. The commit labeled `fb36640` holds a reference to the tree
    `d6f50a2`. This tree mirrors the repository’s root directory during that commit.
  prefs: []
  type: TYPE_NORMAL
- en: As we traverse this tree (`d6f50a2`), we encounter various pointers. Some of
    these lead us to blobs, while others to trees. A blob, such as `2d69956`, corresponds
    to a file—in this case, `LICENSE`. Meanwhile, a tree, such as `1d0f85d`, stands
    for a subdirectory named `contents`. This subdirectory tree can further point
    to its own set of blobs and trees.
  prefs: []
  type: TYPE_NORMAL
- en: 'This intricate linkage crafts a hierarchy reminiscent of a traditional filesystem.
    Each layer of this hierarchy denotes different files and directories in your repository.
    Central to Git’s design philosophy is efficiency. By structuring its data in this
    hierarchical manner, Git can swiftly track changes across files and directories
    without redundant storage. For instance, unchanged files across commits point
    to the same blob, optimizing storage and retrieval:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – Efficient file management in Git](img/B21203_02_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – Efficient file management in Git
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Git’s tree structure and how it relates to blobs and commits is
    fundamental for any developer. It is not just about using Git commands; it is
    about appreciating the ingenious architecture beneath, ensuring that your code’s
    history is efficiently and accurately preserved. As you progress in your Git journey,
    this knowledge will empower you to utilize Git’s capabilities to their fullest.
  prefs: []
  type: TYPE_NORMAL
- en: Up to this point, you have learned that Git recognizes the state of each file
    and registers it in a key-value store. You also learned that this key-value store
    has a tree structure with parent-child relationships. If you peek into the `.git/`
    directory, you will see that it has a very simple structure, and it is thanks
    to this simplicity that Git can manage complex projects.
  prefs: []
  type: TYPE_NORMAL
- en: If you have understood all this, then you are well-prepared for your journey
    to mastering Git. While this book cannot cover every Git command, understanding
    these basics will ensure you will be okay even if you encounter unfamiliar Git
    commands in the future. You have the technical foundation to understand them.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s learn one more thing to conclude your preparation for your Git journey
    in this chapter. That is the mindset for the journey with Git. This mindset is
    not only for using Git but is directly related to collaboration in DevOps as well.
  prefs: []
  type: TYPE_NORMAL
- en: Becoming a guru of Git communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s hit the pause button for a moment. While most resources might hurry you
    along to cover essential Git commands, conflict resolutions, merge types, and
    Git workflows, we are taking a breather to focus on the core of the matter.
  prefs: []
  type: TYPE_NORMAL
- en: So, why was Git even developed in the first place? At its essence, Git was created
    to streamline communication in complex development projects. Since this book aims
    to elevate your role within a DevOps team, understanding the communicative power
    of Git is key. After all, DevOps is not just about technology; it is about improving
    collaboration, breaking down silos, and facilitating smoother workflows.
  prefs: []
  type: TYPE_NORMAL
- en: As you navigate through Git commands and repositories, bear in mind that you
    are not just sharing code; you are also communicating with your team. Your commits,
    pull requests, and merges should be thought of as dialogues in a broader conversation
    aimed at creating something magnificent.
  prefs: []
  type: TYPE_NORMAL
- en: So, as you proceed with learning Git, focus on honing your mindset. A well-tuned
    approach to Git goes beyond mere commands; it makes you an invaluable team player,
    aligned with the overarching objectives of your DevOps environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember: haste makes waste. Take the time to understand the Git essentials
    deeply, and you will not only be a proficient coder but also an exceptional collaborator
    in your DevOps team.'
  prefs: []
  type: TYPE_NORMAL
- en: git commit – Revisiting the most important command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you ask me, the most important command in Git is `git commit`. If it is perfect,
    everything else is secondary. This command delineates the scope of all your coding
    activities and solidifies your output, determining the quality of your work. A
    commit serves as a unit of communication. Getting this unit of communication wrong
    can confuse all subsequent communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have you ever built something using LEGO bricks? The essence of LEGO is not
    only just about following instructions but also about sparking creativity and
    building something original. Sometimes, you collaborate with friends, like building
    a castle together. Everyone might have a role: someone makes the gate, another
    the foundation, and someone else the tower. Your success lies in building a magnificent
    castle as a team. But consider this: even if you individually craft a brilliant
    part, it may not be appreciated if it does not align with others’ visions or does
    not fit with the pieces they have created. It is essential to ensure that the
    parts match in size and to frequently verify this compatibility. In other words,
    you need to continually adjust the way and parts of the build while communicating
    at the right times. As kids, you might have made strange creations without perfect
    communication, and while it might have been praised for its creativity, the situation
    is different now. If you are reading this book, you likely work in an organization,
    creating some product, possibly earning a salary, and holding responsibility.
    This means these considerations are not just nice to have; they are a must.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s transition back to coding. When you code within a team, not only you but
    all team members, past and present, will review your code and actions in Git.
    Even when you code alone, your future self and past self are your collaborators.
    Many times, I have struggled to understand my old code or recall what I was trying
    to accomplish by running `git log` command and still have no idea. How well Git
    operations are managed will be reflected in the code management and production
    process. It would be better to have a principle that you can remember when using
    Git.
  prefs: []
  type: TYPE_NORMAL
- en: Control quality and quantity to be a good communicator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are plenty of good practices out there on how to use Git. However, many
    things can be categorized somewhere in the four boxes of the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13 – Excellence in git commit](img/B21203_02_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 – Excellence in git commit
  prefs: []
  type: TYPE_NORMAL
- en: Early and often commit – Embracing a core principle for DevOps success
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The modern software development landscape has changed drastically over the past
    few decades. Traditional Waterfall have made way for Agile methodologies, and
    this has further evolved into the DevOps culture that many organizations now embrace.
    Central to this evolution is the notion of **Continuous Integration and Continuous
    Delivery** (**CI**/**CD**). One of the foundational practices supporting this
    methodology is the idea of committing code early and often. In this section, we
    will delve into the importance of this practice, especially in the context of
    Git and GitHub for DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: The traditional paradigm
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the days of yore, developers would often spend days or even weeks working
    on a feature or a fix, only to merge their changes into the main branch at the
    end. This would often lead to merge conflicts, bugs, and a lot of manual intervention
    to rectify issues. This model was not scalable and was antithetical to the fast-paced,
    customer-centric demands of today’s tech environment.
  prefs: []
  type: TYPE_NORMAL
- en: The shift to early commits
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Committing early means that as soon as you have a logical chunk of work completed,
    you commit it. This does not necessarily mean the entire feature is done, but
    maybe just a function or a class. Why is this beneficial?
  prefs: []
  type: TYPE_NORMAL
- en: '**Smaller changes**: Smaller changes are easier to review. They are more digestible,
    making the code review process more efficient and effective.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduced merge conflicts**: By committing and pushing your changes early,
    you reduce the chances of running into a merge conflict since you are frequently
    syncing your branch with the main branch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Faster feedback loop**: The sooner you commit and push your changes, the
    sooner automated tests can run, and the sooner you can get feedback on your code.
    This allows for quicker iterations and faster delivery of features and fixes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The benefit of often commits
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Committing often goes hand-in-hand with committing early. The more frequently
    you commit, the more the following points are kept to:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Easier to pinpoint issues**: If a bug arises, it is much simpler to identify
    the cause when you are sifting through a small commit rather than a massive one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easier to roll back**: If a commit causes an unforeseen issue, rolling back
    to a previous stable state is straightforward. This safety net can be a lifesaver
    in production environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Awesome commit message – Crafting clear, informative, and concise narratives
    for your code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the realm of software development, the code we write is not merely a set
    of instructions for machines; it is also a form of communication with our peers.
    However, while code shows the *how*, it is the commit message that illuminates
    the *why*. A well-crafted commit message is a beacon for fellow developers, providing
    context, clarity, and a historical record of code changes.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of commit messages
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'At its core, a commit message serves several key functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Historical record**: It offers a chronological account of changes, allowing
    developers to understand the evolution of a codebase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Context**: It provides reasoning for changes, granting insights that the
    code alone might not convey.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documentation**: Beyond inline comments and external documentation, commit
    messages act as a form of documentation that can explain decisions and trade-offs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Characteristics of an awesome commit message
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'What differentiates a good commit message from an awesome one? Here are the
    hallmarks of an exceptional commit message:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Concise subject line**: Begin with a brief and direct subject line, ideally
    under 50 characters, capturing the essence of the commit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git commit -m "subject-line" -m "``description-body"` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use the active voice**: Phrases such as “*Add feature*” or “*Fix bug*” are
    clearer and more direct than “*Added feature*” or “*Fixed bug*.”'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reference issues**: If the commit relates to a specific issue or task in
    a tracking system, reference its ID or link, aiding in traceability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DevOps connection
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: For the contemporary DevOps engineer, commit messages are not just an afterthought;
    they are a core component of the DevOps philosophy.
  prefs: []
  type: TYPE_NORMAL
- en: In today’s software landscape, the line between application development and
    infrastructure has become increasingly blurred. Engineers skilled in infrastructure
    might find themselves reading application code and vice versa. More importantly,
    tools across both domains are now integrating with Git, enabling professionals
    to view commit messages alongside Git hashes on various platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Given this integration, a commit message no longer remains confined to its repository
    or team. It embarks on a journey across different organizational boundaries and
    platforms. This transition highlights the value of a well-crafted commit message
    as a universal language that can be understood and appreciated by diverse stakeholders
    in the software development and delivery pipeline. In the quest to break organizational
    silos and improve developer experience, your awesome commit message will help
    your journey.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some tips for a great commit message:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transparency is key**: Clear commit messages allow teams, from development
    to operations, to understand code changes, reducing friction and enhancing collaboration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continuous delivery relies on history**: As organizations push towards more
    frequent releases, the ability to quickly understand and verify changes becomes
    paramount. An informative commit message is a critical tool in this process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commit message examples
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Here is an example of a commit message. This is basic, and you can use it as
    a starting point to add your own context from here, but it should not be too long:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Category** | **Example** **commit messages** |'
  prefs: []
  type: TYPE_TB
- en: '| **Simple changes** | Add `README.md` |'
  prefs: []
  type: TYPE_TB
- en: '| Update license expiration date |'
  prefs: []
  type: TYPE_TB
- en: '| Remove deprecated method XYZ |'
  prefs: []
  type: TYPE_TB
- en: '| **Feature additions/updates** | Implement user authentication flow |'
  prefs: []
  type: TYPE_TB
- en: '| Add search functionality to the homepage |'
  prefs: []
  type: TYPE_TB
- en: '| Extend API to support versioning |'
  prefs: []
  type: TYPE_TB
- en: '| **Bug fixes** | Fix login bug causing session timeouts |'
  prefs: []
  type: TYPE_TB
- en: '| Resolve memory leak in the data processing module |'
  prefs: []
  type: TYPE_TB
- en: '| Correct the typo in the user registration form |'
  prefs: []
  type: TYPE_TB
- en: '| **Refactoring and code** **quality improvements** | Refactor database connection
    logic for pooling |'
  prefs: []
  type: TYPE_TB
- en: '| Optimize image loading for faster page rendering |'
  prefs: []
  type: TYPE_TB
- en: '| Improve error handling in the payment gateway |'
  prefs: []
  type: TYPE_TB
- en: '| **Documentation** **and comments** | Document main algorithms in XYZ module
    |'
  prefs: []
  type: TYPE_TB
- en: '| Update comments for clarity in the X function |'
  prefs: []
  type: TYPE_TB
- en: '| Revise API documentation for new endpoints |'
  prefs: []
  type: TYPE_TB
- en: '| **Reverting changes** | Revert “Add experimental feature X” |'
  prefs: []
  type: TYPE_TB
- en: '| Rollback to a stable state before the caching layer update |'
  prefs: []
  type: TYPE_TB
- en: '| **Dependency and** **external integrations** | Upgrade to v2.1.3 of ABC library
    |'
  prefs: []
  type: TYPE_TB
- en: '| Integrate the latest security patches for the XYZ framework |'
  prefs: []
  type: TYPE_TB
- en: '| **With issue/task** **tracking references** | Fix #1234: Address edge case
    in order checkout |'
  prefs: []
  type: TYPE_TB
- en: '| Feature #5678: Add multi-language support |'
  prefs: []
  type: TYPE_TB
- en: '| **Merges operations** | Merge branch ‘feature/user-profiles’ |'
  prefs: []
  type: TYPE_TB
- en: '| Resolve merge conflict in main.css |'
  prefs: []
  type: TYPE_TB
- en: '| **Test-related changes** | Add unit tests for utility functions |'
  prefs: []
  type: TYPE_TB
- en: '| Refactor integration tests to use mock data |'
  prefs: []
  type: TYPE_TB
- en: '| Fix flaky test in user registration flow |'
  prefs: []
  type: TYPE_TB
- en: Table 2.1 – Commit message example
  prefs: []
  type: TYPE_NORMAL
- en: Single-purpose code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the evolving landscape of software development, where Agile and DevOps practices
    champion swift iteration and robust collaboration, the principle of single-purpose
    code gains heightened importance. Its influence transcends the realm of code structure,
    weaving itself into the very fabric of developer experience and Git communication.
    Let’s delve into the profound connections that intertwine these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Aligning with Agile principles
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Agile methodologies, at their core, promote adaptability, continuous improvement,
    and delivering value in small, manageable increments. Single-purpose code seamlessly
    aligns with these tenets:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Incremental development**: Just as Agile breaks down features into smaller
    user stories or tasks, single-purpose code encourages breaking down software components
    into focused, manageable chunks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adaptability**: Single-purpose components are easier to modify or replace,
    aligning with Agile’s embrace of change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enhancing the DevOps pipeline
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'DevOps emphasizes the continuous integration and delivery of software, bridging
    the worlds of development and operations. Here’s where single-purpose code shines:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Streamlined CI/CD**: With code components being focused and independent,
    the chances of one module unexpectedly affecting another during integrations are
    reduced, leading to smoother CI/CD pipelines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Better monitoring and logging**: When components have a single responsibility,
    it is easier to monitor their behavior and log relevant events. Any anomalies
    can be traced directly to a specific functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elevating the developer experience
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The concept of **Developer Experience** (**DX**) revolves around making developers’
    lives easier, promoting productivity, and reducing friction. Single-purpose code
    plays a pivotal role in this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Intuitive onboarding**: New team members can understand and contribute faster
    when the codebase consists of clear, focused components'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Efficient debugging**: With each component doing one thing, identifying and
    resolving issues becomes a more streamlined process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The deep-rooted connection with Git communication
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As previously noted, there is a profound synergy between single-purpose code
    and Git:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Clear commit messages**: Writing single-purpose code results in precise commit
    messages. A change to a singularly focused function or module can be succinctly
    described in Git, promoting transparency and clarity in communication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplified code reviews**: Pull requests on platforms such as GitHub become
    more straightforward when they revolve around focused changes. It is easier for
    reviewers to understand the intent and verify the implementation, leading to more
    meaningful feedback and collaboration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Complete code: Striking a balance between precision and progress'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the realm of software development, there is an age-old tension between the
    need for perfection and the demands of progress. Developers often grapple with
    the question, When is my code ready? In this discourse, we aim to elucidate the
    concept of complete code, a philosophy that emphasizes producing robust, fully
    realized solutions without getting mired in the unattainable pursuit of perfection.
  prefs: []
  type: TYPE_NORMAL
- en: The essence of complete code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The ethos behind **complete code** is simple yet profound: any code written
    should be whole in its intent and execution. This means the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No half-measures**: If you are implementing a feature or fixing a bug, the
    code should accomplish its goal fully, not just partially or superficially.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Review-ready**: The code should be of a quality that it is ready for peer
    review. This means not only being functional but also adhering to coding standards
    and best practices of the team or organization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Accompanied with tests**: Wherever applicable, the code should come with
    tests, ensuring that it not only works as intended now but continues to do so
    as the software evolves.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Done is better than perfect
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'While the emphasis is on completeness, it is crucial to recognize that chasing
    perfection can be a counterproductive endeavor. Software is inherently iterative,
    and waiting for the perfect solution can stall progress. The mantra “done is better
    than perfect” serves as a reminder of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Iterative improvement is key**: It is okay if the solution is not the most
    optimal out of the gate. It needs to work, and improvements can be made over time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feedback fuels perfection**: Often, getting the code out and gathering feedback
    leads to better solutions than endless internal iterations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The role of testing in complete code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Testing is a linchpin in the complete code philosophy:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Validation**: Tests validate that the code does what it is supposed to do,
    offering a safety net against regressions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Documentation**: Well-crafted tests also act as documentation, providing
    insights into the expected behavior of the code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Confidence**: Tests instill confidence. When developers write complete code
    backed by tests, they can make changes or add features with the assurance that
    they will know if something breaks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The importance of modern development practices
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'In an era where Agile and DevOps dominate and CI/CD pipelines automate software
    delivery, the importance of complete code becomes even more pronounced:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Streamlined pipelines**: The CI/CD pipeline is executed with the consideration
    that the integrated code may be incomplete. That does not mean it can be incomplete
    at any time, and your team’s testing statistics will turn red if there are too
    many failures. Incomplete code disrupts the pipeline, causes bottlenecks and inefficiencies,
    and is indicative of the quality of your team’s code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collaborative efficiency**: In team settings, when a developer commits complete,
    review-ready code, it fosters a smoother collaboration. Reviewers spend less time
    pointing out basic issues and more time delving into architectural or logical
    discussions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now you understand how to preserve history in Git. Commit messages are a pain
    to write. You have to describe your work in just a few dozen characters. However,
    it is important to pay attention to these details in Git collaboration.
  prefs: []
  type: TYPE_NORMAL
- en: Because you are spending a few hours to make the commit (maybe dozens of hours),
    it would be a shame to ruin it when you could make the collaboration great with
    just a few more seconds or a few more minutes of attention.
  prefs: []
  type: TYPE_NORMAL
- en: The excellence is in the details. Let’s practice and become a real guru!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you wrap up this chapter, you should feel more acquainted with Git’s essential
    features, underlying mechanics, and, most importantly, the philosophy of collaboration
    it champions. Understanding these fundamentals is often far more crucial than
    memorizing a litany of Git commands or stashing away snippets for quick use.
  prefs: []
  type: TYPE_NORMAL
- en: If you have internalized the insights from this chapter, rest assured you have
    obtained a solid grasp of Git’s basics. You are not just prepared to commit code;
    you are ready to be a collaborative force within your team.
  prefs: []
  type: TYPE_NORMAL
- en: When you first join a project managed by Git, the initial challenges are usually
    not resolving intricate conflicts or juggling chaotic branches; rather, the challenge
    lies in crafting meaningful commits and proving yourself to be an invaluable team
    player. Each well-considered commit you make not only contributes to the project
    but also fortifies your standing within the team.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move on to more advanced Git usage to help you shine as a team player.
  prefs: []
  type: TYPE_NORMAL
