<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer038">
<h1 class="chapter-number" id="_idParaDest-69"><a id="_idTextAnchor069"/>4<a id="_idTextAnchor070"/></h1>
<h1 id="_idParaDest-70"><a id="_idTextAnchor071"/>Everything Starts with Source Control</h1>
<p>Source control is one of the most basic tools that is used in software development. Therefore, it is probably safe to assume that you have worked with source control before. For that reason, this chapter will contain only a brief introduction to source control and quickly move on to more advanced topics to help you to set up your source control to support DevOps practices.</p>
<p>Multiple DevOps practices rely on source control, so setting up your repositories to continuously deliver value to your users is a great way to get started and a prerequisite for many of the subjects in the following chapters.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>The types of source control in Azure DevOps source control systems</li>
<li>Selecting a branching and merging strategy </li>
<li>Securing source control using branch policies </li>
<li>Other tools that are available for source control</li>
</ul>
<h1 id="_idParaDest-71"><a id="_idTextAnchor072"/>Technical requirements</h1>
<p>To practice the subjects covered in this chapter, you may need an Azure DevOps organization. Also, ensure that Git tools are installed on your local machine. You can download Git tools from here: <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a>.</p>
<h1 id="_idParaDest-72"><a id="_idTextAnchor073"/><a id="_idTextAnchor074"/><a id="_idTextAnchor075"/>Types of source control in Azure DevOps</h1>
<p>While there are many different source<a id="_idIndexMarker263"/> control systems in existence, they can be classified into two categories, centralized and decentralized, as<a id="_idIndexMarker264"/> follows:</p>
<ul>
<li>In a <strong class="bold">centralized source control</strong> system, only the server has the full history and the full set of branches that make up<a id="_idIndexMarker265"/> the repository.</li>
<li>In a <strong class="bold">decentralized source control</strong> system, everyone<a id="_idIndexMarker266"/> working with the repository has a full copy of the repository, all of the branches, and its history.</li>
</ul>
<p>Azure Repos, part of Azure DevOps <a id="_idIndexMarker267"/>services, offers both types of source control through<strong class="bold"> Team Foundation Version Con<a id="_idTextAnchor076"/>trol</strong> (<strong class="bold">TFVC</strong>) and Git. The next two sections discuss both types of source control in more det<a id="_idTextAnchor077"/>ail.</p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor078"/>Centralized source control</h2>
<p>In a centralized source <a id="_idIndexMarker268"/>control system, the server is the only location where the full repository, including all of the history, is stored. When you create a local version of the content, you only receive the latest version of the code. Receiving this latest version is called <strong class="bold">checking out</strong> the repository. In <a id="_idIndexMarker269"/>addition to this latest version, your own computer only has the changes you make locally.</p>
<p>Not checking out the full history obviously saves space on your local computer. However, disk space is hardly ever an issue nowadays. The downside of this is that you need to be continuously connected to the server to perform operations such as viewing the history of a file, recent commits of others, or which line in a file was last changed by who.</p>
<p>An advantage <a id="_idIndexMarker270"/>of centralized source control systems is that they often offer opti<a id="_idTextAnchor079"/>ons for fine-grained control over who can access which branches, directories, and even<a id="_idTextAnchor080"/> files.</p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor081"/>Decentralized source control</h2>
<p>With a decentralized source<a id="_idIndexMarker271"/> control system, all files, history, and branches are also stored on a server. The difference with centralized source control comes when you <strong class="bold">clone</strong> the repository to have a local copy on your own computer.</p>
<p>Since you have a full clone of the repository, you can now view the history of a file and other branches without connecting to the server again. This obviously lessens the load on the server and allows you to continue working even when disconnected, which are two advantages of<a id="_idIndexMarker272"/> decentralized source<a id="_idTextAnchor082"/> control.</p>
<p>The downside is that<a id="_idIndexMarker273"/> decentralized source control can be harder to learn than centralized source control. Overall, the learning curve of decentralized source control systems is steeper. Also, access control on the level of individual directories and files is often more limited.</p>
<p>No matter which type of source control you are using, you must put a branching and merging strategy in place to allow developers to work on different features in<a id="_idTextAnchor083"/> parallel, while always keeping your <strong class="source-inline">master</strong> branch in a shippable state.</p>
<p>In a recent update to Azure DevOps, the default branch that gets created at the time of the repository creation is now named <strong class="source-inline">main</strong>. Azure DevOps also offers you the ability to rename your <a id="_idIndexMarker274"/>default branch to something else. Refer here for more information: <a href="https://docs.microsoft.com/en-us/azure/devops/repos/git/change-default-branch">https://docs.microsoft.com/en-us/azure/devops/repos/git/change-default-branch</a>.</p>
<p>In the next section, we will look at the different source control systems that have been most commonly used within the developer <a id="_idTextAnchor084"/>community. </p>
<h2 id="_idParaDest-75"><a id="_idTextAnchor085"/>Source control systems</h2>
<p>There are many source<a id="_idIndexMarker275"/> control systems in use, but in this chapter, we will only be looking at the three currently most used. They are the following:</p>
<ul>
<li>TFVC</li>
<li>Git</li>
<li>Subversion</li>
</ul>
<p>Within Azure DevOps, only TVFC and Git are available. Subversion is a centralized source control system that is created by the Apache Foundation. In the upcoming subsections, we’ll take a look at TFVC and Git in <a id="_idIndexMarker276"/>more detail and learn how to migrate sources between them. Subversion is discussed at the end of this chapter in th<a id="_idTextAnchor086"/>e <em class="italic">Other tools for source con<a id="_idTextAnchor087"/>trol</em> section.</p>
<h3>TFVC</h3>
<p><strong class="bold">TFVC</strong> is a centralized source <a id="_idIndexMarker277"/>control system that was introduced by Microsoft in 2013, as part of <strong class="bold">Team Foundation Server</strong> (<strong class="bold">TFS</strong>), the product that has evolved to become Azure DevOps. TFVC is still<a id="_idIndexMarker278"/> supported in Azure DevOps but is not recommended <a id="_idIndexMarker279"/>for new projects. If you are not already working with TFVC, there is no value in learning it as Microsoft will most likely not release new features for it, but it isn’t necessary to move away from it without other drivers.</p>
<p>In Azure DevOps, there is a maximum of one TFVC repository p<a id="_idTextAnchor088"/><a id="_idTextAnchor089"/>er team project.</p>
<h3>Git</h3>
<p>Next to <a id="_idIndexMarker280"/><a id="_idIndexMarker281"/>TFVC, Azure DevOps also supports hosting <a id="_idIndexMarker282"/><a id="_idIndexMarker283"/>Git repositories. Git is a form of decentralized source control that is the standard now among the developer community. Git is not specific to Azure DevOps but is a general protocol that is used by many platforms that provide source control hosting as a service. Well-known examples next to Azure DevOps are GitHub and GitLab.</p>
<p>To work with a <a id="_idIndexMarker284"/>Git repository, you must first clone it:</p>
<ol>
<li>Open <em class="italic">Command Prompt</em> and navigate to the directory where you want to store the repository.</li>
<li>Execute the following command and replace the example URL with the URL to your Git repository. The example URL shows how the location of a Git repository in Azure DevOps is built up:<p class="source-code"><strong class="bold">git clone https://{organization}@dev.azure.com/{organization}/{teamProjec t}/_git/{repository}</strong></p></li>
</ol>
<p>Now, you can start working on the changes you want to make. In this example, a new file, <strong class="source-inline">NewFile.txt</strong>, was added.</p>
<ol>
<li value="3">Next, this file must be staged for commit. Staging files is done to differentiate between files you want to commit and changes you want to keep for your own:<p class="source-code"><strong class="bold">git add NewFile.txt</strong></p></li>
<li>After staging all of the changes you want to group into a single commit, creating the actual <strong class="source-inline">commit</strong> is done by calling the <strong class="source-inline">commit</strong> command and specifying a description of the changes:<p class="source-code"><strong class="bold">git commit -m “Added a new file that contains an important text”</strong></p></li>
<li>Finally, you can push your changes back to the central<a id="_idIndexMarker285"/> repository (also termed as the remote), by executing the following command:<p class="source-code"><strong class="bold">git push</strong></p></li>
</ol>
<p>To make more changes, you can stage and commit changes as often as required. You can push the commits one at a time, or you can push multiple commits at once.</p>
<p>You can also work with Git through the <strong class="bold">Visual Studio</strong> (<strong class="bold">VS</strong>) or VS Code interfaces. Here, you execute precisely the<a id="_idIndexMarker286"/> same steps, but instead of your familiar command-line interface, you can use <a id="_idTextAnchor090"/><a id="_idTextAnchor091"/><a id="_idTextAnchor092"/>a visual interface.</p>
<h3>Large File Storage</h3>
<p>Git is designed and optimized for working with plain text files and tracking changes from version to version. However, you might want to store other things than just text files in source control. Examples <a id="_idIndexMarker287"/>are images or binary files that should be included with your application at runtime. While these are valid use cases, out of the box, they <a id="_idIndexMarker288"/>do not work very well with Git. To fix this, <strong class="bold">Large File Storage</strong> (<strong class="bold">LFS</strong>) was introduced.</p>
<p>Instead of storing the binary file itself, Git LFS allows you to store a small, text file that acts as a pointer to the binary file. The text file contains a hash of the binary file so that the client can download the file when cloning or fetching changes. Subsequently when you update the binary file, the hash within the text file is also updated.</p>
<p>To work with Git LFS, you must install the LFS client next to the Git client. This is a separate client that every user of the repository must download. Without this client, other users will only see the pointer files instead of the actual binary files. After installing the client, you must <a id="_idIndexMarker289"/>prepare the repository for the use of LFS. The following example commands enable the use of LFS for MP4 files:</p>
<pre class="source-code">
git lfs install
git lfs track “*.mp4” 
git add .gitattributes</pre>
<p>From here onward, you can work with MP4 files just like any file, and b<a id="_idTextAnchor093"/>ehind the scenes, they will be stored <a id="_idIndexMarker290"/>separately from <a id="_idTextAnchor094"/>your text file changes.</p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor095"/>Migrating between control systems</h2>
<p>One of the steps<a id="_idIndexMarker291"/> on the DevOps journey is the consolidation of tools. This means that, at some point, you might be asked to migrate sources from one source control system to another, and companies might decide to move all of their sources from GitLab or Subversion to Azure Repos. There are multiple options available to you to do migrations like these.</p>
<p>The most likely event is that you will receive requests to move sources to one or more Azure Git repositories. Possible sources are other Git repositories, TFVC, or Subversion. There are tools and approaches available to do such a migration while retaining the history of changes in the original repository.</p>
<p>If there is no procedure available or you must import sources from another system, you can also fall back on creating a new, empty repository and initialize that with an existing code base. The disadvantage of this is that a<a id="_idTextAnchor096"/><a id="_idTextAnchor097"/><a id="_idTextAnchor098"/>ll history will be lost.</p>
<h3>Migrating existing Git repositories</h3>
<p>When it comes to<a id="_idIndexMarker292"/> migrating sources, moving to another location for <a id="_idIndexMarker293"/>hosting Git repositories is straightforward compared to other migrations. Let’s learn how to do this:</p>
<ol>
<li value="1">First, clone the existing repository to your local computer:<p class="source-code"><strong class="bold">git clone https://{organization}@dev.azure.com/{organization}/{teamProjec t}/_git/{repository} .</strong></p></li>
<li>Add another remote server that refers to the new, empty repository that you want to move the sources to:<p class="source-code"><strong class="bold">git remote add migrationTarget https://{organization}@dev.azure.com/{organization}/{teamProjec t}/_git/{newRepository}</strong></p></li>
<li>Finally, push the changes<a id="_idIndexMarker294"/> to this new repository. You must do this separately for every branch you want to move next to the master:<p class="source-code"><strong class="bold">git push migrationTarget master</strong></p></li>
</ol>
<p>Meanwhile, other developers might have continued to work with the existing repository.</p>
<ol>
<li value="4">To include those in the<a id="_idIndexMarker295"/> new repository as well, you must fetch them to your local computer from the original repository and then push them to the new repository. Again, repeat this for every branch:<p class="source-code"><strong class="bold">git fetch origin master</strong></p><p class="source-code"><strong class="bold">git push migrationTarget master</strong></p></li>
<li>Instruct all developers to start using the new remote repository. Subsequently, plan to decommission the original.</li>
<li>After a successful migration, it is often best to remove the old repository. This prevents anyone from continuing to work there accidentally.</li>
</ol>
<p>The preceding steps will work for any Git-to-Git migration.</p>
<p>Now, if you specifically want to migrate to an Azure Git repository, you can also use the <strong class="source-inline">Import</strong> functionality that is included with Azure DevOps. To do this, follow these steps:</p>
<ol>
<li value="1">Navigate to <strong class="bold">Repos</strong> and, optionally, create a new Git repository.</li>
<li>Choose to im<a id="_idTextAnchor099"/>port an existing repository.</li>
<li>Provide the requested information.</li>
<li>Click on <strong class="bold">Import</strong> to start importing the repository.</li>
</ol>
<p>The following screenshot illustrates these steps:</p>
<div>
<div class="IMG---Figure" id="_idContainer025">
<img alt="Figure 4.1 – Importing a repository " height="640" src="image/B18655_04_01.jpg" width="1135"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Importing a repository</p>
<p>The disadvantage of this<a id="_idIndexMarker296"/> approach is that you cannot keep pushing <a id="_idIndexMarker297"/>changes from the source repository to the new repository. This means that all other developers on your team must make sure that they move their changes over on<a id="_idTextAnchor100"/> their own or do not have any pending work whil<a id="_idTextAnchor101"/>e you migrate the repository.</p>
<h3>Migrating from TFVC to an Azure Git repository</h3>
<p>To migrate from <a id="_idIndexMarker298"/>TFVC to Git, you can<a id="_idIndexMarker299"/> use the same import repository <a id="_idIndexMarker300"/>as for moving from any Git repository to an Azure repository. This wizard can move the history of changes for the last 180 days when doing the import. If this is not enough and you are required to move more than 180 days’ worth of history to the <a id="_idIndexMarker301"/>new repository, there are other approaches you can use but they are more involved. Links to more <a id="_idIndexMarker302"/>detailed advice are included at the end of this chapter.</p>
<h3>Migrating from Subversion to an Azure Git repository</h3>
<p>A final type of request that<a id="_idIndexMarker303"/> you might receive is that of migrating from a Subversion repository to a Git repository. For this, there is no out-of-the-box<a id="_idIndexMarker304"/> solution from Microsoft <a id="_idIndexMarker305"/>available. However, Atlassian has created a tool that can be used to migrate a Subversion repository to a local Git repository while maintaining the changes history.</p>
<p>After running this tool, the only thing left to do is to add a remote repository to a new empty, hosted repository and push all of the branches. These are the<a id="_idTextAnchor102"/> same as the steps for migrating from Git to Git, starting at the st<a id="_idTextAnchor103"/>ep that adds a new remote repository.</p>
<h3>Migrating without retaining history</h3>
<p>If you are asked to do <a id="_idIndexMarker306"/>a migration without retaining history, you can just create a new, empty repository out of sources folder on your local computer and push existing changes there. </p>
<p>Execute the following commands from the directory that contains the files that should go into the <strong class="source-inline">master</strong> branch:</p>
<pre class="source-code">
git init 
git add
git commit -m “Initial import of existing sources”
git remote add https://{organization}@dev.azure.com/{organization}/{teamProject}/_git/{repository}
git push</pre>
<p>These commands initialize a new repository, create the first commit out of all of the files already in the directory, add a reference to the target server location, and push the newly created repository there.</p>
<p>If you want to retain <a id="_idIndexMarker307"/>multiple branches, you must repeat the following steps for every other branch:</p>
<ol>
<li value="1">First, go to the right directory for that branch:<p class="source-code"><strong class="bold">Git checkout {branchName}</strong></p></li>
<li>Now, copy the files that need to go into this branch into your working directory. Then, continue with the following co<a id="_idTextAnchor104"/>mmands:<p class="source-code"><strong class="bold">git add . </strong></p><p class="source-code"><strong class="bold">git commit </strong></p><p class="source-code"><strong class="bold">git push</strong></p></li>
</ol>
<p>This completes the migration, and the latest version of the sources you had on your local computer is now available in Git. Other<a id="_idTextAnchor105"/> members of your team can now clone the repository and work with it. Next, we’ll go o<a id="_idTextAnchor106"/>n to learn about branching and merging.</p>
<h1 id="_idParaDest-77"><a id="_idTextAnchor107"/>Selecting a branching and merging strategy</h1>
<p>Source control allows you to keep a history of all of the changes you have made to your files, and also allows working separately from your team members for a while if you so desire. We <a id="_idIndexMarker308"/>call this <strong class="bold">branching</strong>. When you are branching in source control, you <strong class="bold">fork</strong> the line of changes currently registered. We call <a id="_idIndexMarker309"/>such a fork a <strong class="bold">branch</strong>. A branch allows you to temporarily isolate some work from the rest. At any point, if you want to integrate the changes from a branch with the changes on the other fork, you can <strong class="bold">merge</strong> these changes back. Branches are often used for working on not-yet-complete features, proofs of concept, or hotfixes. Using branches allows you to later de<a id="_idTextAnchor108"/>cide which changes to incl<a id="_idTextAnchor109"/>ude in the next version and which not to.</p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor110"/>Branching strategies</h2>
<p>There are many<a id="_idIndexMarker310"/> branching strategies available, but the three most used nowadays are the following:</p>
<ul>
<li>GitHub Flow </li>
<li>GitFlow </li>
<li>Release Flow</li>
</ul>
<p>The following subsections will discuss these in greater detail.</p>
<p class="callout-heading">Tip</p>
<p class="callout">As an alternative to<a id="_idIndexMarker311"/> branching, trunk-based development is becoming more popular nowadays. To learn more about this, visit <a href="https://trunkbaseddevelopment.com/">https://trunkbaseddevelopment.com/</a>.</p>
<h3>GitHub Flow</h3>
<p>GitHub Flow is a simple, yet <a id="_idIndexMarker312"/>often sufficient, branching strategy. In GitHub Flow, there<a id="_idIndexMarker313"/> is one <strong class="bold">master</strong> branch that should always be in <a id="_idIndexMarker314"/>a deployable state. No unfinished cha<a id="_idTextAnchor111"/>nges are allowed to go onto the <strong class="source-inline">master</strong> branch.</p>
<p>If you want to start work on a new feature or bugfix, you need to create a new topic branch on the <strong class="source-inline">master</strong> branch where you commit your work. Only when you are completely done with that work should you merge this branch back to the <strong class="source-inline">master</strong> branch. An example commit flow might look like this:</p>
<div>
<div class="IMG---Figure" id="_idContainer026">
<img alt="Figure 4.2 – GitHub Flow " height="294" src="image/B18655_04_02.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – GitHub Flow</p>
<p>As this is the branching scheme with the lea<a id="_idTextAnchor112"/>st branches involved, this is probably a good strategy to start with.</p>
<p>Refer here for more<a id="_idIndexMarker315"/> information: <a href="https://www.geeksforgeeks.org/git-flow-vs-github-flow/">https://w<span id="_idTextAnchor113"/>ww.geeksforgeeks.org/git-flow-vs-github-flow/</a>.</p>
<h3>GitFlow</h3>
<p>GitFlow is another well-known, elaborate branching scheme, and can deal with almost any situation that <a id="_idIndexMarker316"/>might arise when working with software. GitFlow <a id="_idIndexMarker317"/>describes creating a <strong class="source-inline">develop</strong> branch of the <strong class="source-inline">master</strong> branch whenever you start work on a new version. <strong class="source-inline">develop</strong> is the integration branch where you combine new features and do integration testing. It should only contain work that you believe is ready to be released.</p>
<p>From <strong class="source-inline">develop</strong>, you can create one or more <strong class="source-inline">feature</strong> branches where you start working on new features. Only when a feature is done should you merge that branch back to the <strong class="source-inline">develop</strong> branch.</p>
<p>When you want to release a new version of your application, you create a <strong class="source-inline">release</strong> branch of the <strong class="source-inline">develop</strong> branch. You can perform final testing on the code on this branch, and perform one or more bug fixes if needed. When you are satisfied with the quality of the code, you can merge this branch with <strong class="source-inline">master</strong> and tag the version. You can also merge these bug fixes back to <strong class="source-inline">develop</strong>, so they will also be incorporated in new developments. This flow is visible in the following <a id="_idTextAnchor114"/>diagram:</p>
<div>
<div class="IMG---Figure" id="_idContainer027">
<img alt="Figure 4.3 – GitFlow branching model " height="277" src="image/B18655_04_03.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – GitFlow branching model</p>
<p>If there is ever a critical bug that you need to ship as fast as possible, or you want to do a hotfix, this is also possible using the GitFlow-based branching strategy. In that case, you can create a new branch of <strong class="source-inline">master</strong> on which you can fix the bug. After testing, you can merge<a id="_idTextAnchor115"/> this branch to both <strong class="source-inline">master</strong> and <strong class="source-inline">d<a id="_idTextAnchor116"/>evelop</strong>—just as you would with a <strong class="source-inline">release</strong> branch.</p>
<h3>Release Flow</h3>
<p><strong class="bold">Release Flow</strong> is the branching system that is used by the Azure DevOps team to develop Azure DevOps. It is <a id="_idIndexMarker318"/>also based on working with short-lived topic branches that are made from and merged into the <strong class="source-inline">master</strong> branch.</p>
<p>The difference is that it is <a id="_idIndexMarker319"/>not the code that is on the <strong class="source-inline">master</strong> branch that is deployed to production. Instead, whenever a new version of the product needs to be released, a new branch is created of <strong class="source-inline">master</strong> with the name <strong class="source-inline">release-{version}</strong>. The code from this branch is then deployed to production. Once a new <strong class="source-inline">release</strong> branch is deployed, the previous one can be disregarded. This results in the following flow:</p>
<div>
<div class="IMG---Figure" id="_idContainer028">
<img alt="Figure 4.4 – Release flow branching model " height="293" src="image/B18655_04_04.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Release flow branching model</p>
<p>The advantage of this model is that it allows for taking a snapshot of the current state of the <strong class="source-inline">master</strong> branch and taking that to production. If there is ever a bug in production that needs to be fixed ahead of a new complete releas<a id="_idTextAnchor117"/>e, then the necessary commits can be merged from <a id="_idTextAnchor118"/>the <strong class="source-inline">master</strong> branch to the current <strong class="source-inline">release</strong> branch.</p>
<h3>Trunk-based development</h3>
<p>In many companies, branching and merging are done to retain flexibility when releasing a new version of<a id="_idIndexMarker320"/> the software, and being able to <a id="_idIndexMarker321"/>cherry pick changes for a particular version only at the last moment. This flexibility comes at the cost of having to merge or integrate your changes at some point.</p>
<p>This cost is not only the time it takes but also the risks that a merge operation introduces. Merging the changes from two different branches that contain perfectly work<a id="_idTextAnchor119"/>ing software might still produce non-working code.</p>
<p>For this reason, you might consider switching to <strong class="bold">trunk-based development</strong>. In trunk-based development, you are no longer using branching for picking the changes that go into a version. Instead, every developer on the team continuously works from the same branch (often the <strong class="source-inline">master</strong> branch) and only creates a short-lived branch for preparing one single change, which is then<a id="_idIndexMarker322"/> merged into the <strong class="source-inline">master</strong> branch.</p>
<p class="callout-heading">Benefits of Trunk-Based Development</p>
<p class="callout">Trunk-based<a id="_idIndexMarker323"/> development facilitates increased agility for the development teams when releasing features to production. The features teams will develop features using temporary and short-lived <strong class="source-inline">features</strong> branches. The changes will be unit tested and verified in the development environment, and then subsequently pushed to the <strong class="source-inline">master</strong> branch using the Git <strong class="source-inline">PULL</strong> request feature. This is explained in the subsequent sections. </p>
<p class="callout">You can read<a id="_idIndexMarker324"/> more about trunk-based development here: <a href="https://trunkbaseddevelopment.com/">https://trunkbaseddevelopment.com/</a>.</p>
<p>When you <a id="_idIndexMarker325"/>adopt this, you will need another way to determine which changes will and won’t yet be available to your us<a id="_idTextAnchor120"/>ers when releasing a new version of your softwa<a id="_idTextAnchor121"/>re. You can do this by using <strong class="bold">branching by abstraction</strong>.</p>
<h3>Branching by abstraction</h3>
<p>When branching by abstraction, you do <a id="_idIndexMarker326"/>not keep two versions of your code side by side using branches, but you keep them side by side in your code<a id="_idIndexMarker327"/> base instead. For example, when you want to change the implementation of a class called <strong class="source-inline">FoodClassifier</strong>, which implements the <strong class="source-inline">IFoodClassifier</strong> interface, you go through the following steps:</p>
<ol>
<li value="1">Refactor the name of the <strong class="source-inline">FoodClassifier</strong> class to <strong class="source-inline">FoodClassifierToBeRemoved</strong>.</li>
<li>Create a copy of the complete <strong class="source-inline">FoodClassifierToBeRemoved</strong> class.</li>
<li>Change the name of this copy back to <strong class="source-inline">FoodClassifier</strong>.</li>
</ol>
<p>At this point, your changes should look like this:</p>
<p class="source-code"><strong class="bold">public class FoodClassifier : IFoodClassifier</strong></p>
<p class="source-code"><strong class="bold">{</strong></p>
<p class="source-code"><strong class="bold">public FoodClassification Classify(Food food)</strong></p>
<p class="source-code"><strong class="bold">{</strong></p>
<p class="source-code"><strong class="bold">// Unchanged classification algorithm</strong></p>
<p class="source-code"><strong class="bold">}</strong></p>
<p class="source-code"><strong class="bold">}</strong></p>
<p class="source-code"><strong class="bold">public class FoodClassifierToBeRemoved : IFoodClassifer</strong></p>
<p class="source-code"><strong class="bold">{</strong></p>
<p class="source-code"><strong class="bold">public FoodClassification Classif<a id="_idTextAnchor122"/>y(Food food)</strong></p>
<p class="source-code"><strong class="bold">{</strong></p>
<p class="source-code"><strong class="bold">// Unchanged classification algorithm</strong></p>
<p class="source-code"><strong class="bold">}</strong></p>
<p class="source-code"><strong class="bold">}</strong></p>
<p>Please note that at runtime, your application<a id="_idIndexMarker328"/> will behave just as it did before. You have just added a new, yet unused, class with a behavior change. It is safe to commit these changes and even ship the new binaries to a user. Now you can <a id="_idIndexMarker329"/>start changing the implementation of the new <strong class="source-inline">FoodClassifier</strong> class, test it, and establish trust in its implementation.</p>
<p>Meanwhile, you can keep committing and pushing your changes, even to customers. Switching to the new implementation can be done using your dependency injection configuration, a Boolean flag, or environment variables. Just choose what makes sense in your scenario.</p>
<p>Only when you are fully satisfied that the new implementation is working do you remove the <strong class="source-inline">FoodClassifierToBeRemoved</strong> class and update any references back to <strong class="source-inline">FoodClassifier</strong>.</p>
<p>We will expand on <a id="_idIndexMarker330"/>branching by abstraction in <a href="B18655_06.xhtml#_idTextAnchor330"><em class="italic">Chapter 6</em></a>, <em class="italic">Implementing Continuous Deployment and Release Management</em>, when discussing feature toggles. While being a recommended way forward to further accelerate your delivery, branching by abstraction is a double-edged sword. If you do not have a process to<a id="_idIndexMarker331"/> keep the number <a id="_idTextAnchor123"/>of side-by-side implementations under control and clean them up after switching i<a id="_idTextAnchor124"/>mplementations, the quality of your code base might decline.</p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor125"/>Merging strategies</h2>
<p>Depending on the<a id="_idIndexMarker332"/> source<a id="_idTextAnchor126"/> control system you are working with, there might be multipl<a id="_idTextAnchor127"/>e ways you can merge your changes from one branch to another.</p>
<h3>TFVC</h3>
<p>When you are working with<a id="_idIndexMarker333"/> TFVC, you can prepare a merge locally by choosing both a source and target branch and then picking the list of changes you <a id="_idIndexMarker334"/>want to merge. TFVC will then execute the merge and will show you the changes that are the consequence of this merge as <em class="italic">local</em> changes. Yo<a id="_idTextAnchor128"/>u can review, correct, or change these changes, and resolve any conflicts. After this, y<a id="_idTextAnchor129"/>ou can commit the changes just as you would any regular change.</p>
<h3>Git</h3>
<p>A merge using Git can be <a id="_idIndexMarker335"/>performed by switching to the target branch and then<a id="_idIndexMarker336"/> merging all of the changes from the source branch. If there are conflicting changes between the branches, you must resolve those just as you would when fetching new changes from the server. After merging the changes from the source branch and resolving any changes, you can commit the changes. This will result in a mer<a id="_idTextAnchor130"/>ge commit, which you push to the remote just as any other change.</p>
<p>The merge commit can be done using the visual interface of Visual Studio or VS Code, or by using the following sequence of commands:</p>
<pre class="source-code">
git checkout targetBranch 
git merge sourceBranch</pre>
<p>During the merge process, if there are any conflicts, you have to resolve these at this point. Otherwise, you cannot continue:</p>
<pre class="source-code">
git commit -m “Merged changes from sourceBranch” 
git push</pre>
<p>As you will read in the <em class="italic">Securing repositories</em> section, it is possible to protect some branches by disallowing merging this way. When it comes to merging changes to <strong class="source-inline">master</strong>, you might want to use another mechanism, namely, pull requests. Using a pull request, you can open a<a id="_idIndexMarker337"/> request for someone else to pull changes from your local branch to the target branch. This way, another team member can first review your changes and then <a id="_idIndexMarker338"/>merge them when they meet all agreed standards. Others can comment on your changes or request updates before they perform the merge. This is the most common way of enforcing the <em class="italic">four-eyes principle</em> for source code when working with Git. The <em class="italic">four-eyes principle</em> says that every change or action should be viewed by at least two people.</p>
<p>When you are approving a pull request, there are different strategies you can use for generating <a id="_idTextAnchor131"/>the merge commit. T<a id="_idTextAnchor132"/>he most commonly used are a merge commit, squash commit, or rebase.</p>
<h3>Merge commit</h3>
<p>A regular <strong class="bold">merge commit</strong> is a type of commit that maintains visibility of all previous commits. It has a reference to <a id="_idIndexMarker339"/>two parents, showing both origins <a id="_idIndexMarker340"/>of the change, namely the source and target branch. This is the same type of merge as you can perform manually using a Git merge. Th<a id="_idTextAnchor133"/>e advantage of this type of commit is that <a id="_idTextAnchor134"/>it clearly shows where the new state of the target branch comes from.</p>
<h3>Squash commit</h3>
<p>When performing a so-called <strong class="bold">squash commit</strong>, you are combining all of the individual commits from the source <a id="_idIndexMarker341"/>branch in one new commit. This is useful when all of<a id="_idIndexMarker342"/> the commits on the source branch relate to one feature and you want to keep a clear, concise change history on the target branch. This approach makes most sense when there are commits with bug fixes or clean-up operations on the source branch. The disadvantage is that you might lose the rati<a id="_idTextAnchor135"/><a id="_idTextAnchor136"/><a id="_idTextAnchor137"/>onale for some incremental changes that were made on the source branch.</p>
<h3>Rebase</h3>
<p><strong class="bold">Rebasing</strong> a branch means that all of the new commits or changes in your local branch that is not yet merged <a id="_idIndexMarker343"/>with the <strong class="source-inline">master</strong> branch are put aside for a bit. Meanwhile, all<a id="_idIndexMarker344"/> of the commits for which the <strong class="source-inline">master</strong> branch is ahead of your local branch are now merged into your local branch. Finally, all of your own commits that were set aside are now reapplied. The following diagram shows a branch before and after a rebase commit:</p>
<div>
<div class="IMG---Figure" id="_idContainer029">
<img alt="Figure 4.5 – Rebasing " height="194" src="image/B18655_04_05.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Rebasing</p>
<p>After rebasing the<a id="_idTextAnchor138"/> source branch, it is now merged into <strong class="source-inline">master</strong>. The advantage of this kind of merge<a id="_idTextAnchor139"/> is that you retain all individual changes in one single commit history.</p>
<h1 id="_idParaDest-80"><a id="_idTextAnchor140"/>Managing repositories</h1>
<p>When working in Azure <a id="_idIndexMarker345"/>Repos, every team project can have a maximum of one TFVC repository. However, when working with Git, you can have multiple repositories in the same team project. A discussion that is gaining more attention lately is that of having a single repository for all applications or a repository per application. Other topics that are important wh<a id="_idTextAnchor141"/>en managing repositories are creatin<a id="_idTextAnchor142"/>g and removing repositories, securing them, and setting policies on them.</p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor143"/>Monorepo or multi-repo</h2>
<p>You use a <strong class="bold">monolithic repository</strong> (<strong class="bold">monorepo</strong>) when you store all of the code from all of your projects and applications in one single source control repository. Contrary to this, you might use multiple repositories where every application, library, or project is stored in its <a id="_idIndexMarker346"/>own repository. Both<a id="_idIndexMarker347"/> approaches have their own pr<a id="_idTextAnchor144"/>os and cons, and both approaches are used by companies from small to large.</p>
<p>Possible advantages of a <a id="_idIndexMarker348"/>monorepo can include the following:</p>
<ul>
<li>Easier reuse of existing code: If all of the code is in a single repository, it is accessible and visible to everyone. This means that the chances of reuse are increased.</li>
<li>Having all applications in one repository also means that any change affecting more than one application can be made in a single commit in a single repository. A typical example is an API change.</li>
<li>With all of the code being accessible to and maintained by everyone, there is less chance that a developer or team claims a specific repository as its own. This encourages learning from each other.</li>
</ul>
<p>Disadvantages of<a id="_idIndexMarker349"/> mono repositories include the following:</p>
<ul>
<li>A monorepo can become very, very large, even up to the point that developers checkout or clone only part of the monorepo. This effectively defeats most of the advantages of a monorepo.</li>
<li>Having one repository with all of the code encourages tight coupling between components or applications. If you have multiple repositories, you could update an API and release it under a new version and upgrade clients one by one. In a monorepo, you might be tempted to upgrade the API and change all of the consumers in one commit, with all of the risks attached.</li>
</ul>
<p>Which approach<a id="_idIndexMarker350"/> works best for you is influenced not only by the advantages and disadvantages discussed but also by the background and makeup of your team and organization. If you have a single team doing all the development for internal applications, a m<a id="_idTextAnchor145"/>onorepo might make more sense. If you have multiple teams working on differ<a id="_idTextAnchor146"/>ent applications for different clients, multiple repositories make more sense.</p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor147"/>Creating and removing repositories</h2>
<p>In Azure DevOps, you <a id="_idIndexMarker351"/>can have multiple Git repositories per team project. Try doing the following:</p>
<ol>
<li value="1">First, visit the <strong class="bold">Manage repositories</strong> interface. The following scree<a id="_idTextAnchor148"/>nshot shows how to access this interface:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer030">
<img alt="Figure 4.6 – Managing repositories " height="410" src="image/B18655_04_06.jpg" width="1256"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – Managing repositories</p>
<ol>
<li value="2">After opening this interface, a new interface (as shown in the following screenshot) opens up. Here, you can add new repositories by clicking on the <strong class="bold">Add...</strong> button with a plus sign ( refer to the vertical section next to the left navigation menu) and filling out a repository name.</li>
<li>Repositories can also be removed by clicking on their name and then <strong class="bold">Delete repositor<a id="_idTextAnchor149"/>y</strong> (marked with <strong class="bold">2</strong>; refer to the context menu shown for the repository name):</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer031">
<img alt="Figure 4.7 – Deleting a repository " height="656" src="image/B18655_04_07.jpg" width="1256"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – Deleting a repository</p>
<p>Removing repositories is<a id="_idIndexMarker352"/> not something that is often done. It might make more sense to <a id="_idTextAnchor150"/>make a no-longer-used repository read-only or remove all authori<a id="_idTextAnchor151"/>zations on it.</p>
<p>Now, let’s learn how to secure the repositories that we create.</p>
<h2 id="_idParaDest-83"><a id="_idTextAnchor152"/>Securing repositories</h2>
<p>While the security <a id="_idIndexMarker353"/>options with distributed source control are often not as broad as with centralized source control, Azure Repos offers some means to set authorizations on a repository or a server-side branch. In the last figure of the previous section, you can also see how you can select a group or user in the middle column and then update the authorizations on the repository. By default, all authorizations are inherited from project defaults.</p>
<p class="callout-heading">Tip</p>
<p class="callout">It is recommended to only change authorizations as little as possible and if you do, it is often best to work via groups and allow authorizations.</p>
<p>You can also change <a id="_idIndexMarker354"/>the authorizations for a specific branch by opening the repository <a id="_idTextAnchor153"/>branches in the drop-down menu on the left and clicking on the branch you want to override the authorizations for. In the preceding screenshot, this is ma<a id="_idTextAnchor154"/>rked with <strong class="bold">3</strong>; refer to the expansion of the <strong class="source-inline">HenryBreen.RazorAnalysers</strong> repository.</p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor155"/>Branch policies</h2>
<p>Finally, it is possible to <a id="_idIndexMarker355"/>enforce one or more policies on pull requests to <a id="_idIndexMarker356"/>a specific branch. The interface for branch policies is shown in the following screenshot and can be accessed by choosing the <strong class="bold">Branch policies</strong> option while managing the authorizations on a repository branch:</p>
<div>
<div class="IMG---Figure" id="_idContainer032">
<img alt="Figure 4.8 – Branch policies " height="780" src="image/B18655_04_08.jpg" width="825"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8 – Branch policies</p>
<p>The first four checkboxes are related to default policies that can be enabled (or not) on your preference. By default, they are all disabled.</p>
<p><strong class="bold">Build validation</strong> can be<a id="_idIndexMarker357"/> used to disallow the merge of any pull request if one or more of the select builds have not been completed success<a id="_idTextAnchor156"/>fully. How to set up such a build is something you will learn in the next chapter.</p>
<p>Next to builds, you can also<a id="_idIndexMarker358"/> call external services to inspect the pull request and to allow or disallow it. An often used integration here is with a code quality tool. You might also call your own APIs here to enforce team agreements on things such as pull request titles, relation to work items, or more complex constraints.</p>
<p>Finally, you can enforce that a specific user or group has to be included in the review of a pull request<a id="_idTextAnchor157"/>. This might be needed to enforce a specific level o<a id="_idTextAnchor158"/>f quality, but it can also be a limiting factor in your development speed and flow.</p>
<h1 id="_idParaDest-85"><a id="_idTextAnchor159"/>Other tools for source control</h1>
<p>Next to the source<a id="_idIndexMarker359"/> control systems available in Azure Repos, there are also <a id="_idTextAnchor160"/>some other well-known systems that you should know about:<a id="_idTextAnchor161"/></p>
<ul>
<li>GitHub </li>
<li>GitLab </li>
<li>Subversion</li>
</ul>
<p>We’ll go over each of these in the upcoming subsections.</p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor162"/>GitHub</h2>
<p><strong class="bold">GitHub</strong> is a hosted source control provider that delivers hosted Git repositories. GitHub allows anyone to create as <a id="_idIndexMarker360"/>many publicly visible repositories as they want. When <a id="_idIndexMarker361"/>you create private repositories that require three or more contributors, you must switch to a paid subscription.</p>
<p>This model allows unlimited free usage of the platform if developing in public, which has made GitHub by far the largest host of open source software in the world.</p>
<p>GitHub was acquired by Microsoft in 2018 and since then, Microsoft and GitHub have worked together to create a great integration experience between GitHub repositories and Azure DevOps, specifically with Azure Boards and Azure Pipelines. In addition to this, Microsoft has stated that<a id="_idIndexMarker362"/> GitHub and Azure Repos will continue to exist next to each other and that there are currently no plans to terminate one of the products in favor of the other.</p>
<p>There is also an enterprise offering by <a id="_idIndexMarker363"/>GitHub called GitHub Enterprise, which comes with two deployment options, namely cloud-hosted and self-hosted (or on-premises).</p>
<p>You can read more<a id="_idIndexMarker364"/> about the various GitHub products and pricing plans here: <a href="https://docs.github.com/en/get-started/learning-about-github/githubs-products">https://docs.github.com/en/get-started/learning-about-github/githubs-products</a>. </p>
<p>The public roa<a id="_idTextAnchor163"/><a id="_idTextAnchor164"/><a id="_idTextAnchor165"/>dmap for GitHub can be viewed here: <a href="https://github.com/orgs/github/projects/4247/views/1">https://github.com/orgs/github/projects/4247/views/1</a>.</p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor166"/>GitLab</h2>
<p><a id="_idTextAnchor167"/>GitLab is another <a id="_idIndexMarker365"/>platform that delivers hosted Git reposi<a id="_idTextAnchor168"/>tories. Just like Azure DevOps, source control hosting is one <a id="_idIndexMarker366"/>of the services it provides.</p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor169"/>Subversion</h2>
<p>An older source control <a id="_idIndexMarker367"/>system is Subversion. Subversion was developed and first used in 2004 and is maintained by the Apache Software Foundation. Subversion is a centralized<a id="_idIndexMarker368"/> source control system that supports all the features that you would expect of such a system.</p>
<p>There are many false arguments as to why Subversion would be inferior to Git; however, most of them are not true for more recent versions of Subversion. The reality is that Subversion is a widely used type of source control system that performs well, especially for very large repositories, or repositories that have very specific authorization needs.</p>
<p>While Azure DevOps cannot host Su<a id="_idTextAnchor170"/>bversion repositories, it can connect to and work with sources that are stored in Subversion.</p>
<h1 id="_idParaDest-89"><a id="_idTextAnchor171"/>Summary</h1>
<p>In this chapter, you have learned about source control. You saw that there are two types of source control: centralized and decentralized, both supported by Azure DevOps. TFVC is no longer recommended for new projects. You should use Git whenever starting a new project.</p>
<p>When using Git, you can have more than one repository in your team project. For each repository, you can assign policies to lock down specific branches and enforce the four-eyes principle. You have also learned about access control, and how to provide users access to one or more repositories. Finally, you have learned about alternative tools, and how to migrate sources from one tool to the other.</p>
<p>You can use what you have learned to make decisions on which type of source control system to use in your products. You can now professionally organize the repository or repositories you work in. You are now able to work with different branching strategies and use policies for enforcing security or quality requirements.</p>
<p>The next chapter will t<a id="_idTextAnchor172"/>ake what you have learned about source control and use that to set up continuous integration.</p>
<h1 id="_idParaDest-90"><a id="_idTextAnchor173"/>Questions</h1>
<p>As we conclude, here is a list of questions for you to test your knowledge regarding this chapter’s material. You will find the answers in the <em class="italic">Assessments</em> section of the <em class="italic">Appendix</em>:</p>
<ol>
<li value="1">What are the differences between centralized and decentralized source control, and which works best in what situation?</li>
<li>True or false? Git is an example of decentralized source control.</li>
<li>Which of the following is not a common branching strategy?<ol><li>Release Flow</li><li>Rebasing</li><li>GitFlow</li><li>GitHub Flow</li></ol></li>
<li>Many companies want a code review to be performed before code is merged into the <strong class="source-inline">master</strong> branch. What construct is used to do so when working with Git, and how can this be enforced in Azure DevOps?</li>
<li>Which of the following are not valid merge strategies?<ol><li>Rebasing</li><li>Trunk-based development</li><li>Merge commit</li><li>Squash commit</li></ol></li>
</ol>
<h1 id="_idParaDest-91"><a id="_idTextAnchor174"/>Exercises</h1>
<ul>
<li>Prerequisite reading: <a href="https://docs.microsoft.com/en-us/azure/devops/boards/best-practices-agile-project-management%20">https://docs.microsoft.com/en-us/azure/devops/boards/best-practices-agile-project-management.</a></li>
<li>Create your first team project, and name it <strong class="source-inline">PacktBookLibrary</strong>. Apply other settings as per the following screenshot:</li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer033">
<img alt="Figure 4.9 – Create a new team project " height="1069" src="image/B18655_04_09.jpg" width="1222"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9 – Create a new team project</p>
<ul>
<li>Once the <strong class="source-inline">PacktBookLibrary</strong> team project has been created, using the left navigation, go to <strong class="bold">Boards</strong> | <strong class="bold">Queries</strong>. Create a new query with filter options as defined in the following screenshot, and save it as <strong class="source-inline">Product-Backlog</strong> within <strong class="bold">My Queries</strong>. Note that it should show you a tree of work items starting with <strong class="bold">Epic</strong> items as the parent work item entry in the listview. The objective here is to visualize the breakdown of the entire <strong class="source-inline">Product-Backlog</strong> query in a hierarchical manner:</li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer034">
<img alt="Figure 4.10 – Query editor " height="618" src="image/B18655_04_10.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10 – Query editor</p>
<ul>
<li>Using the <strong class="bold">Column options</strong> section within the <strong class="bold">Editor</strong> view, choose columns (Stack Rank, .. ) and <strong class="bold">Sorting</strong> on <strong class="bold">Stack Rank</strong>:<div class="IMG---Figure" id="_idContainer035"><img alt="Figure 4.11 – Add columns and apply sorting " height="789" src="image/B18655_04_11.jpg" width="881"/></div></li>
</ul>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.11 – Add columns and apply sorting</p>
<ul>
<li>Add an initial Product Backlog (Epics and Features) as shown in the following screenshot:</li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer036">
<img alt="Figure 4.12 – DevOps feature list " height="538" src="image/B18655_04_12.jpg" width="888"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.12 – DevOps feature list</p>
<p>The goal here is to track the implementation of the important DevOps practices through the same product backlog so that those are included during the work planning and prioritization process. Eventually, it is the same set of team members who will work on implementing these practices as well.</p>
<ul>
<li>You can either configure a new Git repository to start adding your code or import code from an existing Git repository. The starter code for the <strong class="source-inline">PacktBookLibrary</strong> solution is available here: https://github.com/PacktPublishing/Exam-Guide-AZ-400-Designing-and-Implementing-Microsoft-DevOps-Solutions.</li>
</ul>
<p>The dialog in the following screenshot is shown when you import an existing repository:</p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
<div>
<div class="IMG---Figure" id="_idContainer037">
<img alt="Figure 4.13 – Import a Git repository " height="488" src="image/B18655_04_13.jpg" width="1200"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.13 – Import a Git repository</p>
<ul>
<li>Once the code has been imported, you should be able to view the code files within the repository.</li>
<li>Configure branch policies for the <strong class="source-inline">main</strong> branch in the repository within the following settings:<ul><li>Turn on (use the toggle button) <strong class="bold">Require minimum number of reviewers</strong>. Set the minimum reviewer count as <strong class="bold">1</strong>.</li><li>Turn on (use the toggle button) <strong class="bold">Check for linked work items</strong> to <strong class="bold">Required</strong>.</li></ul></li>
<li>Turn on <strong class="bold">Limit merge types</strong>. Select <strong class="bold">Squash merge</strong> as the only option from the allowed merge types list.</li>
<li>Clone the <strong class="source-inline">PacktBookLibrary</strong> repository (the <strong class="source-inline">main</strong> branch) to a local folder within your workstation.</li>
<li>Check out the source code by creating a branch off <strong class="source-inline">main</strong>, and then start using it for making commits. Periodically plan to raise a <strong class="source-inline">PULL</strong> request to merge your changes with the <strong class="source-inline">main</strong> branch.</li>
</ul>
<p>After completing the steps mentioned in the exercise list, your source control repository wi<a id="_idTextAnchor175"/>ll be set up. We will build upon this foundation in the next chapters through exercises.</p>
<h1 id="_idParaDest-92"><a id="_idTextAnchor176"/>Further reading</h1>
<ul>
<li>More information about working with Git can be found at <a href="https://docs.microsoft.com/en-us/learn/paths/intro-to-vc-git/">https://docs.microsoft.com/en-us/learn/paths/intro-to-vc-git/</a>.</li>
<li>The original Microsoft advice on TFVC versus Git can be found at <a href="https://docs.microsoft.com/en-us/azure/devops/repos/tfvc/comparison-git-tfvc?view=azure-devopsviewFallbackFrom=vsts">https://docs.microsoft.com/en-us/azure/devops/repos/tfvc/comparison-git-tfvc?view=azure-devopsviewFallbackFrom=vsts</a>.</li>
<li>More information about Git LFS can be found at <a href="https://docs.microsoft.com/en-us/azure/devops/repos/git/manage-large-files?view=azure-devops">https://docs.microsoft.com/en-us/azure/devops/repos/git/manage-large-files?view=azure-devops</a>.</li>
<li>Instructions for downloading Git LFS can be found at <a href="https://git-lfs.github.com/">https://git-lfs.github.com/</a>.</li>
<li>More information about migrating to Git can be found at <a href="https://docs.microsoft.com/en-us/azure/devops/repos/git/import-from-TFVC?view=azure-devops">https://docs.microsoft.com/en-us/azure/devops/repos/git/import-from-TFVC?view=azure-devops</a>.</li>
<li>An Atlassian tool for converting an SVN repository to a local Git repository can be found at <a href="https://www.atlassian.com/git/tutorials/migrating-convert">https://www.atlassian.com/git/tutorials/migrating-convert</a>. </li>
<li>More information about GitFlow can be found at <a href="https://datasift.github.io/gitflow/IntroducingGitFlow.xhtml">https://datasift.github.io/gitflow/IntroducingGitFlow.xhtml</a>.</li>
<li>More information about GitHub Flow can be found at <a href="https://guides.github.com/introduction/flow/">https://guides.github.com/introduction/flow/</a>.</li>
<li>Release Flow is described in more detail at <a href="https://docs.microsoft.com/en-us/azure/devops/learn/devops-at-microsoft/release-flow">https://docs.microsoft.com/en-us/azure/devops/learn/devops-at-microsoft/release-flow</a>.</li>
<li>Trunk-based development is discussed at <a href="https://trunkbaseddevelopment.com/">https://trunkbaseddevelopment.com/</a>.</li>
<li>More information about GitLab can be found at <a href="https://about.gitlab.com/">https://about.gitlab.com/</a>. </li>
<li>More information about Subversion can be found at <a href="https://subversion.apache.org/docs/">https://subversion.apache.org/docs/</a>.</li>
</ul>
</div>
</div></body></html>