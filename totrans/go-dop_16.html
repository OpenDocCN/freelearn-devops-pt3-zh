<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer062">
			<h1 id="_idParaDest-289"><a id="_idTextAnchor645"/>Chapter <a id="_idTextAnchor646"/>13: Infrastructure as Code with Terraform</h1>
			<p><strong class="bold">Infrastructure as Code</strong> (<strong class="bold">IaC</strong>) is the practice of provisioning computing infrastructure using machine-readable, declarative specifications or imperative code, rather than using an interactive configuration tool. IaC became increasingly popular with the rise of cloud computing. Infrastructure administrators who were previously maintaining long-lived infrastructure found themselves needing to scale in both agility and capacity as companies adopted cloud infrastructure. </p>
			<p>Remember that at this time, software teams and infrastructure teams were unlikely to work closely together until a software project needed to be deployed. IaC created a bridge between infrastructure administrators and software developers by establishing a shared set of documents that described the desired infrastructure for the software project. The IaC specifications or code often live within or alongside the project. By establishing this shared context between software developers and infrastructure administrators, these two teams were able to work together earlier in the software development life cycle and establish a shared vision for infrastructure.</p>
			<p>In this chapter, we'll start off by learning about how Terraform approaches IaC and the basics of its usage. After we have a handle on how Terraform works, we'll discuss Terraform providers and see how the vast ecosystem of providers can empower us to describe and provision a wide variety of resources, not just compute infrastructure such as virtual machines. Finally, we'll learn how to extend Terraform by building our own pet store Terraform provider.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>An introduction to IaC</li>
				<li>Understanding the basics of Terraform</li>
				<li>Understanding the basics of Terraform providers</li>
				<li>Building a pet store Terraform provider</li>
			</ul>
			<h1 id="_idParaDest-290"><a id="_idTextAnchor647"/>Technical requirements</h1>
			<p>In this chapter, you will need to have the following:</p>
			<ul>
				<li>Docker</li>
				<li>Git</li>
				<li>Go</li>
				<li>The Terraform CLI: <a href="https://learn.hashicorp.com/tutorials/terraform/install-cli">https://learn.hashicorp.com/tutorials/terraform/install-cli</a></li>
				<li>The Azure CLI: <a href="https://docs.microsoft.com/en-us/cli/azure/install-azure-cli">https://docs.microsoft.com/en-us/cli/azure/install-azure-cli</a></li>
				<li>The code for this chapter: <a href="https://github.com/PacktPublishing/Go-for-DevOps/tree/main/chapter/13/petstore-provider">https://github.com/PacktPublishing/Go-for-DevOps/tree/main/chapter/13/petstore-provider</a></li>
			</ul>
			<p>Let's get started by learning some Terraform basics.</p>
			<p>The code files for this chapter can be downloaded from <a href="https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/13/petstore-provider">https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/13/petstore-provider</a></p>
			<h1 id="_idParaDest-291"><a id="_idTextAnchor648"/>An introduction to IaC</h1>
			<p>IaC had a significant impact beyond bringing infrastructure and software development teams together; the practice also made it much easier and safer to deploy infrastructure for projects. By defining the <a id="_idIndexMarker1244"/>infrastructure and storing the specifications in a software project, the infrastructure code could be tested in the same way that the software project was tested. As with testing code, consistently testing infrastructure code reduces bugs, surfaces inefficiencies, and increases confidence in the infrastructure deployment process.</p>
			<p>We take it for granted today, but in many organizations, working with infrastructure administrators to build a cluster for a non-trivial application could take weeks. Taking that same experience, condensing it into a handful of files, and then being able to deploy a cluster in minutes was a game changer.</p>
			<p>There are many IaC tools available. Each has its own flavor for how the tool approaches the problem of describing and provisioning infrastructure. Though they are all a bit different, each tool can be categorized using a couple of facets, by how the code is specified by the author, and by how it deals with changes to code. The foremost category is how the infrastructure code is specified. Specifically, the code is a declarative specification describing the desired state (what to provision), or the code is a set of imperative steps described in a programming language (how to provision). The second category is how the tool applies the infrastructure, push or pull. Pull IaC tools watch for changes to code in a centralized repository. Push IaC tools apply their changes to the destination system.</p>
			<p>IaC is a critical practice in bridging the gap between writing, delivering, and operating software. It is one of <a id="_idIndexMarker1245"/>the key areas where development overlaps with operations. Mastering the practice will better enable your team to deliver software faster with greater agility and reliability<a id="_idTextAnchor649"/>.</p>
			<h1 id="_idParaDest-292"><a id="_idTextAnchor650"/>Understanding the basics of Terraform</h1>
			<p><strong class="bold">Terraform</strong> (<a href="https://www.terraform.io/">https://www.terraform.io/</a>) is an open source IaC tool written in Go and created by HashiCorp that <a id="_idIndexMarker1246"/>provides a consistent command-line experience for managing a wide variety of resources. With Terraform, infrastructure engineers define the <a id="_idIndexMarker1247"/>desired state of a set of hierarchical resources using declarative Terraform configuration files or with imperative code (<a href="https://www.terraform.io/cdktf">https://www.terraform.io/cdktf</a>), which results in Terraform configurations files. These configuration files are the code in IaC. They can be used to manage the full life cycle of creating, mutating, and destroying resources, plan and predict changes to resources, provide a graph of dependencies in complex resource topologies, and store the last observed state of a system.</p>
			<p>Terraform is simple to get started and has a fairly linear learning curve. There are many features of Terraform we will not cover in this chapter that will be useful as you deepen your adoption of the tool. The goal of this chapter is not to become an expert with Terraform but rather to show you how to get started and be effective quickly.</p>
			<p>In this section, you will learn the basics of how Terraform operates, and how to use the Terraform CLI. We'll start off with a simple example and discuss what happens at execution time. By the end of the section, you should feel comfortable defining resources, initializing, and applying using the Terraform C<a id="_idTextAnchor651"/>LI.</p>
			<h2 id="_idParaDest-293"><a id="_idTextAnchor652"/>Initializing and applying infrastructure specs using Terraform</h2>
			<p>In the first <a id="_idIndexMarker1248"/>part of this section, we will discuss <a id="_idIndexMarker1249"/>resources rather than infrastructure <a id="_idIndexMarker1250"/>components. Discussing <a id="_idIndexMarker1251"/>resources and components is rather abstract. Let's use a concrete example to explain the normal flow of actions with Terraform.</p>
			<p>For our first example, we will use a directory structured like the following:</p>
			<p class="source-code">.</p>
			<p class="source-code">├── main.tf</p>
			<p>In the preceding block, we have a directory with a single <strong class="source-inline">main.tf</strong> file. In that file, we will add the following content:</p>
			<p class="source-code">resource "local_file" "foo" {</p>
			<p class="source-code">    content  = "foo!"</p>
			<p class="source-code">    filename = "${path.module}/foo.txt"</p>
			<p class="source-code">}</p>
			<p>In the preceding Terraform <strong class="source-inline">main.tf</strong> configuration file, we define a <strong class="source-inline">local_file</strong> resource named <strong class="source-inline">foo</strong> with the <strong class="source-inline">foo!</strong> content located at <strong class="source-inline">${path.module}/foo.txt. ${path.module}</strong> is the filesystem path of the module, in this case, <strong class="source-inline">./foo.txt</strong>.</p>
			<p>We can simply run the following to initialize Terraform in the directory and apply the desired state:</p>
			<p class="source-code">$ terraform init &amp;&amp; terraform apply</p>
			<p>The preceding <strong class="source-inline">terraform init</strong> command will check the validity of <strong class="source-inline">main.tf</strong>, pull down the providers needed, and initialize the local state of the project. After the <strong class="source-inline">init</strong> command is <a id="_idIndexMarker1252"/>executed, the <strong class="source-inline">apply</strong> command <a id="_idIndexMarker1253"/>will be executed. We'll <a id="_idIndexMarker1254"/>break these down into two <a id="_idIndexMarker1255"/>parts, <strong class="source-inline">init</strong> and then <strong class="source-inline">apply</strong>. The <strong class="source-inline">init</strong> command should output the following:</p>
			<p class="source-code">$ terraform init &amp;&amp; terraform apply</p>
			<p class="source-code">Initializing the backend...</p>
			<p class="source-code">Initializing provider plugins...</p>
			<p class="source-code">- Finding latest version of hashicorp/local...</p>
			<p class="source-code">- Installing hashicorp/local v2.2.2...</p>
			<p class="source-code">- Installed hashicorp/local v2.2.2 (signed by HashiCorp)</p>
			<p class="source-code">Terraform has created a lock file .terraform.lock.hcl to record the provider</p>
			<p class="source-code">selections it made preceding. Include this file in your version control repository</p>
			<p class="source-code">so that Terraform can guarantee to make the same selections by default when</p>
			<p class="source-code">you run "terraform init" in the future.</p>
			<p class="source-code">Terraform has been successfully initialized!</p>
			<p class="source-code">You may now begin working with Terraform. Try running "terraform plan" to see</p>
			<p class="source-code">any changes that are required for your infrastructure. All Terraform commands</p>
			<p class="source-code">should now work.</p>
			<p class="source-code">If you ever set or change modules or backend configuration for Terraform,</p>
			<p class="source-code">rerun this command to reinitialize your working directory. If you forget, other</p>
			<p class="source-code">commands will detect it and remind you to do so if necessary.</p>
			<p>As you can see from the preceding output, Terraform installed the <strong class="source-inline">hashicorp/local</strong> provider at a specific version. Terraform then saved the version to a local lock file, <strong class="source-inline">.terraform.lock.hcl</strong>, to ensure that the same version is used in the future, establishing the information needed to have a reproducible build. Finally, Terraform <a id="_idIndexMarker1256"/>provides instructions for using <strong class="source-inline">terraform plan</strong> to <a id="_idIndexMarker1257"/>see what <a id="_idIndexMarker1258"/>Terraform will do to reach <a id="_idIndexMarker1259"/>the desired state described in <strong class="source-inline">main.tf</strong>.</p>
			<p>After initialization, running <strong class="source-inline">terraform apply</strong> will trigger Terraform to determine the current desired state and compare it to the known state of the resources in <strong class="source-inline">main.tf</strong>. <strong class="source-inline">terraform apply</strong> presents the operator with a plan of the operations that will be executed. Upon operator approval of the plan, Terraform executes the plan and stores the updated state of the resources. Let's see the output from <strong class="source-inline">terraform apply</strong>:</p>
			<p class="source-code">Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:</p>
			<p class="source-code">  + create</p>
			<p class="source-code">Terraform will perform the following actions:</p>
			<p class="source-code">  # local_file.foo will be created</p>
			<p class="source-code">  + resource "local_file" "foo" {</p>
			<p class="source-code">      + content              = "foo!"</p>
			<p class="source-code">      + directory_permission = "0777"</p>
			<p class="source-code">      + file_permission      = "0777"</p>
			<p class="source-code">      + filename             = "./foo.txt"</p>
			<p class="source-code">      + id                   = (known after apply)</p>
			<p class="source-code">    }</p>
			<p class="source-code">Plan: 1 to add, 0 to change, 0 to destroy.</p>
			<p class="source-code">Do you want to perform these actions?</p>
			<p class="source-code">  Terraform will perform the actions described preceding.</p>
			<p class="source-code">  Only 'yes' will be accepted to approve.</p>
			<p class="source-code">  Enter a value: yes</p>
			<p class="source-code">local_file.foo: Creating...</p>
			<p class="source-code">local_file.foo: Creation complete after 0s [id=4bf3e335199107182c6f7638efaad377acc7f452]</p>
			<p class="source-code">Apply complete! Resources: 1 added, 0 changed, 0 destroyed.</p>
			<p>After <a id="_idIndexMarker1260"/>confirming the plan by entering <strong class="source-inline">yes</strong>, Terraform <a id="_idIndexMarker1261"/>has applied <a id="_idIndexMarker1262"/>the desired state and created the <a id="_idIndexMarker1263"/>resource, a local file. The directory should look like the following:</p>
			<p class="source-code">.</p>
			<p class="source-code">├── .terraform</p>
			<p class="source-code">│   └── providers</p>
			<p class="source-code">│       └── registry.terraform.io</p>
			<p class="source-code">│           └── hashicorp</p>
			<p class="source-code">│               └── local</p>
			<p class="source-code">│                   └── 2.2.2</p>
			<p class="source-code">│                       └── darwin_arm64</p>
			<p class="source-code">│                           └── terraform-provider-local_v2.2.2_x5</p>
			<p class="source-code">├── .terraform.lock.hcl</p>
			<p class="source-code">├── foo.txt</p>
			<p class="source-code">├── main.tf</p>
			<p class="source-code">└── terraform.tfstate</p>
			<p>In the <a id="_idIndexMarker1264"/>preceding directory structure, we <a id="_idIndexMarker1265"/>can see the local provider <a id="_idIndexMarker1266"/>that Terraform used to provision <a id="_idIndexMarker1267"/>the file, the Terraform lock file, the <strong class="source-inline">foo.txt</strong> file, and a <strong class="source-inline">terraform.tfstate</strong> file. Let's explore <strong class="source-inline">foo.txt</strong> and the <strong class="source-inline">terraform.tfstate</strong> files:</p>
			<p class="source-code">$ cat foo.txt</p>
			<p class="source-code">foo!</p>
			<p>As we described in <strong class="source-inline">main.tf</strong>, Terraform has created <strong class="source-inline">foo.txt</strong> with the <strong class="source-inline">foo!</strong> content. Next, let's look at <strong class="source-inline">terraform.tfstate</strong>:</p>
			<p class="source-code">$ cat terraform.tfstate</p>
			<p class="source-code">{</p>
			<p class="source-code">  "version": 4,</p>
			<p class="source-code">  "terraform_version": "1.1.7",</p>
			<p class="source-code">  "serial": 1,</p>
			<p class="source-code">  "lineage": "384e96a1-5878-ed22-5368-9795a3231a00",</p>
			<p class="source-code">  "outputs": {},</p>
			<p class="source-code">  "resources": [</p>
			<p class="source-code">    {</p>
			<p class="source-code">      "mode": "managed",</p>
			<p class="source-code">      "type": "local_file",</p>
			<p class="source-code">      "name": "foo",</p>
			<p class="source-code">      "provider": "provider[\"registry.terraform.io/hashicorp/local\"]",</p>
			<p class="source-code">      "instances": [</p>
			<p class="source-code">        {</p>
			<p class="source-code">          "schema_version": 0,</p>
			<p class="source-code">          "attributes": {</p>
			<p class="source-code">            "content": "foo!",</p>
			<p class="source-code">            "content_base64": null,</p>
			<p class="source-code">            "directory_permission": "0777",</p>
			<p class="source-code">            "file_permission": "0777",</p>
			<p class="source-code">            "filename": "./foo.txt",</p>
			<p class="source-code">            "id": "4bf3e335199107182c6f7638efaad377acc7f452",</p>
			<p class="source-code">            "sensitive_content": null,</p>
			<p class="source-code">            "source": null</p>
			<p class="source-code">          },</p>
			<p class="source-code">          "sensitive_attributes": [],</p>
			<p class="source-code">          "private": "bnVsbA=="</p>
			<p class="source-code">        }</p>
			<p class="source-code">      ]</p>
			<p class="source-code">    }</p>
			<p class="source-code">  ]</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">terraform.tfstate</strong> file is a bit more interesting than <strong class="source-inline">foo.txt</strong>. The <strong class="source-inline">tfstate</strong> file is where Terraform stores its last known state for the resources applied in the plan. This <a id="_idIndexMarker1268"/>enables Terraform to inspect the <a id="_idIndexMarker1269"/>differences with the last known <a id="_idIndexMarker1270"/>state and build a plan for updating <a id="_idIndexMarker1271"/>the resource if the desired state changes in the future. </p>
			<p>Next, let's change the desired state in <strong class="source-inline">main.tf</strong> and see what happens when we apply the configuration again. Let's update <strong class="source-inline">main.tf</strong> to the following:</p>
			<p class="source-code">resource "local_file" "foo" {</p>
			<p class="source-code">    content  = "foo changed!"</p>
			<p class="source-code">    filename = "${path.module}/foo.txt"</p>
			<p class="source-code">    file_permissions = "0644"</p>
			<p class="source-code">}</p>
			<p>Note that we've changed the content of <strong class="source-inline">foo.txt</strong> and added file permissions to the resource. Now, let's apply the desired state and see what happens:</p>
			<p class="source-code">$ terraform apply -auto-approve</p>
			<p class="source-code">local_file.foo: Refreshing state... [id=4bf3e335199107182c6f7638efaad377acc7f452]</p>
			<p class="source-code">Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:</p>
			<p class="source-code">-/+ destroy and then create replacement</p>
			<p class="source-code">Terraform will perform the following actions:</p>
			<p class="source-code">  # local_file.foo must be replaced</p>
			<p class="source-code">-/+ resource "local_file" "foo" {</p>
			<p class="source-code">      ~ content              = "foo!" -&gt; "foo changed!" # forces replacement</p>
			<p class="source-code">      ~ file_permission      = "0777" -&gt; "0644" # forces replacement</p>
			<p class="source-code">      ~ id                   = "4bf3e335199107182c6f7638efaad377acc7f452" -&gt; (known after apply)</p>
			<p class="source-code">        # (2 unchanged attributes hidden)</p>
			<p class="source-code">    }</p>
			<p class="source-code">Plan: 1 to add, 0 to change, 1 to destroy.</p>
			<p class="source-code">local_file.foo: Destroying... [id=4bf3e335199107182c6f7638efaad377acc7f452]</p>
			<p class="source-code">local_file.foo: Destruction complete after 0s</p>
			<p class="source-code">local_file.foo: Creating...</p>
			<p class="source-code">local_file.foo: Creation complete after 0s [id=5d6b2d23a15b5391d798c9c6a6b69f9a57c41aa5]</p>
			<p class="source-code">Apply complete! Resources: 1 added, 0 changed, 1 destroyed.</p>
			<p>Terraform was able to determine the attributes of the resource that have changed and create a plan for reaching the desired state. As the plan output states with <strong class="source-inline">1</strong> to add, <strong class="source-inline">0</strong> to change, <strong class="source-inline">1</strong> to destroy, the local <strong class="source-inline">foo.txt</strong> file will be deleted and then recreated, since <a id="_idIndexMarker1272"/>a change to the file <a id="_idIndexMarker1273"/>permissions forces the replacement <a id="_idIndexMarker1274"/>of the file. This example <a id="_idIndexMarker1275"/>illustrates that a single attribute change can, but does not always, cause the deletion and recreation of a resource. Note that we added the <strong class="source-inline">-auto-approve</strong> flag to the <strong class="source-inline">apply</strong> command. As the name implies, this will not prompt approval of the plan before it is applied. You may want to use caution when using that flag, as it's good practice to check the plan to ensure that the actions you expect are the actions described in the plan.</p>
			<p>Let's see the new contents of <strong class="source-inline">foo.txt</strong>:</p>
			<p class="source-code">$ cat foo.txt</p>
			<p class="source-code">foo changed!</p>
			<p>As you can see, the content of <strong class="source-inline">foo.txt</strong> has been updated to reflect the desired state. Now, let's examine the directory:</p>
			<p class="source-code">.</p>
			<p class="source-code">├── foo.txt</p>
			<p class="source-code">├── main.tf</p>
			<p class="source-code">├── terraform.tfstate</p>
			<p class="source-code">└── terraform.tfstate.backup</p>
			<p>Note that a new file was created, <strong class="source-inline">terraform.tfstate.backup</strong>. This is a copy of the previous <strong class="source-inline">tfstate</strong> file in case the new <strong class="source-inline">tfstate</strong> file is corrupted or lost.</p>
			<p>By default, the <strong class="source-inline">tfstate</strong> files are stored locally. When working individually, this is perfectly <a id="_idIndexMarker1276"/>fine; however, when working <a id="_idIndexMarker1277"/>with a team, it would become <a id="_idIndexMarker1278"/>difficult to share the most recent <a id="_idIndexMarker1279"/>state with others. This is where remote state (<a href="https://www.terraform.io/language/state/remote">https://www.terraform.io/language/state/remote</a>) becomes extremely useful. We will not cover this feature here, but you should be aware of it.</p>
			<p>Finally, we will destroy the resource we have created:</p>
			<p class="source-code">$ terraform destroy</p>
			<p class="source-code">local_file.foo: Refreshing state... [id=5d6b2d23a15b5391d798c9c6a6b69f9a57c41aa5]</p>
			<p class="source-code">Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:</p>
			<p class="source-code">  - destroy</p>
			<p class="source-code">Terraform will perform the following actions:</p>
			<p class="source-code">  # local_file.foo will be destroyed</p>
			<p class="source-code">  - resource "local_file" "foo" {</p>
			<p class="source-code">      - content              = "foo changed!" -&gt; null</p>
			<p class="source-code">      - directory_permission = "0777" -&gt; null</p>
			<p class="source-code">      - file_permission      = "0644" -&gt; null</p>
			<p class="source-code">      - filename             = "./foo.txt" -&gt; null</p>
			<p class="source-code">      - id                   = "5d6b2d23a15b5391d798c9c6a6b69f9a57c41aa5" -&gt; null</p>
			<p class="source-code">    }</p>
			<p class="source-code">Plan: 0 to add, 0 to change, 1 to destroy.</p>
			<p class="source-code">Do you really want to destroy all resources?</p>
			<p class="source-code">  Terraform will destroy all your managed infrastructure, as shown above.</p>
			<p class="source-code">  There is no undo. Only 'yes' will be accepted to confirm.</p>
			<p class="source-code">  Enter a value: yes</p>
			<p class="source-code">local_file.foo: Destroying... [id=5d6b2d23a15b5391d798c9c6a6b69f9a57c41aa5]</p>
			<p class="source-code">local_file.foo: Destruction complete after 0s</p>
			<p class="source-code">Destroy complete! Resources: 1 destroyed.</p>
			<p>Running <strong class="source-inline">terraform destroy</strong> will clean up all of the resources described in the desired state. If you examine your directory, you will see that the <strong class="source-inline">foo.txt</strong> file has been deleted.</p>
			<p>Congratulations! You <a id="_idIndexMarker1280"/>have covered the absolute <a id="_idIndexMarker1281"/>basics of Terraform. We have <a id="_idIndexMarker1282"/>learned at a high level how Terraform <a id="_idIndexMarker1283"/>operates and how to use the Terraform CLI. We created a simple local file resource, mutated it, and destroyed it. In the next section, we'll discuss Terraform providers and explore the world that opens up when we take a<a id="_idTextAnchor653"/>dvantage of the vast ecosystem of them.</p>
			<h1 id="_idParaDest-294"><a id="_idTextAnchor654"/>Understanding the basics of Terraform providers</h1>
			<p>At its heart, Terraform is a platform for reconciling an expressed desired state with an external system. The way <a id="_idIndexMarker1284"/>Terraform interacts with external APIs is through plugins called <strong class="bold">providers</strong>. A provider is responsible <a id="_idIndexMarker1285"/>for describing the schema for its exposed resources, and implementing <strong class="bold">Create, Read, Update, and Delete</strong> (<strong class="bold">CRUD</strong>) interactions with external <a id="_idIndexMarker1286"/>APIs. Providers enable Terraform to express nearly any external API's resources as Terraform resources.</p>
			<p>Through its thousands of community and verified providers, Terraform is able to manage resources including databases such as Redis, Cassandra, and MongoDB, cloud infrastructure for all major cloud service providers, communication and messaging services such as Discord and SendGrid, and a vast number of other providers. If you are interested, you <a id="_idIndexMarker1287"/>can explore a listing of them in the Terraform Registry (<a href="https://registry.terraform.io/">https://registry.terraform.io/</a>). You can simply write, plan, and apply your way to your desired infrastructure.</p>
			<p>In this section, we will build on our experience of using a local provider and extend what we learned to use a provider that interacts with an external API. We will define the desired state for a<a id="_idTextAnchor655"/> set of cloud resources and provision them.</p>
			<h2 id="_idParaDest-295"><a id="_idTextAnchor656"/>Defining and provisioning cloud resources</h2>
			<p>Imagine that we want to deploy infrastructure to our cloud service provider. In this case, we're going <a id="_idIndexMarker1288"/>to use Microsoft Azure via the <strong class="source-inline">hashicorp/azurerm</strong> provider. In an <a id="_idIndexMarker1289"/>empty directory, let's start by authoring a simple <strong class="source-inline">main.tf</strong> file like the following:</p>
			<p class="source-code"># Configure the Azure provider</p>
			<p class="source-code">terraform {</p>
			<p class="source-code">  required_providers {</p>
			<p class="source-code">    azurerm = {</p>
			<p class="source-code">      source  = "hashicorp/azurerm"</p>
			<p class="source-code">      version = "~&gt; 3.0"</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">provider "azurerm" {</p>
			<p class="source-code">  features {}</p>
			<p class="source-code">}</p>
			<p class="source-code">resource "azurerm_resource_group" "mygroup" {</p>
			<p class="source-code">  name     = "mygroup"</p>
			<p class="source-code">  location = "southcentralus"</p>
			<p class="source-code">}</p>
			<p>The preceding Terraform configuration file requires the <strong class="source-inline">hashicorp/azurerm</strong> provider and defines a resource group named <strong class="source-inline">mygroup</strong> in the <strong class="source-inline">southcentralus</strong> region (a resource group is an Azure concept that groups infrastructure resources together).</p>
			<p>To run the rest of the examples in this section, you will need an Azure account. If you do not have an Azure account, you can sign up for a free account with $200 of Azure credits: <a href="https://azure.microsoft.com/en-us/free/">https://azure.microsoft.com/en-us/free/</a>.</p>
			<p>Once you have an account, log in with the Azure CLI:</p>
			<p class="source-code">$ az login</p>
			<p>The preceding <a id="_idIndexMarker1290"/>command will log you into your Azure account and set the <a id="_idIndexMarker1291"/>default context to your primary Azure subscription. To see what subscription is active, run the following:</p>
			<p class="source-code">$ az account show</p>
			<p class="source-code">{</p>
			<p class="source-code">  "environmentName": "AzureCloud",</p>
			<p class="source-code">  "isDefault": true,</p>
			<p class="source-code">  "managedByTenants": [],</p>
			<p class="source-code">  "name": "mysubscription",</p>
			<p class="source-code">  "state": "Enabled",</p>
			<p class="source-code">  "tenantId": "888bf....db93",</p>
			<p class="source-code">  "user": {</p>
			<p class="source-code">      ...</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The preceding command output shows the name of the subscription and other details about the current context of the Azure CLI. The <strong class="source-inline">azurerm</strong> provider will use the authentication context of the Azure CLI to interact with the Azure APIs.</p>
			<p>Now that we have an authenticated Azure session on the Azure CLI, let's use <strong class="source-inline">init</strong> and <strong class="source-inline">apply</strong> to create our desired state. Within the directory containing the <strong class="source-inline">main.tf</strong> file, run the following:</p>
			<p class="source-code">$ terraform init &amp;&amp; terraform apply</p>
			<p><strong class="source-inline">terraform init</strong> will initialize the directory, pulling down the latest <strong class="source-inline">azurerm</strong> provider. By <a id="_idIndexMarker1292"/>specifying the <strong class="source-inline">~&gt; 3.0</strong> version constraint, Terraform is <a id="_idIndexMarker1293"/>directed to install the latest version of the provider in the <strong class="source-inline">3.0.x</strong> series. You should see something like the following output from <strong class="source-inline">init</strong>:</p>
			<p class="source-code">Initializing the backend...</p>
			<p class="source-code">Initializing provider plugins...</p>
			<p class="source-code">- Finding hashicorp/azurerm versions matching "~&gt; 3.0"...</p>
			<p class="source-code">- Installing hashicorp/azurerm v3.0.2...</p>
			<p class="source-code">- Installed hashicorp/azurerm v3.0.2 (signed by HashiCorp)</p>
			<p class="source-code">Terraform has created a lock file .terraform.lock.hcl to record the provider</p>
			<p class="source-code">selections it made above. Include this file in your version control repository</p>
			<p class="source-code">so that Terraform can guarantee to make the same selections by default when</p>
			<p class="source-code">you run "terraform init" in the future.</p>
			<p class="source-code">Terraform has been successfully initialized!</p>
			<p class="source-code">You may now begin working with Terraform. Try running "terraform plan" to see</p>
			<p class="source-code">any changes that are required for your infrastructure. All Terraform commands</p>
			<p class="source-code">should now work.</p>
			<p class="source-code">If you ever set or change modules or backend configuration for Terraform,</p>
			<p class="source-code">rerun this command to reinitialize your working directory. If you forget, other</p>
			<p class="source-code">commands will detect it and remind you to do so if necessary.</p>
			<p>This output should look familiar from the <em class="italic">Initializing and applying infrastructure specs using Terraform</em> section. After initialization, you will again be greeted with the plan for creating the <a id="_idIndexMarker1294"/>desired resources. Once the plan is approved, the <a id="_idIndexMarker1295"/>desired resources are created. The output should look like the following:</p>
			<p class="source-code">Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:</p>
			<p class="source-code">  + create</p>
			<p class="source-code">Terraform will perform the following actions:</p>
			<p class="source-code">  # azurerm_resource_group.rg will be created</p>
			<p class="source-code">  + resource "azurerm_resource_group" "mygroup" {</p>
			<p class="source-code">      + id       = (known after apply)</p>
			<p class="source-code">      + location = "southcentralus"</p>
			<p class="source-code">      + name     = "mygroup"</p>
			<p class="source-code">    }</p>
			<p class="source-code">Plan: 1 to add, 0 to change, 0 to destroy.</p>
			<p class="source-code">Do you want to perform these actions?</p>
			<p class="source-code">  Terraform will perform the actions described above.</p>
			<p class="source-code">  Only 'yes' will be accepted to approve.</p>
			<p class="source-code">  Enter a value: yes</p>
			<p class="source-code">azurerm_resource_group.mygroup: Creating...</p>
			<p class="source-code">azurerm_resource_group.mygroup: Creation complete after 2s [id=/subscriptions/8ec-...-24a/resourceGroups/mygroup]</p>
			<p>As you can <a id="_idIndexMarker1296"/>see from the preceding output, the resource group is <a id="_idIndexMarker1297"/>created. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you are using a free Azure account, you may not have regional capacity in the <strong class="source-inline">southcentralus</strong> location. You may need to use a different region such as <strong class="source-inline">centralus</strong> or <strong class="source-inline">northeurope</strong>. To find <a id="_idIndexMarker1298"/>out more information on what region would be best for you, view the Azure geography guidance here: <a href="https://azure.microsoft.com/en-us/global-infrastructure/geographies/#geographies">https://azure.microsoft.com/en-us/global-infrastructure/geographies/#geographies</a>.</p>
			<p>Opening the Azure portal and navigating to the <strong class="bold">Resource groups</strong> view, you should see the following:</p>
			<div>
				<div id="_idContainer060" class="IMG---Figure">
					<img src="Images/B17626_13_001.jpg" alt="Figure 13.1 – The created resource group in Azure&#13;&#10;" width="871" height="676"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.1 – The created resource group in Azure</p>
			<p>In the preceding screenshot, we <a id="_idIndexMarker1299"/>can see our newly created Azure <a id="_idIndexMarker1300"/>resource group, <strong class="source-inline">mygroup</strong>.</p>
			<p>Let's see what new files have been added to our local directory after running <strong class="source-inline">init</strong> and <strong class="source-inline">apply</strong>:</p>
			<p class="source-code">.</p>
			<p class="source-code">├── .terraform</p>
			<p class="source-code">│   └── providers</p>
			<p class="source-code">│       └── registry.terraform.io</p>
			<p class="source-code">│           └── hashicorp</p>
			<p class="source-code">│               └── azurerm</p>
			<p class="source-code">│                   └── 3.0.2</p>
			<p class="source-code">│                       └── darwin_arm64</p>
			<p class="source-code">│                           └── terraform-provider-azurerm_v3.0.2_x5</p>
			<p class="source-code">├── .terraform.lock.hcl</p>
			<p class="source-code">├── main.tf</p>
			<p class="source-code">└── terraform.tfstate</p>
			<p>Similar to the previous section, we can see the Terraform lock and state files. However, in the <strong class="source-inline">providers</strong> directory, we now see that the <strong class="source-inline">azurerm</strong> provider was installed.</p>
			<p>Let's add some <a id="_idIndexMarker1301"/>more resources and apply them. You can find a <a id="_idIndexMarker1302"/>listing of all of the supported resources in the Azure <a id="_idIndexMarker1303"/>provider documentation (<a href="https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs">https://registry.terraform.io/providers/hashicorp/azurerm/latest/docs</a>). We'll update the <strong class="source-inline">main.tf</strong> file to contain the following resources:</p>
			<p class="source-code">resource "azurerm_resource_group" "mygroup" {</p>
			<p class="source-code">  name     = "mygroup"</p>
			<p class="source-code">  location = "southcentralus"</p>
			<p class="source-code">}</p>
			<p class="source-code">resource "azurerm_service_plan" "myplan" {</p>
			<p class="source-code">  name                = "myplan"</p>
			<p class="source-code">  resource_group_name = azurerm_resource_group.mygroup.name</p>
			<p class="source-code">  location            = azurerm_resource_group.mygroup.location</p>
			<p class="source-code">  os_type             = "Linux"</p>
			<p class="source-code">  sku_name            = "S1"</p>
			<p class="source-code">}</p>
			<p class="source-code">resource "random_integer" "ri" {</p>
			<p class="source-code">  min = 10000</p>
			<p class="source-code">  max = 99999</p>
			<p class="source-code">}</p>
			<p class="source-code">resource "azurerm_linux_web_app" "myapp" {</p>
			<p class="source-code">  name                = "myapp-${random_integer.ri.result}"</p>
			<p class="source-code">  resource_group_name = azurerm_resource_group.mygroup.name</p>
			<p class="source-code">  location            = azurerm_service_plan.myplan.location</p>
			<p class="source-code">  service_plan_id     = azurerm_service_plan.myplan.id</p>
			<p class="source-code">  site_config {</p>
			<p class="source-code">      application_stack {</p>
			<p class="source-code">          docker_image = "nginxdemos/hello"</p>
			<p class="source-code">          docker_image_tag = "latest"</p>
			<p class="source-code">      }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">output "host_name" {</p>
			<p class="source-code">    value = azurerm_linux_web_app.myapp.default_hostname</p>
			<p class="source-code">}</p>
			<p>The resources added to the preceding <strong class="source-inline">main.tf</strong> file include two Azure resources, an App Service plan, a Linux web app, and one <strong class="source-inline">random_integer</strong> resource. The Azure App Service plan <a id="_idIndexMarker1304"/>defines a regional deployment of compute <a id="_idIndexMarker1305"/>infrastructure for running a Linux-based web application. The Azure Linux web app is associated with the Azure App Service plan and is <a id="_idIndexMarker1306"/>configured to run a hello world NGINX demo container image. The <strong class="source-inline">random_integer</strong> resource is needed to provide some random input for the <strong class="bold">Fully Qualified Domain Name</strong> (<strong class="bold">FQDN</strong>) for the Linux web app.</p>
			<p>Note the use of variables. For example, we use <strong class="source-inline">azurerm_resource_group.mygroup.name</strong> to provide the value for <strong class="source-inline">resource_group_name</strong> in the <strong class="source-inline">azure_service_plan</strong> resource. Variable usage helps to minimize the number of string literals in the configuration files. This is helpful when making a change because you can make it in one place, rather than each occurrence of the string.</p>
			<p>Also, note <a id="_idIndexMarker1307"/>the use of an output variable, <strong class="source-inline">host_name</strong>. This instructs Terraform <a id="_idIndexMarker1308"/>to output the <strong class="source-inline">host_name</strong> key with the value of <strong class="source-inline">azurerm_linux_web_app.myapp.default_hostname</strong> after the completion of <strong class="source-inline">terraform apply</strong>. We'll use this output to make it easier to open the website after it is provisioned.</p>
			<p>Let's run <strong class="source-inline">terraform apply</strong> again and see what happens:</p>
			<p class="source-code">$ terraform apply</p>
			<p class="source-code">│</p>
			<p class="source-code">│ Error: Inconsistent dependency lock file</p>
			<p class="source-code">│</p>
			<p class="source-code">│ The following dependency selections recorded in the lock file are inconsistent with the current configuration:</p>
			<p class="source-code">│   - provider registry.terraform.io/hashicorp/random: required by this configuration but no version is selected</p>
			<p class="source-code">│</p>
			<p class="source-code">│ To update the locked dependency selections to match a changed configuration, run:</p>
			<p class="source-code">│   terraform init -upgrade</p>
			<p class="source-code">│</p>
			<p>Oh no! <strong class="source-inline">terraform apply</strong> responds with an error, informing us that we have a new provider added to the configuration that we didn't have last time. Run <strong class="source-inline">terraform init -upgrade</strong>, and the <strong class="source-inline">random</strong> module will be added:</p>
			<p class="source-code">$ terraform init -upgrade</p>
			<p class="source-code">Initializing the backend...</p>
			<p class="source-code">Initializing provider plugins...</p>
			<p class="source-code">- Finding latest version of hashicorp/random...</p>
			<p class="source-code">- Finding hashicorp/azurerm versions matching "~&gt; 3.0"...</p>
			<p class="source-code">- Installing hashicorp/random v3.1.2...</p>
			<p class="source-code">- Installed hashicorp/random v3.1.2 (signed by HashiCorp)</p>
			<p class="source-code">- Using previously-installed hashicorp/azurerm v3.0.2</p>
			<p>You should <a id="_idIndexMarker1309"/>see some output like the preceding that shows Terraform <a id="_idIndexMarker1310"/>installing the latest version of the <strong class="source-inline">hashicorp/random</strong> provider. Let's see what our directory looks like now that we've added the provider:</p>
			<p class="source-code">.</p>
			<p class="source-code">├── .terraform</p>
			<p class="source-code">│   └── providers</p>
			<p class="source-code">│       └── registry.terraform.io</p>
			<p class="source-code">│           └── hashicorp</p>
			<p class="source-code">│               ├── azurerm</p>
			<p class="source-code">│               │   └── 3.0.2</p>
			<p class="source-code">│               │       └── darwin_arm64</p>
			<p class="source-code">│               │           └── terraform-provider-azurerm_v3.0.2_x5</p>
			<p class="source-code">│               └── random</p>
			<p class="source-code">│                   └── 3.1.2</p>
			<p class="source-code">│                       └── darwin_arm64</p>
			<p class="source-code">│                           └── terraform-provider-random_v3.1.2_x5</p>
			<p>As you can <a id="_idIndexMarker1311"/>see, the <strong class="source-inline">random</strong> provider is now installed. We should be <a id="_idIndexMarker1312"/>ready to use <strong class="source-inline">apply</strong> again:</p>
			<p class="source-code">$ terraform apply -auto-approve</p>
			<p class="source-code">azurerm_resource_group.mygroup: Refreshing state...</p>
			<p class="source-code">...</p>
			<p class="source-code">Plan: 3 to add, 0 to change, 0 to destroy.</p>
			<p class="source-code">Changes to Outputs:</p>
			<p class="source-code">  + host_name = (known after apply)</p>
			<p class="source-code">random_integer.ri: Creating...</p>
			<p class="source-code">random_integer.ri: Creation complete after 0s [id=18515]</p>
			<p class="source-code">azurerm_service_plan.myplan: Creating...</p>
			<p class="source-code">azurerm_service_plan.myplan: Still creating... [10s elapsed]</p>
			<p class="source-code">azurerm_service_plan.myplan: Creation complete after 12s [id=/subscriptions/8ec-...-24a/resourceGroups/mygroup/providers/Microsoft.Web/serverfarms/myplan]</p>
			<p class="source-code">azurerm_linux_web_app.myapp: Creating...</p>
			<p class="source-code">azurerm_linux_web_app.myapp: Still creating... [10s elapsed]</p>
			<p class="source-code">azurerm_linux_web_app.myapp: Still creating... [20s elapsed]</p>
			<p class="source-code">azurerm_linux_web_app.myapp: Creation complete after 28s [id=/subscriptions/8ec-...-24a/resourceGroups/mygroup/providers/Microsoft.Web/sites/myapp-18515]</p>
			<p class="source-code">Apply complete! Resources: 3 added, 0 changed, 0 destroyed.</p>
			<p class="source-code">Outputs:</p>
			<p class="source-code">host_name = "myapp-18515.azurewebsites.net"</p>
			<p>We've omitted some of the output of <strong class="source-inline">terraform apply</strong>. The things to note here are that we are <a id="_idIndexMarker1313"/>creating each of the resources we described in <strong class="source-inline">main.tf</strong>, they have <a id="_idIndexMarker1314"/>provisioned successfully, and <strong class="source-inline">host_name</strong> contains a <strong class="bold">Universal Resource Identifier</strong> (<strong class="bold">URI</strong>) for accessing the newly <a id="_idIndexMarker1315"/>deployed web application.</p>
			<p>Take the <strong class="source-inline">host_name</strong> URI and open it in a browser. You should see the following:</p>
			<div>
				<div id="_idContainer061" class="IMG---Figure">
					<img src="Images/B17626_13_002.jpg" alt="Figure 13.2 – NGINX running in Azure App Service&#13;&#10;" width="1026" height="520"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.2 – NGINX running in Azure App Service</p>
			<p>If you go back to the Azure portal, you will also see the resources created within your resource group.</p>
			<p>I hope you will take some time to experiment by defining and applying other resources. Once you get the hang of using providers and some basic syntax, Terraform is a joy to work with. When you are done with your resources, just run <strong class="source-inline">terraform destroy</strong>, and they will be deleted.</p>
			<p>In this section, we learned some basics about using providers to manipulate cloud resources. We only <a id="_idIndexMarker1316"/>need to use a couple of providers, but as discussed in the <a id="_idIndexMarker1317"/>opening of the section, there are thousands of providers out there. It's very likely that you will be able to find a provider to solve your problem. However, there may be APIs and resources you would like to manage with Terraform without an existing provider. In the next<a id="_idTextAnchor657"/> section, we will build a Terraform provider for a fictional pet store.</p>
			<h1 id="_idParaDest-296"><a id="_idTextAnchor658"/>Building a pet store Terraform provider</h1>
			<p>Even though the Terraform provider registry (<a href="https://registry.terraform.io/">https://registry.terraform.io/</a>) has almost every provider you can <a id="_idIndexMarker1318"/>think of, there is a chance that a provider you need does not yet exist. Perhaps you want to use Terraform to interact with resources of a <a id="_idIndexMarker1319"/>proprietary API internal to <a id="_idIndexMarker1320"/>your company. If you want to manage resources that don't yet exist in the Terraform provider ecosystem, you will need to write a provider for that API. The good news is that writing a Terraform provider is relatively simple. The thoughtful folks at HashiCorp provide great documentation, SDKs, and tools to make building a provider a breeze. </p>
			<p>In the previous sections, we learned the basics of Terraform and how to use providers to interact with resources in both local and external systems. We were able to build cloud resources to deploy a Linux web application running in a container. </p>
			<p>In this section, we will build upon the previous sections and learn how to build our own provider. The Terraform provider we are building in this section will expose pet resources and will interact with a local <strong class="source-inline">docker-compose-h</strong>osted pet store service to simulate an external API. </p>
			<p>You will learn how to define custom resources with a strong schema and validations, create data sources, and implement CRUD interactions for our pet resources. Finally, we'll discuss pub<a id="_idTextAnchor659"/>lishing a module for the world to use via the Terraform provider registry.</p>
			<h2 id="_idParaDest-297"><a id="_idTextAnchor660"/>Resources for building custom providers</h2>
			<p>HashiCorp provides <a id="_idIndexMarker1321"/>an extensive set of tutorials for building custom providers (<a href="https://learn.hashicorp.com/collections/terraform/providers">https://learn.hashicorp.com/collections/terraform/providers</a>). I highly recommend reviewing the content if you intend on building your own custom provider. </p>
			<p>The code for this section is located in <a href="https://github.com/PacktPublishing/Go-for-DevOps/tree/main/chapter/13/petstore-provider">https://github.com/PacktPublishing/Go-for-DevOps/tree/main/chapter/13/petstore-provider</a>. We will not cover all of the code, but we will dive into the most interesting parts. I've done my best to keep to only the most simple implementation; however, simple is not always elegant.</p>
			<p>Additionally, our pet store custom provider uses the Terraform plugin SDK v2 (<a href="https://www.terraform.io/plugin/sdkv2/sdkv2-intro">https://www.terraform.io/plugin/sdkv2/sdkv2-intro</a>) rather than the new (at the time of writing) Terraform plugin framework. I chose this path as the majority of existing providers use the SDK v2, and <em class="italic">the Terraform plugin framework</em> (<a href="https://www.terraform.io/plugin/framework">https://www.terraform.io/plugin/framework</a>) has not reached stability yet. If you are interested in weighing the benefits, read the <em class="italic">Which SDK Should I Use?</em> article from HashiCorp (<a href="https://www.terraform.io/plugin/which-sdk">https://www.terraform.io/plugin/which-sdk</a>).</p>
			<p>Now that we have e<a id="_idTextAnchor661"/>stablished a foundation of content and learning, let's proceed to the code.</p>
			<h2 id="_idParaDest-298"><a id="_idTextAnchor662"/>The pet store provider</h2>
			<p>Our pet store Terraform provider is just another Go application. Most of the interactions between Terraform <a id="_idIndexMarker1322"/>and the provider are handled at the Terraform SDK level, and very little gets in the way of the provider developer. Let's start off by taking a look at the directory structure of the provider:</p>
			<p class="source-code">.</p>
			<p class="source-code">├── Makefile</p>
			<p class="source-code">├── docker-compose.yml</p>
			<p class="source-code">├── examples</p>
			<p class="source-code">│   └── main.tf</p>
			<p class="source-code">├── go.mod</p>
			<p class="source-code">├── go.sum</p>
			<p class="source-code">├── internal</p>
			<p class="source-code">│   ├── client # contains the grpc pet store API client</p>
			<p class="source-code">│   │   └── ...</p>
			<p class="source-code">│   ├── data_source_pet.go</p>
			<p class="source-code">│   ├── provider.go</p>
			<p class="source-code">│   ├── resource_pets.go</p>
			<p class="source-code">│   └── schema.go</p>
			<p class="source-code">└── main.go</p>
			<p>As I said, it's a <a id="_idIndexMarker1323"/>standard Go application with an entry point in <strong class="source-inline">main.go</strong>. Let's start at the top and work our way down the files. The first on the list is the Makefile:</p>
			<p class="source-code">HOSTNAME=example.com</p>
			<p class="source-code">NAMESPACE=gofordevops</p>
			<p class="source-code">NAME=petstore</p>
			<p class="source-code">BINARY=terraform-provider-${NAME}</p>
			<p class="source-code">VERSION=0.1.0</p>
			<p class="source-code">GOARCH  := $(shell go env GOARCH)</p>
			<p class="source-code">GOOS := $(shell go env GOOS)</p>
			<p class="source-code">default: install</p>
			<p class="source-code">build:</p>
			<p class="source-code">     go build -o ${BINARY}</p>
			<p class="source-code">install: build</p>
			<p class="source-code">     mkdir -p ~/.terraform.d/plugins/${HOSTNAME}/${NAMESPACE}/${NAME}/${VERSION}/${GOOS}_${GOARCH}</p>
			<p class="source-code">     mv ${BINARY} ~/.terraform.d/plugins/${HOSTNAME}/${NAMESPACE}/${NAME}/${VERSION}/${GOOS}_${GOARCH}</p>
			<p class="source-code">test:</p>
			<p class="source-code">     go test ./... -v</p>
			<p class="source-code">testacc:</p>
			<p class="source-code">     TF_ACC=1 go test ./... -v $(TESTARGS) -timeout 120m</p>
			<p>The preceding Makefile offers some helpful build tasks and environmental configuration. For example, <strong class="source-inline">make</strong> or <strong class="source-inline">make install</strong> will build the provider for the current architecture <a id="_idIndexMarker1324"/>and place it in the <strong class="source-inline">~/.terraform.d/plugins</strong> directory tree, which will enable us to use the provider locally without publishing it to the registry.</p>
			<p>Next, we have the <strong class="source-inline">docker-compose.yml</strong> file. Let's take a look:</p>
			<p class="source-code">version: '3.7'</p>
			<p class="source-code">services:</p>
			<p class="source-code">  petstore:</p>
			<p class="source-code">    build:</p>
			<p class="source-code">      context: ../../10/petstore/.</p>
			<p class="source-code">    command:</p>
			<p class="source-code">      - /go/bin/petstore</p>
			<p class="source-code">      - --localDebug</p>
			<p class="source-code">    ports:</p>
			<p class="source-code">      - "6742:6742"</p>
			<p>The <strong class="source-inline">docker-compose.yml</strong> file runs the pet store service from <a href="B17626_10.xhtml#_idTextAnchor496"><em class="italic">Chapter 10</em></a>, <em class="italic">Automating Workflows with GitHub Actions</em>, and exposes the gRPC service on port <strong class="source-inline">6742</strong>. The pet store service stores pets in an in-memory store, so to wipe out the pets currently stored, just restart the service. We'll talk more about starting and stopping the service later in the section.</p>
			<p>Next up, we have <strong class="source-inline">examples/main.tf</strong>. Let's see what an example of defining our pet resources <a id="_idIndexMarker1325"/>will look like:</p>
			<p class="source-code">terraform {</p>
			<p class="source-code">  required_providers {</p>
			<p class="source-code">    petstore = {</p>
			<p class="source-code">      version = "0.1.0"</p>
			<p class="source-code">      source  = "example.com/gofordevops/petstore"</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p class="source-code">...</p>
			<p class="source-code">resource "petstore_pet" "thor" {</p>
			<p class="source-code">  name     = "Thor"</p>
			<p class="source-code">  type     = "dog"</p>
			<p class="source-code">  birthday = "2021-04-01T00:00:00Z"</p>
			<p class="source-code">}</p>
			<p class="source-code">resource "petstore_pet" "tron" {</p>
			<p class="source-code">  name     = "Tron"</p>
			<p class="source-code">  type     = "cat"</p>
			<p class="source-code">  birthday = "2020-06-25T00:00:00Z"</p>
			<p class="source-code">}</p>
			<p class="source-code">data "petstore_pet" "all" {</p>
			<p class="source-code">  depends_on = [petstore_pet.thor, petstore_pet.tron]</p>
			<p class="source-code">}</p>
			<p>In the preceding <strong class="source-inline">main.tf</strong> file, we can see the provider registered and configured to use the local pet store service. We can also see the definition for two <strong class="source-inline">petstore_pet</strong> resources, <strong class="source-inline">Thor</strong> and <strong class="source-inline">Tron</strong>. After the resources, we define a <strong class="source-inline">petstore_pet</strong> data source. We will walk through bits of this file in more detail later in the section.</p>
			<p>The main reason I'd like you to see <strong class="source-inline">main.tf</strong> before we get into the code is that it will give you an idea of the interface we want to achieve in the provider implementation. I believe seeing <a id="_idIndexMarker1326"/>the usage of the provider will help you to better understand the provider implementation.</p>
			<p>The rest of the source code is all in Go, so rather than going from top to bottom, I'm going to move to the entry point in <strong class="source-inline">main.go</strong> and dive into the actual implementation:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">     "github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"</p>
			<p class="source-code">     "github.com/hashicorp/terraform-plugin-sdk/v2/plugin"</p>
			<p class="source-code">     petstore "github.com/PacktPublishing/Go-for-DevOps/chapter/13/petstore-provider/internal"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">     plugin.Serve(&amp;plugin.ServeOpts{</p>
			<p class="source-code">          ProviderFunc: func() *schema.Provider {</p>
			<p class="source-code">               return petstore.Provider()</p>
			<p class="source-code">          },</p>
			<p class="source-code">     })</p>
			<p class="source-code">}</p>
			<p>Well, <strong class="source-inline">main.go</strong> is simple enough. All we are doing in <strong class="source-inline">main</strong> is starting a plugin server via the Terraform plugin SDK v2 and providing it with an implementation of our pet store provider. Let's next <a id="_idIndexMarker1327"/>look at the <strong class="source-inline">petstore.Provider</strong> implementation in <strong class="source-inline">internal/provider.go</strong>:</p>
			<p class="source-code">// Provider is the entry point for defining the Terraform provider, and will create a new Pet Store provider.</p>
			<p class="source-code">func Provider() *schema.Provider {</p>
			<p class="source-code">     return &amp;schema.Provider{</p>
			<p class="source-code">          Schema: map[string]*schema.Schema{</p>
			<p class="source-code">               "host": {</p>
			<p class="source-code">                    Type:        schema.TypeString,</p>
			<p class="source-code">                    Optional:    true,</p>
			<p class="source-code">                    DefaultFunc: schema.EnvDefaultFunc("PETSTORE_HOST", nil),</p>
			<p class="source-code">               },</p>
			<p class="source-code">          },</p>
			<p class="source-code">          ResourcesMap: map[string]*schema.Resource{</p>
			<p class="source-code">               "petstore_pet": resourcePet(),</p>
			<p class="source-code">          },</p>
			<p class="source-code">          DataSourcesMap: map[string]*schema.Resource{</p>
			<p class="source-code">               "petstore_pet": dataSourcePet(),</p>
			<p class="source-code">          },</p>
			<p class="source-code">          ConfigureContextFunc: configure,</p>
			<p class="source-code">     }</p>
			<p class="source-code">}</p>
			<p>There are only two funcs in <strong class="source-inline">provider.go</strong>. The <strong class="source-inline">Provider</strong> func creates an <strong class="source-inline">*schema.Provider</strong> that describes the schema for configuring the provider, the resources of the provider, the data sources of the provider, and the configure func for initializing the provider. The resource map for the provider contains resources by a string name and their schemas. The schemas for each of the structures describe the domain-specific <a id="_idIndexMarker1328"/>language to Terraform for interacting with their fields and resource hierarchies. We will examine the schemas for these structures in more detail soon.</p>
			<p>Next, let's look at the <strong class="source-inline">configure</strong> func in <strong class="source-inline">provider.go</strong>:</p>
			<p class="source-code">// configure builds a new Pet Store client the provider will use to interact with the Pet Store service</p>
			<p class="source-code">func configure(_ context.Context, data *schema.ResourceData) (interface{}, diag.Diagnostics) {</p>
			<p class="source-code">     // Warning or errors can be collected in a slice type</p>
			<p class="source-code">     var diags diag.Diagnostics</p>
			<p class="source-code">     host, ok := data.Get("host").(string)</p>
			<p class="source-code">     if !ok {</p>
			<p class="source-code">          return nil, diag.Errorf("the host (127.0.0.1:443) must be provided explicitly or via env var PETSTORE_HOST")</p>
			<p class="source-code">     }</p>
			<p class="source-code">     c, err := client.New(host)</p>
			<p class="source-code">     if err != nil {</p>
			<p class="source-code">          return nil, append(diags, diag.Diagnostic{</p>
			<p class="source-code">               Severity: diag.Error,</p>
			<p class="source-code">               Summary:  "Unable to create Pet Store client",</p>
			<p class="source-code">               Detail:   "Unable to connect to the Pet Store service",</p>
			<p class="source-code">          })</p>
			<p class="source-code">     }</p>
			<p class="source-code">     return c, diags</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">configure</strong> func is responsible for handling provider configuration. Note how the <strong class="source-inline">host</strong> data described in the preceding <strong class="source-inline">Provider</strong> schema is available via the <strong class="source-inline">data</strong> argument. This is a common pattern you will see throughout the provider. We use the <strong class="source-inline">host</strong> configuration data to construct the client for the pet store service. If we are unable to construct <a id="_idIndexMarker1329"/>a pet store client, we append a <strong class="source-inline">diag.Diagnostic</strong> structure to the slice of <strong class="source-inline">diag.Diagnostics</strong>. These diagnostic structures inform Terraform of an event of varying severity occurring in the provider. In this case, it is an error if we are unable to build the client, which should be communicated back to the user. If all goes well, we return the <strong class="source-inline">client</strong> instance and<a id="_idTextAnchor663"/> an empty slice of <strong class="source-inline">diag.Diagnostics</strong>.</p>
			<p>Next, let's examine the pet store data source.</p>
			<h3>Implementing the pet store data source</h3>
			<p>The pet store data source is a bit simpler than the resource implementation, given that a data source is <a id="_idIndexMarker1330"/>intended as a way for Terraform to pull in data from an external API and is read-only in this case. The pet store data source is defined in <strong class="source-inline">internal/data_source_pet.go</strong>.</p>
			<p>There are three functions of primary interest in the pet store data source. We will approach them one at a time. Let's start with the <strong class="source-inline">dataSourcePet</strong> func:</p>
			<p class="source-code">func dataSourcePet() *schema.Resource {</p>
			<p class="source-code">     return &amp;schema.Resource{</p>
			<p class="source-code">          ReadContext: dataSourcePetRead,</p>
			<p class="source-code">          Schema:      getPetDataSchema(),</p>
			<p class="source-code">     }</p>
			<p class="source-code">}</p>
			<p>The preceding function creates the <strong class="source-inline">*schema.Resource</strong> data source by providing a schema for the data being provided via <strong class="source-inline">getPetDataSchema</strong>. <strong class="source-inline">ReadContext</strong> expects a function <a id="_idIndexMarker1331"/>that is responsible for translating the input schema, querying the external API, and returning data to Terraform that matches the structure defined in the schema.</p>
			<p>The definition of <strong class="source-inline">getPetDataSchema</strong> is located in <strong class="source-inline">internal/schema.go</strong>, and it is helpful to review it prior to examining the code in <strong class="source-inline">dataSourcePetRead</strong>. We will break down the function into two parts, the input and the computed output: </p>
			<p class="source-code">func getPetDataSchema() map[string]*schema.Schema {</p>
			<p class="source-code">     return map[string]*schema.Schema{</p>
			<p class="source-code">          "pet_id": {</p>
			<p class="source-code">               Type:     schema.TypeString,</p>
			<p class="source-code">               Optional: true,</p>
			<p class="source-code">          },</p>
			<p class="source-code">          "name": {</p>
			<p class="source-code">               Type:             schema.TypeString,</p>
			<p class="source-code">               Optional:         true,</p>
			<p class="source-code">               ValidateDiagFunc: validateName(),</p>
			<p class="source-code">          },</p>
			<p class="source-code">          "type": {</p>
			<p class="source-code">               Type:             schema.TypeString,</p>
			<p class="source-code">               Optional:         true,</p>
			<p class="source-code">               ValidateDiagFunc: validateType(),</p>
			<p class="source-code">          },</p>
			<p class="source-code">          "birthday": {</p>
			<p class="source-code">               Type:             schema.TypeString,</p>
			<p class="source-code">               Optional:         true,</p>
			<p class="source-code">               ValidateDiagFunc: validateBirthday(),</p>
			<p class="source-code">          },</p>
			<p>The preceding schema describes the data structure for the pet store pet data source. Each of the top-level keys is marked as optional and will be used to filter the data source. For <a id="_idIndexMarker1332"/>example, the <strong class="source-inline">name</strong> key specifies that it is optional, is of type <strong class="source-inline">string</strong>, and should be validated with the <strong class="source-inline">validateName</strong> func. We will examine validations in more detail later in the section. </p>
			<p>The following is the schema for the output of the data source:</p>
			<p class="source-code">          "pets": {</p>
			<p class="source-code">               Type:     schema.TypeList,</p>
			<p class="source-code">               Computed: true,</p>
			<p class="source-code">               Elem: &amp;schema.Resource{</p>
			<p class="source-code">                    Schema: map[string]*schema.Schema{</p>
			<p class="source-code">                         "id": {</p>
			<p class="source-code">                              Type:     schema.TypeString,</p>
			<p class="source-code">                              Computed: true,</p>
			<p class="source-code">                         },</p>
			<p class="source-code">                         "name": {</p>
			<p class="source-code">                              Type:     schema.TypeString,</p>
			<p class="source-code">                              Computed: true,</p>
			<p class="source-code">                         },</p>
			<p class="source-code">                         "type": {</p>
			<p class="source-code">                              Type:     schema.TypeString,</p>
			<p class="source-code">                              Computed: true,</p>
			<p class="source-code">                         },</p>
			<p class="source-code">                         "birthday": {</p>
			<p class="source-code">                              Type:     schema.TypeString,</p>
			<p class="source-code">                              Computed: true,</p>
			<p class="source-code">                         },</p>
			<p class="source-code">                    },</p>
			<p class="source-code">               },</p>
			<p class="source-code">          },</p>
			<p class="source-code">     }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">pets</strong> key contains all the <strong class="source-inline">Computed</strong> values, which means each of the values is read-only. These represent the list result of the query.</p>
			<p>Now that we have <a id="_idIndexMarker1333"/>a better understanding of the data schema we are working with, let's continue with the implementation of <strong class="source-inline">dataSourcePetRead</strong>:</p>
			<p class="source-code">// dataSourcePetRead finds pets in the pet store given an ID</p>
			<p class="source-code">func dataSourcePetRead(ctx context.Context, data *schema.ResourceData, meta interface{}) diag.Diagnostics {</p>
			<p class="source-code">     psClient, err := clientFromMeta(meta)</p>
			<p class="source-code">     if err != nil {</p>
			<p class="source-code">          return diag.FromErr(err)</p>
			<p class="source-code">     }</p>
			<p class="source-code">     pets, err := findPetsInStore(ctx, psClient, findPetsRequest{</p>
			<p class="source-code">          Name:     data.Get("name").(string),</p>
			<p class="source-code">          Birthday: data.Get("birthday").(string),</p>
			<p class="source-code">          Type:     PetType(data.Get("type").(string)),</p>
			<p class="source-code">          ID:       data.Get("pet_id").(string),</p>
			<p class="source-code">     })</p>
			<p class="source-code">     if err != nil {</p>
			<p class="source-code">          return diag.FromErr(err)</p>
			<p class="source-code">     }</p>
			<p class="source-code">     // always run</p>
			<p class="source-code">     data.SetId(strconv.FormatInt(time.Now().Unix(), 10))</p>
			<p class="source-code">     if err := data.Set("pets", flattenPets(pets)); err != nil {</p>
			<p class="source-code">          return diag.FromErr(err)</p>
			<p class="source-code">     }</p>
			<p class="source-code">     return nil</p>
			<p class="source-code">}</p>
			<p>In <strong class="source-inline">dataSourcePetRead</strong>, we instantiate a client for the pet store service, populate the filter criteria from the data schema supplied, and then set the <strong class="source-inline">pets</strong> key in the <strong class="source-inline">data</strong> argument <a id="_idIndexMarker1334"/>with the pets returned from the pet store service in the key value format specified by the schema. The <strong class="source-inline">flattenPets</strong> function is responsible for transforming the protobuf structures we receive from the pet store service into the format expected by the schema. If you are interested in the implementation, it is not terribly elegant, but it is simple.</p>
			<p>I purposely didn't mention the <strong class="source-inline">data.SetId</strong> function. We are setting the value of that to a value that will cause the data to be fetched from the pet store service each time. Terraform identifies that data has changed if the ID for that data has changed. This ensures that the ID changes each time the function is executed.</p>
			<p>In the <strong class="source-inline">configure</strong> func, we created the pet store client, so how did we gain access to that client in the data source? We can find the answer to that in the <strong class="source-inline">clientFromMeta</strong> func:</p>
			<p class="source-code">// clientFromMeta casts meta into a Pet Store client or returns an error</p>
			<p class="source-code">func clientFromMeta(meta interface{}) (*client.Client, error) {</p>
			<p class="source-code">     psClient, ok := meta.(*client.Client)</p>
			<p class="source-code">     if !ok {</p>
			<p class="source-code">          return nil, errors.New("meta does not contain a Pet Store client")</p>
			<p class="source-code">     }</p>
			<p class="source-code">     return psClient, nil</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">clientFromMeta</strong> func takes the <strong class="source-inline">meta interface{}</strong> argument passed into the <strong class="source-inline">ReadContext</strong> func and casts it as the pet store client. The <strong class="source-inline">meta</strong> variable contains the variable <a id="_idIndexMarker1335"/>returned in the <strong class="source-inline">configure</strong> func. This is not as intuitive as we would like, but it is effective.</p>
			<p>With the code described previously and some helpers from <strong class="source-inline">internal/data_source_pet.go</strong>, we have implemented a filtered data source to the pet store API that we can use in Terraform configuration files.</p>
			<p>Next, let's take<a id="_idTextAnchor664"/> a look <a id="_idIndexMarker1336"/>at how we handle CRUD interactions for pet resources.</p>
			<h3>Implementing the Pet resource</h3>
			<p>The implementation for the Pet resource follows many of the same patterns as the pet store data source, but <a id="_idIndexMarker1337"/>with the pet resources, we also need to implement create, update, and delete interactions in addition to read. Unless otherwise stated, the code we cover for the pet resource implementation is in <strong class="source-inline">internal/resource_pet.go</strong>. </p>
			<p>Let's start by examining the <strong class="source-inline">resourcePet</strong> func, which is the func called when we created the provider schema:</p>
			<p class="source-code">func resourcePet() *schema.Resource {</p>
			<p class="source-code">     return &amp;schema.Resource{</p>
			<p class="source-code">          CreateContext: resourcePetCreate,</p>
			<p class="source-code">          ReadContext:   resourcePetRead,</p>
			<p class="source-code">          UpdateContext: resourcePetUpdate,</p>
			<p class="source-code">          DeleteContext: resourcePetDelete,</p>
			<p class="source-code">          Schema:        getPetResourceSchema(),</p>
			<p class="source-code">          Importer: &amp;schema.ResourceImporter{</p>
			<p class="source-code">               StateContext: schema.ImportStatePassthroughContext,</p>
			<p class="source-code">          },</p>
			<p class="source-code">     }</p>
			<p class="source-code">}</p>
			<p>Just like the pet store data source, the pet resource defines handlers for each CRUD operation as well as a schema. Before we get into the CRUD operations, let's first look at the schema, which is in <strong class="source-inline">internal/schema.go</strong>:</p>
			<p class="source-code">func getPetResourceSchema() map[string]*schema.Schema {</p>
			<p class="source-code">     return map[string]*schema.Schema{</p>
			<p class="source-code">          "id": {</p>
			<p class="source-code">               Type:     schema.TypeString,</p>
			<p class="source-code">               Optional: true,</p>
			<p class="source-code">               Computed: true,</p>
			<p class="source-code">          },</p>
			<p class="source-code">          "name": {</p>
			<p class="source-code">               Type:             schema.TypeString,</p>
			<p class="source-code">               Required:         true,</p>
			<p class="source-code">               ValidateDiagFunc: validateName(),</p>
			<p class="source-code">          },</p>
			<p class="source-code">          "type": {</p>
			<p class="source-code">               Type:             schema.TypeString,</p>
			<p class="source-code">               Required:         true,</p>
			<p class="source-code">               ValidateDiagFunc: validateType(),</p>
			<p class="source-code">          },</p>
			<p class="source-code">          "birthday": {</p>
			<p class="source-code">               Type:             schema.TypeString,</p>
			<p class="source-code">               Required:         true,</p>
			<p class="source-code">               ValidateDiagFunc: validateBirthday(),</p>
			<p class="source-code">          },</p>
			<p class="source-code">     }</p>
			<p class="source-code">}</p>
			<p>The schema defined here is simpler than the data source schema, since we are not defining  query <a id="_idIndexMarker1338"/>filters. Note that the <strong class="source-inline">id</strong> key is computed, but all the others are not. The <strong class="source-inline">id</strong> value is generated by the pet store service and is not to be specified by the user. </p>
			<p>Since these values are specified by the user as a string, validation becomes more significant. For a better user experience, we want to provide feedback to a user when a value is invalid. Let's take a look at how we validate the <strong class="source-inline">type</strong> field with the <strong class="source-inline">validateType</strong> func:</p>
			<p class="source-code">func validateType() schema.SchemaValidateDiagFunc {</p>
			<p class="source-code">     return validateDiagFunc(validation.StringInSlice([]string{</p>
			<p class="source-code">          string(DogPetType),</p>
			<p class="source-code">          string(CatPetType),</p>
			<p class="source-code">          string(ReptilePetType),</p>
			<p class="source-code">          string(BirdPetType),</p>
			<p class="source-code">     }, true))</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">validateType</strong> func returns a validation constructed with each valid value of the enumeration. This prevents a user from entering a string value for a pet type that is not supported in the pet store. The rest of the validations take a similar approach to validating the range of input values.</p>
			<p>Now that we <a id="_idIndexMarker1339"/>have explored the schema, we are prepared to explore the CRUD operations. Let's start with the <strong class="source-inline">read</strong> operation:</p>
			<p class="source-code">// resourcePetRead finds a pet in the pet store by ID and populate the resource data</p>
			<p class="source-code">func resourcePetRead(ctx context.Context, data *schema.ResourceData, meta interface{}) diag.Diagnostics {</p>
			<p class="source-code">     psClient, err := clientFromMeta(meta)</p>
			<p class="source-code">     if err != nil {</p>
			<p class="source-code">          return diag.FromErr(err)</p>
			<p class="source-code">     }</p>
			<p class="source-code">     pets, err := findPetsInStore(ctx, psClient, findPetsRequest{ID: data.Id()})</p>
			<p class="source-code">     if err != nil {</p>
			<p class="source-code">          return diag.FromErr(err)</p>
			<p class="source-code">     }</p>
			<p class="source-code">     if len(pets) == 0 {</p>
			<p class="source-code">          return nil</p>
			<p class="source-code">     }</p>
			<p class="source-code">     return setDataFromPet(pets[0], data)</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">resourcePetRead</strong> func fetches the pet store client from the <strong class="source-inline">meta</strong> argument and then finds the pet by ID in the store. If the pet is found, the <strong class="source-inline">data</strong> argument is updated <a id="_idIndexMarker1340"/>with data from the pet.</p>
			<p>That's simple enough. Next, let's look at create:</p>
			<p class="source-code">// resourcePetCreate creates a pet in the pet store</p>
			<p class="source-code">func resourcePetCreate(ctx context.Context, data *schema.ResourceData, meta interface{}) diag.Diagnostics {</p>
			<p class="source-code">     psClient, err := clientFromMeta(meta)</p>
			<p class="source-code">     if err != nil {</p>
			<p class="source-code">          return diag.FromErr(err)</p>
			<p class="source-code">     }</p>
			<p class="source-code">     pet := &amp;client.Pet{Pet: &amp;pb.Pet{}}</p>
			<p class="source-code">     diags := fillPetFromData(pet, data)</p>
			<p class="source-code">     ids, err := psClient.AddPets(ctx, []*pb.Pet{pet.Pet})</p>
			<p class="source-code">     if err != nil {</p>
			<p class="source-code">          return append(diags, diag.FromErr(err)...)</p>
			<p class="source-code">     }</p>
			<p class="source-code">     data.SetId(ids[0])</p>
			<p class="source-code">     return diags</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">resourcePetCreate</strong> func follows a similar pattern. The difference is that the pet is constructed from fields in the <strong class="source-inline">data</strong> argument, and then the pet store API is called to add <a id="_idIndexMarker1341"/>the pet to the store. In the end, the ID for the new pet is set.</p>
			<p>Next, let's look at update:</p>
			<p class="source-code">// resourcePetUpdate updates a pet in the pet store by ID</p>
			<p class="source-code">func resourcePetUpdate(ctx context.Context, data *schema.ResourceData, meta interface{}) diag.Diagnostics {</p>
			<p class="source-code">     psClient, err := clientFromMeta(meta)</p>
			<p class="source-code">     if err != nil {</p>
			<p class="source-code">          return diag.FromErr(err)</p>
			<p class="source-code">     }</p>
			<p class="source-code">     pets, err := findPetsInStore(ctx, psClient, findPetsRequest{ID: data.Id()})</p>
			<p class="source-code">     if err != nil {</p>
			<p class="source-code">          return diag.FromErr(err)</p>
			<p class="source-code">     }</p>
			<p class="source-code">     if len(pets) == 0 {</p>
			<p class="source-code">          return diag.Diagnostics{</p>
			<p class="source-code">               {</p>
			<p class="source-code">                    Severity: diag.Error,</p>
			<p class="source-code">                    Summary:  "no pet was found",</p>
			<p class="source-code">                    Detail:   "no pet was found when trying to update the pet by ID",</p>
			<p class="source-code">               },</p>
			<p class="source-code">          }</p>
			<p class="source-code">     }</p>
			<p class="source-code">     pet := pets[0]</p>
			<p class="source-code">     diags := fillPetFromData(pet, data)</p>
			<p class="source-code">     if diags.HasError() {</p>
			<p class="source-code">          return diags</p>
			<p class="source-code">     }</p>
			<p class="source-code">     if err := psClient.UpdatePets(ctx, []*pb.Pet{pet.Pet}); err != nil {</p>
			<p class="source-code">          return append(diags, diag.FromErr(err)...)</p>
			<p class="source-code">     }</p>
			<p class="source-code">     return diags</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">resourcePetUpdate</strong> func combines parts of read and create. Initially, we need to check to see <a id="_idIndexMarker1342"/>whether the pet is in the store and fetch the pet data. If we don't find the pet, we return an error. If we do find the pet, we update the fields of the pet and call <strong class="source-inline">UpdatePets</strong> on the pet store client.</p>
			<p>The delete operation is relatively trivial, so I will not dive into it here. If you want, you can take a look at <strong class="source-inline">resourcePetDelete</strong> to see for yourself.</p>
			<p>At this point,<a id="_idTextAnchor665"/> we have <a id="_idIndexMarker1343"/>now implemented the pet resource and are ready to see our Terraform provider in action.</p>
			<h3>Running the pet store provider</h3>
			<p>Now that we have a fully implemented pet store provider, the fun part is running it. From the <a id="_idIndexMarker1344"/>root of the pet store provider, run the following commands. Be sure to have Docker running:</p>
			<p class="source-code">$ docker-compose up -d</p>
			<p class="source-code">$ make</p>
			<p class="source-code">$ cd examples</p>
			<p class="source-code">$ terraform init &amp;&amp; terraform apply</p>
			<p>The preceding commands will start the pet store service using <strong class="source-inline">docker-compose</strong>, build and install the provider, move it into the example directory, and finally, use <strong class="source-inline">init</strong> and <strong class="source-inline">apply</strong> to create our desired state containing our pets.</p>
			<p>When <strong class="source-inline">init</strong> executes, you should see something like the following:</p>
			<p class="source-code">Initializing the backend...</p>
			<p class="source-code">Initializing provider plugins...</p>
			<p class="source-code">- Finding example.com/gofordevops/petstore versions matching "0.1.0"...</p>
			<p class="source-code">- Installing example.com/gofordevops/petstore v0.1.0...</p>
			<p class="source-code">- Installed example.com/gofordevops/petstore v0.1.0 (unauthenticated)</p>
			<p>Yay! The provider is installed and Terraform is ready to apply our resources.</p>
			<p>After Terraform has applied the resources, you should see the following output:</p>
			<p class="source-code">Apply complete! Resources: 2 added, 0 changed, 0 destroyed.</p>
			<p class="source-code">Outputs:</p>
			<p class="source-code">all_pets = {</p>
			<p class="source-code">  "birthday" = tostring(null)</p>
			<p class="source-code">  "id" = "1648955761"</p>
			<p class="source-code">  "name" = tostring(null)</p>
			<p class="source-code">  "pet_id" = tostring(null)</p>
			<p class="source-code">  "pets" = tolist([</p>
			<p class="source-code">    {</p>
			<p class="source-code">      "birthday" = "2020-06-25T00:00:00Z"</p>
			<p class="source-code">      "id" = "495b1c94-6f67-46f2-9d4d-e84cc182d523"</p>
			<p class="source-code">      "name" = "Tron"</p>
			<p class="source-code">      "type" = "cat"</p>
			<p class="source-code">    },</p>
			<p class="source-code">    {</p>
			<p class="source-code">      "birthday" = "2021-04-01T00:00:00Z"</p>
			<p class="source-code">      "id" = "36e65cb2-18ea-4aec-a410-7bad64d7b00d"</p>
			<p class="source-code">      "name" = "Thor"</p>
			<p class="source-code">      "type" = "dog"</p>
			<p class="source-code">    },</p>
			<p class="source-code">  ])</p>
			<p class="source-code">  "type" = tostring(null)</p>
			<p class="source-code">}</p>
			<p class="source-code">thor = {</p>
			<p class="source-code">  "36e65cb2-18ea-4aec-a410-7bad64d7b00d" = {</p>
			<p class="source-code">    "birthday" = "2021-04-01T00:00:00Z"</p>
			<p class="source-code">    "id" = "36e65cb2-18ea-4aec-a410-7bad64d7b00d"</p>
			<p class="source-code">    "name" = "Thor"</p>
			<p class="source-code">    "type" = "dog"</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>We can see from the preceding output that both of our resources, <strong class="source-inline">Tron</strong> and <strong class="source-inline">Thor</strong>, have been <a id="_idIndexMarker1345"/>added, and our data source when queried with no filters returned each of the pets. Lastly, we can see the <strong class="source-inline">thor</strong> output was returned, containing the data for <strong class="source-inline">Thor</strong>.</p>
			<p>Let's review <strong class="source-inline">examples/main.tf</strong> again and see where the <strong class="source-inline">thor</strong> output came from:</p>
			<p class="source-code">variable "pet_name" {</p>
			<p class="source-code">  type    = string</p>
			<p class="source-code">  default = "Thor"</p>
			<p class="source-code">}</p>
			<p class="source-code">data "petstore_pet" "all" {</p>
			<p class="source-code">  depends_on = [petstore_pet.thor, petstore_pet.tron]</p>
			<p class="source-code">}</p>
			<p class="source-code"># Only returns Thor by name</p>
			<p class="source-code">output "thor" {</p>
			<p class="source-code">  value = {</p>
			<p class="source-code">    for pet in data.petstore_pet.all.pets :</p>
			<p class="source-code">    pet.id =&gt; pet</p>
			<p class="source-code">    if pet.name == var.pet_name</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>In the preceding <strong class="source-inline">main.tf</strong> file, we defined a <strong class="source-inline">pet_name</strong> variable with the value of <strong class="source-inline">Thor</strong>. We then queried the pet store data source, providing no filters but depending on the completion <a id="_idIndexMarker1346"/>of both of the resources in the file. Lastly, we output a key of <strong class="source-inline">thor</strong>, with the value being a query that matches only when <strong class="source-inline">pet.name</strong> equals <strong class="source-inline">var.pet_name</strong>. This filtered the data source for only pets named <strong class="source-inline">Thor</strong>.</p>
			<p>You can now use any of the Terraform skills you've lear<a id="_idTextAnchor666"/>ned thus far to manipulate pet store resources. There really wasn't all that much code to implement.</p>
			<h2 id="_idParaDest-299"><a id="_idTextAnchor667"/>Publishing custom providers</h2>
			<p>Anyone can publish a provider to the Terraform Registry by logging into it using a GitHub account. Again, HashiCorp has excellent documentation on how to publish a provider. We <a id="_idIndexMarker1347"/>will not walk through the process in this book, as <a id="_idIndexMarker1348"/>the documentation for <em class="italic">Release and Publish a Provider to the Terraform Registry</em> (<a href="https://learn.hashicorp.com/tutorials/terraform/provider-release-publish">https://learn.hashicorp.com/tutorials/terraform/provider-release-publish</a>) is likely sufficient if you have reached this far in your journey building your own Terraform provider.</p>
			<h1 id="_idParaDest-300"><a id="_idTextAnchor668"/>Summary</h1>
			<p>In this chapter, we learned about the history of IaC and the advantages of leveraging the practice to bring software development and operations together by setting a shared context for expressing and continuously testing infrastructure. We learned where Terraform lies in the ecosystem of IaC tooling and how to use it to describe desired infrastructure states, mutate existing infrastructure, deploy a cloud infrastructure, and finally, create our own resources for automating external APIs. You should now be prepared with the tools needed to improve your own software projects.</p>
			<p>In the next chapter, we will learn how to use Go to deploy applications to Kubernetes and build upon that knowledge to understand how to extend it with Go. We'll enable our Kubernetes users to reconcile pets as custom Kubernetes resources.</p>
		</div>
	</div></body></html>