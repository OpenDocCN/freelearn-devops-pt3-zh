- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Provisioning Resources
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Life is chaotic, dangerous, and surprising. Buildings should reflect that.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: – Frank Gehry (famous architect)
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: '**DevOps** is a game of resources. Of taking the resources that you have and
    putting them in the right place. It sounds easy, but it is not. The acquisition
    of resources is based on several criteria and requirements that the DevOps engineer
    receives. If you want to optimally provision resources, then you have to understand
    the logic and reasoning behind provisioning those resources as well as the strategy
    behind the intended use of the underlying infrastructure.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'And if you want all that in plain English: take only what you need.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: 'So, that will be one of the underlying concepts of this chapter: rightsizing.
    **Rightsizing** is the art of finding the optimal resource sizes for your application
    or workload. A lot of this is just trial and error (often yours, but someone else’s
    if you can get it) and trust me when I say this, it is much easier to do that
    programmatically than manually in the modern DevOps landscape.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: But that’s easier said than done, because sometimes the load placed upon your
    resources is a lot larger than the size of the resources you’ve provisioned, especially
    if your application becomes popular. You become a victim of your own success.
    Or you provision resources that can hold at maximum capacity, but that capacity
    is only occasional, and you can’t possibly ramp your resources up in time.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings us to the second underlying concept of this chapter: scaling. **Scaling**
    your resources up and down is one of the important aspects of DevOps and removing
    resources is as key an aspect of provisioning them as adding resources is. This
    must almost always be done programmatically, and we will look at a couple of ways
    in which Python can help us with that.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: If you master these concepts and how to use them effectively, you can save you
    and your organization a massive amount of time, money, and resources. In addition
    to this, you will be able to deliver on spikes in demand in a way that addresses
    the needs of both your organization and its customers.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will explore the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: How to provision virtual resources with Python
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use Python SDKs for various clouds and provision resources through them
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How scaling works, the types of scaling, and choosing the correct type of scaling
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How containerization of resources can help with rightsizing and easier provisioning
    (and where Python plays a role)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here is a list of requirements that you will need to meet to complete the exercises
    in this chapter:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Python installation with boto3, Kubernetes, and Docker libraries installed
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An AWS account
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowledge of how to use a Jupyter Notebook
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are on Windows, the use of **Windows Subsystem for Linux** (**WSL**)
    to use Docker locally
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A GitHub account, and basic knowledge of Git and repositories
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Access to this book’s repository: [https://github.com/PacktPublishing/Hands-On-Python-for-DevOps](https://github.com/PacktPublishing/Hands-On-Python-for-DevOps)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A basic understanding of virtualization and Kubernetes
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python SDKs (and why everyone uses them)
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s take it from the top. **SDKs**, or **software development kits**, are
    official programming libraries and **CLIs** released by a platform that allows
    developers to develop tools and applications that leverage that platform. These
    SDKs are usually written in very popular languages so as to cover the largest
    number of developers possible.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: 'The three major clouds (where the majority of DevOps work is done) have the
    following programming languages in common among them for SDKs: **Java**, **.NET**,
    **C++**, **Go**, **JavaScript**/**TypeScript**/**Node.js**, and **Python**. If
    you work on one of these – and the chances that you do are greater than the chances
    that you don’t – you need to choose a programming language.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: So, the question then becomes, why Python? Also, why are we asking this question
    four chapters into this book? Well, I’ll tell you. Python is the exact balance
    between loose and structured that is necessary to pull off a lot of DevOps principles.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Strictly typed languages such as Java, .NET, and C++ can be good for development,
    but they will produce awful results for the flexibility that is required of the
    modern DevOps workload. That being said, most clouds are built on these languages.
    But operating on them is a different game entirely. Think of these languages as
    the bones that provide sturdiness and Python as the joints that provide flexibility
    – they should be everywhere that requires flexibility.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Then, on the other end of the spectrum, you have that JavaScript trio. The reason
    they are sometimes unsuited for this – even though there is a massive amount of
    support for them from the major clouds – is the limitations and syntactic quirks
    that are natural to these languages. They aren’t meant to natively work this way
    and in addition to that, they are single-threaded and difficult to operate concurrently.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: The primary competitor and, at times, cooperator to Python in this department
    is Go. And let me tell you, Go is good. A majority of cloud-based tools such as
    **Docker** and **Kubernetes** are built in Go, and ones that aren’t are usually
    built in Python. But Go is really the only other language that can go toe to toe
    with Python for how useful it is in DevOps. And I’m telling you this because much
    of what I’m going to work through in this chapter will involve frameworks written
    in Go, such as **Terraform** and Docker.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: With all of this information out of the way, let’s finally put the focus back
    on Python. Python is easygoing. It has variable assignment without strict data
    types, which is incredibly useful for loosely coupled services, a very common
    architectural choice. It has a big community and is almost always the first SDK
    offered by modern infrastructure providers. As mentioned previously in this section,
    Python can essentially enter into a symbiotic relationship with any framework
    written in any language. If there is a popular framework or tool, its Pythonic
    version will likely be well-maintained and properly updated.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: That was a quick look at the importance of and popularity of Python SDKs, now,
    we are now going to see an example of how Python SDKs can be used to provision
    resources.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Creating an AWS EC2 instance with Python’s boto3 library
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Boto3** – it’s a name you’ve probably heard very often if you’ve worked with
    AWS and Python. It is the SDK that contains nearly every major AWS service that
    is currently available with Python.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'For this example, we are going to use Boto3 in a script that will provision
    an EC2 instance in your AWS account. It sounds simple, but there are still a lot
    of steps that you need to follow to make it happen, so let’s get started. We will
    now begin by first logging into our AWS account and searching for the Sagemaker
    service. Let’s dive into it:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'For this exercise, we need a clean environment where we can write Python code
    but also configure permissions in a terminal. To do this, in my AWS account, I’m
    going to create something else that we will use down the line: a **Sagemaker**
    notebook. A Sagemaker notebook is a Jupyter notebook service run on AWS servers:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Console to create a notebook instance in Amazon Sagemaker](img/B21320_04_1.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Console to create a notebook instance in Amazon Sagemaker
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the breadcrumb at the top, you can see that the path is **Amazon
    Sagemaker** -> **Notebook instances** -> **Create** **notebook instance**.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'Any smaller notebook is good. We’re using **ml.t3.medium** for this exercise:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Created notebook](img/B21320_04_2.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Created notebook
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Once your notebook is up and running, click on **Open Jupyter** to get to your
    **Jupyter IDE**. Now, the instance itself will have some AWS permissions because
    it is an AWS creation, but not enough to provision an EC2 programmatically. It
    will, however, come pre-installed with boto3 and the **AWS CLI**.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t have them installed, install `boto3` with `pip` and the AWS CLI
    through AWS’s official website [(https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html](https://docs.aws.amazon.com/cli/latest/userguide/getting-started-install.html)),
    which contains installers for all operating systems.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s try and provision the EC2 with the pre-existing Sagemaker role that
    comes pre-assigned to Sagemaker:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Code to invoke boto3 API](img/B21320_04_3.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Code to invoke boto3 API
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: It worked. But, as you see here, the Sagemaker instance already came pre-configured
    with a role that had EC2 access.. If that had not been the case, you would have
    had to give the role some permissions or use the AWS CLI to attach a role profile
    to the instance. But it worked, and that is great. You can view your EC2 instance
    in your AWS console.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are a few things to note here:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: You always need to define an `ImageID` (AWS has a public catalog). The one I’m
    using is AWS’s proprietary Linux version.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to define the instance size and the maximum and minimum number of instances
    to create.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, that was simple and easy to understand, wasn’t it? Well, that’s good. Now
    we can move on to the concepts that make the provisioning of resources so necessary.
    Scaling and autoscaling are essential concepts in DevOps and they are both just
    a matter of provisioning resources.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Scaling and autoscaling
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Scaling** is the act of increasing or decreasing the size of a workload or
    resource depending on the demand for it. **Autoscaling** is doing this automatically
    based on some sort of trigger.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: As is often the case with workloads and applications, you can become a victim
    of your own success. The more your application succeeds, the greater the strain
    on it due to demand from users or services. To manage this strain often requires
    limitations placed on access to your application. You should do this if you don’t
    want to get overwhelmed with requests, trust me, because someone will try to do
    exactly that. But you should also have provisions in your infrastructure that
    can help it grow naturally with your growing user base.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: That is where scaling comes in. Scaling can be done either vertically (adding
    greater computing power to a device) or horizontally (adding more computers).
    When performing one powerful act, vertical scaling is ideal and when processing
    a greater number of requests, you’ll need horizontal scaling. Most DevOps workloads
    require the latter over the former.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: We will now explore the different types of scaling based on how hands-on you
    have to be with the workload that you are scaling. We will start with manual scaling
    and slowly escalate toward a more automated approach.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: Manual scaling with Python
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we dive into autoscaling, let’s just look at some regular scaling (done
    with Python, of course). We will vertically scale an instance manually using Python’s
    SDK for AWS. I will be using just my regular local IDE. But you can do this with
    any combination of Python, AWS CLI, and an AWS account. So, let’s head into the
    steps you would need to take to manually scale an EC2 instance using Python scripts:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code to create an EC2 instance (this will be up in the book’s repository
    as well):'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Function to create an EC2 instance](img/B21320_04_4.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Function to create an EC2 instance
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'And when you run it, you’ll get the instance ID (which you will need for this
    next part):'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – EC2 instance created with a unique ID](img/B21320_04_5.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – EC2 instance created with a unique ID
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll see that the instance with that same instance size and ID has been created
    on the AWS EC2 console:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Running EC2 instance](img/B21320_04_6.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Running EC2 instance
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, vertical scaling acts on that same instance but the instance size cannot
    be changed while it is running, so we will stop the instance first:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Function to stop an EC2 instance](img/B21320_04_7.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Function to stop an EC2 instance
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: 'This code will stop the instance when it is run. Confirm that the instance
    is stopped and note the size of the instance is still **t2.nano**:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Stopped EC2 instance](img/B21320_04_8.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – Stopped EC2 instance
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s write the code to modify the instance into a `t2.micro` instance:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Code to update an EC2 instance](img/B21320_04_9.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – Code to update an EC2 instance
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'After running this code, you’ll notice that on the console, your instance is
    now a **t2.micro** instance:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – Updated EC2 instance size](img/B21320_04_10.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – Updated EC2 instance size
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: So, once you restart the instance, it will have that extra power available.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may have noticed that this is a slog. And vertical scaling is – more often
    than not – a slog of downtime. While there are use cases for things like these
    (especially when you need to work with bigger individual machines), it’s not the
    norm. Usually, horizontal autoscaling is better for your use case because of the
    lesser amount of downtime associated with the process. We’ll dive into that now.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Autoscaling with Python based on a trigger
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Autoscaling requires automating the process of increasing the available compute
    resources according to some sort of metric or statistic. In order to autoscale,
    we need to design a mechanism that will trigger our SDK call once a certain metric
    or threshold has been reached.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Understand that looking at this particular example from a singular cloud perspective
    may make it seem a little impractical because most cloud platforms have in-built
    autoscaling. The key here lies in fine-tuning that autoscaling. I’m going to create
    an **autoscaling group** and define the thresholds for scaling using a Python
    script. Then, I’m going to modify those thresholds and I will tell you the significance
    of why after I have done it.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write a basic script to make an autoscaling group and put a threshold
    on it using a policy for CPU utilization. We’ll go step-by-step from the launch
    configuration to the autoscaling group to the rule by which the instances will
    autoscale:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we write the code to create a launch configuration that all machines
    in the autoscaling group will follow:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.11 – Code to create a launch configuration](img/B21320_04_11.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 – Code to create a launch configuration
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create the autoscaling group, which uses the launch configuration
    that we created previously:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.12 – Code to create an autoscaling group](img/B21320_04_12.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 – Code to create an autoscaling group
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will create a policy that will scale the group upward if CPU utilization
    is greater than 70%:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.13 – Code to create a scaling policy](img/B21320_04_13.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: Figure 4.13 – Code to create a scaling policy
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Running all of these will give you a basic autoscaling group of virtual machines
    with these specifications. Now, you may be asking yourself where Python helps
    with this autoscaling. Well, for that, you first have to look at the metrics produced
    by these virtual machines.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look through the metrics that are produced by the VMs, you’ll be able
    to find their CPU utilization metrics, which can be exported. Using these metrics,
    you can calculate the average utilization of CPUs over a period of time (that
    programming language Python helps, I’m told), then use that data to find a better
    autoscaling target. To modify the target, you can simply use the same code as
    before with a different metric value:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14 – Code for modified scaling policy](img/B21320_04_14.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: Figure 4.14 – Code for modified scaling policy
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: Your findings on the data may even reveal that there is a better metric to use
    for your workload than CPU utilization. You can modify that here as well.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: This type of scaling is very useful and there are a lot of situations where
    you definitely will use these. However, this isn’t the only way to implement scaling
    and virtualization. In the next section, we will explore containers and their
    roles and purpose in the field of scaling and virtualization.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Containers and where Python fits in with containers
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Containers** are small packages of software that serve as a unique runtime
    containing all of the necessary resources to run a small facet of an application,
    or sometimes the entire application itself.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: The containers themselves are written in Go, as is the container orchestration
    service, Kubernetes. Those parts do not require Python unless the application
    code itself is written in Python. Where Python comes in handy is as the glue between
    the various containerized services. Orchestrating the orchestration, if you will.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are going to learn about the role that Python plays in the overall container
    picture. Python, as always, has a lot of libraries that support the use of containers
    and Kubernetes, and we will explore some of these libraries and how using Python
    can simplify your DevOps work where these important infrastructural elements are
    concerned.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying Docker administration with Python
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Keeping Docker images together and organized is tricky. It’s why they invented
    Kubernetes. But Kubernetes itself is tricky. This leaves two gaps:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: First, when there are multiple Docker images but complete orchestration with
    Kubernetes is not required
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, when Kubernetes APIs need to be frequently called or the cluster needs
    to be frequently updated
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For both of these purposes, Python can be a useful tool. Remember this is about
    support, not refactoring. We’re the auxiliary player here.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: So, in this section, we will look at an example of how to use Python to administer
    multiple containers.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'We will write a script to get a specific Docker image and create a container
    for it. This script can be rerun to do the same thing over and over again. You
    may also use the `restart` command if a container malfunctions. Now let’s look
    at the code to pull Docker images and start a container:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15 – Code to pull Docker images and start a container](img/B21320_04_15.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: Figure 4.15 – Code to pull Docker images and start a container
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: It’s simple, but that’s the key to it. Its simplicity provides building blocks
    to improve upon.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: But even if we keep it simple, sometimes the use of containers gets complex,
    which is where Kubernetes comes in. With Kubernetes comes its own challenges.
    These challenges can also be simplified and managed using Python.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: Managing Kubernetes with Python
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There will come a time in your container usage when Kubernetes will be the way
    that you need to go. At this time, Python can help as well. Python can help simplify
    a lot of Kubernetes administration tasks and since most Kubernetes workloads are
    run on the cloud, those SDKs are going to come in pretty handy as well.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: I’m only going to include one example, which will consist of the manipulation
    of Kubernetes namespaces. Just to be safe, we don’t want to crash and burn with
    computing resources yet, especially if you are new to Kubernetes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '**Namespaces** are abstractions within a Kubernetes cluster that are used to
    divide computer resources based on certain criteria. A criterion can be environment
    (dev, production, etc.), network restrictions, or based on resource quotas available
    to a namespace.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use Python to create and modify namespaces and manipulate the resources
    within them. Let’s look at the steps to initialize a Kubernetes cluster and manage
    it using Python:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you will need to install Kubernetes with `pip` using the following command:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, let’s write a script to create a few namespaces in our cluster. We can
    add resources to these namespaces later:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.16 – Code to create Kubernetes namespaces from a list](img/B21320_04_16.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
- en: Figure 4.16 – Code to create Kubernetes namespaces from a list
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s write a policy for these namespaces and implement them into Kubernetes:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.17 – Creating a policy for namespaces for implementation](img/B21320_04_17.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
- en: Figure 4.17 – Creating a policy for namespaces for implementation
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: This will create policies for both namespaces, which will block external traffic
    from outside the namespace. As you can see here, we’ve implemented the same formatted
    policy to both namespaces using an iterator. This is but one of the ways you can
    automate in Kubernetes using Python.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为两个命名空间创建策略，阻止来自命名空间外部的外部流量。正如你所看到的，我们使用迭代器对两个命名空间实施了相同格式的策略。这只是使用 Python
    在 Kubernetes 中进行自动化的众多方式之一。
- en: Eventually, you can automate these steps to the point where it will be possible
    for you to simply list out and visualize your Kubernetes cluster and press a couple
    of buttons to adjust it to your needs. Everything else, the cluster will take
    care of.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，你可以将这些步骤自动化到一个程度，只需列出并可视化你的 Kubernetes 集群，按几个按钮就能根据需求调整。其他所有事情，集群将自动处理。
- en: Summary
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter sent us on quite a trip in terms of how we use Python. We figured
    out how SDKs work, what advantages they have, and why Python is so useful to have
    in the world of SDK use. You can literally build applications on top of applications,
    I’ve seen it.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 本章让我们在使用 Python 的过程中进行了相当一番探索。我们搞清楚了 SDK 如何工作，它们的优势是什么，以及为什么 Python 在 SDK 使用的世界里如此有用。你几乎可以在应用之上再构建应用，我亲眼见过。
- en: We also learned about scaling and how much of a hassle that is because of the
    balance you have to strike between availability and cost. Here, we also found
    use for Python and its great SDKs and data processing abilities, helping us strike
    that balance.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还学习了扩展性问题，以及如何因为需要在可用性和成本之间找到平衡而变得麻烦。这里，我们也发现了 Python 及其强大的 SDK 和数据处理能力的作用，帮助我们实现了这种平衡。
- en: Containers are also greatly supported by Python libraries, which can help act
    as a glue filler in the gaps between Docker and Kubernetes. We learned about the
    assisting role that Python plays in the management of these services.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 容器也得到了 Python 库的强力支持，这些库可以帮助填补 Docker 与 Kubernetes 之间的空白。我们了解了 Python 在管理这些服务中的辅助作用。
- en: So, in conclusion, in this chapter you have learned quite a bit about Python’s
    SDKs, using them for autoscaling, rightsizing, and containers. In the next chapter,
    we will take a closer look at how Python can be used to manipulate and interact
    with already provisioned resources.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，总结来说，在这一章你学到了许多关于 Python SDK 的内容，包括如何使用它们进行自动扩展、调整大小以及管理容器。在下一章，我们将更详细地探讨如何使用
    Python 操控和与已经配置好的资源进行交互。
- en: 'Part 2: Sample Implementations of Python in DevOps'
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二部分：Python 在 DevOps 中的示例实现
- en: This part will cover sample implementations for some common DevOps use cases
    using Python.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分将涵盖一些常见 DevOps 用例的 Python 示例实现。
- en: 'This part has the following chapters:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 5*](B21320_05.xhtml#_idTextAnchor099), *Manipulating Resources*'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第五章*](B21320_05.xhtml#_idTextAnchor099)，*资源操作*'
- en: '[*Chapter 6*](B21320_06.xhtml#_idTextAnchor129), *Security and DevSecOps with
    Python*'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第六章*](B21320_06.xhtml#_idTextAnchor129)，*使用 Python 进行安全性与 DevSecOps*'
- en: '[*Chapter 7*](B21320_07.xhtml#_idTextAnchor142), *Automating Tasks*'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第七章*](B21320_07.xhtml#_idTextAnchor142)，*自动化任务*'
- en: '[*Chapter 8*](B21320_08.xhtml#_idTextAnchor155), *Understanding Event-Driven
    Architecture*'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第八章*](B21320_08.xhtml#_idTextAnchor155)，*理解事件驱动架构*'
- en: '[*Chapter 9*](B21320_09.xhtml#_idTextAnchor165), *Using Python for CI/CD Pipelines*'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第九章*](B21320_09.xhtml#_idTextAnchor165)，*使用 Python 进行 CI/CD 流水线*'
