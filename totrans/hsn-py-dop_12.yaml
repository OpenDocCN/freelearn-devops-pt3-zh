- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How Python Integrates with IaC Concepts
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Never measure the height of a mountain until you have reached the top. Then
    you will see how low it was.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: – Dag Hammarskjöld
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: So, as we approach this penultimate chapter, we get to the topic of **Infrastructure
    as Code** (**IaC**). It is quite the topic, indeed, one that has taken the IT
    world by storm. It is a response to the fact that there are now more resources
    available for applications and workloads than there ever were before and the only
    thing left to do is arrange them in the most optimal way. Sure, you might find
    a way to do this once manually and it might work. But having to do it over and
    over again with a guarantee that you won’t make mistakes? That’s foolish talk
    and a waste of manpower.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: So, based on these observations, the concept of IaC emerged. It posited that
    if resource creation, provisioning, and updating were standardized in the form
    of code with constants and variables arranged in an organized way, you could standardize
    the replication of resources, making things such as backups, failovers, re-deployments
    and a whole lot of other operations activities easier.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Of course, IaC has its detractors, because all good technology does. They believe
    that it is too fast, too powerful, capable of running up your cloud bill and putting
    up resources that become too hard to untangle and are not as easily customizable.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: It’s an interesting thought, but when I look at IaC, I am reminded of the initial
    passage in Adam Smith’s *Wealth of Nations* where he talks about how the division
    of labor increases production more than any other factor. IaC concepts do the
    same, where the labor (resources) is separated from the schematics that build
    them, allowing them to be produced over and over again.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Python as a language has been very friendly towards IaC, perhaps the second-most
    behind Go. There are a lot of native IaC libraries and stacks in Python (which
    we will cover), in addition to modules and APIs to interact with IaC tools not
    written in Python. The flexibility of Python and the desire for loose, yet strict
    replication that comes with IaC allowed Python to become such a huge part of the
    growing IaC trend.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will help you with a concept in IaC that is considered unique
    to DevOps, one that was created to fuel the constant need for automation and standardization
    in a DevOps workload. It will help you understand why DevOps and coding need to
    be so closely related to each other. That is why, in this chapter, you will learn
    the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: The basics of **SaltStack** and how it is built in Python along with how to
    evaluate SaltStack modules at the code and command-line levels
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basics of **Ansible** and how to create your own automated Ansible module
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How you can use Python to interact with other IaC tools, such as Terraform,
    to add automation on top of already built automation
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to pursue this chapter to its logical conclusion, you will need to
    fulfill a few technical requirements:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: Installation of Python with the **Salt library** and Ansible
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installation of NPM and NodeJS with `cdktf`
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installation of Terraform CLI
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An AWS and a GCP account
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A GitHub account to retrieve the repository for this book ([https://github.com/PacktPublishing/Hands-On-Python-for-DevOps](https://github.com/PacktPublishing/Hands-On-Python-for-DevOps))
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A significant amount of patience and understanding
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automation and customization with Python’s Salt library
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We talk about all of these fancy architectures and frameworks that we want to
    make; we talk about all of these different tools that we want to use, all of these
    workflows, and they are fun. They are very exciting, but the thing that a lot
    of DevOps still boils down to is server management; the Ops side of DevOps. It
    is still important and relevant in today’s world and will be for as long as people
    use it, which is likely forever.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Server management in the modern day requires the creation of modern, custom
    environments based on the requirements of the application being hosted. It also
    requires a lot of automation features to be maintained and to stay in an optimized
    state based on present circumstances.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: The radio was never replaced by the television, and television in turn probably
    won’t be replaced by streaming completely. Everything changes, evolves, or reduces
    down, but the thing itself and the skills needed to use it will be relevant in
    one way or another. This is why the tools for server management will always be
    there and they will evolve.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: That’s what the Salt library (used interchangeably with SaltStack) is used for.
    In essence, it consists of a central server that can be used to send commands
    to all servers connected to it. The requirements are that the minion (server to
    be managed) is configured to receive commands from the master (server that does
    the managing). It’s a pretty simple concept, executed using only the finest Python
    code.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s get into it. We will start with the installation of a Salt server
    and a minion, and then, we will see how we can customize the Python code that
    comprises Salt if needed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: 'The architecture of the Salt library consists of, as we said, a master and
    several minions. So, let’s start by creating servers that mirror this configuration:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create one master server and a minion in GCP, and one minion in AWS
    to show cross-cloud functionality. For this exercise, we are using Ubuntu as our
    primary **operating system** (**OS**), but other OSs will work just as well. We
    will make a minion and a master Salt instance in GCP:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Salt instances in GCP](img/B21320_12_1.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – Salt instances in GCP
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also add a minion instance in AWS:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Salt instance in AWS](img/B21320_12_2.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – Salt instance in AWS
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can SSH into the `salt-master` instance and install the Salt master
    library:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![Figure 12.3 – Salt master version](img/B21320_12_3.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – Salt master version
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, install the Salt minion library in both of the minion instances using
    the following command:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![Figure 12.4 – Salt minion version](img/B21320_12_4.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – Salt minion version
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, go back to the Salt master and run the following command:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After we have done so, we will insert the following lines at the bottom to
    account for interfacing between the master and the minions:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Next, we will run `sudo systemctl start salt-master` to initialize the Salt
    master system module, then run the `sudo systemctl status salt-master` command
    to get the status of the Salt master. When we run the command, we get something
    like the following:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.5 – Running Salt master server](img/B21320_12_5.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: Figure 12.5 – Running Salt master server
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: That is a running Salt master; now, we need to configure our minions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps to configuring the minions are similar to those for the master, but
    with a few differences, as we will explore here:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 'On each minion, run `sudo nano /etc/salt/minion`, and in the `nano` file, enter
    the following:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Replace `salt_master_ip` with the IP of your Salt master server.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, run `sudo systemctl start salt-minion`, which will initialize the minion.
    Then, run `sudo systemctl status salt-minion` to check whether the minion is running:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.6 – Running Salt minion](img/B21320_12_6.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: Figure 12.6 – Running Salt minion
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, on the Salt master, you can run a little example command as follows:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: That’s the basics of it. Now, let’s move to the part where we look at the Python
    code a little closer.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break down a particular Salt module so that we can learn the intricacies
    behind it:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Each Salt module is a Python function that can be called. Let’s take one module
    as an example from the documentation, in this case, the one for network connections:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 12.7 – Salt module from\uFEFF the documentation](img/B21320_12_7.jpg)"
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: Figure 12.7 – Salt module from the documentation
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: This is great documentation! It shows you the function and the CLI version for
    it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the function:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'connect function. An equivalent in code would be as follows:'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These two commands are equivalent, but you can see the pragmatism in running
    them from the command line, as these commands are far more comfortable in that
    way than as functions.That stands true for a lot of command-line tools and is
    the reason that a lot of them exist in the first place.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Next, we will look at Ansible, which has a similar idea to execute but takes
    a slightly different approach while still using Python.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: How Ansible works and the Python code behind it
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lot of this section will be more of the same that you saw in the previous
    section, similar tools, similar implementations, and whatnot. But, like SaltStack,
    this too is an important and very common tool in the IaC realm, which is why it
    deserves the coverage that we are giving it. Ansible is powerful, its learning
    curve is probably not as steep as that of SaltStack, and it is easier on users
    who like more cleanly pre-packaged code that they don’t have to modify too much.
    Oh, and it’s also written in Python.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Ansible is run and maintained by IBM under its Red Hat label (I like that tech
    companies have their own *DC Vertigo*-esque labels for their more risque stuff
    now; it really makes the things I say about it being an art even more true). It
    is meant to maintain and affect servers using SSH key pairs to access those servers.
    That simplifies some things, such as when you control a server and all the associated
    servers are in the same **virtual private** **cloud** (**VPC**).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Ansible is a bit more flexible in terms of the OSs that you can control with
    it, but for this exercise, we will use old, reliable Ubuntu. With all that exposition
    out of the way, let’s get into the finicky details of Ansible and give you a little
    sample of how it works.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be reusing the same instances used during the Salt exercise for this,
    so let’s start with the master instance:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by using `pip` to install Ansible on the system:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![Figure 12.8 – Successful Ansible installation](img/B21320_12_8.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
- en: Figure 12.8 – Successful Ansible installation
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have done this, make a directory to use as the common Ansible configuration
    directory and go into it:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The next thing to do is to create an `inventory.ini` file, which will serve
    the same function as the master IP in SaltStack but in reverse, with the IPs of
    the servers being controlled and placed in the controlling server.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run `sudo nano inventory.ini`, which will create the inventory file, and place
    a list of IP addresses that you want to run in there:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, you can run the `ansible-inventory -i inventory.ini --list` command and
    this will give you the following list of hosts:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.9 - Ansible inventory](img/B21320_12_9.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
- en: Figure 12.9 - Ansible inventory
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you can ping these hosts to test your connection with the following command:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, you can run playbooks and runbooks through a centralized command server
    and you can even sort the hosts into fleets just by changing the inventory list.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Those are the basics of Ansible; now, let’s look a little deeper and find the
    Python behind the CLI as we did with SaltStack. We will do so by creating a custom
    module to use with Ansible. We’ll keep it local this time, but this is basically
    how you run custom operations with Ansible all the time.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s create a new Ansible module, custom-made by us:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'In the environment where you have installed Ansible, create a `hello_ansible.py`
    file and add the following code to it:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'That gives us the Python code that will be executed and now we need to change
    the Python code’s permissions into something executable. We do this by using the
    following command:'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we need to make a playbook to run the function locally, and for that,
    we can create a playbook called `hello.yml` and add some code to it:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, execute the YAML file:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This will give you a result as a string, shown as follows:'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: "![Figure 12.10 – Result of \uFEFFour Ansible module](img/B21320_12_10.jpg)"
  id: totrans-103
  prefs: []
  type: TYPE_IMG
- en: Figure 12.10 – Result of our Ansible module
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: That is how you create a customized Ansible module. This module will give you
    the sum of two strings that you put into it, perhaps the most basic operation
    that you can do with a module. But everything else is the same, even for more
    complex operations. Just replace `join_strings` in the code with the function
    of your choice and add the variables needed to execute that function and return
    the resulting value. Maybe, for example, it could be a function to restart a server
    or run a particular CLI command; it can be practically anything that you can do
    on a command line in the OS that you are using.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Now, even this is a little bit underpowered in terms of the resources that you
    can use and the way that you can use them. It is useful for more conventional
    systems, but for systems that require unconventional architectures, something
    like Terraform is better suited. We will now discuss how we can use Terraform
    with Python to automate IaC even further.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Automate the automation of IaC with Python
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IaC has grown in popularity and in ways that people have never imagined. The
    most popular IaC framework currently is arguably Terraform. Terraform doesn’t
    just work on servers and more solid resources of the like, it works on APIs and
    looser infrastructure as well. Basically, anything that you can use in any major
    cloud, there is a Terraform API to use it. Terraform is the ultimate automation
    tool in many ways, and it can be further automated with the help of Python.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Terraform is, of course, written in Go, which is great because Go is a very
    good complement to Python. One is good where the other lacks and vice versa. While
    Go is good for singular implementations, Python is great at multiplying the effectiveness
    of that implementation. Basically, Go is the bullet and Python is the gun, and
    that is an effective combination. We will use this combination to great effect
    in this section.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'HashiCorp, the creator of Terraform, has created APIs that allow Python to
    interact with Terraform. These APIs are packaged in the `cdktf` library published
    by HashiCorp in a number of languages. Let’s take a look at the steps we need
    to perform to install and run the `cdktf` library:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to first have NPM, NodeJS, and the Terraform CLI installed to install
    `cdktf-cli`:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, you can use the `cdktf` to create a Python environment:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This will create a new Python template, which can be used then to run a Terraform
    template. In the template, you can find the `main.py` file in the `stacks` folder.
    In the folder, you can add this script:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将创建一个新的 Python 模板，之后可以用来运行 Terraform 模板。在模板中，你可以在`stacks`文件夹中找到`main.py`文件。在该文件夹中，你可以添加以下脚本：
- en: '[PRE19]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This code is simple enough to understand; it works exactly like an IaC module
    would, creating an S3 bucket with the name given at the time of your execution
    of the program. To execute the program, run the following command:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码足够简单，易于理解；它的工作方式与 IaC 模块完全相同，在你执行程序时创建一个名称为指定名称的 S3 存储桶。要执行程序，运行以下命令：
- en: '[PRE20]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you want to revert the program and simply delete the resource that you created,
    you can just run the following command:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想撤销程序并仅删除你创建的资源，你只需运行以下命令：
- en: '[PRE21]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: That is basically all you need to do. The AWS, Google Cloud, and Azure modules
    for Terraform are usually included with the installation, as are the equivalent
    Python libraries when they are installed using `cdktf`. You can find the documentation
    for all of these libraries and what they do on HashiCorp’s GitHub and on its website.
    HashiCorp is very clear about the things that its products can do, even if it
    is sometimes difficult to collate all of that information in one place. So, using
    these references, you can practically create any resource you want; it is all
    up to your imagination.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上就是你需要做的所有事情。Terraform 的 AWS、Google Cloud 和 Azure 模块通常会随着安装一起提供，使用`cdktf`安装时，相应的
    Python 库也会包含在内。你可以在 HashiCorp 的 GitHub 和官方网站上找到这些库的文档以及它们的功能。HashiCorp 对其产品能做什么非常明确，尽管有时将所有这些信息整理到一个地方可能会有些困难。所以，通过这些参考资料，你几乎可以创建任何你想要的资源；一切都取决于你的想象力。
- en: Summary
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: So, that is the chapter, one that was a little more serious than the ones you
    might have been used to, but this is serious business. IaC is a concept to be
    taken seriously; it is very powerful and can be the solution to a lot of problems
    that require the application of DevOps principles.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这就是本章的内容，虽然比你可能习惯的章节要严肃一些，但这确实是严肃的事情。IaC 是一个值得认真对待的概念；它非常强大，可以解决许多需要应用 DevOps
    原则的问题。
- en: We initially looked at a very basic application of IaC using Python in SaltStack.
    It was quite rudimentary but very effective for simple projects. We closed it
    out by diving into the guts of SaltStack and understanding the logic behind its
    Python modules.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最初查看了使用 Python 在 SaltStack 中应用 IaC 的非常基础的案例。它虽然相当基础，但对于简单项目来说非常有效。我们通过深入了解
    SaltStack 的内部原理，理解了它 Python 模块背后的逻辑。
- en: After that, we looked at the slightly more flexible Ansible and discovered all
    of the conveniences that it provides as well as the customization possibilities.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们查看了稍微灵活一些的 Ansible，发现了它所提供的所有便利功能以及自定义的可能性。
- en: Lastly, we looked at Terraform and `cdktf`, which is used with Python Terraform
    and resource modules in order to perform Terraform’s resource creation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们看了 Terraform 和`cdktf`，它与 Python Terraform 及资源模块一起使用，用于执行 Terraform 的资源创建。
- en: All of this has hopefully helped you gain a new perspective on IaC and allowed
    you to understand its importance in DevOps and its integration with Python.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些内容希望能够帮助你获得一个新的视角，了解 IaC，并理解它在 DevOps 中的重要性以及它与 Python 的集成。
- en: In conclusion, IaC is powerful, vast, and useful to learn. In the next chapter,
    we will take all that you have learned here and in the previous chapters, and
    raise it all to a higher level.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，IaC 是强大的、广阔的，且值得学习。在下一章中，我们将把你在这里和前几章学到的所有内容提升到一个更高的层次。
