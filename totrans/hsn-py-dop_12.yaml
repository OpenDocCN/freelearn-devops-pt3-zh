- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How Python Integrates with IaC Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Never measure the height of a mountain until you have reached the top. Then
    you will see how low it was.
  prefs: []
  type: TYPE_NORMAL
- en: – Dag Hammarskjöld
  prefs: []
  type: TYPE_NORMAL
- en: So, as we approach this penultimate chapter, we get to the topic of **Infrastructure
    as Code** (**IaC**). It is quite the topic, indeed, one that has taken the IT
    world by storm. It is a response to the fact that there are now more resources
    available for applications and workloads than there ever were before and the only
    thing left to do is arrange them in the most optimal way. Sure, you might find
    a way to do this once manually and it might work. But having to do it over and
    over again with a guarantee that you won’t make mistakes? That’s foolish talk
    and a waste of manpower.
  prefs: []
  type: TYPE_NORMAL
- en: So, based on these observations, the concept of IaC emerged. It posited that
    if resource creation, provisioning, and updating were standardized in the form
    of code with constants and variables arranged in an organized way, you could standardize
    the replication of resources, making things such as backups, failovers, re-deployments
    and a whole lot of other operations activities easier.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, IaC has its detractors, because all good technology does. They believe
    that it is too fast, too powerful, capable of running up your cloud bill and putting
    up resources that become too hard to untangle and are not as easily customizable.
  prefs: []
  type: TYPE_NORMAL
- en: It’s an interesting thought, but when I look at IaC, I am reminded of the initial
    passage in Adam Smith’s *Wealth of Nations* where he talks about how the division
    of labor increases production more than any other factor. IaC concepts do the
    same, where the labor (resources) is separated from the schematics that build
    them, allowing them to be produced over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: Python as a language has been very friendly towards IaC, perhaps the second-most
    behind Go. There are a lot of native IaC libraries and stacks in Python (which
    we will cover), in addition to modules and APIs to interact with IaC tools not
    written in Python. The flexibility of Python and the desire for loose, yet strict
    replication that comes with IaC allowed Python to become such a huge part of the
    growing IaC trend.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will help you with a concept in IaC that is considered unique
    to DevOps, one that was created to fuel the constant need for automation and standardization
    in a DevOps workload. It will help you understand why DevOps and coding need to
    be so closely related to each other. That is why, in this chapter, you will learn
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics of **SaltStack** and how it is built in Python along with how to
    evaluate SaltStack modules at the code and command-line levels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The basics of **Ansible** and how to create your own automated Ansible module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How you can use Python to interact with other IaC tools, such as Terraform,
    to add automation on top of already built automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to pursue this chapter to its logical conclusion, you will need to
    fulfill a few technical requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Installation of Python with the **Salt library** and Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installation of NPM and NodeJS with `cdktf`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installation of Terraform CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An AWS and a GCP account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A GitHub account to retrieve the repository for this book ([https://github.com/PacktPublishing/Hands-On-Python-for-DevOps](https://github.com/PacktPublishing/Hands-On-Python-for-DevOps))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A significant amount of patience and understanding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automation and customization with Python’s Salt library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We talk about all of these fancy architectures and frameworks that we want to
    make; we talk about all of these different tools that we want to use, all of these
    workflows, and they are fun. They are very exciting, but the thing that a lot
    of DevOps still boils down to is server management; the Ops side of DevOps. It
    is still important and relevant in today’s world and will be for as long as people
    use it, which is likely forever.
  prefs: []
  type: TYPE_NORMAL
- en: Server management in the modern day requires the creation of modern, custom
    environments based on the requirements of the application being hosted. It also
    requires a lot of automation features to be maintained and to stay in an optimized
    state based on present circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: The radio was never replaced by the television, and television in turn probably
    won’t be replaced by streaming completely. Everything changes, evolves, or reduces
    down, but the thing itself and the skills needed to use it will be relevant in
    one way or another. This is why the tools for server management will always be
    there and they will evolve.
  prefs: []
  type: TYPE_NORMAL
- en: That’s what the Salt library (used interchangeably with SaltStack) is used for.
    In essence, it consists of a central server that can be used to send commands
    to all servers connected to it. The requirements are that the minion (server to
    be managed) is configured to receive commands from the master (server that does
    the managing). It’s a pretty simple concept, executed using only the finest Python
    code.
  prefs: []
  type: TYPE_NORMAL
- en: So, let’s get into it. We will start with the installation of a Salt server
    and a minion, and then, we will see how we can customize the Python code that
    comprises Salt if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The architecture of the Salt library consists of, as we said, a master and
    several minions. So, let’s start by creating servers that mirror this configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create one master server and a minion in GCP, and one minion in AWS
    to show cross-cloud functionality. For this exercise, we are using Ubuntu as our
    primary **operating system** (**OS**), but other OSs will work just as well. We
    will make a minion and a master Salt instance in GCP:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.1 – Salt instances in GCP](img/B21320_12_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – Salt instances in GCP
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also add a minion instance in AWS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.2 – Salt instance in AWS](img/B21320_12_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – Salt instance in AWS
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can SSH into the `salt-master` instance and install the Salt master
    library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 12.3 – Salt master version](img/B21320_12_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – Salt master version
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, install the Salt minion library in both of the minion instances using
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 12.4 – Salt minion version](img/B21320_12_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – Salt minion version
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, go back to the Salt master and run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After we have done so, we will insert the following lines at the bottom to
    account for interfacing between the master and the minions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will run `sudo systemctl start salt-master` to initialize the Salt
    master system module, then run the `sudo systemctl status salt-master` command
    to get the status of the Salt master. When we run the command, we get something
    like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.5 – Running Salt master server](img/B21320_12_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.5 – Running Salt master server
  prefs: []
  type: TYPE_NORMAL
- en: That is a running Salt master; now, we need to configure our minions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps to configuring the minions are similar to those for the master, but
    with a few differences, as we will explore here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On each minion, run `sudo nano /etc/salt/minion`, and in the `nano` file, enter
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Replace `salt_master_ip` with the IP of your Salt master server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Then, run `sudo systemctl start salt-minion`, which will initialize the minion.
    Then, run `sudo systemctl status salt-minion` to check whether the minion is running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.6 – Running Salt minion](img/B21320_12_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.6 – Running Salt minion
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, on the Salt master, you can run a little example command as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That’s the basics of it. Now, let’s move to the part where we look at the Python
    code a little closer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break down a particular Salt module so that we can learn the intricacies
    behind it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Each Salt module is a Python function that can be called. Let’s take one module
    as an example from the documentation, in this case, the one for network connections:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: "![Figure 12.7 – Salt module from\uFEFF the documentation](img/B21320_12_7.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 12.7 – Salt module from the documentation
  prefs: []
  type: TYPE_NORMAL
- en: This is great documentation! It shows you the function and the CLI version for
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'connect function. An equivalent in code would be as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These two commands are equivalent, but you can see the pragmatism in running
    them from the command line, as these commands are far more comfortable in that
    way than as functions.That stands true for a lot of command-line tools and is
    the reason that a lot of them exist in the first place.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we will look at Ansible, which has a similar idea to execute but takes
    a slightly different approach while still using Python.
  prefs: []
  type: TYPE_NORMAL
- en: How Ansible works and the Python code behind it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A lot of this section will be more of the same that you saw in the previous
    section, similar tools, similar implementations, and whatnot. But, like SaltStack,
    this too is an important and very common tool in the IaC realm, which is why it
    deserves the coverage that we are giving it. Ansible is powerful, its learning
    curve is probably not as steep as that of SaltStack, and it is easier on users
    who like more cleanly pre-packaged code that they don’t have to modify too much.
    Oh, and it’s also written in Python.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible is run and maintained by IBM under its Red Hat label (I like that tech
    companies have their own *DC Vertigo*-esque labels for their more risque stuff
    now; it really makes the things I say about it being an art even more true). It
    is meant to maintain and affect servers using SSH key pairs to access those servers.
    That simplifies some things, such as when you control a server and all the associated
    servers are in the same **virtual private** **cloud** (**VPC**).
  prefs: []
  type: TYPE_NORMAL
- en: Ansible is a bit more flexible in terms of the OSs that you can control with
    it, but for this exercise, we will use old, reliable Ubuntu. With all that exposition
    out of the way, let’s get into the finicky details of Ansible and give you a little
    sample of how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be reusing the same instances used during the Salt exercise for this,
    so let’s start with the master instance:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by using `pip` to install Ansible on the system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 12.8 – Successful Ansible installation](img/B21320_12_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.8 – Successful Ansible installation
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have done this, make a directory to use as the common Ansible configuration
    directory and go into it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next thing to do is to create an `inventory.ini` file, which will serve
    the same function as the master IP in SaltStack but in reverse, with the IPs of
    the servers being controlled and placed in the controlling server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run `sudo nano inventory.ini`, which will create the inventory file, and place
    a list of IP addresses that you want to run in there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you can run the `ansible-inventory -i inventory.ini --list` command and
    this will give you the following list of hosts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.9 - Ansible inventory](img/B21320_12_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.9 - Ansible inventory
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you can ping these hosts to test your connection with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, you can run playbooks and runbooks through a centralized command server
    and you can even sort the hosts into fleets just by changing the inventory list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Those are the basics of Ansible; now, let’s look a little deeper and find the
    Python behind the CLI as we did with SaltStack. We will do so by creating a custom
    module to use with Ansible. We’ll keep it local this time, but this is basically
    how you run custom operations with Ansible all the time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s create a new Ansible module, custom-made by us:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the environment where you have installed Ansible, create a `hello_ansible.py`
    file and add the following code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That gives us the Python code that will be executed and now we need to change
    the Python code’s permissions into something executable. We do this by using the
    following command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to make a playbook to run the function locally, and for that,
    we can create a playbook called `hello.yml` and add some code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, execute the YAML file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will give you a result as a string, shown as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: "![Figure 12.10 – Result of \uFEFFour Ansible module](img/B21320_12_10.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 12.10 – Result of our Ansible module
  prefs: []
  type: TYPE_NORMAL
- en: That is how you create a customized Ansible module. This module will give you
    the sum of two strings that you put into it, perhaps the most basic operation
    that you can do with a module. But everything else is the same, even for more
    complex operations. Just replace `join_strings` in the code with the function
    of your choice and add the variables needed to execute that function and return
    the resulting value. Maybe, for example, it could be a function to restart a server
    or run a particular CLI command; it can be practically anything that you can do
    on a command line in the OS that you are using.
  prefs: []
  type: TYPE_NORMAL
- en: Now, even this is a little bit underpowered in terms of the resources that you
    can use and the way that you can use them. It is useful for more conventional
    systems, but for systems that require unconventional architectures, something
    like Terraform is better suited. We will now discuss how we can use Terraform
    with Python to automate IaC even further.
  prefs: []
  type: TYPE_NORMAL
- en: Automate the automation of IaC with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: IaC has grown in popularity and in ways that people have never imagined. The
    most popular IaC framework currently is arguably Terraform. Terraform doesn’t
    just work on servers and more solid resources of the like, it works on APIs and
    looser infrastructure as well. Basically, anything that you can use in any major
    cloud, there is a Terraform API to use it. Terraform is the ultimate automation
    tool in many ways, and it can be further automated with the help of Python.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform is, of course, written in Go, which is great because Go is a very
    good complement to Python. One is good where the other lacks and vice versa. While
    Go is good for singular implementations, Python is great at multiplying the effectiveness
    of that implementation. Basically, Go is the bullet and Python is the gun, and
    that is an effective combination. We will use this combination to great effect
    in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'HashiCorp, the creator of Terraform, has created APIs that allow Python to
    interact with Terraform. These APIs are packaged in the `cdktf` library published
    by HashiCorp in a number of languages. Let’s take a look at the steps we need
    to perform to install and run the `cdktf` library:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to first have NPM, NodeJS, and the Terraform CLI installed to install
    `cdktf-cli`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, you can use the `cdktf` to create a Python environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will create a new Python template, which can be used then to run a Terraform
    template. In the template, you can find the `main.py` file in the `stacks` folder.
    In the folder, you can add this script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This code is simple enough to understand; it works exactly like an IaC module
    would, creating an S3 bucket with the name given at the time of your execution
    of the program. To execute the program, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you want to revert the program and simply delete the resource that you created,
    you can just run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That is basically all you need to do. The AWS, Google Cloud, and Azure modules
    for Terraform are usually included with the installation, as are the equivalent
    Python libraries when they are installed using `cdktf`. You can find the documentation
    for all of these libraries and what they do on HashiCorp’s GitHub and on its website.
    HashiCorp is very clear about the things that its products can do, even if it
    is sometimes difficult to collate all of that information in one place. So, using
    these references, you can practically create any resource you want; it is all
    up to your imagination.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, that is the chapter, one that was a little more serious than the ones you
    might have been used to, but this is serious business. IaC is a concept to be
    taken seriously; it is very powerful and can be the solution to a lot of problems
    that require the application of DevOps principles.
  prefs: []
  type: TYPE_NORMAL
- en: We initially looked at a very basic application of IaC using Python in SaltStack.
    It was quite rudimentary but very effective for simple projects. We closed it
    out by diving into the guts of SaltStack and understanding the logic behind its
    Python modules.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we looked at the slightly more flexible Ansible and discovered all
    of the conveniences that it provides as well as the customization possibilities.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we looked at Terraform and `cdktf`, which is used with Python Terraform
    and resource modules in order to perform Terraform’s resource creation.
  prefs: []
  type: TYPE_NORMAL
- en: All of this has hopefully helped you gain a new perspective on IaC and allowed
    you to understand its importance in DevOps and its integration with Python.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, IaC is powerful, vast, and useful to learn. In the next chapter,
    we will take all that you have learned here and in the previous chapters, and
    raise it all to a higher level.
  prefs: []
  type: TYPE_NORMAL
