["```\n// Read from an I/O stream.\ntype Reader interface {\n     Read(p []byte) (n int, err error)\n}\n// Write to an I/O stream.\ntype Writer interface {\n     Write(p []byte) (n int, err error)\n}\n// Seek to a certain spot in the I/O stream.\ntype Seeker interface {\n     Seek(offset int64, whence int) (int64, error)\n}\n// Close the I/O stream.\ntype Closer interface {\n     Close() error\n}\n```", "```\ndata, err := os.ReadFile(\"path/to/file\")\n```", "```\nif err := os.WriteFile(“path/to/fi”, data, 0644); err != nil {\n     return err\n}\n```", "```\nclient := &http.Client{}\nreq, err := http.NewRequest(\"GET\", \"http://myserver.mydomain/myfile\", nil)\nif err != nil {\n        return err\n}\nreq = req.WithContext(ctx) \nresp, err := client.Do(req) \ncancel()\nif err != nil {\n        return err\n}\n// resp contains an io.ReadCloser that we can read as a file. \n// Let's use io.ReadAll() to read the entire content to data. \ndata, err := io.ReadAll(resp.Body) \n```", "```\nflags := os.O_CREATE|os.O_WRONLY|os.O_TRUNC\nf, err := os.OpenFile(\"path/to/file\", flags, 0644)\nif err != nil {\n     return err\n}\ndefer f.Close() \nif err := io.Copy(f, resp.Body); err != nil { \n    return err \n} \n```", "```\nf, err := os.Open(\"path/to/file\")\nif err != nil {\n     return err\n}\nif err := io.Copy(os.Stdout, f); err != nil {\n     return err\n}\n```", "```\ntype User struct{\n  Name string\n  ID int\n}\n```", "```\nfunc getUser(s string) (User, error) {\n     sp := strings.Split(s, \":\")\n     if len(sp) != 2 {\n          return User{}, fmt.Errorf(\"record(%s) was not in the correct format\", s)\n    } \n    id, err := strconv.Atoi(sp[1]) \n     if err != nil {\n          return User{}, fmt.Errorf(\"record(%s) had non-numeric ID\", s)\n     }\n     return User{Name: strings.TrimSpace(sp[0]), ID: id}, nil\n}\n```", "```\nfunc decodeUsers(ctx context.Context, r io.Reader) chan User {\n     ch := make(chan User, 1)\n     go func() {\n          defer close(ch)\n          scanner := bufio.NewScanner(r)\n          for scanner.Scan() {\n               if ctx.Err() != nil {\n                    ch <- User{err: ctx.Err()}\n                    return\n               }\n               u, err := getUser(scanner.Text())\n               if err != nil {\n                    u.err = err\n                    ch <- u\n                    return\n               }\n               ch <- u\n          }\n     }()\n     return ch\n}\n```", "```\nf, err := os.Open(\"path/to/file/with/users\")\nif err != nil {\n     return err\n}\ndefer f.Close()  \nfor user := range decodeUsers(ctx, f) {\n     if user.err != nil {\n          fmt.Println(\"Error: \", user.err)\n          return err\n     }\n     fmt.Println(user)\n}\n```", "```\nfunc writeUser(ctx context.Context, w io.Writer, u User) error {\n     if ctx.Err() != nil {\n          return ctx.Err()\n     }\n     if _, err := w.Write([]byte(user.String())); err != nil {\n          return err\n     }\n     return nil\n}\n```", "```\nf, err := os.OpenFile(\"file\", flags, 0644); err != nil{\n     return err\n}\ndefer f.Close() \nfor i, u := range users {\n     // Write a carriage return before the next entry, except\n     // the first entry.\n     if i != 0 {\n          if err := w.Write([]byte(\"\\n\")); err != nil {\n               return err\n          }\n     }\n     if err := writeUser(ctx, w, u); err != nil {\n          return err\n     }\n}\n```", "```\nfmt.Println(runtime.GOOS) // linux, darwin, ...\nfmt.Println(runtime.GOARCH) // amd64, arm64, ...\n```", "```\nwd, err := os.Getwd() \nif err != nil { \n    return err \n} \ncontent, err := os.ReadFile(filepath.Join(wd, \"config\", \"config.json\"))\n```", "```\nfileName := filepath.Base(fp) \nif fileName == \".\" { \n    // Path is empty \n    return nil \n}\nnewPath := filepath.Join(os.TempDir(), fileName) \n\nr, err := os.Open(fp) \nif err != nil { \n    return err \n}\ndefer r.Close() \n\nw, err := os.OpenFile(newPath, O_WRONLY | O_CREATE, 0644) \nif err != nil { \n    return err \n}\ndefer w.Close()\n// Copies the file to the temporary file.\n_, err := io.Copy(w, r)\nreturn err\n```", "```\ntype FS interface {\n     Open(name string) (File, error)\n}\n```", "```\ntype File interface {\n     Stat() (FileInfo, error)\n     Read([]byte) (int, error)\n     Close() error\n}\n```", "```\nimport _ \"embed\" \n//go:embed hello.txt\nvar s string\n//go:embed world.txt\nvar b []byte\n```", "```\n// The lines beginning with //go: are not comments, but compiler directives\n//go:embed image/*\n//go:embed index.html\nvar content embed.FS\n```", "```\nerr := fs.WalkDir(\n     content,\n     \".\",\n     func(path string, d fs.DirEntry, err error) error {\n          if err != nil {\n               return err\n          }\n          if !d.IsDir() && filepath.Ext(path) == \".jpg\" {\n               fmt.Println(\"jpeg file: \", path)\n          }\n          return nil\n     },\n)\n```"]