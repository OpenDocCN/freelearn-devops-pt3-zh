- en: '*Chapter 2*: Essential Skills for a DevOps Practitioner'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most common question heard from individuals looking to land their first
    DevOps role is, *What are the important skills?* The list of important skills
    is rather lengthy for a DevOps generalist, the type of role most common for individuals
    looking for their first role in DevOps. This chapter is geared toward individuals
    looking for their first role in DevOps. Individuals who already have careers in
    DevOps can skip this chapter or use it as a refresher.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Scripting, coding, and programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source code management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Infrastructure management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CI/CD concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Soft skills
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cloud-native frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beginner DevOps certifications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripting, coding, and programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are DevOps engineers who are highly skilled at programming. However,
    you don''t have to be a great programmer. To be a great DevOps engineer, debugging
    code, automation through scripting, and working in text-only terminals are also
    important skills. In this section, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigating the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying legacy code versus writing new code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating the command line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Command-line navigation is possibly the most essential skill for anyone looking
    to get a job in the field of DevOps. Command line is a generic term that applies
    to a text-based interface. The most common command-line shell that comes with
    most Linux distributions is **Bash**. While having a basic knowledge of the usage
    of the command line is essential to land a job as a DevOps engineer, mastery of
    it can help you stand apart from other applicants. There is no way to master the
    terminal without making it a part of your regular daily routine. There are many
    well-written, resourceful blogs, articles, and cheat sheets that cover the command
    syntax. The focus of this section will be on techniques to quickly improve your
    comfort level when using the command line.
  prefs: []
  type: TYPE_NORMAL
- en: All navigation can be done through the command line and it is often much quicker.
    Even if you're not sure where you are, `pwd` will output the current path you
    are at in the terminal. If you would like to see what files and folders are in
    the current directory, use the `ls` command. To navigate to a particular folder,
    use the `cd` command. If you want to find a particular string of text in a text
    file, you can use the `grep` command. `grep` is case sensitive by default, but
    like most commands, there are flags that can be applied to change its behavior;
    for example, `grep - i` makes the search insensitive to case. If there are multiple
    results, you can pipe your results with `sort` to sort the results alphabetically,
    or even in reverse order.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2.1* shows the Bashterminal window, where some basic commands have
    been executed and output can be seen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Bash terminal with basic commands'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.01_B18117.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – Bash terminal with basic commands
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding Bash terminal, there are some unique colors,
    the current directory is preceded by an arrow, and the branch that is checked
    out is shown for `git` folders. You can configure the appearance as well as setting
    aliases and custom functions within the `.bashrc` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pro Tip: Play Around and Have Fun'
  prefs: []
  type: TYPE_NORMAL
- en: Learning about the terminal should be fun, and we will expand on it in the next
    section. Till then, google commands, create your own, and be creative! The power
    of the terminal comes from its flexibility; the terminal can be customized to
    fit your needs and most of this customization is done through the `.bashrc` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `.bashrc` file is the central area to set up aliases, functions, and customize
    the look and feel of your terminal. The `.bashrc` file is a shell script that
    loads when the terminal is loaded. If you are using Bash, you will have a `.bashrc`
    file, and a `.zshrc` file if you are using `zsh`. Within the `.bashrc` file, it
    is possible to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Load modules:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify an environment variable:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Activate a Python environment:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set aliases:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Aliases are nicknames for commands, groups of commands, or scripts and can
    be added to the `.bashrc` file. Aliases are often created to make commonly used
    commands shorter. It is best practice to add aliases to a separate file called
    `.bash_aliases`, and then load `.bash_aliases` into `.bashrc`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If your list of aliases is short, you can add them directly to the `.bashrc`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Aliases can also be used to call functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Another useful skill all DevOps engineers should have, and master, is the use
    of text editors within the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Text editors are command-line tools that allow you to directly edit files from
    the terminal window. Common flavors are vim, emacs, and nano. Most Linux distributions
    have vim installed by default. In the following example, we will show you how
    to edit your `.bashrc` file. To open your file in `vi`, type `vi </path/to/file>`.
    In the following example, the command was `sudo vi .zshrc`, which opens the .`zshrc`
    file in `vim` with sudo privileges:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Bash terminal with the vi editor open'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.02_B18117.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – Bash terminal with the vi editor open
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the file is opened in read-only mode. To enter edit mode, type
    *I*. To make your change, enter *esc* followed by *w* to save the file and *q*
    to close the editor.
  prefs: []
  type: TYPE_NORMAL
- en: Text editors are powerful but require some time to be mastered. If you need
    information on `vi` commands, you can find great resources on various online forums.
    A particular favorite of mine is [https://ryanstutorials.net/linuxtutorial/cheatsheetvi.php](https://ryanstutorials.net/linuxtutorial/cheatsheetvi.php).
  prefs: []
  type: TYPE_NORMAL
- en: Scripting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scripts are something DevOps engineers must be capable of creating and maintaining.
    The secret to getting a DevOps job is being able to solve scripting problems,
    which means practice. There are several scripting languages currently used by
    DevOps engineers. No one of them is better than another; instead, each of them
    is best suited for distinct types of jobs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pro Tip: Google Is Your Best Friend when Learning a New Language'
  prefs: []
  type: TYPE_NORMAL
- en: If you are struggling with something, chances are someone else has already struggled
    with it, solved it, and written about it. Don't work harder; instead, work smarter
    and more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Python is heavily used in infrastructure automation and provisioning and has
    become an all-purpose scripting language in DevOps. It is favored by many because
    it is easy to get started with. However, it gets exponentially more difficult
    as your proficiency progresses. The following is the most basic Python script
    (`helloworld.py`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – hello_world.py'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.03_B18117.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 – hello_world.py
  prefs: []
  type: TYPE_NORMAL
- en: Bash
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Bash is the most used scripting language in the Unix/Linux environment and
    has a strong community that provides support. It is used to automate Linux servers
    around the world. The following is the most basic shell script (`helloworld.sh`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – hello_world.sh'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.04_B18117.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.4 – hello_world.sh
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'JavaScript is used as DevOps scripting to create network-centric applications.
    It is a lightweight DevOps scripting Language. JavaScript offers numerous advantages,
    including less server interaction, increased interactivity, immediate feedback
    to visitors, and richer interfaces. The following is the most basic JavaScript
    script (`helloworld.js`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – hello_world.sh'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.05_B18117.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.5 – hello_world.sh
  prefs: []
  type: TYPE_NORMAL
- en: Go
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Go was introduced in 2009 and has drastically changed the DevOps landscape
    since its inception. Built on C, Go was created to be readable by humans and scalable.
    The following is the most basic Go script:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – hello_world.go'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.06_B18117.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.6 – hello_world.go
  prefs: []
  type: TYPE_NORMAL
- en: 'Pro Tip: Focus on Learning One Language at a Time'
  prefs: []
  type: TYPE_NORMAL
- en: You set yourself up for disappointment if you try to learn multiple coding languages
    simultaneously. Unless circumstances require you to learn a new language, get
    proficiency in one language before moving on to the next.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are tons of books and online resources you can choose from when learning
    new languages. A great way to practice is forking a project from GitHub and making
    changes to it. This is some of the most useful experience you can give yourself.
    If you would like to challenge yourself, you can try online sites designed specifically
    to prepare users for technical interviews, also offering a great way to upskill
    your coding game. Here are a couple of favorites:'
  prefs: []
  type: TYPE_NORMAL
- en: 'LeetCode: [https://leetcode.com/](https://leetcode.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'AlgoExpert: [https://www.algoexpert.io/](https://www.algoexpert.io/)'
  prefs: []
  type: TYPE_NORMAL
- en: Other sites built around the type of problems you may see in an interview exist.
    Coding challenge sites can also help tremendously to increase your chances of
    success.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have covered various scripting languages, we need to cover when
    to modify existing code and when to write new code.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned about navigating text-based shells such as Bash,
    as well as how to modify existing files and create files using text editors within
    a shell. We also covered various scripting languages used by DevOps engineers
    and the best use cases for each.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will cover version control and source code management.
  prefs: []
  type: TYPE_NORMAL
- en: Source code management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`git`.'
  prefs: []
  type: TYPE_NORMAL
- en: Git
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An astounding 87% of developers use `git` as their version control. Git is
    a distributed version control software initially designed by Linus Torvalds to
    manage the Linux kernel. The difference between `git` and `svn` is that the complete
    code history is stored on each individual node when using `git` versus a single
    source server when using `svn`. There are several things to consider when learning
    `git`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`git` versions available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting Started with Git
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Windows: [https://gitforwindows.org/](https://gitforwindows.org/)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'macOS: [https://git-scm.com/download/mac](https://git-scm.com/download/mac)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Linux: [https://git-scm.com/download/linux](https://git-scm.com/download/linux)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Second**: There are multiple branching strategies. It is recommended that
    you spend time learning and practice managing your own projects using various
    strategies. Some common strategies are defined as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/Figure_2.07_B18117.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Basic git workflow
  prefs: []
  type: TYPE_NORMAL
- en: The basic `git` workflow has one branch, the main or *Master* branch. Developers
    commit directly to this branch and all deployments, regardless of the environment,
    are made from this branch. This is a workflow that is not recommended unless you
    need to get set up quickly or are working on a private side project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram is a graphical representation of the `git` feature branch
    workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Git feature branch workflow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.08_B18117.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.8 – Git feature branch workflow
  prefs: []
  type: TYPE_NORMAL
- en: The `git` feature branch workflow becomes necessary whenever there is more than
    one person working from the same code base. Both feature *A* and feature *B* can
    be created without the worry of affecting the other's ability to merge back to
    the *Master* branch.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Git feature branch workflow with a Develop branch'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.09_B18117.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.9 – Git feature branch workflow with a Develop branch
  prefs: []
  type: TYPE_NORMAL
- en: The `git` feature workflow with the *Develop* branch is one of the most popular
    branching strategies. The *Master* branch is always in a state that is ready to
    be deployed to production, and developers can work on their own features without
    worrying about merge conflicts from other developers.
  prefs: []
  type: TYPE_NORMAL
- en: '`git` commands and there is no way to memorize them all. We have included two
    approaches to help you feel more confident when starting out.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add commonly used `git` commands as aliases to your `.bash_profile` file. The
    following is a snippet of code that can be added to your `.bashrc` file that combines
    three commands associated with `git` into a single `gp` alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Git function example for .bashrc'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.10_B18117.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.10 – Git function example for .bashrc
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding `gp` alias takes two parameters: `$1=file,` or the path of files
    to the stage, and `$2=commit message`. The following output shows what is seen
    when you execute the `gp` alias. Let''s break this down:'
  prefs: []
  type: TYPE_NORMAL
- en: '`shell_favorites` is a local working directory tracked by `git`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `git stage` command moves `README.md` into the local staging area.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `git commit –m` command commits the `README.md` file to the local repository
    with a commit message, which is `test100721` in our example.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `git push` command pushes the changes that are in your local repository
    to the remote repository that `shell_favorites` is tracked to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following figure, you can see the output the `gp` alias would result
    in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – git push terminal output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.11_B18117.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.11 – git push terminal output
  prefs: []
  type: TYPE_NORMAL
- en: Pretty sweet, no? Adding `git` aliases won't make you a better developer but
    it can simplify your life.
  prefs: []
  type: TYPE_NORMAL
- en: 'My next secret to success with `git` for beginners is having a list of commonly
    used `git` commands close at hand at all times – a `git` cheat sheet. A favorite
    of mine is the one by the education group of GitHub: [https://education.github.com/git-cheat-sheet-education.pdf](https://education.github.com/git-cheat-sheet-education.pdf).'
  prefs: []
  type: TYPE_NORMAL
- en: SCM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Popular SCM tools include GitHub, GitL[ab, and Bitbucket.](https://www.github.com)
  prefs: []
  type: TYPE_NORMAL
- en: '[Gi](https://www.github.com)tHub: [https://www.github.com](https://www.github.com)'
  prefs: []
  type: TYPE_NORMAL
- en: 'GitLab: [https://about.gitlab.com/](https://about.gitlab.com/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Bitbucket: [https://bitbucket.org/](https://bitbucket.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: Each of these SCM tools has unique features to help improve developers' experiences
    and are designed to be user-friendly and easy to use. The reason these solutions
    tend to be easy to use is the rich UI each has developed for the user. You can
    use any of these tools for free by signing up on their websites! Regardless of
    the SCM tool you choose, the version control is still `git`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following table, we will compare the three most popular SCM tools available
    as of 2021:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 2.1 – SCM comparison'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.Table_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 2.1 – SCM comparison
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the day, there really is no bad choice as long as you are learning.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned about `git`, common `git` patterns, and common
    `git` commands. We also discussed options available for source code management
    software.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn about infrastructure tools and techniques
    needed to be successful as a DevOps engineer.
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Gartner defines IT infrastructure this way:'
  prefs: []
  type: TYPE_NORMAL
- en: IT infrastructure is the system of hardware, software, facilities, and service
    components that support the delivery of business systems and IT-enabled processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Infrastructure management can be broken down into three key stages: *capacity
    planning*, *infrastructure provisioning*, and *deployment,* as can be seen in
    the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – Infrastructure management stages'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.12_B18117.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.12 – Infrastructure management stages
  prefs: []
  type: TYPE_NORMAL
- en: The first stage in infrastructure management is capacity planning, which will
    be covered next.
  prefs: []
  type: TYPE_NORMAL
- en: Capacity planning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Capacity planning is the first step in infrastructure management and is followed
    by provisioning and deployment. Several tools can help with collecting the data
    needed to accurately plan resources as collecting accurate data is crucial to
    do so. Tools used during capacity planning are Splunk, the **ELK** (**Elasticsearch,
    Logstash, Kibana**) Stack, and New Relic. Continuous capacity planning is required
    to scale up and scale down resources based on demand in production.
  prefs: []
  type: TYPE_NORMAL
- en: Auto-scaling resources have two benefits, cost savings and better performance.
    When a resource is scaled down, it is removed from usage, which means it no longer
    incurs charges. When resources are scaled up, additional resources are added before
    performance degradation occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Infrastructure provisioning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After capacity numbers are successfully collected and analyzed, we can move
    on to infrastructure provisioning. Provisioning involves the creation, allocation,
    and deletion of infrastructure resources based on the derived capacity numbers
    from capacity planning. Infrastructure resources include servers, containers,
    storage, networks, IPs, and load balancers that can be created and managed on
    cloud service providers such as AWS, Azure, GCP, or on-premises.
  prefs: []
  type: TYPE_NORMAL
- en: A DevOps engineer needs to know how to manage infrastructure resources in the
    cloud and on-premises environments depending on the company's architecture. In
    the following examples, you will be shown boilerplate code for creating AWS EC2
    instances using CloudFormation, Terraform, and Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the organization is managing resources on AWS, then AWS CloudFormation may
    be used to automate the creation/allocation/deletion of infrastructure resources.
    The following is a boiler template for CloudFormation used to provision an EC2
    instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13 – CloudFormation example'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.13_B18117.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.13 – CloudFormation example
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn more about CloudFormation, visit [https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/Welcome.html](https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/Welcome.html).
    If your organization is managing resources across multiple cloud services, providers
    such as AWS, Azure, GCP, and Terraform can be used to automate the creation/allocation/deletion
    of infrastructure resources. The following is a Terraform file that could be used
    to provide an EC2 instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14 – Terraform example'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.14_B18117.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.14 – Terraform example
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible can also be used to provide resources spread across various environments
    both on-premises and in the cloud. The following example will create an EC2 instance
    with the following variables passed in: `MY_KEY`, `EC2_TYPE`, `IMAGE`, `GROUP`,
    `COUNT`, and `VPC_SUBNET`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15 – Ansible example'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.15_B18117.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.15 – Ansible example
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will talk about deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After infrastructure has been provisioned, proceed to the deployment stage.
    Deployment involves installing, configuring, releasing, and managing software
    services on the servers or containers that serve the production workload. Deployment
    is a process that occurs within the servers or containers that are created or
    allocated during the automated provisioning of infrastructure resources. A DevOps
    engineer can use automation tools such as Chef, Ansible, and Salt to automate
    the deployment of software services.
  prefs: []
  type: TYPE_NORMAL
- en: CI/CD concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Continuous Integration** (**CI**) and **Continuous Delivery** (**CD**) are
    synonymous with DevOps. This is because every practice discussed in [*Chapter
    1*](B18117_01_ePub.xhtml#_idTextAnchor013), *Career Paths* – plan, code, build,
    test, release, deploy, and operate – is included in the infinite CI/CD loop, as
    shown in *Figure 2.16*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.16 – Infinite CI/CD loop'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.16_B18117.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.16 – Infinite CI/CD loop
  prefs: []
  type: TYPE_NORMAL
- en: Let's first examine CI and the related practices and tools associated with it.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Continuous integration is the process of merging code changes from multiple
    developers into a single branch on a regular and frequent basis. To do this effectively,
    you need some form of automation that builds your code and executes a battery
    of tests against it. CI servers help to effectively integrate your code using
    CI pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: 'After a developer makes a change, code changes are committed to a source code
    management system by using `git`. The CI server has a built-in listener (hook)
    to trigger a build whenever code is committed. The pipeline creates a new build
    and runs a battery of tests against the build. The tests include static code analysis,
    dynamic code analysis, secret detection, and vulnerability scans, as well as functional
    and integration tests. The following figure shows how a CI server interacts with
    several aspects of the development life cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.17 – CI pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.17_B18117.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.17 – CI pipeline
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration servers include Jenkins, **Travis CI**, **CircleCI**,
    and **GitLab**.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these offers similar functionality with slight differences in the user
    interface and the language required to write the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first CI software we will discuss is the most widely used, Jenkins. Jenkins
    has a large community and many features due to it being open source, which is
    why it is also free to use. Some drawbacks to Jenkins are the overhead to maintain
    it as well as a complex pipeline design. Jenkins pipelines use **Groovy**, which
    is an offshoot of Java. The following is the controller-agent architecture used
    with Jenkins CI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.18 – Jenkins architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.18_B18117.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.18 – Jenkins architecture
  prefs: []
  type: TYPE_NORMAL
- en: GitLab
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'GitLab is both an SCM and CI tool. GitLab CI is new as of 2014, but its user
    base has grown exponentially since its release. GitLab CI uses the runner concept,
    which means each job runs in its own container-based executor. It offers a wide
    range of security tools. It can be difficult to manage if you run it on-premises.
    You can see in the following diagram that there are many servers that need to
    be managed and configured. However, GitLab also offers a **Software as a Service**
    (**SaaS**) option for smaller companies looking to get started more quickly. GitLab
    is YML-based, making it quite easy to write and understand pipelines. The following
    architecture diagram is one viable option to implement GitLab within an organization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.19 – GitLab architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.19_B18117.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.19 – GitLab architecture
  prefs: []
  type: TYPE_NORMAL
- en: Continuous delivery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Continuous delivery is an extension of continuous integration. After the build
    stage, code changes are delivered to higher environments such as stage, test,
    preprod, and prod. With continuous delivery, an automated release process must
    be in place as well. The following diagram shows the CI server stages identified
    as being a CI or CD task:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.20 – CI/CD pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.20_B18117.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.20 – CI/CD pipeline
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration and continuous delivery are advanced skills that you
    will gain over time. If you are looking for entry-level DevOps engineering roles,
    chances are they are not going to require you to have practical experience with
    CI/CD. However, it will be expected that you are able to discuss it and show an
    interest in it as it will likely be a large portion of your job. A good way to
    get started with CI/CD is to incorporate a pipeline into one of your code repositories.
    Have fun learning!
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-native frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cloud-native is an approach to software development that leverages the capabilities
    of the cloud, both public and private. DevOps engineers will be involved in the
    use of cloud-native technologies in any career they choose, making it a very important
    and sought-after skill.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Cloud Native Computing Foundation''s (CNCF) Cloud-Native Definition:'
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-native technologies allow everyone to use immutable technologies with
    modern environments. Containers, service meshes, microservices, immutable infrastructure,
    and declarative APIs personify this approach and enable independent applications
    that are fault-tolerant and easy to manage. With automation, they enable engineers
    to make frequent changes with little disruption.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud-native has several advantages, including faster development times and
    the ability to respond to customers more quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A container is a lightweight purpose-built application that has been packaged
    with all the required dependencies for runtime so it can easily be run on any
    operating system in any environment with few changes needed. Multiple containers
    can run on the same machine while running as segmented processes in the user space.
    Containers take up less space than VMs, can handle more applications, and require
    fewer VMs and operating systems. The following is a diagram that compares the
    infrastructure needed for multiple VMs versus multiple containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.21 – Container and VM comparison'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.21_B18117.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.21 – Container and VM comparison
  prefs: []
  type: TYPE_NORMAL
- en: Docker exercise
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the following exercise, we will go through a basic Docker example, which
    can be done on your own computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow this tutorial to install Docker on your machine: [https://docs.docker.com/get-docker/](https://docs.docker.com/get-docker/).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a Dockerfile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add content to the Dockerfile using the `vi` editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.22 – Dockerfile'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.22_B18117.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.22 – Dockerfile
  prefs: []
  type: TYPE_NORMAL
- en: After you have added the previous four lines to your file, make sure to save
    the file using `:w` and then exit `vi` using `:q`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the Docker image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.23 – Docker images'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.23_B18117.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.23 – Docker images
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to see what exactly is happening during the build, you can
    omit the `–- quiet` command. After the image is built and tagged, you can see
    that the base alpine image along with the DevOps book image is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run your container with the interactive terminal command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.24 – interactive terminal command'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.24_B18117.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.24 – interactive terminal command
  prefs: []
  type: TYPE_NORMAL
- en: The `–it` command runs the container with an interactive terminal, meaning a
    terminal session for the container will be opened, allowing you to interact with
    the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stop and remove all containers and images from your machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.25 – Docker image removal'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.25_B18117.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.25 – Docker image removal
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned about containers and the role they play in DevOps.
    If you followed along with the exercise, you will have created a Dockerfile, created
    a Docker image, and run the Docker image on your computer! Hopefully, this has
    made you interested in continuing to learn more about Docker as the rabbit hole
    goes deep!
  prefs: []
  type: TYPE_NORMAL
- en: Microservice architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before looking at the desired architecture, we'll cover other dated architectures.
  prefs: []
  type: TYPE_NORMAL
- en: Monolithic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We will first cover the monolithic architecture, which shares a single code
    base and database. Because nothing is separate, everything must be released/deployed
    at the same time, which leads to long lead times between customer requests and
    them making it to production. I have worked at several companies and every one
    of them has had monolithic applications. There is a good chance you will run across
    this in your career.
  prefs: []
  type: TYPE_NORMAL
- en: Service-oriented
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Service-oriented architecture** (**SOA**) was a step in the right direction
    – it broke code down by services, which decreased the effort and time it took
    to get changes to production. Service-oriented architecture is prone to similar
    problems that a monolithic architecture has, such as interdependencies that require
    the entire application to be rebuilt even when a single service is checked in.
    Most of the companies I have worked with have had applications that use SOA.'
  prefs: []
  type: TYPE_NORMAL
- en: Microservice
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Microservice architecture has exploded in popularity due to large tech giants
    such as Amazon, Netflix, and Google publishing success stories about its use.
    The key differences between SOA and microservices are the communication protocols,
    storage, and size. Firstly, microservices use a language-agnostic protocol to
    communicate with the UI, resulting in a higher number of remote calls but also
    much higher fault tolerance. Secondly, each microservice has its own storage/database,
    which means each microservice can be designed with the right-fit database for
    its needs versus using the same database that is used for the entire application.
    Lastly, the size and lack of interdependence are what really separates a microservice
    from an SOA. A microservice can be deployed at any time and have no effect on
    other components. SOA shares a database and individual services still maintain
    some dependencies, which does not allow for the deployment of the service individually.
    Most companies are striving for a microservice architecture, which is why it is
    a key skill to have.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, you can see how monolithic, SOA, and microservice
    architecture compare:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.26 – Architecture comparison'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.26_B18117.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.26 – Architecture comparison
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will move on and discuss the importance of soft skills for DevOps engineers.
  prefs: []
  type: TYPE_NORMAL
- en: Soft skills
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Soft skills are defined as *personal attributes that enable someone to interact
    effectively and harmoniously with other people*. The tides are changing, and DevOps
    engineers can no longer expect to succeed solely based on technical abilities.
    The following are a few of the most important soft skills for a DevOps engineer.
  prefs: []
  type: TYPE_NORMAL
- en: Empathy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With regard to DevOps, empathy is the ability to understand coworkers' and clients'
    points of view, or rather, the ability to view a situation from someone else's
    shoes. Approach your colleagues with a calm demeanor. This will lead to a much
    more pleasant work environment where new ideas flourish. If your idea differs
    from your colleague's or client's, start with positive feedback about their idea
    and work your way on to what you disagree with. Developing empathy with your coworkers
    ensures everyone's ideas are heard and issues that may be present can be resolved.
    Developing empathy with clients ensures all feedback is captured and a satisfactory
    end solution is reached.
  prefs: []
  type: TYPE_NORMAL
- en: Teamwork
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Working in a team setting allows for multiple sets of eyes to view code at the
    same time. Working together ensures everyone remains on the same page and that
    a coherent product is delivered.
  prefs: []
  type: TYPE_NORMAL
- en: Adaptability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tech is continuously changing and, as a DevOps engineer, you must prove you
    are good at changing gears, whether it be learning a new language or quickly shifting
    priorities. During an interview, you can discuss how you are learning a new programming
    language or how you have partnered with various departments while solutioning
    your last project. If you are unwilling to change, you will not succeed in DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: Good communication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Good communication includes everything from in-person conversation to Slack
    messages. As a DevOps engineer, you will likely be working with team members who
    are fully remote, in different time zones, and coming from different cultures.
    So, you must be able to communicate effectively in each of these cases. Remember,
    people are busy, so pick the method that is going to be most efficient and effective.
  prefs: []
  type: TYPE_NORMAL
- en: Without strong soft skills, it will be difficult to land a job. DevOps is a
    team sport that requires you to collaborate with many different people in an environment
    that changes quickly. There is no room for drama or ego; everyone's opinion matters,
    and you need to respect that.
  prefs: []
  type: TYPE_NORMAL
- en: Beginner DevOps certifications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like other industries, DevOps has seen an increase in the number of certifications
    that are available to practitioners. Certificates are a great way to showcase
    the knowledge you have, but they do not replace experience and are not required
    or mandatory to get a job as a DevOps engineer. DevOps certifications can help
    you stand apart from other candidates during the interview process. They also
    show your desire to continuously learn. When it comes to review time, you can
    use new certifications you have received since your last review as leverage for
    more merit. The following is a list of different certificates you can opt for:'
  prefs: []
  type: TYPE_NORMAL
- en: AWS certifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'AWS offers a few entry-level certifications for DevOps engineers, starting
    with the AWS Cloud Practitioner certification, which requires about 6 months of
    hands-on experience with AWS. After you finish your AWS Cloud Practitioner exam,
    you can begin preparing for the AWS Associate Architect exam. The following are
    the certifications offered:'
  prefs: []
  type: TYPE_NORMAL
- en: AWS Cloud Practitioner ([https://aws.amazon.com/certification/certified-cloud-practitioner/](https://aws.amazon.com/certification/certified-cloud-practitioner/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS Associate Architect ([https://aws.amazon.com/certification/certified-solutions-architect-associate/](https://aws.amazon.com/certification/certified-solutions-architect-associate/))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google Cloud certifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For Google, there is no generic beginner certification, but the Associate Cloud
    Engineer certification is a good introduction to GCP.
  prefs: []
  type: TYPE_NORMAL
- en: Associate Cloud Engineer ([https://cloud.google.com/certification/cloud-engineer](https://cloud.google.com/certification/cloud-engineer))
  prefs: []
  type: TYPE_NORMAL
- en: Azure certifications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For Azure, there is a fundamentals certification that covers a lot of the basics.
    There are several more, but we will cover more cloud certifications in the *Specialized
    competencies* section in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentals ([https://docs.microsoft.com/en-us/learn/certifications/exams/az-900](https://docs.microsoft.com/en-us/learn/certifications/exams/az-900))
  prefs: []
  type: TYPE_NORMAL
- en: Other resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For beginner content, there are a lot of courses from Udemy, EdX, and Coursera
    as well, depending on the specific areas you are interested in. Certifications
    that cover Docker, Terraform, and Kubernetes, as well as the advanced cloud specialties
    and professional certifications, will be covered in the following chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned the basic skills required to succeed as an entry-level
    DevOps engineer. The skills included navigation of a text-only terminal such as
    Bash, automation using various scripting languages, and understanding Git and
    source code management. You also learned about the basics of infrastructure management
    tools such as Ansible and Terraform, as well as gaining an understanding of CI
    and CD and pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will dive deeper into the skills required for various
    DevOps specialty roles.
  prefs: []
  type: TYPE_NORMAL
