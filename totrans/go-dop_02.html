<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer010">
			<h1 id="_idParaDest-15"><a id="_idTextAnchor013"/>Chapter <a id="_idTextAnchor014"/>1: Go Language Basics</h1>
			<p><strong class="bold">DevOps</strong> is a concept that has been floating around since the early 2000s. It is a popularization of an operations discipline that relies on programming skills with <em class="italic">development psychology</em> popularized by Agile. </p>
			<p><strong class="bold">Site reliability engineering</strong> (<strong class="bold">SRE</strong>) is now considered<a id="_idIndexMarker000"/> a subdiscipline of DevOps, though it is likely the precursor<a id="_idIndexMarker001"/> to DevOps and relies more heavily<a id="_idIndexMarker002"/> on software skills and <strong class="bold">Service - Level Obligation</strong> (<strong class="bold">SLO</strong>)/<strong class="bold">Service - Level Agreement</strong> (<strong class="bold">SLA</strong>) modeling.</p>
			<p>During my early time at Google, like many of today's DevOps shops, we used Python heavily. I think C++ was too painful for many SREs, and we had Python celebrities in <em class="italic">Guido van Rossum</em> and <em class="italic">Alex Martelli</em>.</p>
			<p>But, as time wore on, many of the groups working in Python started having scaling issues. This included everything from Python running out of memory (requiring us to hack in our own <strong class="source-inline">malloc</strong>) to the <strong class="bold">Global Interpreter Lock</strong> (<strong class="bold">GIL</strong>) preventing us from true<a id="_idIndexMarker003"/> multithreading. At scale, we found that the lack of static types was giving us an abundance of errors that should have been caught at compile time. This mirrored what production services had seen years before.</p>
			<p>But, Python came with more than compile-time and service-scaling issues. Simply moving to a new version of Python in the fleet might cause a service to stop working. The Python version run on Google machines would often get upgraded and expose bugs in your code that the previous version did not. Unlike a compiled binary, you could not just roll back to an old version. </p>
			<p>Several of us in different organizations were looking to solve these types of problems without having to use C++. For my personal journey, I heard about <strong class="bold">Go</strong> from my colleagues in our Sydney office (<em class="italic">Hey, Ross!</em>). It was the pre-1.0 days, but they said it was already showing a lot of promise. I can't say I was even remotely convinced that what we needed was another language.</p>
			<p>About 6 months later, however, I had bought Go <em class="italic">hook, line, and sinker</em>. It had everything we needed without everything we didn't. Now, it was still pre-1.0 days, so there was a certain amount of churn back then that was unpleasant (such as finding that Russ Cox had changed the <strong class="source-inline">time</strong> package over the weekend, so I had to rewrite a bunch of code). But, the benefits after writing my first service were undeniable.</p>
			<p>I spent the next 4 years moving my department from a complete Python shop to almost a complete Go shop. I started teaching classes in Go across the world, targeted at operations engineers, rewriting core libraries for Go, and evangelizing to what was probably an annoying amount. Just because Go was invented at Google, it didn't mean that the engineers wanted to throw away their Python code and learn something new; there was more than a little resistance.</p>
			<p>Now, Go has become the <em class="italic">de facto</em> language for cloud orchestration and software in the larger world (from Kubernetes to Docker). Go comes with all the tools you need to make huge strides in the reliability of your tooling and ability to scale.</p>
			<p>Because many of these cloud services are written in Go, their parts are available to you by accessing their packages for your own tooling needs. This can make writing tooling for the cloud an easier experience. </p>
			<p>For the next two chapters, I will be sharing my 10+ years' experience of teaching Go to engineers around the world to give you the basics and essentials of the Go language. Much of what you will read here is based on my free Go basics video training course, <a href="https://www.golangbasics.com">https://www.golangbasics.com</a>. This course will differ slightly from that one in that it is more condensed. As you work your way through the book, we will continue to extend your knowledge of the Go language's standard library and third-party packages. </p>
			<p>This chapter will cover the following main topics: </p>
			<ul>
				<li>Using the Go Playground</li>
				<li>Utilizing Go packages </li>
				<li>Using Go's variable types</li>
				<li>Looping in Go</li>
				<li>Using conditionals</li>
				<li>Learning about functions</li>
				<li>Defining public and private</li>
				<li>Using arrays and slices</li>
				<li>Getting to know about structs</li>
				<li>Understanding Go pointers</li>
				<li>Comprehending Go interfa<a id="_idTextAnchor015"/>ces</li>
			</ul>
			<p>Now, let's get the basics down and get you on your way!</p>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor016"/>Technical requirements</h1>
			<p>The only technical requirement for this chapter is a modern web browser for using the <strong class="bold">Go Playground</strong>.</p>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor017"/>Using the Go Playground</h1>
			<p>The Go Playground, which you can find at <a href="https://play.golang.org/">https://play.golang.org/</a>, is an online code<a id="_idIndexMarker004"/> editor and compiler<a id="_idIndexMarker005"/> that allows you to run Go code without installing Go on your machine. This is the perfect tool for our introductory chapters, allowing you to save your work online without the initial fuss of installing the Go tooling, or finding a code editor, for example.</p>
			<p>There are four important parts of the Go Playground:</p>
			<ul>
				<li>The code editing pane</li>
				<li>The console window</li>
				<li>The <strong class="bold">Run</strong> button</li>
				<li>The <strong class="bold">Share</strong> button</li>
			</ul>
			<p>The code editing pane, which is the yellow portion of the page, allows you to type in the Go code for your program. When you hit the <strong class="bold">Run</strong> button, the code will be compiled and then run with the output sent to the console, which is the white portion of the page below the code editor.</p>
			<p>The following screen shows a glimpse of what the Go Playground does: </p>
			<div>
				<div id="_idContainer006" class="IMG---Figure">
					<img src="Images/B17626_01_001.jpg" alt="Figure 1.1 – Go Playground code editor&#13;&#10;" width="515" height="560"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – Go Playground code editor</p>
			<p>Clicking the <strong class="bold">Share</strong> button will store an immutable copy<a id="_idIndexMarker006"/> of the code and will change the URL from <strong class="source-inline">play.golang.org</strong> into a shareable link, such as <strong class="source-inline">play.golang.org/p/HmnNoBf0p1z</strong>. This link is a unique URL that you can bookmark and share with others. The code in this link cannot be changed, but if you hit the <strong class="bold">Share</strong> button again, it will create a new link with any changes.</p>
			<p>Later chapters, starting with <a href="B17626_04.xhtml#_idTextAnchor289"><em class="italic">Chapter 4</em></a>, <em class="italic">Filesystem Interaction</em>, will require installing the Go tooling for your platform.</p>
			<p>This section taught you about the Go Playground and how to use it to write, view, share, and run your Go code. The Playground<a id="_idIndexMarker007"/> will be used extensively throughout the book to share runnable code examples.</p>
			<p>Now, let's jump into writing Go code, starting with how Go defines packages.</p>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor018"/>Utilizing Go packages</h1>
			<p>Go provides reusable blocks<a id="_idIndexMarker008"/> of code that can be imported into other code using packages. Packages in Go are synonymous with libraries or modules in other languages. Packages are the building blocks of Go programs that divide the content into understandable parts.</p>
			<p>This section will cover how to declare and import a package. We will discuss how to deal with package name conflicts, explore rules around packages, and we will write our first main p<a id="_idTextAnchor019"/>ackage.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor020"/>Declaring a package</h2>
			<p>Go divides programs into <strong class="bold">packages</strong>, sometimes called <em class="italic">modules</em> or <em class="italic">libraries</em> in other languages. Packages live on a path, and the path<a id="_idIndexMarker009"/> is made to look like a path to a directory on a Unix-like filesystem.</p>
			<p>All Go files in a directory must belong to the same package. The package is most commonly named the same as the directory it lives in.</p>
			<p>Declaring a package happens at the top of the file, and should only be preceded by a comment. Declaring a package is as simple as the following:</p>
			<p class="source-code">// Package main is the entrance point for our binary.</p>
			<p class="source-code">// The double slashes provides a comment until the end of the line.</p>
			<p class="source-code">/*</p>
			<p class="source-code">This is a comment that lasts until the closing star slash.</p>
			<p class="source-code">*/</p>
			<p class="source-code"><strong class="bold">package</strong> main</p>
			<p><strong class="source-inline">package main</strong> is special. All other package names declare a package that must be imported into another package to be used. <strong class="source-inline">package main</strong> will declare <strong class="source-inline">func main()</strong>, which is the starting point for a binary to run. </p>
			<p>All Go files in a directory<a id="_idIndexMarker010"/> must have the same package header (compiler-enforced). These files, for most practical purposes, act as if they are concatenated together.</p>
			<p>Let's say you have a directory structure as follows:</p>
			<p class="source-code">mypackage/</p>
			<p class="source-code">  file1.go</p>
			<p class="source-code">  file2.go</p>
			<p>Then, <strong class="source-inline">file1.go</strong> and <strong class="source-inline">file2.go</strong> should have the following: </p>
			<p class="source-code">package mypackage</p>
			<p>When <strong class="source-inline">mypackage</strong> is imported by another package, it will include everything declared in all files in the <strong class="source-inline">mypackage</strong> d<a id="_idTextAnchor021"/>irectory.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor022"/>Importing a package</h2>
			<p>There are two general<a id="_idIndexMarker011"/> types of packages:</p>
			<ul>
				<li>The <strong class="bold">standard library</strong> (<strong class="bold">stdlib</strong>) packages</li>
				<li>All other packages</li>
			</ul>
			<p>Standard library packages<a id="_idIndexMarker012"/> stand out because they don't list some repository information in their path, such as the following:</p>
			<p class="source-code">"fmt"</p>
			<p class="source-code">"encoding/json"</p>
			<p class="source-code">"archive/zip"</p>
			<p>All other packages generally have repository information preceding them, as follows:</p>
			<p class="source-code">"github.com/johnsiilver/golib/lru"</p>
			<p class="source-code">"github.com/kylelemons/godebug/pretty"</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A complete listing of <strong class="source-inline">stdlib</strong> packages<a id="_idIndexMarker013"/> can be found at the following link: <a href="https://golang.org/pkg/">https://golang.org/pkg/</a>.</p>
			<p>To import packages, we use the <strong class="source-inline">import</strong> keyword. So, let's import<a id="_idIndexMarker014"/> the standard library <strong class="source-inline">fmt</strong> package and the <strong class="source-inline">mypackage</strong> package, which lives at <strong class="source-inline">github.com/devopsforgo/mypackage</strong>:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">     "fmt"</p>
			<p class="source-code">     "github.com/devopsforgo/mypackage"</p>
			<p class="source-code">)</p>
			<p>It is important to note that the filenames are not part of the package path, but simply the di<a id="_idTextAnchor023"/>rectory path.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor024"/>Using a package</h2>
			<p>Once you've imported<a id="_idIndexMarker015"/> a package, you can start accessing functions, types, or variables declared in the package by prefacing what you want to access with the name of the package and a period.</p>
			<p>For example, the <strong class="source-inline">fmt</strong> package has a function called <strong class="source-inline">Println()</strong> that can be used to print a line to <em class="italic">stdout</em>. If we want to use it, it is as simple as the following:</p>
			<p class="source-code">fmt.Pri<a id="_idTextAnchor025"/>ntln("Hello!")</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor026"/>Package name conflicts</h2>
			<p>Let's say you have two<a id="_idIndexMarker016"/> packages named <strong class="source-inline">mypackage</strong>. They both have the same name, so our program won't be able to tell which one we are referring to. You can rename a package import into whatever name you want:</p>
			<p class="source-code">import(</p>
			<p class="source-code">     "github.com/devopsforgo/mypackage"</p>
			<p class="source-code">     jpackage "github.com/johnsiilver/mypackage"</p>
			<p class="source-code">)</p>
			<p><strong class="source-inline">jpackage</strong> declares that in this package, we will refer to <strong class="source-inline">github.com/johnsiilver/mypackage</strong> as <strong class="source-inline">jpackage</strong>.</p>
			<p>This ability allows us to use<a id="_idIndexMarker017"/> two similarly named packages as follows:</p>
			<p class="source-code">mypackage.Print()</p>
			<p class="source-code">jpackage.Send()</p>
			<p>Now, we will look at an important rule around packages that improves compile-time <a id="_idTextAnchor027"/>and binary size.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor028"/>Packages must be used</h2>
			<p>Let's introduce you to the following rule: <em class="italic">If you import a package, you must use it</em>.</p>
			<p>One of the things that the Go authors<a id="_idIndexMarker018"/> noticed about many of the other programming languages being used at Google was that they often had unused imports. </p>
			<p>This was leading to compile times that were longer than needed and, in some cases, binary sizes that were much bigger than required. Python files were packaged in a proprietary format to ship around production, and some of these unused imports were adding hundreds of megabytes to the files.</p>
			<p>To prevent these types of problems, Go will not compile a program that imports a package but doesn't use it, as shown here:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">     "fmt"</p>
			<p class="source-code">     "sync"</p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">     fmt.Println("Hello, playground")</p>
			<p class="source-code">}</p>
			<p>The preceding code outputs the following:</p>
			<p class="source-code">./prog.go:5:2: imported and not used: "sync"</p>
			<p>In certain rare circumstances, you may need to do a <em class="italic">side effects</em> import, in which just loading the package<a id="_idIndexMarker019"/> causes something to happen, but you don't use the package. This should <em class="italic">always</em> be done in <strong class="source-inline">package main</strong> and requires prepending with an underscore (<strong class="source-inline">_</strong>):</p>
			<p class="source-code">package main</p>
			<p class="source-code">import (</p>
			<p class="source-code">     "fmt"</p>
			<p class="source-code">     _ "sync" //Just an example </p>
			<p class="source-code">)</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">     fmt.Println("Hello, playground")</p>
			<p class="source-code">}</p>
			<p>Next, we will declare a main package and discuss the basics of writing a Go program that <a id="_idTextAnchor029"/>imports a package.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor030"/>A Go Hello World</h2>
			<p>Let's write a simple <strong class="bold">hello world</strong> program that is similar to the default<a id="_idIndexMarker020"/> program in the Go Playground. This example will demonstrate the following:</p>
			<ul>
				<li>Declaring a package</li>
				<li>Importing the <strong class="source-inline">fmt</strong> package from the standard library, which can print to our screen</li>
				<li>Declaring the <strong class="source-inline">main()</strong> function of a program</li>
				<li>Declaring a string variable using the <strong class="source-inline">:=</strong> operator</li>
				<li>Printing the variable to the screen</li>
			</ul>
			<p>Let's see what<a id="_idIndexMarker021"/> this looks like:</p>
			<p class="source-code">1 package main</p>
			<p class="source-code">2 </p>
			<p class="source-code">3 import "fmt"</p>
			<p class="source-code">4</p>
			<p class="source-code">5 func main() {</p>
			<p class="source-code">6    hello := "Hello World!" fmt.Println(hello) </p>
			<p class="source-code">7          </p>
			<p class="source-code">8 }</p>
			<p>In our first line, we declared the name of our package using the <strong class="source-inline">package</strong> keyword. The entrance point for any Go binary is a package named <strong class="source-inline">main</strong> that has a function called <strong class="source-inline">main()</strong>. </p>
			<p>In our third line, we import the <strong class="source-inline">fmt</strong> package. <strong class="source-inline">fmt</strong> has functions for doing string formatting and writing to various outputs.</p>
			<p>On our fifth line, we declare a function called <strong class="source-inline">main</strong> that takes no arguments and returns no values. <strong class="source-inline">main()</strong> is special, as when a binary is run, it starts by running the <strong class="source-inline">main()</strong> function.</p>
			<p>Go uses <strong class="source-inline">{}</strong> to show where a function starts and where a function ends (similar to C). </p>
			<p>The sixth line declares a variable named <strong class="source-inline">hello</strong> using the <strong class="source-inline">:=</strong> operator. This operator indicates that we wish to create a new variable and assign it a value in a single line. This is the most common, but not the only, way to declare a variable.</p>
			<p>As Go is typed, so <strong class="source-inline">:=</strong> will assign the type based on the value. In this case, it will be a string, but<a id="_idIndexMarker022"/> if the value was an <strong class="bold">integer</strong> (such as <strong class="source-inline">3</strong>), it would be the <strong class="source-inline">in</strong>t type, and if a <strong class="bold">floating-point</strong> (such as <strong class="source-inline">2.4</strong>), it would<a id="_idIndexMarker023"/> be the <strong class="source-inline">float64</strong> type. If we wanted to declare a specific type, such as <strong class="source-inline">int8</strong> or <strong class="source-inline">float32</strong>, we would need some modifications (which we will talk about later).</p>
			<p>On the seventh line, we call a function that is in the <strong class="source-inline">fmt</strong> package called <strong class="source-inline">Println</strong>. <strong class="source-inline">Println()</strong> will print the contents of the <strong class="source-inline">hello</strong> variable to <strong class="source-inline">stdout</strong> followed by a new line character (<strong class="source-inline">\n</strong>).</p>
			<p>You will notice that the way to use a function declared in another package is to use the <em class="italic">package name (without quotes)</em> + <em class="italic">a period</em> + <em class="italic">the name of the function</em>. In this case, <strong class="source-inline">fmt.Println()</strong>.</p>
			<p>In this section, you have learned<a id="_idIndexMarker024"/> how to declare a package, import a package, what the function of the <strong class="source-inline">main</strong> package is, and how to write a basic Go program with a variable declaration. In the next section, we will go into some depth on declari<a id="_idTextAnchor031"/>ng and using variables.</p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor032"/>Using Go's variable types</h1>
			<p>Modern programming languages<a id="_idIndexMarker025"/> are built with primitives called <strong class="bold">types</strong>. When you hear that a variable is a <em class="italic">string</em> or <em class="italic">integer</em>, you are talking about the variable's type. </p>
			<p>With today's programming languages, there are two common type systems used:</p>
			<ul>
				<li><strong class="bold">Dynamic types</strong> (also<a id="_idIndexMarker026"/> called duck typing)</li>
				<li><strong class="bold">Static types</strong></li>
			</ul>
			<p>Go is a <strong class="bold">statically typed</strong> language. For many of you who <a id="_idIndexMarker027"/>might be coming from languages such as Python, Perl, and PHP, then those languages are <strong class="bold">dynamically typed</strong>.</p>
			<p>In a dynamically typed language, you can create<a id="_idIndexMarker028"/> a variable and store anything in it. In those languages, the type simply indicates what is stored in the variable. Here is an example in Python:</p>
			<p class="source-code">v = "hello"</p>
			<p class="source-code">v = 8</p>
			<p class="source-code">v = 2.5</p>
			<p>In this case, <strong class="source-inline">v</strong> can store anything, and the type held by <strong class="source-inline">v</strong> is unknown without using some runtime checks (<em class="italic">runtime</em> meaning that it can't be checked at compile time).</p>
			<p>In a statically typed<a id="_idIndexMarker029"/> language, the type of the variable<a id="_idIndexMarker030"/> is set when it is created. That type cannot change. In this type of language, the type is both what <em class="italic">is</em> stored in the variable and what <em class="italic">can</em> be stored in the variable. Here is a Go example:</p>
			<p class="source-code">v := "hello" // also can do: var v string = "hello"</p>
			<p>The <strong class="source-inline">v</strong> value cannot be set to any other type than a string.</p>
			<p>It might seem like Python is superior because it can store anything in its variable. But in practice, this lack of being specific means that Python must wait until a program is running before it can find <a id="_idIndexMarker031"/>out there is a problem (what we call a <strong class="bold">runtime error</strong>). It is better to find the problem when the software is compiled than when it is deployed.</p>
			<p>Let's take a look at a function to add two numbers together as an example. </p>
			<p>Here is the Python version:</p>
			<p class="source-code">def add(a, b):</p>
			<p class="source-code">     return a+b</p>
			<p>Here is the Go version:</p>
			<p class="source-code">func add(a int, b int) int {</p>
			<p class="source-code">     return a + b</p>
			<p class="source-code">}</p>
			<p>In the Python version, we can see that <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong> will be added together. But, what types are <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong>? What is the result type? What happens if I pass an integer and a float or an integer and a string? </p>
			<p>In some cases, two types cannot be added together in Python, which will cause a runtime exception, and you can never be sure of what the result type will be.</p>
			<p class="callout-heading">Note </p>
			<p class="callout">Python has added <strong class="bold">type hints</strong> to the language to help<a id="_idIndexMarker032"/> avoid these problems. But, practical experience has taught us with JavaScript/Dart/TypeScript/Closure that while it can help, optional type support means that a lot of problems fall through the cracks.</p>
			<p>Our Go version defines the exact types for our arguments and our result. You cannot pass an integer and a float or an integer and a string. You will only ever receive an integer as a return. This allows our compiler<a id="_idIndexMarker033"/> to find any errors with variable types when the program is compiled. In Python, this error could show up at any time, from the instant it ran to 6 months later when a certain code path was executed.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A few years ago, there was a study done on the <em class="italic">Rosetta Code</em> repository for some of the top languages in use to see how they fared in processing time, memory use, and runtime failures. For runtime failures, Go had the least failures, with Python towards the bottom of the ranking. Static typing would have certainly played into that.</p>
			<p class="callout">The study<a id="_idIndexMarker034"/> can be found here: <a href="https://arxiv.org/pdf/1409.0252.pdf">htt<span id="_idTextAnchor033"/>ps://arxiv.org/pdf/1409.0252.pdf</a>.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor034"/>Go's types</h2>
			<p>Go has a rich type system that not only specifies that a type might be an integer but also the size of the integer. This allows a Go programmer<a id="_idIndexMarker035"/> to reduce the size of a variable both in memory and when encoding for network transport. </p>
			<p>The following table shows the most common types used in Go:</p>
			<div>
				<div id="_idContainer007" class="IMG---Figure">
					<img src="Images/011.jpg" alt="Table 1.1 – Common types used in Go and their descriptions&#13;&#10;" width="1586" height="719"/>
				</div>
			</div>
			<p class="figure-caption">Table 1.1 – Common types used in Go and their descriptions</p>
			<p>We will be keeping our discussion mostly to the preceding types; however, the following table is the full list<a id="_idIndexMarker036"/> of types that can be used:</p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="Images/02.jpg" alt="Table 1.2 – Full list of types that you can use in Go&#13;&#10;" width="1547" height="1235"/>
				</div>
			</div>
			<p class="figure-caption"><a id="_idTextAnchor035"/>Table 1.2 – Full list of types that you can use in Go</p>
			<p>Go doesn't just provide<a id="_idIndexMarker037"/> these types; you can also create new types based on these basic types. These custom types become their own type and can have methods attached to them.</p>
			<p>Declaring a custom type is done with the <strong class="source-inline">type</strong> keyword and will be discussed during the section on the <strong class="source-inline">struct</strong> type. For now, we are going to move on to the basics of declaring variables.</p>
			<p>Now that we've talked about our variable types, let's have a look at how we can create them.<a id="_idTextAnchor036"/></p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor037"/>Declaring variables</h2>
			<p>As in most languages, declaring<a id="_idIndexMarker038"/> a variable allocates storage that will hold some type of data. In Go, that data is typed so that only that type can be stored in the allocated storage. As Go has multiple ways to declare a variable, the next parts will talk about the different ways this can be done<a id="_idTextAnchor038"/>.</p>
			<h3>The long way to declare a variable</h3>
			<p>The most specific way to declare<a id="_idIndexMarker039"/> a variable is using the <strong class="source-inline">var</strong> keyword. You can use <strong class="source-inline">var</strong> to declare a variable both at the package level (meaning not inside a function) and within a function. Let's look at some examples of ways to declare variables using <strong class="source-inline">var</strong>:</p>
			<p class="source-code">var i int64</p>
			<p>This declares an <strong class="source-inline">i</strong> variable that can hold an <strong class="source-inline">int64</strong> type. No value is assigned, so the value is assigned the <em class="italic">zero value</em> of an integer, which is <strong class="source-inline">0</strong>:</p>
			<p class="source-code">var i int = 3</p>
			<p>This declares an <strong class="source-inline">i</strong> variable that can hold an <strong class="source-inline">int</strong> type. The value <strong class="source-inline">3</strong> is assigned to <strong class="source-inline">i</strong>.</p>
			<p>Note that the <strong class="source-inline">int</strong> and <strong class="source-inline">int64</strong> types are distinct. You cannot use an <strong class="source-inline">int</strong> type as an <strong class="source-inline">int64</strong> type, and vice versa. However, you can do type conversions to allow interchanging these types. This is discussed later:</p>
			<p class="source-code">var (</p>
			<p class="source-code">     i int</p>
			<p class="source-code">     word = "hello"</p>
			<p class="source-code">)</p>
			<p>Using <strong class="source-inline">()</strong>, we group together a set of declarations. <strong class="source-inline">i</strong> can hold an <strong class="source-inline">int</strong> type and has the integer zero value, <strong class="source-inline">0</strong>. <strong class="source-inline">word</strong> doesn't declare the type, but it is inferred by the string value on the right <a id="_idIndexMarker040"/>side of the equal (<strong class="source-inline">=</strong>) operator.</p>
			<h3>The shorter way</h3>
			<p>In the previous example, we used the <strong class="source-inline">var</strong> keyword to create a variable and the <strong class="source-inline">=</strong> operator to assign values. If we do not have an <strong class="source-inline">=</strong> operator, the compiler<a id="_idIndexMarker041"/> assigns the <em class="italic">zero value</em> for the type (more on this later).</p>
			<p>The important concept is as follows:</p>
			<ul>
				<li><strong class="source-inline">var</strong> created the variable but did not make an assignment.</li>
				<li><strong class="source-inline">=</strong> assigned a value to the variable.</li>
			</ul>
			<p>Within a function (not at the package level), we can do a <em class="italic">create and assign</em> by using the <strong class="source-inline">:=</strong> operator. This both creates a new variable and assigns a value to it:</p>
			<p class="source-code">i := 1                       // i is the int type </p>
			<p class="source-code">word := "hello"              // word is the string type </p>
			<p class="source-code">f := 3.2                     // f is the float64 type </p>
			<p>The important thing to remember when using <strong class="source-inline">:=</strong> is that it means <em class="italic">create and assign</em>. If the variable already exists, you cannot use <strong class="source-inline">:=</strong>, but must use <strong class="source-inline">=</strong>, which just does an assignm<a id="_idTextAnchor039"/>ent.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor040"/>Variable scopes and shadowing</h2>
			<p>A <strong class="bold">scope</strong> is the part<a id="_idIndexMarker042"/> of the program in which a variable<a id="_idIndexMarker043"/> can be seen. In Go, we have the following variable scopes:</p>
			<ul>
				<li><strong class="bold">Package scoped</strong>: Can be seen by the entire package<a id="_idIndexMarker044"/> and is declared outside a function</li>
				<li><strong class="bold">Function scoped</strong>: Can be seen within <strong class="source-inline">{}</strong> which defines<a id="_idIndexMarker045"/> the function</li>
				<li><strong class="bold">Statement scoped</strong>: Can be seen within <strong class="source-inline">{}</strong> of a statement<a id="_idIndexMarker046"/> in a function (<strong class="source-inline">for</strong> loop, <strong class="source-inline">if</strong>/<strong class="source-inline">else</strong>)</li>
			</ul>
			<p>In the following program, the <strong class="source-inline">word</strong> variable is declared at the package level. It can be used by any function defined in the package:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">var word = "hello"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">	fmt.Println(word)</p>
			<p class="source-code">}</p>
			<p>In the following program, the <strong class="source-inline">word</strong> variable<a id="_idIndexMarker047"/> is defined inside the <strong class="source-inline">main()</strong> function and can only be used inside <strong class="source-inline">{}</strong> which defines <strong class="source-inline">main</strong>. Outside, it is undefined:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">	var word string = "hello"</p>
			<p class="source-code">	fmt.Println(word)</p>
			<p class="source-code">}</p>
			<p>Finally, in this program, <strong class="source-inline">i</strong> is statement scoped. It can be used on the line starting our <strong class="source-inline">for</strong> loop and inside <strong class="source-inline">{}</strong> of the loop, but it doesn't exist outside the loop:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">	for i := 0; i &lt; 10; i++ {</p>
			<p class="source-code">		fmt.Println(i)</p>
			<p class="source-code">	}</p>
			<p class="source-code">}</p>
			<p>The best way to think of this is that if your variable<a id="_idIndexMarker048"/> is declared on a line that has <strong class="source-inline">{</strong>or within a set of <strong class="source-inline">{}</strong>, it can only be seen withi<a id="_idTextAnchor041"/>n those <strong class="source-inline">{}</strong>.</p>
			<h3>Cannot redeclare a variable in the same scope</h3>
			<p>The rule for this, <em class="italic">You cannot declare two variables with the same name within the same scope</em>.</p>
			<p>This means that no two variables within the same scope can have the same name:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">     var word = "hello"</p>
			<p class="source-code">     var word = "world"</p>
			<p class="source-code">     fmt.Println(word)</p>
			<p class="source-code">}</p>
			<p>This program is invalid and will generate a compile error. Once you have declared the <strong class="source-inline">word</strong> variable, you cannot recreate it within the same scope. You can change the value to a new value, but you cannot create a second variable with the same name.</p>
			<p>To assign <strong class="source-inline">word</strong> a new value, simply remove <strong class="source-inline">var</strong> from the line. <strong class="source-inline">var</strong> says <em class="italic">create variable where we want to only do an assignment</em>:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">     var word = "hello"</p>
			<p class="source-code">     word = "world"</p>
			<p class="source-code">     fmt.Println(word)</p>
			<p class="source-code">}</p>
			<p>Next, we will look at what happens when you declare two variables with the same name in the same scope, but within separate <a id="_idTextAnchor042"/>code blocks.</p>
			<h3>Variable shadowing</h3>
			<p><strong class="bold">Variable shadowing</strong> occurs when a variable <a id="_idIndexMarker049"/>that is within your variable scope, but not in your local scope, is redeclared. This causes the local<a id="_idIndexMarker050"/> scope to lose access to the <strong class="bold">outer scoped variable</strong>:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">var word = "hello"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">	var word = "world"</p>
			<p class="source-code">	fmt.Println("inside main(): ", word)</p>
			<p class="source-code">	printOutter()</p>
			<p class="source-code">}</p>
			<p class="source-code">func printOutter() {</p>
			<p class="source-code">	fmt.Println("the package level 'word' var: ", word)</p>
			<p class="source-code">}</p>
			<p>As you can see, <strong class="source-inline">word</strong> is declared at the package level. But inside <strong class="source-inline">main</strong>, we define a new <strong class="source-inline">word</strong> variable, which overshadows the package level variable. When we refer to <strong class="source-inline">word</strong> now, we are using the one defined inside <strong class="source-inline">main()</strong>.</p>
			<p><strong class="source-inline">printOutter()</strong> is called, but it doesn't have a locally shadowed <strong class="source-inline">word</strong> variable (one declared between its <strong class="source-inline">{}</strong>), so it used the one at the package level.</p>
			<p>Here's the output of this program:</p>
			<p class="source-code">inside main():  world</p>
			<p class="source-code">the package level 'word' var:  hello</p>
			<p>This is one of the more common bugs for <a id="_idTextAnchor043"/><a id="_idTextAnchor044"/>Go developers.</p>
			<h3>Zero values</h3>
			<p>In some older languages, a variable declaration<a id="_idIndexMarker051"/> without an assignment has an unknown value. This is because the program creates a place in memory to store the value but doesn't put anything in it. So, the bits representing the value are set to whatever happened to be in that memory space before you created the variable.</p>
			<p>This has led to many unfortunate bugs. So, in Go, declaring a variable without an assignment automatically assigns<a id="_idIndexMarker052"/> a value called the <em class="italic">zero value</em>. Here is a list of the zero values for Go types:</p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="Images/03.jpg" alt="Table 1.3 – Zero values for Go types&#13;&#10;" width="1231" height="782"/>
				</div>
			</div>
			<p class="figure-caption"><a id="_idTextAnchor045"/>Table 1.3 – Zero values for Go types</p>
			<p>Now that we understand what zero<a id="_idIndexMarker053"/> values are, let's see how Go prevents unused variables in our code.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor046"/>Function/statement variable must be used</h2>
			<p>The rule here is that if you create a variable<a id="_idIndexMarker054"/> within a function or statement, it must<a id="_idIndexMarker055"/> be used. This is much for the same reason as package imports; declaring a variable that isn't used is almost always a mistake.</p>
			<p>This can be relaxed in much the same way as an import, using <strong class="source-inline">_</strong>, but is far less common. This assigns the value stored in <strong class="source-inline">someVar</strong> to nothing:</p>
			<p class="source-code">_ = someVar</p>
			<p>This assigns the value returned by <strong class="source-inline">someFunc()</strong> to nothing:</p>
			<p class="source-code">_ = someFunc()</p>
			<p>The most common use for this is when a function returns multiple values, but you only need one:</p>
			<p class="source-code">needed, _ := someFunc()</p>
			<p>Here, we create and assign to the <strong class="source-inline">needed</strong> variable, but the second value isn't something we use, so we drop it. </p>
			<p>This section has provided the knowledge of Go's basic types, the different ways to declare a variable, the rules around variable scopes and shadows, and Go's <em class="italic">zero value<a id="_idTextAnchor047"/>s</em>.</p>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor048"/>Looping in Go</h1>
			<p>Most languages have a few different types<a id="_idIndexMarker056"/> of loop statements: <strong class="source-inline">for</strong>, <strong class="source-inline">while</strong>, and <strong class="source-inline">do while</strong>.</p>
			<p>Go differs in that there is a single loop type, <strong class="source-inline">for</strong>, that can implement the functionality of all the loop types in other languages.</p>
			<p>In this section, we will discuss the <strong class="source-inline">for</strong> loop and its many us<a id="_idTextAnchor049"/>es.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor050"/>C style</h2>
			<p>The most basic form<a id="_idIndexMarker057"/> of a loop is similar to C syntax:</p>
			<p class="source-code">for i := 0; i &lt; 10; i++ {</p>
			<p class="source-code">     fmt.Println(i)</p>
			<p class="source-code">}</p>
			<p>This declares an <strong class="source-inline">i</strong> variable<a id="_idIndexMarker058"/> that is an integer scoped to live only for this loop statement. <strong class="source-inline">i := 0;</strong> is the loop initialization statement; it only happens once before the loop starts. <strong class="source-inline">i &lt; 10;</strong> is the conditional statement; it happens at the start of each loop and must evaluate to <strong class="source-inline">true</strong> or the loop ends.</p>
			<p><strong class="source-inline">i++</strong> is the <strong class="source-inline">post</strong> statement; it occurs at the end of every loop. <strong class="source-inline">i++</strong> says to increment the <strong class="source-inline">i</strong> variable by <strong class="source-inline">1</strong>. Go also has common statements, such as <strong class="source-inline">i += 1</strong> and <a id="_idTextAnchor051"/><strong class="source-inline">i--</strong>. </p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor052"/>Removing the init statement</h2>
			<p>We don't need<a id="_idIndexMarker059"/> to have an <strong class="source-inline">init</strong> statement, as shown<a id="_idIndexMarker060"/> in this example:</p>
			<p class="source-code">var i int</p>
			<p class="source-code">for ;i &lt; 10;i++ {</p>
			<p class="source-code">     fmt.Println(i)</p>
			<p class="source-code">}</p>
			<p class="source-code">fmt.Println("i's final value: ", i)</p>
			<p>In this, we declared <strong class="source-inline">i</strong> outside the loop. This means that <strong class="source-inline">i</strong> will be accessible outside the loop once the loop is finished, unlike our previous ex<a id="_idTextAnchor053"/>ample. </p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor054"/>Remove the post statement too and you have a while loop</h2>
			<p>Many languages<a id="_idIndexMarker061"/> have a <strong class="source-inline">while</strong> loop that simply evaluates whether a statement<a id="_idIndexMarker062"/> is true or not. We can do the same by eliminating our <strong class="source-inline">init</strong> and <strong class="source-inline">post</strong> statements:</p>
			<p class="source-code">var i int</p>
			<p class="source-code">for i &lt; 10 {</p>
			<p class="source-code">     i++</p>
			<p class="source-code">}</p>
			<p class="source-code">b := true</p>
			<p class="source-code">for b { // This will loop forever</p>
			<p class="source-code">     fmt.Println("hello")</p>
			<p class="source-code">}</p>
			<p>You might<a id="_idIndexMarker063"/> be asking, <em class="italic">how do we make a loop that runs forever?</em> The <strong class="source-inline">for</strong> loop<a id="_idIndexMarker064"/> has y<a id="_idTextAnchor055"/>ou covered.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor056"/>Creating an infinite loop</h2>
			<p>Sometimes you want a <strong class="bold">loop</strong> to run forever or until some internal condition<a id="_idIndexMarker065"/> inside the loop occurs. Creating an infinite loop<a id="_idIndexMarker066"/> is as simple as removing all statements:</p>
			<p class="source-code">for {</p>
			<p class="source-code">     fmt.Println("Hello World")</p>
			<p class="source-code">}</p>
			<p>This is usually useful for things such as servers that need to process some incoming str<a id="_idTextAnchor057"/>eam forever. </p>
			<h3>Loop control</h3>
			<p>With loops, you occasionally<a id="_idIndexMarker067"/> need to control the execution of the loop from within the loop. This could be because you want to exit the loop or stop the execution of this iteration of the loop and start from the top.</p>
			<p>Here's an example of a loop where we call a function called <strong class="source-inline">doSomething()</strong> that returns an error if the loop should end. What <strong class="source-inline">doSomething()</strong>does is not important for this example: </p>
			<p class="source-code">for {</p>
			<p class="source-code">     if err := doSomething(); err != nil {</p>
			<p class="source-code">          break</p>
			<p class="source-code">     }</p>
			<p class="source-code">     fmt.Println("keep going")</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">break</strong> function here will break out of the loop. <strong class="source-inline">break</strong> is also used to break out of other statements, such as <strong class="source-inline">select</strong> or <strong class="source-inline">switch</strong>, so it's important to know that <strong class="source-inline">break</strong> breaks out of the first statement it is nested inside of.</p>
			<p>If we want to stop the loop on a condition and continue with the next loop, we can use the <strong class="source-inline">continue</strong> statement:</p>
			<p class="source-code">for i := 0; i &lt; 10; i++ {</p>
			<p class="source-code">     if i % 2 == 0 { // Only 0 for even numbers</p>
			<p class="source-code">           continue</p>
			<p class="source-code">     }</p>
			<p class="source-code">     fmt.Println("Odd number: ", i)</p>
			<p class="source-code">}</p>
			<p>This loop will print out the odd numbers from zero to nine. <strong class="source-inline">i % 2</strong> means <em class="italic">i modulus 2</em>. Modulus divides the first number by the second number and returns <a id="_idTextAnchor058"/>the remainder. </p>
			<h3>Loop braces</h3>
			<p>Here is the introduction<a id="_idIndexMarker068"/> of this rule: A <strong class="source-inline">for</strong> loop’s open brace must be on the same line as the <strong class="source-inline">for</strong> keyword.</p>
			<p>With many languages, there are arguments about where to put the braces for loops/conditionals. With Go, the authors decided to pre-empt those arguments with compiler checks. In Go, you can do the following:</p>
			<p class="source-code">for {</p>
			<p class="source-code">     fmt.Println("hello world")</p>
			<p class="source-code">}</p>
			<p>However, the following is incorrect as the opening brace of the <strong class="source-inline">for</strong> loop is on its own line: </p>
			<p class="source-code">for</p>
			<p class="source-code">{</p>
			<p class="source-code">     fmt.Println("hello world")</p>
			<p class="source-code">}</p>
			<p>In this section we learned to use <strong class="source-inline">for</strong> loops as C style loops, as <strong class="source-inline">while</strong> loops. </p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor059"/>Using conditionals</h1>
			<p>Go supports<a id="_idIndexMarker069"/> two types of conditionals, as follows: </p>
			<ul>
				<li><strong class="source-inline">if</strong>/<strong class="source-inline">else</strong> blocks</li>
				<li><strong class="source-inline">switch</strong> blocks</li>
			</ul>
			<p>The standard <strong class="source-inline">if</strong> statement is similar to other languages with the addition of an optional <strong class="source-inline">init</strong> statement borrowed from the standard C-style <strong class="source-inline">for</strong> loop syntax.</p>
			<p><strong class="source-inline">switch</strong> statements provide a sometimes-cleaner alternative to <strong class="source-inline">if</strong>. So, let's jump into t<a id="_idTextAnchor060"/>he <strong class="source-inline">if</strong> conditional.</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor061"/>if statements</h2>
			<p><strong class="source-inline">if</strong> statements<a id="_idIndexMarker070"/> start with a familiar format<a id="_idIndexMarker071"/> that is recognizable in most languages:</p>
			<p class="source-code">if [expression that evaluates to boolean] {</p>
			<p class="source-code">     ...</p>
			<p class="source-code">} </p>
			<p>Here's a simple example:</p>
			<p class="source-code">if x &gt; 2 { </p>
			<p class="source-code">    fmt.Println("x is greater than 2") </p>
			<p class="source-code">}</p>
			<p>The statements within <strong class="source-inline">{}</strong> in <strong class="source-inline">if</strong> will execute if <strong class="source-inline">x</strong> has a value greater than <strong class="source-inline">2</strong>.</p>
			<p>Unlike most languages, Go has the ability to execute a statement within the <strong class="source-inline">if</strong> scope before the evaluation is made:</p>
			<p class="source-code">if [init statement];[statement that evaluates to boolean] {</p>
			<p class="source-code">     ...</p>
			<p class="source-code">}</p>
			<p>Here is a simple example that is similar to the init statement in a <strong class="source-inline">for</strong> loop:</p>
			<p class="source-code">if err := someFunction(); err != nil { </p>
			<p class="source-code">    fmt.Println(err) </p>
			<p class="source-code">}</p>
			<p>Here, we initialize<a id="_idIndexMarker072"/> a variable called <strong class="source-inline">err</strong>. It has a scope of the <strong class="source-inline">if</strong> block. If the <strong class="source-inline">err</strong> variable<a id="_idIndexMarker073"/> does not equal the <strong class="source-inline">nil</strong> value (a special value that indicates certain types are not set – more on this later), it<a id="_idTextAnchor062"/> will print the error.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor063"/>else</h2>
			<p>If you need to execute something<a id="_idIndexMarker074"/> when the condition of an <strong class="source-inline">if</strong> statement is not met, you can<a id="_idIndexMarker075"/> use the <strong class="source-inline">else</strong> keyword:</p>
			<p class="source-code">if condition {</p>
			<p class="source-code">     function1()</p>
			<p class="source-code">}else {</p>
			<p class="source-code">     function2()</p>
			<p class="source-code">}</p>
			<p>In this example, if the <strong class="source-inline">if</strong> condition is true, <strong class="source-inline">function1</strong> will be executed. Otherwise, <strong class="source-inline">function2</strong> occurs.</p>
			<p>It should be noted that most uses of <strong class="source-inline">else</strong> can generally be eliminated for cleaner code. If your <strong class="source-inline">if</strong> condition results in returning from a function using the <strong class="source-inline">return</strong> keyword, you can eliminate <strong class="source-inline">else</strong>. </p>
			<p>An example is as follows:</p>
			<p class="source-code">if v, err := someFunc(); err != nil {</p>
			<p class="source-code">     return err</p>
			<p class="source-code">}else{</p>
			<p class="source-code">     fmt.Println(v)</p>
			<p class="source-code">     return nil</p>
			<p class="source-code">}</p>
			<p>This can be simplified to the following:</p>
			<p class="source-code">v, err := someFunc()</p>
			<p class="source-code">if err != nil {</p>
			<p class="source-code">     return err </p>
			<p class="source-code">}</p>
			<p class="source-code">fmt.Println(v)</p>
			<p class="source-code">return nil</p>
			<p>Sometimes, you want<a id="_idIndexMarker076"/> to only execute code if the <strong class="source-inline">if</strong> condition is not met and another <a id="_idIndexMarker077"/>condition is<a id="_idTextAnchor064"/>. Let's look at that next.</p>
			<h3>else if</h3>
			<p>An <strong class="source-inline">if</strong> block can also contain <strong class="source-inline">else if</strong>, providing multiple levels of execution. The first <strong class="source-inline">if</strong> or <strong class="source-inline">else if</strong> that is matched in order is executed.</p>
			<p>Note that often Go developers <a id="_idIndexMarker078"/>choose the <strong class="source-inline">switch</strong> statement as a cleaner version of this type of conditional.</p>
			<p>An example is as follows:</p>
			<p class="source-code">if x &gt; 0 {</p>
			<p class="source-code">     fmt.Println("x is greater than 0")</p>
			<p class="source-code">} else if x &lt; 0 {</p>
			<p class="source-code">     fmt.Println("x is less than 0")</p>
			<p class="source-code">} else{</p>
			<p class="source-code">     fmt.Println("x is equal to 0")</p>
			<p class="source-code">}</p>
			<p>Now that we have seen<a id="_idIndexMarker079"/> the basics of this conditional, we nee<a id="_idTextAnchor065"/>d to talk about brace style.</p>
			<h3>if/else braces</h3>
			<p>It's time to introduce<a id="_idIndexMarker080"/> this rule: Opening braces for <strong class="source-inline">if</strong>/<strong class="source-inline">else</strong> must be on the line with the associated keyword. If there is another statement in the chain, it must start on the same line as the previous close brace.</p>
			<p>With many languages, there are arguments about where to put the braces for loops/conditionals.</p>
			<p>With Go, the authors decided to pre-empt those arguments with compiler checks. In Go, you can't do the following:</p>
			<p class="source-code">if x &gt; 0 </p>
			<p class="source-code">{ // This must go up on the previous line</p>
			<p class="source-code">     fmt.Println("hello")</p>
			<p class="source-code">}</p>
			<p class="source-code">else { // This line must start on the previous line</p>
			<p class="source-code">     fmt.Println("world")</p>
			<p class="source-code">}</p>
			<p>So, with the arguments on bracing style in Go settled, let's look at an alternative to <strong class="source-inline">i<a id="_idTextAnchor066"/>f</strong>/<strong class="source-inline">else</strong>, the <strong class="source-inline">switch</strong> statement.</p>
			<h3>The switch statement</h3>
			<p><strong class="source-inline">switch</strong> statements are more<a id="_idIndexMarker081"/> elegant <strong class="source-inline">if</strong>/<strong class="source-inline">else</strong> blocks that are very flexible in their use. They can be used for doing exact matching and mu<a id="_idTextAnchor067"/>ltiple true/false evaluations.</p>
			<h4>Exact match switch</h4>
			<p>The following<a id="_idIndexMarker082"/> is an exact match <strong class="source-inline">switch</strong>: </p>
			<p class="source-code">switch [value] {</p>
			<p class="source-code">case [match]:</p>
			<p class="source-code">     [statement]</p>
			<p class="source-code">case [match], [match]:</p>
			<p class="source-code">     [statement]</p>
			<p class="source-code">default:</p>
			<p class="source-code">     [statement]</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">[value]</strong> is matched against each <strong class="source-inline">case</strong> statement. If it matches, the <strong class="source-inline">case</strong> statement executes. Unlike some languages, once a match occurs, no other case is considered. If no match occurs, the <strong class="source-inline">default</strong> statement executes. The <strong class="source-inline">default</strong> statement is optional.</p>
			<p>This has a nicer syntax than <strong class="source-inline">if</strong>/<strong class="source-inline">else</strong> for handling cases where your value can be several values:</p>
			<p class="source-code">switch x {</p>
			<p class="source-code">case 3:</p>
			<p class="source-code">     fmt.Println("x is 3")</p>
			<p class="source-code">case 4, 5:  // executes if x is 4 or 5</p>
			<p class="source-code">     fmt.Println("x is 4 or 5")</p>
			<p class="source-code">default:</p>
			<p class="source-code">     fmt.Println("x is unknown")</p>
			<p class="source-code">}</p>
			<p>switch can also have an <strong class="source-inline">init</strong> statement, similar to <strong class="source-inline">if</strong>:</p>
			<p class="source-code">switch x := someFunc(); x {</p>
			<p class="source-code">case 3<a id="_idTextAnchor068"/>:</p>
			<p class="source-code">     fmt.Println("x is 3")</p>
			<p class="source-code">} </p>
			<h4>True/false evaluation switch</h4>
			<p>We can also eliminate <strong class="source-inline">[match]</strong> so that each <strong class="source-inline">case</strong> statement<a id="_idIndexMarker083"/> isn't an exact match, but a true/false evaluation (as with <strong class="source-inline">if</strong> statements): </p>
			<p class="source-code">switch {</p>
			<p class="source-code">case x &gt; 0:</p>
			<p class="source-code">     fmt.Println("x is greater than 0")</p>
			<p class="source-code">case x &lt; 0:</p>
			<p class="source-code">     fmt.Println("x is less than 0")</p>
			<p class="source-code">default:</p>
			<p class="source-code">     fmt.Println("x must be 0")</p>
			<p class="source-code">}</p>
			<p>At the end of this section, you should be able to use Go's conditional statements to branch code execution in your program based on some criteria and handle cases where no statement was matched. As conditionals are one of the standard building blocks of software, we will use these in<a id="_idTextAnchor069"/> many of the remaining sections.</p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor070"/>Learning about functions</h1>
			<p><strong class="bold">Functions</strong> in Go are what you'd expect from<a id="_idIndexMarker084"/> a modern programming language. There are only a few things that make Go functions different:</p>
			<ul>
				<li>Multiple return values are supported</li>
				<li>Variadic arguments</li>
				<li>Named return values</li>
			</ul>
			<p>The basic function signature is as follows:</p>
			<p class="source-code">func functionName([varName] [varType], ...) ([return value], [return value], ...){</p>
			<p class="source-code">}</p>
			<p>Let's make a basic function<a id="_idIndexMarker085"/> that adds two numbers together and returns the result:</p>
			<p class="source-code">func add(x int, y int) int {</p>
			<p class="source-code">     return x + y</p>
			<p class="source-code">}</p>
			<p>As you can see, this takes in two integers, <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong>, adds them together, and returns the result (which is an integer). Let's show how we can call this function and print its output:</p>
			<p class="source-code">result := add(2, 2)</p>
			<p class="source-code">fmt.Println(result)</p>
			<p>We can simplify this function signature by declaring both <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> types with a single <strong class="source-inline">int</strong> keyword:</p>
			<p class="source-code">func add(x, y int) int {</p>
			<p class="source-code">     return x + y</p>
			<p class="source-code">}</p>
			<p>This <a id="_idTextAnchor071"/>is equivalent to the previous one.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor072"/>Returning multiple values and named results</h2>
			<p>In Go, we can <strong class="bold">return multiple values</strong>. For example, consider a function that divides two integers and returns two variables, the result and the remainder, as follows:</p>
			<p class="source-code">func divide(num, div int) (res, rem int) {</p>
			<p class="source-code">	result = num / div</p>
			<p class="source-code">	remainder = num % div</p>
			<p class="source-code">	return res, rem</p>
			<p class="source-code">}</p>
			<p>This code demonstrates a few new features in our function:</p>
			<ul>
				<li>Argument <strong class="source-inline">num</strong> is the number to be divided</li>
				<li>Argument <strong class="source-inline">div</strong> is the number to divide by</li>
				<li>Return value <strong class="source-inline">res</strong> is the result of the division</li>
				<li>Return value <strong class="source-inline">rem</strong> is the remainder of the division</li>
			</ul>
			<p>First is <strong class="bold">named returns</strong> (<strong class="source-inline">res</strong> and <strong class="source-inline">rem</strong>). These variables are automatically<a id="_idIndexMarker086"/> created and ready for use inside the function.</p>
			<p>Notice I use <strong class="source-inline">=</strong> and not <strong class="source-inline">:=</strong> when doing assignments<a id="_idIndexMarker087"/> to those variables. This is because the variable already exists, and we want to assign a value (<strong class="source-inline">=</strong>). <strong class="source-inline">:=</strong> means <strong class="bold">create and assign</strong>. You can only create a new variable that doesn't exist. You will also notice that now the return type is in parenthesis. You will need to use parenthesis if you use more than one return value or named returns (or in this case, both).</p>
			<p>Calling this function is just as simple as calling <strong class="source-inline">add()</strong> before, as shown here:</p>
			<p class="source-code">result, remainder := divide(3, 2)</p>
			<p class="source-code">fmt.Printf("Result: %d, Remainder %d", result, remainder)</p>
			<p>Strickly speaking, you don't have to use <strong class="source-inline">return</strong> to return the values. However, doing so will prevent some ugly bugs that you will eventually encounter.</p>
			<p>Next, we will look at how we can have a variable number of arguments as function input that allows us to create functions such as <strong class="source-inline">fmt.Println()</strong>, w<a id="_idTextAnchor073"/>hich you have been using in this chapter.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor074"/>Variadic arguments</h2>
			<p>A <strong class="bold">variadic argument</strong> is when you want<a id="_idIndexMarker088"/> to provide <strong class="source-inline">0</strong> to infinite arguments. A good example would be calculating<a id="_idIndexMarker089"/> a sum of integers. Without variadic arguments, you might use a slice (a <em class="italic">growable array type</em>, which we will talk about later), as follows:</p>
			<p class="source-code">func sum(numbers []int) int {</p>
			<p class="source-code">     sum := 0</p>
			<p class="source-code">     for _, n := range numbers {</p>
			<p class="source-code">          sum += n</p>
			<p class="source-code">     }</p>
			<p class="source-code">     return sum</p>
			<p class="source-code">}</p>
			<p>While this is fine, using it is cumbersome:</p>
			<p class="source-code">args := []int{1,2,3,4,5}</p>
			<p class="source-code">fmt.Println(sum(args))</p>
			<p>We can accomplish this same thing by using the variadic (<strong class="source-inline">...</strong>) notation:</p>
			<p class="source-code">func sum(numbers ...int) int {</p>
			<p class="source-code">     // Same code</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">numbers</strong> is still <strong class="source-inline">[]int</strong>, but has<a id="_idIndexMarker090"/> a different calling convention<a id="_idIndexMarker091"/> that is more elegant:</p>
			<p class="source-code">fmt.Println(sum(1,2,3,4,5))</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can use variadic arguments with other arguments, but <a id="_idTextAnchor075"/>it must be the last argument in the function.</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor076"/>Anonymous functions</h2>
			<p>Go has a concept of <strong class="bold">anonymous functions</strong>, which means<a id="_idIndexMarker092"/> a function<a id="_idIndexMarker093"/> without a<a id="_idIndexMarker094"/> name (also called a <strong class="bold">function closure</strong>).</p>
			<p>This can be useful to take advantage of special statements that honor function boundaries, such as <strong class="source-inline">defer</strong>, or in <strong class="source-inline">goroutines</strong>. We will show how to take advantage of these for <strong class="source-inline">goroutines</strong> later, but for now let's show how to execute an anonymous function. This is a contrived example that is only useful in teaching the concept:</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">     result := func(word1, word2 string) string {</p>
			<p class="source-code">          return word1 + " " + word2</p>
			<p class="source-code">     }("hello", "world")</p>
			<p class="source-code">     fmt.Println(result)</p>
			<p class="source-code">}</p>
			<p>This code does the following:</p>
			<ul>
				<li>Defines a single-use function (<strong class="source-inline">func(word1, word2 string) string</strong>)</li>
				<li>Executes the function with the <strong class="source-inline">hello</strong> and <strong class="source-inline">world</strong> arguments</li>
				<li>Assigns the <strong class="source-inline">string</strong> return value to the <strong class="source-inline">result</strong> variable</li>
				<li>Prints <strong class="source-inline">result</strong></li>
			</ul>
			<p>Now that we have arrived at the end of this section, we have learned about how Go functions are declared, the use of multiple return<a id="_idIndexMarker095"/> values, variadic arguments for simplified function<a id="_idIndexMarker096"/> calling, and anonymous functions. Multiple return values will be important in future chapters where we deal with errors, and anonymous functions are key components of our future <strong class="source-inline">defer</strong> statements and for use with concurrency.</p>
			<p>In the next s<a id="_idTextAnchor077"/>ection, we will explore public and private types. </p>
			<h1 id="_idParaDest-42"><a id="_idTextAnchor078"/>Defining public and private</h1>
			<p>Many modern languages<a id="_idIndexMarker097"/> provide a set of options<a id="_idIndexMarker098"/> when declaring constants/variables/functions/methods that detail when a method can be called.</p>
			<p>Go simplifies these <em class="italic">visibility</em> choices down to two types:</p>
			<ul>
				<li><strong class="bold">Public</strong> (exported)</li>
				<li><strong class="bold">Private</strong> (not exported)</li>
			</ul>
			<p><strong class="bold">Public types</strong> are types that can be referred to outside of the package. <strong class="bold">Private types</strong> can only be referred to inside the package. To be public, the constant/variable/function/method must simply start with an uppercase letter. If it starts with a lowercase letter, it is private.</p>
			<p>There is a third type<a id="_idIndexMarker099"/> of visibility that we don't cover here: <strong class="bold">internally exported</strong>. This occurs when a type<a id="_idIndexMarker100"/> is public but in a package, located<a id="_idIndexMarker101"/> within a directory called <strong class="source-inline">internal/</strong>. Those packages can only be used by packages<a id="_idIndexMarker102"/> within a parent directory. You can read about this here: <a href="https://golang.org/doc/go1.4#internalpackages">https://golang.org/doc/go1.4#internalpackages</a>.</p>
			<p>Let's declare a package and create some public and private methods:</p>
			<p class="source-code">package say</p>
			<p class="source-code">import "fmt"</p>
			<p class="source-code">func PrintHello() {</p>
			<p class="source-code">	fmt.Println("Hello")</p>
			<p class="source-code">}</p>
			<p class="source-code">func printWorld() {</p>
			<p class="source-code">	fmt.Println("World")</p>
			<p class="source-code">}</p>
			<p class="source-code">func PrintHelloWorld() {</p>
			<p class="source-code">	PrintHello()</p>
			<p class="source-code">	printWorld()</p>
			<p class="source-code">}</p>
			<p>We have three function calls, two public (<strong class="source-inline">PrintHello()</strong> and <strong class="source-inline">PrintHelloWorld()</strong>) and one private (<strong class="source-inline">printWorld()</strong>). Now, let's create <strong class="source-inline">package main</strong>, import the <strong class="source-inline">say</strong> package, and call our functions:</p>
			<p class="source-code">package main</p>
			<p class="source-code">import "github.com/repo/examples/say"</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">	say.PrintHello()</p>
			<p class="source-code">	say.PrintHelloWorld()</p>
			<p class="source-code">}</p>
			<p>Now, let's compile and run it:</p>
			<p class="source-code">$ go run main.go</p>
			<p class="source-code">Hello</p>
			<p class="source-code">Hello</p>
			<p class="source-code">World</p>
			<p>These work because <strong class="source-inline">PrintHello()</strong> and <strong class="source-inline">PrintHelloWorld()</strong> are both <strong class="bold">exported</strong> (public) functions. <strong class="source-inline">PrintHelloWorld()</strong> calls the private <strong class="source-inline">printWorld()</strong>, but that is legal because they are in the same package.</p>
			<p>If we try to add <strong class="source-inline">say.printWorld()</strong> to <strong class="source-inline">func main()</strong> and run it, we will get the following:</p>
			<p class="source-code">./main.go:8:2: cannot refer to unexported name say.printWorld</p>
			<p>Public and private apply to variables declared outside functions/methods and type declarations.</p>
			<p>By the end of this short<a id="_idIndexMarker103"/> and sweet section, you've acquired the knowledge of Go's public<a id="_idIndexMarker104"/> and private types. This will be useful in code where you do not want to expose types in <a id="_idTextAnchor079"/>your public API. Next, we will look at arrays and slices. </p>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor080"/>Using arrays and slices</h1>
			<p>Languages require<a id="_idIndexMarker105"/> more than the basic types to hold data. The <strong class="source-inline">array</strong> type is one of the core building<a id="_idIndexMarker106"/> blocks in lower-level languages, providing the base sequential data type. For most day-to-day use, Go's <strong class="source-inline">slice</strong> type provides a flexible <strong class="bold">array</strong> that can grow as data needs grow and can be sliced into sections in order to share views of the data. </p>
			<p>In this section, we will talk about arrays as the building blocks of <strong class="bold">slices</strong>, the diffe<a id="_idTextAnchor081"/>rence between the two, and how to utilize them in your code.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor082"/>Arrays</h2>
			<p>The base sequential type<a id="_idIndexMarker107"/> in Go is the array (important to know, but rarely used). Arrays are statically sized (if you create one that holds 10 <strong class="source-inline">int</strong> types, it will always hold exactly 10 <strong class="source-inline">int</strong> types). </p>
			<p>Go provides an <strong class="source-inline">array</strong> type designated by putting <strong class="source-inline">[size]</strong> before the type you wish to create an array of. For example, <strong class="source-inline">var x [5]int or x := [5]int{}</strong> creates an array holding five integers, indexed from <strong class="source-inline">0</strong> to <strong class="source-inline">4</strong>. </p>
			<p>An assignment into an array is as easy as choosing the index. <strong class="source-inline">x[0] = 3</strong> assigns <strong class="source-inline">3</strong> to index <strong class="source-inline">0</strong>. Retrieving that value is as simple as referring to the index; <strong class="source-inline">fmt.Println(x[0] + 2)</strong> will output <strong class="source-inline">5</strong>.</p>
			<p>Arrays, unlike slices, are <em class="italic">not</em> pointer wrapper types. Passing an array as a function argument passes a copy:</p>
			<p class="source-code">func changeValueAtZeroIndex(array [2]int) {</p>
			<p class="source-code">     array[0] = 3</p>
			<p class="source-code">     fmt.Println("inside: ", array[0]) // Will print 3</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">     x := [2]int{}</p>
			<p class="source-code">     changeValueAtZeroIndex(x)</p>
			<p class="source-code">     fmt.Println(x) // Will print 0</p>
			<p class="source-code">}</p>
			<p>Arrays present the following two problems in Go:</p>
			<ul>
				<li>Arrays are typed by size – <strong class="source-inline">[2]int</strong> is distinct from <strong class="source-inline">[3]int</strong>. You cannot use <strong class="source-inline">[3]int</strong> where <strong class="source-inline">[2]int</strong> is required.</li>
				<li>Arrays are a set size. If you need more room, you must make a new array.</li>
			</ul>
			<p>While it is important to know what arrays <a id="_idTextAnchor083"/>are, the most common sequential type used in Go is the slice.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor084"/>Slices</h2>
			<p>The easiest way to understand a slice<a id="_idIndexMarker108"/> is to see it as a type that is built on top of arrays. A slice is a <em class="italic">view</em> into an array. Changing what you can see in your slice's view changes the underlying array's value. The most basic use of slices acts like arrays, with two exceptions:</p>
			<ul>
				<li>A slice is not statically sized.</li>
				<li>A slice can grow to accommodate new values.</li>
			</ul>
			<p>A slice tracks its array, and when it needs more room, it will create a new array that can accommodate the new values and copies the values from the current array into the new array. This happens invisibly to the user. </p>
			<p>Creating a slice can be done similarly to an array, <strong class="source-inline">var x = []int</strong> or <strong class="source-inline">x := []int{}</strong> . This creates a slice of integers with a length of <strong class="source-inline">0</strong> (which has no room to store values). You can retrieve the size of the slice using <strong class="source-inline">len(x)</strong>. </p>
			<p>We can create a slice with initial values easily: <strong class="source-inline">x := []int{8,4,5,6}</strong>. Now, we have <strong class="source-inline">len(x) == 4</strong>, indexed from <strong class="source-inline">0</strong> to <strong class="source-inline">3</strong>. </p>
			<p>Similar to arrays, we can change a value at an index by simply referencing the index. <strong class="source-inline">x[2] = 12</strong> will change the preceding slice to <strong class="source-inline">[]int{8,4,12,6}</strong>.</p>
			<p>Unlike arrays, we can add a new value to the slice using the <strong class="source-inline">append</strong> command. <strong class="source-inline">x = append(x, 2)</strong> will cause the underlying <strong class="source-inline">x</strong> array references to be copied to a new array and assigns the new view of the array back to <strong class="source-inline">x</strong>. The new value is <strong class="source-inline">[]int{8,4,12,6,2}</strong>. You may append multiple values by just putting more comma-delimited values in <strong class="source-inline">append</strong> (that is, <strong class="source-inline">x = append(x, 2, 3, 4, 5)</strong>).</p>
			<p>Remember that slices are simply <em class="italic">views</em> into a trackable array. We can create new limited views of the array. <strong class="source-inline">y := x[1:3]</strong> creates a view (<strong class="source-inline">y</strong>) of the array, yielding <strong class="source-inline">[]int{4, 12}</strong> (<strong class="source-inline">1</strong> is inclusive and <strong class="source-inline">3</strong> is exclusive in <strong class="source-inline">[1:3]</strong>). Changing the value at <strong class="source-inline">y[0]</strong> will change <strong class="source-inline">x[1]</strong>. Appending a single value to <strong class="source-inline">y</strong> via <strong class="source-inline">y = append(y, 10)</strong>will change <strong class="source-inline">x[3]</strong>, yielding <strong class="source-inline">[]int{8,4,12,10,2}</strong>. </p>
			<p>This kind of use isn't common (and is confusing), but the important part is to understand that slices are simply views into an array.</p>
			<p>While slices are a pointer-wrapped type (values in a slice passed to a function that are changed will change in the caller as well), a slice's view will not change.</p>
			<p class="source-code">func doAppend(sl []int) {</p>
			<p class="source-code">     sl = append(sl, 100)</p>
			<p class="source-code">     fmt.Println("inside: ", sl) // inside:  [1 2 3 100]</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() { </p>
			<p class="source-code">     x := []int{1, 2, 3}</p>
			<p class="source-code">     doAppend(x)</p>
			<p class="source-code">     fmt.Println("outside: ", x) // outside:  [1 2 3]</p>
			<p class="source-code">}</p>
			<p>In this example, the <strong class="source-inline">sl</strong> and <strong class="source-inline">x</strong> variables both use the same underlying array (which has changed in both), but the view for <strong class="source-inline">x</strong> does not get updated in <strong class="source-inline">doAppend()</strong>. To update <strong class="source-inline">x</strong> to see the addition to the slice<a id="_idIndexMarker109"/> would require passing a pointer to the slice (pointers are covered in a future chapter) or returning the new slice as seen here:</p>
			<p class="source-code">func doAppend(sl []int) []int {</p>
			<p class="source-code">     return append(sl, 100)</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">     x := []int{1, 2, 3}</p>
			<p class="source-code">     x = doAppend(x)</p>
			<p class="source-code">     fmt.Println("outside: ", x) // outside:  [1 2 3 100]</p>
			<p class="source-code">}</p>
			<p>Now that you see how to crea<a id="_idTextAnchor085"/>te and add to a slice, let's look at how to extract the values.</p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor086"/>Extracting all values</h2>
			<p>To extract values from a slice, we can use<a id="_idIndexMarker110"/> the older C-type <strong class="source-inline">for</strong> loop<a id="_idIndexMarker111"/> or the more common <strong class="source-inline">for</strong>...<strong class="source-inline">range</strong> syntax.</p>
			<p>The older C style is as follows:</p>
			<p class="source-code">for i := 0; i &lt; len(someSlice); i++{</p>
			<p class="source-code">     fmt.Printf("slice entry %d: %s\n", i, someSlice[i])</p>
			<p class="source-code">}</p>
			<p>The more common approach in Go uses <strong class="source-inline">range</strong>:</p>
			<p class="source-code">for index, val := range someSlice {</p>
			<p class="source-code">     fmt.Printf("slice entry %d: %s\n", index, val)</p>
			<p class="source-code">}</p>
			<p>With <strong class="source-inline">range</strong>, we often want to use only the value, but not the index. In Go, you must use variables that are declared in a function, or the compiler will complain with the following:</p>
			<p class="source-code">index declared but not used</p>
			<p>To only extract the values, we can use <strong class="source-inline">_,</strong> (which tells the compiler not to store the output), as follows:</p>
			<p class="source-code">for _, val := range someSlice {</p>
			<p class="source-code">     fmt.Printf("slice entry: %s\n", val)</p>
			<p class="source-code">}</p>
			<p>On very rare occasions, you may want to only print out indexes and not values. This is uncommon because it will simply count from zero to the number of items. However, this can be achieved by simply removing <strong class="source-inline">val</strong> from the <strong class="source-inline">for</strong> statement: <strong class="source-inline">for index := range someSlice</strong>.</p>
			<p>In this section, you have discovered what arrays are, how to create them, and how they relate to slices. In addition, you've acquired the skills to create slices, add data to slices, and extr<a id="_idTextAnchor087"/>act data from slices. Let's move on to learning about maps next. </p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor088"/>Understanding maps</h2>
			<p><strong class="bold">Maps</strong> are a collection of key-value pairs<a id="_idIndexMarker112"/> that a user can use to store some data and retrieve it with a key. In some<a id="_idIndexMarker113"/> languages, these are called <strong class="bold">dictionaries</strong> (<em class="italic">Python</em>) or <strong class="bold">hashes</strong> (<em class="italic">Perl</em>). In contrast to an<a id="_idIndexMarker114"/> array/slice, finding an entry in a map requires a single lookup versus iterating over the entire slice comparing values. Wi<a id="_idTextAnchor089"/>th a large set of items, this can give you significant time savings.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor090"/>Declaring a map</h2>
			<p>There are several ways to declare a map. Let's first look at using <strong class="source-inline">make</strong>:</p>
			<p class="source-code">var counters = make(map[string]int, 10)</p>
			<p>The example just shared<a id="_idIndexMarker115"/> creates a map with <strong class="source-inline">string</strong> keys and stores data that is an <strong class="source-inline">int</strong> type. <strong class="source-inline">10</strong> signifies that we want to pre-size for 10 entries. The map can grow beyond 10 entries and the <strong class="source-inline">10</strong> can be omitted.</p>
			<p>Another way of declaring<a id="_idIndexMarker116"/> a map is by using a <strong class="bold">composite literal</strong>:</p>
			<p class="source-code">modelToMake := map[string]string{</p>
			<p class="source-code">     "prius": "toyota",</p>
			<p class="source-code">     "chevelle": "chevy",</p>
			<p class="source-code">}</p>
			<p>This creates a map with <strong class="source-inline">string</strong> keys and stores the <strong class="source-inline">string</strong> data. We also pre-populate the entry with<a id="_idTextAnchor091"/> two key-value entries. You can omit the entries to have an empty map.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor092"/>Accessing values</h2>
			<p>You can retrieve a value as follows:</p>
			<p class="source-code">carMake := modelToMake["chevelle"]</p>
			<p class="source-code">fmt.Println(carMake) // Prints "chevy"</p>
			<p>This assigns the <strong class="source-inline">chevy</strong> value to <strong class="source-inline">carMake</strong>.</p>
			<p>But what happens if the key isn't in the map? In that case, we will receive the zero value of the data type:</p>
			<p class="source-code">carMake := modelToMake["outback"]</p>
			<p class="source-code">fmt.Println(carMake)</p>
			<p>The preceding code will print<a id="_idIndexMarker117"/> an empty string, which is the zero value of the string<a id="_idIndexMarker118"/> type that is used as values in our map.</p>
			<p>We can also detect if the value is in the map:</p>
			<p class="source-code">if carMake, ok := modelToMake["outback"]; ok {</p>
			<p class="source-code">     fmt.Printf("car model \"outback\" has make %q", carMake)</p>
			<p class="source-code">}else{</p>
			<p class="source-code">     fmt.Printf("car model \"outback\" has an unknown make")</p>
			<p class="source-code">}</p>
			<p>Here we assign two values. The first (<strong class="source-inline">carMake</strong>) is the data stored in the key (or zero value if not s<a id="_idTextAnchor093"/>et), and the second (<strong class="source-inline">ok</strong>) is a Boolean that indicates if the key was found.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor094"/>Adding new values</h2>
			<p>Adding a new key-value pair<a id="_idIndexMarker119"/> or updating a key's value, is done<a id="_idIndexMarker120"/> the same way:</p>
			<p class="source-code">modelToMake["outback"] = "subaru"</p>
			<p class="source-code">counters["pageHits"] = 10</p>
			<p>Now that we can change a key-value pair, let's look at extracting values from a map.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor095"/>Extracting all values</h2>
			<p>To extract values<a id="_idIndexMarker121"/> from a map, we can use the <strong class="source-inline">for</strong>...<strong class="source-inline">range</strong> syntax that we used<a id="_idIndexMarker122"/> for slices. There are a few key differences with maps:</p>
			<ul>
				<li>Instead of an index, you will get the map's key.</li>
				<li>Maps have a non-deterministic order.</li>
			</ul>
			<p>Non-deterministic order means that iterating over the data will return the same data but not in the same order.</p>
			<p>Let's print out all the values in our <strong class="source-inline">carMake</strong> map:</p>
			<p class="source-code">for key, val := range modelToMake {</p>
			<p class="source-code">     fmt.Printf("car model %q has make %q\n", key, val)</p>
			<p class="source-code">}</p>
			<p>This will yield the following, but maybe not in the same order:</p>
			<p class="source-code">car model "prius" has make "toyota"</p>
			<p class="source-code">car model "chevelle" has make "chevy"</p>
			<p class="source-code">car model "outback" has make "subaru"</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Similar to a slice, if you don't need the key, you may use <strong class="source-inline">_</strong> instead. If you simply want the keys, you can omit the value <strong class="source-inline">val</strong> variable, such as <strong class="source-inline">for key := range modelToMake</strong>.</p>
			<p>In this section, you have<a id="_idIndexMarker123"/> learned about the <strong class="source-inline">map</strong> type, how to declare them, add<a id="_idIndexMarker124"/> values to them, and finally how to extract values from them. Let's dive into learning about pointers.</p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor096"/>Understanding Go pointers</h1>
			<p><strong class="bold">Pointers</strong> are another essential tool for programming languages<a id="_idIndexMarker125"/> for efficient memory use. Some readers may have not encountered pointers in their current language, instead having used its cousin, the reference type. In Python, for example, the <strong class="source-inline">dict</strong>, <strong class="source-inline">list</strong>, and <strong class="source-inline">object</strong> types are reference types.</p>
			<p>In this section, we will cover<a id="_idIndexMarker126"/> what pointers are, how to declare them, and how to use them.</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor097"/>Memory addresses</h2>
			<p>In an earlier chapter, we talked<a id="_idIndexMarker127"/> about variables for storing data of some type. For example, if we want to create a variable called <strong class="source-inline">x</strong> that stores an <strong class="source-inline">int</strong> type with a value of <strong class="source-inline">23</strong>, we can write <strong class="source-inline">var x int = 23</strong>.</p>
			<p>Under the hood, the memory allocator allocates us space to store the value. The space is referenced by a unique memory address that looks like <strong class="source-inline">0xc000122020</strong>. This is similar to how a home address is used; it is the reference to where the data lives. </p>
			<p>We can see the memory address where a variable is stored by prepending <strong class="source-inline">&amp;</strong> to a variable name:</p>
			<p class="source-code">fmt.Println(&amp;x)</p>
			<p>This would print <strong class="source-inline">0xc000122020</strong>, the memory address of where <strong class="source-inline">x</strong> is stored.</p>
			<p>This leads to an important concept: functions always make a copy of the arguments passed.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor098"/>Function arguments are copies</h2>
			<p>When we call a function<a id="_idIndexMarker128"/> and pass a variable as a function argument, inside the function you get a copy of that variable. This is important because when you change the variable, you are only affecting the copy inside the function.</p>
			<p class="source-code">func changeValue(word string) {</p>
			<p class="source-code">     word += "world" </p>
			<p class="source-code">}</p>
			<p>In this code, <strong class="source-inline">word</strong> is a copy of the value that was passed. <strong class="source-inline">word</strong> will stop existing at the end of this function call.</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">     say := "hello"</p>
			<p class="source-code">     changeValue(say)</p>
			<p class="source-code">     fmt.Println(say)</p>
			<p class="source-code">}</p>
			<p>This prints <strong class="source-inline">"hello"</strong>. Passing the string and changing it in the function doesn't work, because inside the function<a id="_idIndexMarker129"/> we are working with a copy. Think of every <em class="italic">function call</em> as making a copy of the variable with a copy machine. Editing the copy that came out of the copy machine does not affect the original.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor099"/>Pointers to the rescue</h2>
			<p>Pointers in Go are types that store the address of a value, not the value. So, instead of storing <strong class="source-inline">23</strong>, it would store <strong class="source-inline">0xc000122020</strong>, which is where in memory <strong class="source-inline">23</strong> is stored.</p>
			<p>A pointer type can be declared by prepending the type name with <strong class="source-inline">*</strong>. If we want to create an <strong class="source-inline">intPtr</strong> variable that stores a pointer to <strong class="source-inline">int</strong>, we can do the following:</p>
			<p class="source-code">var intPtr *int</p>
			<p>You cannot store <strong class="source-inline">int</strong> in <strong class="source-inline">intPtr</strong>; you can only store the address of <strong class="source-inline">int</strong>. To get the address of an existing <strong class="source-inline">int</strong>, you can use the <strong class="source-inline">&amp;</strong> symbol on a variable representing <strong class="source-inline">int</strong>.</p>
			<p>Let's assign <strong class="source-inline">intPtr</strong> the address of our <strong class="source-inline">x</strong> variable from previously:</p>
			<p class="source-code">intPtr = &amp;x</p>
			<p class="source-code">intPtr now stores 0xc000122020. </p>
			<p>Now for the big question, <em class="italic">how is this useful?</em> This lets us refer to a value in memory and change that value. We do that through<a id="_idIndexMarker130"/> what is called <strong class="bold">dereferencing</strong> the pointer. This is done<a id="_idIndexMarker131"/> with the <strong class="source-inline">*</strong> operator on the variable.</p>
			<p>We can view or change the value held at <strong class="source-inline">x</strong> by dereferencing the pointer. The following is an example:</p>
			<p class="source-code">fmt.Println(x)             // Will print 23 </p>
			<p class="source-code">fmt.Println(*intPtr)       // Will print 23, the value at x </p>
			<p class="source-code">*intPtr = 80               // Changes the value at x to 80 </p>
			<p class="source-code">fmt.Println(x)             // Will print 80 </p>
			<p>This also works across functions. Let's alter <strong class="source-inline">changeValue()</strong> to work with pointers:</p>
			<p class="source-code">func changeValue(word *string) {</p>
			<p class="source-code">     // Add "world" to the string pointed to by 'word'</p>
			<p class="source-code">     *word += "world"</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">     say := "hello"</p>
			<p class="source-code">     changeValue(&amp;say) // Pass a pointer</p>
			<p class="source-code">     fmt.Println(say) // Prints "helloworld"</p>
			<p class="source-code">}</p>
			<p>Note that operators<a id="_idIndexMarker132"/> such as <strong class="source-inline">*</strong> are called <strong class="bold">overloaded operators</strong>. Their meaning depends on the context in which they are used. When declaring a variable, <strong class="source-inline">*</strong> indicates a pointer type, <strong class="source-inline">var intPtr *int</strong>. When used on a variable, <strong class="source-inline">*</strong> means dereference, <strong class="source-inline">fmt.Println(*intPtr)</strong>. When used between two numbers, it means multiply, <strong class="source-inline">y := 10 * 2</strong>. It takes time to remember what a symbol means when used in certain contexts.</p>
			<p><em class="italic">But, didn't you say every argument is a copy?!</em></p>
			<p>I did indeed. When you pass a pointer to a function, a copy of the pointer is made, but the copy still holds the same memory address. Therefore, it still refers to the same piece of memory. It is a lot like making a copy of a treasure map on the copy machine; the copy still points to the place in the world where you will find the treasure. Some of you are probably thinking, <em class="italic">But maps and slices can have their values changed, what gives?</em></p>
			<p>They are a special type called a <strong class="bold">pointer-wrapped</strong> type. A pointer-wrapped type<a id="_idIndexMarker133"/> hides internal pointers.</p>
			<h3>Don't go crazy with pointers</h3>
			<p>While in our examples we used pointers for basic types, typically pointers are used on long-lived objects or for storage of large data that is expensive to copy. Go's memory model uses<a id="_idIndexMarker134"/> the stack/heap model. <strong class="bold">Stack</strong> memory is created for exclusive use by a function/method call. Allocation on the stack<a id="_idIndexMarker135"/> is significantly faster than on the <strong class="bold">heap</strong>. </p>
			<p><strong class="bold">Heap allocation</strong> occurs in Go when a reference<a id="_idIndexMarker136"/> or pointer cannot be determined to live exclusively within a function's call stack. This is determined<a id="_idIndexMarker137"/> by the compiler doing <strong class="bold">escape analysis</strong>. </p>
			<p>Generally, it is much cheaper to pass copies into a function via an argument and another copy in the return value than it is to use a pointer. Finally, be careful with the number of pointers. Unlike C, it is uncommon in Go to see pointers to pointers, such as <strong class="source-inline">**someType</strong>, and, in over 10 years of coding Go, I have only once seen a single use for <strong class="source-inline">***someType</strong> that was valid. Unlike in the movie <em class="italic">Inception</em>, there is no reason to go deeper.</p>
			<p>To sum up this section, you have gained an understanding of pointers, how to declare them, how to use them in your code, and where you should probably use them. You will use them on long-lived objects or<a id="_idTextAnchor100"/> types holding large amounts of data where copies are expensive. Next, let's explore structs.</p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor101"/>Getting to know about structs</h1>
			<p><strong class="bold">Structs</strong> represent a <strong class="bold">collection of variables</strong>. In the real world, we work with data all the time that would be well represented<a id="_idIndexMarker138"/> by a struct. For example, any form that is filled out in a job application or a vaccine card is a collection of variables (for example, last name, first name, and government ID number) that each has types (for examp<a id="_idTextAnchor102"/>le, <strong class="source-inline">string</strong>, <strong class="source-inline">int</strong>, and <strong class="source-inline">float64</strong>) and are grouped together. That grouping would be a struct in Go.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor103"/>Declaring a struct</h2>
			<p>There are two methods for declaring<a id="_idIndexMarker139"/> a struct. The first way is uncommon except in tests, as it doesn't allow us to reuse the struct's definition to create more variables. But, as we will see it later in tests, we will cover it here:</p>
			<p class="source-code">var record = struct{</p>
			<p class="source-code">     Name string</p>
			<p class="source-code">     Age int</p>
			<p class="source-code">}{</p>
			<p class="source-code">     Name: "John Doak",</p>
			<p class="source-code">     Age: 100, // Yeah, not publishing the real one</p>
			<p class="source-code">}</p>
			<p>Here, we created a struct that contains two fields:</p>
			<ul>
				<li><strong class="source-inline">Name</strong> (<strong class="source-inline">string</strong>)</li>
				<li><strong class="source-inline">Age</strong> (<strong class="source-inline">int</strong>)</li>
			</ul>
			<p>We then created an instance of that struct<a id="_idIndexMarker140"/> that has those values set. To access those fields, we can use the dot <strong class="source-inline">.</strong> operator:</p>
			<p class="source-code">fmt.Printf("%s is %d years old\n", record.Name, record.Age)</p>
			<p>This prints <strong class="source-inline">"John Doak is 100 years old"</strong>.</p>
			<p>Declaring single-use structs, as we have here, is rarely done. Structs become more useful when they are us<a id="_idTextAnchor104"/>ed to create custom types in Go that are reusable. Let's have a look at how we can do that next.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor105"/>Declaring a custom type</h2>
			<p>So far, we have created<a id="_idIndexMarker141"/> a single-use struct, which generally is not useful. Before we talk about the more common way to do this, let's talk about creating <strong class="bold">custom types</strong>.</p>
			<p>Up until this point, we've seen the basic and pointer-wrapped types that are defined by the language: <strong class="source-inline">string</strong>, <strong class="source-inline">bool</strong>, <strong class="source-inline">map</strong>, and <strong class="source-inline">slice</strong>, for example. We can create our own types based on these basic types using the <strong class="source-inline">type</strong> keyword. Let's create a new type called <strong class="source-inline">CarModel</strong> that is based on the <strong class="source-inline">string</strong> type:</p>
			<p class="source-code">type CarModel string</p>
			<p><strong class="source-inline">CarModel</strong> is now its own type, just like <strong class="source-inline">string</strong>. While <strong class="source-inline">CarModel</strong> is based on a <strong class="source-inline">string</strong> type, it is a distinct type. You cannot use <strong class="source-inline">CarModel</strong> in place of a string or vice versa.</p>
			<p>Creating a variable of <strong class="source-inline">CarModel</strong> can be done similar to a <strong class="source-inline">string</strong> type:</p>
			<p class="source-code">var myCar CarModel = "Chevelle"</p>
			<p>Or, by using type conversion, as shown here:</p>
			<p class="source-code">myCar = CarModel("Chevelle") </p>
			<p>Because <strong class="source-inline">CarModel</strong> is based on <strong class="source-inline">string</strong>, we can convert <strong class="source-inline">CarModel</strong> back to <strong class="source-inline">string</strong> with type conversion:</p>
			<p class="source-code">myCarAsString := string(myCar)</p>
			<p>We can create new types based on any other type, including maps, slices, and functions. This can be use<a id="_idTextAnchor106"/>ful for naming purposes or adding custom<a id="_idIndexMarker142"/> methods to a type (we will talk about this in a moment).</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor107"/>Custom struct types</h2>
			<p>The most common way to declare<a id="_idIndexMarker143"/> a struct is using the <strong class="source-inline">type</strong> keyword. Let's create that record again, but this time let's make it reusable by declaring a type:</p>
			<p class="source-code">type Record struct{</p>
			<p class="source-code">     Name string</p>
			<p class="source-code">     Age int</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">     david := Record{Name: "David Justice", Age: 28}</p>
			<p class="source-code">     sarah := Record{Name: "Sarah Murphy", Age: 28}</p>
			<p class="source-code">     fmt.Printf("%+v\n", david)</p>
			<p class="source-code">     fmt.Printf("%+v\n", sarah)</p>
			<p class="source-code">}</p>
			<p>By using <strong class="source-inline">type</strong>, we have made a new type called <strong class="source-inline">Record</strong> that we can use again and again to create variables holding <strong class="source-inline">Name</strong> and <strong class="source-inline">Age</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Similar to how you may define two variables with the same<a id="_idTextAnchor108"/> type on a single line, you may do the same within a <strong class="source-inline">struct</strong> type, such as <strong class="source-inline">First, Last string</strong>.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor109"/>Adding methods to a type</h2>
			<p>A method is similar<a id="_idIndexMarker144"/> to a function, but instead of being independent, it is bound to a type. For example, we have been using the <strong class="source-inline">fmt.Println()</strong> function. That function is independent of any variable that has been declared. </p>
			<p>A method is a function that is attached to a variable. It can only be used on a variable of a type. Let's create a method that returns a string representation of the <strong class="source-inline">Record</strong> type we created earlier:</p>
			<p class="source-code">type Record struct{</p>
			<p class="source-code">     Name string</p>
			<p class="source-code">     Age int</p>
			<p class="source-code">}</p>
			<p class="source-code">// String returns a csv representing our record.</p>
			<p class="source-code">func (r Record) String() string {</p>
			<p class="source-code">     return fmt.Sprintf("%s,%d", r.Name, r.Age)</p>
			<p class="source-code">}</p>
			<p>Notice <strong class="source-inline">func (r Record)</strong>, which attaches the function as a method onto the <strong class="source-inline">Record</strong> struct. You can access the fields of <strong class="source-inline">Record</strong> within this method by using <strong class="source-inline">r.&lt;field&gt;</strong>, such as <strong class="source-inline">r.Name</strong> or <strong class="source-inline">r.Age</strong>.</p>
			<p>This method cannot be used outside of a <strong class="source-inline">Record</strong> object. Here's an example of using it:</p>
			<p class="source-code">john := Record{<a id="_idTextAnchor110"/>Name: "John Doak", Age: 100}</p>
			<p class="source-code">fmt.Println(john.String())</p>
			<p>Let's look at how we change a field's value.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor111"/>Changing a field's value</h2>
			<p>Struct values can be changed by using the variable<a id="_idIndexMarker145"/> attribute followed by <strong class="source-inline">=</strong> and the new value. Here is an example:</p>
			<p class="source-code">myRecord.Name = "Peter Griffin"</p>
			<p class="source-code">fmt.Println(myRecord.Name) // Prints: Peter Griffin</p>
			<p>It is important to remember that a struct is not a reference type. If you pass a variable representing a struct to a function and change a field in the function, it will not change on the outside. Here is an example:</p>
			<p class="source-code">func changeName(r Record) {</p>
			<p class="source-code">     r.Name = "Peter"</p>
			<p class="source-code">     fmt.Println("inside changeName: ", r.Name)</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">     rec := Record{Name: "John"}</p>
			<p class="source-code">     changeName(rec)</p>
			<p class="source-code">     fmt.Println("main: ", rec.Name)</p>
			<p class="source-code">}</p>
			<p>This will output the following:</p>
			<p class="source-code">Inside changeName: Peter </p>
			<p class="source-code">Main: John</p>
			<p>As we learned in the section on <strong class="bold">pointers</strong>, this is because the variable is copied, and we are changing the copy. For struct types that need to have fields that change, we normally pass in a pointer. Let's try this again, using pointers:</p>
			<p class="source-code">func changeName(r *Record) {</p>
			<p class="source-code">	r.Name = "Peter"</p>
			<p class="source-code">	fmt.Println("inside changeName: ", r.Name)</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() {</p>
			<p class="source-code">	// Create a pointer to a Record</p>
			<p class="source-code">	rec := &amp;Record{Name: "John"}</p>
			<p class="source-code">	changeName(rec)</p>
			<p class="source-code">	fmt.Println("main: ", rec.Name)</p>
			<p class="source-code">}</p>
			<p class="source-code">Inside changeName: Peter</p>
			<p class="source-code">Main: Peter</p>
			<p>This will output the following:</p>
			<p class="source-code">Inside changeName: Peter </p>
			<p class="source-code">Main: Peter</p>
			<p>Note that <strong class="source-inline">.</strong> is a <em class="italic">magic</em> operator that works on <strong class="source-inline">struct</strong> or <strong class="source-inline">*struct</strong>.</p>
			<p>When I declared the <strong class="source-inline">rec</strong> variable, I did not set the <strong class="source-inline">age</strong>. Non<a id="_idTextAnchor112"/>-set fields are set to the zero value<a id="_idIndexMarker146"/> of the type. In the case of <strong class="source-inline">Age</strong>, which is <strong class="source-inline">int</strong>, this would be <strong class="source-inline">0</strong>.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor113"/>Changing a field's value in a method</h2>
			<p>In the same way that a function<a id="_idIndexMarker147"/> cannot alter a non-pointer struct, neither can a method. If we had a method called <strong class="source-inline">IncrAge()</strong> that increased the age on the record by one, this would not do what you wanted:</p>
			<p class="source-code">func (r Record) IncrAge() {</p>
			<p class="source-code">     r.Age++</p>
			<p class="source-code">}</p>
			<p>The preceding code passes a copy of <strong class="source-inline">Record</strong>, adds one to the copy's <strong class="source-inline">Age</strong>, and returns. </p>
			<p>To actually increment the age, simple mak<a id="_idTextAnchor114"/>e <strong class="source-inline">Record</strong> a pointer, as follows:</p>
			<p class="source-code">func (r *Record) IncrAge() {</p>
			<p class="source-code">     r.Age++</p>
			<p class="source-code">}</p>
			<p>This will work as expected.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Here is a basic rule that will keep you out of trouble, especially when you are new to the language. If the <strong class="source-inline">struct</strong> type should be a pointer, then make all methods pointer methods. If it shouldn't be, then make them all non-pointers. Don't mix and match.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor115"/>Constructors</h2>
			<p>In many languages, <strong class="bold">constructors</strong> are specially-declared methods <a id="_idIndexMarker148"/>or syntax that are used to initialize fields in an object and sometimes run internal methods as setup. Go doesn't provide any specialized<a id="_idIndexMarker149"/> code for that, instead, we use a <strong class="bold">constructor pattern</strong> using simple functions. </p>
			<p>Constructors are commonly either called <strong class="source-inline">New()</strong> or <strong class="source-inline">New[Type]()</strong> when declaring a public constructor. Use <strong class="source-inline">New()</strong> if there are no other types in the package (and most likely won't be in the future).</p>
			<p>If we wanted to create a constructor that made our <strong class="source-inline">Record</strong> from the previous section, it might look like the following:</p>
			<p class="source-code">func NewRecord(name string, age int) (*Record, error) {</p>
			<p class="source-code">     if name == "" {</p>
			<p class="source-code">          return nil, fmt.Errorf("name cannot be the empty string")</p>
			<p class="source-code">     }</p>
			<p class="source-code">     if age &lt;= 0 {</p>
			<p class="source-code">          return nil, fmt.Errorf("age cannot be &lt;= 0")</p>
			<p class="source-code">     }</p>
			<p class="source-code">     return &amp;Record{Name: name, Age: age}, nil</p>
			<p class="source-code">}</p>
			<p>This constructor takes in a <strong class="source-inline">name</strong> and <strong class="source-inline">age</strong> argument and returns a pointer to <strong class="source-inline">Record</strong> with those fields set. If we pass bad values for those fields, it instead returns the pointer's zero value (<strong class="source-inline">nil</strong>) and an error. Using this looks like the following:</p>
			<p class="source-code">     rec, err := NewRecord("John Doak", 100)</p>
			<p class="source-code">     if err != nil {</p>
			<p class="source-code">          return err</p>
			<p class="source-code">     }</p>
			<p>Don't worry about the error, as we will discuss it in the course of the book's journey.</p>
			<p>By now, you have learned<a id="_idIndexMarker150"/> how to use <strong class="source-inline">struct</strong>, Go's base object type. This included creating a struct, creating custom structs, adding methods, changing <a id="_idTextAnchor116"/><a id="_idTextAnchor117"/><a id="_idTextAnchor118"/>field values, and creating constructor functions. Now, let's look at using Go interfaces to abstract types.</p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor119"/>Comprehending Go interfaces</h1>
			<p>Go provides a type called an <strong class="bold">interface</strong> that stores any value<a id="_idIndexMarker151"/> that declares a set of methods. The implementing value must have declared this set of methods to implement the interface. The value may also have other methods besides the set declared in the interface type.</p>
			<p>If you are new t<a id="_idTextAnchor120"/>o interfaces, understand that they can be a little confusing. Therefore, we will take it one step at a time.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor121"/>Defining an interface type</h2>
			<p>Interfaces are most commonly defined<a id="_idIndexMarker152"/> using the <strong class="source-inline">type</strong> keyword that we discussed in the earlier section on structs. The following defines an interface that returns a string representing the data:</p>
			<p class="source-code">type Stringer interface {</p>
			<p class="source-code">          String() string</p>
			<p class="source-code">}</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="source-inline">Stringer</strong> is a real type defined in the standard library's <strong class="source-inline">fmt</strong> package. Types that implement <strong class="source-inline">Stringer</strong> will have their <strong class="source-inline">String()</strong> method called when passed to <strong class="source-inline">print</strong> functions in the <strong class="source-inline">fmt</strong> package.  Don't let the similar names confuse you; <strong class="source-inline">Stringer</strong> is the interface type's name, and it defines a method called <strong class="source-inline">String()</strong> (which is uppercase to distinguish it from the <strong class="source-inline">string</strong> type, which is lowercase). That method returns a <strong class="source-inline">string</strong> type that should provide some human-readable representation of your data.</p>
			<p>Now, we have a new type called <strong class="source-inline">Stringer</strong>. Any variable that has the <strong class="source-inline">String()</strong> <strong class="source-inline">string</strong> method can be<a id="_idIndexMarker153"/> stored in a variable of type <strong class="source-inline">Stringer</strong>. The following is an example:</p>
			<p class="source-code">type Person struct {</p>
			<p class="source-code">     First, Last string</p>
			<p class="source-code">}</p>
			<p class="source-code">func (p Person) String() string {</p>
			<p class="source-code">     return fmt.Sprintf("%s,%s", p.Last, p.First)</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">Person</strong> represents a record of a person, first and last name. We define <strong class="source-inline">String() string</strong> on it, so <strong class="source-inline">Person</strong> implements <strong class="source-inline">Stringer</strong>:</p>
			<p class="source-code">type StrList []string</p>
			<p class="source-code">func (s StrList) String() string {</p>
			<p class="source-code">     return strings.Join(s, ",")</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">StrList</strong> is a slice of strings. It also implements <strong class="source-inline">Stringer</strong>. The <strong class="source-inline">strings.Join()</strong> function used here takes a slice of strings and creates a single string with each entry from the slice separated by a comma:</p>
			<p class="source-code">// PrintStringer prints the value of a Stringer to stdout.</p>
			<p class="source-code">func PrintStringer(s Stringer) {</p>
			<p class="source-code">     fmt.Println(s.String())</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">PrintStringer()</strong> allows us to print the output of <strong class="source-inline">Stringer.String()</strong> of any type that implements <strong class="source-inline">Stringer</strong>. Both the types<a id="_idIndexMarker154"/> we created above implement <strong class="source-inline">Stringer</strong>.</p>
			<p>Let's see this in action:</p>
			<p class="source-code">func main() { </p>
			<p class="source-code">    john := Person{First: "John", Last: "Doak"} </p>
			<p class="source-code">    var nameList Stringer = StrList{"David", "Sarah"} </p>
			<p class="source-code">    PrintStringer(john)     // Prints: Doak,John </p>
			<p class="source-code">    PrintStringer(nameList) // Prints: David,Sarah </p>
			<p class="source-code">} </p>
			<p>Without interfaces, we would have to write a separate <strong class="source-inline">Print[Type]</strong> function for every type we<a id="_idTextAnchor122"/> wanted to print. Interfaces allow us to pass values that can do common operations defined by their methods.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor123"/>Important things about interfaces</h2>
			<p>The first thing to note about<a id="_idIndexMarker155"/> interfaces is that values <em class="italic">must</em> implement every method defined in the interface. Your value can have methods not defined for the interface, but it doesn't work the other way.</p>
			<p>Another common issue new Go developers encounter is that onc<a id="_idTextAnchor124"/>e the type is stored in an interface, you cannot access its fields, or any methods not defined on the interface.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor125"/>The blank interface – Go's universal value</h2>
			<p>Let's define a blank interface<a id="_idIndexMarker156"/> variable: <strong class="source-inline">var i interface{}. i</strong> is an interface with no defined methods. So, what can you store in that?</p>
			<p>That's right, you can store <em class="italic">anything</em>.</p>
			<p><strong class="source-inline">interface{}</strong> is Go's universal value container that can be used to pass any value to a function and then figure out what it is and what to do with it later. Let's put some things in <strong class="source-inline">i</strong>:</p>
			<p class="source-code">i = 3</p>
			<p class="source-code">i = "hello world"</p>
			<p class="source-code">i = 3.4</p>
			<p class="source-code">i = Person{First: "John"}</p>
			<p>This is all legal<a id="_idIndexMarker157"/> because each of those values has types that define all the methods that the interface defined (which were no methods). This allows us to pass around values in a universal container. This is actually how <strong class="source-inline">fmt.Printf()</strong> and <strong class="source-inline">fmt.Println()</strong> work. Here are their definitions from the <strong class="source-inline">fmt</strong> package:</p>
			<p class="source-code">func Println(a ...interface{}) (n int, err error)</p>
			<p class="source-code">func Printf(format string, a ...interface{}) (n int, err error)</p>
			<p>However, as the interface did not define any methods, <strong class="source-inline">i</strong> is not useful in this form. So, this is great for passing around values, but not using them. </p>
			<p class="callout-heading">Note about interface{} in 1.18:</p>
			<p class="callout">Go 1.18 has introduced<a id="_idIndexMarker158"/> an alias for the blank <strong class="source-inline">interface{}</strong>, called <strong class="source-inline">any</strong>. The Go standard<a id="_idIndexMarker159"/> library now uses <strong class="source-inline">any</strong> in place of <strong class="source-inline">interface{}</strong>. <a id="_idTextAnchor126"/>However, all packages prior to 1.18 will still use <strong class="source-inline">interface{}</strong>. Both are equivalent and can be used interchangeably.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor127"/>Type assertion</h2>
			<p>Interfaces can have their values <em class="italic">asserted</em> to either another interface<a id="_idIndexMarker160"/> type or to their original type. This<a id="_idIndexMarker161"/> is different than <strong class="bold">type conversion</strong>, where you change the type from one to another. In this case, we are saying <em class="italic">it already is this type</em>. </p>
			<p><strong class="bold">Type assertion</strong> allows us to change<a id="_idIndexMarker162"/> an <strong class="source-inline">interface{}</strong> value into a value that we can do something with. </p>
			<p>There are two common ways to do this. The first uses the <strong class="source-inline">if</strong> syntax, as follows:</p>
			<p class="source-code">if v, ok := i.(string); ok {</p>
			<p class="source-code">     fmt.Println(v)</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">i.(string)</strong> is asserting that <strong class="source-inline">i</strong> is a <strong class="source-inline">string</strong> value. If it is not, <strong class="source-inline">ok == false</strong>. If <strong class="source-inline">ok == true</strong>, then <strong class="source-inline">v</strong> will be the <strong class="source-inline">string</strong> value.</p>
			<p>The more common way is with a <strong class="source-inline">switch</strong> statement<a id="_idIndexMarker163"/> and another use of the <strong class="source-inline">type</strong> keyword:</p>
			<p class="source-code">switch v := i.(type) {</p>
			<p class="source-code">case int:</p>
			<p class="source-code">     fmt.Printf("i was %d\n", i)</p>
			<p class="source-code">case string:</p>
			<p class="source-code">     fmt.Printf("i was %s\n", i)</p>
			<p class="source-code">case float:</p>
			<p class="source-code">     fmt.Printf("i was %v\n", i)</p>
			<p class="source-code">case Person, *Person:</p>
			<p class="source-code">     fmt.Printf("i was %v\n", i)</p>
			<p class="source-code">default:</p>
			<p class="source-code">     // %T will print i's underlying type out</p>
			<p class="source-code">     fmt.Printf("i was an unsupported type %T\n", i)</p>
			<p class="source-code">}</p>
			<p>Our <strong class="source-inline">default</strong> statement prints out the underlying type of <strong class="source-inline">i</strong> if it did not match any of the other cases. <strong class="source-inline">%T</strong> is used to print the type information.</p>
			<p>In this section, we learned about Go's <strong class="source-inline">interface</strong> type, how it can be used to provide type abstr<a id="_idTextAnchor128"/><a id="_idTextAnchor129"/><a id="_idTextAnchor130"/><a id="_idTextAnchor131"/><a id="_idTextAnchor132"/><a id="_idTextAnchor133"/><a id="_idTextAnchor134"/><a id="_idTextAnchor135"/><a id="_idTextAnchor136"/><a id="_idTextAnchor137"/><a id="_idTextAnchor138"/><a id="_idTextAnchor139"/><a id="_idTextAnchor140"/><a id="_idTextAnchor141"/><a id="_idTextAnchor142"/><a id="_idTextAnchor143"/><a id="_idTextAnchor144"/><a id="_idTextAnchor145"/><a id="_idTextAnchor146"/><a id="_idTextAnchor147"/><a id="_idTextAnchor148"/><a id="_idTextAnchor149"/><a id="_idTextAnchor150"/><a id="_idTextAnchor151"/><a id="_idTextAnchor152"/><a id="_idTextAnchor153"/><a id="_idTextAnchor154"/><a id="_idTextAnchor155"/><a id="_idTextAnchor156"/><a id="_idTextAnchor157"/><a id="_idTextAnchor158"/><a id="_idTextAnchor159"/><a id="_idTextAnchor160"/><a id="_idTextAnchor161"/><a id="_idTextAnchor162"/><a id="_idTextAnchor163"/>action, and converting<a id="_idIndexMarker164"/> an interface into its concrete type for use.  </p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor164"/>Summary</h1>
			<p>In this chapter, you have learned the basics of the Go language. This includes variable types, functions, loops, methods, pointers, and interfaces. The skills acquired in this chapter provide the basic foundation needed to explore more advanced features of the Go language in our next chapter.</p>
			<p>Next, we will be looking at essential capabilities of the Go language, such as handling errors, using concurrency, and Go's testing framework.</p>
		</div>
	</div></body></html>