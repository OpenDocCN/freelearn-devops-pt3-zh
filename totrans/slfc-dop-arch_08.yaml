- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ticketing Systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll discuss the benefits of tracking your Salesforce changes
    in a ticketing system and how it contributes to a more efficient DevOps process.
    We’ll then look at three of the most common tools for tracking the progress of
    changes in Salesforce:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JIRA** is an issue-tracking and project management software developed by
    Atlassian that allows teams to plan, track, and release software'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asana** is a work management platform that helps teams collaborate, communicate,
    and coordinate work across projects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Work Items** are development tasks that are tracked in Azure DevOps
    to manage agile development processes and ship software more frequently'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will have a clear idea of not only the differences
    between these different types of packages but also when to use them and how to
    build them in Salesforce.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While this chapter isn’t intended to be a direct step-by-step guide for the
    products covered, should you wish to explore them, each one provides a free trial
    with which to learn:'
  prefs: []
  type: TYPE_NORMAL
- en: JIRA – [https://www.atlassian.com/software/jira](https://www.atlassian.com/software/jira)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asana – [https://asana.com/](https://asana.com/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure DevOps – [https://azure.microsoft.com/en-gb/free](https://azure.microsoft.com/en-gb/free)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The benefits of tracking your work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The foundation of any successful project relies on an organized approach toward
    task management and tracking. Utilizing a ticketing system in Salesforce DevOps
    offers multiple advantages.
  prefs: []
  type: TYPE_NORMAL
- en: Transparency
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All tasks and their statuses are visible to team members, fostering open communication
    and promoting teamwork. When everyone has visibility into what needs to be done
    and who is working on what, it eliminates duplicative work and makes coordinating
    easier.
  prefs: []
  type: TYPE_NORMAL
- en: This visibility provides benefits at multiple levels – for individual team members,
    team managers, cross-functional stakeholders, and leadership. For team members,
    having all tasks and current statuses in a central ticketing system lets everyone
    see what needs to be worked on and who is working on what. Immediately, developers
    can check which tickets are **In progress** versus **In code review** or **Ready
    for testing**. Testers can view what items are queued up for validation.
  prefs: []
  type: TYPE_NORMAL
- en: This real-time visibility eliminates duplicating efforts since people can coordinate
    based on the latest information. Team members don’t waste time working on the
    same task or miss blockers that are impeding progress. For managers, ticketing
    transparency helps gauge team workload, identify bottlenecks, and assess resource
    needs. A ticket backlog provides data to plan capacity. Tickets waiting for acceptance
    reveal where processes are slowing down.
  prefs: []
  type: TYPE_NORMAL
- en: Across teams such as product, UX, development, and QA, ticketing gives cross-functional
    transparency. Stakeholders can monitor progress on features or projects that require
    collaboration. Insight into each other’s workstreams enables better coordination.
  prefs: []
  type: TYPE_NORMAL
- en: For leadership, ticket data rolls up into reports that reflect completion rates,
    cycle times, and throughput. This high-level transparency helps executives understand
    team productivity, prioritization, and progress toward strategic goals.
  prefs: []
  type: TYPE_NORMAL
- en: Accountability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each ticket is assigned to a particular team member, which aids in individual
    performance tracking. With tickets tied to individuals, it is clear who is responsible
    for completing specific tasks that support monitoring productivity.
  prefs: []
  type: TYPE_NORMAL
- en: With a ticket assigned to a specific person, there is no ambiguity about who
    owns the work. Responsibilities are clear, which prevents tasks from slipping
    through the cracks if no one takes charge. Team members can be held accountable
    for meeting deadlines and delivering results.
  prefs: []
  type: TYPE_NORMAL
- en: Having tickets tied to owners enables monitoring productivity at an individual
    level. Both team members and managers can quickly check the status of a person’s
    assigned tickets to assess workloads and completion rates. This supports tracking
    performance and progress.
  prefs: []
  type: TYPE_NORMAL
- en: If certain tickets are stalled, it’s evident which team member needs to be approached
    to remove roadblocks. Similarly, when tickets exceed **service-level agreements**
    (**SLAs**), the accountable owner can be notified to take expedient action. From
    a project management perspective, being able to filter and view tickets by assignee
    makes it easy to gauge capacity and balance workloads across the team. Adding
    or removing team members from tickets helps scale resources appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond just assignments, some ticketing systems allow setting due dates, time
    estimates, and reminders. These features provide further accountability guardrails
    to help team members manage their time and priorities.
  prefs: []
  type: TYPE_NORMAL
- en: Prioritization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ticketing also facilitates prioritization. Tickets can be marked with priority
    levels or tagged, which allows the team to focus on the most business-critical
    items first.
  prefs: []
  type: TYPE_NORMAL
- en: One method is assigning priority levels such as P1, P2, and P3 to tickets. P1
    tickets would be critical issues or high-priority features that need to be worked
    on first. P2 and P3 tickets have lower priority and can be queued up behind higher-priority
    work.
  prefs: []
  type: TYPE_NORMAL
- en: Teams can also categorize tickets based on the type of work such as bugs, improvements,
    new features, and so on. Critical bugs that are impairing production systems would
    get prioritized above feature enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: In agile frameworks such as Scrum, prioritization is managed through product
    backlogs. Backlog items are ordered with the highest-value items at the top to
    be completed first in upcoming sprints. Some ticketing systems have built-in processes
    for validating and ranking requested work relative to business value before adding
    tickets. This gates entry into the backlog based on priority. Within a sprint
    backlog, assigning point values to tickets based on estimated effort also allows
    ordering by priority. Larger point tickets get worked on earlier.
  prefs: []
  type: TYPE_NORMAL
- en: At the team level, daily standups provide an opportunity to re-prioritize if
    any urgent or blocked tasks come up. Adjusting ticket priorities keeps the team
    focused. From a portfolio perspective, tagging tickets by strategic themes or
    objectives aids leadership in assessing priority across multiple projects and
    products.
  prefs: []
  type: TYPE_NORMAL
- en: Documentation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition, ticketing provides central documentation. Instead of valuable information
    being scattered across tools and conversations, details about tasks are documented
    within each ticket, creating a knowledge base that persists over time. This includes
    background details and context, requirements, acceptance criteria, design specifications,
    configurations, procedures, code snippets, testing steps, communications, and
    more.
  prefs: []
  type: TYPE_NORMAL
- en: Without ticketing, these important work details end up scattered across Slack
    conversations, emails, wikis, documents, Post-it notes, and individual notebooks.
    Critical information gets siloed and hard to find. However, with a unified ticketing
    system, everything related to a task is documented in one place in an organized
    manner. Team members can easily get up to speed on a ticket by reviewing its history
    and attachments.
  prefs: []
  type: TYPE_NORMAL
- en: Searching tickets allows quickly finding past solutions that can be applied
    to current issues or requirements. It prevents duplicating efforts when similar
    work has already been completed and documented. Well-documented tickets create
    organizational memory that persists even when team members leave or roles change.
    Historical tickets become valuable references and training resources.
  prefs: []
  type: TYPE_NORMAL
- en: From a process perspective, ticketing enables standardizing documentation practices
    across teams. Template ticket types can be defined to guide consistent information
    capture as tasks flow through workstreams.
  prefs: []
  type: TYPE_NORMAL
- en: Collaboration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In each of the chapters so far, collaboration is a recurring element of a successful
    Salesforce DevOps strategy. Having a unified ticketing system also aids collaboration
    across teams such as product, development, QA, support, and so on. It creates
    a shared source of truth for cross-functional transparency.
  prefs: []
  type: TYPE_NORMAL
- en: This transparency has a great deal of practical advantages. While individual
    items will still be controlled by the product owner in the early stages, a visible
    backlog presents a good opportunity for the development team to have input into
    stories that they feel might be too large or complex and need to break apart.
    It also allows the team to sketch out high-level implementation plans for stories
    and keep them together so that an individual developer isn’t left having to create
    a solution on their own, and that there’s a degree of consistency of approach
    regardless of who specifically picks up a ticket.
  prefs: []
  type: TYPE_NORMAL
- en: Ticketing systems create a common platform for these diverse teams to gain visibility
    into each other’s workstreams. For example, the product team can monitor engineering
    tickets to track progress on new features. Support can check the status of pending
    bug fixes. This insight across departments enables the identification of dependencies
    and risks early. Seeing blockers ahead of time allows teams to proactively collaborate
    on solutions instead of reacting down the line.
  prefs: []
  type: TYPE_NORMAL
- en: Tickets provide a centralized communication channel beyond just status updates.
    Teams can use the `@mention` function for relevant members for input, clarifying
    requirements, request approvals, or escalating issues through comments. For complex
    projects, people from different teams can be assigned jointly to collaborative
    tickets. This ensures alignment through shared ownership.
  prefs: []
  type: TYPE_NORMAL
- en: Some ticketing systems have agile project management capabilities, such as Kanban
    boards. This provides a visual collaborative workspace to manage tickets flowing
    through various stages. The ability to convert issues into actionable tickets
    and vice versa streamlines hand-offs between teams. Seamless transitions reduce
    fall-throughs during cross-functional workflows. An additional benefit of Kanban
    boards is the ability to limit the amount of work in progress at any given point
    in the life cycle. Not only does this help not overload development teams, but
    it also provides great visibility of the efficiency of your process. The limit
    in a particular column might mean things aren’t leaving quickly enough, are coming
    in too quickly, or both.
  prefs: []
  type: TYPE_NORMAL
- en: Reporting and analytics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ticketing systems collect valuable data that can be used to generate insightful
    reports and metrics on development workflows. This supports data-driven decisions
    and process improvements. Common ticket reports include summarizing workload by
    assignee, ticket type, priority, project, and so on. These views help identify
    bottlenecks and resource gaps.
  prefs: []
  type: TYPE_NORMAL
- en: Trend reports track things such as tickets opened/closed over time. Analytics
    around cycle time – from ticket creation to completion – help monitor the efficiency
    of development processes. Cycle time by ticket type or project provides insights
    into what areas need streamlining. Dashboard views can visually track ticket backlogs
    and SLA adherence. Other key metrics are lead time, throughput, and WIP limits
    – all of which help optimize process flows.
  prefs: []
  type: TYPE_NORMAL
- en: Reporting on time logged against tickets aids the accuracy of release and sprint
    planning based on historical velocity. Comparing estimated versus actual time
    helps improve effort estimation. For productivity, reports can show ticket completion
    rates by individual team members. Analyzing patterns may indicate the need for
    training, tooling improvements, or reallocations.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, data analytics helps correlate how process changes impact ticket throughput
    and cycle time. This guides where to focus optimization efforts for maximum gains.
  prefs: []
  type: TYPE_NORMAL
- en: Potential pitfalls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While ticketing systems in Salesforce DevOps offer considerable advantages,
    it’s crucial to acknowledge their potential pitfalls. One major risk is mistaking
    a backlog of tickets for actual planning. A well-maintained backlog is undoubtedly
    beneficial, but it’s no substitute for comprehensive plans, such as quarterly
    roadmaps, that provide a broader strategic view of the project’s objectives and
    timelines.
  prefs: []
  type: TYPE_NORMAL
- en: Another challenge lies in the nature of the content within the tickets. Relying
    solely on tickets for documentation can lead to fragmented and scattered information.
    This fragmentation makes it difficult to form a coherent, up-to-date picture of
    the project, as opposed to when well-organized, centralized documentation is available.
    It’s vital to complement ticketing systems with robust documentation practices
    to ensure clarity and continuity.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, the explicit handover of tickets between teams, if not managed thoughtfully,
    can lead to siloed operations. This runs counter to the ethos of DevOps, which
    emphasizes collaboration and integration across different teams. It’s essential
    to foster a culture where ticketing enhances communication and cooperation rather
    than creating barriers between different parts of the organization.
  prefs: []
  type: TYPE_NORMAL
- en: JIRA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JIRA, developed by Atlassian, is one of the most popular ticketing and project
    management tools, widely used for bug tracking, issue tracking, and agile project
    management. One of its main strengths is its flexibility. Teams can customize
    their workflows, create custom fields, and use various plugins to suit their unique
    needs. It integrates seamlessly with Salesforce, providing a unified and efficient
    workspace.
  prefs: []
  type: TYPE_NORMAL
- en: In a Salesforce DevOps context, JIRA can streamline the work process by creating
    a ticket for every task, bug, or feature. These tickets can be assigned, prioritized,
    and tracked until completion. JIRA’s reporting features give useful insights into
    the team’s performance, while its robust search capabilities help quickly find
    issues or tickets.
  prefs: []
  type: TYPE_NORMAL
- en: JIRA plays an integral role in managing end-to-end Salesforce development processes
    and enhancing DevOps collaboration through its flexible workflows and customizability.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a typical project workflow that uses JIRA to manage tasks. Our
    example assumes a reasonably large enterprise team made up of multiple roles,
    as this is the most typical use case seen with JIRA implementations.
  prefs: []
  type: TYPE_NORMAL
- en: The JIRA project life cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When starting the quarterly road mapping process, product managers rely on JIRA
    epics to define the major themes, features, and initiatives slated for the upcoming
    release. These high-level epics establish goals and direction for the team. As
    the product team delves further into details, those broad epics become populated
    with granular user stories, bugs, tasks, and subtasks. This hierarchy of issues
    captures both the big-picture vision and the incremental work needed to deliver
    on it.
  prefs: []
  type: TYPE_NORMAL
- en: By sprint planning, JIRA contains a trove of well-defined issues ready for execution.
    The Scrum team heavily utilizes JIRA’s agile capabilities to estimate issues,
    apply story points, and negotiate scope for the sprint. Release plans take shape
    by mapping dependencies and structuring issues into coherent sprints. Owners are
    assigned, risks discussed, and assumptions challenged so the team is aligned.
  prefs: []
  type: TYPE_NORMAL
- en: Once the sprint is underway, developers take ownership of JIRA issues to build
    solutions to complex problems. JIRA is tightly integrated into the entire development
    workflow for traceability and automation. User stories are worked on in feature
    branches in Git that reference the JIRA issue number. All commits explain the
    work done and map to an issue in commit messages. Pull requests for peer code
    reviews also call out the issues they address.
  prefs: []
  type: TYPE_NORMAL
- en: This connectivity between Git and JIRA provides end-to-end traceability on code
    changes tied to issues. It also enables automation opportunities. Code builds
    can intake JIRA issue IDs to automatically link failures and test results as comments
    or child issues. Transitioning issues through workflow stages can trigger events
    in continuous integration such as build jobs, deployments, or notifications.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when a developer completes coding for a user story, they merge
    the feature branch to the main branch. This triggers a continuous integration
    job that runs Apex tests and static analysis. If any failures arise, they are
    logged as child issues of the story in JIRA for the developer to address. Successful
    builds can automatically deploy the code changes to a Salesforce sandbox for QA
    testing. JIRA issues then progress to the QA testing and validation stages of
    the workflow.
  prefs: []
  type: TYPE_NORMAL
- en: QA engineers take an active role in Salesforce DevOps by automating validation
    to accelerate release cycles while improving quality. JIRA supports this through
    linked test cases, defects, and tight integration with CI/CD pipelines. QA logs
    detailed test steps, results, questions, media, and other issue comments as they
    verify user stories against acceptance criteria.
  prefs: []
  type: TYPE_NORMAL
- en: For efficient regression testing, they build automated test suites using frameworks
    such as Selenium and Jasmine for UI testing, and Apex unit tests for logic testing.
    These automated tests execute as part of continuous integration against feature
    branches and mainline code. QA sets up quality gates, so builds only progress
    if tests pass and code coverage thresholds are met.
  prefs: []
  type: TYPE_NORMAL
- en: Static code analysis is also baked into builds to check for vulnerabilities
    and enforce custom rulesets around code quality and best practices. Failures from
    any of these checks are logged as child issues or bugs, providing an audit trail
    on quality evolution.
  prefs: []
  type: TYPE_NORMAL
- en: When all automated validations pass and QA completes exploratory testing, the
    user story transitions through the JIRA workflow. This can often trigger a continuous
    delivery workflow to automatically deploy and validate the changes in a Salesforce
    sandbox. Downstream teams are notified of the deployment for user acceptance testing.
    However, there are some caveats to be aware of in this approach – if that deployment
    fails for some reason, you also need to handle that and revert the status to whatever
    it was before, which can certainly be more complex. It’s also worth noting that
    some teams enforce a “swim lane limit” on their JIRA boards to prevent too much
    work sitting at any one status. So, even if you do manage to revert the status
    of a ticket that is associated with a failed deployment, there might not be room
    to move it back to a work-in-progress status. To address these types of issues,
    many teams take the opposite approach, in which a JIRA ticket status is only updated
    upon successful deployment.
  prefs: []
  type: TYPE_NORMAL
- en: This comprehensive automation of unit, integration, UI, performance, security,
    compliance, and deployment testing enables rapid feedback on quality. JIRA provides
    traceability on tests, validations, and code changes tied to issues being delivered,
    while automation frees up QA staff for higher-value testing while enforcing quality
    standards.
  prefs: []
  type: TYPE_NORMAL
- en: JIRA is invaluable in enabling the communication rhythms and transparency needed
    for Salesforce DevOps collaboration. Standups centered around JIRA issues provide
    quick status checks on blockers and progress. Retrospectives leverage JIRA data
    on cycle times and velocity to continuously improve processes.
  prefs: []
  type: TYPE_NORMAL
- en: JIRA helps embed DevOps practices even without explicit agile frameworks. Breaking
    work into small issues enables rapid delivery and feedback. Tracking issues through
    defined workflows mirrors pipeline orchestration. Automated hand-offs based on
    JIRA transitions increase collaboration across teams.
  prefs: []
  type: TYPE_NORMAL
- en: Powerful reporting and dashboards spotlight trends, risks, and dependencies.
    Activity streams and notifications keep everyone informed of issue changes in
    real time. This level of transparency supported by JIRA fosters shared ownership
    across silos.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements and acceptance criteria logged in JIRA aid collaboration between
    developers, QA, security, and other teams. Smooth hand-offs happen by aligning
    early on issue details rather than last-minute surprises.
  prefs: []
  type: TYPE_NORMAL
- en: JIRA provides a digital backbone that enables Salesforce teams to inspect and
    adapt quickly based on real-time data. Tight integration with version control,
    test automation, and CI/CD pipelines accelerates feedback cycles.
  prefs: []
  type: TYPE_NORMAL
- en: Standups, retros, sprint planning, and work coordination all revolve around
    JIRA. It is an indispensable tool that empowers teams to deliver faster while
    improving quality and processes. JIRA can help cement an environment of continuous
    improvement, transparency, automation, and collaboration – the foundations of
    DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: A high-level JIRA workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your first step should be to create a JIRA project for your Salesforce release,
    with issue types for user stories, bugs, tasks, and so on. Within this project,
    you should then create epics to capture major features and initiatives for the
    release, and then break those epics down into user stories.
  prefs: []
  type: TYPE_NORMAL
- en: Developers pick up user stories from the backlog for sprint planning. Stories
    are estimated and prioritized before the user stories in the sprint are moved
    to **In Progress**.
  prefs: []
  type: TYPE_NORMAL
- en: Developers commit code to Git feature branches, referencing the JIRA issue number
    that relates to the user story. Once the work for an individual user story is
    complete, developers open pull requests when feature branches are ready for review.
    Pull requests link back to JIRA.
  prefs: []
  type: TYPE_NORMAL
- en: After some code review by peers, the pull requests are merged into the main
    branch, which may kick off automated builds. These builds execute Apex tests and
    static code analysis, with any failures tracked as issues in JIRA.
  prefs: []
  type: TYPE_NORMAL
- en: Successful builds can deploy code to a full copy sandbox for QA testing. QA
    tests user stories and logs any bugs as issues in JIRA for the developers to remediate.
    When user story acceptance criteria are met, QA moves the story to the **QA**
    **Approved** state.
  prefs: []
  type: TYPE_NORMAL
- en: A project manager should review the completed stories, with the product owner
    providing final approval. The project manager then batches approved stories for
    deployment to production via change sets.
  prefs: []
  type: TYPE_NORMAL
- en: A release manager typically coordinates the User Acceptance Testing (UAT) process
    and final deployment to production. After a successful release, the user stories
    are then marked as closed.
  prefs: []
  type: TYPE_NORMAL
- en: In the final review phase following a release, metrics can be gathered on team
    velocity, defect rates, and so on, and then the process repeats for subsequent
    sprints and releases.
  prefs: []
  type: TYPE_NORMAL
- en: This covers major steps such as sprint planning, CI/CD, code changes tied to
    issues, QA testing, approvals, and releases. The workflow is highly customizable
    in JIRA for each team’s needs – this is just a reasonably typical example.
  prefs: []
  type: TYPE_NORMAL
- en: Asana
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Asana provides a powerful work management platform designed to help teams effectively
    coordinate, track, and deliver work across the organization. At its core, Asana
    enables the creation of flexible workflows that map to team processes with customizable
    stages to track task status. Tasks can be organized in list views, kanban-style
    board views, or calendar views based on what works best for each team.
  prefs: []
  type: TYPE_NORMAL
- en: Adopting Asana as the project management platform of choice can significantly
    enhance a Salesforce development team’s ability to plan, track, and collaborate
    on everything from new feature requests to production bug fixes. By mirroring
    their entire development life cycle across differentiated Asana projects, teams
    gain end-to-end visibility and control across the process.
  prefs: []
  type: TYPE_NORMAL
- en: For example, creating separate projects for **Backlog**, **In Development**,
    **Code Review**, **QA Testing**, and **Production Release** provides a logical
    way to segment work as it flows from idea to deployment. Teams can further organize
    by dividing each project into sections based on workstream, application, or initiative.
    This helps cluster-related tasks and ensures continuity of effort.
  prefs: []
  type: TYPE_NORMAL
- en: With this foundation in place, let’s walk through how Asana can optimize productivity
    and coordination from initial intake through final release.
  prefs: []
  type: TYPE_NORMAL
- en: The Asana project life cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, requirement gathering is streamlined by creating a task for each new
    feature or enhancement request. The task can include a high-level description,
    expected delivery timeline, assignment to the appropriate developer or team, links
    to related documentation or tickets, and any other supporting details.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing requests in Asana provides traceability and easy reference later in
    the process. Custom fields can be defined to match the team’s way of working –
    for example, indicating the priority, level of effort, dependencies, or associated
    releases for each task.
  prefs: []
  type: TYPE_NORMAL
- en: During sprint planning and backlog grooming, managers can survey the landscape
    of outstanding requests and schedule the highest-value ones into upcoming iterations.
    Setting milestones and dependencies between tasks ensures proper sequencing and
    delivery of functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Once tasks are ready for active development, they can be moved into the **In
    Development** project. This provides developers with a clear view of their workload
    for the sprint. As work gets completed, developers can easily update the task
    status, log hours, attach screenshots or code snippets, and provide any other
    relevant commentary right within Asana.
  prefs: []
  type: TYPE_NORMAL
- en: For developers, Asana acts as a central workspace to track and execute their
    assigned tasks during the development phase. As soon as work is identified during
    sprint planning, corresponding tasks are created in an **In Development** Asana
    project and assigned to developers based on their roles and capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: These tasks contain all necessary context such as descriptions, due dates, story
    points, links to tickets or specs, and tags indicating the applications or features
    being worked on. By consolidating all this information in Asana, developers have
    clarity on what needs to be done without having to dig through inboxes or chat
    histories.
  prefs: []
  type: TYPE_NORMAL
- en: As work begins, developers can break down larger tasks into granular subtasks
    to represent stages of completion. They can also log hours directly within Asana
    to capture the time spent on each task. Inline comments allow developers to provide
    updates on progress, ask clarifying questions, or request feedback.
  prefs: []
  type: TYPE_NORMAL
- en: Code samples, screenshots, and other relevant artifacts can be attached to tasks
    as they are generated. Mentioning colleagues brings them into the conversation
    as needed. This creates a running record of progress and knowledge sharing that
    lives with the task.
  prefs: []
  type: TYPE_NORMAL
- en: For blocked or delayed tasks, developers can quickly raise red flags by updating
    statuses and notifying managers. Upon completion, tasks are marked as **Ready
    for QA**, which automatically routes them to the next stage in the workflow. Integrations
    with source control tools such as Git and Jenkins mean code commits and builds
    can automatically advance tasks through the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Upon feature completion, work moves into the **Code Review** project where QA
    engineers validate implementation according to specifications. If issues are identified,
    they can spawn new bug tasks linked to the parent for traceability. This tightens
    the feedback loop for developers. Once approved by QA, thoroughly tested code
    progresses to user acceptance testing and staging deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Automated integrations can be configured to update the task status upon successful
    deployment to each environment. This saves teams time manually tracking release
    activity. As work nears production readiness, the change log within Asana gives
    managers full context into what is slated to be released. Immediately, they can
    review all completed tasks, affected components, dependencies, and expected impact.
  prefs: []
  type: TYPE_NORMAL
- en: This level of transparency keeps managers informed and surfaces any roadblocks
    early. Team members can also be `@mentioned` in comments to loop them into discussions
    or solicit feedback on work in progress. If additional needs come up, new subtasks
    can be defined while retaining ties back to the original parent task.
  prefs: []
  type: TYPE_NORMAL
- en: With the full narrative visible, any last-minute changes can be minimized. After
    sign-off, the **Go** button can be clicked on approved production tasks. Peer
    reviews and spot checks post-deployment provide validation that everything rolled
    out smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: Now complete, tasks get marked as **closed** in Asana, creating a permanent
    audit trail from inception to completion. When sized correctly, tasks closed per
    sprint indicate team velocity, which can influence future planning and resourcing.
    Reviewing cycle time per task also uncovers any lags between environments.
  prefs: []
  type: TYPE_NORMAL
- en: Ongoing governance of Asana is required to shape role-based permissions, customize
    fields, set up automation, and monitor adoption. Project and task templates will
    help codify best practices and give teams a head start. Regular Asana training
    will ensure that team members are getting the best use of the full breadth of
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In common with other ticket-based task management systems, Asana contributes
    significantly to communication and collaboration within mature DevOps teams. For
    standups, tasks assigned to each developer are front-and-center with the latest
    updates visible. Team members can easily reference blocked tasks, new impediments,
    and the help needed to unblock progress. Managers gain insight into velocity across
    working threads.
  prefs: []
  type: TYPE_NORMAL
- en: Retrospectives are enhanced by looking at historical Asana data on cycle times,
    workload distribution, and completion rates by developer. This spurs data-driven
    root cause analysis and process improvements.
  prefs: []
  type: TYPE_NORMAL
- en: Backlog grooming is facilitated by having all candidate stories and defects
    sequenced in Asana with priority, scoping, and effort details. This information
    guides decision-making on what gets pulled into upcoming sprints.
  prefs: []
  type: TYPE_NORMAL
- en: The common thread is Asana centralizing all tasks, statuses, and supporting
    context to inform conversations. Unlike chat or email, this knowledge persists
    attached to tasks for future reference. Asana’s flexibility supports any preferred
    cadence of team rituals.
  prefs: []
  type: TYPE_NORMAL
- en: By providing transparency into who is doing what and by when, Asana fuels collaborative
    problem-solving, removal of blockers, and continuous improvement – core DevOps
    tenets. In this way, Asana contributes significantly to alignment, visibility,
    and velocity for Salesforce teams on the DevOps journey.
  prefs: []
  type: TYPE_NORMAL
- en: A high-level Asana workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Begin with creating Asana projects to represent each stage of your Salesforce
    development life cycle (e.g., **Backlog**, **In Development**, **Code Review**,
    **QA Testing**, and **Production Release**). Within each of these Asana projects,
    create sections for different workstreams such as new features, bugs, enhancements,
    and so on. When new tasks are created in Asana, link them to the corresponding
    Git repo for your project and branches that will contain the code changes for
    each task.
  prefs: []
  type: TYPE_NORMAL
- en: As developers work on tasks, they commit code changes frequently to Git branches
    named after the associated Asana task IDs. Upon completing development, developers
    push their feature branches to Git and move the Asana task into **Code Review**.
  prefs: []
  type: TYPE_NORMAL
- en: The QA team then pulls the feature branch to locally validate changes described
    in the Asana task, with any failures logged as new tasks. Once approved, the QA
    team merges validated code into a release candidate branch in Git. This triggers
    deployment to downstream environments.
  prefs: []
  type: TYPE_NORMAL
- en: Before the final production deployment, the Git diff is reviewed alongside the
    Asana change log as a final check. After the release branch is deployed to production,
    it is merged into the main branch.
  prefs: []
  type: TYPE_NORMAL
- en: All tasks related to the release are closed in Asana and, optionally, Git commit
    logs are linked to Asana tasks to maintain end-to-end traceability. As part of
    the release review process, code coverage and quality metrics are taken from Git
    to provide input on developer performance and areas needing improvement.
  prefs: []
  type: TYPE_NORMAL
- en: By integrating Git version control into this workflow, code changes are synchronized
    with project planning and testing processes in Asana. This provides comprehensive
    visibility and traceability.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Work Items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike the previous two solutions, Azure Work Items are a subset of the functionality
    of a much larger overall DevOps solution – one targeting multiple platforms, not
    just Salesforce. Azure DevOps provides a large set of collaborative development
    tools, including Azure Boards, and the Azure Work Items contained therein, for
    work tracking. When we look specifically at the parallels with JIRA or Asana,
    then Azure Boards, with its Work Items feature, helps teams plan, track, and discuss
    work across the entire development cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Work Items in Azure DevOps are a way to track tasks, bugs, features, and more.
    They can be organized into a hierarchy, so you can break down a large feature
    into manageable tasks and track progress at each level. You can visualize your
    work with Kanban boards, backlogs, custom dashboards, and reporting tools.
  prefs: []
  type: TYPE_NORMAL
- en: Azure DevOps acts as the source of truth for development tasks while Salesforce
    provides customer insights directly from service, sales, and marketing teams.
    Viewing each of these data sources, with their different perspectives on the current
    state of your Salesforce system, creates a valuable view of priorities. For example,
    customer service agents can view Azure DevOps bugs and features within Salesforce
    cases to stay updated on issue resolution for customers. They can easily link
    bugs to support cases to showcase customer impact to developers.
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, developers gain visibility into which bugs are linked to high-value
    accounts and opportunities nearing close. This helps technical teams prioritize
    the most critical defects over lesser items. Seeing the full context of each work
    item enables smarter triage and efficient use of development resources. Quicker
    resolution of high-priority defects improves customer retention and satisfaction.
  prefs: []
  type: TYPE_NORMAL
- en: On the flip side, when development teams complete items linked to Salesforce
    records, the changes instantly sync both ways. For instance, when a developer
    resolves a critical bug, the customer service agent sees the update in Salesforce
    immediately. This avoids unnecessary back-and-forth communication and keeps customers
    informed through centralized data.
  prefs: []
  type: TYPE_NORMAL
- en: With this bi-directional sync, work item updates in either system remain in
    real-time sync. Avoiding stale or duplicate data ensures accuracy and a single
    source of truth across departments. This increases process efficiency for collaborating
    on defect resolution.
  prefs: []
  type: TYPE_NORMAL
- en: Further enhancing collaboration, Salesforce users can easily track progress
    on Azure DevOps work from within familiar CRM views. For example, customer service
    managers can create custom Salesforce dashboards to monitor bug resolution timelines.
    Account managers can view features planned for a client right on the account record.
    There is no need to cross-reference disparate systems as all data lives natively
    in Salesforce. This simplifies how non-technical users interact with vital development
    tasks without needing to learn Azure DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: Turning to the developer side, importing Azure DevOps Work Items into Salesforce
    grants new levels of customer insight to inform technical tasks. In traditional
    siloed models, developers have limited visibility into client needs and business
    objectives. By linking work items to accounts, opportunities, and support cases,
    the full context of each item becomes clear.
  prefs: []
  type: TYPE_NORMAL
- en: With this customer focus, developers can understand the experience and frustration
    behind certain bugs. Seeing linked support cases with exact user steps to reproduce
    an error brings clarity faster than traditional isolated tickets. Engineers gain
    empathy and appreciation for the customer journey, which inspires building features
    that truly solve pain points.
  prefs: []
  type: TYPE_NORMAL
- en: The Azure Work Items life cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, diving deeper into Azure DevOps’ role specifically in the development phase
    of the DevOps life cycle, seamless Azure integration facilitates developer productivity
    and collaboration. Within a single Azure DevOps workspace, development teams can
    plan agile sprints, create work items, conduct repositories for source code, execute
    builds, manage testing, track defects, deploy to staging environments, and more.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a developer working on a user story can easily view linked bugs,
    test cases, branches, and builds all in one place. This removes toggling between
    disjointed systems to piece together context. Azure Boards tie connected items
    together for efficient coding with reduced overhead. Within boards, developers
    can assign granular tasks to individuals and track the hours spent on each item.
    This level of visibility enables accurate tracking of capacity and sprint progress.
    Automated burndown charts plot completion over time to pinpoint scope creep or
    blockers needing resolution.
  prefs: []
  type: TYPE_NORMAL
- en: For task management, customizable workflows enabled by Azure Boards allow the
    creation of subtasks, priority designation, status changes, assignment to individuals,
    tracking of remaining work, and more. Developers can break down larger stories
    into executable checklists of actionable development items.
  prefs: []
  type: TYPE_NORMAL
- en: With tasks established, developers utilize Azure Repos for secure source code
    management across Git and GitHub. Advanced version control features such as branching
    and merging enable developers to isolate changes during new feature creation.
    Repos safeguard code integrity throughout the coding process.
  prefs: []
  type: TYPE_NORMAL
- en: Next, by integrating with Azure Pipelines, developers can automatically build,
    test, and deploy with every code change to provide rapid feedback. Full traceability
    from commit to deployment simplifies root cause analysis. Failures get flagged
    quickly to maintain velocity.
  prefs: []
  type: TYPE_NORMAL
- en: For testing, developers leverage Azure Test Plans to create test cases that
    automatically integrate with builds. Testers can easily track which test cases
    need execution, view the status of test runs, and log defects. Linking bugs to
    failing tests accelerates resolution.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout development, teams utilize collaborative tools such as customizable
    team dashboards, built-in wikis, and discussion threads for improving visibility
    and alignment. With everything housed in Azure, developers reduce task switching
    and stay focused. By centralizing the dev life cycle into Azure DevOps, developers
    gain an agile, productive, and collaborative environment that is purpose-built
    for modern development. Integrating these capabilities with customer data from
    Salesforce completes the contextual picture that developers need to deliver innovative
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: A high-level Azure Work Items workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use Azure Work Items for tracking changes in a system using Azure DevOps
    Repos as the Git provider, you begin by setting up a project in Azure DevOps.
    This project serves as the central hub for both your code in Azure Repos and your
    project management activities in Azure Boards, which include your work items.
  prefs: []
  type: TYPE_NORMAL
- en: Once your project is established, the next step is to configure Azure Repos
    within this project. This involves initializing a new repository or importing
    an existing one into Azure Repos. This repository will store your code and track
    changes made over time.
  prefs: []
  type: TYPE_NORMAL
- en: After setting up your repository, the focus shifts to Azure Boards, where you
    manage your work items. These work items can range from features and user stories
    to tasks, bugs, and more, representing the different aspects of your project.
    The key here is to link these work items directly to the changes in your Azure
    Repos. This linking provides traceability and a clear history of what code changes
    relate to which project tasks.
  prefs: []
  type: TYPE_NORMAL
- en: To establish this link, when committing changes to your repository in Azure
    Repos, you include references to these work items in your commit messages. Azure
    DevOps automatically links these commits to the mentioned work items. For example,
    including a phrase such as `Fixes AB#123` in your commit message would link that
    commit to work item 123 in Azure Boards.
  prefs: []
  type: TYPE_NORMAL
- en: Within Azure Boards, you can view the development status and associated commits
    for each work item. This visibility allows you to track the progress of your development
    directly from the work items, offering a comprehensive view of both coding and
    project management activities.
  prefs: []
  type: TYPE_NORMAL
- en: This high-level workflow is integral for teams using Azure DevOps for their
    software development. It ensures a seamless integration between code management
    and project tracking, enhancing the overall efficiency and transparency of the
    development process.
  prefs: []
  type: TYPE_NORMAL
- en: For more detailed instructions and best practices, you should consult the official
    Azure DevOps documentation provided by Microsoft, which offers comprehensive guides
    and step-by-step tutorials for setting up and managing these integrations.
  prefs: []
  type: TYPE_NORMAL
- en: Using an Azure Work Items workflow with GitHub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is equally possible to use GitHub as your main Git provider and still take
    advantage of the tracking capabilities of Azure Work Items. We first install the
    Microsoft Azure Boards application from the GitHub Marketplace, which authorizes
    the integration between the two systems. Within GitHub, under **organization settings**,
    we can verify that the Azure Boards GitHub app has been authorized correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Next, in the Azure DevOps portal, we connect the Azure Boards organization to
    the designated GitHub account through **GitHub Connections**. Here, we specify
    the Azure DevOps organization, project, and repositories to sync with GitHub.
    Critical mappings are then configured in Azure Boards under the *repository mapping*
    section, aligning GitHub repos to Azure DevOps teams and branches.
  prefs: []
  type: TYPE_NORMAL
- en: With the integration setup, developers can now create pull requests and commit
    code changes within GitHub, referencing related Azure DevOps work items directly
    in the commit messages using the work item ID format prefixed with `AB` (for Azure
    Boards). For example, adding `AB#206` to your commit message would link to work
    item ID 206.
  prefs: []
  type: TYPE_NORMAL
- en: In the other direction, you can click the **Add Link** button on a work item
    and select **Existing Item** to add the URL link to a GitHub commit, pull request,
    or issue. This bidirectional linking between the two systems gives full traceability
    between coding activity and project tasks, user stories, bugs, and other work
    items managed in Azure Boards. The integration provides an efficient development
    workflow to maintain progress visibility as code evolves.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve discussed the enormous value and benefits that having
    a task tracking or ticketing system can bring when integrated into your DevOps
    workflow – both at a technical level through Git integration and in terms of giving
    visibility and organization of your work.
  prefs: []
  type: TYPE_NORMAL
- en: 'We looked at some of the common choices of tools that provide the capabilities
    needed to manage your tasks in a DevOps pipeline, as well as a high-level workflow
    for getting started with each system. Hopefully, this will give you both insight
    and inspiration to bring order to your development life cycle with these solutions.
    To aid your decision-making process, here’s a brief overview of each tool’s strengths
    and weaknesses:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature** | **JIRA** | **Asana** | **Azure** **Work Items** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Strengths** |  |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| **Project Management** | Advanced agile management, strong bug tracking |
    User-friendly, great for task and project management | Comprehensive agile planning,
    integrated with Azure DevOps |'
  prefs: []
  type: TYPE_TB
- en: '| **Customization** | Highly customizable, adaptable to complex workflows |
    Simple, easy to use, with basic customization | Highly customizable, supports
    complex workflows |'
  prefs: []
  type: TYPE_TB
- en: '| **Integration** | Deep integration with other Atlassian products | Good integration
    with various apps, including Salesforce | Strong integration with Microsoft products
    and services |'
  prefs: []
  type: TYPE_TB
- en: '| **Reporting** | Robust reporting and analytics | Basic but user-friendly
    reporting | Detailed reporting, analytics, and dashboards |'
  prefs: []
  type: TYPE_TB
- en: '| **Collaboration** | Good for technical teams, detailed tracking | Excellent
    for cross-functional team collaboration | Effective for teams deeply integrated
    with the Microsoft ecosystem |'
  prefs: []
  type: TYPE_TB
- en: '| **Scalability** | Scales well for large and complex projects | Suitable for
    teams of all sizes | Ideal for large teams, especially in enterprise environments
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Weaknesses** |  |'
  prefs: []
  type: TYPE_TB
- en: '| **User Interface** | Complex interface, steeper learning curve | Limited
    features for complex project management | Can be overwhelming for non-technical
    users |'
  prefs: []
  type: TYPE_TB
- en: '| **Pricing** | Can be expensive, especially for large teams | Premium features
    require paid plans | Can be costly, especially with additional Azure services
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Flexibility** | May be overly complex for simple projects | Less flexible
    for complex, technical projects | Tied closely to other Azure services, less standalone
    capability |'
  prefs: []
  type: TYPE_TB
- en: '| **Initial Setup and** **Learning Curve** | Requires time to set up and learn,
    especially for non-technical users | Easy to start with but has limitations for
    scaling | Requires familiarity with the Microsoft ecosystem |'
  prefs: []
  type: TYPE_TB
- en: '| **Collaboration Outside** **Technical Teams** | Less intuitive for non-technical
    team members | Excellent for all team types | Best suited for teams already using
    Microsoft tools |'
  prefs: []
  type: TYPE_TB
- en: Table 8.1 – A comparison of ticketing systems’ strengths and weaknesses
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll move on to another of the core pillars of Salesforce
    DevOps – backing up your data and your metadata. We’ll cover why it’s important
    to consider both as part of a robust backup strategy and discuss how the effectiveness
    of any backup lies in your ability to restore it quickly and easily.
  prefs: []
  type: TYPE_NORMAL
