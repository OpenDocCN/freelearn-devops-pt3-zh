<html><head></head><body>
		<div id="_idContainer040">
			<h1 id="_idParaDest-171" class="chapter-number"><a id="_idTextAnchor233"/>9</h1>
			<h1 id="_idParaDest-172"><a id="_idTextAnchor234"/>Handling Data with Puppet</h1>
			<p>This chapter will focus on how to handle data using Puppet. It will look at Hiera, Puppet’s key-value data lookup tool, and how it ensures that Puppet’s reusable code is made more configurable without burdening it with excessive logic and variables. The basic structure of Hiera will be reviewed, showing how it stores data in hierarchies that provide a rules-based key lookup without a lot of fuss and how it can look up keys in this data to return values using different backends, which are implementations such as YAML files of data or API calls to applications. The use of automatic parameter lookup will be discussed showing how this allows the parameterized profiles to receive data automatically and how the lookup function can be used in Puppet code directly to call data. We will briefly discuss the changes between Hiera 3 and Hiera 5 in terms of legacy Puppet. Then, the three Hiera layers will be reviewed in detail (the global, environment, and module layers), discussing how hierarchies and data should be managed in these different layers. The options available for lookup merging and priority behavior will be shown to highlight how data can either be found on the first match or by combining or merging different values found. We will then discuss when and where data should be used depending on the use case and best practice, and where the code should be kept in terms of directly in a control repo or in its own Hiera data repo. The security of data will then be discussed showing how data can be kept secure with different methods in storage, in transport, and while being used in Puppet code, highlighting the effects and limitations of using the <strong class="source-inline">Sensitive</strong> type, the <strong class="source-inline">node_encrypt </strong>module, and encryption of files via <strong class="source-inline">eyaml</strong>. Finally, some common issues and troubleshooting approaches/tools will be reviewed, showing how the <strong class="source-inline">lookup </strong>command can be optimally used to debug and explain values, and showing why we should never use global variables in hierarchies, how to avoid defaults, the dangers of using Hiera for classification, and how the <strong class="bold">Hiera Data Manager </strong>(<strong class="bold">HDM</strong>) can act as a tool to make your data <span class="No-Break">more accessible.</span></p>
			<p><a id="_idTextAnchor235"/>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>What <span class="No-Break">is Hiera?</span></li>
				<li><span class="No-Break">Hiera levels</span></li>
				<li>Deciding when to use static code or <span class="No-Break">dynamic data</span></li>
				<li>Keeping <span class="No-Break">data secure</span></li>
				<li>Pitfalls, gotchas, <span class="No-Break">and issues</span></li>
			</ul>
			<h1 id="_idParaDest-173"><a id="_idTextAnchor236"/>Technical requirements</h1>
			<p>Clone the control repo from <a href="https://github.com/puppetlabs/control-repo">https://github.com/puppetlabs/control-repo</a> to your GitHub account as <strong class="source-inline">controlrepo-chapter9 </strong>and update the following in this repo on the <span class="No-Break">production branch:</span></p>
			<ul>
				<li><strong class="source-inline">Puppetfile </strong><span class="No-Break">with </span><a href="https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch09/Puppetfile&#13;"><span class="No-Break">https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch09/Puppetfile</span></a></li>
				<li><strong class="source-inline">Manifests/site.pp </strong><span class="No-Break">with </span><a href="https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch09/site.pp&#13;"><span class="No-Break">https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch09/site.pp</span></a></li>
				<li>Create a branch from production called <strong class="source-inline">lab_error </strong>and replace <span class="No-Break">the following:</span><ul><li><strong class="source-inline">data</strong> <span class="No-Break">with </span><a href="https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch09/data&#13;"><span class="No-Break">https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch09/data</span></a></li><li><strong class="source-inline">hiera.yaml</strong> <span class="No-Break">with </span><a href="https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch09/hiera.yaml"><span class="No-Break">https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch09/hiera.yaml</span></a></li></ul></li>
			</ul>
			<p>Build a standard cluster with two Linux clients and two Windows clients by downloading the <strong class="source-inline">params.json</strong> file from <a href="https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch09/params.json ">https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch09/params.json </a>and updating it with the location of your control repo and your SSH key from the control repo. Then, run the following command from your <span class="No-Break"><strong class="source-inline">pecdm </strong></span><span class="No-Break">directory:</span></p>
			<pre class="source-code">
bolt --verbose plan run pecdm::provision –params @params.json</pre>
			<p>Let us first find out what Hiera is and why it <span class="No-Break">is used.</span></p>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor237"/>What is Hiera?</h1>
			<p>So far, we <a id="_idIndexMarker609"/>have discussed how using Puppet creates stateful and reusable code and how, by using the roles and profiles method, parameters can be made available to make modules configurable. We also showed how to use those parameters in code, but to create a scalable, readable, and site-specific data source, Puppet uses a tool called <strong class="bold">Hiera</strong>. Without using Hiera data in Puppet code, it would require endless logic and variables to represent data variations required for node exceptions, location differences, OS version variations, organization differences, and many <span class="No-Break">other circumstances.</span></p>
			<p>Hiera is a data lookup tool that looks up values in files of JSON, HOCON, YAML, and EYAML, the built-in backends, or using custom backends that can call external sources such as websites or databases. It stores data in key-value pairs that can be looked up either explicitly via a function call in code or automatically using the automatic parameter lookup, which matches parameter names from classes to Hiera data values. As this name would suggest, Hiera is focused on using a hierarchy to find data, and the lookups follow a common default with a hierarchy of data sources that override as a more specific node match is found for the data. The hierarchies are configured in a <strong class="source-inline">hiera.yaml </strong>file; this YAML file<a id="_idTextAnchor238"/> lists out the levels in order of priority. This <strong class="source-inline">hiera.yaml </strong>file sets the version of Hiera to be used, which is required, although <em class="italic">5 </em>is the only <span class="No-Break">active version.</span></p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor239"/>Using the built-in backends</h2>
			<p>For <a id="_idIndexMarker610"/>built-in backends in a hierarchy map, there will be a <a id="_idIndexMarker611"/>list of hierarchies, each of which will have <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">name </strong>– A readable label describing <span class="No-Break">the level</span></li>
				<li><strong class="source-inline">datadir </strong>– The base path relative to <strong class="source-inline">hiera.yaml </strong>where all data <span class="No-Break">is stored</span></li>
				<li><strong class="source-inline">data_hash </strong>– The Hiera backend/file type <span class="No-Break">to use</span></li>
				<li>Either <strong class="source-inline">path</strong>, <strong class="source-inline">paths</strong>, <strong class="source-inline">glob</strong>, <strong class="source-inline">globs</strong>, or <strong class="source-inline">mapped_paths </strong>– The file path or paths to the data relative <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">datadir</strong></span></li>
			</ul>
			<p>A default map<a id="_idIndexMarker612"/> can also be created with these keys so that values don’t need to be needlessly repeated in each layer of <span class="No-Break">the hierarchy.</span></p>
			<p>The <strong class="source-inline">data_hash </strong>lookup function key accepts <strong class="source-inline">yaml_data</strong>, <strong class="source-inline">json_data</strong>, and <strong class="source-inline">hocon_data </strong>as values but most Puppet implementations just use YAML data, so this book will default to the <span class="No-Break"><strong class="source-inline">yaml_data </strong></span><span class="No-Break">backend.</span></p>
			<p>The<a id="_idIndexMarker613"/> file path allows a hierarchy level to state a specific location for the data file of that hierarchy using variables interpolated in the code associated with the node, such <a id="_idIndexMarker614"/>as global variables associated with the <strong class="bold">External Node Classifier </strong>(<strong class="bold">ENC</strong>), discussed in <a href="B18492_11.xhtml#_idTextAnchor272"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, or facts and trusted facts. In YAML, the format is to use a percentage sign and a variable name within curly braces, <strong class="source-inline">%{&lt;variable_name}</strong>, and to call a fact, the <strong class="source-inline">facts </strong>array is accessed using dots (<strong class="source-inline">.</strong>). So, <strong class="source-inline">%{facts.application_owner} </strong>would access the <strong class="source-inline">application_owner </strong>fact. Further dots can be used to access structured facts, such as <strong class="source-inline">%{facts.os.family} </strong>to access the <strong class="source-inline">family </strong>value within the <strong class="source-inline">os </strong>fact. Trusted facts similarly are accessed from the <strong class="source-inline">trusted </strong>array, such as <strong class="source-inline">%{trusted.certname}</strong>, and trusted external facts can be accessed <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">%{trusted.external.pds.data}</strong></span><span class="No-Break">.</span></p>
			<p>So, a simple hierarchy could be created in the <strong class="source-inline">hiera.yaml </strong>file with the following piece <span class="No-Break">of code:</span></p>
			<pre class="source-code">
---
version: 5
defaults:
  datadir: data
  data_hash: yaml_data
hierarchy:
  - name: "Node data"
    path: "nodes/%{trusted.certname}.yaml"
  - name: "Location"
    path: "location/%{fact.data_center}.yaml"
  - name: "Common data"
    path: "common.yaml"</pre>
			<p>This <a id="_idIndexMarker615"/>hierarchy would mean that a host with the <strong class="source-inline">certname </strong>trusted fact of <strong class="source-inline">examplehost </strong>and a <strong class="source-inline">data_center </strong>fact of <strong class="source-inline">enterprisedc1 </strong>would first look in <strong class="source-inline">data/nodes/examplehost.yaml</strong>, then in <strong class="source-inline">data/location/enterprisedc1.yaml</strong>, and lastly, in the <strong class="source-inline">/data/common.yaml </strong><span class="No-Break">common file.</span></p>
			<p>It is also <a id="_idIndexMarker616"/>possible to combine multiple variable interpolations together on a path, such as updating the location layer to differentiate on another fact – for example, assuming a <strong class="source-inline">brand </strong>fact existed and different brands within the organization would have variation for a data center, <span class="No-Break"><strong class="source-inline">path: "location/%{facts.brand}-%{fact.data_center}.yaml"</strong></span><span class="No-Break">.</span></p>
			<p>So, if <strong class="source-inline">examplehost </strong>had the <strong class="source-inline">brand </strong>fact set to <strong class="source-inline">retail</strong>, it would look <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">data/location/retail-enterprisedc1.yaml</strong></span><span class="No-Break">.</span></p>
			<p>In these lookups, if it doesn’t find a matching file for its level, it will return nothing and go to the next level. Using the <strong class="source-inline">paths </strong>path file variable instead would allow simplification. Since the only real difference between the hierarchy levels is the path, it could instead be declared with a single hierarchy and paths with an array of <strong class="source-inline">paths</strong>. For example, the hierarchy from the previous example could be reduced to one layer <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">paths</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
 hierarchy:
  - name: "YAML layers"
    paths:
    - "nodes/%{trusted.certname}.yaml"
    - "location/%{fact.data_center}.yaml"
    - "common.yaml"</pre>
			<p>If additional Hiera <a id="_idIndexMarker617"/>layers were required for a different backend, it would need to be understood that any hierarchy would have all its paths examined in order before moving on to the next hierarchy, which may prevent this simplification to maintain the correct order <span class="No-Break">of hierarchy.</span></p>
			<p>In this section, we <a id="_idIndexMarker618"/>will cover globs, only because they can be found in code bases, but they should <em class="italic">not </em>be used, as they make the data structure a lot more complicated than any environment <span class="No-Break">truly needs.</span></p>
			<p>The file path can use <strong class="source-inline">glob </strong>or <strong class="source-inline">globs </strong>to pass Ruby’s style <strong class="source-inline">Dir.glob </strong>method. The full documentation of this can be viewed at <a href="https://www.puppet.com/docs/puppet/latest/hiera_config_yaml_5.html#specifying_file_paths ">https://www.puppet.com/docs/puppet/latest/hiera_config_yaml_5.html#specifying_file_paths. </a>This allows the use of <span class="No-Break">the following:</span></p>
			<ul>
				<li>An asterisk (<strong class="source-inline">*</strong>) as <span class="No-Break">a wildcard</span></li>
				<li>Two asterisks (<strong class="source-inline">**</strong>) to match recursively <span class="No-Break">through directories</span></li>
				<li>A question mark (<strong class="source-inline">?</strong>) to match any <span class="No-Break">one character</span></li>
				<li>A comma-separated list within curly braces (<strong class="source-inline">{this,that,or,not}</strong>) for a literal match with any option in <span class="No-Break">the list</span></li>
				<li>Sets of characters within square brackets (<strong class="source-inline">[xyz]</strong>) to match any one character in the <span class="No-Break">given set</span></li>
				<li>A backslash (<strong class="source-inline">\</strong>) to escape <span class="No-Break">special characters</span></li>
			</ul>
			<p>For example, take the <strong class="source-inline">facts.os.windows </strong>fact and then match either from <strong class="source-inline">display_id </strong>(which was introduced in later versions of Windows 2019) or from <strong class="source-inline">release_id </strong>(which was introduced in Windows 2016 and deprecated in Windows 2019). This combination allows a consistent Hiera layer for a source that has changed repeatedly and needs a combination of facts to find <span class="No-Break">different versions:</span></p>
			<pre class="source-code">
- name: "Windows Release"
  glob: "windows_release/{%{facts.windows.display_id},%{facts.windows.release_id}}"</pre>
			<p>To create <a id="_idIndexMarker619"/>a layer containing network information for the network <a id="_idIndexMarker620"/>on the primary interface or the network domain, the following code could be created, which would search through any directory structure in the network folder <span class="No-Break">to match:</span></p>
			<pre class="source-code">
- name: "Domain or Network"
    glob: "network/**/{%{facts.networking.domain},%{facts.networking.interfaces.ethernet.bindings.0.network}}.yaml"</pre>
			<p>If multiple matches are found, the files will be searched in alphanumerical order. Also, multiple strings can be used in the search using <strong class="source-inline">globs: </strong>and passing an array of strings in a similar fashion <span class="No-Break">to paths.</span></p>
			<p>The final file path option is <strong class="source-inline">mapped_paths</strong>. This option works by providing a variable containing a collection of strings, a variable name (which maps each element of the collection of strings), and a template. For example, if a fact called <strong class="source-inline">$oracle_sids </strong>contained the <strong class="source-inline">['ora1','ora2','ora3'] </strong>array, the following hierarchy would perform lookups in the <strong class="source-inline">/oracle_dbs/ora1.yaml</strong>,  <strong class="source-inline">/oracle_dbs/ora2.yaml</strong>, and <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">oracle_dbs/ora3.yaml </strong></span><span class="No-Break">files:</span></p>
			<pre class="source-code">
- name: "Oracle sids"
    mapped_paths: [oracle_sid, sid, "oracle_dbs/%{sid}.yaml"]</pre>
			<p>Although<a id="_idIndexMarker621"/> we have taken some time to cover globs, it’s important to reiterate that this should only be used to understand pre-existing complex data structures in code and for you to try and refactor and simplify. <em class="italic">This should not be used in new </em><span class="No-Break"><em class="italic">code bases</em></span><span class="No-Break">.</span></p>
			<p>Having <a id="_idIndexMarker622"/>discussed the hierarchy in detail, it’s now time to shift focus to the data used and how to call the lookups to the hierarchy. As was mentioned in the <em class="italic">Using the built-in backends </em>section, YAML is the most commonly used built-in data type and will be used in all examples, but the difference will only be in the presentation of the language rather than the actual <span class="No-Break">structures used.</span></p>
			<p>In the YAML data files, we create key-value pairs and keys with lists of values. The keys can just be single values but, more commonly, will be structured with the format <strong class="source-inline">&lt;module_name&gt;::&lt;paramater_name&gt;</strong>, where <strong class="source-inline">module_name </strong>can contain multiple segments reflecting a certain class namespace within <span class="No-Break">the module.</span></p>
			<p>To give an example of this, for the <strong class="source-inline">exampleapp </strong>profile module, a data file could contain the settings for the <strong class="source-inline">enable_service </strong>parameter to be <strong class="source-inline">true</strong>, it could contain an array of options of <strong class="source-inline">[opt1,opt2,opt3]</strong>, and for a <strong class="source-inline">user</strong>’s parameter, it could contain a hash of each user’s settings to be created for <strong class="source-inline">exampleuser </strong>and <strong class="source-inline">anotheruser</strong>. This would look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
---
profile::exampleapp::enable_service: true
profile::exampleapp::options:
  - opt1
  - opt2
  - opt3
profile::exampleapp::users:
  exampleuser:
    uid: 101
    home: /app/exampleapp
    gig: 102
  anotheruser:
    uid: 201</pre>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor240"/>Accessing data</h2>
			<p>The <a id="_idIndexMarker623"/>next point would be how this hierarchy and data is accessed in Puppet code and, as was mentioned at the beginning of this chapter, there are two ways Puppet looks up data in code: via the automatic class parameter lookup or via the Puppet lookup function. The recommended model involves driving virtually all data required via automatic parameter lookups to profile classes using the Role and Profile model (discussed in <a href="B18492_08.xhtml#_idTextAnchor212"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>) and <span class="No-Break">the Forge.</span></p>
			<p>The automatic class parameter lookup works by taking any parameters of a class that has been included/declared as a resource and, first, checking whether the parameter has been set by the declaration, and if not, performing a Hiera lookup on each parameter of the <strong class="source-inline">&lt;module_name&gt;::&lt; parameter_name&gt; </strong>form. It is important to note that this is not a namespaced key itself in Hiera; it is just a string name and values can’t be inserted into the data structure. In the case of using profiles and having a set profile module and an Oracle profile, this could look like <strong class="source-inline">profile::oracle::version</strong>. To set data for this, we might have a specific version for a <strong class="source-inline">server1.example.com </strong>node in a <strong class="source-inline">data/nodes/server1.example.com.yaml </strong>file, such as setting the version parameter for <strong class="source-inline">profile::oracle</strong> to Oracle 21c with the <span class="No-Break">following line:</span></p>
			<p><span class="No-Break"><strong class="source-inline">profile::oracle::version: 21c</strong></span></p>
			<p>If this lookup had failed, it would look to see whether any default value was set in the parameter in the class manifest, before then assigning it <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">undef</strong></span><span class="No-Break">.</span></p>
			<p>The data found in Hiera by default will return as a string or an array of strings; we will show later how this can <span class="No-Break">be converted.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The automatic class parameter lookups do not work for defined resource types, only classes. To mimic the functionality, you can use an explicit <strong class="source-inline">lookup() </strong>call in <span class="No-Break">your code.</span></p>
			<p>The <a id="_idIndexMarker624"/>other mechanism in Puppet code is the <strong class="source-inline">lookup </strong>function. It is more direct and can be used within Puppet code; it is called with a key, which can be multiple segments, each separated by two colons (<strong class="source-inline">::</strong>), or it can be simple global values. The colons are used here simply for convention and do not drill down into a data structure. To look up the same Oracle parameter, the following example would assign it to an <span class="No-Break"><strong class="source-inline">oracle_version </strong></span><span class="No-Break">variable:</span></p>
			<p><strong class="source-inline">$</strong><span class="No-Break"><strong class="source-inline">oracle_version=lookup(profile::oracle::version)</strong></span></p>
			<p>If the data is an array, it is possible to access a specific key using <span class="No-Break">dot notation:</span></p>
			<p><strong class="source-inline">$</strong><span class="No-Break"><strong class="source-inline">exampleuser_id=lookup(profile::exampleapp::users.exampleuser.id)</strong></span></p>
			<p>It is possible to provide a default value if no value is returned by using the arguments in the function or an options hash (the full options can be viewed in the documentation at <a href="https://www.puppet.com/docs/puppet/latest/hiera_automatic.html#puppet_lookup-arguments">https://www.puppet.com/docs/puppet/latest/hiera_automatic.html#puppet_lookup-arguments</a>) and providing a value to return – for example, to return the <strong class="source-inline">no id found </strong>string if the lookup in the previous example had returned no value, the following could <span class="No-Break">be used:</span></p>
			<p><strong class="source-inline">exampleuser_id=lookup(profile::exampleapp::users.exampleuser.id, {default_value =&gt; 'no </strong><span class="No-Break"><strong class="source-inline">id found'})</strong></span></p>
			<p>This will be discussed in more detail in the <em class="italic">Pitfalls, gotchas, and issues </em>section, but providing defaults is considered poor practice, as it hides failures and may make people assume a value has in fact been found and things are functioning correctly. It will also be noticed that the second and third arguments are marked as <strong class="source-inline">undef</strong>; these are for data type and the merge strategy, which will be <span class="No-Break">discussed next.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">lookup </strong>function replaces the legacy <strong class="source-inline">hiera_&lt;data_type&gt;  </strong>and <strong class="source-inline">hiera </strong>functions that existed with Hiera 3. As these functions are deprecated, they should not be used as they can produce <span class="No-Break">inconsistent results.</span></p>
			<p>What <a id="_idIndexMarker625"/>has been discussed so far is the simplest case, where we expect to simply look up a value and find the first match. This is Hiera’s default behavior and allows you to override values to varying degrees of specificity. Sometimes, though, you might want to return some combination of all the values present in all the layers of the hierarchy. Lookup options can be set in the data files to describe how this <span class="No-Break">should happen.</span></p>
			<p>The <strong class="source-inline">lookup_options </strong>reserved key allows for different merge behaviors to be set on lookups that are set against either a particular key or against a regular expression following <span class="No-Break">this format:</span></p>
			<pre class="source-code">
lookup_options:
  &lt;key name or regular expression&gt;:
  merge: &lt;MERGE OPTION&gt;</pre>
			<p>The most common approach is to put this behavior in the <strong class="source-inline">common.yaml </strong>file, but if, say, a node override or some priority override may be more important, it can make sense to then put it into different levels of <span class="No-Break">the hierarchy.</span></p>
			<p>There are four merge behaviors that can be set with the <span class="No-Break">data files:</span></p>
			<ul>
				<li><strong class="source-inline">first </strong>– Return the first match in the <span class="No-Break">hierarchy order</span></li>
				<li><strong class="source-inline">unique </strong>– Return an array of all matching unique values in <span class="No-Break">the hierarchy</span></li>
				<li><strong class="source-inline">hash </strong>– Return a hash of shallow merged hash keys using the highest hierarchy <span class="No-Break">key match</span></li>
				<li><strong class="source-inline">deep </strong>– Return a hash of deep merged hash keys using the highest hierarchy <span class="No-Break">key match</span></li>
			</ul>
			<p>Hiera’s <a id="_idIndexMarker626"/>default behavior, <strong class="source-inline">first</strong>, will look for the first value to match in hierarchy order. Assuming there is no other <strong class="source-inline">lookup_option </strong>value declared for the key, there is no need to implicitly declare it. But if, for example, <strong class="source-inline">common.yaml </strong>was set to <strong class="source-inline">unique </strong>and, for our node exception, we wanted to set only the values we had declared for <strong class="source-inline">profile:oracle::limits</strong>, we could set the following in our node’s YAML <span class="No-Break">data file:</span></p>
			<pre class="source-code">
lookup_options:
  profile::oracle::limits:
    merge: first</pre>
			<p>The <strong class="source-inline">unique </strong>keyword will find all matching keys and return a merged and flattened array. So, for example, if we wanted to install all requested Oracle versions in a profile, we could set <span class="No-Break">the following:</span></p>
			<pre class="source-code">
lookup_options:
  profile::oracle::versions
    merge: unique</pre>
			<p>If the <strong class="source-inline">11 </strong>value was found at the node level, <strong class="source-inline">12 </strong>at the organizational level, and <strong class="source-inline">11,13 </strong>found at the common hierarchy level, the returned value would be an array <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">[11,12,13]</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">hash </strong>keyword will merge hashes from all matching levels by merging the top-level keys of the hashes together. This essentially performs a shallow hash merge, which means that<a id="_idIndexMarker627"/> top-level keys are merged but the merge will not recursively descend and merge data structures nested underneath. This will keep the order in which the keys are written as matched from the lowest priority data source but will take the values from the highest priority source. It’s easiest to think of this as it is adding the keys to a hash as it steps from highest to lowest levels. It will override and append values as it does so but it won’t recursively merge the values in the keys. For example, imagine a lookup was performed on <strong class="source-inline">profile::oracle::limits </strong>and at the lowest level,  <strong class="source-inline">common.yaml </strong>existed and contained <span class="No-Break">the following:</span></p>
			<pre class="source-code">
lookup_options:
  profile::oracle::limits
    merge: hash
profile::oracle::limits:
  '*/nofile':
    soft: 2048
    hard: 8192
  'oracle/nofile':
    soft: 65536
    hard: 65536
  'oracle/nproc':
    soft: 2048
    hard: 16384
  'oracle/stack':
    soft: 10240
    hard: 32768</pre>
			<p>Then imagine that <strong class="source-inline">/node/examplenode.server.com.yaml </strong>had a higher priority <a id="_idIndexMarker628"/>due to the following <span class="No-Break"><strong class="source-inline">hiera.yaml </strong></span><span class="No-Break">section:</span></p>
			<pre class="source-code">
hierarchy:
  - name: "Per-node data"
    path: "nodes/%{trusted.certname}.yaml"
  - name: "Common data"
    path: "common.yaml"</pre>
			<p>And <strong class="source-inline">/node/examplenode.server.com.yaml </strong>contained <span class="No-Break">the following:</span></p>
			<pre class="source-code">
profile::oracle::limits:
  'oracle/nproc':
    soft: 4096
    hard: 16384
  'oracle/memlock':
    soft:  3145728
    hard:  4194304
  'oracle/stack':
    hard: 65536</pre>
			<p>The hash lookup on <strong class="source-inline">profile::oracle::limits </strong>would return <span class="No-Break">the following:</span></p>
			<pre class="source-code">
profile::oracle::limits:
  '*/nofile':
    soft: 2048
    hard: 8192
  'oracle/nofile':
    soft: 65536
    hard: 65536
  'oracle/nproc':
    soft: 4096
    hard: 16384
  'oracle/stack':
    hard: 65536
  'oracle/memlock':
    soft:  3145728
    hard:  4194304</pre>
			<p>Note that, in this case, the <strong class="source-inline">profile::oracle::limits.oracle/stack</strong> key was<a id="_idIndexMarker629"/> taken from the highest priority so only the hard value was seen, and no recursive merge was performed. This shortcut syntax with a dot (<strong class="source-inline">.</strong>) can be used to access an element in hash or array, where, in the case of an array, the index number <span class="No-Break">is used.</span></p>
			<p>A <strong class="source-inline">deep </strong>merge <a id="_idIndexMarker630"/>combines any number of hashes or arrays but is able to merge values inside the hash or array recursively. This means that <strong class="source-inline">hash </strong>values are merged with another <strong class="source-inline">deep </strong>merge and arrays are not flattened and can contain nested arrays. If the previous example lookup options were configured as <strong class="source-inline">deep_merge</strong>, then the lookup would return both hard and soft limits for the <span class="No-Break"><strong class="source-inline">oracle/stack </strong></span><span class="No-Break">key.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Merging more than three nested levels of nesting in a hash will have a serious performance impact on Hiera and should <span class="No-Break">be avoided.</span></p>
			<p>There are also options that can be assigned to affect the merging of arrays. For instance, <strong class="source-inline">sort_merged_arrays </strong>will result in the merged array being sorted by key rather than the default behavior, where the array is ordered from lowest priority to highest, and <strong class="source-inline">merge_hash_arrays</strong>, where hashes within arrays will be deep merged if set to <strong class="source-inline">true</strong>. One final option allows <strong class="source-inline">deep </strong>merges to have a <strong class="source-inline">knockout_prefix </strong>key, whereby a key containing a value, normally as double dashes (<strong class="source-inline">--</strong>), is used as a prefix before the value and will cause a value to be removed instead <span class="No-Break">of added.</span></p>
			<p>For example, if the<a id="_idIndexMarker631"/> model given in <a href="B18492_08.xhtml#_idTextAnchor212"><span class="No-Break"><em class="italic">Chapter 8</em></span></a><em class="italic"> </em>for using flexible classes is implemented, using a <strong class="source-inline">deep </strong>merge and a <strong class="source-inline">knockout </strong>prefix would allow classes to be added or removed at each <span class="No-Break">hierarchy level:</span></p>
			<pre class="source-code">
lookup_options:
 profile::base::extra_classes:
   merge:
     strategy: deep
     knockout_prefix: --
     sort_merged_arrays: true</pre>
			<p>Some example data could be for <strong class="source-inline">node/example.server.com.yaml</strong>, where the highest level of the hierarchy, <strong class="source-inline">node</strong>, contained the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
profile::base::extra_classes:
  - pci::dss
  - email</pre>
			<p>In contrast, <strong class="source-inline">datacenter/europe.dc.1.yaml</strong>, a lower hierarchy, contained <span class="No-Break">the following:</span></p>
			<pre class="source-code">
profile::base::extra_classes:
  - email
  - gdpr</pre>
			<p>This would result in a lookup on <strong class="source-inline">profile::base::extra_classes </strong>containing <strong class="source-inline">gdpr </strong>and <strong class="source-inline">pci::dss</strong>, in that order, but <span class="No-Break">not </span><span class="No-Break"><strong class="source-inline">email</strong></span><span class="No-Break">.</span></p>
			<p>So far, the <a id="_idIndexMarker632"/>examples have used the most common place to set <strong class="source-inline">lookup_options </strong>in <strong class="source-inline">common.yaml</strong>. But <strong class="source-inline">lookup_options </strong>performs a hash merge, which will take the highest order of each key found. So let’s say, for example, that <strong class="source-inline">/data/common.yaml</strong>, the lowest level, contained the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
lookup_options:
  profile::base::extra_classes:
    merge:
      strategy: deep
      knockout_prefix: --
      sort_merged_arrays: true</pre>
			<p>And <strong class="source-inline">/data/example.server.com.yaml</strong>, at a higher level, contained <span class="No-Break">the following:</span></p>
			<pre class="source-code">
lookup_options:
  profile::base::extra_classes:
    merge: first:</pre>
			<p>Then a lookup that matched the <strong class="source-inline">profile::base::extra_classes </strong>key in <strong class="source-inline">/data/example.server.com.yaml </strong>would use the first match lookup and not a <span class="No-Break"><strong class="source-inline">deep </strong></span><span class="No-Break">merge.</span></p>
			<p>Another lookup option is to use regex and the <strong class="source-inline">convert_to </strong>option, which converts values to something other than a string. One particularly useful example of this is when using values we wish to keep sensitive, we could simply add a regex string in the common<a id="_idIndexMarker633"/> level of the hierarchy, which would match all keys beginning with <strong class="source-inline">profile </strong>and a final key name that ended with <strong class="source-inline">password </strong>and ensure that the parameter was converted <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">Sensitive</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
---
lookup_options:
  '^profile::.+::\w+_password$':</pre>
			<p>In the <em class="italic">Keeping data secure </em>section, there will be more discussion on <span class="No-Break">securing data.</span></p>
			<p>While it is possible to essentially override the lookup settings set in the data file in the <strong class="source-inline">lookup </strong>function itself, we would strongly recommend against this as it could be confusing to have the data saying one thing and the <strong class="source-inline">lookup </strong>function behaving otherwise. It could lead to changes in the data that have unexpected consequences for the <strong class="source-inline">lookup </strong>function. If it is required, the syntax can be found in the documentation <span class="No-Break">at </span><a href="https://www.puppet.com/docs/puppet/8/hiera_automatic.html#puppet_lookup"><span class="No-Break">https://www.puppet.com/docs/puppet/8/hiera_automatic.html#puppet_lookup</span></a><span class="No-Break">.</span></p>
			<p>Interpolation is also available in Hiera data via both variables and functions. While this can be useful to avoid the repetition of data, it can also make the data vastly more complicated than we would want it to be, and in general, we would advise <span class="No-Break">against it.</span></p>
			<p>As with hierarchies using facts, <strong class="source-inline">trusted </strong>and <strong class="source-inline">server_facts </strong>can provide consistent variables, and the variables are interpolated in the same way, so a simple example would be to set a <strong class="source-inline">config </strong>file that uses the hostname <span class="No-Break">as follows:</span></p>
			<p><span class="No-Break"><strong class="source-inline">tivoli_config_file: '/opt/app/tivoli/client/%{trusted.hostname}.conf'</strong></span></p>
			<p>Hiera<a id="_idIndexMarker634"/> provides a limited number of special interpolation functions. They are not the same as Puppet functions. The following functions can be used to interpolate <span class="No-Break">Hiera data:</span></p>
			<ul>
				<li><strong class="source-inline">lookup </strong>(<span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">hiera</strong></span><span class="No-Break">)</span></li>
				<li><span class="No-Break"><strong class="source-inline">alias</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">literal</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">scope</strong></span></li>
			</ul>
			<p>Using the same format as variables, a function can be declared <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">${&lt;function&gt;(&lt;arguments&gt;)}</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">lookup </strong>function <a id="_idIndexMarker635"/>allows a Hiera value to be looked up from within the data. This can be useful to prevent data having to be repeatedly entered and reduce maintenance since, if the data changed, it would only need to be changed in one place. For example, something like a repository server could vary depending on the client’s location or be used repeatedly to provide the full location of packages. The following example shows how two binaries could provide their full paths using a lookup and <span class="No-Break">reduce repetition:</span></p>
			<pre class="source-code">
profile::base::artifactoryserver: artifactory.example.com
profile::exampleapp1::binary:  %{lookup (profile::base::artifactoryserver)}/exampleapp1.rpm
profile::anotherapp::binary:  %{lookup (profile::base::artifactoryserver)}/anotherapp.rpm</pre>
			<p>This would also make maintenance much simpler; if the artifactory server was to change, only one line would need to <span class="No-Break">be updated.</span></p>
			<p>The <strong class="source-inline">alias </strong>function<a id="_idIndexMarker636"/> allows for data structures in Hiera data to be returned since <strong class="source-inline">lookup </strong>would only return a string. So, if the <strong class="source-inline">base </strong>profile had an <strong class="source-inline">extensions </strong>parameter that took an array of strings and we wanted to pass the same list of extensions to another profile, <strong class="source-inline">exampleapp</strong>, it would be coded <span class="No-Break">like this:</span></p>
			<pre class="source-code">
profile::base::extensions:
  -  'option1'
  -  'option2'
  -  'option3'
profile::exampleapp::extensions: "%{alias(profile::base::extensions)}"</pre>
			<p>The <strong class="source-inline">literal </strong>function<a id="_idIndexMarker637"/> allows the escaping of the percentage<a id="_idIndexMarker638"/> sign (<strong class="source-inline">%</strong>) so that it does not assume it is for a variable or function to be interpolated. To do this, we use the <strong class="source-inline">%{literal('%')} </strong>function where a <strong class="source-inline">% </strong>sign is to be used. This can be useful in scenarios such as Apache configuration files or for Windows environmental variables; if, for example, we wanted to have the <strong class="source-inline">%PACKAGEHOME%/External </strong>string at <strong class="source-inline">profile::nuget::</strong>, then the following code could <span class="No-Break">be used:</span></p>
			<pre class="source-code">
profile::nuget::
: %{literal('%')}{PACKAGEHOME} %{literal('%')}</pre>
			<p>The <strong class="source-inline">scope </strong>function is<a id="_idIndexMarker639"/> likely only to be used in legacy code. It really just interpolates variables and only had a use case when Puppet variables were dynamically scoped. The same Tivoli example in this section would be written as <strong class="source-inline"> </strong><span class="No-Break"><strong class="source-inline">tivoli_config_file: '/opt/app/tivoli/client/%{scope(facts.hostname)}.conf'</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor241"/>Using custom backends</h2>
			<p>In <a id="_idIndexMarker640"/>addition to the built-in backends described so far, custom backends <a id="_idIndexMarker641"/>can be written or downloaded from the Forge and configured into Hiera. It is beyond the scope of this book to write custom backends but Puppet’s documenta<a id="_idTextAnchor242"/>tion covers how to write them <span class="No-Break">at </span><a href="https://www.puppet.com/docs/puppet/8/hiera_custom_backends.html#custom_backends_overview"><span class="No-Break">https://www.puppet.com/docs/puppet/8/hiera_custom_backends.html#custom_backends_overview</span></a><span class="No-Break">.</span></p>
			<p>Custom backends use one of three data types, selected based on their performance requirements for the type of data <span class="No-Break">being accessed.</span></p>
			<p>The <strong class="source-inline">data_hash </strong>backend type, as<a id="_idIndexMarker642"/> was seen for the built-in backend, is used for data sources that are cheap to read, such as files on a disk. This profile is used where the data is small, static, can be read all at once, and most of it gets used. It returns a hash of <span class="No-Break">key-value pairs.</span></p>
			<p>The <strong class="source-inline">lookup_key </strong>type is<a id="_idIndexMarker643"/> used for data sources that are expensive to read, such as secure HTTP API connections. This profile is used where the data is big, only part is used, and it can change during compilation. It returns a key pair. The most commonly used custom backend is <strong class="source-inline">hiera-eyaml </strong>for encrypting Hiera, which will be covered in detail in the <em class="italic">Keeping data </em><span class="No-Break"><em class="italic">secure </em></span><span class="No-Break">section.</span></p>
			<p>The <strong class="source-inline">data_dig </strong>backend type is <a id="_idIndexMarker644"/>used for data sources that access arbitrary elements of a collection, such as a database. With a similar profile to <strong class="source-inline">lookup_key </strong>but accessing subkeys of elements to return a key pair, the function will dig into a <span class="No-Break">dotted key.</span></p>
			<p>A final data type <a id="_idIndexMarker645"/>to mention is <strong class="source-inline">hiera3_backend</strong>, which was only relevant as a stepover from legacy Puppet setups; this book will not cover this configuration, but details can be found in the Puppet documentation at <a href="https://www.puppet.com/docs/puppet/8/hiera_config_yaml_5.html">https://www.puppet.com/docs/puppet/8/hiera_config_yaml_5.html</a>. The Puppet documentation advises how to migrate from Hiera 3 backends if you encounter them in legacy code <span class="No-Break">at </span><a href="https://www.puppet.com/docs/puppet/8/hiera_migrate.html"><span class="No-Break">https://www.puppet.com/docs/puppet/8/hiera_migrate.html</span></a><span class="No-Break">.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">From a user perspective, Hiera version 5 is an evolution of Hiera 3, with Hiera 4 as an experimental version, but Hiera 5 was fully implemented in Puppet itself while Hiera 3 was its own standing implementation. Puppet 7 and below has a dependency on a Ruby gem for Hiera version 3 to support any legacy Hiera 3 backends where <em class="italic">Hiera:Backend </em>was extended. This dependency was removed in <span class="No-Break">Puppet 8.</span></p>
			<p>These<a id="_idIndexMarker646"/> data types can then be combined with the file paths, as<a id="_idIndexMarker647"/> already discussed with the built-in backends, but with the additional paths of <strong class="source-inline">uri </strong>and <strong class="source-inline">uris </strong>to allow the direction to URIs such as <span class="No-Break">web sources.</span></p>
			<p>The <strong class="source-inline">options </strong>parameter then allows a hash of anything required by the custom backend, such as credentials or key information, and the content will depend on <span class="No-Break">the implementation.</span></p>
			<p>Most modules will explain in their README file how to use the <strong class="source-inline">options </strong>parameter. For example, <a href="https://forge.puppet.com/modules/petems/hiera_vault/">https://forge.puppet.com/modules/petems/hiera_vault/</a> is a Hiera backend for HashiCorp’s Vault; building on their example, the following code shows an example assuming that the keys would all start with <strong class="source-inline">secret_</strong>, come from a <strong class="source-inline">vault.example.com </strong>server, and have mounts for two teams (<strong class="source-inline">digital </strong>and <strong class="source-inline">trade</strong>), which used the node name, location, and <strong class="source-inline">common </strong>for their <span class="No-Break">secret hierarchy:</span></p>
			<pre class="source-code">
hierarchy:
  - name: "Vault secrets"
    lookup_key: hiera_vault
    options:
      confine_to_keys:
        - "^secret_.*"
      ssl_verify: false
      address: https://vault.example.com:8200
      token: notreallyatoken&gt;
      default_field: value
      mounts:
        digital:
          - %{::trusted.certname}
          - %{::trusted.extensions.pp_region}
          - common
        trade:
          - %{::trusted.certname}
          - %{::trusted.extensions.pp_region}
          - common</pre>
			<p>Another <a id="_idIndexMarker648"/>example is <a href="https://forge.puppet.com/modules/tragiccode/azure_key_vault/">https://forge.puppet.com/modules/tragiccode/azure_key_vault/</a>, allowing <a id="_idIndexMarker649"/>access to secrets in Azure, which, if we were to create a lookup based on the department assigned to the server looking for keys starting with <strong class="source-inline">secret</strong>, would look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
- name: 'Department Azure secrets'
    lookup_key: azure_key_vault::lookup
    options:
      vault_name: "%{trusted.extensions.pp_department}"
      vault_api_version: '2023-02-04'
      metadata_api_version: '2023-02-11'
      key_replacement_token: '-'
      confine_to_keys:
        - '^secret_.*'</pre>
			<p>In <a href="B18492_13.xhtml#_idTextAnchor321"><span class="No-Break"><em class="italic">Chapter 13</em></span></a>, the <strong class="bold">Puppet Data Service </strong>(<strong class="bold">PDS</strong>) will be examined, along with a series of backends <a id="_idIndexMarker650"/>useful <a id="_idIndexMarker651"/>for extending Puppet’s <span class="No-Break">data access.</span></p>
			<p>Now that we have reviewed how Hiera works, let us look at how it works in the different layers <span class="No-Break">of Puppet.</span></p>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor243"/>Hiera layers</h1>
			<p>Hiera has <a id="_idIndexMarker652"/>been discussed just in the context of the levels in a single hierarchy but there are three layers of hierarchy, each of which contains its own configuration of levels. When a lookup is performed by Puppet as part of a Puppet run, it will look through each of these layers, examining the levels of hierarchy <span class="No-Break">within each.</span></p>
			<p>The global layer<a id="_idIndexMarker653"/> is the first layer and is configured by default in <strong class="source-inline">$confdir/hiera.yaml</strong>, usually <strong class="source-inline">/etc/puppetlabs/puppet/hiera.yaml</strong>. Hiera version 3 only works at this layer, and its existence is more just a leftover for compatibility purposes. Puppet’s documentation suggests its only purpose should be for Hiera 3 compatibility and acting as a global override, but we would advise you to <em class="italic">not use it at all </em>since it exists outside of the code deployment and control processes, which will be reviewed in <a href="B18492_11.xhtml#_idTextAnchor272"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>. This would leave control of the file localized to the Puppet server, which would only be desirable if you wanted to step around the code <span class="No-Break">deployment process.</span></p>
			<p>The <a id="_idIndexMarker654"/>environment layer is the next and main layer of data, and it is configured inside each environment usually at a path such as <strong class="source-inline">/etc/puppetlabs/code/production/hiera.yaml</strong>. Environments and control repos will be discussed in complete detail in <a href="B18492_11.xhtml#_idTextAnchor272"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, but to understand the context here, an environment is a set of Puppet modules and manifests at fixed versions for a specific group of Puppet nodes, and a control repo is a module structure used to manage  the environments, containing a file called a Puppetfile detailing the sources of the modules, at which version they should be deployed, and where they should <span class="No-Break">be deployed.</span></p>
			<p>A choice needs to<a id="_idIndexMarker655"/> be made as to whether the <strong class="source-inline">hiera.yaml </strong>file and data will be contained in the control repo together, or whether to have a separate control repo and modules containing Hiera data. This is configured by the control repo deploying the modules typically into a data directory in the environment and ensuring that Hiera uses that data path in its <strong class="source-inline">hiera.yaml </strong>file. This separation can make sense when the control of a set of data needs to be managed by a certain team or group and containing it within the control repo would allow too much access/visibility. For example, if our <strong class="source-inline">hiera.yaml </strong>file was configured to use data as a source path, we could add Hiera data from a module into that path with an entry into <span class="No-Break">a Puppetfile:</span></p>
			<pre class="source-code">
mod 'exampleorg_hieradata',
  :git    =&gt; 'https://&lt;your_git_server&gt;/exampleorg/hieradata.git',
  :install_path =&gt; 'data'</pre>
			<p>The final layer <a id="_idIndexMarker656"/>is the module layer, and this is configured by a <strong class="source-inline">hiera.yaml </strong>file inside each module, typically with a data folder in the module too. So, when deployed in an environment on a server, the <strong class="source-inline">hiera.yaml </strong>file would be in a location such as <strong class="source-inline">/etc/puppetlabs/code/environments/production/modules/example_module/hiera.yaml</strong>. The best use for the module layer is to set defaults for the parameters of all classes in the modules, being careful to keep them relevant to the focus of the module, and not external organizational data, which would be better placed into the environment layer. An example of setting defaults can be seen in the <strong class="source-inline">puppetlabs/ntp </strong>module, available at <a href="https://github.com/puppetlabs/puppetlabs-ntp">https://github.com/puppetlabs/puppetlabs-ntp</a>, which sets defaults based on the OS version. The <strong class="source-inline">hiera.yaml </strong>file could also be configured to allow for increasing granularity of specific OS versions, going from defaults and a general OS family such as Windows to a specific full OS version, such as AlmaLinux-8.5, as shown in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
hierarchy:
  - name: 'Full Version' 
    path: '%{facts.os.name}-%{facts.os.release.full}.yaml' 
  - name: 'Major Version' 
    path: '%{facts.os.name}-%{facts.os.release.major}.yaml' 
  - name: 'Distribution Name' 
    path: '%{facts.os.name}.yaml' 
  - name: 'Operating System Family' 
    path: '%{facts.os.family}-family.yaml' 
  - name: 'common' 
    path: 'common.yaml</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">The module layer is often seen as an alternative to the <strong class="source-inline">params.pp </strong>class, which used to be part of the module pattern and contained default values and Hiera lookup calls. It was used before the modern Hiera layers existed with automatic <span class="No-Break">parameter lookups.</span></p>
			<p>You can only<a id="_idIndexMarker657"/> bind data keys in the module’s namespace, so in the <strong class="source-inline">exampleapp </strong>module, only <strong class="source-inline">exampleapp::key </strong>values could be set, not a global key such as <strong class="source-inline">key1 </strong>or another module such as <strong class="source-inline">anotherapp::key</strong>. This can lead to another pattern option particularly useful for in-house written modules, whereby this limitation is used to allow application teams to have full control of their environmental data for modules without being able to affect other modules. This <a id="_idIndexMarker658"/>might be a consideration for the profiles modules owned by a particular team who wishes to <span class="No-Break">manage expectations.</span></p>
			<p><strong class="source-inline">default_hierarchy </strong>is sometimes known as the fourth layer and is only available in the module layer; it essentially involves declaring a <strong class="source-inline">default_hierarchy </strong>key within the module hierarchy. The key difference with this layer is that it will only be called if there is no match within the other three layers, so there is no <span class="No-Break">merging behavior:</span></p>
			<pre class="source-code">
default_hierarchy:
  - name: 'defaults'
    path: 'defaults.yaml'
    data_hash: yaml_data</pre>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="source-inline">default_hierarchy </strong>produces the same behavior as the <strong class="source-inline">params.pp </strong>approach did since any match in the three Hiera layers will ignore and not merge any <span class="No-Break">matching values.</span></p>
			<p>Having reviewed these layers, this leads to a question of how should the hierarchies be constructed. Hierarchies can be made complicated very quickly but we should remember that the underlying approach is that they should be made to run from the most specific data for a node down to general data. They should be as short as possible since data files are easier to work with, and the more evaluations of hierarchies you create, the greater the impact on Puppet’s infrastructure performance. Too many backends (particularly customized backends) will create complications and external dependencies, which can break Puppet compilation. The Roles and Profiles method should allow less data to be managed in Hiera, and if built-in facts are not enough, custom facts can be created and multiple facts can be used in a <span class="No-Break">path together.</span></p>
			<p>The global level lends itself to just being structured on the name of the node and data common to all nodes since it would only be used for overrides outside of Puppet code <span class="No-Break">environment control.</span></p>
			<p>For the environment layer, the common structure of node data to look at is <span class="No-Break">as follows:</span></p>
			<ul>
				<li>The name of <span class="No-Break">the node</span></li>
				<li>The <span class="No-Break">node owner</span></li>
				<li>The <span class="No-Break">node’s purpose</span></li>
				<li>The location of <span class="No-Break">the node</span></li>
				<li>Data common to <span class="No-Break">all nodes</span></li>
			</ul>
			<p>This <a id="_idIndexMarker659"/>could lead to a simple hierarchy such as <span class="No-Break">the following:</span></p>
			<pre class="source-code">
- name: "Node data"
  path: "node/%{trusted.certname}.yaml"
- name: "Org data"
  path: "node/%{facts.org}.yaml"
- name: "Application-Tier"
  path: "app_tier/%{facts.app_tier}.yaml"
- name: "Datacenter"
  path: "datacenter/%{facts.datacenter}.yaml"
- name: "Common data"
  path: "common.yaml"</pre>
			<p>The module layer, as discussed, then just becomes a focus for defaults for values often based on facts such as OS version <span class="No-Break">and platform.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Do not use the <strong class="source-inline">environment </strong>fact itself in any hierarchy. Use the environment layer for <span class="No-Break">environment-based data.</span></p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor244"/>Lab – add data to a module</h2>
			<p>In this lab, download<a id="_idIndexMarker660"/> and update the Grafana module from <a href="B18492_08.xhtml#_idTextAnchor212"><span class="No-Break"><em class="italic">Chapter 8</em></span></a><em class="italic"> </em>to contain defaults in Hiera data instead of on <span class="No-Break">the parameters.</span></p>
			<p>To do this, let us assume the <strong class="source-inline">common.yaml </strong>file will contain all the present defaults <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">init.pp</strong></span><span class="No-Break">.</span></p>
			<p>For Red Hat, we will have the following: d<strong class="source-inline">ownload_source = '</strong><a href="https://dl.grafana.com/enterprise/release/grafana-enterprise-8.4.3-1.x86_64.rpm"><span class="No-Break">https://dl.grafana.com/enterprise/release/grafana-enterprise-8.4.3-1.x86_64.rpm</span></a><span class="No-Break"><strong class="source-inline">'package_provider ='yum'</strong></span><span class="No-Break">.</span></p>
			<p>While for Windows, we will have <span class="No-Break">the following:</span></p>
			<pre class="source-code">
download_source = 'https://dl.grafana.com/enterprise/release/grafana-enterprise-9.4.1.windows-amd64.msi'
package_provider = 'windows'</pre>
			<p>You can refer <span class="No-Break">to </span><a href="https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch08/grafana"><span class="No-Break">https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch08/grafana</span></a><span class="No-Break">.</span></p>
			<p>An example answer is <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch09/grafana&#13;"><span class="No-Break">https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch09/grafana</span><span class="No-Break">.</span></a></p>
			<p>Later, in the <em class="italic">Keeping data secure </em>section, it will be shown how the password can be properly secured and not just in plain text in the <span class="No-Break">YAML file.</span></p>
			<p>In this section, we have seen how to use the three layers of Hiera and how to structure the hierarchy in these layers. Now, we will look at when data should be used in Hiera and when it should just be used in <span class="No-Break">code directly.</span></p>
			<h1 id="_idParaDest-180"><a id="_idTextAnchor245"/>Deciding when to use static code or dynamic data</h1>
			<p>Having <a id="_idIndexMarker661"/>viewed all the possibilities of managing data structure and looking over the code examples covered in this book, it probably raises the question <a id="_idIndexMarker662"/>about when to write code and when to use data. <span class="No-Break"><em class="italic">Figure 9</em></span><em class="italic">.1 </em>highlights a decision tree <span class="No-Break">to follow:</span></p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/B18492_09_01.jpg" alt="Figure 9.1 – Data or code decision tree"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Data or code decision tree</p>
			<p>The first key thing is if the data doesn’t vary over nodes and it’s only used once, the simplest thing is to hardcode the data in Puppet code – for example, just directly setting the owner of a file as <strong class="source-inline">exampleuser </strong>in a file <span class="No-Break">resource attribute.</span></p>
			<p>If a value is used multiple times, then there is clearly a value in assigning a variable and using this variable where it is required. This simplifies maintenance if the value needs to be changed but does mean you have to keep track of variables when reading <span class="No-Break">the code.</span></p>
			<p>If, on the <a id="_idIndexMarker663"/>other hand, there is variation across nodes and overriding the <a id="_idIndexMarker664"/>value on certain conditions, the first question should be about how complex the logic is. If it is as simple as a single check, then the gain from abstracting into Hiera is not big; the issue with abstracting values into Hiera is that they are no longer clearly visible looking at the code and require translation and thought. So, if simple conditional logic can be used, it’s generally better to keep the values <span class="No-Break">in code.</span></p>
			<p>Once logic becomes more complicated and can vary based on combinations of conditions, then we can use Hiera data and an auto parameter lookup, or if it was found to be required, the <span class="No-Break"><strong class="source-inline">lookup </strong></span><span class="No-Break">function.</span></p>
			<p>It is also best throughout this to use the simplest method available at the time and escalate through the levels of complexity as code changes and grows. Creating complex data structures and performing abstraction for the future simply creates complexity and requires more work without really <span class="No-Break">gaining benefits.</span></p>
			<h1 id="_idParaDest-181"><a id="_idTextAnchor246"/>Keeping data secure</h1>
			<p>One of the <a id="_idIndexMarker665"/>key elements of managing data is ensuring that secret data is kept secure, and this can be challenging with Puppet when this data must be stored, transferred across the infrastructure to the client, and used within Puppet code to set the state. In this section, we will discuss the methods available to secure data, what levels data can be secured at, and the limitations of the methods used at <span class="No-Break">each level.</span></p>
			<p>The most common first step is to secure data in storage. This can be achieved using <strong class="source-inline">hiera-eyaml</strong>, a custom Hiera backend available at <a href="https://github.com/voxpupuli/hiera-eyaml">https://github.com/voxpupuli/hiera-eyaml</a>. This module creates <strong class="source-inline">pkcs7 </strong>keys, which are then used to encrypt and decrypt data. Having followed the instructions in the module to <a id="_idIndexMarker666"/>create and distribute keys, a hierarchy can be created, such as <span class="No-Break">the following:</span></p>
			<pre class="source-code">
hierarchy:
  - name: "Hiera data in yaml and eyaml files committed to the control-repo"
    lookup_key: eyaml_lookup_key
    options:
      pkcs7_private_key: /etc/puppetlabs/puppet/eyaml/private_key.pkcs7.pem
      pkcs7_public_key:  /etc/puppetlabs/puppet/eyaml/public_key.pkcs7.pem
    paths:
      - "nodes/%{trusted.certname}.yaml"
      - "location/%{facts.whereami}/%{facts.group}.yaml"
      - "groups/%{facts.group}.yaml"
      - "secrets/nodes/%{trusted.certname}.eyaml"
      - "os/%{facts.os.family}.yaml"
      - "common.yaml"</pre>
			<p>It can simplify the hierarchy to note that the <strong class="source-inline">eyaml </strong>backend can read YAML files too, and there’s no reason to separate <strong class="source-inline">yaml </strong>and <strong class="source-inline">eyaml </strong>files into different hierarchies assuming their path and options are the same, as shown in the <span class="No-Break">previous example.</span></p>
			<p><strong class="source-inline">hiera-eyaml </strong>is fine for simple encryption and limited numbers of users involved with encrypting secrets, but for larger setups, using <strong class="source-inline">gpg </strong>keys with <a href="https://github.com/voxpupuli/hiera-eyaml-gpg">https://github.com/voxpupuli/hiera-eyaml-gpg</a> becomes more practical rather than sharing signing keys amongst multiple teams. Once the configuration and key management are done, this simply varies by using <strong class="source-inline">gpg_gnugpghome </strong>options rather than <strong class="source-inline">pkcs7 </strong>key <a id="_idIndexMarker667"/>options, such as <span class="No-Break">the following:</span></p>
			<pre class="source-code">
    options:
      gpg_gnupghome: /opt/puppetlabs/server/data/puppetserver/.gnupg</pre>
			<p>An alternative to these encrypted data file approaches is if an appropriate secure key store exists, such as HashiCorp Vault, or a cloud-native key store, such as Azure Key Vault, then using a backend that can access these services will ensure data is <span class="No-Break">securely stored.</span></p>
			<p>Regardless of the backend choice, this will only ensure the data is secured in storage. As was discussed in the <em class="italic">Accessing data </em>section, by default, Hiera will return a string when accessed by Puppet code. <strong class="source-inline">lookup_options </strong>can be used to convert the parameter type to <strong class="source-inline">Sensitive </strong>in Puppet 5.5 and above, and care should be taken to ensure all secure parameters are covered either via wildcards or <span class="No-Break">explicit naming.</span></p>
			<p>Care must be taken to use the <strong class="source-inline">Sensitive </strong>data type well; it can be easy to either mistakenly keep it secured so the value can’t be used where it is needed or accidentally expose it when using the <span class="No-Break"><strong class="source-inline">unwrap </strong></span><span class="No-Break">function.</span></p>
			<p>When using <strong class="source-inline">file </strong>and <strong class="source-inline">content</strong>, for example, the following attempt to put <strong class="source-inline">secret_value </strong>into a <strong class="source-inline">/etc/secure </strong>file would be exposed on a file diff, which, as discussed in <a href="B18492_03.xhtml#_idTextAnchor048"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, is when a comparison of changes to files is recorded into the <span class="No-Break">report logs:</span></p>
			<pre class="source-code">
file {'/etc/secure':
  ensure =&gt; present,
  content =&gt; ${secret_value},
}</pre>
			<p>This <a id="_idIndexMarker668"/>could be prevented by setting the <strong class="source-inline">file_diff </strong>parameter to <strong class="source-inline">false </strong>or setting the server not to use <span class="No-Break">file diffs.</span></p>
			<p>Similarly, for templates, care must be taken. If using Puppet 6.2 or greater, then templates will work directly with Sensitive values and you can simply use the Sensitive value in <span class="No-Break">a template:</span></p>
			<pre class="source-code">
file {'/tmp/test1':
  ensure =&gt; present,
  content =&gt; (epp('example.epp', { 'password' =&gt; $secure_password })),
}</pre>
			<p>For versions below Puppet 6.2, you would need to unwrap the variable in the template and then mark the contents as Sensitive, as in <span class="No-Break">this example:</span></p>
			<p><strong class="source-inline">content =&gt; Sensitive(epp('example.epp', { 'password' =&gt; </strong><span class="No-Break"><strong class="source-inline">unwrap($secure_password)})),</strong></span></p>
			<p>Using <strong class="source-inline">Sensitive </strong>well keeps the data out of the logs, but unfortunately, not the catalog file itself, and if you are using PuppetDB, catalogs will be stored there too. In this case, using the <strong class="source-inline">node_encrypt </strong>module available at <a href="https://forge.puppet.com/modules/binford2k/node_encrypt">https://forge.puppet.com/modules/binford2k/node_encrypt</a> allows for any secret to be encrypted in the catalog using the clients’ keys, and using a <strong class="source-inline">Deferred </strong>function decrypts them at the time of catalog application. This keeps secrets out of the catalog and the report produced after a catalog <span class="No-Break">is applied.</span></p>
			<p>Assuming the instructions to configure <strong class="source-inline">node_encrypt </strong>have been followed on the infrastructure, this means the line assigning values to the <strong class="source-inline">content </strong>parameter in the previous<a id="_idIndexMarker669"/> piece of code could be updated to invoke the <strong class="source-inline">node_encrypt::secret </strong>function <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
content =&gt; (epp('example.epp', { 'password' =&gt; $secure_password })). node_encrypt::secret,</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">The current version of <strong class="source-inline">node_encrypt </strong>relies on <strong class="source-inline">Deferred </strong>functions, which became available in Puppet 6, so version 0.4.1 needs to be used to work on older versions, and you would use the <strong class="source-inline">node_encrypt::file </strong>type instead of the <strong class="source-inline">file </strong>type to encrypt <span class="No-Break">file resources.</span></p>
			<p>This section has shown how to keep data secure in storage, transport to catalog, and report processing, and some of the issues that can be experienced. In the next section, we will discuss general issues and problems when handling data <span class="No-Break">in Hiera.</span></p>
			<h1 id="_idParaDest-182"><a id="_idTextAnchor247"/>Lab – use eyaml to store a secret</h1>
			<p>In <a id="_idIndexMarker670"/>this lab, the <strong class="source-inline">puppet-hiera_eyaml </strong>module has been used to set up <strong class="source-inline">eyaml </strong>with default <strong class="source-inline">pkcs </strong>keys, with a global Hiera setup to look at the node name, OS, and common values. In <strong class="source-inline">site.pp</strong>, a Hiera lookup is performed to look up the value of <strong class="source-inline">secret::examplefiles</strong>, which is used as content to create a <strong class="source-inline">/var/tmp/secret_example </strong>file on the Puppet primary server. The lookup has a default of not set. In this lab, you will encrypt a secret and add it within the OS level so the content of the <span class="No-Break">file changes.</span></p>
			<p>SSH to the primary server and elevate <span class="No-Break">to root:</span></p>
			<pre class="source-code">
ssh centos@&lt;primary_host&gt;
sudo su -</pre>
			<p>Run the <strong class="source-inline">eyaml encrypt –p </strong>command from within the <strong class="source-inline">/etc/puppetlabs/puppet </strong>directory and enter a secret of your choice at <span class="No-Break">the prompt:</span></p>
			<pre class="source-code">
cd /etc/puppetlabs/puppet
eyaml encrypt -p</pre>
			<p>Copy the<a id="_idIndexMarker671"/> output after the string starting with <strong class="source-inline">ENC[ </strong>and paste it into the data section at <strong class="source-inline">/etc/puppetlabs/puppet/data/os/RedHat.eyaml </strong>so it contains something <span class="No-Break">like this:</span></p>
			<pre class="source-code">
---
secret::example: ENC[PKCS7,&lt;long string of chars&gt;]</pre>
			<p>Run <strong class="source-inline">puppet agent –t </strong>and observe the change in the <strong class="source-inline">/var/tmp/secret_example</strong> content to the content <span class="No-Break">you set.</span></p>
			<p>This was a very simple example and it should be noted, as was highlighted in the <em class="italic">Hiera layers </em>section, that you would more likely be using an environment hierarchy and keeping your data secure, as was shown in the <em class="italic">Keeping data secure </em>section, by using the Sensitive option in the lookup <strong class="source-inline">options </strong>parameter. Additionally, the public key used for <strong class="source-inline">eyaml </strong>could be copied to a desktop to encrypt secrets, if that was secure enough for your <span class="No-Break">organization’s policies.</span></p>
			<p>Now that we have fully reviewed the Hiera configuration, we will show how we can understand issues with lookup <span class="No-Break">and data.</span></p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor248"/>Pitfalls, gotchas, and issues</h1>
			<p>When <a id="_idIndexMarker672"/>working in large datasets with multiple levels and layers, it can become complicated to understand why certain answers have been generated or where errors have been inserted. This section will focus on approaches to understanding and debugging data lookups and tools that can make the data <span class="No-Break">more visible.</span></p>
			<p>Hiera problems tend to fall into a few categories: syntax, formatting, backend communication and <a id="_idIndexMarker673"/>performance issues, hierarchy ordering mistakes, and <span class="No-Break">many others.</span></p>
			<p>The <strong class="source-inline">puppet lookup </strong>command is the best way to test Hiera data and is, in effect, like the <strong class="source-inline">lookup </strong>function used in Puppet code. Using this on the primary server, the basic syntax of this command is <strong class="source-inline">puppet lookup &lt;key&gt; --node &lt;node_name&gt; --</strong><span class="No-Break"><strong class="source-inline">environment &lt;environment_name&gt;</strong></span><span class="No-Break">.</span></p>
			<p>This command will return the value, if found, or nothing. It is important to understand the effect of the various flags available to the command to return more detailed information. A common mistake is to use the <strong class="source-inline">--debug </strong>and <strong class="source-inline">--explain </strong>flags together; they shouldn’t be used together as the former is focused on high levels of logging to allow you to understand why errors such as syntax, formatting, or the backend are being generated, while the latter is focused on showing how a value was reached, where Hiera looked, and what <span class="No-Break">it found.</span></p>
			<p>For example, an <strong class="source-inline">explain </strong>lookup on <strong class="source-inline">motd::content </strong>might look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
puppet lookup --explain motd::content --node node-name --environment production
 Searching for "lookup_options"
  Global Data Provider (hiera configuration version 5)
    Using configuration "/etc/puppetlabs/puppet/hiera.yaml"
    Hierarchy entry "Classifier Configuration Data"
      No such key: "lookup_options"
  Environment Data Provider (hiera configuration version 5)
    Using configuration "/etc/puppetlabs/code/environments/production/hiera.yaml"
    Merge strategy hash
      Hierarchy entry "Yaml backend"
        Merge strategy hash
          Path "/etc/puppetlabs/code/environments/production/data/nodes/pe-server-0-540983.05eqwrwxv1ourfszstaygpgbth.zx.internal.cloudapp.net.yaml"
            Original path: "nodes/%{trusted.certname}.yaml"
            Path not found
          Path "/etc/puppetlabs/code/environments/production/data/common.yaml"
            Original path: "common.yaml"
           Found key: "motd::content" value: "test"</pre>
			<p>Looking at the <a id="_idIndexMarker674"/>output from debug, we see far more information with regards Facter and other system work going on, as can be seen from the command and sample output <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
<strong class="bold">puppet lookup motd::content –-node node-name –-environment production -–debug</strong>
Debug: Facter: Managed to read hostname: pe-server-0-d6a9f5 and domain: vhcpsckl41fedgadugqovud0sa.cwx.internal.cloudapp.net
Debug: Facter: Loading external facts
Debug: Facter: fact "domain" has resolved to: vhcpsckl41fedgadugqovud0sa.cwx.internal.cloudapp.net
Debug: Lookup of 'motd::content'
  Searching for "lookup_options"
    Global Data Provider (hiera configuration version 5)
      Using configuration "/etc/puppetlabs/puppet/hiera.yaml"
      Hierarchy entry "Example yaml"
        Merge strategy hash
          Path "/etc/puppetlabs/puppet/data/nodes/pe-server-0-d6a9f5.vhcpsckl41fedgadugqovud0sa.cwx.internal.cloudapp.net.eyaml"</pre>
			<p>Without a <a id="_idIndexMarker675"/>node being provided, the lookup will assume the lookup is for the server you are running the command from, and the environment will default <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">production</strong></span><span class="No-Break">.</span></p>
			<p>In terms of syntax and formatting problems, one of the most common errors is when the opening <strong class="source-inline">--- </strong>of the YAML file is malformed. This can happen in a couple <span class="No-Break">of ways:</span></p>
			<ul>
				<li>A space is inadvertently added to the start of the line or a Unicode character conversion takes place, changing it to <strong class="source-inline">—</strong>. In this case, an error in <strong class="source-inline">debug </strong>will look <span class="No-Break">like this:</span></li>
			</ul>
			<p><strong class="source-inline">Error: Could not run: (&lt;unknown&gt;): mapping values are not allowed in this context at line 2 </strong><span class="No-Break"><strong class="source-inline">column 8</strong></span></p>
			<ul>
				<li>If a space<a id="_idIndexMarker676"/> is inserted within the dashes, such as <strong class="source-inline">-- -</strong>, then an error in <strong class="source-inline">debug </strong>will be seen <span class="No-Break">like this:</span></li>
			</ul>
			<p><strong class="source-inline">Error: Could not run: (&lt;unknown&gt;): did not find expected '--' indicator while parsing a block collection at line 1 </strong><span class="No-Break"><strong class="source-inline">column 1</strong></span></p>
			<p>Another common syntax mistake is using key-value pairs without a space between the colon symbol (<strong class="source-inline">:</strong>) and the value; so <strong class="source-inline">key: value </strong>and <strong class="source-inline">key : value </strong>are valid but <strong class="source-inline">key:value </strong>is not and it will error in debugging <span class="No-Break">like so:</span></p>
			<p><strong class="source-inline">Error: Could not run: (&lt;unknown&gt;): mapping values are not allowed in this context at line 3 </strong><span class="No-Break"><strong class="source-inline">column 10</strong></span></p>
			<p>If tabs are used instead of spaces for indentation, then in debugging, an error will be caused such as <span class="No-Break">the following:</span></p>
			<p><strong class="source-inline">Error: Could not run: (&lt;unknown&gt;): found character that cannot start any token while scanning for the next token at line 4 </strong><span class="No-Break"><strong class="source-inline">column 1</strong></span></p>
			<p>For formatting, using single quotes in data with variables will result in a literal string of the variable name being returned instead <span class="No-Break">of interpolation.</span></p>
			<p>File permissions can also be an issue and, therefore, it is worth ensuring you are running the lookup commands as the same user, as Puppet will be typically running under the <strong class="source-inline">pe-puppet </strong>or <span class="No-Break"><strong class="source-inline">puppet </strong></span><span class="No-Break">user.</span></p>
			<p>Using <strong class="source-inline">--debug</strong>, it can <a id="_idIndexMarker677"/>be useful to see whether custom backends are the areas that experience issues, errors, or slowdowns. In general, we would recommend examining patterns such as the PDS and external <span class="No-Break">data providers.</span></p>
			<p>Be careful to note this will not debug the actual data but only the <strong class="source-inline">hiera.yaml </strong>file, data files that are not valid YAML will just be ignored, which can be seen <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">--explain</strong></span><span class="No-Break">.</span></p>
			<p>In terms of hierarchy problems, this is where the <strong class="source-inline">--explain </strong>flag will prove most useful since it will step through explaining the configuration files used, the hierarchies found, the merge strategy, and the paths examined in detail so that it becomes clear how it stepped through the hierarchy and how it may not be working <span class="No-Break">as expected.</span></p>
			<p>Depending on what variables are being used in your hierarchy, it may be required to use the <strong class="source-inline">--compile </strong>flag since, by default, when using Puppet <strong class="source-inline">lookup</strong>, it will not perform a catalog compilation, so only the <strong class="source-inline">$facts</strong>, <strong class="source-inline">$trusted</strong>, and <strong class="source-inline">$server_facts </strong>variables will be available. We strongly advise against using arbitrary values from manifests as these can vastly overcomplicate the lookup and produce <span class="No-Break">unpredictable results.</span></p>
			<p>From this, it can be seen that you always want to use the <strong class="source-inline">Facter </strong>array, to avoid the risk of module variables and top-scope <strong class="source-inline">Facter </strong><span class="No-Break">variables clashing.</span></p>
			<p>Some other options can be useful to test what would happen if you changed the configuration, such as changing the merge strategy with the <strong class="source-inline">--merge </strong>flag or by providing updating facts using <strong class="source-inline">--facts</strong>, <span class="No-Break">for example.</span></p>
			<p>The full command reference of options for lookups can be seen <span class="No-Break">at </span><a href="https://www.puppet.com/docs/puppet/latest/man/lookup.html"><span class="No-Break">https://www.puppet.com/docs/puppet/latest/man/lookup.html</span></a><span class="No-Break">.</span></p>
			<p>If updating the global Hiera file, be careful to <a id="_idIndexMarker678"/>restart the <strong class="bold">Puppet Server Services </strong>to ensure it <span class="No-Break">is re-read.</span></p>
			<p>Having touched<a id="_idIndexMarker679"/> on the point previously in the <em class="italic">Accessing data </em>section, we do not recommend using defaults on <strong class="source-inline">lookup </strong>functions. Data defaults in modules or profiles should be meaningful as well. So, providing the default config file location makes sense for a module if you expect most users just to use it, but if it is being added just to avoid failure in lookup, that can be a serious mistake and will mask issues in Hiera data or code that won’t be noticed, as the code is successfully applied with defaults. The key thing to avoid is passing a default value that then requires lots of logic in Puppet code to work out how to <span class="No-Break">translate it.</span></p>
			<p>Classification in Hiera is possible since some users choose to look up Hiera data and include classes in the <strong class="source-inline">site.pp </strong>file. Modules such as <a href="https://github.com/ripienaar/puppet-classifier">https://github.com/ripienaar/puppet-classifier</a> focus on this sort of approach. There is a balance of coding structure to consider, as can also be seen in our flexible roles and profiles approach. By putting too much data into Hiera, it can abstract away from clear coding since the data is then not directly visible in the code. So, it is best to consider whether the complexity elevation is <span class="No-Break">worth it.</span></p>
			<p>One of the issues of Hiera can be its structure, which makes it inaccessible to less involved users. To <a id="_idIndexMarker680"/>make Hiera data more visible, <strong class="bold">Betadots Hiera Data Manager (</strong><a href="https://forge.puppet.com/modules/betadots/hdm ">https://forge.puppet.com/modules/betadots/hdm) </a>is an excellent option as it allows graphical search, updates, and deletion of Hiera data. However, in production environments, this should be limited to just <span class="No-Break">viewing data.</span></p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/B18492_09_02.jpg" alt="Figure 9.2 – Hiera Data Manager example lookup"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Hiera Data Manager example lookup</p>
			<p>Another<a id="_idIndexMarker681"/> option to make Hiera data more accessible for self-service is the PDS, which will be discussed in detail in <a href="B18492_13.xhtml#_idTextAnchor321"><span class="No-Break"><em class="italic">Chapter 13</em></span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-184"><a id="_idTextAnchor249"/>Lab – troubleshoot Hiera</h1>
			<p>Troubleshoot<a id="_idIndexMarker682"/> the <a id="_idIndexMarker683"/>Hiera data in the <span class="No-Break">production environment:</span></p>
			<ol>
				<li>SSH to the primary server, elevate to root, and deploy the <span class="No-Break"><strong class="source-inline">lab_error </strong></span><span class="No-Break">environment:</span><pre class="source-code">
<strong class="bold">ssh centos@&lt;primary_host&gt;</strong>
<strong class="bold">sudo su -</strong>
<strong class="bold">puppet code deploy environment lab_error --wait</strong></pre></li>
				<li>Perform a lookup with the <strong class="source-inline">debug </strong>flag of the <strong class="source-inline">profile::error::example </strong>key on the primary server in the <strong class="source-inline">lab_error </strong>environment and work through the errors found, correcting them in your control repo and running the <strong class="source-inline">code deploy </strong>command from the <span class="No-Break">previous step:</span><pre class="source-code">
<strong class="bold">puppet lookup profile::error::example --debug --environment lab_error</strong></pre></li>
				<li>Resolve <a id="_idIndexMarker684"/>the errors in the data in <strong class="source-inline">controlrepo-chapter9/data </strong><span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">hiera.yaml</strong></span><span class="No-Break">.</span></li>
				<li>Run the <a id="_idIndexMarker685"/>same command with <strong class="source-inline">explain </strong>to understand how it gets to the current solution and why it is not finding a value based on its <span class="No-Break"><strong class="source-inline">os.family </strong></span><span class="No-Break">fact:</span><pre class="source-code">
<strong class="bold">puppet lookup profile::error::example --debug --environment lab_error</strong></pre></li>
				<li>Update the Hiera data in the <strong class="source-inline">control </strong>repo branch, <strong class="source-inline">lab_error</strong>, and redeploy so that the lookup now finds the value for the <strong class="source-inline">os.family </strong>fact of the <span class="No-Break">primary node:</span></li>
			</ol>
			<p><strong class="bold">puppet code deploy environment </strong><span class="No-Break"><strong class="bold">lab_error --wait</strong></span></p>
			<p><strong class="bold">puppet lookup profile::error::example --debug --</strong><span class="No-Break"><strong class="bold">environment lab_error</strong></span></p>
			<p>Check the commented solutions <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch09/data_solutions"><span class="No-Break">https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch09/data_solutions</span></a><span class="No-Break">.</span></p>
			<p>As part of  creating the lab environment in the <em class="italic">Technical requirements </em>section, HDM has been installed using the <strong class="source-inline">puppet-HDM </strong>module. Try using HDM to view the data following <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Open a web browser at <strong class="source-inline">http://&lt;public IP </strong><span class="No-Break"><strong class="source-inline">of puppetserver&gt;:3000</strong></span><span class="No-Break">.</span></li>
				<li>Complete the signup details to create an admin user (the details are <span class="No-Break">not important).</span></li>
				<li>Click <strong class="bold">Create a new user </strong>on the next page and enter <strong class="source-inline">non-admin user </strong>(the details again are <span class="No-Break">not important).</span></li>
				<li>Click<a id="_idIndexMarker686"/> the admin user name on the top right, log out, and<a id="_idIndexMarker687"/> then log back in as the non-admin user <span class="No-Break">you created.</span></li>
				<li>Select <strong class="source-inline">environment production </strong>and <strong class="source-inline">lab_error </strong><span class="No-Break">in turn.</span></li>
				<li>Explore the Hiera keys and values visible to HDM in <span class="No-Break">each environment</span><span class="No-Break">.</span></li>
			</ol>
			<h1 id="_idParaDest-185"><a id="_idTextAnchor250"/>Summary</h1>
			<p>In this chapter, we examined how Puppet can handle data using the Hiera tool, reducing how much complexity would need to be put into code to represent a node, data center, organizational, OS, and other configuration differences. Hiera was shown to be a tool based on hierarchies of data that allowed us to access different files based on facts. It had built-in backends for data to be stored in YAML, JSON, HOCON, and EYAML files. The data structure was shown; we examined how values could be put into data files and how lookups can be performed; the types of merge were examined here as well as how special setups such as <strong class="source-inline">knockout </strong>prefixes can be used <span class="No-Break">in arrays.</span></p>
			<p>We then showed how some custom backends can be used that have data types on different profiles; typically, these are specific integrations such as Vault or EYAML from the Forge, or in-house developed integrations to <span class="No-Break">access data.</span></p>
			<p>We then covered how Hiera worked over three layers – global, environment, and module – showing how global layers had little purpose in a modern Puppet setup but can be used as an override system, environment as the main source for data, and module allowing for defaults to be set on modules. Some common approaches to structuring hierarchies were then discussed, including an approach that stepped through the name of the node, the node owner, the node’s purpose, the location of the node, and common to all <span class="No-Break">nodes’ data.</span></p>
			<p>A review of how to make decisions on whether to use data in code or in Hiera showed that it depended on how flexible data needed to be, and this can vary from static data that is hardcoded in Puppet code to more advanced and flexible data requiring the full hierarchy to be described accurately. It was advised not to build ahead but to refactor as required so as not to make data more complicated than it needs <span class="No-Break">to be.</span></p>
			<p>We then discussed how to keep data secure in storage and transport, and when being used in Puppet catalogs, reports, and PuppetDB. We saw how to use <strong class="source-inline">eyaml</strong> to secure data in storage by encrypting values with the more flexible PGP approach, allowing multiple keys and teams. Then, the <strong class="source-inline">Sensitive </strong>value was shown to ensure values were not exposed in logs or code. This did not prevent values in catalogs and reports, and the <strong class="source-inline">node_encrypt </strong>module was shown to allow resources and values to be encrypted and be applied at configuration time using <span class="No-Break"><strong class="source-inline">Deferred </strong></span><span class="No-Break">functions.</span></p>
			<p>Approaches to debugging and troubleshooting were then reviewed, highlighting the difference between <strong class="source-inline">--explain </strong>and <strong class="source-inline">--debug</strong>. The former allows an understanding of how the hierarchy was reviewed and the latter returns errors such as syntax and failures with backends. The advice was given to be careful with using Hiera as a classifier, as this would abstract classification information away from code, but highlighted that the PDS did use this approach in <span class="No-Break">later chapters.</span></p>
			<p>In the next chapter, having reviewed the Puppet language in detail, the focus will change to the Puppet infrastructure. We will examine the open source components that make up the Puppet platform, how they make themselves available to the system via APIs, and how they communicate and log. The full Puppet agent life cycle will be examined, looking at the process of agent registration and communication with the platform. PuppetDB and PostgreSQL will be seen to allow the storage of data such as facts, reports, and catalogs, allowing discovery and examination with the <strong class="bold">Puppet Query Language </strong>(<strong class="bold">PQL</strong>). Compile servers will then be discussed as Puppet’s method of <span class="No-Break">scaling horizontally.</span></p>
		</div>
	

		<div id="_idContainer041" class="Content">
			<h1 id="_idParaDest-186"><a id="_idTextAnchor251"/>Part 3 – The Puppet Platform and Bolt Orchestration</h1>
			<p>In this part, you will understand how Puppet is structured as a platform, how the various components work together and communicate, and the common architecture approaches used to deliver scale. We will then show the various methods that can be used to classify which code is applied to servers and how code is versioned and deployed to infrastructure. Bolt will be introduced as Puppet’s way of running procedural scripts and code, which can be traditional scripts in various languages or plans based on the Puppet language. We will then review how you can monitor, tune, and integrate Puppet infrastructure with various tools and <span class="No-Break">third-party products.</span></p>
			<p>This part has the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B18492_10.xhtml#_idTextAnchor252"><em class="italic">Chapter 10</em></a>, <em class="italic">Puppet Platform Parts and Functions</em></li>
				<li><a href="B18492_11.xhtml#_idTextAnchor272"><em class="italic">Chapter 11</em></a>, <em class="italic">Classification and Release Management</em></li>
				<li><a href="B18492_12.xhtml#_idTextAnchor293"><em class="italic">Chapter 12</em></a>, <em class="italic">Bolt for Orchestration</em></li>
				<li><a href="B18492_13.xhtml#_idTextAnchor321"><em class="italic">Chapter 13</em></a>, <em class="italic">Taking Puppet Server Further</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer042" class="Basic-Graphics-Frame">
			</div>
		</div>
		<div>
			<div id="_idContainer043">
			</div>
		</div>
	</body></html>