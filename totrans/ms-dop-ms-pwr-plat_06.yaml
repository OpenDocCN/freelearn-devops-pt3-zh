- en: <st c="0">6</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2">A Deep Dive into Continuous Integration/Continuous Deployment (CI/CD)
    Pipelines</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="81">In this chapter, we will</st> <st c="106">get hands-on experience
    in designing</st> **<st c="144">Application Life</st>** **<st c="160">C</st>****<st
    c="162">ycle Management</st>** <st c="177">(</st>**<st c="179">ALM</st>**<st c="182">)
    processes for applications with both code first and low-code/no-code components.</st>
    <st c="266">In addition, we will cover how DevOps engineers can standardize pipelines</st>
    <st c="339">and refuel</st> <st c="350">them in any</st> <st c="362">other</st>
    <st c="368">new Power Platform projects, using</st> **<st c="404">pipeline templates</st>**
    <st c="422">and</st> **<st c="427">reusable workflows</st>** <st c="445">in</st>
    **<st c="449">Azure DevOps</st>** <st c="461">and</st> **<st c="466">GitHub</st>**
    <st c="472">as reusable building blocks.</st> <st c="502">We will gain insights</st>
    <st c="523">and a solid understanding of the</st> **<st c="557">ALM Accelerator
    for Power Platform</st>** <st c="591">package, part of the Power Platform Center
    of Excellence Starter Kit, and what we can reuse from this package in our own
    DevOps environment.</st> <st c="733">We will also learn about</st> **<st c="758">Power
    Platform pipelines</st>**<st c="782">, the managed pipelines, and how</st> <st
    c="814">they can leverage the features of professional DevOps tools, such as automated
    testing.</st> <st c="903">Finally, the chapter</st> <st c="923">will also teach
    us about</st> **<st c="949">automated testing</st>** <st c="966">with available
    open source frameworks</st> <st c="1004">and their integration into</st> **<st
    c="1032">Continuous Integration and Continuous Deployment</st>** <st c="1080">(</st>**<st
    c="1082">CI/CD</st>**<st c="1087">) pipelines.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1100">In this chapter, we’re going to cover the following</st> <st c="1153">main
    topics:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1165">When everything comes together – branches, environments, and Power</st>
    <st c="1233">Platform catalog</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1249">Azure pipeline templates and reusable</st> <st c="1288">GitHub
    workflows</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1304">The ALM Accelerator for</st> <st c="1329">Power Platform</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1343">Automated testing in DevOps and Power</st> <st c="1382">Platform
    pipelines</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1400">Technical requirements</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1423">To do a deep dive into our CI/CD pipelines by using pro-development
    DevOps tools, we need to have</st> <st c="1522">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="1536">A Power Platform subscription</st>**<st c="1566">: We can sign
    up for a Power Apps Developer Plan (</st>[<st c="1617">https://www.microsoft.com/en-us/power-platform/products/power-apps/free</st>](https://www.microsoft.com/en-us/power-platform/products/power-apps/free)<st
    c="1689">) if we already have a Microsoft Entra ID work account, or we can join
    the Microsoft 365 Developer</st> <st c="1789">Program (</st>[<st c="1798">https://developer.microsoft.com/en-us/microsoft-365/dev-program</st>](https://developer.microsoft.com/en-us/microsoft-365/dev-program)<st
    c="1862">).</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="1865">An Azure DevOps Services organization</st>**<st c="1903">: We
    can create a DevOps organization any time</st> *<st c="1951">for free</st>* <st
    c="1959">(</st>[<st c="1961">https://learn.microsoft.com/en-us/azure/devops/user-guide/sign-up-invite-teammates</st>](https://learn.microsoft.com/en-us/azure/devops/user-guide/sign-up-invite-teammates)<st
    c="2043">).</st> <st c="2047">If we create a public project in Azure DevOps, we
    get multiple free pipelines and free access to every feature of the service (see
    the</st> **<st c="2182">Azure DevOps for Open</st>** **<st c="2204">Source</st>**
    <st c="2210">offering).</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="2221">A</st> **<st c="2224">GitHub handle</st>** <st c="2237">and public
    repository (</st>[<st c="2261">https://github.com/signup</st>](https://github.com/signup)<st
    c="2287">), which is also</st> *<st c="2305">free</st>* <st c="2309">for</st>
    <st c="2314">public repositories.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="2334">Samples and walkthroughs discussed in this chapter are located</st>
    <st c="2398">at</st> [<st c="2401">https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/tree/main/Chapter06</st>](https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/tree/main/Chapter06)<st
    c="2500">.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="2501">When everything comes together</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2532">In the previous chapter, we saw how Azure DevOps Services pipelines
    and GitHub flows can interact with our Dataverse environments and Power Platform
    solutions to deliver DevOps</st> <st c="2710">CI/CD capabilities.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2729">Branches and environments</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="2755">If we follow the</st> <st c="2772">trunk-based branching strategy</st>
    <st c="2804">or the very similar</st> **<st c="2824">GitHub flow</st>**<st c="2835">,
    we will frequently create short-lived branches for development purposes.</st>
    <st c="2910">These branches are the</st> <st c="2932">so-called</st> **<st c="2943">feature
    branches</st>** <st c="2959">that we can use to implement new user requirements
    or fix bugs that our customers or our internal quality assurance process</st>
    <st c="3084">have found.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3095">We can use</st> **<st c="3107">Build Tools for Power Platform</st>**
    <st c="3137">and, respectively, the underlying</st> **<st c="3172">Pac CLI</st>**
    <st c="3179">to spin up</st> <st c="3191">developer</st> <st c="3201">environments.</st>
    <st c="3215">A typical branch</st> <st c="3231">structure of a particular solution
    might look</st> <st c="3278">as follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: <st c="3314">With the help of</st> **<st c="3332">branch policies</st>**<st
    c="3347">, we can force developers</st> <st c="3372">to use pull requests to merge
    back changes to test and/or main branches.</st> <st c="3446">In the case of Azure
    DevOps Services, if we configure any of the branch policies for a branch (</st>**<st
    c="3541">Require</st>** **<st c="3550">a</st>** **<st c="3552">minimum number
    of reviewers</st>**<st c="3579">,</st> **<st c="3581">Check for linked work items</st>**<st
    c="3608">,</st> **<st c="3610">Check for comment resolution</st>**<st c="3638">,
    or</st> **<st c="3643">Limit merge types</st>**<st c="3660">), that branch</st>
    <st c="3675">cannot be deleted and requires</st> **<st c="3707">pull requests</st>**
    <st c="3720">(</st>**<st c="3722">PRs</st>**<st c="3725">) for all changes.</st>
    <st c="3745">As such, we can avoid accidental changes directly committed to these</st>
    <st c="3814">dedicated branches:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Branch Policies](img/B22208_06_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="4609">Figure 6.1 – Branch Policies</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4637">Check for linked work items</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4665">We highly recommend enforcing this setting for your dedicated main
    and test branches.</st> <st c="4752">It just ensures that there can be no changes
    without well-defined user stories or</st> <st c="4834">backlog items.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4848">We can implement similar configurations on GitHub.</st> <st c="4900">This
    is called</st> **<st c="4915">branch protection rules</st>**<st c="4938">, and
    it provides even more</st> <st c="4965">options.</st> <st c="4975">For instance,
    we can require PR reviews before merging, require status checks to pass before
    merging, and restrict who can push to the branch.</st> <st c="5118">We can also
    force</st> **<st c="5136">signed commits</st>** <st c="5150">to verify the authenticity</st>
    <st c="5177">of a commit, by attaching a cryptographic signature to it.</st> <st
    c="5237">This signature is created using the committer’s private key and can be
    verified by others, using the committer’s public key.</st> <st c="5362">Signed
    commits provide assurance that code changes are made by a trusted and</st> <st
    c="5439">authorized source.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5457">The following figure shows all the protection rules</st> <st c="5509">available
    for</st> <st c="5524">GitHub branches:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Branch protection rules](img/B22208_06_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="7557">Figure 6.2 – Branch protection rules</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7593">Whichever DevOps tool we use, our goal is to create a DevOps framework
    in which professional developers can collaborate not just with each other but
    also with every developer (citizen developer).</st> <st c="7790">To set up the
    right</st> **<st c="7810">quality gates</st>** <st c="7823">during development,
    it is recommended</st> <st c="7861">to map our branch structure in dedicated and
    ad hoc/developer Power</st> <st c="7930">Platform environments:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Branches and environments](img/B22208_06_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="8032">Figure 6.3 – Branches and environments</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8070">In the preceding diagram, the arrows</st> <st c="8107">between
    the Power Platform environments and Git branches represent the code</st> <st c="8183">and
    deployment flows.</st> <st c="8206">The production environment</st> <st c="8232">and
    test environment can handle only PRs (i.e.</st> <st c="8280">the solution is only
    imported into those environments), whereas developer environments should be bidirectional,
    since changes in those environments will be exported back to Git repos and, respectively,
    dev branches.</st> <st c="8496">In our case, the</st> `<st c="8513">US_XXX_Y</st>`
    <st c="8521">branch represents</st> <st c="8539">a short-lived feature branch
    containing the implementation of a user story.</st> <st c="8616">CI/CD pipelines
    with different trigger conditions manage the interaction between the two worlds,
    starting from the beginning of a solution’s life cycle.</st> <st c="8769">Pipelines/workflows
    can even be used to create these automations throughout the</st> <st c="8849">developer
    journey.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8867">Let’s have a detailed look at how we can</st> <st c="8908">use
    Azure Pipelines to automate some of the most</st> <st c="8958">common steps:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="8971">Create a developer branch</st>**<st c="8997">: We can use the
    following Bash script to create</st> <st c="9047">a branch:</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**<st c="9350">Provision a Power Platform developer environment</st>**<st c="9399">:
    First, we need to sign in to the Power Platform environment by using a service
    principal on a Microsoft-hosted Windows machine, as the Pac CLI stores authentication
    credentials as plain text on</st> <st c="9596">Linux machines:</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="9761">We also need to sign</st> <st c="9782">in to our Azure tenant,
    using the same service principal, to figure out who has triggered this</st> <st
    c="9878">Azure Pipeline:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="10491">pac admin create --name "dev-US_XXX_Y" \</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="10532">--type Developer \</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="10551">--user $AADObjectID</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="10716"># Get the environment Id (the row before the last row contains
    the information)</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="10796">rawOutput=$(pac admin list --name dev-us_XXX_Y | tail -n 2)</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="10856">environmentId=$(echo $rawOutput | cut -d ' ' -f 2)</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="10907">#adding system administrator role to the user who has created
    the developer environment</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="10995">pac admin assign-user --environment $environmentId --user $AADObjectID
    --role "System Administrator"</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="11096">Developer environments</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11119">Every user in Power Platform can create up to three developer
    environments</st> <st c="11195">for free.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="11615">export solution</st>`<st c="11630">,</st> `<st c="11632">import
    solution</st>`<st c="11647">,</st> `<st c="11649">copy environment</st>`<st c="11665">,
    and</st> `<st c="11671">backup</st>`<st c="11677">, against the environment.</st>
    <st c="11704">If we want to automate the service connection creation process,
    it is also possible.</st> <st c="11789">We need to create a JSON file that we
    will post as a payload to the</st> `<st c="11857">REST</st>` <st c="11861">endpoint
    of Azure DevOps Services (see</st> `<st c="11901">AzDO/.pipelines/config-tokenizer.yml</st>`
    <st c="11937">in the</st> `<st c="11945">Chapter06</st>` <st c="11954">folder
    of the</st> <st c="11969">GitHub repo):</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="12550">We can use the following Bash</st> <st c="12580">script to tokenize
    this JSON file (see</st> `<st c="12620">AzDO/.pipelines/create-service-connection.yml</st>`
    <st c="12665">in the</st> `<st c="12673">Chapter06</st>` <st c="12682">folder
    of the</st> <st c="12697">GitHub repo):</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="13813">If we want to execute</st> <st c="13835">this script locally,
    then we can use</st> `<st c="14589">az devops</st>` <st c="14598">CLI commands
    to automatically create our</st> <st c="14640">service connection:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'steps:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- checkout: git://PowerPlatform/Copilot@${{parameters.sourceBranch}}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'displayName: ''Checkout Source Branch'''
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'persistCredentials: true'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- task: PowerPlatformToolInstaller@2'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'inputs:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'DefaultVersion: true'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- task: PowerPlatformPackSolution@2'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'inputs:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'SolutionSourceFolder: ''$(System.DefaultWorkingDirectory)/src/$(solutionName)'''
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'SolutionOutputFile: ''$(Build.ArtifactStagingDirectory)/Solution/$(solutionName).zip'''
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'SolutionType: ''Unmanaged'''
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- task: PublishBuildArtifacts@1'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'inputs:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'PathtoPublish: ''$(Build.ArtifactStagingDirectory)/Solution'''
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'ArtifactName: ''Solution'''
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'publishLocation: ''Container'''
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- task: PowerPlatformImportSolution@2'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'inputs:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'authenticationType: ''PowerPlatformSPN'''
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'PowerPlatformSPN: ${{parameters.serviceconnection}}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'SolutionInputFile: ''$(Build.ArtifactStagingDirectory)/Solution/$(solutionName).zip'''
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'AsyncOperation: true'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'MaxAsyncWaitTime: ''60'''
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '- task: PowerPlatformPublishCustomizations@2'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'inputs:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'authenticationType: ''PowerPlatformSPN'''
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'PowerPlatformSPN: ${{parameters.serviceconnection}}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="16663">trigger:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="16672">-  dev/*</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="16680">After going through these automation steps, we finally have a
    developer branch on which we can start our work.</st> <st c="16792">It is recommended
    to assign one or more work items to this branch by using the available tools in
    Azure DevOps; otherwise, PRs submitted later will be automatically rejected (if
    recommended branch policies</st> <st c="16998">are configured).</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17014">The following figure shows us how to assign the</st> <st c="17062">branch
    to an</st> **<st c="17076">Issue</st>** <st c="17081">work item:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Linking a branch to a work item](img/B22208_06_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="17272">Figure 6.4 – Linking a branch to a work item</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17316">Making changes in the Power Platform environment</st> <st c="17365">should
    be reflected on the dev branch to track changes in the version control system.</st>
    <st c="17452">To achieve this, we need to create another pipeline (</st>`<st c="17505">Export-to-Git</st>`<st
    c="17519">) that exports our managed and unmanaged solutions, unpacks them, and
    commits changes to our dev branch.</st> <st c="17625">We saw some of these building
    blocks in</st> [*<st c="17665">Chapter 5</st>*](B22208_05.xhtml#_idTextAnchor089)<st
    c="17674">. In addition to that pipeline, we need to add a step to export the
    solution as unmanaged and to unpack the solution with type</st> `<st c="17801">Both</st>`<st
    c="17805">. To commit changes back to a branch, we can use the following Git commands,
    executed as Bash script after our</st> `<st c="17916">PowerPlatformExportSolution@2</st>`
    <st c="17945">and</st> `<st c="17950">PowerPlatformUnpackSolution@2</st>` <st
    c="17979">build tasks in</st> <st c="17995">the pipeline:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: <st c="19227">With the help of this pipeline, our developers can constantly
    commit their changes back to their own</st> <st c="19329">dedicated dev branches
    throughout feature development.</st> <st c="19384">We set the version number of
    the solution intentionally to</st> `<st c="19443">0.0.0.0</st>` <st c="19450">to
    avoid conflicting merges, as well as to manage version numbers with Azure pipelines.</st>
    <st c="19539">When developers are ready, they can submit a PR back to the</st>
    <st c="19599">parent branch.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19613">Let’s discuss some additional DevOps design principles and recommendations</st>
    <st c="19688">in conjunction with our</st> <st c="19713">DevOps process:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="19783">PowerPlatformPackSolution@2</st>` <st c="19810">build task anytime
    to pack our solution from source control.</st> <st c="19872">It is a compression
    step—actually it zips our folder, so it doesn’t require a long compilation time.</st>
    <st c="19973">Of course, if we have</st> <st c="19994">code components to be built,
    such as</st> **<st c="20032">PowerApps Component Framework</st>** <st c="20061">(</st>**<st
    c="20063">PCF</st>**<st c="20066">) controls or Dataverse plugins, or if we target
    multiple environments with the same manifest (solution), then it is worth creating
    dedicated pipelines</st> <st c="20219">for CI.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="20361">Export-to-Git</st>` <st c="20374">pipeline, we can submit a
    PR to merge back our changes to test and later to production branches.</st> <st
    c="20472">We can introduce CD pipelines that are executed upon completion of the
    PR on the target branch with a simple</st> <st c="20581">branch trigger:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**<st c="21239">Version numbers of solutions – when do we need to set them?</st>**
    <st c="21299">As discussed earlier, with the rise of DevOps, we want to maintain
    only one version, the latest of our applications in production.</st> <st c="21431">We
    use versioning and version numbers to be able to track changes back to the</st>
    <st c="21509">source code:</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="22099">This means that during the build/deployment, the version</st>
    <st c="22156">is calculated on the fly, using the build name of the Azure pipeline.</st>
    <st c="22227">This provides a one-to-one relationship between the solution version
    and the pipeline that generated</st> <st c="22328">that version.</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<st c="22505">Export-to-Git</st>` <st c="22518">pipeline, we can introduce
    a parameter that expects the name of the branch in which the parent branch’s current
    version should be deployed.</st> <st c="22659">If we don’t want to override our
    work in such a way, we can use Git commands such as</st> `<st c="22744">git rebase</st>`
    <st c="22754">to restore our developer branch to the latest version of the parent
    branch.</st> <st c="22831">After this, we need to import the solution using the
    other pipeline into our</st> <st c="22908">developer environments.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="22931">Overall, we can manage our development work with the following</st>
    <st c="22995">four pipelines:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Pipelines to manage a solution](img/B22208_06_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="23412">Figure 6.5 – Pipelines to manage a solution</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23455">We can create GitHub workflows in the same way.</st> <st c="23504">Those
    Bash and PowerShell scripts can be easily moved to GitHub workflows, and the same
    branch and repository structure with assigned Power Platform environments can
    be built upon, like in Azure</st> <st c="23699">DevOps Services.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23715">The Power Platform catalog</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="23742">In addition to this kind</st> <st c="23767">of CI/CD delivery
    to Power Platform environments, Power Platform provides a new concept for managing
    our reusable packages.</st> <st c="23892">The</st> **<st c="23896">Power Platform
    catalog</st>** <st c="23918">is a package manager that contains solution templates,
    PCF components, end-to-end solutions, and other assets for reuse purposes.</st>
    <st c="24049">It is based on the same concept that we use in pro-dev scenarios
    when we publish our packages in different package management repositories, such
    as NuGet, npm, Maven, and Pip.</st> <st c="24225">The catalog in Power Platform
    is a feature that allows developers and makers to easily discover and use Power
    Platform templates and code components within their organization.</st> <st c="24401">It
    provides a private, central location for finding and installing the latest and
    most reliable versions of components, offering templates that deliver immediate
    value.</st> <st c="24570">For administrators and line of business approvers, the
    catalog serves as a single source of truth to store and maintain Power Platform
    artifacts, allowing them to curate and control the content to accelerate value
    for makers and developers.</st> <st c="24811">It also enables approval workflows
    for the use of sanctioned components and templates in sensitive regulatory and
    statutory scenarios, providing management capabilities with settings</st> <st
    c="24994">and metadata.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25007">To bring the catalog into one dedicated environment (it is recommended
    to provide a separate environment, such as</st> `<st c="25122">Catalog</st>`<st
    c="25129">), we need to install</st> <st c="25151">it as Dynamics 365 application
    from</st> <st c="25188">AppSource:</st> [<st c="25199">https://appsource.microsoft.com/product/dynamics-365/powerappssvc.catalogmanager-preview?flightCodes=dde212e5c66047c59bf2b346c419cef6</st>](https://appsource.microsoft.com/product/dynamics-365/powerappssvc.catalogmanager-preview?flightCodes=dde212e5c66047c59bf2b346c419cef6)<st
    c="25332">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25333">After installing this D365 application, we can submit and deploy
    the following assets</st> <st c="25420">to it:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="25426">Dataverse solutions</st>** <st c="25446">(managed or unmanaged)
    or</st> **<st c="25473">package deployer packages</st>** <st c="25498">(enterprise
    templates can</st> <st c="25524">also be published to</st> <st c="25546">the catalog)</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="25558">Templates</st>** <st c="25568">for a Power App or a Power</st>
    <st c="25596">Automate flow</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="25609">Power Platform code-first components</st>** <st c="25646">such
    as custom connectors</st> <st c="25672">or</st> **<st c="25676">Power Apps component
    framework</st>** <st c="25706">(</st>**<st c="25708">PCF</st>**<st c="25711">)
    controls</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="25722">The Power Platform catalog</st> <st c="25749">brings additional
    security roles to manage the life cycle</st> <st c="25807">of catalog items –</st>
    **<st c="25827">Catalog Submitter</st>** <st c="25844">to submit items to the
    catalog,</st> **<st c="25877">Catalog Read-Only Member</st>** <st c="25901">to
    discover and install</st> <st c="25925">items from the catalog,</st> **<st c="25950">Catalog
    Approver</st>** <st c="25966">to approve submissions</st> <st c="25989">to the</st>
    <st c="25996">catalog, and</st> **<st c="26010">Catalog Administrator</st>** <st
    c="26031">to administer the catalog.</st> <st c="26059">We get this enterprise-grade
    security from catalogs</st> <st c="26111">as well.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26119">Our Azure pipelines and GitHub workflows can target not just environments
    but also catalogs.</st> <st c="26213">The Pac CLI provides the appropriate commands
    to submit our solutions, custom connectors, and PCF components to the catalog.</st>
    <st c="26338">The following script creates a submission on our</st> `<st c="26387">mpa_ITBase_managed</st>`
    <st c="26405">solution (we used it in</st> [*<st c="26430">Chapter 4</st>*](B22208_04.xhtml#_idTextAnchor074)
    <st c="26439">for managed pipelines) from the enterprise templates and submits
    a new</st> <st c="26511">catalog item:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: <st c="26983">These scripts can run on behalf of service</st> <st c="27026">principals
    as well.</st> <st c="27047">By default, submissions need to be approved by catalog
    administrators, but we can change the configuration so that certain publishers,
    such as service principals running in Azure Pipelines or GitHub workflows, get</st>
    <st c="27261">automatic approval.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27280">The following figure shows the</st> `<st c="27410">mpa_ITBase_managed</st>`
    <st c="27428">solution:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Power Platform Catalog Manager](img/B22208_06_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="27540">Figure 6.6 – Power Platform Catalog Manager</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27583">Power Platform catalogs</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27607">Power Platform catalogs</st> <st c="27631">will be part of</st>
    **<st c="27648">managed environments</st>** <st c="27668">after they become</st>
    <st c="27687">generally</st> <st c="27696">available.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27707">Let’s now move on to the pipeline templates and reusable workflows
    that provide reusability of our Azure pipelines and GitHub workflows on a</st>
    <st c="27849">large scale.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27861">Azure pipeline templates and reusable GitHub workflows</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="27916">Looking back at our Azure pipelines</st> <st c="27952">in the
    previous section, we can say that it is a pretty good starting point to have everything
    automated.</st> <st c="28059">However, if we need to support hundreds or even
    thousands of applications, then this approach of keeping three to four pipelines
    in every single repository, in which those solutions are maintained, will become
    more complex.</st> <st c="28283">The more and more applications we develop, the
    more and more different versions of these Azure pipelines will exist in parallel.</st>
    <st c="28412">It would be great to have a centralized repository containing the
    business logic of these pipelines and the solutions only customizing some parameters
    before calling them.</st> <st c="28584">This is the idea behind Azure pipeline
    templates and reusable</st> <st c="28646">GitHub workflows.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="28663">Azure pipeline templates</st>** <st c="28688">make it possible
    to create reusable business logic that we can use throughout our YAML pipeline
    instances.</st> <st c="28796">These templates can be also used to control what
    is allowed in a pipeline by defining policies that the “caller” should follow.</st>
    <st c="28924">For example, we can enforce task execution constraints by leveraging
    a template that acts as a safeguard, ensuring that any task performed follows
    our organization’s</st> <st c="29090">security guidelines.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29110">For instance, the following</st> `<st c="29199">AzDO/.pipelines/template/include-paccli-steps.yml</st>`
    <st c="29248">in the</st> `<st c="29256">Chapter06</st>` <st c="29265">folder
    of the</st> <st c="29280">GitHub repo):</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: <st c="29471">The pipeline file that consumes this template executes it on Linux
    and then on the Windows agent (</st><st c="29570">see</st> `<st c="29575">AzDO/.pipelines/azure-pipeline-template.yml</st>`<st
    c="29618">):</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: <st c="29854">We can also parameterize our Azure pipeline template</st> <st
    c="29907">files, and the caller pipelines can set those parameters according to
    their</st> <st c="29984">customization needs.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30004">The same</st> <st c="30013">concept, called</st> `<st c="30161">workflow_call</st>`<st
    c="30174">. The following reusable workflow installs the Pac CLI on the target
    platform.</st> <st c="30253">The version number of the tool and the target platform
    are parameters of this flow (</st><st c="30337">see</st> `<st c="30342">GitHub/.github/workflows/install-paccli.yml</st>`<st
    c="30385">):</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: <st c="30713">To call our workflow</st> <st c="30734">from other workflows,
    we need to create a dedicated job in our</st> *<st c="30798">caller</st>* <st
    c="30804">GitHub workflows (</st><st c="30823">see</st> `<st c="30828">GitHub/.github/workflows/Deploy.yml</st>`<st
    c="30863">):</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: <st c="31188">The real power of this concept in Azure DevOps and GitHub is that
    we can place our templates</st> <st c="31281">and reusable workflows in different
    locations in the same repository, or even in different Git repositories.</st>
    <st c="31391">If we look at the pipelines that we created to spin up developer
    environments, create service connections, and export/import our solutions from/to
    environments, respectively, we can now place these templates or reusable workflows
    in a dedicated Git repository.</st> <st c="31652">The different projects and solutions
    can call our templates by using this reusable concept.</st> <st c="31744">Conversely,
    we can improve and maintain these workflows centrally by reducing the overall
    effort to manage large numbers</st> <st c="31865">of projects.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31877">Besides the reusable</st> <st c="31898">workflows, GitHub offers
    so-called</st> **<st c="31934">GitHub starter workflows</st>**<st c="31958">.
    GitHub starter workflows are also templates</st> <st c="32003">that are stored
    in an organization’s</st> *<st c="32041">GitHub repository</st>*<st c="32058">.
    These templates are displayed when we create a new workflow in the GitHub UI.</st>
    <st c="32138">Upon creating the workflow, the template will be copied to our repository,
    and with that, we decouple the instance from the template.</st> <st c="32272">We
    can use GitHub starter workflows to help projects set up their workflows, based
    on our</st> <st c="32362">reusable workflows.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32381">Now that we understand pipeline templates and reusable workflows,
    let’s learn about the ALM Accelerator for Power Platform, which heavily uses this
    concept under</st> <st c="32544">the hood.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32553">The ALM Accelerator for Power Platform</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="32592">The ALM Accelerator for Power Platform</st> <st c="32631">is a
    tool that helps developers automate their software development workflows for Power
    Platform.</st> <st c="32730">Although</st> <st c="32738">it is part of the</st>
    **<st c="32757">Center of Excellence</st>** <st c="32777">(</st>**<st c="32779">CoE</st>**<st
    c="32782">)</st> **<st c="32785">Starter Kit</st>**<st c="32796">, which is a
    collection of components and tools that help organizations get started with Power
    Platform adoption, it can be installed as a standalone solution in one of our</st>
    <st c="32969">Dataverse environments.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32992">The ALM Accelerator includes Azure pipeline templates, Azure pipelines,
    and Power Platform applications to help professional developers realize DevOps
    and ALM in their projects.</st> <st c="33171">This accelerator package is called
    the</st> **<st c="33210">ALM Accelerator for Advanced Makers</st>** <st c="33245">(</st>**<st
    c="33247">AA4AM</st>**<st c="33252">) solution, and it consists of reference</st>
    <st c="33293">implementations originally developed by the CoE Starter Kit engineering
    team at Microsoft.</st> <st c="33385">After its successful implementation, the
    team decided to make it open source and available for every organization, proving
    how healthy application life cycle management can be realized in Power Platform.</st>
    <st c="33589">We can use these pipelines and applications as they are, or we can
    customize them based on our organizational requirements, and of course, we can
    learn a lot from the underlying concepts that this team devised a few</st> <st
    c="33805">years ago.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33815">We can find comprehensive documentation about the accelerator,
    how we can install it, how we can create our pipelines based on the available
    pipeline templates, and how we can manage our Power Platform solutions in Azure</st>
    <st c="34037">DevOps repositories.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="34057">Branches, environments, and pipeline</st> <st c="34094">templates,
    as previously discussed in this chapter, are essential to understand how ALM Accelerator
    works under the hood.</st> <st c="34217">The main features</st> <st c="34234">of
    the accelerator are</st> <st c="34258">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="34272">There is a model-driven app,</st> **<st c="34302">ALM Accelerator
    for Power Platform Administration</st>**<st c="34351">, to create and manage</st>
    <st c="34373">deployment profiles.</st> **<st c="34395">Deployment profiles</st>**
    <st c="34414">describe the CD process</st> <st c="34438">of the solution throughout
    our environments.</st> <st c="34484">It is conceptionally the same as how we define
    Power Platform managed pipelines.</st> <st c="34565">It is recommended to create
    a deployment profile per Power Platform solution, as the profile also contains
    information about the Azure DevOps project, Git repository and target branches,
    and the corresponding Power</st> <st c="34780">Platform environments.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="34802">There is another canvas app, ALM Accelerator for Power Platform,
    that provides a UI for developers and visualizes the solutions and assigned deployment
    profiles in the given Power</st> <st c="34983">Platform environment.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="35004">Through the ALM Accelerator for Power Platform canvas app, we
    can easily create a branch and commit our solution versions (changes) multiple
    times to</st> <st c="35155">this branch.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="35167">The canvas app provides a way to move our changes through the
    defined environments.</st> <st c="35252">Every deployment (release) is a PR to
    the parent branch.</st> <st c="35309">After completing the PR in Azure DevOps,
    a pipeline imports the solution to the assigned environment defined in the</st>
    <st c="35425">deployment profile.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="35444">It is recommended to create one repository per solution.</st>
    <st c="35502">This repository contains our pipelines, utilizing the pipeline templates
    provided by</st> <st c="35587">the accelerator.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="35603">We can add more environments, and we can create the same branch
    structure that we discussed at the beginning of</st> <st c="35716">this chapter.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="35729">The canvas app uses custom connectors and calls the REST API endpoints
    of Azure DevOps Services to interact with the</st> <st c="35847">defined pipelines.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="35865">The</st> `<st c="35870">coe-alm-accelerator-templates</st>` <st
    c="35899">GitHub repository contains the pipeline templates that the ALM accelerator
    also utilizes.</st> <st c="35990">We need to fork this repo to our Azure DevOps
    project as an additional</st> <st c="36061">Git repository.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="36076">We can customize the pipeline templates for our</st> <st c="36125">organization’s
    needs.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="36146">The ALM Accelerator for Power Platform</st> <st c="36185">is only
    available for Azure</st> <st c="36214">DevOps Services.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="36230">The following figure shows the ALM Accelerator for Power Platform</st>
    <st c="36297">at work:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – The ALM Accelerator for Power Platform](img/B22208_06_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="37172">Figure 6.7 – The ALM Accelerator for Power Platform</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="37223">We can see the unmanaged solutions available in the selected environment
    (developer environments).</st> <st c="37323">We can use the</st> **<st c="37338">Commit
    Solution</st>**<st c="37353">,</st> **<st c="37355">Deploy Solution</st>**<st
    c="37370">, and</st> **<st c="37376">Delete Solution</st>** <st c="37391">buttons
    to trigger our pipelines, commit our changes, or</st> <st c="37449">initiate PRs.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="37462">The ALM Accelerator for Power Platform</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="37501">Having observed the extensive flexibility</st> <st c="37543">of
    the techniques presented earlier in this chapter, as well as the effectiveness
    of pipelines in managed environments, we should consider the ALM Accelerator for
    Power Platform as a tool for acquainting ourselves with various design patterns
    and concepts.</st> <st c="37801">These can then be incorporated into our custom
    Azure DevOps pipelines and, subsequently, our</st> <st c="37894">GitHub workflows.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="37911">Now, we have everything in place to operate and manage a high
    number of projects and solutions in our organization.</st> <st c="38028">One last
    thing we need to provide to ensure the quality of our applications is</st> **<st
    c="38107">automated testing</st>**<st c="38124">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38125">Automated testing in DevOps and Power Platform pipelines</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="38182">Test automation and automated tests</st> <st c="38218">are essential
    parts of ALM and DevOps</st> <st c="38257">processes.</st> <st c="38268">Without
    automated</st> <st c="38285">tests, we are not able</st> <st c="38308">to share
    the solutions with other developers, we are not able to work together on solutions
    as autonomous SCRUM teams, and it is always a great challenge to modify solutions
    because we cannot know how far our applications can fall into regression.</st>
    <st c="38557">To avoid regression and achieve high test coverage, we need to establish
    the same quality-assurance processes as in custom development projects.</st> <st
    c="38702">Power Platform provides multiple tools and frameworks to create functional
    tests for</st> <st c="38787">our solutions.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="39841">Select</st>`<st c="39847">,</st> `<st c="39849">SetProperty</st>`<st
    c="39860">,</st> `<st c="39862">Assert</st>`<st c="39868">, and</st> `<st c="39874">Trace</st>`<st
    c="39879">. Test expressions build up test cases.</st> `<st c="40156">true</st>`
    <st c="40160">or</st> `<st c="40164">false</st>` <st c="40169">in the test.</st>
    <st c="40183">If the assertion returns</st> `<st c="40208">false</st>`<st c="40213">,
    the test</st> <st c="40224">case fails.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="40235">Tests created with Power Apps Test Studio can be executed by Azure
    pipelines.</st> <st c="40314">The step-by-step guide available in the</st> *<st
    c="40354">Further reading</st>* <st c="40369">section (</st>*<st c="40379">Automate
    tests with Azure DevOps Pipelines</st>*<st c="40422">) uses the test’s playback
    URL as input for the automated test execution.</st> <st c="40497">The repository
    available under</st> [<st c="40528">https://github.com/microsoft/PowerAppsTestAutomation</st>](https://github.com/microsoft/PowerAppsTestAutomation)
    <st c="40580">provides an</st> `<st c="40675">MSTest</st>` <st c="40681">test
    method that uses</st> `<st c="40958">AppMagic.TestStudio.GetTestExecutionInfo()</st>`
    `<st c="41121">MSTest</st>` <st c="41127">test method then succeeds or fails,
    based on these results.</st> <st c="41188">The result of the test method is also
    written back to our Azure pipeline, and we can see the test result directly in
    Azure DevOps Services</st> <st c="41327">build results.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="41341">Power Apps Test Engine</st>** <st c="41364">is the newest approach
    to test PowerApps</st> <st c="41405">canvas apps, using a Playwright-based engine.</st>
    **<st c="41452">Playwright</st>** <st c="41462">won popularity with its stability</st>
    <st c="41496">and performance, easy setup, unified API for Chromium, Firefox,
    and WebKit, and official bindings for JavaScript, Python, and C#.</st> <st c="41627">Playwright
    was originally developed by Microsoft, and it has been open sourced and released
    for</st> <st c="41723">community contributions.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41747">PowerApps Test Engine allows us to write tests in the YAML format
    using the intuitive Power Fx language, with a</st> **<st c="41860">Document Object
    Model</st>** <st c="41881">(</st>**<st c="41883">DOM</st>**<st c="41886">) abstraction
    that permits the crafting of tests</st> <st c="41935">using references to control
    names established during the design phase.</st> <st c="42007">This approach means
    that test authors are not required to possess</st> <st c="42072">JS knowledge</st>
    <st c="42085">or familiarity with the browser DOM related</st> <st c="42129">to
    the app’s visual output.</st> <st c="42158">The following YAML file</st> <st c="42181">shows
    such</st> <st c="42193">an example:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: <st c="43158">We can download this YAML file</st> <st c="43189">from Power Apps
    Test Studio</st> <st c="43217">and import</st> <st c="43228">it into our</st>
    <st c="43240">PowerApps</st> <st c="43251">Test Engine.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43263">Test Engine also supports</st> **<st c="43290">connector mocking</st>**<st
    c="43307">, allowing us to create mocks</st> <st c="43336">around the surrounding
    connectors and connections used in our application.</st> <st c="43412">As such,
    we can test our applications isolated from third-party production services.</st>
    <st c="43497">Furthermore, Test Engine supports screenshots and video recording,
    enabling us to take screenshots at any time of the test execution and document
    the test sequence through video recordings, which can be instrumental in troubleshooting
    unsuccessful tests and analyzing the actual user experience of the test scenario
    that did</st> <st c="43822">not pass.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43831">Other well-known tools that we can call during the pipeline executions,
    with the help of the Pac CLI</st> <st c="43932">and PowerShell modules, are the</st>
    `<st c="44003">AppChecker</st>` <st c="44013">(</st>`<st c="44015">pac solution
    check</st>`<st c="44033">) for</st> <st c="44040">canvas apps.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44052">When testing</st> **<st c="44066">Microsoft Copilot Studio</st>**<st
    c="44090">, we can use the</st> **<st c="44107">PVA Test Framework</st>**<st c="44125">,
    a sample solution that</st> <st c="44149">can be found</st> <st c="44163">on GitHub.</st>
    <st c="44174">It demonstrates how to run tests on a Microsoft Copilot Studio chatbot
    using APIs and the Direct Line channel.</st> <st c="44285">The framework confirms
    that the bot functions</st> <st c="44330">as intended in a variety of situations,
    including</st> <st c="44380">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44395">Testing the natural language understanding model to trigger the</st>
    <st c="44460">right topics.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="44473">Validating the options for multiple matched topics (“</st>*<st
    c="44527">did you mean…</st>*<st c="44541">” question is raised by the copilot
    if the user intent</st> <st c="44597">is ambiguous)</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="44610">Conducting load testing</st> <st c="44635">at scale</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="44643">Testing complete</st> <st c="44661">end-to-end conversations</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="44685">Testing the functionality of</st> <st c="44715">adaptive cards</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="44729">Including a test step in the CI/CD deployment pipeline to prevent
    deployment if</st> <st c="44810">tests fail</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="44820">We can create</st> **<st c="44835">conversational scripts</st>**
    <st c="44857">manually, or we can use</st> <st c="44881">the PVA Test Framework</st>
    <st c="44904">to export existing conversations from Dataverse</st> <st c="44952">in
    the</st> *<st c="44960">CHAT format</st>*<st c="44971">. We can then convert these
    CHAT files to JSON with the help of the PVA Test Framework and let them execute
    against the Direct Line REST API endpoints.</st> <st c="45123">The framework can
    be easily integrated into our Azure pipelines and GitHub workflows, since it is
    a .NET 6 console app that can run on Windows-based</st> <st c="45272">hosted agents.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45286">To test</st> **<st c="45295">model-driven Power Apps</st>** <st
    c="45318">and</st> **<st c="45323">Power Pages websites</st>**<st c="45343">,
    we can use other</st> <st c="45361">web test</st> <st c="45370">frameworks, such
    as</st> <st c="45391">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45405">The</st> **<st c="45410">Selenium Test Framework</st>** <st c="45433">is
    a suite of automation</st> <st c="45458">testing tools that allows developers
    to create robust, browser-based regression automation suites and tests.</st> <st
    c="45568">It can scale and distribute scripts across many environments and supports
    a wide range of</st> <st c="45658">programming languages.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="45680">Playwright is a cross-browser, cross-platform, and cross-language</st>
    <st c="45747">tool for reliable end-to-end testing of web apps.</st> <st c="45797">It
    supports all modern rendering engines, native mobile emulation, auto-wait, web-first
    assertions, tracing, and full isolation.</st> <st c="45926">Playwright interacts
    with browsers using its</st> <st c="45971">own API.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="45979">Appium.io for mobile application testing</st>**<st c="46020">:
    Appium is a freely available, open source</st> <st c="46064">software suite and
    ecosystem, engineered to facilitate user interface automation across a wide array
    of application platforms.</st> <st c="46192">This includes mobile OSes (iOS, Android,
    and Tizen), web browsers (Chrome, Firefox, and Safari), desktop environments (macOS
    and Windows), and television OSes (Roku, tvOS, Android TV, and Samsung).</st>
    <st c="46390">Its goal is to enable the automation of any mobile application,
    irrespective of the programming language or testing</st> <st c="46505">framework
    used, granting</st> <st c="46530">complete access to backend</st> **<st c="46558">application
    programming interfaces</st>** <st c="46592">(</st>**<st c="46594">APIs</st>**<st
    c="46598">) and</st> **<st c="46605">databases</st>** <st c="46614">(</st>**<st
    c="46616">DBs</st>**<st c="46619">) within the</st> <st c="46633">test scripts.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="46646">Cypress is a JavaScript-based, end-to-end testing</st> <st c="46696">framework
    built on Mocha.</st> <st c="46723">It is designed to simplify the process of setting
    up, writing, running, and debugging tests for web applications.</st> <st c="46837">Cypress
    tests anything that runs in a web browser and is built to handle modern JavaScript
    frameworks especially well.</st> <st c="46956">Some of the key advantages of Cypress
    include faster and more reliable tests, reduced flakiness, dashboard support for
    detailed reporting, parallel</st> <st c="47103">test</st> <st c="47109">execution,
    and support for</st> **<st c="47136">behavior-driven development</st>** <st c="47163">(</st>**<st
    c="47165">BDD</st>**<st c="47168">) and</st> **<st c="47175">test-driven development</st>**
    <st c="47198">(</st>**<st c="47200">TDD</st>**<st c="47203">) testing.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="47214">JMeter is an open source tool developed</st> <st c="47254">by
    the Apache Software Foundation for load-testing and analyzing the performance
    of a variety of services.</st> <st c="47362">JMeter is written in Java and can
    be used to test the performance and functional behavior of various applications
    and protocols, such</st> <st c="47496">as</st> **<st c="47499">HTTP</st>** <st
    c="47503">(</st>**<st c="47505">Hypertext Transfer Protocol</st>**<st c="47532">),</st>
    **<st c="47536">SOAP</st>** <st c="47540">(</st>**<st c="47542">Simple Object
    Access Protocol</st>**<st c="47571">),</st> **<st c="47575">FTP</st>** <st c="47578">(</st>**<st
    c="47580">File Transfer Protocol</st>**<st c="47602">), and</st> **<st c="47610">LDAP</st>**
    <st c="47614">(</st>**<st c="47616">Lightweight Directory Access Protocol</st>**<st
    c="47653">).</st> <st c="47657">It</st> <st c="47659">offers</st> <st c="47666">a</st>
    <st c="47669">full-featured IDE, a dynamic HTML report, a multithreaded framework,
    and a highly extensible core with pluggable samplers</st> <st c="47791">and plugins.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="47803">Testing Power Automate cloud flows and desktop flows is a more
    complex engineering challenge than executing UI-automated tests in browsers or
    on mobile devices.</st> <st c="47965">At the time of writing, there is no recommended
    framework to realize integration and system tests against our cloud and desktop
    flows.</st> <st c="48100">Since these components are considered as part of the
    business logic layer, we can test them through the UI components in front of them,
    as</st> <st c="48239">end-to-end tests.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48256">Conversely, we can provide partial solutions to test HTTP-triggered
    and Webhook-triggered cloud flows, by calling their corresponding REST API endpoints
    and comparing their results with what</st> <st c="48448">we expect.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48458">As we learned in</st> [*<st c="48476">Chapter 5</st>*](B22208_05.xhtml#_idTextAnchor089)<st
    c="48485">,</st> `<st c="48615">OnDeploymentCompleted</st>` <st c="48636">event
    can be used to test our solution after it is deployed</st> <st c="48696">to the
    target environment, represented as a deployment</st> <st c="48751">stage.</st>
    <st c="48759">Our Power Automate</st> <st c="48777">cloud flows, as the event
    handlers</st> <st c="48812">of this event, can call Azure pipelines or GitHub
    workflows to execute code-first, pro-development test automation scripts (similar
    to how we called GitHub workflows in</st> [*<st c="48982">Chapter 5</st>*](B22208_05.xhtml#_idTextAnchor089)<st
    c="48991">) to commit our solution to a Git repository.</st> <st c="49038">The
    next deployment stage’s pre-approval gate (</st>`<st c="49085">OnApprovalStarted</st>`
    <st c="49103">or</st> `<st c="49107">OnPredeploymentStarted</st>`<st c="49129">)
    can then check the results of the test execution in the previous environment.</st>
    <st c="49210">If the tests pass, deployment to the next environment</st> <st c="49264">can
    continue.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="49277">Finally, we can use other</st> <st c="49303">Microsoft Azure services,
    such as the</st> **<st c="49342">Azure Load Testing</st>** <st c="49361">service,
    to execute a</st> **<st c="49383">JMeter</st>** <st c="49389">test against our</st>
    <st c="49406">Power Platform solutions.</st> <st c="49433">JMeter also provides
    recording capabilities, and the Azure Load Testing service can be used to mimic
    hundreds of parallel users simultaneously interacting with</st> <st c="49593">our
    applications.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="49610">Based on the kind of solution, we need to choose a testing tool
    with the right depth and breadth.</st> <st c="49709">The more business- or mission-critical
    applications we need to design and deliver, the more time we should invest and
    spend on this</st> <st c="49841">DevOps discipline.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="49859">Summary</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="49867">In this chapter, we explored the advanced patterns of DevOps CI/CD
    processes and learned how to establish a robust branching strategy that reflects
    the development, testing, and production environments of our solutions.</st> <st
    c="50088">We examined numerous examples of automating branch creation, spinning
    up Power Platform environments with service connections, and importing and exporting
    solutions using various Pac</st> <st c="50271">CLI-based scripts.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="50289">We also delved into the Power Platform catalog as the package
    management solution for Power Platform.</st> <st c="50392">Additionally, we learned
    about the ALM Accelerator for Power Platform and how this solution uses pipeline
    templates, a branching strategy, and environment management.</st> <st c="50559">Finally,
    we became familiar with the test automation frameworks that can be used with Power</st>
    <st c="50651">Platform solutions.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="50670">In the next chapter, we will take another step forward and learn
    about the implementation of DevSecOps processes on</st> <st c="50787">Power Platform.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="50802">Further reading</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="50818">The</st> `<st c="50823">az devops</st>` <st c="50832">CLI:</st>
    [<st c="50838">https://learn.microsoft.com/en-us/cli/azure/devops?view=azure-cli-latest</st>](https://learn.microsoft.com/en-us/cli/azure/devops?view=azure-cli-latest)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="50910">Windows Subsystem for</st> <st c="50933">Linux:</st> [<st c="50940">https://learn.microsoft.com/en-us/training/modules/wsl-introduction/</st>](https://learn.microsoft.com/en-us/training/modules/wsl-introduction/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="51008">Azure DevOps approval</st> <st c="51031">flow:</st> [<st c="51037">https://learn.microsoft.com/en-us/azure/devops/pipelines/process/approvals?view=azure-devops&tabs=check-pass</st>](https://learn.microsoft.com/en-us/azure/devops/pipelines/process/approvals?view=azure-devops&tabs=check-pass)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="51145">The Power Platform</st> <st c="51165">catalog:</st> [<st c="51174">https://learn.microsoft.com/en-us/power-platform/developer/catalog</st>](https://learn.microsoft.com/en-us/power-platform/developer/catalog)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="51240">Azure DevOps pipeline</st> <st c="51263">templates:</st> [<st
    c="51274">https://learn.microsoft.com/en-us/azure/devops/pipelines/process/templates?view=azure-devops&pivots=templates-includes</st>](https://learn.microsoft.com/en-us/azure/devops/pipelines/process/templates?view=azure-devops&pivots=templates-includes)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="51392">GitHub starter</st> <st c="51408">flows:</st> [<st c="51415">https://docs.github.com/en/actions/using-workflows/creating-starter-workflows-for-your-organization</st>](https://docs.github.com/en/actions/using-workflows/creating-starter-workflows-for-your-organization)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="51514">GitHub reusable</st> <st c="51531">workflows:</st> [<st c="51542">https://docs.github.com/en/actions/using-workflows/reusing-workflows</st>](https://docs.github.com/en/actions/using-workflows/reusing-workflows)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="51610">The ALM Accelerator for Power</st> <st c="51641">Platform:</st>
    [<st c="51651">https://learn.microsoft.com/en-us/power-platform/guidance/alm-accelerator/overview</st>](https://learn.microsoft.com/en-us/power-platform/guidance/alm-accelerator/overview)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="51733">The source code of ALM</st> <st c="51757">Accelerator:</st> [<st
    c="51770">https://github.com/microsoft/coe-starter-kit/tree/main/CenterofExcellenceALMAccelerator</st>](https://github.com/microsoft/coe-starter-kit/tree/main/CenterofExcellenceALMAccelerator)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="51857">ALM Accelerator Pipeline</st> <st c="51883">templates:</st> [<st
    c="51894">https://github.com/microsoft/coe-alm-accelerator-templates/tree/main</st>](https://github.com/microsoft/coe-alm-accelerator-templates/tree/main)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="51962">Power Apps Test</st> <st c="51979">Studio:</st> [<st c="51987">https://docs.microsoft.com/en-us/powerapps/maker/canvas-apps/test-studio</st>](https://docs.microsoft.com/en-us/powerapps/maker/canvas-apps/test-studio)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="52059">Visual Studio Unit</st> <st c="52079">testing:</st> [<st c="52088">https://learn.microsoft.com/en-us/visualstudio/test/getting-started-with-unit-testing?view=vs-2022&tabs=dotnet%2Cmstest</st>](https://learn.microsoft.com/en-us/visualstudio/test/getting-started-with-unit-testing?view=vs-2022&tabs=dotnet%2Cmstest)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="52207">Automate tests with Azure DevOps</st> <st c="52241">Pipelines:</st>
    [<st c="52252">https://docs.microsoft.com/en-us/powerapps/maker/canvas-apps/test-studio-classic-pipeline-editor</st>](https://docs.microsoft.com/en-us/powerapps/maker/canvas-apps/test-studio-classic-pipeline-editor)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="52348">PowerApps Test</st> <st c="52364">Engine:</st> [<st c="52372">https://learn.microsoft.com/en-us/power-apps/developer/test-engine/overview</st>](https://learn.microsoft.com/en-us/power-apps/developer/test-engine/overview)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="52447">The Azure Load Testing</st> <st c="52471">service:</st> [<st c="52480">https://learn.microsoft.com/en-us/azure/load-testing/overview-what-is-azure-load-testing</st>](https://learn.microsoft.com/en-us/azure/load-testing/overview-what-is-azure-load-testing)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="52568">Microsoft Copilot Studio test</st> <st c="52599">framework:</st>
    [<st c="52610">https://powervirtualagents.microsoft.com/en-us/blog/automate-testing-of-your-power-virtual-agents-chatbots-with-the-pva-test-framework-sample-solution/</st>](https://powervirtualagents.microsoft.com/en-us/blog/automate-testing-of-your-power-virtual-agents-chatbots-with-the-pva-test-framework-sample-solution/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="52761">Microsoft Copilot Studio Implementation</st> <st c="52802">Guide:</st>
    [<st c="52809">https://aka.ms/CopilotStudioImplementationGuide</st>](https://aka.ms/CopilotStudioImplementationGuide)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
