<html><head></head><body>
		<div id="_idContainer073">
			<h1 id="_idParaDest-99" class="chapter-number"><a id="_idTextAnchor103"/><st c="0">6</st></h1>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor104"/><st c="2">A Deep Dive into Continuous Integration/Continuous Deployment (CI/CD) Pipelines</st></h1>
			<p><st c="81">In this chapter, we will</st><a id="_idIndexMarker618"/><st c="106"> get hands-on experience in designing </st><strong class="bold"><st c="144">Application Life</st></strong><strong class="bold"><st c="160"> C</st></strong><strong class="bold"><st c="162">ycle Management</st></strong><st c="177"> (</st><strong class="bold"><st c="179">ALM</st></strong><st c="182">) processes for applications with both code first and low-code/no-code components. </st><st c="266">In addition, we will cover how DevOps engineers can standardize pipelines</st><a id="_idIndexMarker619"/><st c="339"> and refuel</st><a id="_idIndexMarker620"/><st c="350"> them in any</st><a id="_idIndexMarker621"/><st c="362"> other</st><a id="_idIndexMarker622"/><st c="368"> new Power Platform projects, using </st><strong class="bold"><st c="404">pipeline templates</st></strong><st c="422"> and </st><strong class="bold"><st c="427">reusable workflows</st></strong><st c="445"> in </st><strong class="bold"><st c="449">Azure DevOps</st></strong><st c="461"> and </st><strong class="bold"><st c="466">GitHub</st></strong><st c="472"> as reusable building blocks. </st><st c="502">We will gain insights</st><a id="_idIndexMarker623"/><st c="523"> and a solid understanding of the </st><strong class="bold"><st c="557">ALM Accelerator for Power Platform</st></strong><st c="591"> package, part of the Power Platform Center of Excellence Starter Kit, and what we can reuse from this package in our own DevOps environment. </st><st c="733">We will also learn about </st><strong class="bold"><st c="758">Power Platform pipelines</st></strong><st c="782">, the managed pipelines, and how</st><a id="_idIndexMarker624"/><st c="814"> they can leverage the features of professional DevOps tools, such as automated testing. </st><st c="903">Finally, the chapter</st><a id="_idIndexMarker625"/><st c="923"> will also teach us about </st><strong class="bold"><st c="949">automated testing</st></strong><st c="966"> with available open source frameworks</st><a id="_idIndexMarker626"/><st c="1004"> and their integration into </st><strong class="bold"><st c="1032">Continuous Integration and Continuous Deployment</st></strong><st c="1080"> (</st><span class="No-Break"><strong class="bold"><st c="1082">CI/CD</st></strong></span><span class="No-Break"><st c="1087">) pipelines.</st></span></p>
			<p><st c="1100">In this chapter, we’re going to cover the following </st><span class="No-Break"><st c="1153">main topics:</st></span></p>
			<ul>
				<li><st c="1165">When everything comes together – branches, environments, and Power </st><span class="No-Break"><st c="1233">Platform catalog</st></span></li>
				<li><st c="1249">Azure pipeline templates and reusable </st><span class="No-Break"><st c="1288">GitHub workflows</st></span></li>
				<li><st c="1304">The ALM Accelerator for </st><span class="No-Break"><st c="1329">Power Platform</st></span></li>
				<li><st c="1343">Automated testing in DevOps and Power </st><span class="No-Break"><st c="1382">Platform pipelines</st></span></li>
			</ul>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor105"/><st c="1400">Technical requirements</st></h1>
			<p><st c="1423">To do a deep dive into our CI/CD pipelines by using pro-development DevOps tools, we need to have </st><span class="No-Break"><st c="1522">the following:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="1536">A Power Platform subscription</st></strong><st c="1566">: We can sign up for a Power Apps Developer Plan (</st><a href="https://www.microsoft.com/en-us/power-platform/products/power-apps/free"><st c="1617">https://www.microsoft.com/en-us/power-platform/products/power-apps/free</st></a><st c="1689">) if we already have a Microsoft Entra ID work account, or we can join the Microsoft 365 Developer </st><span class="No-Break"><st c="1789">Program (</st></span><a href="https://developer.microsoft.com/en-us/microsoft-365/dev-program"><span class="No-Break"><st c="1798">https://developer.microsoft.com/en-us/microsoft-365/dev-program</st></span></a><span class="No-Break"><st c="1862">).</st></span></li>
				<li><strong class="bold"><st c="1865">An Azure DevOps Services organization</st></strong><st c="1903">: We can create a DevOps organization any time </st><em class="italic"><st c="1951">for free</st></em><st c="1959"> (</st><a href="https://learn.microsoft.com/en-us/azure/devops/user-guide/sign-up-invite-teammates"><st c="1961">https://learn.microsoft.com/en-us/azure/devops/user-guide/sign-up-invite-teammates</st></a><st c="2043">). </st><st c="2047">If we create a public project in Azure DevOps, we get multiple free pipelines and free access to every feature of the service (see the </st><strong class="bold"><st c="2182">Azure DevOps for Open </st></strong><span class="No-Break"><strong class="bold"><st c="2204">Source</st></strong></span><span class="No-Break"><st c="2210"> offering).</st></span></li>
				<li><st c="2221">A </st><strong class="bold"><st c="2224">GitHub handle</st></strong><st c="2237"> and public repository (</st><a href="https://github.com/signup"><st c="2261">https://github.com/signup</st></a><st c="2287">), which is also </st><em class="italic"><st c="2305">free</st></em><st c="2309"> for </st><span class="No-Break"><st c="2314">public repositories.</st></span></li>
				<li><st c="2334">Samples and walkthroughs discussed in this chapter are located </st><span class="No-Break"><st c="2398">at </st></span><a href="https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/tree/main/Chapter06"><span class="No-Break"><st c="2401">https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/tree/main/Chapter06</st></span></a><span class="No-Break"><st c="2500">.</st></span></li>
			</ul>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor106"/><st c="2501">When everything comes together</st></h1>
			<p><st c="2532">In the previous chapter, we saw how Azure DevOps Services pipelines and GitHub flows can interact with our Dataverse environments and Power Platform solutions to deliver DevOps </st><span class="No-Break"><st c="2710">CI/CD capabilities.</st></span></p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor107"/><st c="2729">Branches and environments</st></h2>
			<p><st c="2755">If we follow the</st><a id="_idIndexMarker627"/><st c="2772"> trunk-based branching strategy </st><a id="_idIndexMarker628"/><st c="2804">or the very similar </st><strong class="bold"><st c="2824">GitHub flow</st></strong><st c="2835">, we will frequently create short-lived branches for development purposes. </st><st c="2910">These branches are the</st><a id="_idIndexMarker629"/><st c="2932"> so-called </st><strong class="bold"><st c="2943">feature branches</st></strong><st c="2959"> that we can use to implement new user requirements or fix bugs that our customers or our internal quality assurance process </st><span class="No-Break"><st c="3084">have found.</st></span></p>
			<p><st c="3095">We can use </st><strong class="bold"><st c="3107">Build Tools for Power Platform</st></strong><st c="3137"> and, respectively, the underlying </st><strong class="bold"><st c="3172">Pac CLI</st></strong><st c="3179"> to spin up </st><a id="_idIndexMarker630"/><st c="3191">developer </st><a id="_idIndexMarker631"/><st c="3201">environments. </st><st c="3215">A typical branch</st><a id="_idIndexMarker632"/><st c="3231"> structure of a particular solution might look </st><span class="No-Break"><st c="3278">as follows:</st></span></p>
			<pre class="source-code"><st c="3289">
main
    test
        devA
        devB
        devZ</st></pre>			<p><st c="3314">With the help of </st><strong class="bold"><st c="3332">branch policies</st></strong><st c="3347">, we can force developers</st><a id="_idIndexMarker633"/><st c="3372"> to use pull requests to merge back changes to test and/or main branches. </st><st c="3446">In the case of Azure DevOps Services, if we configure any of the branch policies for a branch (</st><strong class="bold"><st c="3541">Require </st></strong><strong class="bold"><st c="3550">a </st></strong><strong class="bold"><st c="3552">minimum number of reviewers</st></strong><st c="3579">, </st><strong class="bold"><st c="3581">Check for linked work items</st></strong><st c="3608">, </st><strong class="bold"><st c="3610">Check for comment resolution</st></strong><st c="3638">, or </st><strong class="bold"><st c="3643">Limit merge types</st></strong><st c="3660">), that branch</st><a id="_idIndexMarker634"/><st c="3675"> cannot be deleted and requires </st><strong class="bold"><st c="3707">pull requests</st></strong><st c="3720"> (</st><strong class="bold"><st c="3722">PRs</st></strong><st c="3725">) for all changes. </st><st c="3745">As such, we can avoid accidental changes directly committed to these </st><span class="No-Break"><st c="3814">dedicated branches:</st></span></p>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/B22208_06_1.jpg" alt="Figure 6.1 – Branch Policies"/><st c="3833"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="4609">Figure 6.1 – Branch Policies</st></p>
			<p class="callout-heading"><st c="4637">Check for linked work items</st></p>
			<p class="callout"><st c="4665">We highly recommend enforcing this setting for your dedicated main and test branches. </st><st c="4752">It just ensures that there can be no changes without well-defined user stories or </st><span class="No-Break"><st c="4834">backlog items.</st></span></p>
			<p><st c="4848">We can implement similar configurations on GitHub. </st><st c="4900">This is called </st><strong class="bold"><st c="4915">branch protection rules</st></strong><st c="4938">, and it provides even more</st><a id="_idIndexMarker635"/><st c="4965"> options. </st><st c="4975">For instance, we can require PR reviews before merging, require status checks to pass before merging, and restrict who can push to the branch. </st><st c="5118">We can also force </st><strong class="bold"><st c="5136">signed commits</st></strong><st c="5150"> to verify the authenticity</st><a id="_idIndexMarker636"/><st c="5177"> of a commit, by attaching a cryptographic signature to it. </st><st c="5237">This signature is created using the committer’s private key and can be verified by others, using the committer’s public key. </st><st c="5362">Signed commits provide assurance that code changes are made by a trusted and </st><span class="No-Break"><st c="5439">authorized source.</st></span></p>
			<p><st c="5457">The following figure shows all the protection rules</st><a id="_idIndexMarker637"/><st c="5509"> available for </st><span class="No-Break"><st c="5524">GitHub branches:</st></span></p>
			<div>
				<div id="_idContainer067" class="IMG---Figure">
					<img src="image/B22208_06_2.jpg" alt="Figure 6.2 – Branch protection rules"/><st c="5540"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="7557">Figure 6.2 – Branch protection rules</st></p>
			<p><st c="7593">Whichever DevOps tool we use, our goal is to create a DevOps framework in which professional developers can collaborate not just with each other but also with every developer (citizen developer). </st><st c="7790">To set up the right </st><strong class="bold"><st c="7810">quality gates</st></strong><st c="7823"> during development, it is recommended</st><a id="_idIndexMarker638"/><st c="7861"> to map our branch structure in dedicated and ad hoc/developer Power </st><span class="No-Break"><st c="7930">Platform environments:</st></span></p>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/B22208_06_3.jpg" alt="Figure 6.3 – Branches and environments"/><st c="7952"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="8032">Figure 6.3 – Branches and environments</st></p>
			<p><st c="8070">In the preceding diagram, the arrows</st><a id="_idIndexMarker639"/><st c="8107"> between the Power Platform environments and Git branches represent the code</st><a id="_idIndexMarker640"/><st c="8183"> and deployment flows. </st><st c="8206">The production environment</st><a id="_idIndexMarker641"/><st c="8232"> and test environment can handle only PRs (i.e. </st><st c="8280">the solution is only imported into those environments), whereas developer environments should be bidirectional, since changes in those environments will be exported back to Git repos and, respectively, dev branches. </st><st c="8496">In our case, the </st><strong class="source-inline"><st c="8513">US_XXX_Y</st></strong><st c="8521"> branch represents</st><a id="_idIndexMarker642"/><st c="8539"> a short-lived feature branch containing the implementation of a user story. </st><st c="8616">CI/CD pipelines with different trigger conditions manage the interaction between the two worlds, starting from the beginning of a solution’s life cycle. </st><st c="8769">Pipelines/workflows can even be used to create these automations throughout the </st><span class="No-Break"><st c="8849">developer journey.</st></span></p>
			<p><st c="8867">Let’s have a detailed look at how we can</st><a id="_idIndexMarker643"/><st c="8908"> use Azure Pipelines to automate some of the most </st><span class="No-Break"><st c="8958">common steps:</st></span></p>
			<ol>
				<li><strong class="bold"><st c="8971">Create a developer branch</st></strong><st c="8997">: We can use the following Bash script to create </st><span class="No-Break"><st c="9047">a branch:</st></span><pre class="source-code">
<strong class="bold"><st c="9056">git config user.name $(Build.RequestedFor)</st></strong>
<strong class="bold"><st c="9099">git config user.email $(Build.RequestedForEmail)</st></strong>
<strong class="bold"><st c="9148">#creating the branch under "dev" folder</st></strong>
<strong class="bold"><st c="9188">newbranch=dev/${{ parameters.devbranch }}</st></strong>
<strong class="bold"><st c="9230">git checkout -b $newbranch</st></strong>
<strong class="bold"><st c="9257">git -c http.extraheader="AUTHORIZATION: bearer $(System.AccessToken)" push origin $newbranch</st></strong></pre></li>				<li><strong class="bold"><st c="9350">Provision a Power Platform developer environment</st></strong><st c="9399">: First, we need to sign in to the Power Platform environment by using a service principal on a Microsoft-hosted Windows machine, as the Pac CLI stores authentication credentials as plain text on </st><span class="No-Break"><st c="9596">Linux machines:</st></span><pre class="source-code">
<strong class="bold"><st c="9611">pac auth create --applicationId 862e5a17-d38b-43ff-b24f-88a77f59623f \</st></strong>
<strong class="bold"><st c="9682">   --clientSecret $(ClientSecret) \</st></strong>
<strong class="bold"><st c="9715">   --tenant 4ae51f31-033a-48fa-be48-5ece14d2c081</st></strong></pre><p class="list-inset"><st c="9761">We also need to sign</st><a id="_idIndexMarker644"/><st c="9782"> in to our Azure tenant, using the same service principal, to figure out who has triggered this </st><span class="No-Break"><st c="9878">Azure Pipeline:</st></span></p><pre class="source-code"><strong class="bold"><st c="9893">az login --service-principal \</st></strong>
<strong class="bold"><st c="9924">      -u 862e5a17-d38b-43ff-b24f-88a77f59623f \</st></strong>
<strong class="bold"><st c="9966">      -p $(ClientSecret) \</st></strong>
<strong class="bold"><st c="9987">      --tenant 4ae51f31-033a-48fa-be48-5ece14d2c081</st></strong>
<strong class="bold"><st c="10033">AADObjectID=$(az ad user show \</st></strong>
<strong class="bold"><st c="10065">             --id $(Build.RequestedForEmail) \</st></strong>
<strong class="bold"><st c="10099">             --query id \</st></strong>
<strong class="bold"><st c="10112">             --output tsv)</st></strong>
<strong class="bold"><st c="10126">    echo "AADObject ID: $AADObjectID"</st></strong></pre><p class="list-inset"><st c="10160">The </st><strong class="source-inline"><st c="10165">$(Build.RequestedForEmail)</st></strong><st c="10191"> system variable contains the email address of the user who started the pipeline. </st><st c="10273">We use the Microsoft Entra ID’s user object ID to create a Power Platform developer environment on behalf of this user (the command, per se, runs under the name of the service principal and not on behalf of </st><span class="No-Break"><st c="10480">our users):</st></span></p><pre class="source-code"><strong class="bold"><st c="10491">pac admin create --name "dev-US_XXX_Y" \</st></strong>
<strong class="bold"><st c="10532">       --type Developer \</st></strong>
<strong class="bold"><st c="10551">       --user $AADObjectID</st></strong></pre><p class="list-inset"><st c="10571">After creating the Power Platform</st><a id="_idIndexMarker645"/><st c="10605"> environment, we need to assign the developer (who has started the pipeline) to it as the </st><span class="No-Break"><st c="10695">System Administrator:</st></span></p><pre class="source-code"><strong class="bold"><st c="10716"># Get the environment Id (the row before the last row contains the information)</st></strong>
<strong class="bold"><st c="10796">rawOutput=$(pac admin list --name dev-us_XXX_Y | tail -n 2)</st></strong>
<strong class="bold"><st c="10856">environmentId=$(echo $rawOutput | cut -d ' ' -f 2)</st></strong>
<strong class="bold"><st c="10907">#adding system administrator role to the user who has created the developer environment</st></strong>
<strong class="bold"><st c="10995">pac admin assign-user --environment $environmentId --user $AADObjectID --role "System Administrator"</st></strong></pre></li>			</ol>
			<p class="callout-heading"><st c="11096">Developer environments</st></p>
			<p class="callout"><st c="11119">Every user in Power Platform can create up to three developer environments </st><span class="No-Break"><st c="11195">for free.</st></span></p>
			<ol>
				<li value="3"><strong class="bold"><st c="11204">Create an Azure DevOps Service connection</st></strong><st c="11246">: As we have seen earlier in </st><a href="B22208_05.xhtml#_idTextAnchor089"><span class="No-Break"><em class="italic"><st c="11276">Chapter 5</st></em></span></a><st c="11285">, </st><strong class="bold"><st c="11287">Azure DevOps Service connections</st></strong><st c="11319"> are used to connect to first- and third-party</st><a id="_idIndexMarker646"/><st c="11365"> services, such as Microsoft Azure, GitHub, AKS, Docker, and Power Platform, from Azure Pipelines. </st><st c="11464">Every task of Power Platform Build Tools expects a </st><strong class="bold"><st c="11515">Power Platform service connection reference</st></strong><st c="11558"> to be able to authenticate</st><a id="_idIndexMarker647"/><st c="11585"> and perform actions, such as </st><strong class="source-inline"><st c="11615">export solution</st></strong><st c="11630">, </st><strong class="source-inline"><st c="11632">import solution</st></strong><st c="11647">, </st><strong class="source-inline"><st c="11649">copy environment</st></strong><st c="11665">, and </st><strong class="source-inline"><st c="11671">backup</st></strong><st c="11677">, against the environment. </st><st c="11704">If we want to automate the service connection creation process, it is also possible. </st><st c="11789">We need to create a JSON file that we will post as a payload to the </st><strong class="source-inline"><st c="11857">REST</st></strong><st c="11861"> endpoint of Azure DevOps Services (see </st><strong class="source-inline"><st c="11901">AzDO/.pipelines/config-tokenizer.yml</st></strong><st c="11937"> in the </st><strong class="source-inline"><st c="11945">Chapter06</st></strong><st c="11954"> folder of the </st><a id="_idIndexMarker648"/><span class="No-Break"><st c="11969">GitHub repo):</st></span><pre class="source-code"><st c="11982">
{
   "authorization": {
      "parameters": {
         "tenantId": "GUID",
         "applicationId": "GUID",
         "clientSecret": "secret"
      },
      "scheme": "None"
   },
   "createdBy": {},
   "data": {},
   "isShared": false,
   "isOutdated": false,
   "name": "ConnenctionName",
   "owner": "library",
   "type": "powerplatform-spn",
   "url": "DataverseURL",
   "administratorsGroup": null,
   "description": "",
   "groupScopeId": null,
   "operationStatus": null,
   "readersGroup": null,
   "serviceEndpointProjectReferences": [
    {
         "description": "",
         "name": "ProjectName",
         "projectReference": {
            "id": "ProjectID",
            "name": "ProjectName"
         }
     }
   ]
}</st></pre><p class="list-inset"><st c="12550">We can use the following Bash</st><a id="_idIndexMarker649"/><st c="12580"> script to tokenize this JSON file (see </st><strong class="source-inline"><st c="12620">AzDO/.pipelines/create-service-connection.yml</st></strong><st c="12665"> in the </st><strong class="source-inline"><st c="12673">Chapter06</st></strong><st c="12682"> folder of the </st><span class="No-Break"><st c="12697">GitHub repo):</st></span></p><pre class="source-code"><st c="12710"># Set the filename
filename="config_tokenizer.json"
# Read the JSON file
json_string=$(cat .pipelines/$filename)
# Replace the value
new_json_string=$(jq '.authorization.parameters.clientSecret = "$(ClientSecret)"' &lt;&lt;&lt; "$json_string")
new_json_string=$(jq '.authorization.parameters.tenantId = "$(tenantId)"' &lt;&lt;&lt; "$new_json_string")
new_json_string=$(jq '.authorization.parameters.applicationId = "$(applicationId)"' &lt;&lt;&lt; "$new_json_string")
new_json_string=$(jq '.url = "${{ parameters.ppdevenvironmentURL }}"' &lt;&lt;&lt; "$new_json_string")
new_json_string=$(jq '.name = "${{ parameters.ppdevenvironment }}"' &lt;&lt;&lt; "$new_json_string")
new_json_string=$(jq '.serviceEndpointProjectReferences[0].projectReference.id = "$(System.TeamProjectId)"' &lt;&lt;&lt; "$new_json_string")
new_json_string=$(jq '.serviceEndpointProjectReferences[0].projectReference.name = "$(System.TeamProject)"' &lt;&lt;&lt; "$new_json_string")
new_json_string=$(jq '.serviceEndpointProjectReferences[0].name = "${{ parameters.ppdevenvironment }}"' &lt;&lt;&lt; "$new_json_string")
# Write the modified JSON data back to the file
echo $new_json_string &gt; config.json</st></pre><p class="list-inset"><st c="13813">If we want to execute</st><a id="_idIndexMarker650"/><st c="13835"> this script locally, then we can use </st><strong class="bold"><st c="13873">Windows Subsystem for Linux</st></strong><st c="13900"> (</st><strong class="bold"><st c="13902">WSL</st></strong><st c="13905">) on Windows machines</st><a id="_idIndexMarker651"/><st c="13927"> to download a Linux distro, such as Ubuntu or Debian. </st><st c="13982">To install WSL, we just need to visit the Microsoft Store and search for the distro. </st><st c="14067">If the WSL feature is missing from our OS, the installation will provide us with a guide on how to enable the feature from the Control Panel by selecting the menu item, </st><strong class="bold"><st c="14236">Turn Windows features on or off</st></strong><st c="14267">. After installing the distro, we can use Windows Terminal or the terminal in Visual Studio Code to execute the previous scripts. </st><st c="14397">If we want to use PowerShell</st><a id="_idIndexMarker652"/><st c="14425"> instead of Bash, we can use </st><strong class="bold"><st c="14454">Microsoft Copilot</st></strong><st c="14471"> (</st><a href="https://copilot.microsoft.com"><st c="14473">https://copilot.microsoft.com</st></a><st c="14502">) anytime to translate the Bash script to the </st><span class="No-Break"><st c="14549">PowerShell version.</st></span></p><p class="list-inset"><st c="14568">Finally, we can use </st><strong class="source-inline"><st c="14589">az devops</st></strong><st c="14598"> CLI commands to automatically create our </st><span class="No-Break"><st c="14640">service connection:</st></span></p><pre class="source-code"><strong class="bold"><st c="14659">echo $(PatToken) | az devops login --organization $(System.CollectionUri)</st></strong>
<strong class="bold"><st c="14733">az devops service-endpoint create \</st></strong>
<strong class="bold"><st c="14769">   --organization $(System.CollectionUri) \</st></strong>
<strong class="bold"><st c="14810">   --project $(System.TeamProject) --service-endpoint-configuration config.json</st></strong></pre></li>				<li><strong class="bold"><st c="14887">Import the solution to the new developer environment</st></strong><st c="14940">: Now, we have everything in place to import</st><a id="_idIndexMarker653"/><st c="14985"> the solution into our brand-new developer environment as an unmanaged one. </st><st c="15061">Since our branch is derived from the test branch, it contains the latest source code version of the solution (see </st><strong class="source-inline"><st c="15175">AzDO/.pipelines/import-solution.yml</st></strong><st c="15210"> in the </st><strong class="source-inline"><st c="15218">Chapter06</st></strong><st c="15227"> folder of the </st><span class="No-Break"><st c="15242">GitHub repo):</st></span><pre class="source-code"><st c="15255">
steps:
- checkout: git://PowerPlatform/Copilot@${{parameters.sourceBranch}}
  displayName: 'Checkout Source Branch'
  persistCredentials: true
- task: PowerPlatformToolInstaller@2
  inputs:
   DefaultVersion: true
- task: PowerPlatformPackSolution@2
  inputs:
    SolutionSourceFolder: '$(System.DefaultWorkingDirectory)/src/$(solutionName)'
    SolutionOutputFile: '$(Build.ArtifactStagingDirectory)/Solution/$(solutionName).zip'
    SolutionType: 'Unmanaged'
- task: PublishBuildArtifacts@1
  inputs:
    PathtoPublish: '$(Build.ArtifactStagingDirectory)/Solution'
    ArtifactName: 'Solution'
    publishLocation: 'Container'
- task: PowerPlatformImportSolution@2
  inputs:
    authenticationType: 'PowerPlatformSPN'
    PowerPlatformSPN: ${{parameters.serviceconnection}}
    SolutionInputFile: '$(Build.ArtifactStagingDirectory)/Solution/$(solutionName).zip'
    AsyncOperation: true
    MaxAsyncWaitTime: '60'
- task: PowerPlatformPublishCustomizations@2
  inputs:
    authenticationType: 'PowerPlatformSPN'
    PowerPlatformSPN: ${{parameters.serviceconnection}}</st></pre><p class="list-inset"><st c="16256">We use </st><strong class="source-inline"><st c="16264">${{parameters.serviceconnection}}</st></strong><st c="16297"> as a string parameter of the pipeline, which represents the name of the service connection </st><span class="No-Break"><st c="16389">previously created.</st></span></p><p class="list-inset"><st c="16408">We can put these steps together</st><a id="_idIndexMarker654"/><st c="16440"> into one pipeline or keep them separately. </st><st c="16484">We can also chain these pipelines by using other trigger conditions, such as </st><strong class="source-inline"><st c="16561">branch created</st></strong><st c="16575">. For instance, a new dev branch is created under the </st><strong class="source-inline"><st c="16629">dev/*</st></strong><st c="16634"> condition looks, </st><span class="No-Break"><st c="16652">as follows:</st></span></p><pre class="source-code"><strong class="bold"><st c="16663">trigger:</st></strong>
<strong class="bold"><st c="16672">-  dev/*</st></strong></pre></li>			</ol>
			<p><st c="16680">After going through these automation steps, we finally have a developer branch on which we can start our work. </st><st c="16792">It is recommended to assign one or more work items to this branch by using the available tools in Azure DevOps; otherwise, PRs submitted later will be automatically rejected (if recommended branch policies </st><span class="No-Break"><st c="16998">are configured).</st></span></p>
			<p><st c="17014">The following figure shows us how to assign the</st><a id="_idTextAnchor108"/><st c="17062"> branch to an </st><strong class="bold"><st c="17076">Issue</st></strong> <span class="No-Break"><st c="17081">work item:</st></span></p>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/B22208_06_4.jpg" alt="Figure 6.4 – Linking a branch to a work item"/><st c="17092"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="17272">Figure 6.4 – Linking a branch to a work item</st></p>
			<p><st c="17316">Making changes in the Power Platform environment</st><a id="_idIndexMarker655"/><st c="17365"> should be reflected on the dev branch to track changes in the version control system. </st><st c="17452">To achieve this, we need to create another pipeline (</st><strong class="source-inline"><st c="17505">Export-to-Git</st></strong><st c="17519">) that exports our managed and unmanaged solutions, unpacks them, and commits changes to our dev branch. </st><st c="17625">We saw some of these building blocks in </st><a href="B22208_05.xhtml#_idTextAnchor089"><span class="No-Break"><em class="italic"><st c="17665">Chapter 5</st></em></span></a><st c="17674">. In addition to that pipeline, we need to add a step to export the solution as unmanaged and to unpack the solution with type </st><strong class="source-inline"><st c="17801">Both</st></strong><st c="17805">. To commit changes back to a branch, we can use the following Git commands, executed as Bash script after our </st><strong class="source-inline"><st c="17916">PowerPlatformExportSolution@2</st></strong><st c="17945"> and </st><strong class="source-inline"><st c="17950">PowerPlatformUnpackSolution@2</st></strong><st c="17979"> build tasks in </st><span class="No-Break"><st c="17995">the pipeline:</st></span></p>
			<pre class="source-code"><st c="18008">
-  checkout:  git://$(System.TeamProject)/$(Build.Repository.Name)@${{parameters.targetBranch}}
    displayName:  'Checkout  Source  Branch'
    persistCredentials:  true
#  Configure  email/name  and  checkout  git  branch
-  script:  |
      git  config  user.name  $(Build.RequestedFor)
      git  config  user.email  $(Build.RequestedForEmail)
      git  checkout  origin/${{parameters.targetBranch}}  --track
[[Adding here those PowerPlatformExportSolution@2 and PowerPlatformUnpackSolution@2 steps discussed earlier.]]
-  script:  |
        #!/bin/bash
        set  -e
        #  Set  the  path  to  the  directory  containing  the  solution
        solution_dir="$(Build.SourcesDirectory)/src/$(solutionName)"
        #  Find  all  Solution.xml  files  in  the  solution  directory  and  its  subdirectories
        find  "$solution_dir"  -type  f  -name  "Solution.xml"  |  while  read  -r  file;  do
                #  Replace  the  content  of  the  &lt;Version&gt;  tag  with  0.0.0.0
                sed  -i  's|&lt;Version&gt;.*&lt;/Version&gt;|&lt;Version&gt;0.0.0.0&lt;/Version&gt;|g'  "$file"
        done
    displayName:  "Set  version  number  to  0.0.0.0"
-  script:  |
        rm  -rf  ./out/$(solutionName).zip
        rm  -rf  ./out/$(solutionName)_managed.zip
        git  add  --all
        git  commit  -am  "Solution  is  committed"  --allow-empty
        git  -c  httpO.extraheader="AUTHORIZATION:  bearer  $(System.AccessToken)"  push  origin  ${{parameters.targetBranch}}</st></pre>			<p><st c="19227">With the help of this pipeline, our developers can constantly commit their changes back to their own </st><a id="_idIndexMarker656"/><st c="19329">dedicated dev branches throughout feature development. </st><st c="19384">We set the version number of the solution intentionally to </st><strong class="source-inline"><st c="19443">0.0.0.0</st></strong><st c="19450"> to avoid conflicting merges, as well as to manage version numbers with Azure pipelines. </st><st c="19539">When developers are ready, they can submit a PR back to the </st><span class="No-Break"><st c="19599">parent branch.</st></span></p>
			<p><st c="19613">Let’s discuss some additional DevOps design principles and recommendations</st><a id="_idIndexMarker657"/><st c="19688"> in conjunction with our </st><span class="No-Break"><st c="19713">DevOps process:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="19728">Do we need a separate pipeline for CI?</st></strong><st c="19767"> We can use the </st><strong class="source-inline"><st c="19783">PowerPlatformPackSolution@2</st></strong><st c="19810"> build task anytime to pack our solution from source control. </st><st c="19872">It is a compression step—actually it zips our folder, so it doesn’t require a long compilation time. </st><st c="19973">Of course, if we have</st><a id="_idIndexMarker658"/><st c="19994"> code components to be built, such as </st><strong class="bold"><st c="20032">PowerApps Component Framework</st></strong><st c="20061"> (</st><strong class="bold"><st c="20063">PCF</st></strong><st c="20066">) controls or Dataverse plugins, or if we target multiple environments with the same manifest (solution), then it is worth creating dedicated pipelines </st><span class="No-Break"><st c="20219">for CI.</st></span></li>
				<li><strong class="bold"><st c="20226">Do we need a separate pipeline for CD, pipeline stages, and approval processes?</st></strong><st c="20306"> After finalizing our work on the dev branch using the </st><strong class="source-inline"><st c="20361">Export-to-Git</st></strong><st c="20374"> pipeline, we can submit a PR to merge back our changes to test and later to production branches. </st><st c="20472">We can introduce CD pipelines that are executed upon completion of the PR on the target branch with a simple </st><span class="No-Break"><st c="20581">branch trigger:</st></span><pre class="source-code">
<strong class="bold"><st c="20596">trigger:</st></strong>
<strong class="bold"><st c="20605">-  test</st></strong></pre><p class="list-inset"><st c="20612">We can also create </st><a id="_idIndexMarker659"/><st c="20632">pipelines for the PR itself that are triggered as a build validation policy. </st><st c="20709">These pipelines validate code by pre-merging and building pull request changes, which – in the case of Power Platform – builds the solution and deploys it to an on-demand provisioned Power Platform environment and then executes various checks, such</st><a id="_idIndexMarker660"/><st c="20957"> as calling </st><strong class="source-inline"><st c="20969">SolutionChecker</st></strong><st c="20984"> or performing </st><strong class="bold"><st c="20999">automated tests</st></strong><st c="21014">. We can introduce approval processes for staging environments (test and production) to control when changes are approved by release managers</st><a id="_idIndexMarker661"/><st c="21155"> or environment administrators, with the help of </st><strong class="bold"><st c="21204">Azure DevOps </st></strong><span class="No-Break"><strong class="bold"><st c="21217">Services environments</st></strong></span><span class="No-Break"><st c="21238">.</st></span></p></li>				<li><strong class="bold"><st c="21239">Version numbers of solutions – when do we need to set them?</st></strong><st c="21299"> As discussed earlier, with the rise of DevOps, we want to maintain only one version, the latest of our applications in production. </st><st c="21431">We use versioning and version numbers to be able to track changes back to the </st><span class="No-Break"><st c="21509">source code:</st></span><pre class="source-code"><st c="21521">
#  Solution  version  in  source  control  is  not  used.  </st><st c="21572">Instead,  create  version  at  build  time  from  the  current  build  number.
</st><st c="21641">-  pwsh:  |
      Get-ChildItem  -Path  "$(Build.SourcesDirectory)\$(RepoName)\${{parameters.solutionName}}\SolutionPackage\**\Solution.xml"  |
      ForEach-Object  {
                (Get-Content  $_.FullName)  `
                        -replace  '&lt;Version&gt;0.0.0.0&lt;\/Version&gt;',  '&lt;Version&gt;$(Build.BuildNumber)&lt;/Version&gt;'  |
                Out-File  $_.FullName
      }
    displayName:  'Update  Solution  XML  with  Build  Number'</st></pre><p class="list-inset"><st c="21978">We can set the </st><strong class="source-inline"><st c="21994">Build.BuildNumber</st></strong><st c="22011"> of an Azure pipeline run directly in the </st><span class="No-Break"><st c="22053">YAML file:</st></span></p><pre class="source-code"><st c="22063">name:  1.0.$(Date:yyyyMMdd)$(Rev:.r)</st></pre><p class="list-inset"><st c="22099">This means that during the build/deployment, the version</st><a id="_idIndexMarker662"/><st c="22156"> is calculated on the fly, using the build name of the Azure pipeline. </st><st c="22227">This provides a one-to-one relationship between the solution version and the pipeline that generated </st><span class="No-Break"><st c="22328">that version.</st></span></p></li>				<li><strong class="bold"><st c="22341">How to keep our developer branch up to date?</st></strong><st c="22386"> Creating a pipeline that deploys the latest version to our branch from the parent branch. </st><st c="22477">With a slight change in our </st><strong class="source-inline"><st c="22505">Export-to-Git</st></strong><st c="22518"> pipeline, we can introduce a parameter that expects the name of the branch in which the parent branch’s current version should be deployed. </st><st c="22659">If we don’t want to override our work in such a way, we can use Git commands such as </st><strong class="source-inline"><st c="22744">git rebase</st></strong><st c="22754"> to restore our developer branch to the latest version of the parent branch. </st><st c="22831">After this, we need to import the solution using the other pipeline into our </st><span class="No-Break"><st c="22908">developer environments.</st></span></li>
			</ul>
			<p><st c="22931">Overall, we can manage our development work with the following </st><span class="No-Break"><st c="22995">four pipelines:</st></span></p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/B22208_06_5.jpg" alt="Figure 6.5 – Pipelines to manage a solution"/><st c="23010"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="23412">Figure 6.5 – Pipelines to manage a solution</st></p>
			<p><st c="23455">We can create GitHub workflows in the same way. </st><st c="23504">Those Bash and PowerShell scripts can be easily moved to GitHub workflows, and the same branch and repository structure with assigned Power Platform environments can be built upon, like in Azure </st><span class="No-Break"><st c="23699">DevOps Services.</st></span></p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor109"/><st c="23715">The Power Platform catalog</st></h2>
			<p><st c="23742">In addition to this kind</st><a id="_idIndexMarker663"/><st c="23767"> of CI/CD delivery to Power Platform environments, Power Platform provides a new concept for managing our reusable packages. </st><st c="23892">The </st><strong class="bold"><st c="23896">Power Platform catalog</st></strong><st c="23918"> is a package manager that contains solution templates, PCF components, end-to-end solutions, and other assets for reuse purposes. </st><st c="24049">It is based on the same concept that we use in pro-dev scenarios when we publish our packages in different package management repositories, such as NuGet, npm, Maven, and Pip. </st><st c="24225">The catalog in Power Platform is a feature that allows developers and makers to easily discover and use Power Platform templates and code components within their organization. </st><st c="24401">It provides a private, central location for finding and installing the latest and most reliable versions of components, offering templates that deliver immediate value. </st><st c="24570">For administrators and line of business approvers, the catalog serves as a single source of truth to store and maintain Power Platform artifacts, allowing them to curate and control the content to accelerate value for makers and developers. </st><st c="24811">It also enables approval workflows for the use of sanctioned components and templates in sensitive regulatory and statutory scenarios, providing management capabilities with settings </st><span class="No-Break"><st c="24994">and metadata.</st></span></p>
			<p><st c="25007">To bring the catalog into one dedicated environment (it is recommended to provide a separate environment, such as </st><strong class="source-inline"><st c="25122">Catalog</st></strong><st c="25129">), we need to install</st><a id="_idIndexMarker664"/><st c="25151"> it as Dynamics 365 application from </st><span class="No-Break"><st c="25188">AppSource: </st></span><a href="https://appsource.microsoft.com/product/dynamics-365/powerappssvc.catalogmanager-preview?flightCodes=dde212e5c66047c59bf2b346c419cef6"><span class="No-Break"><st c="25199">https://appsource.microsoft.com/product/dynamics-365/powerappssvc.catalogmanager-preview?flightCodes=dde212e5c66047c59bf2b346c419cef6</st></span></a><span class="No-Break"><st c="25332">.</st></span></p>
			<p><st c="25333">After installing this D365 application, we can submit and deploy the following assets </st><span class="No-Break"><st c="25420">to it:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="25426">Dataverse solutions</st></strong><st c="25446"> (managed or unmanaged) or </st><strong class="bold"><st c="25473">package deployer packages</st></strong><st c="25498"> (enterprise templates can</st><a id="_idIndexMarker665"/><st c="25524"> also be published to </st><span class="No-Break"><st c="25546">the catalog)</st></span></li>
				<li><strong class="bold"><st c="25558">Templates</st></strong><st c="25568"> for a Power App or a Power </st><span class="No-Break"><st c="25596">Automate flow</st></span></li>
				<li><strong class="bold"><st c="25609">Power Platform code-first components</st></strong><st c="25646"> such as custom connectors</st><a id="_idIndexMarker666"/><st c="25672"> or </st><strong class="bold"><st c="25676">Power Apps component framework</st></strong><st c="25706"> (</st><span class="No-Break"><strong class="bold"><st c="25708">PCF</st></strong></span><span class="No-Break"><st c="25711">) controls</st></span></li>
			</ul>
			<p><st c="25722">The Power Platform catalog</st><a id="_idIndexMarker667"/><st c="25749"> brings additional security roles to manage the life cycle</st><a id="_idIndexMarker668"/><st c="25807"> of catalog items – </st><strong class="bold"><st c="25827">Catalog Submitter</st></strong><st c="25844"> to submit items to the catalog, </st><strong class="bold"><st c="25877">Catalog Read-Only Member</st></strong><st c="25901"> to discover and install</st><a id="_idIndexMarker669"/><st c="25925"> items from the catalog, </st><strong class="bold"><st c="25950">Catalog Approver</st></strong><st c="25966"> to approve submissions</st><a id="_idIndexMarker670"/><st c="25989"> to the</st><a id="_idIndexMarker671"/><st c="25996"> catalog, and </st><strong class="bold"><st c="26010">Catalog Administrator</st></strong><st c="26031"> to administer the catalog. </st><st c="26059">We get this enterprise-grade security from catalogs </st><span class="No-Break"><st c="26111">as well.</st></span></p>
			<p><st c="26119">Our Azure pipelines and GitHub workflows can target not just environments but also catalogs. </st><st c="26213">The Pac CLI provides the appropriate commands to submit our solutions, custom connectors, and PCF components to the catalog. </st><st c="26338">The following script creates a submission on our </st><strong class="source-inline"><st c="26387">mpa_ITBase_managed</st></strong><st c="26405"> solution (we used it in </st><a href="B22208_04.xhtml#_idTextAnchor074"><span class="No-Break"><em class="italic"><st c="26430">Chapter 4</st></em></span></a><st c="26439"> for managed pipelines) from the enterprise templates and submits a new </st><span class="No-Break"><st c="26511">catalog item:</st></span></p>
			<pre class="source-code"><st c="26524">
# Power Platform Catalog Manager application's GUID
pac admin list --application 83a35943-cb41-4266-b7d2-81d60f383695
# environment is the "Catalog" environment
pac catalog list --environment 0b90d036-e017-e840-9287-b1de3d95e252
# create a submission json file
pac catalog create-submission
# update the generated json file
pac catalog submit --environment 0b90d036-e017-e840-9287-b1de3d95e252 --path .\submission.json --solution-zip .\mpa_ITBase_managed.zip</st></pre>			<p><st c="26983">These scripts can run on behalf of service</st><a id="_idIndexMarker672"/><st c="27026"> principals as well. </st><st c="27047">By default, submissions need to be approved by catalog administrators, but we can change the configuration so that certain publishers, such as service principals running in Azure Pipelines or GitHub workflows, get </st><span class="No-Break"><st c="27261">automatic approval.</st></span></p>
			<p><st c="27280">The following figure shows the </st><strong class="bold"><st c="27312">Power Platform Catalog Manager</st></strong><st c="27342"> UI and an approval dialog after we have successfully submitted our </st><span class="No-Break"><strong class="source-inline"><st c="27410">mpa_ITBase_managed</st></strong></span><span class="No-Break"><st c="27428"> solution:</st></span></p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/B22208_06_6.jpg" alt="Figure 6.6 – Power Platform Catalog Manager"/><st c="27438"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="27540">Figure 6.6 – Power Platform Catalog Manager</st></p>
			<p class="callout-heading"><st c="27583">Power Platform catalogs</st></p>
			<p class="callout"><st c="27607">Power Platform catalogs</st><a id="_idIndexMarker673"/><st c="27631"> will be part of </st><strong class="bold"><st c="27648">managed environments</st></strong><st c="27668"> after they become </st><span class="No-Break"><st c="27687">generally</st></span><span class="No-Break"><a id="_idIndexMarker674"/></span><span class="No-Break"><st c="27696"> available.</st></span></p>
			<p><st c="27707">Let’s now move on to the pipeline templates and reusable workflows that provide reusability of our Azure pipelines and GitHub workflows on a </st><span class="No-Break"><st c="27849">large scale.</st></span></p>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor110"/><st c="27861">Azure pipeline templates and reusable GitHub workflows</st></h1>
			<p><st c="27916">Looking back at our Azure pipelines</st><a id="_idIndexMarker675"/><st c="27952"> in the previous section, we can say that it is a pretty good starting point to have everything automated. </st><st c="28059">However, if we need to support hundreds or even thousands of applications, then this approach of keeping three to four pipelines in every single repository, in which those solutions are maintained, will become more complex. </st><st c="28283">The more and more applications we develop, the more and more different versions of these Azure pipelines will exist in parallel. </st><st c="28412">It would be great to have a centralized repository containing the business logic of these pipelines and the solutions only customizing some parameters before calling them. </st><st c="28584">This is the idea behind Azure pipeline templates and reusable </st><span class="No-Break"><st c="28646">GitHub workflows.</st></span></p>
			<p><strong class="bold"><st c="28663">Azure pipeline templates</st></strong><st c="28688"> make it possible to create reusable business logic that we can use throughout our YAML pipeline instances. </st><st c="28796">These templates can be also used to control what is allowed in a pipeline by defining policies that the “caller” should follow. </st><st c="28924">For example, we can enforce task execution constraints by leveraging a template that acts as a safeguard, ensuring that any task performed follows our organization’s </st><span class="No-Break"><st c="29090">security guidelines.</st></span></p>
			<p><st c="29110">For instance, the following </st><strong class="bold"><st c="29139">template file</st></strong><st c="29152"> contains one step to install</st><a id="_idIndexMarker676"/><st c="29181"> the Pac CLI (see </st><strong class="source-inline"><st c="29199">AzDO/.pipelines/template/include-paccli-steps.yml</st></strong><st c="29248"> in the </st><strong class="source-inline"><st c="29256">Chapter06</st></strong><st c="29265"> folder of the </st><span class="No-Break"><st c="29280">GitHub repo):</st></span></p>
			<pre class="source-code"><st c="29293">
# File: templates/include-paccli-steps.yml
steps:
-  bash:  |
        echo  "Installing  Pac  CLI"
        dotnet  tool  install  --global  Microsoft.PowerApps.CLI.Tool
    displayName:  "Installing  Pac  CLI"</st></pre>			<p><st c="29471">The pipeline file that consumes this template executes it on Linux and then on the Windows agent (</st><span class="No-Break"><st c="29570">see </st></span><span class="No-Break"><strong class="source-inline"><st c="29575">AzDO/.pipelines/azure-pipeline-template.yml</st></strong></span><span class="No-Break"><st c="29618">):</st></span></p>
			<pre class="source-code"><st c="29621">
# File: azure-pipelines.yml
jobs:
- job: Linux
  pool:
    vmImage: 'ubuntu-latest'
  steps:
  - template: templates/include-paccli-steps.yml
- job: Windows
  pool:
    vmImage: 'windows-latest'
  steps:
  - template: templates/include-paccli-steps.yml</st></pre>			<p><st c="29854">We can also parameterize our Azure pipeline template</st><a id="_idIndexMarker677"/><st c="29907"> files, and the caller pipelines can set those parameters according to their </st><span class="No-Break"><st c="29984">customization needs.</st></span></p>
			<p><st c="30004">The same</st><a id="_idIndexMarker678"/><st c="30013"> concept, called </st><strong class="bold"><st c="30030">reusable workflows</st></strong><st c="30048">, is available on GitHub. </st><st c="30074">To make a GitHub workflow reusable, we need to introduce a special trigger condition – </st><strong class="source-inline"><st c="30161">workflow_call</st></strong><st c="30174">. The following reusable workflow installs the Pac CLI on the target platform. </st><st c="30253">The version number of the tool and the target platform are parameters of this flow (</st><span class="No-Break"><st c="30337">see </st></span><span class="No-Break"><strong class="source-inline"><st c="30342">GitHub/.github/workflows/install-paccli.yml</st></strong></span><span class="No-Break"><st c="30385">):</st></span></p>
			<pre class="source-code"><st c="30388">
on:
  workflow_call:
    inputs:
      version:
        required: true
        type: number
      platform:
       required: true
       type: string
       description: "platform"
jobs:
  installpac:
    runs-on: ${{inputs.platform}}
    steps:
     - name: install pac cli
       shell: bash
       run: |
          echo "version number: ${{inputs.version}}"
          dotnet tool install --global Microsoft.PowerApps.CLI.Tool</st></pre>			<p><st c="30713">To call our workflow</st><a id="_idIndexMarker679"/><st c="30734"> from other workflows, we need to create a dedicated job in our </st><em class="italic"><st c="30798">caller</st></em><st c="30804"> GitHub workflows (</st><span class="No-Break"><st c="30823">see </st></span><span class="No-Break"><strong class="source-inline"><st c="30828">GitHub/.github/workflows/Deploy.yml</st></strong></span><span class="No-Break"><st c="30863">):</st></span></p>
			<pre class="source-code"><st c="30866">
name: Call a reusable workflow
on:
  workflow_dispatch:
jobs:
  call-paccli-workflow:
    uses: jovadker/ppmanaged/.github/workflows/install-paccli.yml@main
    with:
      version: 8
      platform: ubuntu-latest
  call-workflow-windows:
    uses: jovadker/ppmanaged/.github/workflows/install-paccli.yml@main
    with:
      version: 8
      platform: windows-latest</st></pre>			<p><st c="31188">The real power of this concept in Azure DevOps and GitHub is that we can place our templates</st><a id="_idIndexMarker680"/><st c="31281"> and reusable workflows in different locations in the same repository, or even in different Git repositories. </st><st c="31391">If we look at the pipelines that we created to spin up developer environments, create service connections, and export/import our solutions from/to environments, respectively, we can now place these templates or reusable workflows in a dedicated Git repository. </st><st c="31652">The different projects and solutions can call our templates by using this reusable concept. </st><st c="31744">Conversely, we can improve and maintain these workflows centrally by reducing the overall effort to manage large numbers </st><span class="No-Break"><st c="31865">of projects.</st></span></p>
			<p><st c="31877">Besides the reusable</st><a id="_idIndexMarker681"/><st c="31898"> workflows, GitHub offers so-called </st><strong class="bold"><st c="31934">GitHub starter workflows</st></strong><st c="31958">. GitHub starter workflows are also templates</st><a id="_idIndexMarker682"/><st c="32003"> that are stored in an organization’s </st><em class="italic"><st c="32041">GitHub repository</st></em><st c="32058">. These templates are displayed when we create a new workflow in the GitHub UI. </st><st c="32138">Upon creating the workflow, the template will be copied to our repository, and with that, we decouple the instance from the template. </st><st c="32272">We can use GitHub starter workflows to help projects set up their workflows, based on our </st><span class="No-Break"><st c="32362">reusable workflows.</st></span></p>
			<p><st c="32381">Now that we understand pipeline templates and reusable workflows, let’s learn about the ALM Accelerator for Power Platform, which heavily uses this concept under </st><span class="No-Break"><st c="32544">the hood.</st></span></p>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor111"/><st c="32553">The ALM Accelerator for Power Platform</st></h1>
			<p><st c="32592">The ALM Accelerator for Power Platform</st><a id="_idIndexMarker683"/><st c="32631"> is a tool that helps developers automate their software development workflows for Power Platform. </st><st c="32730">Although</st><a id="_idIndexMarker684"/><st c="32738"> it is part of the </st><strong class="bold"><st c="32757">Center of Excellence</st></strong><st c="32777"> (</st><strong class="bold"><st c="32779">CoE</st></strong><st c="32782">) </st><strong class="bold"><st c="32785">Starter Kit</st></strong><st c="32796">, which is a collection of components and tools that help organizations get started with Power Platform adoption, it can be installed as a standalone solution in one of our </st><span class="No-Break"><st c="32969">Dataverse environments.</st></span></p>
			<p><st c="32992">The ALM Accelerator includes Azure pipeline templates, Azure pipelines, and Power Platform applications to help professional developers realize DevOps and ALM in their projects. </st><st c="33171">This accelerator package is called the </st><strong class="bold"><st c="33210">ALM Accelerator for Advanced Makers</st></strong><st c="33245"> (</st><strong class="bold"><st c="33247">AA4AM</st></strong><st c="33252">) solution, and it consists of reference</st><a id="_idIndexMarker685"/><st c="33293"> implementations originally developed by the CoE Starter Kit engineering team at Microsoft. </st><st c="33385">After its successful implementation, the team decided to make it open source and available for every organization, proving how healthy application life cycle management can be realized in Power Platform. </st><st c="33589">We can use these pipelines and applications as they are, or we can customize them based on our organizational requirements, and of course, we can learn a lot from the underlying concepts that this team devised a few </st><span class="No-Break"><st c="33805">years ago.</st></span></p>
			<p><st c="33815">We can find comprehensive documentation about the accelerator, how we can install it, how we can create our pipelines based on the available pipeline templates, and how we can manage our Power Platform solutions in Azure </st><span class="No-Break"><st c="34037">DevOps repositories.</st></span></p>
			<p><st c="34057">Branches, environments, and pipeline</st><a id="_idIndexMarker686"/><st c="34094"> templates, as previously discussed in this chapter, are essential to understand how ALM Accelerator works under the hood. </st><st c="34217">The main features</st><a id="_idIndexMarker687"/><st c="34234"> of the accelerator are </st><span class="No-Break"><st c="34258">the following:</st></span></p>
			<ul>
				<li><st c="34272">There is a model-driven app, </st><strong class="bold"><st c="34302">ALM Accelerator for Power Platform Administration</st></strong><st c="34351">, to create and manage</st><a id="_idIndexMarker688"/><st c="34373"> deployment profiles. </st><strong class="bold"><st c="34395">Deployment profiles</st></strong><st c="34414"> describe the CD process</st><a id="_idIndexMarker689"/><st c="34438"> of the solution throughout our environments. </st><st c="34484">It is conceptionally the same as how we define Power Platform managed pipelines. </st><st c="34565">It is recommended to create a deployment profile per Power Platform solution, as the profile also contains information about the Azure DevOps project, Git repository and target branches, and the corresponding Power </st><span class="No-Break"><st c="34780">Platform environments.</st></span></li>
				<li><st c="34802">There is another canvas app, ALM Accelerator for Power Platform, that provides a UI for developers and visualizes the solutions and assigned deployment profiles in the given Power </st><span class="No-Break"><st c="34983">Platform environment.</st></span></li>
				<li><st c="35004">Through the ALM Accelerator for Power Platform canvas app, we can easily create a branch and commit our solution versions (changes) multiple times to </st><span class="No-Break"><st c="35155">this branch.</st></span></li>
				<li><st c="35167">The canvas app provides a way to move our changes through the defined environments. </st><st c="35252">Every deployment (release) is a PR to the parent branch. </st><st c="35309">After completing the PR in Azure DevOps, a pipeline imports the solution to the assigned environment defined in the </st><span class="No-Break"><st c="35425">deployment profile.</st></span></li>
				<li><st c="35444">It is recommended to create one repository per solution. </st><st c="35502">This repository contains our pipelines, utilizing the pipeline templates provided by </st><span class="No-Break"><st c="35587">the accelerator.</st></span></li>
				<li><st c="35603">We can add more environments, and we can create the same branch structure that we discussed at the beginning of </st><span class="No-Break"><st c="35716">this chapter.</st></span></li>
				<li><st c="35729">The canvas app uses custom connectors and calls the REST API endpoints of Azure DevOps Services to interact with the </st><span class="No-Break"><st c="35847">defined pipelines.</st></span></li>
				<li><st c="35865">The </st><strong class="source-inline"><st c="35870">coe-alm-accelerator-templates</st></strong><st c="35899"> GitHub repository contains the pipeline templates that the ALM accelerator also utilizes. </st><st c="35990">We need to fork this repo to our Azure DevOps project as an additional </st><span class="No-Break"><st c="36061">Git repository.</st></span></li>
				<li><st c="36076">We can customize the pipeline templates for our </st><span class="No-Break"><st c="36125">organization’s needs.</st></span></li>
				<li><st c="36146">The ALM Accelerator for Power Platform</st><a id="_idIndexMarker690"/><st c="36185"> is only available for Azure </st><span class="No-Break"><st c="36214">DevOps Services.</st></span></li>
			</ul>
			<p><st c="36230">The following figure shows the ALM Accelerator for Power Platform </st><span class="No-Break"><st c="36297">at work:</st></span></p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/B22208_06_7.jpg" alt="Figure 6.7 – The ALM Accelerator for Power Platform"/><st c="36305"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="37172">Figure 6.7 – The ALM Accelerator for Power Platform</st></p>
			<p><st c="37223">We can see the unmanaged solutions available in the selected environment (developer environments). </st><st c="37323">We can use the </st><strong class="bold"><st c="37338">Commit Solution</st></strong><st c="37353">, </st><strong class="bold"><st c="37355">Deploy Solution</st></strong><st c="37370">, and </st><strong class="bold"><st c="37376">Delete Solution</st></strong><st c="37391"> buttons to trigger our pipelines, commit our changes, or </st><span class="No-Break"><st c="37449">initiate PRs.</st></span></p>
			<p class="callout-heading"><st c="37462">The ALM Accelerator for Power Platform</st></p>
			<p class="callout"><st c="37501">Having observed the extensive flexibility</st><a id="_idIndexMarker691"/><st c="37543"> of the techniques presented earlier in this chapter, as well as the effectiveness of pipelines in managed environments, we should consider the ALM Accelerator for Power Platform as a tool for acquainting ourselves with various design patterns and concepts. </st><st c="37801">These can then be incorporated into our custom Azure DevOps pipelines and, subsequently, our </st><span class="No-Break"><st c="37894">GitHub workflows.</st></span></p>
			<p><st c="37911">Now, we have everything in place to operate and manage a high number of projects and solutions in our organization. </st><st c="38028">One last thing we need to provide to ensure the quality of our applications is </st><span class="No-Break"><strong class="bold"><st c="38107">automated testing</st></strong></span><span class="No-Break"><st c="38124">.</st></span></p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor112"/><st c="38125">Automated testing in DevOps and Power Platform pipelines</st></h1>
			<p><st c="38182">Test automation and automated tests</st><a id="_idIndexMarker692"/><st c="38218"> are essential parts of ALM and DevOps </st><a id="_idIndexMarker693"/><st c="38257">processes. </st><st c="38268">Without automated</st><a id="_idIndexMarker694"/><st c="38285"> tests, we are not able</st><a id="_idIndexMarker695"/><st c="38308"> to share the solutions with other developers, we are not able to work together on solutions as autonomous SCRUM teams, and it is always a great challenge to modify solutions because we cannot know how far our applications can fall into regression. </st><st c="38557">To avoid regression and achieve high test coverage, we need to establish the same quality-assurance processes as in custom development projects. </st><st c="38702">Power Platform provides multiple tools and frameworks to create functional tests for </st><span class="No-Break"><st c="38787">our solutions.</st></span></p>
			<p><strong class="bold"><st c="38801">Power Apps Test Studio</st></strong><st c="38824"> enables you to create comprehensive</st><a id="_idIndexMarker696"/><st c="38860"> end-to-end UI tests for canvas apps, ensuring consistent quality by verifying app performance with each new update or change. </st><st c="38987">Tests can be authored using </st><strong class="bold"><st c="39015">Power Apps expressions </st></strong><st c="39038">(</st><strong class="bold"><st c="39039">Power Fx</st></strong><st c="39047">) or recorded to capture app</st><a id="_idIndexMarker697"/><st c="39076"> interactions, which are then translated into expressions automatically. </st><st c="39149">These tests can be executed within Test Studio, where a playback URL is available, to check app functionality, and they are also runnable in a web browser. </st><st c="39305">These tests can be even built into our app deployment process to be automated</st><a id="_idIndexMarker698"/><st c="39382"> with Azure pipelines. </st><st c="39405">Power Apps Studio uses the same terms</st><a id="_idIndexMarker699"/><st c="39442"> and definitions that Azure DevOps Services defines for test automation. </st><strong class="bold"><st c="39515">Test cases</st></strong><st c="39525"> contain a series of</st><a id="_idIndexMarker700"/><st c="39545"> instructions or actions, called </st><strong class="bold"><st c="39578">test steps</st></strong><st c="39588">, which are developed</st><a id="_idIndexMarker701"/><st c="39609"> using the Power Apps</st><a id="_idIndexMarker702"/><st c="39630"> expression language (</st><strong class="bold"><st c="39652">Power Fx language</st></strong><st c="39670">). </st><strong class="bold"><st c="39674">Test expressions</st></strong><st c="39690"> can use the functions</st><a id="_idIndexMarker703"/><st c="39712"> that we created in our application (such as clicking on a button) and some additional automated test-related functions, such as </st><strong class="source-inline"><st c="39841">Select</st></strong><st c="39847">, </st><strong class="source-inline"><st c="39849">SetProperty</st></strong><st c="39860">, </st><strong class="source-inline"><st c="39862">Assert</st></strong><st c="39868">, and </st><strong class="source-inline"><st c="39874">Trace</st></strong><st c="39879">. Test expressions build up test cases. </st><strong class="bold"><st c="39919">Test suites</st></strong><st c="39930"> are containers for </st><strong class="bold"><st c="39950">our test cases</st></strong><st c="39964">, which we use to execute</st><a id="_idIndexMarker704"/><st c="39989"> our test steps in a hierarchical order. </st><st c="40030">Another term that we often use</st><a id="_idIndexMarker705"/><st c="40060"> in test automation is </st><strong class="bold"><st c="40083">test assertion</st></strong><st c="40097">. This refers to test expressions that are evaluated to be </st><strong class="source-inline"><st c="40156">true</st></strong><st c="40160"> or </st><strong class="source-inline"><st c="40164">false</st></strong><st c="40169"> in the test. </st><st c="40183">If the assertion returns </st><strong class="source-inline"><st c="40208">false</st></strong><st c="40213">, the test </st><span class="No-Break"><st c="40224">case fails.</st></span></p>
			<p><st c="40235">Tests created with Power Apps Test Studio can be executed by Azure pipelines. </st><st c="40314">The step-by-step guide available in the </st><em class="italic"><st c="40354">Further reading</st></em><st c="40369"> section (</st><em class="italic"><st c="40379">Automate tests with Azure DevOps Pipelines</st></em><st c="40422">) uses the test’s playback URL as input for the automated test execution. </st><st c="40497">The repository available under </st><a href="https://github.com/microsoft/PowerAppsTestAutomation"><st c="40528">https://github.com/microsoft/PowerAppsTestAutomation</st></a><st c="40580"> provides an </st><strong class="bold"><st c="40593">MSTest</st></strong><st c="40599"> project</st><a id="_idIndexMarker706"/><st c="40607"> that wraps the execution of our playback URL. </st><st c="40654">It is one particular </st><strong class="source-inline"><st c="40675">MSTest</st></strong><st c="40681"> test method that uses </st><strong class="bold"><st c="40704">Selenium WebDriver</st></strong><st c="40722"> under the hood to navigate</st><a id="_idIndexMarker707"/><st c="40749"> the browser to the playback URL, log in on behalf of the configured user (no multi-factor authentication is supported), and then wait for the test execution results. </st><st c="40916">The WebDriver is also used to execute the </st><strong class="source-inline"><st c="40958">AppMagic.TestStudio.GetTestExecutionInfo()</st></strong> <strong class="bold"><st c="41000">JavaScript</st></strong><st c="41011"> (</st><strong class="bold"><st c="41013">JS</st></strong><st c="41015">) method in the context of Power Apps Test Studio to get the test results directly from the browser. </st><st c="41117">The </st><strong class="source-inline"><st c="41121">MSTest</st></strong><st c="41127"> test method then succeeds or fails, based on these results. </st><st c="41188">The result of the test method is also written back to our Azure pipeline, and we can see the test result directly in Azure DevOps Services </st><span class="No-Break"><st c="41327">build results.</st></span></p>
			<p><strong class="bold"><st c="41341">Power Apps Test Engine</st></strong><st c="41364"> is the newest approach to test PowerApps</st><a id="_idIndexMarker708"/><st c="41405"> canvas apps, using a Playwright-based engine. </st><strong class="bold"><st c="41452">Playwright</st></strong><st c="41462"> won popularity with its stability</st><a id="_idIndexMarker709"/><st c="41496"> and performance, easy setup, unified API for Chromium, Firefox, and WebKit, and official bindings for JavaScript, Python, and C#. </st><st c="41627">Playwright was originally developed by Microsoft, and it has been open sourced and released for </st><span class="No-Break"><st c="41723">community contributions.</st></span></p>
			<p><st c="41747">PowerApps Test Engine allows us to write tests in the YAML format using the intuitive Power Fx language, with a </st><strong class="bold"><st c="41860">Document Object Model</st></strong><st c="41881"> (</st><strong class="bold"><st c="41883">DOM</st></strong><st c="41886">) abstraction that permits the crafting of tests</st><a id="_idIndexMarker710"/><st c="41935"> using references to control names established during the design phase. </st><st c="42007">This approach means that test authors are not required to possess</st><a id="_idIndexMarker711"/><st c="42072"> JS knowledge</st><a id="_idIndexMarker712"/><st c="42085"> or familiarity with the browser DOM related</st><a id="_idIndexMarker713"/><st c="42129"> to the app’s visual output. </st><st c="42158">The following YAML file</st><a id="_idIndexMarker714"/><st c="42181"> shows such </st><span class="No-Break"><st c="42193">an example:</st></span></p>
			<pre class="source-code"><st c="42204">
testSuite:
   testSuiteName: Regression test suite
   testSuiteDescription: ''
   persona: User1
   appLogicalName: vadkerti_contentgenerator_48e05
   appId: ''
   onTestCaseStart: ""
   onTestCaseComplete: ""
   onTestSuiteComplete: ""
   networkRequestMocks:
   testCases:
   - testCaseName: Test with empty input
      testCaseDescription: ''
      testSteps: |
         =
         SetProperty(Prompt.Text, "Writing some test");
         Select(SystemPrompt);
         SetProperty(Prompt.Text, "");
         Select(SystemPrompt);
         Select(Prompt);
         Select(Button4);
         Assert(IsMatch(TextInput4.Text, "I'm sorry, I'm not sure what you are asking. </st><st c="42759">Can you please provide more context or clarify your question?&lt;|im_end|&gt;"), "Different output");
testSettings:
   filePath:
   browserConfigurations:
   - browser: Chromium
      device:
      screenWidth: 0
      screenHeight: 0
   locale: en-US
   recordVideo: true
   headless: true
   enablePowerFxOverlay: false
   timeout: 30000
environmentVariables:
   filePath:
   users:
   - personaName: User1
      emailKey: user1Email
      passwordKey: user1Password</st></pre>			<p><st c="43158">We can download this YAML file</st><a id="_idIndexMarker715"/><st c="43189"> from Power Apps Test Studio</st><a id="_idIndexMarker716"/><st c="43217"> and import</st><a id="_idIndexMarker717"/><st c="43228"> it into our</st><a id="_idIndexMarker718"/><st c="43240"> PowerApps </st><span class="No-Break"><st c="43251">Test Engine.</st></span></p>
			<p><st c="43263">Test Engine also supports </st><strong class="bold"><st c="43290">connector mocking</st></strong><st c="43307">, allowing us to create mocks</st><a id="_idIndexMarker719"/><st c="43336"> around the surrounding connectors and connections used in our application. </st><st c="43412">As such, we can test our applications isolated from third-party production services. </st><st c="43497">Furthermore, Test Engine supports screenshots and video recording, enabling us to take screenshots at any time of the test execution and document the test sequence through video recordings, which can be instrumental in troubleshooting unsuccessful tests and analyzing the actual user experience of the test scenario that did </st><span class="No-Break"><st c="43822">not pass.</st></span></p>
			<p><st c="43831">Other well-known tools that we can call during the pipeline executions, with the help of the Pac CLI</st><a id="_idIndexMarker720"/><st c="43932"> and PowerShell modules, are the </st><strong class="bold"><st c="43965">SolutionChecker</st></strong><st c="43980"> for solutions and the </st><strong class="source-inline"><st c="44003">AppChecker</st></strong><st c="44013"> (</st><strong class="source-inline"><st c="44015">pac solution check</st></strong><st c="44033">) for </st><span class="No-Break"><st c="44040">canvas apps.</st></span></p>
			<p><st c="44052">When testing </st><strong class="bold"><st c="44066">Microsoft Copilot Studio</st></strong><st c="44090">, we can use the </st><strong class="bold"><st c="44107">PVA Test Framework</st></strong><st c="44125">, a sample solution that</st><a id="_idIndexMarker721"/><st c="44149"> can be found </st><a id="_idIndexMarker722"/><st c="44163">on GitHub. </st><st c="44174">It demonstrates how to run tests on a Microsoft Copilot Studio chatbot using APIs and the Direct Line channel. </st><st c="44285">The framework confirms that the bot functions</st><a id="_idIndexMarker723"/><st c="44330"> as intended in a variety of situations, including</st><a id="_idIndexMarker724"/> <span class="No-Break"><st c="44380">the following:</st></span></p>
			<ul>
				<li><st c="44395">Testing the natural language understanding model to trigger the </st><span class="No-Break"><st c="44460">right topics.</st></span></li>
				<li><st c="44473">Validating the options for multiple matched topics (“</st><em class="italic"><st c="44527">did you mean…</st></em><st c="44541">” question is raised by the copilot if the user intent </st><span class="No-Break"><st c="44597">is ambiguous)</st></span></li>
				<li><st c="44610">Conducting load testing </st><span class="No-Break"><st c="44635">at scale</st></span></li>
				<li><st c="44643">Testing complete </st><span class="No-Break"><st c="44661">end-to-end conversations</st></span></li>
				<li><st c="44685">Testing the functionality of </st><span class="No-Break"><st c="44715">adaptive cards</st></span></li>
				<li><st c="44729">Including a test step in the CI/CD deployment pipeline to prevent deployment if </st><span class="No-Break"><st c="44810">tests fail</st></span></li>
			</ul>
			<p><st c="44820">We can create </st><strong class="bold"><st c="44835">conversational scripts</st></strong><st c="44857"> manually, or we can use</st><a id="_idIndexMarker725"/><st c="44881"> the PVA Test Framework</st><a id="_idIndexMarker726"/><st c="44904"> to export existing conversations from Dataverse</st><a id="_idIndexMarker727"/><st c="44952"> in the </st><em class="italic"><st c="44960">CHAT format</st></em><st c="44971">. We can then convert these CHAT files to JSON with the help of the PVA Test Framework and let them execute against the Direct Line REST API endpoints. </st><st c="45123">The framework can be easily integrated into our Azure pipelines and GitHub workflows, since it is a .NET 6 console app that can run on Windows-based </st><span class="No-Break"><st c="45272">hosted agents.</st></span></p>
			<p><st c="45286">To test </st><strong class="bold"><st c="45295">model-driven Power Apps</st></strong><st c="45318"> and </st><strong class="bold"><st c="45323">Power Pages websites</st></strong><st c="45343">, we can use other</st><a id="_idIndexMarker728"/><st c="45361"> web test</st><a id="_idIndexMarker729"/><st c="45370"> frameworks, such as </st><span class="No-Break"><st c="45391">the following:</st></span></p>
			<ul>
				<li><st c="45405">The </st><strong class="bold"><st c="45410">Selenium Test Framework</st></strong><st c="45433"> is a suite of automation</st><a id="_idIndexMarker730"/><st c="45458"> testing tools that allows developers to create robust, browser-based regression automation suites and tests. </st><st c="45568">It can scale and distribute scripts across many environments and supports a wide range of </st><span class="No-Break"><st c="45658">programming languages.</st></span></li>
				<li><st c="45680">Playwright is a cross-browser, cross-platform, and cross-language </st><a id="_idIndexMarker731"/><st c="45747">tool for reliable end-to-end testing of web apps. </st><st c="45797">It supports all modern rendering engines, native mobile emulation, auto-wait, web-first assertions, tracing, and full isolation. </st><st c="45926">Playwright interacts with browsers using its </st><span class="No-Break"><st c="45971">own API.</st></span></li>
				<li><strong class="bold"><st c="45979">Appium.io for mobile application testing</st></strong><st c="46020">: Appium is a freely available, open source</st><a id="_idIndexMarker732"/><st c="46064"> software suite and ecosystem, engineered to facilitate user interface automation across a wide array of application platforms. </st><st c="46192">This includes mobile OSes (iOS, Android, and Tizen), web browsers (Chrome, Firefox, and Safari), desktop environments (macOS and Windows), and television OSes (Roku, tvOS, Android TV, and Samsung). </st><st c="46390">Its goal is to enable the automation of any mobile application, irrespective of the programming language or testing</st><a id="_idIndexMarker733"/><st c="46505"> framework used, granting</st><a id="_idIndexMarker734"/><st c="46530"> complete access to backend </st><strong class="bold"><st c="46558">application programming interfaces</st></strong><st c="46592"> (</st><strong class="bold"><st c="46594">APIs</st></strong><st c="46598">) and </st><strong class="bold"><st c="46605">databases</st></strong><st c="46614"> (</st><strong class="bold"><st c="46616">DBs</st></strong><st c="46619">) within the </st><span class="No-Break"><st c="46633">test scripts.</st></span></li>
				<li><st c="46646">Cypress is a JavaScript-based, end-to-end testing</st><a id="_idIndexMarker735"/><st c="46696"> framework built on Mocha. </st><st c="46723">It is designed to simplify the process of setting up, writing, running, and debugging tests for web applications. </st><st c="46837">Cypress tests anything that runs in a web browser and is built to handle modern JavaScript frameworks especially well. </st><st c="46956">Some of the key advantages of Cypress include faster and more reliable tests, reduced flakiness, dashboard support for detailed reporting, parallel</st><a id="_idIndexMarker736"/><st c="47103"> test </st><a id="_idIndexMarker737"/><st c="47109">execution, and support for </st><strong class="bold"><st c="47136">behavior-driven development</st></strong><st c="47163"> (</st><strong class="bold"><st c="47165">BDD</st></strong><st c="47168">) and </st><strong class="bold"><st c="47175">test-driven development</st></strong><st c="47198"> (</st><span class="No-Break"><strong class="bold"><st c="47200">TDD</st></strong></span><span class="No-Break"><st c="47203">) testing.</st></span></li>
				<li><st c="47214">JMeter is an open source tool developed</st><a id="_idIndexMarker738"/><st c="47254"> by the Apache Software Foundation for load-testing and analyzing the performance of a variety of services. </st><st c="47362">JMeter is written in Java and can be used to test the performance and functional behavior of various applications and protocols, such </st><a id="_idIndexMarker739"/><st c="47496">as </st><strong class="bold"><st c="47499">HTTP</st></strong><st c="47503"> (</st><strong class="bold"><st c="47505">Hypertext Transfer Protocol</st></strong><st c="47532">), </st><strong class="bold"><st c="47536">SOAP</st></strong><st c="47540"> (</st><strong class="bold"><st c="47542">Simple Object Access Protocol</st></strong><st c="47571">), </st><strong class="bold"><st c="47575">FTP</st></strong><st c="47578"> (</st><strong class="bold"><st c="47580">File Transfer Protocol</st></strong><st c="47602">), and </st><strong class="bold"><st c="47610">LDAP</st></strong><st c="47614"> (</st><strong class="bold"><st c="47616">Lightweight Directory Access Protocol</st></strong><st c="47653">). </st><st c="47657">It</st><a id="_idIndexMarker740"/><st c="47659"> offers</st><a id="_idIndexMarker741"/><st c="47666"> a </st><a id="_idIndexMarker742"/><st c="47669">full-featured IDE, a dynamic HTML report, a multithreaded framework, and a highly extensible core with pluggable samplers </st><span class="No-Break"><st c="47791">and plugins.</st></span></li>
			</ul>
			<p><st c="47803">Testing Power Automate cloud flows and desktop flows is a more complex engineering challenge than executing UI-automated tests in browsers or on mobile devices. </st><st c="47965">At the time of writing, there is no recommended framework to realize integration and system tests against our cloud and desktop flows. </st><st c="48100">Since these components are considered as part of the business logic layer, we can test them through the UI components in front of them, as </st><span class="No-Break"><st c="48239">end-to-end tests.</st></span></p>
			<p><st c="48256">Conversely, we can provide partial solutions to test HTTP-triggered and Webhook-triggered cloud flows, by calling their corresponding REST API endpoints and comparing their results with what </st><span class="No-Break"><st c="48448">we expect.</st></span></p>
			<p><st c="48458">As we learned in </st><a href="B22208_05.xhtml#_idTextAnchor089"><span class="No-Break"><em class="italic"><st c="48476">Chapter 5</st></em></span></a><st c="48485">, </st><strong class="bold"><st c="48487">Power Platform-managed pipelines</st></strong><st c="48519"> provide multiple hooks to test</st><a id="_idIndexMarker743"/><st c="48550"> deployment before, during, and after any deployment stages. </st><st c="48611">The </st><strong class="source-inline"><st c="48615">OnDeploymentCompleted</st></strong><st c="48636"> event can be used to test our solution after it is deployed</st><a id="_idIndexMarker744"/><st c="48696"> to the target environment, represented as a deployment</st><a id="_idIndexMarker745"/><st c="48751"> stage. </st><st c="48759">Our Power Automate</st><a id="_idIndexMarker746"/><st c="48777"> cloud flows, as the event handlers</st><a id="_idIndexMarker747"/><st c="48812"> of this event, can call Azure pipelines or GitHub workflows to execute code-first, pro-development test automation scripts (similar to how we called GitHub workflows in </st><a href="B22208_05.xhtml#_idTextAnchor089"><span class="No-Break"><em class="italic"><st c="48982">Chapter 5</st></em></span></a><st c="48991">) to commit our solution to a Git repository. </st><st c="49038">The next deployment stage’s pre-approval gate (</st><strong class="source-inline"><st c="49085">OnApprovalStarted</st></strong><st c="49103"> or </st><strong class="source-inline"><st c="49107">OnPredeploymentStarted</st></strong><st c="49129">) can then check the results of the test execution in the previous environment. </st><st c="49210">If the tests pass, deployment to the next environment </st><span class="No-Break"><st c="49264">can continue.</st></span></p>
			<p><st c="49277">Finally, we can use other</st><a id="_idIndexMarker748"/><st c="49303"> Microsoft Azure services, such as the </st><strong class="bold"><st c="49342">Azure Load Testing </st></strong><st c="49361">service, to execute a </st><strong class="bold"><st c="49383">JMeter</st></strong><st c="49389"> test against our</st><a id="_idIndexMarker749"/><st c="49406"> Power Platform solutions. </st><st c="49433">JMeter also provides recording capabilities, and the Azure Load Testing service can be used to mimic hundreds of parallel users simultaneously interacting with </st><span class="No-Break"><st c="49593">our applications.</st></span></p>
			<p><st c="49610">Based on the kind of solution, we need to choose a testing tool with the right depth and breadth. </st><st c="49709">The more business- or mission-critical applications we need to design and deliver, the more time we should invest and spend on this </st><span class="No-Break"><st c="49841">DevOps discipline.</st></span></p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor113"/><st c="49859">Summary</st></h1>
			<p><st c="49867">In this chapter, we explored the advanced patterns of DevOps CI/CD processes and learned how to establish a robust branching strategy that reflects the development, testing, and production environments of our solutions. </st><st c="50088">We examined numerous examples of automating branch creation, spinning up Power Platform environments with service connections, and importing and exporting solutions using various Pac </st><span class="No-Break"><st c="50271">CLI-based scripts.</st></span></p>
			<p><st c="50289">We also delved into the Power Platform catalog as the package management solution for Power Platform. </st><st c="50392">Additionally, we learned about the ALM Accelerator for Power Platform and how this solution uses pipeline templates, a branching strategy, and environment management. </st><st c="50559">Finally, we became familiar with the test automation frameworks that can be used with Power </st><span class="No-Break"><st c="50651">Platform solutions.</st></span></p>
			<p><st c="50670">In the next chapter, we will take another step forward and learn about the implementation of DevSecOps processes on </st><span class="No-Break"><st c="50787">Power Platform.</st></span></p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor114"/><st c="50802">Further reading</st></h1>
			<ul>
				<li><st c="50818">The </st><strong class="source-inline"><st c="50823">az devops</st></strong> <span class="No-Break"><st c="50832">CLI: </st></span><a href="https://learn.microsoft.com/en-us/cli/azure/devops?view=azure-cli-latest"><span class="No-Break"><st c="50838">https://learn.microsoft.com/en-us/cli/azure/devops?view=azure-cli-latest</st></span></a></li>
				<li><st c="50910">Windows Subsystem for </st><span class="No-Break"><st c="50933">Linux: </st></span><a href="https://learn.microsoft.com/en-us/training/modules/wsl-introduction/"><span class="No-Break"><st c="50940">https://learn.microsoft.com/en-us/training/modules/wsl-introduction/</st></span></a></li>
				<li><st c="51008">Azure DevOps approval </st><span class="No-Break"><st c="51031">flow: </st></span><a href="https://learn.microsoft.com/en-us/azure/devops/pipelines/process/approvals?view=azure-devops&amp;tabs=check-pass"><span class="No-Break"><st c="51037">https://learn.microsoft.com/en-us/azure/devops/pipelines/process/approvals?view=azure-devops&amp;tabs=check-pass</st></span></a></li>
				<li><st c="51145">The Power Platform </st><span class="No-Break"><st c="51165">catalog: </st></span><a href="https://learn.microsoft.com/en-us/power-platform/developer/catalog"><span class="No-Break"><st c="51174">https://learn.microsoft.com/en-us/power-platform/developer/catalog</st></span></a></li>
				<li><st c="51240">Azure DevOps pipeline </st><span class="No-Break"><st c="51263">templates: </st></span><a href="https://learn.microsoft.com/en-us/azure/devops/pipelines/process/templates?view=azure-devops&amp;pivots=templates-includes"><span class="No-Break"><st c="51274">https://learn.microsoft.com/en-us/azure/devops/pipelines/process/templates?view=azure-devops&amp;pivots=templates-includes</st></span></a></li>
				<li><st c="51392">GitHub starter </st><span class="No-Break"><st c="51408">flows: </st></span><a href="https://docs.github.com/en/actions/using-workflows/creating-starter-workflows-for-your-organization"><span class="No-Break"><st c="51415">https://docs.github.com/en/actions/using-workflows/creating-starter-workflows-for-your-organization</st></span></a></li>
				<li><st c="51514">GitHub reusable </st><span class="No-Break"><st c="51531">workflows: </st></span><a href="https://docs.github.com/en/actions/using-workflows/reusing-workflows"><span class="No-Break"><st c="51542">https://docs.github.com/en/actions/using-workflows/reusing-workflows</st></span></a></li>
				<li><st c="51610">The ALM Accelerator for Power </st><span class="No-Break"><st c="51641">Platform: </st></span><a href="https://learn.microsoft.com/en-us/power-platform/guidance/alm-accelerator/overview"><span class="No-Break"><st c="51651">https://learn.microsoft.com/en-us/power-platform/guidance/alm-accelerator/overview</st></span></a></li>
				<li><st c="51733">The source code of ALM </st><span class="No-Break"><st c="51757">Accelerator: </st></span><a href="https://github.com/microsoft/coe-starter-kit/tree/main/CenterofExcellenceALMAccelerator"><span class="No-Break"><st c="51770">https://github.com/microsoft/coe-starter-kit/tree/main/CenterofExcellenceALMAccelerator</st></span></a></li>
				<li><st c="51857">ALM Accelerator Pipeline </st><span class="No-Break"><st c="51883">templates: </st></span><a href="https://github.com/microsoft/coe-alm-accelerator-templates/tree/main"><span class="No-Break"><st c="51894">https://github.com/microsoft/coe-alm-accelerator-templates/tree/main</st></span></a></li>
				<li><st c="51962">Power Apps Test </st><span class="No-Break"><st c="51979">Studio: </st></span><a href="https://docs.microsoft.com/en-us/powerapps/maker/canvas-apps/test-studio"><span class="No-Break"><st c="51987">https://docs.microsoft.com/en-us/powerapps/maker/canvas-apps/test-studio</st></span></a></li>
				<li><st c="52059">Visual Studio Unit </st><span class="No-Break"><st c="52079">testing: </st></span><a href="https://learn.microsoft.com/en-us/visualstudio/test/getting-started-with-unit-testing?view=vs-2022&amp;tabs=dotnet%2Cmstest"><span class="No-Break"><st c="52088">https://learn.microsoft.com/en-us/visualstudio/test/getting-started-with-unit-testing?view=vs-2022&amp;tabs=dotnet%2Cmstest</st></span></a></li>
				<li><st c="52207">Automate tests with Azure DevOps </st><span class="No-Break"><st c="52241">Pipelines: </st></span><a href="https://docs.microsoft.com/en-us/powerapps/maker/canvas-apps/test-studio-classic-pipeline-editor"><span class="No-Break"><st c="52252">https://docs.microsoft.com/en-us/powerapps/maker/canvas-apps/test-studio-classic-pipeline-editor</st></span></a></li>
				<li><st c="52348">PowerApps Test </st><span class="No-Break"><st c="52364">Engine: </st></span><a href="https://learn.microsoft.com/en-us/power-apps/developer/test-engine/overview"><span class="No-Break"><st c="52372">https://learn.microsoft.com/en-us/power-apps/developer/test-engine/overview</st></span></a></li>
				<li><st c="52447">The Azure Load Testing </st><span class="No-Break"><st c="52471">service: </st></span><a href="https://learn.microsoft.com/en-us/azure/load-testing/overview-what-is-azure-load-testing"><span class="No-Break"><st c="52480">https://learn.microsoft.com/en-us/azure/load-testing/overview-what-is-azure-load-testing</st></span></a></li>
				<li><st c="52568">Microsoft Copilot Studio test </st><span class="No-Break"><st c="52599">framework: </st></span><a href="https://powervirtualagents.microsoft.com/en-us/blog/automate-testing-of-your-power-virtual-agents-chatbots-with-the-pva-test-framework-sample-solution/"><span class="No-Break"><st c="52610">https://powervirtualagents.microsoft.com/en-us/blog/automate-testing-of-your-power-virtual-agents-chatbots-with-the-pva-test-framework-sample-solution/</st></span></a></li>
				<li><st c="52761">Microsoft Copilot Studio Implementation </st><span class="No-Break"><st c="52802">Guide: </st></span><a href="https://aka.ms/CopilotStudioImplementationGuide"><span class="No-Break"><st c="52809">https://aka.ms/CopilotStudioImplementationGuide</st></span></a></li>
			</ul>
		</div>
	<div id="charCountTotal" value="52856"/></body></html>