<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer015">
			<h1 id="_idParaDest-133"><a id="_idTextAnchor289"/>Chapter <a id="_idTextAnchor290"/>4: Filesystem Interactions</h1>
			<p>A fundamental part of any developer's life is interacting with <strong class="bold">files</strong>. They represent data that must be processed and configured for our systems, cached items can be served, and many other uses.</p>
			<p>One of Go's strongest features is its abstraction of <strong class="bold">file interfaces</strong>, which allows a common set of tools to interact with streams of data from disks and networks. These interfaces set a common standard that all major packages use to export their data streams. Moving from one to another just becomes an exercise in accessing the <strong class="bold">filesystem</strong> with the necessary credentials.</p>
			<p>Packages related to specific data formats, such as CSV, JSON, YAML, TOML, and XML, build on these common file interfaces. These packages use the interfaces defined by the standard library to read these types of files from disk or HTTP streams. </p>
			<p>Because Go is multiplatform, you may want to write software that can work on different OSs. Go provides packages that allow you to detect the OS and its packages to handle differences in OS pathing.</p>
			<p>In this chapter, we are going to cover the following topics:</p>
			<ul>
				<li>All I/O in Go are files</li>
				<li>Reading and writing to files</li>
				<li>Streaming file content</li>
				<li>OS-agnostic pathing</li>
				<li>OS-agnostic filesystems</li>
			</ul>
			<p>After completing this chapter, you should have a set of skills for interacting with data that's stored in a wide variety of mediums, which will be useful in your everyday life as a DevOps engineer.</p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor291"/>All I/O in Go are files</h1>
			<p>Go provides an <strong class="bold">input-output</strong> (<strong class="bold">I/O</strong>) system based on files. This should come as no surprise since Go is the <a id="_idIndexMarker372"/>brainchild of two prominent engineers, Rob Pike and Ken Thompson, who, while at <em class="italic">Bell Labs</em>, designed the UNIX and Plan 9 operating systems – both of which treat (almost) everything as a file.</p>
			<p>Go provides the <strong class="source-inline">io</strong> package, which contains interfaces to interact with I/O primitives such as disk files, remote files, and network services.<a id="_idTextAnchor292"/></p>
			<h2 id="_idParaDest-135"><a id="_idTextAnchor293"/>I/O interfaces</h2>
			<p>The basic block of I/O is <strong class="source-inline">byte</strong>, an 8-bit value. I/O uses streams of bytes to allow you to read and write. With some I/Os, you <a id="_idIndexMarker373"/>can only read from beginning to end as you process the stream (such as network I/O). Some I/Os, such as disks, allow you to <em class="italic">seek</em> something in the file. </p>
			<p>Some common operations that we perform when we interact with a byte stream include reading, writing, seeking a location in a byte stream, and closing a stream when we have finished our work.</p>
			<p>Go provides the following interfaces for these basic operations:</p>
			<p class="source-code">// Read from an I/O stream.</p>
			<p class="source-code">type Reader interface {</p>
			<p class="source-code">     Read(p []byte) (n int, err error)</p>
			<p class="source-code">}</p>
			<p class="source-code">// Write to an I/O stream.</p>
			<p class="source-code">type Writer interface {</p>
			<p class="source-code">     Write(p []byte) (n int, err error)</p>
			<p class="source-code">}</p>
			<p class="source-code">// Seek to a certain spot in the I/O stream.</p>
			<p class="source-code">type Seeker interface {</p>
			<p class="source-code">     Seek(offset int64, whence int) (int64, error)</p>
			<p class="source-code">}</p>
			<p class="source-code">// Close the I/O stream.</p>
			<p class="source-code">type Closer interface {</p>
			<p class="source-code">     Close() error</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">io</strong> package also contains composite interfaces such as <strong class="source-inline">ReadWriter</strong> and <strong class="source-inline">ReadWriteCloser</strong>. These interfaces are common in packages that allow you to interact with files or <a id="_idIndexMarker374"/>networks. These interfaces allow you to use common tooling that uses these interfaces, regardless of what is underneath (such as a local filesystem, remote filesystem, or an HTTP connection).</p>
			<p>In this section, we have learned that Go file interaction is based on the <strong class="source-inline">[]byte</strong> type and introduced the basic interfaces for I/O. Next, we will learn about reading and writing files using methods that utilize these interface<a id="_idTextAnchor294"/>s.</p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor295"/>Reading and writing to files</h1>
			<p>The most common scenario in DevOps tooling is the need to manipulate files: <em class="italic">reading</em>, <em class="italic">writing</em>, <em class="italic">reformatting</em>, or <em class="italic">analyzing</em> the data in those files. These files could be in many formats – JSON, YAML, XML, CSV, and others that are probably familiar to you. They are used to configure both local services and to interact with your cloud network provider.</p>
			<p>In this section, we will cover the basics of reading and writing entire file<a id="_idTextAnchor296"/>s.</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor297"/>Reading local files</h2>
			<p>Let's start by reading a <a id="_idIndexMarker375"/>configuration file on a local disk by using the <strong class="source-inline">os.Readfile()</strong> function:</p>
			<p class="source-code">data, err := os.ReadFile("path/to/file")</p>
			<p>The <strong class="source-inline">ReadFile()</strong> method reads the location from its function parameter and returns that file's content. That return value is then stored in the data variable. An error is returned if the file cannot be read. For a refresher on errors, see the <em class="italic">Handling errors in Go</em> section in <a href="B17626_02.xhtml#_idTextAnchor166"><em class="italic">Chapter 2</em></a>, <em class="italic">Go Language Essentials</em>.</p>
			<p><strong class="source-inline">ReadFile()</strong> is a helper function that calls <strong class="source-inline">os.Open()</strong> and retrieves an <strong class="source-inline">io.Reader</strong>. The <strong class="source-inline">io.ReadAll()</strong> function is used to read the entire content of <strong class="source-inline">io.Reader</strong>.</p>
			<p><strong class="source-inline">data</strong> is of the <strong class="source-inline">[]byte</strong> type, so if you would like to use it as a <strong class="source-inline">string</strong>, you can simply convert it into one by using <strong class="source-inline">s := string(data)</strong>. This is called <em class="italic">type conversion</em>, where we convert from <a id="_idIndexMarker376"/>one type into another. In Go, you can only convert certain types from one into another. The full list of conversion rules can be found at <a href="https://golang.org/ref/spec#Conversions.strings">https://golang.org/ref/spec#Conversions.strings</a> can be converted back into bytes with <strong class="source-inline">b := []byte(s)</strong>. Most other types require a package called <strong class="source-inline">strconv</strong> to be <a id="_idIndexMarker377"/>converted into strings (<a href="https://pkg.go.dev/strconv">https://pkg.go.dev/strconv</a>).</p>
			<p>If the data that's represented in the file is of a common format such as JSON or YAML, then we can retrieve and write that data efficie<a id="_idTextAnchor298"/>ntly.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor299"/>Writing local files</h2>
			<p>The most common <a id="_idIndexMarker378"/>way to write to local disk is by using <strong class="source-inline">os.Writefile()</strong>. This writes a complete file to disk. <strong class="source-inline">WriteFile</strong> will create the file if necessary and truncate the file if it exists:</p>
			<p class="source-code">if err := os.WriteFile(“path/to/fi”, data, 0644); err != nil {</p>
			<p class="source-code">     return err</p>
			<p class="source-code">}</p>
			<p>The preceding code writes data to <strong class="source-inline">path/to/fi</strong> with Unix-like permissions, <strong class="source-inline">0644</strong>. If you have not seen Unix-like permissions before, a quick internet search will help you with these. </p>
			<p>If your data is stored in a <strong class="source-inline">string</strong>, you can simply convert it into<strong class="source-inline">[]byte</strong> by doing<strong class="source-inline">[]byte(data)</strong>. <strong class="source-inline">WriteFile()</strong> is a wrapper around <strong class="source-inline">os.OpenFile()</strong> that handles file flags and modes for you while closing the file after the write is com<a id="_idTextAnchor300"/>plete.</p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor301"/>Reading remote files</h2>
			<p>The way the remote file is read is <a id="_idIndexMarker379"/>going to be implementation-dependent. However, these concepts will still be built on the <strong class="source-inline">io</strong> interfaces we discussed earlier.</p>
			<p>For example, let's say that we want to connect to a text file that is stored on an HTTP server, to collect common text-formatted information such as application metrics. We can connect to that server and retrieve the file in a way that's very similar to what was shown in the preceding example:</p>
			<p class="source-code">client := &amp;http.Client{}</p>
			<p class="source-code">req, err := http.NewRequest("GET", "http://myserver.mydomain/myfile", nil)</p>
			<p class="source-code">if err != nil {</p>
			<p class="source-code">        return err</p>
			<p class="source-code">}</p>
			<p class="source-code">req = req.WithContext(ctx) </p>
			<p class="source-code">resp, err := client.Do(req) </p>
			<p class="source-code">cancel()</p>
			<p class="source-code">if err != nil {</p>
			<p class="source-code">        return err</p>
			<p class="source-code">}</p>
			<p class="source-code">// resp contains an io.ReadCloser that we can read as a file. </p>
			<p class="source-code">// Let's use io.ReadAll() to read the entire content to data. </p>
			<p class="source-code">data, err := io.ReadAll(resp.Body) </p>
			<p>As you can see, the setup to get our <strong class="source-inline">io.ReadCloser</strong> depends on our I/O target, but what it returns is just an interface from the <strong class="source-inline">io</strong> package that we can use with any function that supports those interfaces. </p>
			<p>Because it uses <strong class="source-inline">io</strong> interfaces, we can do slick things such as stream the content directly to a local file instead of <a id="_idIndexMarker380"/>copying the entire file into memory and writing it to disk. This is faster and more memory efficient as each chunk that is read is then immediately written to disk.</p>
			<p>Let's use <strong class="source-inline">os.OpenFile()</strong> to open a file for writing and stream the content from the web server into the file:</p>
			<p class="source-code">flags := os.O_CREATE|os.O_WRONLY|os.O_TRUNC</p>
			<p class="source-code">f, err := os.OpenFile("path/to/file", flags, 0644)</p>
			<p class="source-code">if err != nil {</p>
			<p class="source-code">     return err</p>
			<p class="source-code">}</p>
			<p class="source-code">defer f.Close() </p>
			<p class="source-code">if err := io.Copy(f, resp.Body); err != nil { </p>
			<p class="source-code">    return err </p>
			<p class="source-code">} </p>
			<p><strong class="source-inline">OpenFile()</strong> is the more complex method of opening a file when you need to either write to a file or be more <a id="_idIndexMarker381"/>specific with how you interact with it. You should use <strong class="source-inline">os.Open()</strong> when you just want to read from a local file. Our flags here are the standard Unix-like bitmasks that do the following:</p>
			<ul>
				<li>Create the file if it doesn't exist: <strong class="source-inline">os.O_CREATE</strong>.</li>
				<li>Write to a file: <strong class="source-inline">os.O_WRONLY</strong>.</li>
				<li>If the file exists, truncate it versus append to it: <strong class="source-inline">os.O_TRUNC</strong>.</li>
			</ul>
			<p>A list of flags can be found here: <a href="https://pkg.go.dev/os#pkg-constants">https://pkg.go.dev/os#pkg-constants</a>.</p>
			<p><strong class="source-inline">io.Copy()</strong> reads from <strong class="source-inline">io.Reader</strong> and writes to <strong class="source-inline">io.Writer</strong> until <strong class="source-inline">Reader</strong> is empty. This copies the file from the HTTP server to the local disk.</p>
			<p>In this section, you learned how to read an entire file using <strong class="source-inline">os.ReadFile()</strong>, how to type convert a <strong class="source-inline">[]byte</strong> into a <strong class="source-inline">string</strong>, and how to write an entire file to disk using <strong class="source-inline">os.WriteFile()</strong>. We also <a id="_idIndexMarker382"/>learned about the differences between <strong class="source-inline">os.Open()</strong> and <strong class="source-inline">os.OpenFile()</strong> and showed you how to use utility functions such as <strong class="source-inline">io.Copy()</strong> and <strong class="source-inline">io.ReadAll()</strong>. Finally, we learned how HTTP clients expose their data streams as <strong class="source-inline">io</strong> interfaces that can be read using these same tools.</p>
			<p>Next, we will look at interacting with these file interfaces as streams instead of reading and writing ent<a id="_idTextAnchor302"/>ire files.</p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor303"/>Streaming file content</h1>
			<p>In the previous sections, we learned how to read and write in large blocks using <strong class="source-inline">os.ReadFile()</strong> and <strong class="source-inline">os.WriteFile()</strong>.</p>
			<p>This works well when the files are small, which is usually the case when you're doing DevOps automation. However, sometimes, the files we want to read are very large – in most cases, you <a id="_idIndexMarker383"/>wouldn't want to read a 2 GiB file into memory. In those cases, we want to stream the contents of the file in manageable chunks that we can operate on while keeping memory usage low.</p>
			<p>The most basic version of this was shown in the previous section. There, we used two streams to copy a file: <strong class="source-inline">io.ReadCloser</strong> from the HTTP client and <strong class="source-inline">io.WriteCloser</strong> for writing to local disk. We used the <strong class="source-inline">io.Copy()</strong> function to copy from the network file to the disk file.</p>
			<p>Go's <strong class="source-inline">io</strong> interfaces also allow us to stream files to copy content, search for content, manipulate input to output<a id="_idTextAnchor304"/>, and more.</p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor305"/>Stdin/Stdout/Stderr are just files</h2>
			<p>Throughout this book, you will see us writing to the console using <strong class="source-inline">fmt.Println()</strong> or <strong class="source-inline">fmt.Printf()</strong>, two functions <a id="_idIndexMarker384"/>from the <strong class="source-inline">fmt</strong> package. Those functions are <a id="_idIndexMarker385"/>reading and writing to files that represent the terminal.</p>
			<p>Those functions use an <strong class="source-inline">io.Writer</strong> called <strong class="source-inline">os.Stdout</strong>. When we use the same functions <a id="_idIndexMarker386"/>in the <strong class="source-inline">log</strong> package, we <a id="_idIndexMarker387"/>are usually writing to <strong class="source-inline">os.Stderr</strong>.</p>
			<p>You can use the same interfaces we've been using to read/write to other files to also read/write to these files. When we want to copy a file and output its content to the terminal, we can do the following:</p>
			<p class="source-code">f, err := os.Open("path/to/file")</p>
			<p class="source-code">if err != nil {</p>
			<p class="source-code">     return err</p>
			<p class="source-code">}</p>
			<p class="source-code">if err := io.Copy(os.Stdout, f); err != nil {</p>
			<p class="source-code">     return err</p>
			<p class="source-code">}</p>
			<p>While we <a id="_idIndexMarker388"/>won't go into the details, <strong class="source-inline">os.Stdin</strong> is simply an <strong class="source-inline">io.Reader</strong>. You can read from it using the <strong class="source-inline">io</strong> and<a id="_idTextAnchor306"/> <strong class="source-inline">bufio</strong> packages.</p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor307"/>Reading data out of a stream</h2>
			<p>What if we wanted <a id="_idIndexMarker389"/>to read a stream that represented user records and return them on a channel?</p>
			<p>Let's say the records are simple <strong class="source-inline">&lt;user&gt;:&lt;id&gt;</strong> text and each record was delimited by the new line character (<strong class="source-inline">\n</strong>). These records might be stored on an HTTP server or a local disk. This doesn't matter to us because it is simply a stream behind an interface. Let's assume that we receive this as an <strong class="source-inline">io.Reader</strong>.</p>
			<p>First, we will define a <strong class="source-inline">User</strong> struct:</p>
			<p class="source-code">type User struct{</p>
			<p class="source-code">  Name string</p>
			<p class="source-code">  ID int</p>
			<p class="source-code">}</p>
			<p>Next, let’s define a function that can split a line we receive:</p>
			<p class="source-code">func getUser(s string) (User, error) {</p>
			<p class="source-code">     sp := strings.Split(s, ":")</p>
			<p class="source-code">     if len(sp) != 2 {</p>
			<p class="source-code">          return User{}, fmt.Errorf("record(%s) was not in the correct format", s)</p>
			<p class="source-code">    } </p>
			<p class="source-code">    id, err := strconv.Atoi(sp[1]) </p>
			<p class="source-code">     if err != nil {</p>
			<p class="source-code">          return User{}, fmt.Errorf("record(%s) had non-numeric ID", s)</p>
			<p class="source-code">     }</p>
			<p class="source-code">     return User{Name: strings.TrimSpace(sp[0]), ID: id}, nil</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">getUser()</strong> takes a string and returns a <strong class="source-inline">User</strong>. We use the <strong class="source-inline">strings</strong> package's <strong class="source-inline">Split()</strong> function to split the string into a <strong class="source-inline">[]string</strong> while using <strong class="source-inline">:</strong> as the divider. </p>
			<p><strong class="source-inline">Split()</strong> should return two values; if not, then we return an error.</p>
			<p>Since we are splitting a string, our user ID is stored as a <strong class="source-inline">string</strong>. But we want to use the integer value in <a id="_idIndexMarker390"/>our <strong class="source-inline">User</strong> record. Here, we can use the <strong class="source-inline">strconv</strong> package's <strong class="source-inline">Atoi()</strong> method to convert the string version of the number into an integer. If it is not an integer, then the entry is bad, and we return an error.</p>
			<p>Now, let's create a function that reads in the stream and writes the <strong class="source-inline">User</strong> records to a channel:</p>
			<p class="source-code">func decodeUsers(ctx context.Context, r io.Reader) chan User {</p>
			<p class="source-code">     ch := make(chan User, 1)</p>
			<p class="source-code">     go func() {</p>
			<p class="source-code">          defer close(ch)</p>
			<p class="source-code">          scanner := bufio.NewScanner(r)</p>
			<p class="source-code">          for scanner.Scan() {</p>
			<p class="source-code">               if ctx.Err() != nil {</p>
			<p class="source-code">                    ch &lt;- User{err: ctx.Err()}</p>
			<p class="source-code">                    return</p>
			<p class="source-code">               }</p>
			<p class="source-code">               u, err := getUser(scanner.Text())</p>
			<p class="source-code">               if err != nil {</p>
			<p class="source-code">                    u.err = err</p>
			<p class="source-code">                    ch &lt;- u</p>
			<p class="source-code">                    return</p>
			<p class="source-code">               }</p>
			<p class="source-code">               ch &lt;- u</p>
			<p class="source-code">          }</p>
			<p class="source-code">     }()</p>
			<p class="source-code">     return ch</p>
			<p class="source-code">}</p>
			<p>Here, we are using the <strong class="source-inline">bufio</strong> package's <strong class="source-inline">Scanner</strong> type. <strong class="source-inline">Scanner</strong> allows us to take an <strong class="source-inline">io.Reader</strong> and scan it until we find a <a id="_idIndexMarker391"/>delimiter. By default, this is <strong class="source-inline">\n</strong>, though you can change this using the <strong class="source-inline">.Split()</strong> method. <strong class="source-inline">Scan()</strong> will return <strong class="source-inline">true</strong> until we reach the end of the Reader's output. Note that <strong class="source-inline">io.Reader</strong> returns an error, <strong class="source-inline">io.EOF</strong>, when it reaches the end of the stream. </p>
			<p>After each <strong class="source-inline">Scan()</strong> call, the scanner <a id="_idIndexMarker392"/>stores the bytes read, which you can retrieve as a <strong class="source-inline">string</strong> using <strong class="source-inline">.Text()</strong>. The content in <strong class="source-inline">.Text()</strong> changes each time <strong class="source-inline">.Scan()</strong> is called. Also, note that we check our <strong class="source-inline">Context</strong> object and stop its execution if it's canceled.</p>
			<p>We pass the content of that <strong class="source-inline">string</strong> to our previously defined <strong class="source-inline">getUser()</strong>. If we receive an <strong class="source-inline">error</strong>, we return it in the <strong class="source-inline">User</strong> record to inform the caller of the error. Otherwise, we return our <strong class="source-inline">User</strong> record with all the information.</p>
			<p>Now, let's invoke this against a file:</p>
			<p class="source-code">f, err := os.Open("path/to/file/with/users")</p>
			<p class="source-code">if err != nil {</p>
			<p class="source-code">     return err</p>
			<p class="source-code">}</p>
			<p class="source-code">defer f.Close()  </p>
			<p class="source-code">for user := range decodeUsers(ctx, f) {</p>
			<p class="source-code">     if user.err != nil {</p>
			<p class="source-code">          fmt.Println("Error: ", user.err)</p>
			<p class="source-code">          return err</p>
			<p class="source-code">     }</p>
			<p class="source-code">     fmt.Println(user)</p>
			<p class="source-code">}</p>
			<p>Here, we open our file on <a id="_idIndexMarker393"/>disk and pass it to <strong class="source-inline">decodeUsers()</strong>. We receive a <strong class="source-inline">User</strong><em class="italic"> </em>record from the <em class="italic">output channel</em> and we print the user to the screen concurrently while reading the file stream.</p>
			<p>Instead of using <strong class="source-inline">os.Open()</strong>, we could have opened the file via <strong class="source-inline">http.Client</strong> and passed it to <strong class="source-inline">decodeUsers()</strong>. The complete code can be found here: <a href="https://play.golang.org/p/OxehTsHT6Qj">https://play.gola<span id="_idTextAnchor308"/>ng.org/p/OxehTsHT6Qj</a>.</p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor309"/>Writing data into a stream</h2>
			<p>Writing to a stream is <a id="_idIndexMarker394"/>even simpler – we just convert our <strong class="source-inline">User</strong> into a <strong class="source-inline">string</strong> and write it to an <strong class="source-inline">io.Writer</strong>. This looks as follows:</p>
			<p class="source-code">func writeUser(ctx context.Context, w io.Writer, u User) error {</p>
			<p class="source-code">     if ctx.Err() != nil {</p>
			<p class="source-code">          return ctx.Err()</p>
			<p class="source-code">     }</p>
			<p class="source-code">     if _, err := w.Write([]byte(user.String())); err != nil {</p>
			<p class="source-code">          return err</p>
			<p class="source-code">     }</p>
			<p class="source-code">     return nil</p>
			<p class="source-code">}</p>
			<p>Here, we have taken in an <strong class="source-inline">io.Writer</strong> that represents the place to write to and a <strong class="source-inline">User </strong>record that we <a id="_idIndexMarker395"/>want to write into that output. We can use this to write to a file on disk:</p>
			<p class="source-code">f, err := os.OpenFile("file", flags, 0644); err != nil{</p>
			<p class="source-code">     return err</p>
			<p class="source-code">}</p>
			<p class="source-code">defer f.Close() </p>
			<p class="source-code">for i, u := range users {</p>
			<p class="source-code">     // Write a carriage return before the next entry, except</p>
			<p class="source-code">     // the first entry.</p>
			<p class="source-code">     if i != 0 {</p>
			<p class="source-code">          if err := w.Write([]byte("\n")); err != nil {</p>
			<p class="source-code">               return err</p>
			<p class="source-code">          }</p>
			<p class="source-code">     }</p>
			<p class="source-code">     if err := writeUser(ctx, w, u); err != nil {</p>
			<p class="source-code">          return err</p>
			<p class="source-code">     }</p>
			<p class="source-code">}</p>
			<p>Here, we opened a file on our local disk. When our containing function (not shown) returns, the file will <a id="_idIndexMarker396"/>be closed. Then, we wrote the <strong class="source-inline">User</strong> records stored in variable users (<strong class="source-inline">[]Users</strong>) one at a time to the file. Finally, we wrote a carriage return, <strong class="source-inline">("\n")</strong>, before every record except the first one.</p>
			<p>You can see this in action here: <a href="https://play.golang.org/p/bxuFyPT5nSk">https://play.golang.org/p/bxuFyPT5nSk</a>. We have provided a streaming version of this using channels that you can find here: <a href="https://play.golang.org/p/njuE1n7dyOM">https://play.g<span id="_idTextAnchor310"/>olang.org/p/njuE1n7dyOM</a>.</p>
			<p>In the next section, we'll learn how to use the <strong class="source-inline">path/filepath</strong> package to write software that works on multiple OSs t<a id="_idTextAnchor311"/>hat use different path delimiters.</p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor312"/>OS-agnostic pathing</h1>
			<p>One of Go's greatest strengths lies in its multiplatform support. A developer can develop on a Linux workstation <a id="_idIndexMarker397"/>and run the same Go program, recompiled into native code, on a Windows server.</p>
			<p>One of the areas of difficulty when developing software that runs on multiple OSs is <em class="italic">accessing files</em>. Path formats are slightly different for each operating system. The most obvious example is the different file separators for OSs: <strong class="source-inline">\</strong> on Windows and <strong class="source-inline">/</strong> on Unix-like systems. Less obvious would be how to escape special characters on a particular OS, which can differ even between Unix-based OSs.</p>
			<p>The <strong class="source-inline">path/filepath</strong> package provides access to functions that will allow you to handle pathing for the native OS. This should not be confused with the root <strong class="source-inline">path</strong> package, which looks similar but handle<a id="_idTextAnchor313"/>s a more general URL-style pathing.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor314"/>What OS/platform am I running?</h2>
			<p>While we will discuss how to gain file access and perform pathing using agnostic functions, it is still important to understand what OS you are running on. You may use different locations for files based on the OS you are running.</p>
			<p>Using the <strong class="source-inline">runtime</strong> package, you can <a id="_idIndexMarker398"/>detect the OS and platform you are running on:</p>
			<p class="source-code">fmt.Println(runtime.GOOS) // linux, darwin, ...</p>
			<p class="source-code">fmt.Println(runtime.GOARCH) // amd64, arm64, ...</p>
			<p>This gives you the running OS. We can print out the current list of OS types and hardware architecture that's sup<a id="_idTextAnchor315"/>ported by Go with <strong class="bold">go tool dist list</strong>.</p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor316"/>Using filepath</h2>
			<p>With <strong class="bold">filepath</strong>, you can be ignorant <a id="_idIndexMarker399"/>of the pathing rules for the OS you are running on when manipulating a path. Paths are divided into the following areas:</p>
			<ul>
				<li>The <strong class="bold">directories</strong> in <a id="_idIndexMarker400"/>the path</li>
				<li>The <strong class="bold">file</strong> in the <a id="_idIndexMarker401"/>path</li>
			</ul>
			<p>A file path's final directory or file <a id="_idIndexMarker402"/>is called the <strong class="bold">base</strong>. The path your binary is run<a id="_idTextAnchor317"/>ning in <a id="_idIndexMarker403"/>is called the <strong class="bold">working directory</strong>.</p>
			<h3>Joining a file path</h3>
			<p>Let's say we want to access a configuration file, <strong class="source-inline">config.json</strong>, that is stored in the <strong class="source-inline">config/</strong> directory, which is <a id="_idIndexMarker404"/>in the same directory as our binary. Let's use <strong class="source-inline">os</strong> and <strong class="source-inline">path/filepath</strong> to read that file in a way that works on all OSs:</p>
			<p class="source-code">wd, err := os.Getwd() </p>
			<p class="source-code">if err != nil { </p>
			<p class="source-code">    return err </p>
			<p class="source-code">} </p>
			<p class="source-code">content, err := os.ReadFile(filepath.Join(wd, "config", "config.json"))</p>
			<p>In this example, the first thing we do is get the working directory. This allows us to make calls relative to where our binary is running. </p>
			<p><strong class="source-inline">filepath.Join()</strong> allows us to join the components of our path into a single path. This fills in the OS-specific directory separators for you and uses the native pathing rules. On a Unix-like system, this might be <strong class="source-inline">/home/jdoak/bin/config/config.json</strong>, while on Windows, this might be <strong class="source-inline">C:\Documents and <a id="_idTextAnchor318"/>Settings\jdoak\go\bin\config\config.json</strong>. </p>
			<h3>Splitting a file path</h3>
			<p>In some circumstances, it is <a id="_idIndexMarker405"/>important to split filepaths along their path separators in different ways. <strong class="source-inline">filepath</strong> provides the following:</p>
			<ul>
				<li><strong class="source-inline">Base()</strong>: Returns the last element of the path</li>
				<li><strong class="source-inline">Ext()</strong>: Returns the file extension, if it has one</li>
				<li><strong class="source-inline">Split()</strong>: Returns the split directory and file</li>
			</ul>
			<p>We can use these to get various parts of a path. This can be useful when we wish to copy a file into another directory while retaining the file's name.</p>
			<p>Let's copy a file from its location to our OS's <strong class="bold">TMPDIR</strong>:</p>
			<p class="source-code">fileName := filepath.Base(fp) </p>
			<p class="source-code">if fileName == "." { </p>
			<p class="source-code">    // Path is empty </p>
			<p class="source-code">    return nil </p>
			<p class="source-code">}</p>
			<p class="source-code">newPath := filepath.Join(os.TempDir(), fileName) </p>
			<p class="source-code"> </p>
			<p class="source-code">r, err := os.Open(fp) </p>
			<p class="source-code">if err != nil { </p>
			<p class="source-code">    return err </p>
			<p class="source-code">}</p>
			<p class="source-code">defer r.Close() </p>
			<p class="source-code"> </p>
			<p class="source-code">w, err := os.OpenFile(newPath, O_WRONLY | O_CREATE, 0644) </p>
			<p class="source-code">if err != nil { </p>
			<p class="source-code">    return err </p>
			<p class="source-code">}</p>
			<p class="source-code">defer w.Close()</p>
			<p class="source-code">// Copies the file to the temporary file.</p>
			<p class="source-code">_, err := io.Copy(w, r)</p>
			<p class="source-code">return err</p>
			<p>Now, it's time to look at the <a id="_idIndexMarker406"/>different pathing options you can use to reference <a id="_idTextAnchor319"/>files and how the <strong class="source-inline">filepath</strong> package can help.</p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor320"/>Relative and absolute pathing</h2>
			<p>There are two types of pathing when <a id="_idIndexMarker407"/>it comes to accessing a filesystem:</p>
			<ul>
				<li><strong class="bold">Absolute pathing</strong>: Pathing from <a id="_idIndexMarker408"/>the root directory to the file</li>
				<li><strong class="bold">Relative pathing</strong>: Pathing from your <a id="_idIndexMarker409"/>current location in the filesystem</li>
			</ul>
			<p>During development, it is often handy to convert a relative path into an absolute path and vice versa.</p>
			<p><strong class="source-inline">filepath</strong> provides <a id="_idIndexMarker410"/>a few functions to help with this:</p>
			<ul>
				<li><strong class="source-inline">Abs()</strong>: Returns the absolute path. If it's not an absolute path, return the working directory, as well as the path.</li>
				<li><strong class="source-inline">Rel()</strong>: Returns the relative path of a path to a base.</li>
			</ul>
			<p>We will leave it as an exercise for you to experiment with using these.</p>
			<p>In this section, we learned how to use the <strong class="source-inline">path/filepath</strong> and <strong class="source-inline">runtime</strong> packages to handle file pathing for different OSs. We introduced <strong class="source-inline">runtime.GOOS</strong> to help you detect the OS your user is using and <strong class="source-inline">os.Getwd()</strong> to determine where in the filesystem your program is. <strong class="source-inline">os.TempDir()</strong> was introduced to locate your OS's location for temporary files. Finally, we learned about the functions in <strong class="source-inline">path/filepath</strong> that allow you to <a id="_idIndexMarker411"/>combine and split file paths agnostically to you but with an output specific to the OS.</p>
			<p>Next, we will look at Go's new <strong class="source-inline">io/fs</strong> package, which was introduced in version 1.16. It introduces new interfaces to abstra<a id="_idTextAnchor321"/>ct filesystems in the same way <strong class="source-inline">io</strong> does for files.</p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor322"/>OS-agnostic filesystems</h1>
			<p>One of the newest and more <a id="_idIndexMarker412"/>exciting developments in the latest Go releases is the new <strong class="source-inline">io/fs</strong> and <strong class="source-inline">embed</strong> packages, which <a id="_idIndexMarker413"/>were introduced in <strong class="bold">Go 1.16</strong>.</p>
			<p>While we have shown agnostic access to our local filesystem via the <strong class="source-inline">os</strong> package, as well as agnostic file pathing manipulation through <strong class="source-inline">filepath</strong>, we haven't seen an agnostic way of accessing an entire filesystem.</p>
			<p>In the cloud era, files are just as likely to be in filesystems that exist in remote data centers such as Microsoft Azure's Blob Storage, Google Cloud's Filestore, or Amazon AWS's EFS as they are on local disk. </p>
			<p>Each of these filesystems comes with a client for accessing the files in Go, but they are specific to that network service. We can't treat each of these in the same way as I treat my local filesystem. <strong class="source-inline">io/fs</strong> is meant to provide a foundation to help solve this problem.</p>
			<p>Another problem is that many files must be packaged with that binary, often in a container definition. Those files do not change during the lifetime of the program. It would be easier to include them in the binary and access them with a filesystem interface. A simple web application that needs image, HTML, and CSS files is a good example of this use <a id="_idTextAnchor323"/>case. The new <strong class="source-inline">embed</strong> package aims to fix this issue.</p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor324"/>io.fs filesystems</h2>
			<p>Our new <strong class="source-inline">io/fs</strong> filesystem <a id="_idIndexMarker414"/>exports interfaces that can be implemented by filesystem providers. The root interface, <strong class="source-inline">FS</strong>, has the simplest definition:</p>
			<p class="source-code">type FS interface {</p>
			<p class="source-code">     Open(name string) (File, error)</p>
			<p class="source-code">}</p>
			<p>This lets you open any file, where <strong class="source-inline">File</strong> is defined as follows:</p>
			<p class="source-code">type File interface {</p>
			<p class="source-code">     Stat() (FileInfo, error)</p>
			<p class="source-code">     Read([]byte) (int, error)</p>
			<p class="source-code">     Close() error</p>
			<p class="source-code">}</p>
			<p>This provides the simplest of filesystems. You can open a file at a path and either get information about the file <a id="_idIndexMarker415"/>or read it. As filesystems tend to differ in functionality, this is the only shared functionality between all the given filesystems.</p>
			<p>A <strong class="bold">filesystem</strong> can have other capabilities, all of which are defined as supersets of <strong class="source-inline">FS</strong> (such as <strong class="source-inline">ReadDirFS</strong> and <strong class="source-inline">StatFS</strong>) to allow for file walking and to provide directory information. There is a noticeable lack of writability for FS objects. You must provide your own since the Go authors<a id="_idTextAnchor325"/> haven't defined one as part of the standard library.</p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor326"/>embed</h2>
			<p>The <strong class="source-inline">embed</strong> package allows <a id="_idIndexMarker416"/>you to embed files directly into the binary using a <strong class="source-inline">//go:embed</strong> directive.</p>
			<p><strong class="source-inline">embed</strong> can embed files in three ways, as follows:</p>
			<ul>
				<li>As bytes</li>
				<li>As a string</li>
				<li>Into an <strong class="source-inline">embed.FS</strong> (which implements <strong class="source-inline">fs.FS</strong>)</li>
			</ul>
			<p>The first two are done by putting a directive over the specific variable type:</p>
			<p class="source-code">import _ "embed" </p>
			<p class="source-code">//go:embed hello.txt</p>
			<p class="source-code">var s string</p>
			<p class="source-code">//go:embed world.txt</p>
			<p class="source-code">var b []byte</p>
			<p><strong class="source-inline">//go:embed hello.txt</strong> represents a Go directive instructing the compiler to take a file called <strong class="source-inline">hello.txt</strong> and store it in variables. </p>
			<p><strong class="source-inline">_</strong> on the <strong class="source-inline">import</strong> line instructs the compiler to ignore the fact that we don't directly use <strong class="source-inline">embed</strong>. This is called an <em class="italic">anonymous import</em>, where we <a id="_idIndexMarker417"/>need a package to be loaded but don't use its functionality <a id="_idIndexMarker418"/>directly. Without <strong class="source-inline">_</strong>, we would receive a compile error for not using the imported package.</p>
			<p>The final method of using <strong class="source-inline">embed.FS</strong> is useful when you wish to embed several files in the filesystem: </p>
			<p class="source-code">// The lines beginning with //go: are not comments, but compiler directives</p>
			<p class="source-code">//go:embed image/*</p>
			<p class="source-code">//go:embed index.html</p>
			<p class="source-code">var content embed.FS</p>
			<p>We now have an <strong class="source-inline">fs.FS</strong> that's storing all the files in our <strong class="source-inline">image</strong> directory and our <strong class="source-inline">index.html</strong> file. These file<a id="_idTextAnchor327"/>s no longer need to be included in a container filesystem when we ship our binary.</p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor328"/>Walking our filesystem</h2>
			<p>The <strong class="source-inline">io/fs</strong> package offers a filesystem-agnostic method of walking a filesystem <em class="italic">if the filesystem supports that capability</em>. In the <a id="_idIndexMarker419"/>previous example, we had a directory in our embedded filesystem holding image files. We can print out any <strong class="source-inline">.jpg</strong> files using a directory walker:</p>
			<p class="source-code">err := fs.WalkDir(</p>
			<p class="source-code">     content,</p>
			<p class="source-code">     ".",</p>
			<p class="source-code">     func(path string, d fs.DirEntry, err error) error {</p>
			<p class="source-code">          if err != nil {</p>
			<p class="source-code">               return err</p>
			<p class="source-code">          }</p>
			<p class="source-code">          if !d.IsDir() &amp;&amp; filepath.Ext(path) == ".jpg" {</p>
			<p class="source-code">               fmt.Println("jpeg file: ", path)</p>
			<p class="source-code">          }</p>
			<p class="source-code">          return nil</p>
			<p class="source-code">     },</p>
			<p class="source-code">)</p>
			<p>The preceding function <a id="_idIndexMarker420"/>walks the directory structure of our embedded filesystem (content) from the root (<strong class="source-inline">"."</strong>) and calls the function that was defined, passing it the path of the file, its directory entry, and an error, if there was one. </p>
			<p>In our function, we simply print the path of the file if the file is not a directory and has the<strong class="source-inline">.jpg</strong> extension.</p>
			<p>But what about packages <a id="_idTextAnchor329"/>that are using <strong class="source-inline">io/fs</strong> to access other types of filesystems?</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor330"/>The io/fs future</h2>
			<p>At the time of writing, the <a id="_idIndexMarker421"/>major user of <strong class="source-inline">io/fs</strong> is <strong class="source-inline">embed</strong>. However, we are starting to see third-party packages implementing this interface. </p>
			<p><strong class="source-inline">absfs</strong> provides an <strong class="source-inline">io.FS</strong> hook for their <strong class="source-inline">boltfs/memfs/os</strong> filesystem packages (<a href="https://github.com/absfs">https://github.com/absfs</a>). Several of these packages have wrappers around the popular <strong class="source-inline">afero</strong> filesystem package (<a href="https://github.com/spf13/afero">https://github.com/spf13/afero</a>). Azure has a non-official package that supports Blob storage (<a href="https://github.com/element-of-surprise/azfs">https://github.com/element-of-surprise/azfs</a>). </p>
			<p>There are also <a id="_idIndexMarker422"/>packages for accessing <strong class="bold">Redis</strong>, <strong class="bold">GroupCache</strong>, <strong class="bold">memfs</strong>, local <a id="_idIndexMarker423"/>filesystems, and <a id="_idIndexMarker424"/>tooling support at <a href="https://github.com/gopherfs/fs">https://github.com/gopherfs/fs</a>. </p>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="source-inline">github.com/element-of-surprise</strong> and <a href="https://github.com/gopherfs">https://github.com/gopherfs</a> are owned by the author.</p>
			<p>In this section, you learned about Go's <strong class="source-inline">io/fs</strong> package and how it is becoming a standard for interacting <a id="_idIndexMarker425"/>with filesystems. You also learned how to use the <strong class="source-inline">embed</strong> package to embed files into a binary and access them via the <strong class="source-inline">io/fs</strong> interfaces. </p>
			<h3>We've only scratched the surface</h3>
			<p>I highly encourage you to read the standard library's <strong class="bold">GoDoc</strong> pages to become familiar with its capabilities. The following <a id="_idIndexMarker426"/>are the GoDocs that were covered in this chapter. Here, you can find many useful utilities for dealing with files:</p>
			<ul>
				<li>File interfaces <a id="_idIndexMarker427"/>and basic I/O functions: <a href="">https://pkg.go.dev/io</a></li>
				<li>Buffered <a id="_idIndexMarker428"/>I/O package: <a href="https://pkg.go.dev/bufio">https://pkg.go.dev/bufio</a></li>
				<li>Converting to/from <a id="_idIndexMarker429"/>strings into other types: <a href="">https://pkg.go.dev/strconv</a></li>
				<li>Package for <a id="_idIndexMarker430"/>manipulating strings: <a href="">https://pkg.go.dev/strings</a></li>
				<li>Package for <a id="_idIndexMarker431"/>manipulating bytes: <a href="">https://pkg.go.dev/bytes</a></li>
				<li>Package <a id="_idIndexMarker432"/>for OS interaction: <a href="https://pkg.go.dev/os">https://pkg.go.dev/os</a></li>
				<li>Package for forward slash paths, like URLs: <a href="https://pkg.go.dev/path">https://pkg.go.dev/path</a></li>
				<li>Package for file paths: <a href="https://pkg.go.dev/path/filepath">https://pkg.go.dev/path/filepath</a></li>
				<li>Filesystem <a id="_idIndexMarker433"/>interfaces: <a href="">https://pkg.go.dev/io/fs</a></li>
				<li>Embedded <a id="_idIndexMarker434"/>filesystem: <a href="">https://pkg.go.dev/embed</a></li>
			</ul>
			<p>In this section, we learned how to use <strong class="source-inline">io</strong> interfaces to stream data in and out of files, as well as about the <strong class="source-inline">os</strong> package's <strong class="source-inline">Stdin/Stdout/Stderr</strong> implementations for reading and writing to a <a id="_idIndexMarker435"/>program's input/output. We also learned how to read data by delimiter using the <strong class="source-inline">bufio</strong> package and how to split string content up using the <strong class="source-inline">strings</strong> package.</p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor331"/>Summary</h1>
			<p>This chapter has provided you with a foundation for working with file I/O in the Go language. You learned about the <strong class="source-inline">io</strong> package and its file abstractions and how to read and write files to disk. Then, you learned how to stream file content so that you can work with the network and be more efficient with memory. After that, you learned about the <strong class="source-inline">path/filepath</strong> package, which can help you deal with multiple OSs. Finally, you learned about Go's filesystem-agnostic interfaces for interacting with any filesystem, starting with the new <strong class="source-inline">embed</strong> filesystem.</p>
			<p>In the next chapter, you will learn how to interact with common data types and storage using popular Go packages. There, you will need to rely on the file and filesystem packages from this chapter to interact with data types.</p>
			<p>Interacting with data and storage systems is critical to DevOps work. It allows us to read and change software configurations, store data and make it searchable, ask systems to do work on our behalf, and generate reporting. </p>
			<p>So, let's dive in!</p>
		</div>
	</div></body></html>