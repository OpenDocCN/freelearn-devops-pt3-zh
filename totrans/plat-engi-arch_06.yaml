- en: <st c="0">6</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2">Build for Developers and Their Self-Service</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="45">A platform without accessible features is not a platform.</st> <st
    c="104">As a rule, self-service should be included and must improve accessibility
    to add value.</st> <st c="192">In the process of building platforms, there is
    often no distinction between infrastructure and application layers.</st> <st c="307">The
    integration of</st> **<st c="326">Internal Developer Portals</st>** <st c="352">(</st>**<st
    c="354">IDPs</st>**<st c="358">) adds new complexity to this, addressing some
    demands</st> <st c="413">while leaving others unanswered.</st> <st c="447">It
    is important to bring the community into your platform and be open to</st> <st
    c="520">their contributions.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="540">In this chapter, we will review some concepts and share some ideas
    for best practices.</st> <st c="628">By the end of the chapter, you should understand
    how to approach the building of a platform that is resilient, flexible, and meets
    your users where</st> <st c="776">they are.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="785">In this chapter, we’ll cover the following</st> <st c="829">main
    topics:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="841">Software versus platform development – avoiding</st> <st c="890">a
    mix</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="895">Reducing</st> <st c="905">cognitive load</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="919">Self-service</st> <st c="933">developer portals</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="950">Land, expand, and integrate</st> <st c="979">your IDP</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="987">Architectural considerations for observability in</st> <st c="1038">a
    platform</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1048">Open your platform for community</st> <st c="1082">and collaboration</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1099">Technical requirements</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1122">In this chapter, there will be some technical examples with</st>
    `<st c="1183">.yaml</st>` <st c="1188">files and commands.</st> <st c="1209">While
    you don’t need to set up a cluster to follow along, doing so may enhance your
    understanding.</st> <st c="1308">We used the following technologies to develop
    our samples</st> <st c="1366">and explanations:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1383">kind – the version tested was kind</st> `<st c="1419">v0.22.0 go1.20.13</st>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1436">We used this guide to set up a three-worker node</st> <st c="1486">cluster:</st>
    [<st c="1495">https://kind.sigs.k8s.io/docs/user/quick-start/#configuring-your-kind-cluster</st>](https://kind.sigs.k8s.io/docs/user/quick-start/#configuring-your-kind-cluster)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1572">Docker (a Docker Rootless setup</st> <st c="1605">is recommended)</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1620">The</st> `<st c="1625">kubectl</st>` <st c="1632">command-line
    tool</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1650">A</st> <st c="1653">GitHub repo</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1664">The code examples can be found inside the</st> `<st c="1707">Chapter06</st>`
    <st c="1716">folder</st> <st c="1724">here:</st> [<st c="1730">https://github.com/PacktPublishing/Platform-Engineering-for-Architects</st>](https://github.com/PacktPublishing/Platform-Engineering-for-Architects)<st
    c="1800">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1801">We’ll do a couple of small tutorials over the course of the chapter.</st>
    <st c="1871">While not every code snippet needs to be run against a Kubernetes
    cluster, it is recommended to set up a local Kind cluster with at least one control
    plane node and three worker nodes to get the full value of the tutorials.</st>
    <st c="2095">The configuration for the Kind cluster can be found in the GitHub
    repo for</st> <st c="2170">the chapter.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2182">Software versus platform development – avoiding a mix</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2236">In our journey toward</st> <st c="2259">platform development, we
    have to disambiguate between this and other forms of</st> <st c="2336">software
    development.</st> <st c="2359">Remember that the purpose of the platform is to
    enable development and operations teams; it is not something that customers directly
    experience, although they do</st> <st c="2521">benefit indirectly.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2540">The value of the platform is the unification of all the tools,
    services, and applications required to build and land an application in front
    of users.</st> <st c="2692">In short, a platform is a series of services used
    by developers to deliver software applications into the hands of end users.</st>
    <st c="2818">You can</st> <st c="2825">consume existing software applications,
    so it’s possible to develop</st> <st c="2893">a platform without writing</st>
    <st c="2921">any code.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2930">So, how do you develop a platform, and how do you develop software?</st>
    <st c="2999">Where do they intersect, and where do</st> <st c="3037">they differ?</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3049">The platform life cycle versus the software life cycle</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="3104">In</st> <st c="3108">many</st> <st c="3113">regards, the life cycle
    of a</st> <st c="3142">platform looks similar to any</st> **<st c="3172">Software
    Development Life</st>** **<st c="3198">Cycle</st>** <st c="3203">(</st>**<st c="3205">SDLC</st>**<st
    c="3209">).</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1: An SDLC](img/B31164_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="3214">Figure 6.1: An SDLC</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3233">In the previous chapters, we covered the benefits of a robust planning
    phase and treating your platform as a product.</st> <st c="3352">And while it’s
    important not to over-engineer the platform during this process, you’ll still
    end up with a system that has a variety of aspects.</st> <st c="3497">Thus, due
    to its relative size and complexity, the release of a platform may not be as simple
    as pressing a button and letting your change propagate through some servers or
    clusters.</st> <st c="3680">This is in no small part due to the number of moving
    pieces you can find within a platform.</st> <st c="3772">For example, creating
    a new integration to deliver a</st> **<st c="3825">Software Bill of Materials</st>**
    <st c="3851">(</st>**<st c="3853">SBOM</st>**<st c="3857">) will be</st> <st c="3867">less
    disruptive to users than adjusting policies within an existing policy engine to
    be</st> <st c="3956">more restrictive.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3973">If we look</st> <st c="3985">at the anatomy of a typical</st> <st
    c="4012">platform and its</st> <st c="4029">user considerations, it will be easier
    to understand how the platform life cycle differs from</st> <st c="4123">a</st>
    <st c="4126">software application.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2: An example of IDP components and functional areas](img/B31164_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="4360">Figure 6.2: An example of IDP components and functional areas</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4421">In this platform example, pre-production is on the left, and the
    production environment where customer-facing applications will be deployed is
    on the right (</st>**<st c="4579">Application Landing Zone</st>**<st c="4604">).</st>
    <st c="4608">Whether a single Kubernetes cluster, multi-cluster, or multi-architecture,
    the platform is a cohesive unit that encapsulates these two paradigms.</st> <st
    c="4754">The platform should abstract the architecture away from users, allowing
    them to</st> <st c="4834">work independently.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4853">Here, DevOps engineers care about how the application is built
    and released.</st> <st c="4931">Things such as progressive rollouts, DORA</st>
    <st c="4973">metrics (</st>[<st c="4982">https://dora.dev/</st>](https://dora.dev/)<st
    c="5000">), and other DevOps practices are what the platform may be expected to
    support.</st> <st c="5081">Similarly, if your organization is quite far along
    in its cloud-native journey, the data surrounding the operations of the production
    application would be something site reliability engineers would concern themselves
    with.</st> <st c="5304">And there are other relevant considerations, such as security
    checks, infrastructure as code, and docs.</st> <st c="5408">Each aspect of these
    can be controlled individually within a platform and made available to all or
    a subset of</st> <st c="5519">the personas.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="5532">Figure 6</st>**<st c="5541">.2</st>* <st c="5543">also assumes
    there are personas working in dedicated roles; however, if there’s no dedicated
    DevOps team, it’s likely that developers and quality engineering would share responsibilities
    in that space.</st> <st c="5746">The overall concept should still apply even to
    small organizations, where one person may have a stake in multiple personas’ user
    stories.</st> <st c="5884">Even the theoretical division of the personas should
    assist when undertaking the life cycle of</st> <st c="5979">a platform.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5990">A platform</st> <st c="6001">is more than just the software; it’s
    also its tuning</st> <st c="6055">in concert with the workloads that help make
    sure it’s performant for its users.</st> <st c="6136">While the needs of the users
    do influence the size, scope, and functionality of the platform, it should be
    designed as agnostically as possible so that one user’s golden path isn’t prioritized</st>
    <st c="6329">over another.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6342">Reliability versus serviceability</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="6376">A platform’s</st> **<st c="6390">reliability</st>** <st c="6401">and</st>
    **<st c="6406">serviceability</st>** <st c="6420">are the</st> <st c="6428">largest
    factors of its usability by developers in an</st> <st c="6481">organization.</st>
    <st c="6496">But what do each of these things</st> <st c="6529">really mean?</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6541">At its core, reliability</st> <st c="6567">encompasses the overall
    availability of a platform and the</st> <st c="6626">ability of a user to successfully
    interact with it.</st> <st c="6678">Reliability in a platform should assume that
    multi-tenancy (multiple users who are fully isolated from each other) has been
    implemented in the platform.</st> <st c="6831">The reason for this is that the
    concept can still be applied where it’s not required, but your platform still
    supports multiple users with individual needs.</st> <st c="6988">While multi-tenancy
    isn’t an intuitive approach for an internal tool, highly regulated teams may prefer
    to work in an isolated environment to ensure that there’s no risk of security
    and compliance violations.</st> <st c="7197">Even if all your users are internal
    customers, they still shouldn’t be exposed to or impacted by other</st> <st c="7300">user
    workloads.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7315">To attain the reliability of a platform, you should leverage tuning
    and a policy that helps you ensure workload isolation and maintain the integrity
    of a platform.</st> <st c="7480">In a Kubernetes environment, a node may be a
    virtual machine or real hardware.</st> <st c="7559">As with any machine, each
    node has a set amount of memory and CPU allocated to it.</st> <st c="7642">However,
    unlike your standard virtual machine, when you overcommit the CPU, a node can
    use the CPU that would otherwise belong to a different node.</st> <st c="7790">This
    is not true of memory, although both can be oversubscribed, and</st> **<st c="7859">Out
    of Memory</st>** <st c="7872">(</st>**<st c="7874">OOM</st>**<st c="7877">) will</st>
    <st c="7885">cause a node to reboot.</st> <st c="7909">This allows the overall
    resource requirements to be kept lower by guaranteeing a resource will be able
    to utilize CPU cycles if they’re available; however, on the other hand, a bad
    process that eats CPU due to a software error may never return the CPU cycles
    to the node pool for availability.</st> <st c="8203">Other factors, such as Pod
    priority, requests, limits, and Pod disruption budgets, can influence how a scheduler
    will determine where and how to schedule Pods, and whether or not the kubelet
    will evict an existing workload.</st> <st c="8427">For more information on these
    topics, it’s important to review the Kubernetes documentation regularly as new
    features and best practices emerge and the project continues to</st> <st c="8600">develop
    (</st>[<st c="8609">https://kubernetes.io/docs/home/</st>](https://kubernetes.io/docs/home/)<st
    c="8642">).</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8645">While the final</st> <st c="8661">tuning and orchestration of these
    settings will need to</st> <st c="8717">be determined by the platform engineering
    team, we can generally recommend that this tuning should be part of your planning
    phase.</st> <st c="8849">You should reevaluate continuously over the life cycle
    of</st> <st c="8907">a platform.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8918">The serviceabil</st><st c="8934">ity of a platform is similar to
    reliability, except serviceability looks more at what the golden paths are for
    the users who need to leverage the platform.</st> <st c="9091">For a platform
    to have serviceability, it needs to meet the user’s demands.</st> <st c="9167">Unlike
    self-service, which is a user’s ability to reasonably accomplish all reasonable
    actions without reliance on a governing team, serviceability looks holistically
    at all the user needs and meets them where they are.</st> <st c="9387">Reliability
    could be considered a measurement of serviceability, but the goal of meeting user
    needs is more all-encompassing than just reliability.</st> <st c="9535">Serviceability
    is at the core of a product minds</st><st c="9583">et for</st> <st c="9591">the
    platform.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9604">Similar to a critical user journey, the</st> <st c="9645">golden
    path maps the more critical use case for a user of a system.</st> <st c="9713">In
    general, this is the series of steps the user can take and expect the</st> <st
    c="9786">desired outcome.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9802">For a developer of an application leveraging an IDP, the golden
    path would be something</st> <st c="9891">like this:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3: An example of a golden path using an IDP](img/B31164_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="9973">Figure 6.3: An example of a golden path using an IDP</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10025">A</st> <st c="10028">developer pushes a commit, and then the</st>
    **<st c="10068">Continuous Integration</st>** <st c="10090">(</st>**<st c="10092">CI</st>**<st
    c="10094">) system</st> <st c="10103">does its magic.</st> <st c="10120">The application
    or an upgrade to the application</st> <st c="10168">lands in production, and then
    it sends data back to logging and observability tools for the developer to leverage,
    enabling them to gain insights into their application’s production state</st>
    <st c="10357">and performance.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10373">The conclusion</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="10388">With this in mind, we can now look at where the SDLC diverges
    for platform engineering as compared to the development of an application that
    a platform would run.</st> <st c="10552">Along our golden path within the platform,
    rather than one service or opaque system that does it all, our users interact
    with a system comprised of different services.</st> <st c="10720">Some or all
    of these services may be homegrown, but it’s more likely that these services are
    a mix of internal tooling and open source technologies working in concert to create
    the entity known as</st> *<st c="10917">the platform</st>*<st c="10929">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10930">Since a platform is built of components, you can also break down
    your platform’s SDLC on a per-component basis.</st> <st c="11043">However, as
    with any system, you must watch out for interdependencies that would require multiple
    components to be released</st> <st c="11167">in concert.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11178">Your developers will need the ability to leverage these systems
    both transparently and opaquely.</st> <st c="11276">This means that while the
    use of each tool within the platform should be baked into an automated workflow
    for them, they should be able to see what’s happening and debug issues within
    the individual pieces as necessary.</st> <st c="11496">For example, if a Tekton
    CI job fails, the application developer in our example needs to be able to see
    the failed job and gain insights into what failed within the job, enabling them
    to either fix the application or the</st> <st c="11717">CI job.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11724">Understanding how to effectively manage the life cycle of a platform
    while minimizing user impact can be a case of drinking your own champagne, meaning
    the platform team uses the same processes and technologies they make available
    to users.</st> <st c="11966">The building and life cycle management of a platform
    can leverage the same DevOps tools;</st> *<st c="12055">star (*) as code</st>*
    <st c="12071">patterns such as</st> *<st c="12089">docs as code</st>*<st c="12101">,</st>
    *<st c="12103">infrastructure as code</st>*<st c="12125">, and</st> *<st c="12131">configuration
    as code</st>* <st c="12152">all factor into the build and release of the platform.</st>
    <st c="12208">However, unlike the software application, for end users of a platform
    these declarative pieces will have the highest impact on them, especially when
    compared to something such as a banki</st><st c="12394">ng application for which
    all of those DevOp</st><st c="12438">s aspects are completely black-boxed for
    the end users.</st> <st c="12495">The identity of the customers greatly impacts
    the weight of one facet of software engineering over the other and, thus, differentiates
    between</st> *<st c="12638">software and</st>* *<st c="12651">platform development</st>*<st
    c="12671">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12672">That user-centricity is also paramount to understanding what to
    prioritize within a platform to make it successful.</st> <st c="12789">While the
    users themselves will inform that to a large degree, as we continue through the
    chapter, we will highlight aspects that we think are most important for a</st>
    <st c="12953">successful platform.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12973">With this new understanding of the SDLC for your platform, we
    can start to use that knowledge to contextualize what it means to build a platform
    as</st> <st c="13122">a product.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13132">Reducing cognitive load</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="13156">In</st> [*<st c="13160">Chapter 1</st>*](B31164_01.xhtml#_idTextAnchor014)<st
    c="13169">, we touched on the importance of</st> *<st c="13203">reducing cognitive
    load</st>*<st c="13226">. As technology and systems evolve, they become more complex.</st>
    <st c="13288">The high degree of complexity means that understanding every part
    of a system is a significantly larger mental burden.</st> <st c="13407">The old
    days of monolithic applications on the</st> **<st c="13454">Linux, Apache, MySQL,
    PHP</st>** <st c="13479">(</st>**<st c="13481">LAMP</st>**<st c="13485">) stack</st>
    <st c="13493">are behind us.</st> <st c="13509">Instead, microservices, the cloud,
    virtual networks, and so on have become part and parcel of the day-to-day operations
    of a</st> <st c="13634">software application.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13655">With modern software architectures, a full stack software engineer
    no longer needs to understand a server or operating system that application code
    runs on.</st> <st c="13813">The platform takes care of that for them.</st> <st
    c="13855">However, as much as the platform can abstract a lot of the details away,
    a developer still needs to be able to have awareness and insights into the underlying
    technologies in so far as they are relevant to their application.</st> <st c="14080">Therefore,
    the platform must strike the balance by making it easy for the users to get from
    it what they need, without the noise o</st><st c="14210">f what</st> <st c="14218">they
    don’t.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14229">If we compare and</st> <st c="14247">contrast the priorities of
    the</st> <st c="14279">personas, we can contextualize the scope of the platform
    as it applies to</st> <st c="14353">those users.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '| **<st c="14365">Platform team</st>** | **<st c="14379">Both</st>** | **<st
    c="14384">Development team</st>** |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="14401">Tenant apps</st> | <st c="14413">Platform availability</st>
    | <st c="14435">Application availability</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="14460">User management</st> | <st c="14476">Team RBAC</st> | <st c="14486">Application
    SLO/SLI</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="14506">User authentication</st> | <st c="14526">Security</st> | <st
    c="14535">Pass/fail</st> <st c="14546">CI tests</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="14554">Networking</st> | <st c="14565">Compliance</st> | <st c="14576">CD</st>
    <st c="14580">job success</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="14591">Platform SLO/SLI</st> | <st c="14608">Log aggregation</st>
    | <st c="14624">Application upgrades</st> |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="14645">Platform upgrades</st> | <st c="14663">Error and</st> <st c="14674">exception
    tracking</st> | <st c="14692">Application</st> <st c="14705">resource benchmarking</st>
    |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="14726">Platform scaling</st> | <st c="14743">Policy violation</st>
    |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="14760">Platform architecture</st> | <st c="14782">Quota consumption</st>
    |  |'
  prefs: []
  type: TYPE_TB
- en: '| <st c="14800">Platform serviceability</st> | <st c="14824">Application performance</st>
    |  |'
  prefs: []
  type: TYPE_TB
- en: '<st c="14848">Table 6.1: Comparing and contrasting developer versus platform
    team priorities</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14927">As you can</st> <st c="14939">see, even with a platform team</st>
    <st c="14969">taking care of so many aspects of how an application is delivered
    to an end user, the development team for the application still has many considerations.</st>
    <st c="15124">The platform can take care of shared considerations, such as security
    and compliance, but it’s not the job of the platform to guarantee that the app
    the development team produces is performant.</st> <st c="15318">You could consider
    your IDP a managed service, which wouldn’t be a bad definition for</st> <st c="15404">the
    product.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15416">As a managed service seeks to strike the balance between doing
    and enabling, the preceding table becomes the map to building a successful platform.</st>
    <st c="15565">For example, by investing in tooling around observability and reliability,
    a platform can support the development team in managing their considerations,
    while abstracting away everything else it can.</st> <st c="15765">A developer
    who doesn’t have to care how aggregate logs are stored but knows how to access
    them if needed can simplify day-to-day workflows significantly, allowing more
    cycles to be spent on feature development instead of operational overhead.</st>
    <st c="16009">This reduction of cognitive load can lead to fewer context shifts
    for the team and, therefore, fewer mistakes and less stress.</st> <st c="16136">This
    way, an investment in a platform is an investment in the productivity and health
    of the</st> <st c="16229">development team.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16246">If we think back to our fictitious company, Financial One ACME,
    we can imagine how much more the cognitive load matters as it undergoes a cloud
    transformation strategy.</st> <st c="16416">Since the company is not building
    everything greenfield, its developers have to maintain legacy systems and architectures
    while also refactoring for the new era.</st> <st c="16578">A platform in support
    of this effort allows the developers to learn less.</st> <st c="16652">They just
    need to know what the platform expects from them as they approach their refactorization
    and</st> <st c="16754">migration strategy.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16773">A platform’s commitment to the reduction of cognitive load is
    essentially the promise to developers that you will help them to work more efficiently.</st>
    <st c="16924">Fewer context shifts, expedient and direct feedback loops, and ease
    of use all contribute to developer happiness.</st> <st c="17038">Happy developers
    are less stressed co-workers and contribute to a more positive work environment,
    making it a win-win for the development and</st> <st c="17180">platform teams.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17195">Utilizing a platform while balancing cognitive load</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="17247">While so much of a</st> <st c="17267">platform is serving to build
    an application, it must equally serve to operate the application as well.</st>
    <st c="17370">While the platform’s requirements should be well documented and
    easily understood, humans unfortunately are fairly error-prone; as such, it’s
    incumbent on the platform to enforce its norms.</st> <st c="17560">Kubernetes
    fortunately supports this natively to some degree, with admission controllers</st>
    <st c="17649">and</st> **<st c="17653">Role-Based Access Control</st>** <st c="17678">(</st>**<st
    c="17680">RBAC</st>**<st c="17684">), but you can also leverage tooling such as
    policy engines to ensure that workloads or actions that do not meet those norms
    are rejected and an error is given to the user.</st> <st c="17858">The sooner
    that feedback reaches the user, the lower their cognitive load, as they do not
    have to context-shift to respond to</st> <st c="17984">the platform.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17997">So, how are you supposed to reduce the cognitive load for your
    engineering teams with an internal</st> <st c="18096">developer platform?</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18115">If you don’t know where to begin, start with empathy as you consider</st>
    <st c="18185">implementation details.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18208">Suppose you are one of the engineers using the platform.</st>
    <st c="18266">It is 4 a.m., you are panicking, and nobody else is there to help.</st>
    <st c="18333">Ask yourself, “</st>*<st c="18348">Will this be easy to use?</st>*<st
    c="18374">” When you are satisfied with your approach, ask an engineer to validate</st>
    <st c="18448">your assumptions.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18465">Every detail should align with this principle.</st> <st c="18513">If
    core functionality is simple and makes life easier, users will not have to take
    on cognitive load.</st> <st c="18614">As you account for other aspects such</st>
    <st c="18652">as integrations, follow the same approach.</st> <st c="18696">Straightforward
    architectures are often the most effective.</st> <st c="18756">If “</st>*<st c="18760">Why
    is this architecture here?</st>*<st c="18791">” cannot be answered with “</st>*<st
    c="18819">Because it helps the user</st>*<st c="18845">,” perhaps it should not
    be there</st> <st c="18879">at all.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18886">There are still significant gains that can be made by fine-tuning
    the operations of the IDP.</st> <st c="18980">Additionally, by setting a bar for
    the applications that will run on the platform, your team can define a maturity
    model for them.</st> <st c="19111">That maturity model will help define what an
    application needs to be a successful member of the platform environment, which
    means that developers can work against it as a checklist, instead of needing to
    experiment, ask a human,</st> <st c="19340">or guess.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19349">Pre-production versus production</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="19382">A platform covers both</st> <st c="19405">pre-production</st>
    <st c="19420">and production for a software application.</st> <st c="19464">The
    part of the platform where the application</st> <st c="19510">lands is referred
    to as the</st> **<st c="19539">application</st>** **<st c="19551">landing zone</st>**<st
    c="19563">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19564">While a platform must consider both, the two should never mix,
    so the platform must enforce logical segmentations between the environments.</st>
    <st c="19705">It can do this via architecture or a policy.</st> <st c="19750">However,
    architecture is the best and most secure model, which we’ll cover further in</st>
    [*<st c="19836">Chapter 7</st>*](B31164_07.xhtml#_idTextAnchor381)<st c="19845">.
    In the current chapter, while we may make references to security best practices
    and segmentation strategies, the in-depth explanations can be found in</st> [*<st
    c="19998">Chapter 7</st>*](B31164_07.xhtml#_idTextAnchor381)<st c="20007">. The
    important takeaway for these environments in this chapter should be how they interact
    with cognitive load and how the platform aims to reduce that load across</st>
    <st c="20172">both scopes.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20184">Authentication and tenancy</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="20211">As your platform</st> <st c="20228">expands and gains adoption,
    it essentially becomes multi-tenant.</st> <st c="20294">This is due to the importance
    of ensuring a least privilege policy in a secure environment, as well as helping
    to ensure users don’t trip over each other.</st> <st c="20449">With</st> <st c="20454">multi-tenancy,
    it’s important to still give the feeling of a single tenancy, which means the
    existence of the other users and tenants must be hidden from</st> <st c="20608">each
    user.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20618">One of the first integrations you’ll add to the platform relates
    to authentication and user management.</st> <st c="20723">Most</st> **<st c="20728">OpenID
    Connect</st>** <st c="20742">(</st>**<st c="20744">OIDC</st>**<st c="20748">)
    providers</st> <st c="20760">can integrate into the common IDP toolchain, so selecting
    the correct one won’t be very difficult.</st> <st c="20860">From there, user management
    is pretty straightforward, although it differs between the common tools.</st>
    <st c="20961">For cognitive load, less is more, so one way for your users to authenticate
    across all aspects of a platform means fewer login workflows to remember, fewer
    logins per day, fewer passwords, and a homogenized experience with the rest of
    the tools in</st> <st c="21209">a company.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21219">Let’s look at this in a more realistic scenario.</st> <st c="21269">Financial
    One ACME is a bank.</st> <st c="21299">This means they’re in a highly regulated
    industry with a lot of very sensitive data to protect.</st> <st c="21395">Controlling
    who has access to what data and how they access it is one of the most important
    aspects of the company’s security and compliance story.</st> <st c="21543">It’s
    too much to expect users to remember to exercise all of those security and compliance
    practices perfectly every time.</st> <st c="21666">Thus, the platform needs to
    enforce</st> <st c="21702">that programmatically.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21724">Meeting those</st> <st c="21738">requirements in any industry,
    highly regulated or not, all comes down to</st> <st c="21812">RBAC – how you isolate
    users from each other and guarantee that they have the actions they need without
    the access they do not.</st> <st c="21940">Take a look at the following figure
    to see an example of a</st> <st c="21999">multi-tenant IDP.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4: Multi-tenancy on an IDP cluster](img/B31164_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="22265">Figure 6.4: Multi-tenancy on an IDP cluster</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22308">In this example, workloads from both tenants can share space on
    a node, but through RBAC, the tenants cannot see the other workloads on the same
    nodes where their workloads run.</st> <st c="22487">Another option would be to
    also ensure only one tenant’s workload can run on each node.</st> <st c="22575">However,
    that level of isolation can have negative trade-offs, as it could impact the</st>
    **<st c="22661">high availability</st>** <st c="22678">of those</st> <st c="22687">workloads,
    or require more nodes in order for tenants to have full isolation and high availability.</st>
    <st c="22788">We discussed high availability for a platform in</st> [*<st c="22837">Chapter
    3</st>*](B31164_03.xhtml#_idTextAnchor133)<st c="22846">, and those same principles
    apply to an application that your development team is working on.</st> <st c="22940">Just
    as with the platform, high availability is a characteristic of the resilience
    of an application.</st> <st c="23042">This might mean its ability to handle load
    through scaling, or just its general uptime.</st> <st c="23130">Things that impact
    high availability include location.</st> <st c="23185">While you might have three
    Pods in</st> <st c="23220">a</st> **<st c="23222">ReplicaSet</st>** <st c="23232">for
    an application, if all three of those Pods are on the same node and it is restarted
    (such as with upgrades to the platform), then the application goes down; therefore,
    it is not highly available.</st> <st c="23433">Typically, a highly available application
    will have its replicasets spread across multiple nodes, and if those nodes are
    all in different availability zones, then the application has another layer of
    resilience added to it.</st> <st c="23657">Developers following best practices
    for cloud-native platforms will typically expect their application to be highly
    available, which means at least two other replicasets running on</st> <st c="23838">different
    nodes.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23854">RBAC</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="23859">Regardless of the tenancy model, the kubernetes system RBAC will
    become the spine of self-service for a platform.</st> <st c="23974">You’ll use
    RBAC to restrict user access to the IDP for only the namespaces and environments
    where their workloads will land within the IDP.</st> <st c="24114">You’ll additionally
    have similar</st> <st c="24147">RBAC policies in the end user-facing environment
    where the application will run.</st> <st c="24228">The RBAC policies in the production
    environment will be less permissive than in the development environments, as it
    will be necessary to maintain a higher degree of scrutiny on those permissions.</st>
    <st c="24424">You’ll learn more about this in</st> [*<st c="24456">Chapter 7</st>*](B31164_07.xhtml#_idTextAnchor381)<st
    c="24465">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24466">Further reading</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24482">Kubernetes’ official documentation can be found</st> <st c="24531">here:</st>
    [<st c="24537">https://kubernetes.io/docs/reference/access-authn-authz/rbac/</st>](https://kubernetes.io/docs/reference/access-authn-authz/rbac/)<st
    c="24598">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24599">Borrowing an example from the official documentation, we can see
    an example of RBAC where a user who is assigned a role would have the capability
    to read secrets, but they would not be able to edit or</st> <st c="24801">delete
    them:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: <st c="25134">Similar to this example, by leveraging</st> <st c="25173">RBAC,
    you set your users up to successfully navigate a platform with appropriate guardrails
    in place.</st> <st c="25276">So, how do you determine what a robust RBAC policy
    needs to have to strike the balance between access, actions, and restrictions?</st>
    <st c="25406">This is where self-service takes center stage.</st> <st c="25453">Let’s
    look at some workflows that your users may expect to have on</st> <st c="25520">the
    platform.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5: Example workflows for IDP users](img/B31164_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="25535">Figure 6.5: Example workflows for IDP users</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25578">In the example illustrated in</st> *<st c="25609">Figure 6</st>**<st
    c="25617">.5</st>*<st c="25619">, we have multiple teams and, therefore, likely
    multiple users within the teams, reliant on the same systems within a platform.</st>
    <st c="25747">Sometimes, they will be reliant on the same systems at the same
    time.</st> <st c="25817">Depending on your CI/CD system of choice, best practices
    can vary; however, in general, the idea is that the platform team will ensure
    that the components required for the IDP are capable of scaling</st> <st c="26016">to
    users.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26025">The authentication system used for the Kubernetes cluster can
    be used for pre-production tools such as Argo CD as well, allowing users to leverage
    independent projects within the same Argo</st> <st c="26215">CD instance.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26227">While it’s not a best practice, it is technically possible to
    do the same access pattern for production-level access; however, when production
    is being accessed, it’s a best practice to have a much stricter set of authentications
    and an even more limited permission set once authenticated.</st> <st c="26518">We’ll
    cover this further in</st> [*<st c="26546">Chapter 7</st>*](B31164_07.xhtml#_idTextAnchor381)<st
    c="26555">,</st> *<st c="26557">Building a</st>* *<st c="26568">Secure Platform</st>*<st
    c="26583">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26584">Noisy neighbor prevention</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="26610">It may not immediately be obvious how a noisy neighbor</st> <st
    c="26665">can impact cognitive load, but the protection from such an event helps
    to prevent production incidents that can be difficult to troubleshoot and resolve,
    especially in an environment where multi-tenancy is the standard.</st> <st c="26886">It
    also helps users troubleshoot their applications or assists the platform team
    in troubleshooting production issues by ruling out scenarios that become less
    likely as more protections are put in place.</st> <st c="27090">Since your developer
    teams should expect to have limited access to the production side of an IDP, and
    no access to the metrics and workloads for other teams, all work done to prevent
    a noisy neighbor helps to ensure that those workloads are less likely to enter
    each team’s</st> <st c="27364">cognitive load.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27379">In the context of an IDP, a noisy neighbor means a workload that
    runs in the same environment as another and hogs resources, whether this is through
    an abundance of network traffic, CPU, or memory utilization, or other less-than-neighborly
    behaviors.</st> <st c="27631">Much like a city would have ordinances to prevent
    a neighbor from blocking off a street or playing music way too loud, a platform
    can enforce norms to ensure that one workload doesn’t negatively</st> <st c="27826">impact
    another.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27841">In many real-world scenarios, one Kubernetes cluster is utilized
    for multiple environments.</st> <st c="27934">For organizations with more limited
    cloud spend budgets, dev, QA, staging, and production environments may all be
    located on the same cluster.</st> <st c="28077">Technically speaking, an entire
    IDP could be one cluster.</st> <st c="28135">While this isn’t what we’d consider
    a best practice, it is an extremely common one, utilized to keep costs down.</st>
    <st c="28248">It’s in these scenarios where noisy neighbors are most likely to
    occur, but it can happen even when production is fully isolated, due to a workload
    either experiencing a software bug or just a higher than normal resource utilization
    for valid reasons.</st> <st c="28500">Containerized workloads have an advantage
    in protecting against noisy neighbor scenarios in these shared environments, in
    that those Pod and container definitions can hold the resource definitions, The
    encapsulation of the workload is a strength, particularly for resource management.</st>
    <st c="28785">While the vast majority of protections against noisy neighbor scenarios
    should happen as part of defensive programming for software applications, as well
    as through accurately benchmarking and identifying theresource need of those applications,
    a platform has the ability to be hardened</st> <st c="29072">as well.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29080">How can you achieve that hardening?</st> <st c="29117">Here’s
    how:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29128">Be mindful of the resources that are shared, even with workload
    isolation best practices enforced, such as etcd, the API server, and the</st>
    <st c="29266">networking stack</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="29282">Take preventative measures against</st> <st c="29318">CPU starvation</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="29332">Cluster autoscaling – the automatic addition (or removal)</st>
    <st c="29391">of nodes</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="29399">The care and feeding of etcd</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="29428">etcd is the key-value store that holds every definition for all
    the Kubernetes objects on a cluster – Pod definitions, job definitions, StatefulSets,
    DaemonSets,</st> **<st c="29591">CustomResourceDefinitions</st>** <st c="29616">(</st>**<st
    c="29618">CRDs</st>**<st c="29622">), and so</st> <st c="29632">on are all stored
    in etcd.</st> <st c="29660">This means it can get quite full as platform usage
    increases.</st> <st c="29722">An etcd project</st> <st c="29737">recommends a
    minimum set of resources allocated to the etcd Pods in order to guarantee successful
    production operations.</st> <st c="29859">The detailed recommendations can be
    found in the etcd docs (</st>[<st c="29919">https://etcd.io/docs/v3.6/op-guide/hardware/</st>](https://etcd.io/docs/v3.6/op-guide/hardware/)<st
    c="29964">) but the functional areas are disks, networking, CPU, and memory.</st>
    <st c="30032">As your cluster utilization grows, so too does the needs of etcd.</st>
    <st c="30098">Generally, the best practices for etcd include ensuring it has priority
    for CPU, networking, and dedicated disks, with high throughput and low latency.</st>
    <st c="30250">A</st> **<st c="30252">solid-state drive</st>** <st c="30269">(</st>**<st
    c="30271">SSD</st>**<st c="30274">) should be used for the etcd storage if possible.</st>
    <st c="30326">The etcd</st> <st c="30335">documentation has several suggestions
    for the tuning of etcd, so we won’t reiterate them here.</st> <st c="30430">It’s
    important to keep up with the latest recommendations from the project itself,
    as the technology will continue to evolve over time.</st> <st c="30566">Since
    etcd is a critical component to the successful operations of a Kubernetes cluster,
    watching it carefully with observability and proactively responding to evidence
    of disk pressure, or other resource issues, will be mission-critical to guarantee</st>
    <st c="30817">platform availability.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30839">Even after your etcd configuration is optimized, the actual usage
    or over usage of etcd can still result in noisy neighbors.</st> <st c="30965">The
    cloud-native CD system Argo CD, for example, stores its jobs as CRD entries, not
    as Kubernetes jobs.</st> <st c="31070">As the number of teams and deployments
    from Argo CD grows, so too does the number of entries in etcd.</st> <st c="31172">If
    etcd fills up, the Kubernetes API server goes down.</st> <st c="31227">To prevent
    this, care must be taken to ensure that etcd is healthy and not</st> <st c="31302">getting
    overfull.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31319">One method is to ensure that you’re pruning old</st> <st c="31367">CRD
    entries from etcd.</st> <st c="31391">In the case of Argo CD, this functionality
    is built natively into the app.</st> <st c="31466">In the case of standard Kubernetes
    jobs, a time-to-live mechanism can be utilized by applying the time desired, in
    sections, to the</st> `<st c="31598">spec</st>` <st c="31602">field of the job
    definition.</st> <st c="31632">With this, after the given amount of time has passed
    since the job has succeeded or failed, the garbage collection mechanism will run
    and remove the entry, thus managing the size and health</st> <st c="31822">of
    etcd.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31830">Similarly, other Kubernetes kinds have their own way of invoking
    a clean-up mechanism.</st> <st c="31918">For Deployments, there is a spec for</st>
    `<st c="31955">revisionHistoryLimit</st>`<st c="31975">, which will determine
    how many old versions of the Deployment will be stored.</st> <st c="32054">If
    the number is 0, then in the event of a production issue, the deployment cannot
    be rolled back, but etcd is clean as</st> <st c="32174">a whistle.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32184">Exactly how to tune these clean-up measures will be dependent
    on the number of users and the number of etcd entries that those users generate.</st>
    <st c="32328">The size of etcd will also be a factor, and that can be scaled by
    increasing the size of the control plane nodes.</st> <st c="32442">So, when to
    scale, when to prune, and when to consider adding a cluster to the IDP environment
    will be an exercise in cost management, ROI, and a fundamental part of the platform’s
    life cycle.</st> <st c="32635">It will also need to be a factor in the integrations
    you select for your IDP, but we’ll cover cost management more in</st> [*<st c="32753">Chapter
    8</st>*](B31164_08.xhtml#_idTextAnchor430)<st c="32762">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32763">Understanding the CPU and the scheduler to avoid starvation</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="32823">The next resource that is shared at the cluster scope, regardless
    of tenancy models, is the CPU.</st> <st c="32921">As previously</st> <st c="32935">mentioned,
    when we discussed reliability, in Kubernetes, there is a maximum amount of memory
    that can be used on a node object.</st> <st c="33063">All of the Pods and their
    memory requests are totaled, and if the total memory exceeds what is allocated
    to the node, a Pod will either be scheduled to a different node with available
    room or fail to be scheduled.</st> <st c="33277">If a Pod tries to use more memory
    than the node has available, it will be terminated and rescheduled.</st> <st c="33379">There’s
    a strict boundary on memory allocation along the nodes.</st> <st c="33443">A CPU,
    at a glance, appears to have the same functionality, but in reality, all CPUs
    are available to all nodes.</st> <st c="33556">This means that while app performance
    may be primarily a consideration of the development team, the developers shouldn’t
    have to worry about whether the platform can support the needs of an application.</st>
    <st c="33759">While the developer will need to inform the platform of the workload’s
    needs, the platform will need to be able to</st> <st c="33874">support it.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33885">The actual implementation for</st> <st c="33915">CPU management
    in Kubernetes is the</st> **<st c="33952">Completely Fair Scheduler</st>** <st
    c="33977">(</st>**<st c="33979">CFS</st>**<st c="33982">), which</st> <st c="33991">is
    the same one that</st> <st c="34012">the</st> **<st c="34017">Linux kernel</st>**
    <st c="34029">uses.</st> <st c="34036">Functionally, what this means is that workloads
    on a node can use more of a CPU than the node is allocated if the CPU</st> <st
    c="34154">is available.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="34167">While this capability to overcommit CPU can be useful, as it can
    technically support bin packing, allowing a platform to support more workloads
    as long as they’re not running simultaneously, and without needing to reserve
    more virtual hardware (or actual hardware if you’re running on bare metal), there
    are reasons why you might want to prevent some or all of the CPU from being utilized
    in this fashion, even if it’s</st> <st c="34587">technically available.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="34609">For example, in a production environment, there may be certain
    workloads that must always be performant or are particularly sensitive to CPU
    caching, while other operations could be a little slower or reschedule to new
    nodes more freely.</st> <st c="34848">For these situations, you can better guarantee
    CPU availability by altering the CPU</st> <st c="34932">manager policy.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="34947">To understand the full implementation of CPU management</st> <st
    c="35003">in Kubernetes, read the documentation</st> <st c="35042">here:</st>
    [<st c="35048">https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/</st>](https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/)<st
    c="35124">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="35125">The platform will need to enable CPU management policies in the
    kubelet configuration in order for CPUs to be excluded from the pool.</st> <st
    c="35260">You will have to define how much CPU to reserve, but you can reserve
    all of the CPU, minus what is needed to run the Kubernetes-critical workloads.</st>
    <st c="35408">In order to get the desired outcome, where a Pod is guaranteed the
    CPU it needs at the expense of other Pods, the developer will need to specify
    both requests and limits as whole integers in the Pod spec, and those two values</st>
    <st c="35634">must match.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="35645">Here’s an example</st> <st c="35664">Pod spec:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: <st c="35864">Once your node is configured in this way, it is known as</st>
    *<st c="35922">guaranteed</st>* <st c="35932">by the platform and, therefore,
    is able to use exclusive</st> <st c="35989">CPU.</st> <st c="35995">The</st> **<st
    c="35999">kube-scheduler</st>** <st c="36013">(</st>**<st c="36015">scheduler</st>**
    <st c="36024">for short) will prioritize it being on nodes that</st> <st c="36074">support
    the CPU needs of the Pod.</st> <st c="36109">If that’s only one</st> <st c="36127">node,
    then the scheduler will prioritize that; however, if you have multiple or all
    nodes configured to use exclusive CPU, then although the priority of the Pod will
    be high and, therefore, less likely to be moved (except in more extreme cases),
    it could still be placed on a</st> <st c="36404">new node.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36413">To ensure that a specific node is always selected, or a specific
    type of node is always selected, you can label nodes.</st> <st c="36533">Doing
    so helps the scheduler to match Pods to nodes with labels defined in the Pod spec.</st>
    <st c="36622">This further ensures the correct Pod placement, which has use cases
    beyond noisy neighbor prevention</st> <st c="36723">as well.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36731">If you’ve decided to follow along with a local kind cluster and
    haven’t already, let’s set up the cluster now.</st> <st c="36843">First, clone
    the GitHub repository for the book and change the directory to the one for</st>
    [*<st c="36931">Chapter 6</st>*](B31164_06.xhtml#_idTextAnchor341)<st c="36940">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: <st c="37153">After your cluster-named platform is created, set the context
    to the kind cluster for the chapter.</st> <st c="37253">This removes the need
    to add</st> `<st c="37282">--context kind-platform</st>` <st c="37305">to the
    end of each</st> `<st c="37325">kubectl</st>` <st c="37332">command:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: <st c="37390">Now that we’ve made our lives a little easier, we can begin the
    Pod</st> <st c="37459">labeling demo.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="37473">Here’s the node label command and</st> <st c="37508">example output:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: <st c="37610">Run this command to see the label on</st> <st c="37648">the node:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: <st c="37950">Our final</st> <st c="37960">Pod will look something</st> <st
    c="37985">like this:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: <st c="38315">Important note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38330">In order for the CPU management policy to be enforced on previous
    workloads and new workloads, you have to drain the node and</st> <st c="38457">restart
    it.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38468">Outside of the CPU, the</st> <st c="38492">scheduler looks at
    several other different factors to determine how to prioritize or move Pods, including
    an explicit Pod priority.</st> <st c="38625">If Pod priority is not well understood
    or the tenancy of a platform is not well known, it may not be immediately obvious
    to an engineer why they should not place a high priority on their application
    Pods.</st> <st c="38830">As far as a developer is concerned their production application
    is probably the most important workload.</st> <st c="38935">However, this can
    create noisy neighbor situations if not used well.</st> <st c="39004">One over-prioritized
    Pod seems harmless.</st> <st c="39045">In practice, it is a constant denial-of-service
    attack that worsens with scale.</st> <st c="39125">If the Pod is assigned to a
    replicaset and the instances of it grow with the cluster, then there’s a growing
    number of over-prioritized workloads.</st> <st c="39272">If this problem spreads
    to more than one Pod, then the problem compounds.</st> <st c="39346">This degrades
    the platform service, strains underlying hardware, and impairs troubleshooting.</st>
    <st c="39440">Therefore, the platform may want to limit or prevent such assignments.</st>
    <st c="39511">This can be done with the enforcement of quota or</st> <st c="39561">admission
    controllers.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="39583">We’ll cover quota and admission controllers later in this chapter.</st>
    <st c="39651">However, if Pod priority is something you’d like to use in a platform,
    here are the general steps necessary to</st> <st c="39762">enable it:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="39772">First, create a</st> <st c="39789">priority class.</st> <st c="39805">This
    kind is not scoped to namespaces but is more generally available cluster-wide.</st>
    <st c="39889">Create the class by saving the following content to a YAML file</st>
    <st c="39953">called</st> `<st c="39960">priority.yaml</st>`<st c="39973">:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="40196">Next, apply the</st> <st c="40213">priority class:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="40324">Now, when we create a Pod, we can select that priority.</st> <st
    c="40381">Save the following</st> <st c="40400">as</st> `<st c="40403">pod.yaml</st>`<st
    c="40411">:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="40770">After saving the</st> <st c="40788">Pod, create it with</st> `<st
    c="40808">kubectl create</st>`<st c="40822">:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="40871">There are many other tuning options within Kubernetes to ensure
    that the scheduler makes the decisions you’d prefer.</st> <st c="40989">It is
    also possible to run an additional scheduler profile or to replace the default
    scheduler entirely with a customer profile that abides by</st> <st c="41132">different
    rules.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41148">This is a pretty advanced operation, as it requires a deep understanding
    of how the scheduler works and how you need to change it to optimize the platform.</st>
    <st c="41305">However, if you do decide that this is necessary, we’d recommend
    starting with an additional profile before replacing</st> <st c="41423">the default.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41435">Important note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41450">For OpenShift users, while the end result is the same, the process
    of implementing an exclusive CPU in OpenShift is slightly different and leverages
    machine sets.</st> <st c="41614">Check the latest OpenShift Container Platform
    docs for up-to-date instructions on this topic for</st> <st c="41711">that product.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41724">Rate limiting and network health</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="41757">Rate limiting</st> <st c="41771">is the capping of network</st>
    <st c="41797">traffic or HTTP requests that a service will respond to from a requestor.</st>
    <st c="41872">Each response has a computational cost, so rate limiting acts as
    a protective measure against endpoints being exploited, either intentionally or
    through</st> <st c="42025">an error.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="42034">A common takedown of a system is</st> <st c="42068">a</st> **<st
    c="42070">Distributed Denial-of-Service</st>** <st c="42099">(</st>**<st c="42101">DDoS</st>**<st
    c="42105">) attack.</st> <st c="42116">While such an attack can be initiated by
    a bad actor, it can also be carried out by accident due to human error or a buggy
    piece of software.</st> <st c="42258">DDoS is the most classic example of a noisy
    neighbor.</st> <st c="42312">Computationally expensive, it can be executed either
    via sheer number of requests floodi</st><st c="42400">ng the networking layer,
    spending compute, or through requests that would result in data returns that are
    astronomically large or computationally expensive</st> <st c="42557">to get.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="42564">Rate limits can be implemented to prevent a large number of back-to-back
    calls from creating a noisy neighbor scenario.</st> <st c="42685">This can be
    handled in the cluster ingress, such as nginx.</st> <st c="42744">But there are
    also discreet Kubernetes features within the API server that can be leveraged</st>
    <st c="42836">as well.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="42844">On the API server itself, your team can set API priority and fairness
    rules to help prevent traffic flooding.</st> <st c="42955">This is especially
    important if the noisy neighbor situation is coming from an internal source, meaning
    that cluster ingress is not a factor.</st> <st c="43097">For example, if a backup
    job is misconfigured and it’s trying to query data from within a cluster to create
    backups, or push them too often, applying rate limits can help prevent this job
    from flooding the network layer.</st> <st c="43318">By default, basic priority
    and fairness rules are enabled, although it is possible to alter or disable the
    rules entirely if desired.</st> <st c="43452">However, that’s</st> <st c="43468">not
    recommended.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43484">Cluster scaling and other policies</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="43519">What other policies prevent noisy neighbor situations?</st> <st
    c="43575">Autoscaling</st> <st c="43586">is the most obvious to the authors, although
    there are surely many more.</st> <st c="43660">All of the tuning and planning
    for how to pack workloads onto the platform only goes so far, without the cluster
    ultimately needing to grow (or shrink) in size.</st> <st c="43821">The most classic
    of all noisy neighbor scenarios is caused simply by a platform too small to meet
    the demand of</st> <st c="43933">its users.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43943">Where the resource constraints are in the platform will determine
    how the cluster should scale.</st> <st c="44040">If additional resources are needed
    for non-system components that run on worker nodes, then adding another node to
    the cluster will do the trick.</st> <st c="44186">However, if, despite previous
    efforts, etcd is filling up or the API server encounters constraints, a larger
    control plane</st> <st c="44309">is necessary.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44322">Observability data is the</st> <st c="44349">best measure for
    when and how to scale a cluster.</st> <st c="44399">This data can be collected
    on compute resource utilization by workloads and workload performance.</st> <st
    c="44497">As utilization increases, if thresholds for remaining resources are
    met or exceeded, a cluster scaling event can be triggered.</st> <st c="44624">Your
    observability can also be used even more creatively.</st> <st c="44682">A common
    technical interview question is a troubleshooting problem.</st> <st c="44750">The
    solution is always that a cron job uses too many resources and causes system crashes.</st>
    <st c="44840">With observability in place, you don’t need a human to discover
    that; you can use data.</st> <st c="44928">Significant spikes in resource utilization,
    either on the Pod or node level, can be captured and alerted on.</st> <st c="45037">But
    if you needed to respond to an alert, then this is also an opportunity</st> <st
    c="45112">for automation.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45127">And finally, if all else fails, you can use an event-driven system
    to react to the data collected by the observability stack to restart the faulty
    Pod.</st> <st c="45280">This works and should keep the mission-critical components
    going, but it doesn’t replace a human permanently fixing whatever caused the resource
    utilization to</st> <st c="45440">begin with.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45451">In short, maintaining cluster health and appropriate user and
    workload isolation is key to ensuring that users of a platform can focus on what
    matters most to them, helping us to lay the foundation for the next aspect of
    a successful platform –</st> <st c="45697">self-service.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45710">Enabling self-service developer portals</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="45750">We’ve already stated that a</st> <st c="45779">platform is not
    a platform if self-service isn’t a core tenant of its design.</st> <st c="45857">Now,
    it’s time to understand what that means and how it pertains to the promised reduction
    of cognitive load.</st> <st c="45967">The platform team can’t be on hand to approve
    everything all the time.</st> <st c="46038">As such, it is imperative to put some
    control into the hands of end users, without failing to save them from an increase
    in cognitive load.</st> <st c="46178">This dichotomy requires striking a careful
    balance, which must be discussed and negotiated between the stakeholders to be
    successful.</st> <st c="46312">A platform team trying to control everything too
    tightly prevents the platform from scaling with the users, as it’ll always be
    limited to the size and location of the team.</st> <st c="46485">This means it’s
    time to think about how you help your users help themselves.</st> <st c="46562">What
    should a developer or team be able to do without higher levels of approval?</st>
    <st c="46643">What should be restricted?</st> <st c="46670">How do you enable
    sensible self-service, and how do you enforce reasonable restrictions?</st> <st
    c="46759">We’ve discussed the importance of treating your platform like a product,
    but functionally, the product type is a service.</st> <st c="46881">Any product
    sold “as a service” comes not just with a guarantee of features but also a guarantee
    of engagement and experience from the company selling</st> <st c="47032">the</st>
    **<st c="47036">Software as a Service</st>** <st c="47057">(</st>**<st c="47059">SaaS</st>**<st
    c="47063">) or</st> **<st c="47069">Platform as a Service</st>** <st c="47090">(</st>**<st
    c="47092">PaaS</st>**<st c="47096">).</st> <st c="47100">Even if you’re</st> <st
    c="47114">not selling your PaaS, you should adopt the mindset of service to ensure
    that users are at the center of your</st> <st c="47225">usability considerations.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="47250">Simply put, self-service</st> <st c="47276">means that a user
    can accomplish a reasonable action with reasonable ease, without negatively impacting
    unrelated users or teams.</st> <st c="47406">Understanding self-service as it
    pertains to your platform requires understanding the needs of your users.</st>
    <st c="47513">It’s important to meet your users where they are.</st> <st c="47563">If
    your users are of the kind that spend their whole day on a command</st> <st c="47632">line,
    a</st> **<st c="47641">command-line interface</st>** <st c="47663">(</st>**<st
    c="47665">CLI</st>**<st c="47668">) may be the tool they need most to get the</st>
    <st c="47713">job done.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="47722">However, if your IDP is being used for docs as code instead, in
    addition to code as code, it’s probable that the team leveraging it may benefit
    from a UI instead of</st> <st c="47888">a CLI.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="47894">How does the end user want to accomplish their goals?</st> <st
    c="47949">How does the end user want to receive feedback from platform jobs?</st>
    <st c="48016">When we approach self-service, these are the questions we need to
    ask.</st> <st c="48087">Generally speaking, the platform team should have parameters
    that the developers can operate within.</st> <st c="48188">For example, you can
    guarantee that certain workloads only land in certain locations, and you can tie
    resource (memory and CPU) limits to namespaces within your</st> <st c="48349">Kubernetes
    cluster.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48368">Tip</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48372">Once you begin down this path to fine-tune how workloads land
    and consume resources, it starts influencing cluster capacity artificially.</st>
    <st c="48511">It’s important to only implement this strategy when it becomes truly
    necessary, or after creating a comprehensive cluster scaling and</st> <st c="48645">capacity
    plan.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48659">Enforcing quota</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="48675">A user or team</st> <st c="48691">should be able to land their
    application within the application landing zone.</st> <st c="48769">However, they
    should not be able to do this without reasonable restrictions.</st> <st c="48846">These
    restrictions, such as resource consumption, can be limited to a per-namespace
    basis.</st> <st c="48937">This is done by specifying the kind ResourceQuota.</st>
    <st c="48988">You’ll make a YAML file and apply it to the namespace.</st> <st
    c="49043">Continue reading to see what it will</st> <st c="49080">look like.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="49090">First, create a YAML file; let’s call</st> <st c="49129">it</st>
    `<st c="49132">your-dev-quota.yaml</st>`<st c="49151">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: <st c="49385">Save the file, and now apply the YAML to the namespace.</st> <st
    c="49442">Your command will look something</st> <st c="49475">like this:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: <st c="49553">Now, your developer can schedule any Pods within their namespaces
    as they need to, but the workloads have to stay within the quota boundaries provided
    to them.</st> <st c="49714">The creation of a quota for namespaces helps to enable
    multi-tenancy within a platform.</st> <st c="49802">Divvying up resources to users
    in a way that utilizes cluster capacity without over-taxing it allows users to
    operate independently, but within</st> <st c="49946">reasonable boundaries.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="49968">Quotas can also be managed with GitOps, thereby streamlining requests
    to increase quota or alter quotas from users.</st> <st c="50085">If the process
    for a user to adjust their quota is raising a</st> **<st c="50146">pull request</st>**
    <st c="50158">(</st>**<st c="50160">PR</st>**<st c="50162">) and then</st> <st
    c="50173">waiting for it to be</st> <st c="50194">approved, this makes it much
    easier for them to interact with a platform.</st> <st c="50269">Ease of use will
    be a large factor in the platform’s success within</st> <st c="50337">an organization.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="50353">Simple repeatable workflows</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="50381">We talked about the</st> <st c="50402">importance of simple workflows
    for reducing cognitive load, and truly, this is a topic we could have stuck anywhere
    in this chapter.</st> <st c="50535">However, this aligns most with self-service,
    as it is a core feature.</st> <st c="50605">For a platform to deliver on the promise
    of self-service, it must be easy to use, and the uses must be easy</st> <st c="50713">to
    remember.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="50725">We refer again to our golden path.</st> <st c="50761">A developer
    building an app pushes a commit.</st> <st c="50806">The change makes its way through
    the CI/CD systems until, ultimately, the app install or upgrade lands in the application
    landing zone.</st> <st c="50942">The journey for that PR must be easy to understand,
    intuitive, and predictable for the development team.</st> <st c="51047">If the
    team needs to make changes to the CI jobs, or the CD logic specific to their application,
    then they should expect to have easy access to the governing systems to do</st>
    <st c="51219">just that.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="51229">Let’s bring back our teams for Financial One ACME.</st> <st c="51281">We
    can expand this example one step further and imagine again that the company includes
    multiple personas or user types.</st> <st c="51402">If we consider a development
    team and a corresponding docs team, what would each team need from the</st> <st
    c="51502">CI system?</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="51512">It’s safe to say both teams need the ability to land their jobs
    within the system, to understand whether jobs are successful or failed, and to
    know whether the overall CI pipeline succeeded or failed.</st> <st c="51714">However,
    they may have different needs for interacting with the CI system.</st> <st c="51789">A
    developer or a DevOps engineer may prefer to use a CLI, whereas a docs team or
    a non-technical team may prefer</st> <st c="51901">a</st> **<st c="51904">graphical
    user interface</st>** <st c="51928">(</st>**<st c="51930">GUI</st>**<st c="51933">)
    to leverage</st> <st c="51948">a system.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="51957">The open source CI/CD projects Tekton and Argo CD both ship with
    a GUI.</st> <st c="52030">Both systems also can leverage CLI tools designed to
    interface with the project.</st> <st c="52111">For users of the systems, as long
    as they’ve been granted correct access, they can choose their own adventure for
    the actual interactions with these systems and can determine which is easier,
    keeping a CLI up to date locally or using a GUI occasionally.</st> <st c="52365">By
    being flexible, these tools and your IDP, should you adopt them, enable users
    to self-service based on</st> <st c="52471">their ease.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="52482">However, with something such as</st> <st c="52514">CI pipelines,
    which may take significant time to complete, other options such as API calls or
    Webhook integrations into common tools such as Slack may more easily meet the
    users where they are.</st> <st c="52709">Just as with inputs, the platform should
    meet users where they are for outputs, as the fewer times your users have to context-shift,
    the lower their cognitive load and the easier self-service goals</st> <st c="52907">are
    achieved.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="52920">Important note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="52935">A CI pipeline</st> <st c="52949">is typically a series of jobs;
    some run synchronously, and some run asynchronously to build and validate an application
    based on recent changes.</st> <st c="53095">This could be one PR at a time (CI
    at its core), but it could also be less frequent, such</st> <st c="53185">as daily.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="53194">Even highly technical users love a good GUI, and if they’re already
    interfacing with something such as GitHub or GitLab for a PR review, they may
    not feel like changing paradigms again.</st> <st c="53381">So, while the average
    user may never need to see the internals of the Kubernetes clusters they’re interacting
    with, we did say that the platform should drink its own champagne.</st> <st c="53558">This
    includes best practices such as meeting users where they are.</st> <st c="53625">Some
    Kubernetes solutions such as OpenShift ship with a GUI layer included.</st> <st
    c="53701">For the ones that do not, Lens (</st>[<st c="53733">https://k8slens.dev/</st>](https://k8slens.dev/)<st
    c="53754">) provides</st> <st c="53765">an</st> <st c="53769">easy-to-use GUI.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6: The Lens GUI connected to a local kind cluster representing an
    IDP](img/B31164_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="56728">Figure 6.6: The Lens GUI connected to a local kind cluster representing
    an IDP</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="56806">To summarize, developer self-service is about meeting your users
    where they are and giving them the tools to be successful with a platform.</st>
    <st c="56947">Tshis means understanding their needs but also giving them the capabilities
    to integrate the platform to their way of working, not making their way of working
    fit</st> <st c="57110">the platform.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="57123">Landing, expanding, and integrating your IDP</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="57168">If you followed our recommendations in</st> [*<st c="57208">Chapter
    3</st>*](B31164_03.xhtml#_idTextAnchor133)<st c="57217">, you’ve interviewed the
    users, you’ve mapped the use cases, and you’ve designed your platform.</st> <st
    c="57313">Now comes the fun part – turning it into</st> <st c="57354">something
    real.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="57369">Let’s look at the most basic IDP.</st> <st c="57404">What does
    it do?</st> <st c="57421">Most importantly, users can authenticate to it with
    appropriate access and permissions.</st> <st c="57509">It has a CI system, a CD
    system, at least some basic security tooling such as scanning, and these days,
    something to generate an SBOM.</st> <st c="57644">What about the production location
    for the software that the developers are writing?</st> <st c="57729">Where is
    that?</st> <st c="57744">How does the promotion process look?</st> <st c="57781">Let’s
    look again at our IDP golden path from earlier in</st> *<st c="57837">Figure 6</st>**<st
    c="57845">.3</st>*<st c="57847">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="57848">There are a lot of pieces in this drawing, and software development
    should be iterative, which means we’re not going to be landing everything seen
    here all at once.</st> <st c="58014">So, let’s look at landing an IDP.</st> <st
    c="58048">What does the thinnest viable platform</st> <st c="58087">look like?</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="58097">It’s probably something</st> <st c="58122">like this:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="58132">Authentication</st> <st c="58148">and RBAC</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="58156">Security checks</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="58172">CI/CD</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="58178">An application</st> <st c="58194">landing zone</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="58206">Technically, a CD system isn’t necessary, as long as there’s some
    promotion process for application features and enhancements to reach production.</st>
    <st c="58354">With such a scaled-down approach, or thinnest viable platform, it’s
    fairly easy to see how to land an IDP within an organization.</st> <st c="58484">The
    appeal of a new and shiny product may even drive users to play with it and help
    drive initial adoption.</st> <st c="58592">However, keeping those users engaged
    and attracting the more reticent will require expanding upon the initial offering
    and ensuring that what users use is easy to understand</st> <st c="58766">and
    performant.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="58781">Expanding your IDP, though – how does that look?</st> <st c="58831">Expansion
    may look something like capacity planning, but how will you scale and size your
    resources as the adoption of the platform grows?</st> <st c="58970">In Kubernetes,
    this will mean figuring out cluster sizing and/or</st> <st c="59035">cluster count.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="59049">The expansion will also include features and enhancements, as
    well as planning not just for the development and rollout but also the operations
    of those enhancements.</st> <st c="59217">What are the impacts on the platform
    of adding another feature or integration?</st> <st c="59296">How do you measure
    the success of an enhancement, and how do you use data to determine its return</st>
    <st c="59394">on investments?</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="59409">Enforcement of platform-specific standards</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="59452">If we refer back to the</st> <st c="59477">beginning of the chapter,
    we mentioned that it’s important that platform-specific standards are easy to
    consume for end users, helping to guarantee a low cognitive load, and that this
    must include the enforcement of</st> <st c="59693">those standards.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="59709">There’s no one set way to do this, since norms can differ from
    platform to platform.</st> <st c="59795">However, we have found that there are
    a few things that work well in terms of both process and technology for you to
    adapt to</st> <st c="59921">your organization.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="59939">Maturity models</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="59955">Maturity models fall</st> <st c="59976">slightly more into the
    sociotechnical aspect of cognitive load reduction.</st> <st c="60051">Defining
    maturity models for software applications as they onboard to a platform can help
    developers know they’re building out their application in the right way.</st>
    <st c="60214">This also helps to ensure that the reduction of cognitive load doesn’t
    result in a worse experience for end users, due to something being overlooked
    or forgotten.</st> <st c="60377">Essentially, it ensures that the interests of
    both parties are aligned from a</st> <st c="60455">platform perspective.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="60476">An example of a standard for maturity would be that a new application
    would only onboard to a platform after it has been configured for high availability
    and disaster recovery, if it has unit tests, or if the team has written and committed
    their Prometheus queries and Grafana dashboards for application observability.</st>
    <st c="60796">These types of models can be enforced with CI jobs that check for
    the presence of whatever is deemed appropriate by the platform, or they could
    simply be published as guidelines for a team</st> <st c="60985">to follow.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="60995">Expanding a platform with common platform integrations</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="61050">Taking a platform beyond the thinnest viable platform and into
    a robust system will require leveraging new integrations and better harnessing
    the initial feature sets.</st> <st c="61219">Some common and useful integrations
    are outlined in</st> <st c="61271">this section.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="61284">Static analysis</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="61300">How does a user know whether they’re matching with expected maturity
    models and</st> <st c="61381">platform norms?</st> <st c="61397">How do they receive
    feedback if they are not?</st> <st c="61443">One method for establishing this
    enforcement and feedback loop with users is via static analysis.</st> <st c="61541">When
    the development team submits a PR, then CI jobs kick off.</st> <st c="61604">It
    is during the first CI jobs that a static analysis tool is best positioned; this
    way, if the PR fails, the check compute is not spent needlessly on running tests
    or generating SBOMs, and the feedback loop to the end user raises the error much
    faster.</st> <st c="61858">Reducing time to feedback helps to keep developer velocity
    high and cognitive load low, since developers don’t need to remember to check
    back with the platform after a</st> <st c="62026">significant delay.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="62044">Example</st> <st c="62052">static analysis tools that can be leveraged
    at PR time are security audits that compare image versions to known</st> **<st
    c="62165">Critical Vulnerability Exploits</st>** <st c="62196">(</st>**<st c="62198">CVEs</st>**<st
    c="62202">) to</st> <st c="62208">ensure that vulnerable code is not being pushed.</st>
    <st c="62257">At the time of writing,</st> **<st c="62281">Snyk</st>** <st c="62285">is
    a</st> <st c="62291">popular choice for this, as it is open source and has free</st>
    <st c="62350">options.</st> **<st c="62359">CodeQL</st>** <st c="62365">is another
    popular choice and is also free for open source projects, so it’s very easy to
    find examples of it in use.</st> <st c="62484">Both of these tools are popular
    because they integrate well with</st> <st c="62549">GitHub workflows.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="62566">For the enforcement of norms, however, there are also static</st>
    <st c="62627">analysis tools that verify whether an application conforms to cloud-native
    best practices.</st> <st c="62719">From the</st> **<st c="62728">StackRox</st>**
    <st c="62736">community,</st> **<st c="62748">KubeLinter</st>** <st c="62758">is
    an</st> <st c="62764">excellent example of this.</st> <st c="62792">It ships with
    a variety of checks but can be configured to skip checks that are not desired
    for a platform, or to accept</st> <st c="62913">custom checks.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="62927">Both the aforementioned static analysis tools leverage GitHub
    workflows, which are declarative YAML to define what actions should happen within
    a repository once a PR is raised.</st> <st c="63106">For example, to run KubeLinter
    against the main branch of a repository with GitHub workflows, a</st> `<st c="63202">.github/workflows</st>`
    <st c="63219">directory would be added to the GitHub repository, and then a YAML
    file would be committed to it.</st> <st c="63318">That YAML would look something
    like this</st> `<st c="63359">kubelint.yaml</st>` <st c="63372">file:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: <st c="63834">Admission controllers and policy agents</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="63874">Admission controllers</st> <st c="63896">are another feature of
    Kubernetes.</st> <st c="63932">They come in two flavors, validating and</st> <st
    c="63973">mutating Webhooks.</st> <st c="63992">Both reduce cognitive load and
    also enable self-service.</st> <st c="64049">However, they’re fairly advanced
    topics and may not be part of your platform MVP, or even in the top five integrations.</st>
    <st c="64169">As the platform itself evolves in maturity, these features can</st>
    <st c="64232">be adopted.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="64243">If a mutating Webhook allows a platform to enforce a norm such
    as an environment variable transparently to the user, this allows them to worry
    less about the platform itself and more about the application.</st> <st c="64450">Then,
    if the environment variable changes, the developer doesn’t need to do anything
    differently on their side.</st> <st c="64562">A validating Webhook checks that
    the object being applied matches the expected parameters.</st> <st c="64653">You
    can leverage both types against workloads, and generally, you should always use
    a validation Webhook if you’re using a mutating Webhook to ensure that nothing
    else has incorrectly modified the object after the Webhook</st> <st c="64875">has
    responded.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="64889">Admission controllers are</st> <st c="64916">powerful but somewhat
    complex.</st> <st c="64947">They require setting up a server to run the controller
    and the Webhooks and responses to be written.</st> <st c="65048">Due to their
    size and complexity, relative to other methods of enforcing platform norms, they’re
    not suitable for a new IDP, but for large organizations with many users, they
    can become a</st> <st c="65236">powerful tool.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="65250">Admission controllers can be bespoke, but open source</st> <st
    c="65304">policy agents such</st> <st c="65323">as</st> **<st c="65327">Open Policy
    Agent (OPA)</st>** <st c="65350">or</st> **<st c="65354">Kyverno</st>** <st c="65361">leverage</st>
    <st c="65371">the same features and can help simplify their usage.</st> <st c="65424">Leveraging
    policy-based norms can help platform performance and prevent collisions</st> <st
    c="65507">between workloads.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="65525">Observability</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="65539">To be covered in greater depth in the next section, observability</st>
    <st c="65605">is something that should exist from day one in the IDP and can and
    will be expanded.</st> <st c="65691">Observability should be considered a living
    integration, meaning that it is always being grown and modified to match the life
    cycle of</st> <st c="65826">a platform.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="65837">Some common observability tools are</st> <st c="65874">Prometheus,
    Grafana, and Loki, and they can be used individually but are better configured
    in conjunction with</st> **<st c="65985">OpenTelemetry</st>** <st c="65998">(</st>**<st
    c="66000">Otel</st>**<st c="66004">) and the Otel protocol.</st> <st c="66030">When
    you combine these with Thanos for long-term storage, you can give yourself a little
    more data to analyze as well, which can be nice to understand the context and
    history of</st> <st c="66208">observability data.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="66227">Respectively, these tools specialize in metric queries against
    Kubernetes objects as well as analysis of those metrics, visualization of metrics,
    and log aggregation.</st> <st c="66395">Additionally, this toolset can be used
    by single tenants with multiple users, or as a multi-tenant tool.</st> <st c="66500">The
    user authentication and RBAC for the IDP can be leveraged for these, just as they
    could with the CI/CD solutions we</st> <st c="66620">discussed previously.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="66641">The MVP of a platform and its golden path should be the main focus
    of the initial observability implementation.</st> <st c="66754">Observability
    should be done in a way to measure user satisfaction, and</st> **<st c="66826">Service-Level
    Objectives</st>** <st c="66850">(</st>**<st c="66852">SLOs</st>**<st c="66856">)
    directly</st> <st c="66868">maps to a user’s success with the platform.</st> <st
    c="66912">Therefore, as a best practice, make sure that the core components of
    the golden path are available, have a set target for success and latency, and
    ensure that the platform team can leverage observability to make data-informed
    decisions, including tracking usage of certain features and the failure</st> <st
    c="67210">rates within.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="67223">As an example, let’s say that Financial One ACME initially shipped
    a new platform MVP, with Tekton included for CI and Argo CD for CD.</st> <st c="67359">But
    thanks to the observability stack, the platform team can see that only 1% of users
    leverage the Tekton integration.</st> <st c="67479">This is an indicator that
    the CI needs are being met elsewhere.</st> <st c="67543">Thanks to this data,
    the team can take the decision to deprecate the Tekton deployment and reclaim
    some cluster capacity, while letting users continue to work in their preferred
    way.</st> <st c="67726">Alternatively, they could work to understand why the feature
    of the platform isn’t being used and seek to help users adopt the new</st> <st
    c="67857">CI system.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="67867">Integrating your platform</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="67893">Integration of the platform</st> <st c="67921">doesn’t just mean
    integrating components with each other; it also means integrating the IDP into
    a company’s way of working.</st> <st c="68047">This entails a service-first culture,
    user-centricity, feedback loops for operational excellence, and meeting users
    where</st> <st c="68169">they are.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="68178">Once again, we will go back to Financial One ACME.</st> <st c="68230">This
    company needs to balance both a new-age technology stack and a legacy stack.</st>
    <st c="68312">An opportunity exists here to meet these users where they are by
    integrating the existing workflows for authentication into the new platform.</st>
    <st c="68454">If they’re already using GitHub or GitLab, they’re likely using
    some kind of single sign-on, which should be compatible with any</st> <st c="68583">Kubernetes-based
    IDP.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="68604">Integration into a company’s way of working may mean certain options
    to solve some problems don’t meet the users’ needs at this time.</st> <st c="68739">For
    example, if the reason for low Tekton adoption in the Financial One ACME development
    team was because GitHub workflows with Argo CD are capable of handling all of
    their CI/CD needs, then that integration with Tekton may be an effort with a low
    return.</st> <st c="68995">Developers who are refactoring a monolith may find
    more benefit from being able to use a shared CI tool.</st> <st c="69100">This
    would help them to create a common set of tests, and checks between the old monolithic
    system and new system, ensuring that they’re maintaining parity during the transition.</st>
    <st c="69279">In the example of low Tekton adoption, an upfront analysis of the
    decision may prevent wasted time, instead that time may be better spent on the
    integration of a data transformation tool such as Apache Airflow or</st> <st c="69492">Argo
    Workflows.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="69507">Since successful IDP adoption is going to be data-driven, a key
    aspect of this will be</st> **<st c="69595">observability</st>**<st c="69608">.
    The</st> <st c="69613">observability of a platform will help to drive its value
    to consumers and the team that must</st> <st c="69707">maintain it.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="69719">Architectural considerations for observability in a platform</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="69780">Self-service and cognitive load – we’ve already alluded to the
    importance of observability in these topics.</st> <st c="69889">Your platform
    cannot act in service to its users without observability prioritized.</st> <st
    c="69973">In other words, you should expect to watch and</st> <st c="70020">measure
    everything.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="70039">Observability</st> <st c="70054">comes in two flavors; the first
    is observability for the benefit of the platform team.</st> <st c="70141">This
    is the way the platform team will collect data and information to help build their
    reliability.</st> <st c="70242">Using the site reliability practices of SLOs,
    the platform team can measure customer satisfaction by setting SLOs for the platform
    and then creating observability in support</st> <st c="70416">of them.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="70424">The good news is that, in the Kubernetes world, this is easier
    because of objects and microservices.</st> <st c="70526">The bad news is that
    there are a lot more things to measure than ever before due to microservices,
    and it’s hard to know whether you’ve captured everything.</st> <st c="70683">Your
    observability should have a life cycle, like your software.</st> <st c="70748">Start
    with good, iterate to better, and realize that observability is a living thing
    that will likely never reach a</st> <st c="70864">completed state.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="70880">There’s a standard observability toolbox in Prometheus, Grafana,
    Loki, and other</st> **<st c="70962">Free Open Source Software</st>** <st c="70987">(</st>**<st
    c="70989">FOSS</st>**<st c="70993">) projects</st> <st c="71004">that help to
    observe and measure workloads and provide insights into their operations.</st>
    <st c="71092">Often, the consumers of observability data are</st> **<st c="71139">site
    reliability engineers</st>** <st c="71165">(</st>**<st c="71167">SREs</st>**<st
    c="71171">) or</st> <st c="71177">DevOps engineers, but any user who is concerned
    about the operational excellence of their application should be able to easily
    review and use</st> <st c="71319">this information.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="71336">Equally important observability tooling that is more applicable
    for troubleshooting a production issue of some kind includes networking tracing,
    liveness probes, and stack traces.</st> <st c="71517">A platform should supply
    the implementation and validation of this toolchain and make it available to users
    in a restricted fashion, ensuring security and compliance</st> <st c="71683">are
    upheld.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="71694">Naturally, the log and telemetry data retention policies introduce
    their own scaling concerns, and logging and backup systems can be the worst perpetrators
    of noisy neighbor behaviors.</st> <st c="71880">Thus, the care and operations
    of these systems fall to the platform team to ensure a smooth integration into
    the pre-production and production environments.</st> <st c="72037">Other best
    practices around observability, such as sanitizing logs and keeping platform and
    application logs quarantined from each other, are important, but we will cover
    these topics in more detail in</st> [*<st c="72239">Chapter 7</st>*](B31164_07.xhtml#_idTextAnchor381)
    <st c="72248">when building a</st> <st c="72265">secure platform.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="72281">Observability in a platform</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="72309">Observability is, to put it simply, the way you</st> <st c="72358">measure
    your platform.</st> <st c="72381">In a service-based approach to a platform product,
    the SRE practice of an SLO or multiple SLOs is designed to uphold the golden path.</st>
    <st c="72515">If you think about your SDLC, that path should have been previously
    defined in the planning phase.</st> <st c="72614">An SLO that supports a user
    to ensure their success and happiness as they journey along a golden path represents
    a best practice for an</st> <st c="72750">observability strategy.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="72773">If we refer back to Financial One ACME, as well as the golden
    paths that we’ve defined for a successful IDP within this organization, we can
    see an observability strategy start to develop.</st> <st c="72963">The platform
    team can measure the Pod health for the most critical items in a workflow.</st>
    <st c="73051">If Argo CD is crash-looping or a component Pod is not ready, then
    you know that user expectations around CD are not</st> <st c="73167">being met.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="73177">If jobs are failing for security checks or SBOM generation, then
    the security and compliance systems need attention.</st> <st c="73295">This could
    block PRs from being merged and interrupt developer workflows as they try to determine
    why necessary checks aren’t succeeding.</st> <st c="73433">All along the golden
    path there is something we can measure that will help inform platform health and</st>
    <st c="73535">developer satisfaction.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="73558">Observability in a platform should be in support of SLOs.</st>
    <st c="73617">These measure customer satisfaction through the collection and analysis
    of data.</st> <st c="73698">When we discussed data-driven decision-making for
    platform evolution in</st> [*<st c="73770">Chapter 1</st>*](B31164_01.xhtml#_idTextAnchor014)<st
    c="73779">, we espoused the value of it as a way to maintain the product mindset
    for a platform.</st> <st c="73866">SLOs are a concrete, data-driven way to create
    a feedback loop that your team can</st> <st c="73948">iterate against.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="73964">If your organization cannot meet an SLO, then users are probably
    not happy.</st> <st c="74041">However, even if you’re meeting your SLO target,
    SLOs can still be improved.</st> <st c="74118">It’s reasonable to start with an
    SLO such as “</st>*<st c="74164">jobs will succeed 80% of the time</st>*<st c="74198">”
    and increase that number to 99.99%.</st> <st c="74237">This way, you can still
    evolve a platform without increasing the cognitive load</st> <st c="74317">on
    users.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="74326">Important note</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="74341">100% is a bad SLO target because it’s an impossible metric; however,
    the concepts of three, four, or even five nines of availability can</st> <st c="74479">be
    applied.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="74490">For further reading on SLOs, we recommend</st> *<st c="74533">Site
    Reliability Engineering: How Google Runs</st>* *<st c="74579">Production Systems</st>*<st
    c="74597">.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="74598">Centralized observability – when and why you need it</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="74651">What happens when a platform</st> <st c="74681">hits a critical
    failure?</st> <st c="74706">How do developers, DevOps teams, SREs, or whoever
    is responsible for responding to production</st> <st c="74799">outages figure
    out what’s happening?</st> <st c="74837">Immediately logging into the production
    system and debugging and troubleshooting is one option, but it’s not the most
    secure one.</st> <st c="74967">Ultimately, it may become necessary, but it should
    be considered a last resort, not the</st> <st c="75055">first step.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="75066">How do you know that your observability stack isn’t the man down?</st>
    <st c="75133">In a single-cluster IDP, these questions are easy to answer.</st>
    <st c="75194">But in a multi-cluster or multi-cloud IDP, those questions become
    more complicated.</st> <st c="75278">This is where a centralized observability
    stack becomes critical for the success of any application, including the IDP itself.</st>
    <st c="75405">A centralized observability stack allows for environment-agnostic
    observability.</st> <st c="75486">The centralized system can reach out to the
    IDP clusters and validate their liveness with probes, or it can simply alert on
    the absence of data.</st> <st c="75631">If the IDP clusters stop calling home
    or shipping logs, that’s a good indicator that there’s</st> <st c="75724">a problem.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="75734">Important metrics</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="75752">Since a platform can be prescriptive about how and where workloads
    run, it can also be prescriptive about how workloads are measured.</st> <st c="75887">For
    example, the DORA DevOps metrics can be collected and used to give indicators
    of quality of service or service health.</st> <st c="76010">A platform can support
    this by making services available to expose the necessary data points, or it can
    enforce the calculation of the metrics by forcibly collecting the necessary metrics,
    since it’s the controlling entity of</st> <st c="76236">the environment.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="76252">While SLOs and service-level indicators cannot be fully standardized
    across multiple services, a platform should seek to support the collection, aggregation,
    and retention policies of any critical metrics for an application.</st> <st c="76478">Those
    metrics must then be made available easily and with proper RBAC.</st> <st c="76549">This
    allows users to self-service defining metrics and troubleshooting issues with</st>
    <st c="76632">the software.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="76645">Observability in service for developers</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="76685">Observability for the consumers</st> <st c="76718">of a platform
    looks a little different from what the platform team might see and do.</st> <st
    c="76803">While the toolbox is roughly the same, the data needed is a little different.</st>
    <st c="76881">In addition to their application performance and uptime, developers
    on the platform will care more about failed CI jobs, DORA DevOps metrics, application
    logs, and exceptions.</st> <st c="77057">They need the ability to see all of their
    observability, with no platform-level observability or observability from other
    tenants.</st> <st c="77188">This not only helps maintain a security and compliance
    posture but also reduces cognitive load, since all the data from all the sources
    can make it hard for developers to understand what data they need and how to</st>
    <st c="77401">interpret it.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="77414">There are several ways to approach achieving this clean signal
    to developers.</st> <st c="77493">The observability offering Thanos is specifically
    designed to be a long-term storage solution for Prometheus metrics, natively supporting
    multi-tenancy.</st> <st c="77646">The query language is still Prometheus’ PROMQL,
    which creates a familiar way of interacting with observability data in Thamos.</st>
    <st c="77773">It does, however, expect a somewhat significant amount of dedicated
    cloud storage to support</st> <st c="77866">its operations.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="77881">When we get into the implications of storing and serving observability
    data in a platform, the issue of scaling the platform takes a new shape.</st>
    <st c="78026">We’ll dive into cost management more concretely in later chapters.</st>
    <st c="78093">However, there are a few high-level considerations we can take a
    look</st> <st c="78163">at now.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="78170">As setting up Thanos requires creating object storage and allowing
    access between it and a platform, it adds another layer of complexity to the platform.</st>
    <st c="78325">The storage must be set up, and the networking paths that connect
    it to the rest of the platform must also be created and maintained.</st> <st c="78459">This
    pays dividends for large-scale operations that need to keep observability data
    around for a long time, but it’s not ideal for smaller IDPs or early versions
    of the platform.</st> <st c="78638">Conversely, Prometheus can be used the same
    way, but it can also keep the data in a persistent volume via local mode or not
    persist the data at all, meaning that if the Prometheus Pod were to restart, the
    metrics it had known about would</st> <st c="78876">be lost.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="78884">It’s possible for teams within an IDP to have different needs
    for metric longevity; as such, there is a fairly common pattern of multiple instances
    of Prometheus</st> <st c="79047">using federation.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="79064">Federation is essentially one Prometheus instance that scrapes
    the data it needs from another.</st> <st c="79160">These instances can be on the
    same cluster or across different clusters.</st> <st c="79233">In the use case
    of a multi-tenant IDP, Prometheus federation is a logical choice.</st> <st c="79315">The
    platform owns the application landing zone and, therefore, will hold the source
    of truth for resource utilization within its observability.</st> <st c="79459">However,
    it’s not wise or secure to open that up to all users if the development team also
    uses Prometheus to measure their application health through things such as canary
    routes and synthetic probes.</st> <st c="79661">The developers may want to tie
    that data together with the data that the platform owns to get a full picture
    of their application performance.</st> <st c="79804">By giving the developer Prometheus
    instance federated access to the data it needs, developers can get that information
    without exceeding their</st> <st c="79946">RBAC.</st> <st c="79953">Additionally,
    this model keeps cognitive load low by creating a useful</st> **<st c="80024">signal-to-noise</st>**
    <st c="80039">ratio.</st> <st c="80047">A signal-to-noise ratio</st> <st c="80071">is
    the total number of signals that a developer receives and the number of signals
    that are actionable versus noise.</st> <st c="80188">The less noise a developer
    is exposed to, the more effectively they can parse the data they need</st> <st
    c="80285">to review.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="80295">The actual implementation for this isn’t very difficult; it’s
    a few new lines in the Prometheus YAML file.</st> <st c="80403">The important
    takeaway is that the applications can get information from the platform and any
    necessary shared services, but not from each other.</st> <st c="80549">Since application-level
    observability data is more likely to have personally identifying information or
    other sensitive data in it, this helps the platform team guarantee that security
    and compliance best practices or requirements</st> <st c="80780">are followed.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="80793">The recommended example for federation in this case would be cross-service
    federation.</st> <st c="80881">Here, the most common model is to have a central
    Prometheus server that does federation and is scraped by other Prometheus servers
    that may not</st> <st c="81025">support federation.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7: A Prometheus federation model](img/B31164_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="81381">Figure 6.7: A Prometheus federation model</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="81422">The YAML for the</st> <st c="81440">platform Prometheus instance
    would look a little something</st> <st c="81499">like this:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: <st c="81987">In the</st> *<st c="81995">Figure 6</st>**<st c="82003">.7</st>*
    <st c="82005">example, there is a shared service, and it may be difficult to understand
    what kind of service would be important to multiple application observability
    stacks.</st> <st c="82166">One use case would be for DevOps DORA metrics.</st>
    <st c="82213">In DORA there are four key areas that a team would</st> <st c="82263">measure
    if they’re looking to implement a DORA</st> <st c="82311">maturity model:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="82326">Mean time to resolve</st>**<st c="82347">: How long it takes
    to recover from</st> <st c="82384">a failure</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="82393">Change failure rate</st>**<st c="82413">: How often deployments
    lead</st> <st c="82443">to failures</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="82454">Lead time to change</st>**<st c="82474">: How long it takes
    for a change to</st> <st c="82511">reach production</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="82527">Deployment frequency</st>**<st c="82548">: How often changes</st>
    <st c="82569">are deployed</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="82581">To get this data, the CI/CD systems would need to be queried,
    or they can be configured to send data via a Webhook, and using Prometheus to
    obtain and normalize said data, would allow all compared data to exist in the
    same format, which makes calculation easier.</st> <st c="82845">The implementation
    details for this would involve a Prometheus exporter.</st> <st c="82918">A Prometheus
    exporter is a service that queries data from systems that may not be immediately
    Prometheus-friendly but then transforms it so that it is in a compatible data
    format.</st> <st c="83098">For example, to calculate the lead time to change,
    a Prometheus exporter would get data from the CI system, normalize it, and make
    it available via either a query to the Prometheus API</st> <st c="83283">or federation.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="83297">Whatever observability implementation paths you ultimately use,
    the data and its criticality should be made available to everyone who can leverage
    it, for the success of the platform and the products it supports.</st> <st c="83511">Do
    this with care and also with an understanding that data is a key asset</st> <st
    c="83585">for users.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="83595">Opening your platform for community and collaboration</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="83649">We often use the</st> <st c="83666">term</st> *<st c="83672">open
    source</st>*<st c="83683">, but open source doesn’t always mean free, and vice
    versa.</st> <st c="83743">However, when we discuss FOSS, the most important aspect
    of the software is not the technology but the community behind it.</st> <st c="83867">Open
    source communities foster collaboration and help to organically grow software
    in ways that revolutionize</st> <st c="83977">the industry.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="83990">When we previously discussed learning about your users, it was
    largely in the context of getting things off the ground, but you need to maintain
    that same user-centricity in order to keep the product running and relevant.</st>
    <st c="84213">The best way to harness the power of your users is to bring them
    to the table with the team, creating a community as seen in FOSS projects that
    invites collaboration, contribution, and communication.</st> <st c="84413">By
    doing so, you can have a data-driven, user-led platform that evolves with the
    organization it is intended to serve.</st> <st c="84532">Oftentimes, a project
    lifts off, but the roadmap beyond that is fuzzy.</st> <st c="84603">As the adrenaline
    of the initial push to an IDP fades, the risk of losing momentum and becoming
    complacent develops.</st> <st c="84720">The community aspect should then act as
    the fuel to keep the</st> <st c="84781">vehicle moving.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="84796">At this point, you’re likely asking, how do we go about creating
    this community?</st> <st c="84878">How do we bring people to the table without
    undoing the reduction of cognitive load we’ve been striving for with</st> <st
    c="84991">our platform?</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="85004">There’s no one magic button solution for this but, rather, several
    things that can be done in concert, such as adding a contributor guide to a repository
    that sets expectations around what kind of contributions are desired and how contributions
    will</st> <st c="85255">be reviewed.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="85267">Another aspect is that some of the tools you might include in
    your platform can help to entice collaboration.</st> <st c="85378">Policy engines,
    for example, entice collaboration because users can propose new policies or adjustments
    to their policies.</st> <st c="85501">By having a repository for policies that
    is open to end users, you can invite PRs against the policies for users to propose
    new permissions or adjustments to existing permissions.</st> <st c="85681">As
    we discussed with self-service, this leverages a known useful workflow of Git
    PRs and</st> <st c="85770">peer review.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="85782">Similarly, the use of quotas for an environment is a configuration
    that can be managed with GitOps; a PR for more quotas and some GitHub workflows
    can be leveraged to help developers request quotas.</st> <st c="85982">In both
    examples, the leveraging of Git repos and PRs allows users to interact with a
    platform in a more intuitive way that fits with their workflows.</st> <st c="86133">Once
    again, meeting your “customers” where they are helps to reduce their cognitive
    load, while enticing collaboration is necessary to ensure that the platform continues
    to meet</st> <st c="86311">their needs.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="86323">A platform should drink</st> <st c="86348">its own champagne.</st>
    <st c="86367">If the product security team has demands on the application that
    a platform must support, such as the generations of SBOMs or automated penetration
    testing jobs, the platform itself should be evaluated against the same security
    standards.</st> <st c="86606">Doing this is not only an exercise in intellectual
    honesty, ensuring that the way security standards are enforced is reasonable and
    doesn’t interfere with serviceability and self-service, but also a pathway toward
    engagement from your internal community in the development and hardening of</st>
    <st c="86896">the platform.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="86909">A discerning reader may wonder, “</st>*<st c="86943">How do you
    reconcile the dichotomy between the reduction of cognitive load for users and
    their engagement in the</st>* *<st c="87057">platform experience?</st>*<st c="87077">”</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="87079">This is an important question, as endless requests for feedback
    may result in silence, since the mental load of generating feedback may be high
    especially if users don’t feel that feedback will</st> <st c="87273">be actioned.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="87285">There is no single approach to gaining community engagement that
    is guaranteed to work, but when we look at some best practices from around the
    FOSS community, we can see there’s</st> <st c="87465">a trend.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="87473">Planning in the open</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="87494">Regular planning meetings and community meetings that are attended
    by the platform team, as well as being open to anyone to attend, help to create
    and foster the open collaboration needed to grow a community culture around a
    platform.</st> <st c="87730">In a Kubernetes project, most of the project meetings
    are on a public calendar, and there are mailing lists that individuals can sign
    up for to keep abreast of the latest and greatest news coming from each project.</st>
    <st c="87945">Regular product updates and plans that are emailed out and transparent
    to a company will help to maintain interest and engagement, hopefully resulting
    in the proactive feedback necessary for the long-term success of</st> <st c="88161">the
    IDP.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="88169">Accepting contributions</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="88193">Accepting contributions is probably one of the more logistically
    difficult sociotechnical aspects of landing and expanding an IDP.</st> <st c="88325">However,
    some open source IDP projects lend themselves very nicely to this paradigm.</st>
    <st c="88410">The recent open source darling Backstage provides, among many other
    features, a plugin-capable architecture.</st> <st c="88519">In other words, by
    laying down Backstage as the IDP framework when a team finds they’re missing functionality
    or would benefit from some additional quality-of-life features, they can leverage
    the plugin</st> <st c="88722">framework to propose the new feature via a PR to
    the internal</st> <st c="88784">IDP project.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="88796">While you don’t have to use this exact framework to achieve the
    same results, the pattern that Backstage exemplifies allows for easy contributions
    from users and a standardized way of proposing changes via hands on contribution,
    instead of just sending a request to the platform</st> <st c="89076">team’s backlog.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="89091">Summary</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="89099">In this chapter, we looked at how to build for developers and
    the importance of cognitive load.</st> <st c="89196">Protecting users from undesired
    outcomes positively influences their cognitive load and gives them fewer concerns,
    and fewer things to debug if something goes wrong can help keep developers working
    efficiently.</st> <st c="89407">Additionally, the relationship between cognitive
    load and self-service was explored, and we took a look at some common tools and
    patterns to deliver a platform that meets the users where they are.</st> <st c="89604">If
    you were following along with a kind cluster, you may have even gained some hands-on
    experience with these recommendations.</st> <st c="89731">While we touched briefly
    on the security aspects of each of these topics, we’ll cover each of them and
    more topics in depth in the</st> <st c="89862">next chapter.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="0">Part 3 – Platforms as a Product Best Practices</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="47">In the last part, we will provide you with the tools to optimize
    your platform for cost efficiency, enabling your users to do the same.</st> <st
    c="184">We will achieve this by outlining the simple steps required to establish
    transparency within your cost landscape and by providing you with best practices
    to reduce your infrastructure expenses.</st> <st c="378">From infrastructure costs,
    we will move on to technical debts, which can negatively impact the maintenance
    costs of the selected technology stack if they are not dealt with correctly.</st>
    <st c="562">You will learn about tools and frameworks to evaluate technical debts
    and the importance of documenting what decisions you make.</st> <st c="691">Finally,
    we will take a look into the future.</st> <st c="737">You will learn about the
    imperative of change and why you have to become an active part of driving change.</st>
    <st c="844">You might discover a different perspective on your golden path and
    some ideas about future</st> <st c="935">relevant technologies.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="957">This part has the</st> <st c="976">following chapters:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[*<st c="995">Chapter 7</st>*](B31164_07.xhtml#_idTextAnchor381)<st c="1005">,</st>
    *<st c="1007">Building Secure and Compliant Products</st>*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*<st c="1045">Chapter 8</st>*](B31164_08.xhtml#_idTextAnchor430)<st c="1055">,</st>
    *<st c="1057">Cost Management and Best Practices</st>*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*<st c="1091">Chapter 9</st>*](B31164_09.xhtml#_idTextAnchor479)<st c="1101">,</st>
    *<st c="1103">Choosing Technical Debt to Unbreak Platforms</st>*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*<st c="1147">Chapter 10</st>*](B31164_10.xhtml#_idTextAnchor507)<st c="1158">,</st>
    *<st c="1160">Crafting Platform Products for the Future</st>*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
