- en: <st c="0">6</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">6</st>
- en: <st c="2">Build for Developers and Their Self-Service</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2">为开发人员及其自助服务构建</st>
- en: <st c="45">A platform without accessible features is not a platform.</st> <st
    c="104">As a rule, self-service should be included and must improve accessibility
    to add value.</st> <st c="192">In the process of building platforms, there is
    often no distinction between infrastructure and application layers.</st> <st c="307">The
    integration of</st> **<st c="326">Internal Developer Portals</st>** <st c="352">(</st>**<st
    c="354">IDPs</st>**<st c="358">) adds new complexity to this, addressing some
    demands</st> <st c="413">while leaving others unanswered.</st> <st c="447">It
    is important to bring the community into your platform and be open to</st> <st
    c="520">their contributions.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45">没有可访问功能的平台不是一个平台。</st> <st c="104">作为规则，自助服务应该包含在内，并且必须提高可访问性，以增加价值。</st>
    <st c="192">在构建平台的过程中，通常没有区分基础设施层和应用层。</st> <st c="307">内部开发者门户（</st>**<st c="326">IDPs</st>**<st
    c="352">）的集成为此带来了新的复杂性，它解决了一些需求</st> <st c="413">同时也留下了一些未解答的问题。</st> <st c="447">将社区引入你的平台并对他们的贡献持开放态度是很重要的。</st>
- en: <st c="540">In this chapter, we will review some concepts and share some ideas
    for best practices.</st> <st c="628">By the end of the chapter, you should understand
    how to approach the building of a platform that is resilient, flexible, and meets
    your users where</st> <st c="776">they are.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="540">在本章中，我们将回顾一些概念，并分享一些最佳实践的思路。</st> <st c="628">到本章结束时，你应该了解如何构建一个具有韧性、灵活性并能够满足用户需求的平台。</st>
    <st c="776">他们所处的位置。</st>
- en: <st c="785">In this chapter, we’ll cover the following</st> <st c="829">main
    topics:</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="785">在本章中，我们将涵盖以下</st> <st c="829">主要主题：</st>
- en: <st c="841">Software versus platform development – avoiding</st> <st c="890">a
    mix</st>
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="841">软件开发与平台开发——避免</st> <st c="890">混淆</st>
- en: <st c="895">Reducing</st> <st c="905">cognitive load</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="895">减少</st> <st c="905">认知负荷</st>
- en: <st c="919">Self-service</st> <st c="933">developer portals</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="919">自助服务</st> <st c="933">开发者门户</st>
- en: <st c="950">Land, expand, and integrate</st> <st c="979">your IDP</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="950">落地、扩展和集成</st> <st c="979">你的IDP</st>
- en: <st c="987">Architectural considerations for observability in</st> <st c="1038">a
    platform</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="987">平台可观察性的架构考虑</st> <st c="1038">在平台中</st>
- en: <st c="1048">Open your platform for community</st> <st c="1082">and collaboration</st>
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1048">为社区开放你的平台</st> <st c="1082">并促进合作</st>
- en: <st c="1099">Technical requirements</st>
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1099">技术要求</st>
- en: <st c="1122">In this chapter, there will be some technical examples with</st>
    `<st c="1183">.yaml</st>` <st c="1188">files and commands.</st> <st c="1209">While
    you don’t need to set up a cluster to follow along, doing so may enhance your
    understanding.</st> <st c="1308">We used the following technologies to develop
    our samples</st> <st c="1366">and explanations:</st>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1122">在本章中，将会有一些技术示例，包括</st> `<st c="1183">.yaml</st>` <st c="1188">文件和命令。</st>
    <st c="1209">虽然你不需要设置集群来跟随本章内容，但如果设置集群，可能会加深你的理解。</st> <st c="1308">我们使用了以下技术来开发我们的示例</st>
    <st c="1366">和解释：</st>
- en: <st c="1383">kind – the version tested was kind</st> `<st c="1419">v0.22.0 go1.20.13</st>`
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1383">kind – 测试版本为kind</st> `<st c="1419">v0.22.0 go1.20.13</st>`
- en: <st c="1436">We used this guide to set up a three-worker node</st> <st c="1486">cluster:</st>
    [<st c="1495">https://kind.sigs.k8s.io/docs/user/quick-start/#configuring-your-kind-cluster</st>](https://kind.sigs.k8s.io/docs/user/quick-start/#configuring-your-kind-cluster)
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1436">我们使用本指南设置了一个三节点的</st> <st c="1486">集群：</st> [<st c="1495">https://kind.sigs.k8s.io/docs/user/quick-start/#configuring-your-kind-cluster</st>](https://kind.sigs.k8s.io/docs/user/quick-start/#configuring-your-kind-cluster)
- en: <st c="1572">Docker (a Docker Rootless setup</st> <st c="1605">is recommended)</st>
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1572">Docker（建议使用Docker无根设置）</st> <st c="1605">推荐使用</st>
- en: <st c="1620">The</st> `<st c="1625">kubectl</st>` <st c="1632">command-line
    tool</st>
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1620">The</st> `<st c="1625">kubectl</st>` <st c="1632">命令行工具</st>
- en: <st c="1650">A</st> <st c="1653">GitHub repo</st>
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1650">一个</st> <st c="1653">GitHub 仓库</st>
- en: <st c="1664">The code examples can be found inside the</st> `<st c="1707">Chapter06</st>`
    <st c="1716">folder</st> <st c="1724">here:</st> [<st c="1730">https://github.com/PacktPublishing/Platform-Engineering-for-Architects</st>](https://github.com/PacktPublishing/Platform-Engineering-for-Architects)<st
    c="1800">.</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1664">代码示例可以在</st> `<st c="1707">Chapter06</st>` <st c="1716">文件夹内找到</st>
    <st c="1724">这里：</st> [<st c="1730">https://github.com/PacktPublishing/Platform-Engineering-for-Architects</st>](https://github.com/PacktPublishing/Platform-Engineering-for-Architects)<st
    c="1800">。</st>
- en: <st c="1801">We’ll do a couple of small tutorials over the course of the chapter.</st>
    <st c="1871">While not every code snippet needs to be run against a Kubernetes
    cluster, it is recommended to set up a local Kind cluster with at least one control
    plane node and three worker nodes to get the full value of the tutorials.</st>
    <st c="2095">The configuration for the Kind cluster can be found in the GitHub
    repo for</st> <st c="2170">the chapter.</st>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1801">在本章中，我们将进行一些小型教程。</st> <st c="1871">尽管并非每个代码片段都需要在Kubernetes集群中运行，但建议设置一个本地的Kind集群，其中至少包含一个控制平面节点和三个工作节点，以便充分体验教程的价值。</st>
    <st c="2095">Kind集群的配置可以在GitHub上的章节仓库中找到。</st>
- en: <st c="2182">Software versus platform development – avoiding a mix</st>
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2182">软件与平台开发——避免混淆</st>
- en: <st c="2236">In our journey toward</st> <st c="2259">platform development, we
    have to disambiguate between this and other forms of</st> <st c="2336">software
    development.</st> <st c="2359">Remember that the purpose of the platform is to
    enable development and operations teams; it is not something that customers directly
    experience, although they do</st> <st c="2521">benefit indirectly.</st>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2236">在我们迈向</st> <st c="2259">平台开发的过程中，我们必须明确区分平台开发和其他形式的</st> <st c="2336">软件开发。</st>
    <st c="2359">请记住，平台的目的是为了使开发和运维团队能够进行开发和运营；它并不是客户直接体验的东西，尽管客户确实</st> <st c="2521">间接受益。</st>
- en: <st c="2540">The value of the platform is the unification of all the tools,
    services, and applications required to build and land an application in front
    of users.</st> <st c="2692">In short, a platform is a series of services used
    by developers to deliver software applications into the hands of end users.</st>
    <st c="2818">You can</st> <st c="2825">consume existing software applications,
    so it’s possible to develop</st> <st c="2893">a platform without writing</st>
    <st c="2921">any code.</st>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2540">平台的价值在于将构建和交付应用程序所需的所有工具、服务和应用程序统一在一起，呈现在用户面前。</st> <st c="2692">简而言之，平台是开发者用来将软件应用程序交付给最终用户的一系列服务。</st>
    <st c="2818">你可以</st> <st c="2825">使用现有的软件应用程序，因此也可以在不编写</st> <st c="2893">任何代码的情况下开发</st>
    <st c="2921">一个平台。</st>
- en: <st c="2930">So, how do you develop a platform, and how do you develop software?</st>
    <st c="2999">Where do they intersect, and where do</st> <st c="3037">they differ?</st>
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2930">那么，如何开发一个平台，如何开发软件呢？</st> <st c="2999">它们在哪些地方交集，在哪些地方不同？</st>
- en: <st c="3049">The platform life cycle versus the software life cycle</st>
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="3049">平台生命周期与软件生命周期</st>
- en: <st c="3104">In</st> <st c="3108">many</st> <st c="3113">regards, the life cycle
    of a</st> <st c="3142">platform looks similar to any</st> **<st c="3172">Software
    Development Life</st>** **<st c="3198">Cycle</st>** <st c="3203">(</st>**<st c="3205">SDLC</st>**<st
    c="3209">).</st>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3104">在</st> <st c="3108">许多</st> <st c="3113">方面，平台的生命周期看起来与任何</st>
    <st c="3142">软件开发生命周期</st> **<st c="3172">类似</st>** **<st c="3198">（SDLC）</st>**
    <st c="3203">(</st>**<st c="3205">SDLC</st>**<st c="3209">)。</st>
- en: '![Figure 6.1: An SDLC](img/B31164_06_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1：一个SDLC](img/B31164_06_01.jpg)'
- en: '<st c="3214">Figure 6.1: An SDLC</st>'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3214">图6.1：一个SDLC</st>
- en: <st c="3233">In the previous chapters, we covered the benefits of a robust planning
    phase and treating your platform as a product.</st> <st c="3352">And while it’s
    important not to over-engineer the platform during this process, you’ll still
    end up with a system that has a variety of aspects.</st> <st c="3497">Thus, due
    to its relative size and complexity, the release of a platform may not be as simple
    as pressing a button and letting your change propagate through some servers or
    clusters.</st> <st c="3680">This is in no small part due to the number of moving
    pieces you can find within a platform.</st> <st c="3772">For example, creating
    a new integration to deliver a</st> **<st c="3825">Software Bill of Materials</st>**
    <st c="3851">(</st>**<st c="3853">SBOM</st>**<st c="3857">) will be</st> <st c="3867">less
    disruptive to users than adjusting policies within an existing policy engine to
    be</st> <st c="3956">more restrictive.</st>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3233">在前面的章节中，我们讨论了强大规划阶段的好处，并将平台视为产品的处理方式。</st> <st c="3352">虽然在此过程中避免过度设计平台很重要，但你仍然会最终得到一个具有多方面特性的系统。</st>
    <st c="3497">因此，由于平台的相对规模和复杂性，平台的发布可能不像按下按钮并让你的更改在一些服务器或集群中传播那样简单。</st> <st c="3680">这在很大程度上是因为平台内部有大量的动态组件。</st>
    <st c="3772">例如，创建一个新的集成以交付</st> **<st c="3825">软件材料清单</st>** <st c="3851">(</st>**<st
    c="3853">SBOM</st>**<st c="3857">)将比在现有的策略引擎中调整策略以使其</st> <st c="3867">更具限制性对用户造成的干扰更小。</st>
- en: <st c="3973">If we look</st> <st c="3985">at the anatomy of a typical</st> <st
    c="4012">platform and its</st> <st c="4029">user considerations, it will be easier
    to understand how the platform life cycle differs from</st> <st c="4123">a</st>
    <st c="4126">software application.</st>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3973">如果我们看看</st> <st c="3985">一个典型平台的结构及其</st> <st c="4012">用户考量，理解平台生命周期如何与</st>
    <st c="4123">软件应用程序</st> <st c="4126">有所不同会更加容易。</st>
- en: '![Figure 6.2: An example of IDP components and functional areas](img/B31164_06_02.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2：IDP组件和功能区域示例](img/B31164_06_02.jpg)'
- en: '<st c="4360">Figure 6.2: An example of IDP components and functional areas</st>'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4360">图6.2：IDP组件和功能区域示例</st>
- en: <st c="4421">In this platform example, pre-production is on the left, and the
    production environment where customer-facing applications will be deployed is
    on the right (</st>**<st c="4579">Application Landing Zone</st>**<st c="4604">).</st>
    <st c="4608">Whether a single Kubernetes cluster, multi-cluster, or multi-architecture,
    the platform is a cohesive unit that encapsulates these two paradigms.</st> <st
    c="4754">The platform should abstract the architecture away from users, allowing
    them to</st> <st c="4834">work independently.</st>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4421">在这个平台示例中，预生产环境位于左侧，生产环境则位于右侧，客户面向的应用程序将在其中部署（</st>**<st c="4579">应用程序着陆区</st>**<st
    c="4604">）。</st> <st c="4608">无论是单一Kubernetes集群、多集群还是多架构，平台是一个紧密结合的整体，包含这两种范式。</st>
    <st c="4754">平台应该将架构从用户中抽象出来，让他们能够</st> <st c="4834">独立工作。</st>
- en: <st c="4853">Here, DevOps engineers care about how the application is built
    and released.</st> <st c="4931">Things such as progressive rollouts, DORA</st>
    <st c="4973">metrics (</st>[<st c="4982">https://dora.dev/</st>](https://dora.dev/)<st
    c="5000">), and other DevOps practices are what the platform may be expected to
    support.</st> <st c="5081">Similarly, if your organization is quite far along
    in its cloud-native journey, the data surrounding the operations of the production
    application would be something site reliability engineers would concern themselves
    with.</st> <st c="5304">And there are other relevant considerations, such as security
    checks, infrastructure as code, and docs.</st> <st c="5408">Each aspect of these
    can be controlled individually within a platform and made available to all or
    a subset of</st> <st c="5519">the personas.</st>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4853">在这里，DevOps工程师关心的是应用程序如何构建和发布。</st> <st c="4931">诸如渐进式发布、DORA</st>
    <st c="4973">指标（</st>[<st c="4982">https://dora.dev/</st>](https://dora.dev/)<st
    c="5000">）以及其他DevOps实践是平台可能需要支持的内容。</st> <st c="5081">同样，如果您的组织在云原生之路上已经走得很远，那么与生产应用程序操作相关的数据将是站点可靠性工程师关心的内容。</st>
    <st c="5304">还有其他相关的考量因素，比如安全检查、基础设施即代码以及文档。</st> <st c="5408">这些方面的每一项都可以在平台内单独控制，并对所有或部分</st>
    <st c="5519">角色可用。</st>
- en: '*<st c="5532">Figure 6</st>**<st c="5541">.2</st>* <st c="5543">also assumes
    there are personas working in dedicated roles; however, if there’s no dedicated
    DevOps team, it’s likely that developers and quality engineering would share responsibilities
    in that space.</st> <st c="5746">The overall concept should still apply even to
    small organizations, where one person may have a stake in multiple personas’ user
    stories.</st> <st c="5884">Even the theoretical division of the personas should
    assist when undertaking the life cycle of</st> <st c="5979">a platform.</st>'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="5532">图6</st>**<st c="5541">.2</st>* <st c="5543">假设有专门的角色在工作；然而，如果没有专门的DevOps团队，那么开发人员和质量工程师很可能会在这方面分担职责。</st>
    <st c="5746">这个整体概念仍然适用于即便是小型组织，在这些组织中，一个人可能需要同时承担多个角色的用户故事。</st> <st c="5884">即使是理论上划分的角色，也应该有助于在进行平台生命周期管理时提供帮助。</st>'
- en: <st c="5990">A platform</st> <st c="6001">is more than just the software; it’s
    also its tuning</st> <st c="6055">in concert with the workloads that help make
    sure it’s performant for its users.</st> <st c="6136">While the needs of the users
    do influence the size, scope, and functionality of the platform, it should be
    designed as agnostically as possible so that one user’s golden path isn’t prioritized</st>
    <st c="6329">over another.</st>
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5990">平台</st> <st c="6001">不仅仅是软件；它还是与工作负载协同调优的过程，以确保其对用户的性能。</st> <st
    c="6136">虽然用户需求确实会影响平台的大小、范围和功能，但它应该尽可能设计得不偏不倚，以确保一个用户的黄金路径不会优先于</st> <st c="6329">另一个用户。</st>
- en: <st c="6342">Reliability versus serviceability</st>
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="6342">可靠性与可维护性</st>
- en: <st c="6376">A platform’s</st> **<st c="6390">reliability</st>** <st c="6401">and</st>
    **<st c="6406">serviceability</st>** <st c="6420">are the</st> <st c="6428">largest
    factors of its usability by developers in an</st> <st c="6481">organization.</st>
    <st c="6496">But what do each of these things</st> <st c="6529">really mean?</st>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6376">一个平台的</st> **<st c="6390">可靠性</st>** <st c="6401">和</st> **<st
    c="6406">可服务性</st>** <st c="6420">是开发者在</st> <st c="6428">组织中使用该平台的最大因素。</st>
    <st c="6481">但这些因素到底意味着什么呢？</st> <st c="6496">这些概念各自到底意味着什么呢？</st>
- en: <st c="6541">At its core, reliability</st> <st c="6567">encompasses the overall
    availability of a platform and the</st> <st c="6626">ability of a user to successfully
    interact with it.</st> <st c="6678">Reliability in a platform should assume that
    multi-tenancy (multiple users who are fully isolated from each other) has been
    implemented in the platform.</st> <st c="6831">The reason for this is that the
    concept can still be applied where it’s not required, but your platform still
    supports multiple users with individual needs.</st> <st c="6988">While multi-tenancy
    isn’t an intuitive approach for an internal tool, highly regulated teams may prefer
    to work in an isolated environment to ensure that there’s no risk of security
    and compliance violations.</st> <st c="7197">Even if all your users are internal
    customers, they still shouldn’t be exposed to or impacted by other</st> <st c="7300">user
    workloads.</st>
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6541">从本质上讲，可靠性</st> <st c="6567">涵盖了平台的整体可用性以及用户与平台成功互动的能力。</st> <st
    c="6626">平台的可靠性应假设已经在平台中实现了多租户（多个用户之间完全隔离）。</st> <st c="6678">这是因为这个概念仍然可以在不需要的地方应用，但你的平台仍然支持具有各自需求的多个用户。</st>
    <st c="6831">尽管多租户对于内部工具而言并不是直观的做法，但高度监管的团队可能更愿意在一个隔离的环境中工作，以确保没有安全性和合规性违规的风险。</st>
    <st c="6988">即使所有用户都是内部客户，他们仍然不应该暴露于或受到其他</st> <st c="7300">用户工作负载的影响。</st>
- en: <st c="7315">To attain the reliability of a platform, you should leverage tuning
    and a policy that helps you ensure workload isolation and maintain the integrity
    of a platform.</st> <st c="7480">In a Kubernetes environment, a node may be a
    virtual machine or real hardware.</st> <st c="7559">As with any machine, each
    node has a set amount of memory and CPU allocated to it.</st> <st c="7642">However,
    unlike your standard virtual machine, when you overcommit the CPU, a node can
    use the CPU that would otherwise belong to a different node.</st> <st c="7790">This
    is not true of memory, although both can be oversubscribed, and</st> **<st c="7859">Out
    of Memory</st>** <st c="7872">(</st>**<st c="7874">OOM</st>**<st c="7877">) will</st>
    <st c="7885">cause a node to reboot.</st> <st c="7909">This allows the overall
    resource requirements to be kept lower by guaranteeing a resource will be able
    to utilize CPU cycles if they’re available; however, on the other hand, a bad
    process that eats CPU due to a software error may never return the CPU cycles
    to the node pool for availability.</st> <st c="8203">Other factors, such as Pod
    priority, requests, limits, and Pod disruption budgets, can influence how a scheduler
    will determine where and how to schedule Pods, and whether or not the kubelet
    will evict an existing workload.</st> <st c="8427">For more information on these
    topics, it’s important to review the Kubernetes documentation regularly as new
    features and best practices emerge and the project continues to</st> <st c="8600">develop
    (</st>[<st c="8609">https://kubernetes.io/docs/home/</st>](https://kubernetes.io/docs/home/)<st
    c="8642">).</st>
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7315">为了实现平台的可靠性，你应该利用调优和策略，帮助你确保工作负载隔离，并保持平台的完整性。</st> <st c="7480">在
    Kubernetes 环境中，一个节点可以是虚拟机或真实硬件。</st> <st c="7559">与任何机器一样，每个节点都有分配给它的固定内存和 CPU。</st>
    <st c="7642">然而，与标准虚拟机不同，当你超额分配 CPU 时，节点可以使用原本属于其他节点的 CPU。</st> <st c="7790">这一点对内存不适用，虽然内存也可以被过度订阅，且</st>
    **<st c="7859">内存不足</st>** <st c="7872">(</st>**<st c="7874">OOM</st>**<st c="7877">)
    会</st> <st c="7885">导致节点重启。</st> <st c="7909">这样可以通过保证在 CPU 周期可用时，资源能够使用这些 CPU
    周期，从而降低整体资源需求；然而，另一方面，由于软件错误导致的 CPU 占用过多的恶劣进程，可能永远无法将 CPU 周期返回给节点池，以便再次使用。</st>
    <st c="8203">其他因素，例如 Pod 优先级、请求、限制和 Pod 中断预算，会影响调度器如何决定在哪个地方以及如何调度 Pods，是否会驱逐已有的工作负载。</st>
    <st c="8427">有关这些主题的更多信息，重要的是定期查看 Kubernetes 文档，因为新特性和最佳实践不断涌现，而该项目也在持续</st> <st
    c="8600">发展（</st>[<st c="8609">https://kubernetes.io/docs/home/</st>](https://kubernetes.io/docs/home/)<st
    c="8642">）。</st>
- en: <st c="8645">While the final</st> <st c="8661">tuning and orchestration of these
    settings will need to</st> <st c="8717">be determined by the platform engineering
    team, we can generally recommend that this tuning should be part of your planning
    phase.</st> <st c="8849">You should reevaluate continuously over the life cycle
    of</st> <st c="8907">a platform.</st>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8645">虽然这些设置的最终调优和编排需要</st> <st c="8661">由平台工程团队来决定，但我们通常建议，这些调优应该成为规划阶段的一部分。</st>
    <st c="8717">在平台生命周期内，你应该持续不断地进行评估。</st> <st c="8849">你应该在平台的生命周期中持续重新评估。</st>
    <st c="8907">平台。</st>
- en: <st c="8918">The serviceabil</st><st c="8934">ity of a platform is similar to
    reliability, except serviceability looks more at what the golden paths are for
    the users who need to leverage the platform.</st> <st c="9091">For a platform
    to have serviceability, it needs to meet the user’s demands.</st> <st c="9167">Unlike
    self-service, which is a user’s ability to reasonably accomplish all reasonable
    actions without reliance on a governing team, serviceability looks holistically
    at all the user needs and meets them where they are.</st> <st c="9387">Reliability
    could be considered a measurement of serviceability, but the goal of meeting user
    needs is more all-encompassing than just reliability.</st> <st c="9535">Serviceability
    is at the core of a product minds</st><st c="9583">et for</st> <st c="9591">the
    platform.</st>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8918">平台的可服务性</st><st c="8934">类似于可靠性，不同之处在于可服务性更多关注的是需要利用平台的用户的黄金路径。</st>
    <st c="9091">为了使平台具有可服务性，它需要满足用户的需求。</st> <st c="9167">与自助服务不同，自助服务是用户在不依赖管理团队的情况下，能够合理完成所有合理操作的能力，可服务性则从整体上看待所有用户需求，并在用户所在的位置满足这些需求。</st>
    <st c="9387">可靠性可以视为可服务性的衡量标准，但满足用户需求的目标比单纯的可靠性更加全面。</st> <st c="9535">可服务性是平台产品思维的核心</st><st
    c="9583">，</st> <st c="9591">平台的核心。</st>
- en: <st c="9604">Similar to a critical user journey, the</st> <st c="9645">golden
    path maps the more critical use case for a user of a system.</st> <st c="9713">In
    general, this is the series of steps the user can take and expect the</st> <st
    c="9786">desired outcome.</st>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9604">类似于关键用户旅程，</st> <st c="9645">黄金路径映射了系统用户的更关键使用场景。</st> <st c="9713">一般来说，这是用户可以采取的步骤序列，并期望达到</st>
    <st c="9786">预期结果。</st>
- en: <st c="9802">For a developer of an application leveraging an IDP, the golden
    path would be something</st> <st c="9891">like this:</st>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9802">对于利用IDP的应用程序开发者来说，黄金路径可能是这样的：</st>
- en: '![Figure 6.3: An example of a golden path using an IDP](img/B31164_06_03.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3：使用IDP的黄金路径示例](img/B31164_06_03.jpg)'
- en: '<st c="9973">Figure 6.3: An example of a golden path using an IDP</st>'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9973">图6.3：使用IDP的黄金路径示例</st>
- en: <st c="10025">A</st> <st c="10028">developer pushes a commit, and then the</st>
    **<st c="10068">Continuous Integration</st>** <st c="10090">(</st>**<st c="10092">CI</st>**<st
    c="10094">) system</st> <st c="10103">does its magic.</st> <st c="10120">The application
    or an upgrade to the application</st> <st c="10168">lands in production, and then
    it sends data back to logging and observability tools for the developer to leverage,
    enabling them to gain insights into their application’s production state</st>
    <st c="10357">and performance.</st>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10025">开发者推送提交后，</st> **<st c="10068">持续集成</st>** <st c="10090">(</st>**<st
    c="10092">CI</st>**<st c="10094">) 系统</st> <st c="10103">自动执行其魔法。</st> <st c="10120">应用程序或应用程序的升级</st>
    <st c="10168">进入生产环境后，它会将数据发送回日志记录和可观察性工具，供开发者利用，从而使他们能够获得关于应用程序生产状态</st> <st
    c="10357">和性能的洞察。</st>
- en: <st c="10373">The conclusion</st>
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="10373">结论</st>
- en: <st c="10388">With this in mind, we can now look at where the SDLC diverges
    for platform engineering as compared to the development of an application that
    a platform would run.</st> <st c="10552">Along our golden path within the platform,
    rather than one service or opaque system that does it all, our users interact
    with a system comprised of different services.</st> <st c="10720">Some or all
    of these services may be homegrown, but it’s more likely that these services are
    a mix of internal tooling and open source technologies working in concert to create
    the entity known as</st> *<st c="10917">the platform</st>*<st c="10929">.</st>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10388">考虑到这一点，我们现在可以看一下，平台工程的SDLC与一个平台运行的应用程序开发之间的分歧。</st> <st c="10552">在平台的黄金路径中，用户不再是与一个完成所有工作的服务或不透明系统交互，而是与由多个服务组成的系统交互。</st>
    <st c="10720">这些服务中的一些或全部可能是自家研发的，但更可能是这些服务是内部工具与开源技术的混合，共同协作，构建出我们所说的</st> *<st
    c="10917">平台</st>*<st c="10929">。</st>
- en: <st c="10930">Since a platform is built of components, you can also break down
    your platform’s SDLC on a per-component basis.</st> <st c="11043">However, as
    with any system, you must watch out for interdependencies that would require multiple
    components to be released</st> <st c="11167">in concert.</st>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10930">由于平台由多个组件构成，你还可以基于每个组件来拆解平台的SDLC。</st> <st c="11043">然而，与任何系统一样，你必须警惕那些需要多个组件一起发布的相互依赖关系。</st>
    <st c="11167">这些组件必须协调发布。</st>
- en: <st c="11178">Your developers will need the ability to leverage these systems
    both transparently and opaquely.</st> <st c="11276">This means that while the
    use of each tool within the platform should be baked into an automated workflow
    for them, they should be able to see what’s happening and debug issues within
    the individual pieces as necessary.</st> <st c="11496">For example, if a Tekton
    CI job fails, the application developer in our example needs to be able to see
    the failed job and gain insights into what failed within the job, enabling them
    to either fix the application or the</st> <st c="11717">CI job.</st>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11178">你的开发人员需要能够透明和不透明地使用这些系统。</st> <st c="11276">这意味着，虽然平台中的每个工具的使用应该自动化融入工作流程中，但开发人员应能够看到发生了什么，并在必要时调试各个部分的问题。</st>
    <st c="11496">例如，如果一个Tekton CI任务失败，我们示例中的应用开发人员需要能够看到失败的任务，并深入了解任务失败的原因，从而帮助他们修复应用或CI任务。</st>
    <st c="11717">CI任务。</st>
- en: <st c="11724">Understanding how to effectively manage the life cycle of a platform
    while minimizing user impact can be a case of drinking your own champagne, meaning
    the platform team uses the same processes and technologies they make available
    to users.</st> <st c="11966">The building and life cycle management of a platform
    can leverage the same DevOps tools;</st> *<st c="12055">star (*) as code</st>*
    <st c="12071">patterns such as</st> *<st c="12089">docs as code</st>*<st c="12101">,</st>
    *<st c="12103">infrastructure as code</st>*<st c="12125">, and</st> *<st c="12131">configuration
    as code</st>* <st c="12152">all factor into the build and release of the platform.</st>
    <st c="12208">However, unlike the software application, for end users of a platform
    these declarative pieces will have the highest impact on them, especially when
    compared to something such as a banki</st><st c="12394">ng application for which
    all of those DevOp</st><st c="12438">s aspects are completely black-boxed for
    the end users.</st> <st c="12495">The identity of the customers greatly impacts
    the weight of one facet of software engineering over the other and, thus, differentiates
    between</st> *<st c="12638">software and</st>* *<st c="12651">platform development</st>*<st
    c="12671">.</st>
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11724">了解如何有效管理平台生命周期，同时尽量减少对用户的影响，可能就像是在“喝自家酿的香槟”，意味着平台团队使用他们提供给用户的相同流程和技术。</st>
    <st c="11966">平台的构建和生命周期管理可以利用相同的DevOps工具；</st> *<st c="12055">代码即配置（star (*)
    as code）</st>* <st c="12071">等模式，如</st> *<st c="12089">文档即代码（docs as code）</st>*<st
    c="12101">、</st> *<st c="12103">基础设施即代码（infrastructure as code）</st>*<st c="12125">和</st>
    *<st c="12131">配置即代码（configuration as code）</st>* <st c="12152">都对平台的构建和发布有重要影响。</st>
    <st c="12208">然而，与软件应用程序不同，对于平台的最终用户来说，这些声明式的内容对他们的影响最大，尤其是与诸如银行应用等完全封闭的DevOps方面相比，后者对最终用户完全是黑盒处理。</st>
    <st c="12394">这些DevOps</st><st c="12438">方面对于平台最终用户来说完全是黑盒的。</st> <st c="12495">客户的身份会极大影响软件工程的某一方面相对于其他方面的重要性，因此区分了</st>
    *<st c="12638">软件开发和</st>* *<st c="12651">平台开发</st>*<st c="12671">。</st>
- en: <st c="12672">That user-centricity is also paramount to understanding what to
    prioritize within a platform to make it successful.</st> <st c="12789">While the
    users themselves will inform that to a large degree, as we continue through the
    chapter, we will highlight aspects that we think are most important for a</st>
    <st c="12953">successful platform.</st>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12672">以用户为中心的设计同样是理解平台成功所需优先考虑的事项的关键。</st> <st c="12789">虽然用户自身会在很大程度上提供相关信息，但随着本章的推进，我们将重点强调我们认为对成功平台最为重要的方面。</st>
    <st c="12953">成功的平台</st>。
- en: <st c="12973">With this new understanding of the SDLC for your platform, we
    can start to use that knowledge to contextualize what it means to build a platform
    as</st> <st c="13122">a product.</st>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12973">通过对平台的SDLC有了新的理解，我们可以开始利用这些知识来阐明将平台构建为**产品**的意义。</st>
- en: <st c="13132">Reducing cognitive load</st>
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="13122">减少认知负荷</st>
- en: <st c="13156">In</st> [*<st c="13160">Chapter 1</st>*](B31164_01.xhtml#_idTextAnchor014)<st
    c="13169">, we touched on the importance of</st> *<st c="13203">reducing cognitive
    load</st>*<st c="13226">. As technology and systems evolve, they become more complex.</st>
    <st c="13288">The high degree of complexity means that understanding every part
    of a system is a significantly larger mental burden.</st> <st c="13407">The old
    days of monolithic applications on the</st> **<st c="13454">Linux, Apache, MySQL,
    PHP</st>** <st c="13479">(</st>**<st c="13481">LAMP</st>**<st c="13485">) stack</st>
    <st c="13493">are behind us.</st> <st c="13509">Instead, microservices, the cloud,
    virtual networks, and so on have become part and parcel of the day-to-day operations
    of a</st> <st c="13634">software application.</st>
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13156">在</st> [*<st c="13160">第1章</st>*](B31164_01.xhtml#_idTextAnchor014)<st
    c="13169">中，我们提到了</st> *<st c="13203">减少认知负担</st>*<st c="13226">的重要性。随着技术和系统的发展，它们变得更加复杂。</st>
    <st c="13288">高度的复杂性意味着理解系统的每个部分将成为更大的心理负担。</st> <st c="13407">曾经的单体应用程序时代已经过去，</st>
    **<st c="13454">Linux, Apache, MySQL, PHP</st>** <st c="13479">(</st>**<st c="13481">LAMP</st>**<st
    c="13485">) 堆栈</st> <st c="13493">已经成为历史。</st> <st c="13509">现在，微服务、云、虚拟网络等已成为软件应用程序日常操作的组成部分。</st>
- en: <st c="13655">With modern software architectures, a full stack software engineer
    no longer needs to understand a server or operating system that application code
    runs on.</st> <st c="13813">The platform takes care of that for them.</st> <st
    c="13855">However, as much as the platform can abstract a lot of the details away,
    a developer still needs to be able to have awareness and insights into the underlying
    technologies in so far as they are relevant to their application.</st> <st c="14080">Therefore,
    the platform must strike the balance by making it easy for the users to get from
    it what they need, without the noise o</st><st c="14210">f what</st> <st c="14218">they
    don’t.</st>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13655">在现代软件架构中，完整栈软件工程师不再需要理解运行应用程序代码的服务器或操作系统。</st> <st c="13813">平台为他们处理了这些问题。</st>
    <st c="13855">然而，尽管平台可以抽象出许多细节，开发人员仍然需要对底层技术有一定的意识和理解，特别是当这些技术与他们的应用程序相关时。</st>
    <st c="14080">因此，平台必须在简化用户操作和提供所需信息之间找到平衡，避免提供那些不相关的“噪音”。</st>
- en: <st c="14229">If we compare and</st> <st c="14247">contrast the priorities of
    the</st> <st c="14279">personas, we can contextualize the scope of the platform
    as it applies to</st> <st c="14353">those users.</st>
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14229">如果我们对比</st> <st c="14247">和对照不同角色的优先级，</st> <st c="14279">我们可以将平台的范围与这些用户的需求进行对照。</st>
- en: '| **<st c="14365">Platform team</st>** | **<st c="14379">Both</st>** | **<st
    c="14384">Development team</st>** |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| **<st c="14365">平台团队</st>** | **<st c="14379">双方</st>** | **<st c="14384">开发团队</st>**
    |'
- en: '| <st c="14401">Tenant apps</st> | <st c="14413">Platform availability</st>
    | <st c="14435">Application availability</st> |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| <st c="14401">租户应用程序</st> | <st c="14413">平台可用性</st> | <st c="14435">应用程序可用性</st>
    |'
- en: '| <st c="14460">User management</st> | <st c="14476">Team RBAC</st> | <st c="14486">Application
    SLO/SLI</st> |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| <st c="14460">用户管理</st> | <st c="14476">团队RBAC</st> | <st c="14486">应用程序SLO/SLI</st>
    |'
- en: '| <st c="14506">User authentication</st> | <st c="14526">Security</st> | <st
    c="14535">Pass/fail</st> <st c="14546">CI tests</st> |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| <st c="14506">用户认证</st> | <st c="14526">安全</st> | <st c="14535">通过/失败</st>
    <st c="14546">CI测试</st> |'
- en: '| <st c="14554">Networking</st> | <st c="14565">Compliance</st> | <st c="14576">CD</st>
    <st c="14580">job success</st> |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| <st c="14554">网络</st> | <st c="14565">合规性</st> | <st c="14576">CD</st> <st
    c="14580">工作成功</st> |'
- en: '| <st c="14591">Platform SLO/SLI</st> | <st c="14608">Log aggregation</st>
    | <st c="14624">Application upgrades</st> |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| <st c="14591">平台SLO/SLI</st> | <st c="14608">日志聚合</st> | <st c="14624">应用程序升级</st>
    |'
- en: '| <st c="14645">Platform upgrades</st> | <st c="14663">Error and</st> <st c="14674">exception
    tracking</st> | <st c="14692">Application</st> <st c="14705">resource benchmarking</st>
    |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| <st c="14645">平台升级</st> | <st c="14663">错误和</st> <st c="14674">异常追踪</st>
    | <st c="14692">应用程序</st> <st c="14705">资源基准测试</st> |'
- en: '| <st c="14726">Platform scaling</st> | <st c="14743">Policy violation</st>
    |  |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| <st c="14726">平台扩展性</st> | <st c="14743">政策违规</st> |  |'
- en: '| <st c="14760">Platform architecture</st> | <st c="14782">Quota consumption</st>
    |  |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| <st c="14760">平台架构</st> | <st c="14782">配额消耗</st> |  |'
- en: '| <st c="14800">Platform serviceability</st> | <st c="14824">Application performance</st>
    |  |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| <st c="14800">平台可维护性</st> | <st c="14824">应用程序性能</st> |  |'
- en: '<st c="14848">Table 6.1: Comparing and contrasting developer versus platform
    team priorities</st>'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14848">表6.1：对比开发团队与平台团队的优先级</st>
- en: <st c="14927">As you can</st> <st c="14939">see, even with a platform team</st>
    <st c="14969">taking care of so many aspects of how an application is delivered
    to an end user, the development team for the application still has many considerations.</st>
    <st c="15124">The platform can take care of shared considerations, such as security
    and compliance, but it’s not the job of the platform to guarantee that the app
    the development team produces is performant.</st> <st c="15318">You could consider
    your IDP a managed service, which wouldn’t be a bad definition for</st> <st c="15404">the
    product.</st>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14927">正如你所看到的，即使有平台团队</st> <st c="14939">负责许多应用程序交付给最终用户的方面，应用程序的开发团队仍然有许多需要考虑的问题。</st>
    <st c="14969">平台可以处理共享的考虑因素，例如安全性和合规性，但平台的工作并不是保证开发团队生产的应用程序具有良好的性能。</st> <st
    c="15124">你可以将你的IDP视为一种托管服务，这对于</st> <st c="15404">该产品来说并不是一个坏的定义。</st>
- en: <st c="15416">As a managed service seeks to strike the balance between doing
    and enabling, the preceding table becomes the map to building a successful platform.</st>
    <st c="15565">For example, by investing in tooling around observability and reliability,
    a platform can support the development team in managing their considerations,
    while abstracting away everything else it can.</st> <st c="15765">A developer
    who doesn’t have to care how aggregate logs are stored but knows how to access
    them if needed can simplify day-to-day workflows significantly, allowing more
    cycles to be spent on feature development instead of operational overhead.</st>
    <st c="16009">This reduction of cognitive load can lead to fewer context shifts
    for the team and, therefore, fewer mistakes and less stress.</st> <st c="16136">This
    way, an investment in a platform is an investment in the productivity and health
    of the</st> <st c="16229">development team.</st>
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15416">作为一种托管服务，旨在实现“做”和“启用”之间的平衡，前面的表格成为了构建成功平台的路线图。</st> <st c="15565">例如，通过在可观察性和可靠性工具方面进行投资，平台可以支持开发团队管理他们的考量，同时抽象掉它能抽象掉的其他一切。</st>
    <st c="15765">一个不必关心聚合日志如何存储的开发人员，但知道如何在需要时访问它们，可以显著简化日常工作流程，从而让更多的精力投入到功能开发中，而不是运营负担。</st>
    <st c="16009">这种认知负荷的减少可以导致团队的上下文切换更少，从而减少错误和压力。</st> <st c="16136">通过这种方式，对平台的投资就是对开发团队生产力和健康的投资。</st>
    <st c="16229">开发团队。</st>
- en: <st c="16246">If we think back to our fictitious company, Financial One ACME,
    we can imagine how much more the cognitive load matters as it undergoes a cloud
    transformation strategy.</st> <st c="16416">Since the company is not building
    everything greenfield, its developers have to maintain legacy systems and architectures
    while also refactoring for the new era.</st> <st c="16578">A platform in support
    of this effort allows the developers to learn less.</st> <st c="16652">They just
    need to know what the platform expects from them as they approach their refactorization
    and</st> <st c="16754">migration strategy.</st>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16246">如果我们回想一下我们虚构的公司，Financial One ACME，我们可以想象在公司进行云转型战略时，认知负荷会变得更加重要。</st>
    <st c="16416">由于公司并不是从零开始构建一切，开发人员不仅要维护遗留系统和架构，还要进行新的时代重构。</st> <st c="16578">支持这一工作的平台可以让开发人员学得更少。</st>
    <st c="16652">他们只需要知道平台在他们进行重构和</st> <st c="16754">迁移战略时对他们的期望。</st>
- en: <st c="16773">A platform’s commitment to the reduction of cognitive load is
    essentially the promise to developers that you will help them to work more efficiently.</st>
    <st c="16924">Fewer context shifts, expedient and direct feedback loops, and ease
    of use all contribute to developer happiness.</st> <st c="17038">Happy developers
    are less stressed co-workers and contribute to a more positive work environment,
    making it a win-win for the development and</st> <st c="17180">platform teams.</st>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16773">平台对减少认知负荷的承诺本质上是向开发人员做出的承诺，即你将帮助他们更高效地工作。</st> <st c="16924">减少上下文切换、迅速直接的反馈循环和易用性，所有这些都有助于提高开发人员的工作满意度。</st>
    <st c="17038">快乐的开发人员是压力更小的同事，有助于创造更加积极的工作环境，这对开发团队和</st> <st c="17180">平台团队来说都是双赢的局面。</st>
- en: <st c="17195">Utilizing a platform while balancing cognitive load</st>
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="17195">在平衡认知负荷的同时使用平台</st>
- en: <st c="17247">While so much of a</st> <st c="17267">platform is serving to build
    an application, it must equally serve to operate the application as well.</st>
    <st c="17370">While the platform’s requirements should be well documented and
    easily understood, humans unfortunately are fairly error-prone; as such, it’s
    incumbent on the platform to enforce its norms.</st> <st c="17560">Kubernetes
    fortunately supports this natively to some degree, with admission controllers</st>
    <st c="17649">and</st> **<st c="17653">Role-Based Access Control</st>** <st c="17678">(</st>**<st
    c="17680">RBAC</st>**<st c="17684">), but you can also leverage tooling such as
    policy engines to ensure that workloads or actions that do not meet those norms
    are rejected and an error is given to the user.</st> <st c="17858">The sooner
    that feedback reaches the user, the lower their cognitive load, as they do not
    have to context-shift to respond to</st> <st c="17984">the platform.</st>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17247">尽管平台的许多功能是为了构建应用程序，但它同样必须能够支持应用程序的运行。</st> <st c="17267">尽管平台的需求应当有详细的文档记录且易于理解，但人类往往容易出错；因此，平台必须强制执行其规范。</st>
    <st c="17370">幸运的是，Kubernetes在一定程度上本身就支持这一点，通过准入控制器</st> <st c="17560">和</st>
    **<st c="17653">基于角色的访问控制</st>** <st c="17678">(</st>**<st c="17680">RBAC</st>**<st
    c="17684">)，但你也可以利用工具如策略引擎来确保那些不符合规范的工作负载或操作被拒绝，并给用户返回错误信息。</st> <st c="17858">越早收到反馈，用户的认知负担越轻，因为他们不需要切换上下文来响应</st>
    <st c="17984">平台。</st>
- en: <st c="17997">So, how are you supposed to reduce the cognitive load for your
    engineering teams with an internal</st> <st c="18096">developer platform?</st>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17997">那么，如何通过内部</st> <st c="18096">开发者平台来减少工程团队的认知负担呢？</st>
- en: <st c="18115">If you don’t know where to begin, start with empathy as you consider</st>
    <st c="18185">implementation details.</st>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18115">如果你不知道从哪里开始，考虑到实现细节时，从同理心出发。</st>
- en: <st c="18208">Suppose you are one of the engineers using the platform.</st>
    <st c="18266">It is 4 a.m., you are panicking, and nobody else is there to help.</st>
    <st c="18333">Ask yourself, “</st>*<st c="18348">Will this be easy to use?</st>*<st
    c="18374">” When you are satisfied with your approach, ask an engineer to validate</st>
    <st c="18448">your assumptions.</st>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18208">假设你是使用该平台的工程师之一。</st> <st c="18266">现在是凌晨四点，你正处于慌乱中，而没有其他人能帮助你。</st>
    <st c="18333">问问自己：“</st>*<st c="18348">这会容易使用吗？</st>*<st c="18374">” 当你对自己的方法感到满意时，找一位工程师来验证</st>
    <st c="18448">你的假设。</st>
- en: <st c="18465">Every detail should align with this principle.</st> <st c="18513">If
    core functionality is simple and makes life easier, users will not have to take
    on cognitive load.</st> <st c="18614">As you account for other aspects such</st>
    <st c="18652">as integrations, follow the same approach.</st> <st c="18696">Straightforward
    architectures are often the most effective.</st> <st c="18756">If “</st>*<st c="18760">Why
    is this architecture here?</st>*<st c="18791">” cannot be answered with “</st>*<st
    c="18819">Because it helps the user</st>*<st c="18845">,” perhaps it should not
    be there</st> <st c="18879">at all.</st>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18465">每个细节都应与这一原则保持一致。</st> <st c="18513">如果核心功能简单且能简化用户的操作，用户就无需承担认知负担。</st>
    <st c="18614">在考虑其他方面时，</st> <st c="18652">比如集成，遵循相同的方法。</st> <st c="18696">直接的架构往往是最有效的。</st>
    <st c="18756">如果“</st>*<st c="18760">为什么会有这个架构存在？</st>*<st c="18791">”这个问题无法用“</st>*<st
    c="18819">因为它帮助了用户</st>*<st c="18845">”来回答，也许它根本不应该存在。</st> <st c="18879">完全没有必要。</st>
- en: <st c="18886">There are still significant gains that can be made by fine-tuning
    the operations of the IDP.</st> <st c="18980">Additionally, by setting a bar for
    the applications that will run on the platform, your team can define a maturity
    model for them.</st> <st c="19111">That maturity model will help define what an
    application needs to be a successful member of the platform environment, which
    means that developers can work against it as a checklist, instead of needing to
    experiment, ask a human,</st> <st c="19340">or guess.</st>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18886">通过微调IDP的操作，仍然可以取得显著的提升。</st> <st c="18980">此外，设定平台上应用程序的标准，你的团队可以为它们定义一个成熟度模型。</st>
    <st c="19111">这个成熟度模型将帮助定义一个应用程序需要具备哪些条件，才能成为平台环境中的成功成员，这意味着开发者可以以此为检查表进行工作，而无需进行实验、向人请教，</st>
    <st c="19340">或猜测。</st>
- en: <st c="19349">Pre-production versus production</st>
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="19349">前期生产与生产阶段</st>
- en: <st c="19382">A platform covers both</st> <st c="19405">pre-production</st>
    <st c="19420">and production for a software application.</st> <st c="19464">The
    part of the platform where the application</st> <st c="19510">lands is referred
    to as the</st> **<st c="19539">application</st>** **<st c="19551">landing zone</st>**<st
    c="19563">.</st>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19564">While a platform must consider both, the two should never mix,
    so the platform must enforce logical segmentations between the environments.</st>
    <st c="19705">It can do this via architecture or a policy.</st> <st c="19750">However,
    architecture is the best and most secure model, which we’ll cover further in</st>
    [*<st c="19836">Chapter 7</st>*](B31164_07.xhtml#_idTextAnchor381)<st c="19845">.
    In the current chapter, while we may make references to security best practices
    and segmentation strategies, the in-depth explanations can be found in</st> [*<st
    c="19998">Chapter 7</st>*](B31164_07.xhtml#_idTextAnchor381)<st c="20007">. The
    important takeaway for these environments in this chapter should be how they interact
    with cognitive load and how the platform aims to reduce that load across</st>
    <st c="20172">both scopes.</st>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20184">Authentication and tenancy</st>
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="20211">As your platform</st> <st c="20228">expands and gains adoption,
    it essentially becomes multi-tenant.</st> <st c="20294">This is due to the importance
    of ensuring a least privilege policy in a secure environment, as well as helping
    to ensure users don’t trip over each other.</st> <st c="20449">With</st> <st c="20454">multi-tenancy,
    it’s important to still give the feeling of a single tenancy, which means the
    existence of the other users and tenants must be hidden from</st> <st c="20608">each
    user.</st>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20618">One of the first integrations you’ll add to the platform relates
    to authentication and user management.</st> <st c="20723">Most</st> **<st c="20728">OpenID
    Connect</st>** <st c="20742">(</st>**<st c="20744">OIDC</st>**<st c="20748">)
    providers</st> <st c="20760">can integrate into the common IDP toolchain, so selecting
    the correct one won’t be very difficult.</st> <st c="20860">From there, user management
    is pretty straightforward, although it differs between the common tools.</st>
    <st c="20961">For cognitive load, less is more, so one way for your users to authenticate
    across all aspects of a platform means fewer login workflows to remember, fewer
    logins per day, fewer passwords, and a homogenized experience with the rest of
    the tools in</st> <st c="21209">a company.</st>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21219">Let’s look at this in a more realistic scenario.</st> <st c="21269">Financial
    One ACME is a bank.</st> <st c="21299">This means they’re in a highly regulated
    industry with a lot of very sensitive data to protect.</st> <st c="21395">Controlling
    who has access to what data and how they access it is one of the most important
    aspects of the company’s security and compliance story.</st> <st c="21543">It’s
    too much to expect users to remember to exercise all of those security and compliance
    practices perfectly every time.</st> <st c="21666">Thus, the platform needs to
    enforce</st> <st c="21702">that programmatically.</st>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21219">让我们在一个更现实的场景中来看这个问题。</st> <st c="21269">Financial One ACME 是一家银行。</st>
    <st c="21299">这意味着它们处于一个高度监管的行业，需要保护大量非常敏感的数据。</st> <st c="21395">控制谁能访问哪些数据，以及如何访问这些数据，是公司安全性和合规性方面最重要的内容之一。</st>
    <st c="21543">期望用户每次都完美地记住并执行所有这些安全和合规实践，实在是过于苛刻。</st> <st c="21666">因此，平台需要程序化地强制执行</st>
    <st c="21702">这些规则。</st>
- en: <st c="21724">Meeting those</st> <st c="21738">requirements in any industry,
    highly regulated or not, all comes down to</st> <st c="21812">RBAC – how you isolate
    users from each other and guarantee that they have the actions they need without
    the access they do not.</st> <st c="21940">Take a look at the following figure
    to see an example of a</st> <st c="21999">multi-tenant IDP.</st>
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 满足任何行业的这些<st c="21724">要求</st>，无论是否高度监管，最终都归结于<st c="21738">RBAC —— 如何将用户相互隔离，并确保他们只拥有需要的权限，而没有不必要的访问权限。</st>
    <st c="21812">请查看下图，了解一个</st> <st c="21999">多租户身份提供者（IDP）的示例。</st>
- en: '![Figure 6.4: Multi-tenancy on an IDP cluster](img/B31164_06_04.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4：IDP 集群中的多租户](img/B31164_06_04.jpg)'
- en: '<st c="22265">Figure 6.4: Multi-tenancy on an IDP cluster</st>'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22265">图 6.4：IDP 集群中的多租户</st>
- en: <st c="22308">In this example, workloads from both tenants can share space on
    a node, but through RBAC, the tenants cannot see the other workloads on the same
    nodes where their workloads run.</st> <st c="22487">Another option would be to
    also ensure only one tenant’s workload can run on each node.</st> <st c="22575">However,
    that level of isolation can have negative trade-offs, as it could impact the</st>
    **<st c="22661">high availability</st>** <st c="22678">of those</st> <st c="22687">workloads,
    or require more nodes in order for tenants to have full isolation and high availability.</st>
    <st c="22788">We discussed high availability for a platform in</st> [*<st c="22837">Chapter
    3</st>*](B31164_03.xhtml#_idTextAnchor133)<st c="22846">, and those same principles
    apply to an application that your development team is working on.</st> <st c="22940">Just
    as with the platform, high availability is a characteristic of the resilience
    of an application.</st> <st c="23042">This might mean its ability to handle load
    through scaling, or just its general uptime.</st> <st c="23130">Things that impact
    high availability include location.</st> <st c="23185">While you might have three
    Pods in</st> <st c="23220">a</st> **<st c="23222">ReplicaSet</st>** <st c="23232">for
    an application, if all three of those Pods are on the same node and it is restarted
    (such as with upgrades to the platform), then the application goes down; therefore,
    it is not highly available.</st> <st c="23433">Typically, a highly available application
    will have its replicasets spread across multiple nodes, and if those nodes are
    all in different availability zones, then the application has another layer of
    resilience added to it.</st> <st c="23657">Developers following best practices
    for cloud-native platforms will typically expect their application to be highly
    available, which means at least two other replicasets running on</st> <st c="23838">different
    nodes.</st>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22308">在这个例子中，两个租户的工作负载可以共享一个节点的空间，但通过 RBAC，租户无法看到在同一节点上运行的其他工作负载。</st>
    <st c="22487">另一种选择是确保每个节点上只能运行一个租户的工作负载。</st> <st c="22575">然而，这种隔离程度可能会带来负面影响，因为它可能会影响</st>
    **<st c="22661">高可用性</st>** <st c="22678">，或者需要更多节点来确保租户之间完全隔离并保持高可用性。</st> <st
    c="22788">我们在</st> [*<st c="22837">第 3 章</st>*](B31164_03.xhtml#_idTextAnchor133)<st
    c="22846">讨论了平台的高可用性，这些相同的原则也适用于你的开发团队正在开发的应用程序。</st> <st c="22940">与平台一样，高可用性是应用程序韧性的一项特征。</st>
    <st c="23042">这可能意味着它通过扩展来处理负载的能力，或者仅仅是其整体的正常运行时间。</st> <st c="23130">影响高可用性的因素之一是位置。</st>
    <st c="23185">虽然你可能在</st> <st c="23220">一个</st> **<st c="23222">副本集（ReplicaSet）</st>**
    <st c="23232">中有三个 Pod，但如果这三个 Pod 都在同一个节点上，并且该节点被重启（例如平台升级时），那么应用程序将会停机；因此，它就不是高可用的。</st>
    <st c="23433">通常，高可用的应用程序会将副本集分布在多个节点上，如果这些节点位于不同的可用区，则该应用程序会增加一层额外的韧性。</st> <st
    c="23657">遵循云原生平台最佳实践的开发人员通常会期望他们的应用程序具备高可用性，这意味着至少有两个副本集在</st> <st c="23838">不同节点上运行。</st>
- en: <st c="23854">RBAC</st>
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="23854">RBAC</st>
- en: <st c="23859">Regardless of the tenancy model, the kubernetes system RBAC will
    become the spine of self-service for a platform.</st> <st c="23974">You’ll use
    RBAC to restrict user access to the IDP for only the namespaces and environments
    where their workloads will land within the IDP.</st> <st c="24114">You’ll additionally
    have similar</st> <st c="24147">RBAC policies in the end user-facing environment
    where the application will run.</st> <st c="24228">The RBAC policies in the production
    environment will be less permissive than in the development environments, as it
    will be necessary to maintain a higher degree of scrutiny on those permissions.</st>
    <st c="24424">You’ll learn more about this in</st> [*<st c="24456">Chapter 7</st>*](B31164_07.xhtml#_idTextAnchor381)<st
    c="24465">.</st>
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23859">无论租户模型如何，Kubernetes 系统中的 RBAC 将成为平台自服务的骨架。</st> <st c="23974">你将使用
    RBAC 限制用户对 IDP 的访问，仅限于他们的工作负载将落在 IDP 中的命名空间和环境。</st> <st c="24114">此外，你将在面向最终用户的环境中也有类似的</st>
    <st c="24147">RBAC 策略，应用程序将在该环境中运行。</st> <st c="24228">生产环境中的 RBAC 策略将比开发环境中更为严格，因为需要对这些权限进行更高程度的审查。</st>
    <st c="24424">你将在</st> [*<st c="24456">第 7 章</st>*](B31164_07.xhtml#_idTextAnchor381)<st
    c="24465">中学习更多关于此的内容。</st>
- en: <st c="24466">Further reading</st>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24466">进一步阅读</st>
- en: <st c="24482">Kubernetes’ official documentation can be found</st> <st c="24531">here:</st>
    [<st c="24537">https://kubernetes.io/docs/reference/access-authn-authz/rbac/</st>](https://kubernetes.io/docs/reference/access-authn-authz/rbac/)<st
    c="24598">.</st>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24599">Borrowing an example from the official documentation, we can see
    an example of RBAC where a user who is assigned a role would have the capability
    to read secrets, but they would not be able to edit or</st> <st c="24801">delete
    them:</st>
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="25134">Similar to this example, by leveraging</st> <st c="25173">RBAC,
    you set your users up to successfully navigate a platform with appropriate guardrails
    in place.</st> <st c="25276">So, how do you determine what a robust RBAC policy
    needs to have to strike the balance between access, actions, and restrictions?</st>
    <st c="25406">This is where self-service takes center stage.</st> <st c="25453">Let’s
    look at some workflows that your users may expect to have on</st> <st c="25520">the
    platform.</st>
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5: Example workflows for IDP users](img/B31164_06_05.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
- en: '<st c="25535">Figure 6.5: Example workflows for IDP users</st>'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25578">In the example illustrated in</st> *<st c="25609">Figure 6</st>**<st
    c="25617">.5</st>*<st c="25619">, we have multiple teams and, therefore, likely
    multiple users within the teams, reliant on the same systems within a platform.</st>
    <st c="25747">Sometimes, they will be reliant on the same systems at the same
    time.</st> <st c="25817">Depending on your CI/CD system of choice, best practices
    can vary; however, in general, the idea is that the platform team will ensure
    that the components required for the IDP are capable of scaling</st> <st c="26016">to
    users.</st>
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26025">The authentication system used for the Kubernetes cluster can
    be used for pre-production tools such as Argo CD as well, allowing users to leverage
    independent projects within the same Argo</st> <st c="26215">CD instance.</st>
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26227">While it’s not a best practice, it is technically possible to
    do the same access pattern for production-level access; however, when production
    is being accessed, it’s a best practice to have a much stricter set of authentications
    and an even more limited permission set once authenticated.</st> <st c="26518">We’ll
    cover this further in</st> [*<st c="26546">Chapter 7</st>*](B31164_07.xhtml#_idTextAnchor381)<st
    c="26555">,</st> *<st c="26557">Building a</st>* *<st c="26568">Secure Platform</st>*<st
    c="26583">.</st>
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26584">Noisy neighbor prevention</st>
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="26610">It may not immediately be obvious how a noisy neighbor</st> <st
    c="26665">can impact cognitive load, but the protection from such an event helps
    to prevent production incidents that can be difficult to troubleshoot and resolve,
    especially in an environment where multi-tenancy is the standard.</st> <st c="26886">It
    also helps users troubleshoot their applications or assists the platform team
    in troubleshooting production issues by ruling out scenarios that become less
    likely as more protections are put in place.</st> <st c="27090">Since your developer
    teams should expect to have limited access to the production side of an IDP, and
    no access to the metrics and workloads for other teams, all work done to prevent
    a noisy neighbor helps to ensure that those workloads are less likely to enter
    each team’s</st> <st c="27364">cognitive load.</st>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27379">In the context of an IDP, a noisy neighbor means a workload that
    runs in the same environment as another and hogs resources, whether this is through
    an abundance of network traffic, CPU, or memory utilization, or other less-than-neighborly
    behaviors.</st> <st c="27631">Much like a city would have ordinances to prevent
    a neighbor from blocking off a street or playing music way too loud, a platform
    can enforce norms to ensure that one workload doesn’t negatively</st> <st c="27826">impact
    another.</st>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27841">In many real-world scenarios, one Kubernetes cluster is utilized
    for multiple environments.</st> <st c="27934">For organizations with more limited
    cloud spend budgets, dev, QA, staging, and production environments may all be
    located on the same cluster.</st> <st c="28077">Technically speaking, an entire
    IDP could be one cluster.</st> <st c="28135">While this isn’t what we’d consider
    a best practice, it is an extremely common one, utilized to keep costs down.</st>
    <st c="28248">It’s in these scenarios where noisy neighbors are most likely to
    occur, but it can happen even when production is fully isolated, due to a workload
    either experiencing a software bug or just a higher than normal resource utilization
    for valid reasons.</st> <st c="28500">Containerized workloads have an advantage
    in protecting against noisy neighbor scenarios in these shared environments, in
    that those Pod and container definitions can hold the resource definitions, The
    encapsulation of the workload is a strength, particularly for resource management.</st>
    <st c="28785">While the vast majority of protections against noisy neighbor scenarios
    should happen as part of defensive programming for software applications, as well
    as through accurately benchmarking and identifying theresource need of those applications,
    a platform has the ability to be hardened</st> <st c="29072">as well.</st>
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29080">How can you achieve that hardening?</st> <st c="29117">Here’s
    how:</st>
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29128">Be mindful of the resources that are shared, even with workload
    isolation best practices enforced, such as etcd, the API server, and the</st>
    <st c="29266">networking stack</st>
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="29282">Take preventative measures against</st> <st c="29318">CPU starvation</st>
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="29332">Cluster autoscaling – the automatic addition (or removal)</st>
    <st c="29391">of nodes</st>
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="29399">The care and feeding of etcd</st>
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="29428">etcd is the key-value store that holds every definition for all
    the Kubernetes objects on a cluster – Pod definitions, job definitions, StatefulSets,
    DaemonSets,</st> **<st c="29591">CustomResourceDefinitions</st>** <st c="29616">(</st>**<st
    c="29618">CRDs</st>**<st c="29622">), and so</st> <st c="29632">on are all stored
    in etcd.</st> <st c="29660">This means it can get quite full as platform usage
    increases.</st> <st c="29722">An etcd project</st> <st c="29737">recommends a
    minimum set of resources allocated to the etcd Pods in order to guarantee successful
    production operations.</st> <st c="29859">The detailed recommendations can be
    found in the etcd docs (</st>[<st c="29919">https://etcd.io/docs/v3.6/op-guide/hardware/</st>](https://etcd.io/docs/v3.6/op-guide/hardware/)<st
    c="29964">) but the functional areas are disks, networking, CPU, and memory.</st>
    <st c="30032">As your cluster utilization grows, so too does the needs of etcd.</st>
    <st c="30098">Generally, the best practices for etcd include ensuring it has priority
    for CPU, networking, and dedicated disks, with high throughput and low latency.</st>
    <st c="30250">A</st> **<st c="30252">solid-state drive</st>** <st c="30269">(</st>**<st
    c="30271">SSD</st>**<st c="30274">) should be used for the etcd storage if possible.</st>
    <st c="30326">The etcd</st> <st c="30335">documentation has several suggestions
    for the tuning of etcd, so we won’t reiterate them here.</st> <st c="30430">It’s
    important to keep up with the latest recommendations from the project itself,
    as the technology will continue to evolve over time.</st> <st c="30566">Since
    etcd is a critical component to the successful operations of a Kubernetes cluster,
    watching it carefully with observability and proactively responding to evidence
    of disk pressure, or other resource issues, will be mission-critical to guarantee</st>
    <st c="30817">platform availability.</st>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30839">Even after your etcd configuration is optimized, the actual usage
    or over usage of etcd can still result in noisy neighbors.</st> <st c="30965">The
    cloud-native CD system Argo CD, for example, stores its jobs as CRD entries, not
    as Kubernetes jobs.</st> <st c="31070">As the number of teams and deployments
    from Argo CD grows, so too does the number of entries in etcd.</st> <st c="31172">If
    etcd fills up, the Kubernetes API server goes down.</st> <st c="31227">To prevent
    this, care must be taken to ensure that etcd is healthy and not</st> <st c="31302">getting
    overfull.</st>
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31319">One method is to ensure that you’re pruning old</st> <st c="31367">CRD
    entries from etcd.</st> <st c="31391">In the case of Argo CD, this functionality
    is built natively into the app.</st> <st c="31466">In the case of standard Kubernetes
    jobs, a time-to-live mechanism can be utilized by applying the time desired, in
    sections, to the</st> `<st c="31598">spec</st>` <st c="31602">field of the job
    definition.</st> <st c="31632">With this, after the given amount of time has passed
    since the job has succeeded or failed, the garbage collection mechanism will run
    and remove the entry, thus managing the size and health</st> <st c="31822">of
    etcd.</st>
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31319">一种方法是确保你从 etcd 中修剪掉旧的</st> <st c="31367">CRD 条目。</st> <st c="31391">在
    Argo CD 的情况下，这个功能是原生集成到应用中的。</st> <st c="31466">在标准 Kubernetes 作业的情况下，可以通过在作业定义的</st>
    `<st c="31598">spec</st>` <st c="31602">字段中应用所需的时间，来使用生存时间（TTL）机制。</st> <st c="31632">这样，在作业成功或失败后经过一定时间，垃圾回收机制将运行并移除该条目，从而管理
    etcd 的大小和健康状态。</st>
- en: <st c="31830">Similarly, other Kubernetes kinds have their own way of invoking
    a clean-up mechanism.</st> <st c="31918">For Deployments, there is a spec for</st>
    `<st c="31955">revisionHistoryLimit</st>`<st c="31975">, which will determine
    how many old versions of the Deployment will be stored.</st> <st c="32054">If
    the number is 0, then in the event of a production issue, the deployment cannot
    be rolled back, but etcd is clean as</st> <st c="32174">a whistle.</st>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31830">类似地，其他 Kubernetes 类型也有各自的清理机制。</st> <st c="31918">对于部署（Deployments），有一个规范是</st>
    `<st c="31955">revisionHistoryLimit</st>`<st c="31975">，它决定了将保留多少个旧版本的部署。</st>
    <st c="32054">如果该数字为 0，那么在生产问题发生时，部署将无法回滚，但 etcd 会保持干净，像</st> <st c="32174">口哨一样清晰。</st>
- en: <st c="32184">Exactly how to tune these clean-up measures will be dependent
    on the number of users and the number of etcd entries that those users generate.</st>
    <st c="32328">The size of etcd will also be a factor, and that can be scaled by
    increasing the size of the control plane nodes.</st> <st c="32442">So, when to
    scale, when to prune, and when to consider adding a cluster to the IDP environment
    will be an exercise in cost management, ROI, and a fundamental part of the platform’s
    life cycle.</st> <st c="32635">It will also need to be a factor in the integrations
    you select for your IDP, but we’ll cover cost management more in</st> [*<st c="32753">Chapter
    8</st>*](B31164_08.xhtml#_idTextAnchor430)<st c="32762">.</st>
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32184">如何调整这些清理措施，将取决于用户数量以及这些用户生成的 etcd 条目数量。</st> <st c="32328">etcd
    的大小也是一个因素，而这个因素可以通过增加控制平面节点的大小来扩展。</st> <st c="32442">因此，何时扩展，何时修剪，何时考虑向 IDP 环境中添加集群，将是一个成本管理、投资回报率（ROI）和平台生命周期的基本部分。</st>
    <st c="32635">它还需要成为你为 IDP 选择的集成工具的一个因素，但我们会在</st> [*<st c="32753">第 8 章</st>*](B31164_08.xhtml#_idTextAnchor430)<st
    c="32762">中更详细地讨论成本管理。</st>
- en: <st c="32763">Understanding the CPU and the scheduler to avoid starvation</st>
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="32763">理解 CPU 和调度器以避免饥饿现象</st>
- en: <st c="32823">The next resource that is shared at the cluster scope, regardless
    of tenancy models, is the CPU.</st> <st c="32921">As previously</st> <st c="32935">mentioned,
    when we discussed reliability, in Kubernetes, there is a maximum amount of memory
    that can be used on a node object.</st> <st c="33063">All of the Pods and their
    memory requests are totaled, and if the total memory exceeds what is allocated
    to the node, a Pod will either be scheduled to a different node with available
    room or fail to be scheduled.</st> <st c="33277">If a Pod tries to use more memory
    than the node has available, it will be terminated and rescheduled.</st> <st c="33379">There’s
    a strict boundary on memory allocation along the nodes.</st> <st c="33443">A CPU,
    at a glance, appears to have the same functionality, but in reality, all CPUs
    are available to all nodes.</st> <st c="33556">This means that while app performance
    may be primarily a consideration of the development team, the developers shouldn’t
    have to worry about whether the platform can support the needs of an application.</st>
    <st c="33759">While the developer will need to inform the platform of the workload’s
    needs, the platform will need to be able to</st> <st c="33874">support it.</st>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33885">The actual implementation for</st> <st c="33915">CPU management
    in Kubernetes is the</st> **<st c="33952">Completely Fair Scheduler</st>** <st
    c="33977">(</st>**<st c="33979">CFS</st>**<st c="33982">), which</st> <st c="33991">is
    the same one that</st> <st c="34012">the</st> **<st c="34017">Linux kernel</st>**
    <st c="34029">uses.</st> <st c="34036">Functionally, what this means is that workloads
    on a node can use more of a CPU than the node is allocated if the CPU</st> <st
    c="34154">is available.</st>
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: <st c="34167">While this capability to overcommit CPU can be useful, as it can
    technically support bin packing, allowing a platform to support more workloads
    as long as they’re not running simultaneously, and without needing to reserve
    more virtual hardware (or actual hardware if you’re running on bare metal), there
    are reasons why you might want to prevent some or all of the CPU from being utilized
    in this fashion, even if it’s</st> <st c="34587">technically available.</st>
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: <st c="34609">For example, in a production environment, there may be certain
    workloads that must always be performant or are particularly sensitive to CPU
    caching, while other operations could be a little slower or reschedule to new
    nodes more freely.</st> <st c="34848">For these situations, you can better guarantee
    CPU availability by altering the CPU</st> <st c="34932">manager policy.</st>
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: <st c="34947">To understand the full implementation of CPU management</st> <st
    c="35003">in Kubernetes, read the documentation</st> <st c="35042">here:</st>
    [<st c="35048">https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/</st>](https://kubernetes.io/docs/tasks/administer-cluster/cpu-management-policies/)<st
    c="35124">.</st>
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: <st c="35125">The platform will need to enable CPU management policies in the
    kubelet configuration in order for CPUs to be excluded from the pool.</st> <st
    c="35260">You will have to define how much CPU to reserve, but you can reserve
    all of the CPU, minus what is needed to run the Kubernetes-critical workloads.</st>
    <st c="35408">In order to get the desired outcome, where a Pod is guaranteed the
    CPU it needs at the expense of other Pods, the developer will need to specify
    both requests and limits as whole integers in the Pod spec, and those two values</st>
    <st c="35634">must match.</st>
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: <st c="35645">Here’s an example</st> <st c="35664">Pod spec:</st>
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="35864">Once your node is configured in this way, it is known as</st>
    *<st c="35922">guaranteed</st>* <st c="35932">by the platform and, therefore,
    is able to use exclusive</st> <st c="35989">CPU.</st> <st c="35995">The</st> **<st
    c="35999">kube-scheduler</st>** <st c="36013">(</st>**<st c="36015">scheduler</st>**
    <st c="36024">for short) will prioritize it being on nodes that</st> <st c="36074">support
    the CPU needs of the Pod.</st> <st c="36109">If that’s only one</st> <st c="36127">node,
    then the scheduler will prioritize that; however, if you have multiple or all
    nodes configured to use exclusive CPU, then although the priority of the Pod will
    be high and, therefore, less likely to be moved (except in more extreme cases),
    it could still be placed on a</st> <st c="36404">new node.</st>
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36413">To ensure that a specific node is always selected, or a specific
    type of node is always selected, you can label nodes.</st> <st c="36533">Doing
    so helps the scheduler to match Pods to nodes with labels defined in the Pod spec.</st>
    <st c="36622">This further ensures the correct Pod placement, which has use cases
    beyond noisy neighbor prevention</st> <st c="36723">as well.</st>
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36731">If you’ve decided to follow along with a local kind cluster and
    haven’t already, let’s set up the cluster now.</st> <st c="36843">First, clone
    the GitHub repository for the book and change the directory to the one for</st>
    [*<st c="36931">Chapter 6</st>*](B31164_06.xhtml#_idTextAnchor341)<st c="36940">:</st>
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="37153">After your cluster-named platform is created, set the context
    to the kind cluster for the chapter.</st> <st c="37253">This removes the need
    to add</st> `<st c="37282">--context kind-platform</st>` <st c="37305">to the
    end of each</st> `<st c="37325">kubectl</st>` <st c="37332">command:</st>
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="37390">Now that we’ve made our lives a little easier, we can begin the
    Pod</st> <st c="37459">labeling demo.</st>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: <st c="37473">Here’s the node label command and</st> <st c="37508">example output:</st>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="37610">Run this command to see the label on</st> <st c="37648">the node:</st>
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="37950">Our final</st> <st c="37960">Pod will look something</st> <st
    c="37985">like this:</st>
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="38315">Important note</st>
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38330">In order for the CPU management policy to be enforced on previous
    workloads and new workloads, you have to drain the node and</st> <st c="38457">restart
    it.</st>
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38468">Outside of the CPU, the</st> <st c="38492">scheduler looks at
    several other different factors to determine how to prioritize or move Pods, including
    an explicit Pod priority.</st> <st c="38625">If Pod priority is not well understood
    or the tenancy of a platform is not well known, it may not be immediately obvious
    to an engineer why they should not place a high priority on their application
    Pods.</st> <st c="38830">As far as a developer is concerned their production application
    is probably the most important workload.</st> <st c="38935">However, this can
    create noisy neighbor situations if not used well.</st> <st c="39004">One over-prioritized
    Pod seems harmless.</st> <st c="39045">In practice, it is a constant denial-of-service
    attack that worsens with scale.</st> <st c="39125">If the Pod is assigned to a
    replicaset and the instances of it grow with the cluster, then there’s a growing
    number of over-prioritized workloads.</st> <st c="39272">If this problem spreads
    to more than one Pod, then the problem compounds.</st> <st c="39346">This degrades
    the platform service, strains underlying hardware, and impairs troubleshooting.</st>
    <st c="39440">Therefore, the platform may want to limit or prevent such assignments.</st>
    <st c="39511">This can be done with the enforcement of quota or</st> <st c="39561">admission
    controllers.</st>
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: <st c="39583">We’ll cover quota and admission controllers later in this chapter.</st>
    <st c="39651">However, if Pod priority is something you’d like to use in a platform,
    here are the general steps necessary to</st> <st c="39762">enable it:</st>
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: <st c="39772">First, create a</st> <st c="39789">priority class.</st> <st c="39805">This
    kind is not scoped to namespaces but is more generally available cluster-wide.</st>
    <st c="39889">Create the class by saving the following content to a YAML file</st>
    <st c="39953">called</st> `<st c="39960">priority.yaml</st>`<st c="39973">:</st>
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="40196">Next, apply the</st> <st c="40213">priority class:</st>
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <st c="40324">Now, when we create a Pod, we can select that priority.</st> <st
    c="40381">Save the following</st> <st c="40400">as</st> `<st c="40403">pod.yaml</st>`<st
    c="40411">:</st>
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <st c="40770">After saving the</st> <st c="40788">Pod, create it with</st> `<st
    c="40808">kubectl create</st>`<st c="40822">:</st>
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <st c="40871">There are many other tuning options within Kubernetes to ensure
    that the scheduler makes the decisions you’d prefer.</st> <st c="40989">It is
    also possible to run an additional scheduler profile or to replace the default
    scheduler entirely with a customer profile that abides by</st> <st c="41132">different
    rules.</st>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41148">This is a pretty advanced operation, as it requires a deep understanding
    of how the scheduler works and how you need to change it to optimize the platform.</st>
    <st c="41305">However, if you do decide that this is necessary, we’d recommend
    starting with an additional profile before replacing</st> <st c="41423">the default.</st>
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41435">Important note</st>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41450">For OpenShift users, while the end result is the same, the process
    of implementing an exclusive CPU in OpenShift is slightly different and leverages
    machine sets.</st> <st c="41614">Check the latest OpenShift Container Platform
    docs for up-to-date instructions on this topic for</st> <st c="41711">that product.</st>
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41724">Rate limiting and network health</st>
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="41757">Rate limiting</st> <st c="41771">is the capping of network</st>
    <st c="41797">traffic or HTTP requests that a service will respond to from a requestor.</st>
    <st c="41872">Each response has a computational cost, so rate limiting acts as
    a protective measure against endpoints being exploited, either intentionally or
    through</st> <st c="42025">an error.</st>
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: <st c="42034">A common takedown of a system is</st> <st c="42068">a</st> **<st
    c="42070">Distributed Denial-of-Service</st>** <st c="42099">(</st>**<st c="42101">DDoS</st>**<st
    c="42105">) attack.</st> <st c="42116">While such an attack can be initiated by
    a bad actor, it can also be carried out by accident due to human error or a buggy
    piece of software.</st> <st c="42258">DDoS is the most classic example of a noisy
    neighbor.</st> <st c="42312">Computationally expensive, it can be executed either
    via sheer number of requests floodi</st><st c="42400">ng the networking layer,
    spending compute, or through requests that would result in data returns that are
    astronomically large or computationally expensive</st> <st c="42557">to get.</st>
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: <st c="42564">Rate limits can be implemented to prevent a large number of back-to-back
    calls from creating a noisy neighbor scenario.</st> <st c="42685">This can be
    handled in the cluster ingress, such as nginx.</st> <st c="42744">But there are
    also discreet Kubernetes features within the API server that can be leveraged</st>
    <st c="42836">as well.</st>
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: <st c="42844">On the API server itself, your team can set API priority and fairness
    rules to help prevent traffic flooding.</st> <st c="42955">This is especially
    important if the noisy neighbor situation is coming from an internal source, meaning
    that cluster ingress is not a factor.</st> <st c="43097">For example, if a backup
    job is misconfigured and it’s trying to query data from within a cluster to create
    backups, or push them too often, applying rate limits can help prevent this job
    from flooding the network layer.</st> <st c="43318">By default, basic priority
    and fairness rules are enabled, although it is possible to alter or disable the
    rules entirely if desired.</st> <st c="43452">However, that’s</st> <st c="43468">not
    recommended.</st>
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43484">Cluster scaling and other policies</st>
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="43519">What other policies prevent noisy neighbor situations?</st> <st
    c="43575">Autoscaling</st> <st c="43586">is the most obvious to the authors, although
    there are surely many more.</st> <st c="43660">All of the tuning and planning
    for how to pack workloads onto the platform only goes so far, without the cluster
    ultimately needing to grow (or shrink) in size.</st> <st c="43821">The most classic
    of all noisy neighbor scenarios is caused simply by a platform too small to meet
    the demand of</st> <st c="43933">its users.</st>
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43943">Where the resource constraints are in the platform will determine
    how the cluster should scale.</st> <st c="44040">If additional resources are needed
    for non-system components that run on worker nodes, then adding another node to
    the cluster will do the trick.</st> <st c="44186">However, if, despite previous
    efforts, etcd is filling up or the API server encounters constraints, a larger
    control plane</st> <st c="44309">is necessary.</st>
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44322">Observability data is the</st> <st c="44349">best measure for
    when and how to scale a cluster.</st> <st c="44399">This data can be collected
    on compute resource utilization by workloads and workload performance.</st> <st
    c="44497">As utilization increases, if thresholds for remaining resources are
    met or exceeded, a cluster scaling event can be triggered.</st> <st c="44624">Your
    observability can also be used even more creatively.</st> <st c="44682">A common
    technical interview question is a troubleshooting problem.</st> <st c="44750">The
    solution is always that a cron job uses too many resources and causes system crashes.</st>
    <st c="44840">With observability in place, you don’t need a human to discover
    that; you can use data.</st> <st c="44928">Significant spikes in resource utilization,
    either on the Pod or node level, can be captured and alerted on.</st> <st c="45037">But
    if you needed to respond to an alert, then this is also an opportunity</st> <st
    c="45112">for automation.</st>
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45127">And finally, if all else fails, you can use an event-driven system
    to react to the data collected by the observability stack to restart the faulty
    Pod.</st> <st c="45280">This works and should keep the mission-critical components
    going, but it doesn’t replace a human permanently fixing whatever caused the resource
    utilization to</st> <st c="45440">begin with.</st>
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45451">In short, maintaining cluster health and appropriate user and
    workload isolation is key to ensuring that users of a platform can focus on what
    matters most to them, helping us to lay the foundation for the next aspect of
    a successful platform –</st> <st c="45697">self-service.</st>
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45710">Enabling self-service developer portals</st>
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="45750">We’ve already stated that a</st> <st c="45779">platform is not
    a platform if self-service isn’t a core tenant of its design.</st> <st c="45857">Now,
    it’s time to understand what that means and how it pertains to the promised reduction
    of cognitive load.</st> <st c="45967">The platform team can’t be on hand to approve
    everything all the time.</st> <st c="46038">As such, it is imperative to put some
    control into the hands of end users, without failing to save them from an increase
    in cognitive load.</st> <st c="46178">This dichotomy requires striking a careful
    balance, which must be discussed and negotiated between the stakeholders to be
    successful.</st> <st c="46312">A platform team trying to control everything too
    tightly prevents the platform from scaling with the users, as it’ll always be
    limited to the size and location of the team.</st> <st c="46485">This means it’s
    time to think about how you help your users help themselves.</st> <st c="46562">What
    should a developer or team be able to do without higher levels of approval?</st>
    <st c="46643">What should be restricted?</st> <st c="46670">How do you enable
    sensible self-service, and how do you enforce reasonable restrictions?</st> <st
    c="46759">We’ve discussed the importance of treating your platform like a product,
    but functionally, the product type is a service.</st> <st c="46881">Any product
    sold “as a service” comes not just with a guarantee of features but also a guarantee
    of engagement and experience from the company selling</st> <st c="47032">the</st>
    **<st c="47036">Software as a Service</st>** <st c="47057">(</st>**<st c="47059">SaaS</st>**<st
    c="47063">) or</st> **<st c="47069">Platform as a Service</st>** <st c="47090">(</st>**<st
    c="47092">PaaS</st>**<st c="47096">).</st> <st c="47100">Even if you’re</st> <st
    c="47114">not selling your PaaS, you should adopt the mindset of service to ensure
    that users are at the center of your</st> <st c="47225">usability considerations.</st>
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: <st c="47250">Simply put, self-service</st> <st c="47276">means that a user
    can accomplish a reasonable action with reasonable ease, without negatively impacting
    unrelated users or teams.</st> <st c="47406">Understanding self-service as it
    pertains to your platform requires understanding the needs of your users.</st>
    <st c="47513">It’s important to meet your users where they are.</st> <st c="47563">If
    your users are of the kind that spend their whole day on a command</st> <st c="47632">line,
    a</st> **<st c="47641">command-line interface</st>** <st c="47663">(</st>**<st
    c="47665">CLI</st>**<st c="47668">) may be the tool they need most to get the</st>
    <st c="47713">job done.</st>
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: <st c="47722">However, if your IDP is being used for docs as code instead, in
    addition to code as code, it’s probable that the team leveraging it may benefit
    from a UI instead of</st> <st c="47888">a CLI.</st>
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: <st c="47894">How does the end user want to accomplish their goals?</st> <st
    c="47949">How does the end user want to receive feedback from platform jobs?</st>
    <st c="48016">When we approach self-service, these are the questions we need to
    ask.</st> <st c="48087">Generally speaking, the platform team should have parameters
    that the developers can operate within.</st> <st c="48188">For example, you can
    guarantee that certain workloads only land in certain locations, and you can tie
    resource (memory and CPU) limits to namespaces within your</st> <st c="48349">Kubernetes
    cluster.</st>
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48368">Tip</st>
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48372">Once you begin down this path to fine-tune how workloads land
    and consume resources, it starts influencing cluster capacity artificially.</st>
    <st c="48511">It’s important to only implement this strategy when it becomes truly
    necessary, or after creating a comprehensive cluster scaling and</st> <st c="48645">capacity
    plan.</st>
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48659">Enforcing quota</st>
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="48675">A user or team</st> <st c="48691">should be able to land their
    application within the application landing zone.</st> <st c="48769">However, they
    should not be able to do this without reasonable restrictions.</st> <st c="48846">These
    restrictions, such as resource consumption, can be limited to a per-namespace
    basis.</st> <st c="48937">This is done by specifying the kind ResourceQuota.</st>
    <st c="48988">You’ll make a YAML file and apply it to the namespace.</st> <st
    c="49043">Continue reading to see what it will</st> <st c="49080">look like.</st>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: <st c="49090">First, create a YAML file; let’s call</st> <st c="49129">it</st>
    `<st c="49132">your-dev-quota.yaml</st>`<st c="49151">:</st>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <st c="49385">Save the file, and now apply the YAML to the namespace.</st> <st
    c="49442">Your command will look something</st> <st c="49475">like this:</st>
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <st c="49553">Now, your developer can schedule any Pods within their namespaces
    as they need to, but the workloads have to stay within the quota boundaries provided
    to them.</st> <st c="49714">The creation of a quota for namespaces helps to enable
    multi-tenancy within a platform.</st> <st c="49802">Divvying up resources to users
    in a way that utilizes cluster capacity without over-taxing it allows users to
    operate independently, but within</st> <st c="49946">reasonable boundaries.</st>
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: <st c="49968">Quotas can also be managed with GitOps, thereby streamlining requests
    to increase quota or alter quotas from users.</st> <st c="50085">If the process
    for a user to adjust their quota is raising a</st> **<st c="50146">pull request</st>**
    <st c="50158">(</st>**<st c="50160">PR</st>**<st c="50162">) and then</st> <st
    c="50173">waiting for it to be</st> <st c="50194">approved, this makes it much
    easier for them to interact with a platform.</st> <st c="50269">Ease of use will
    be a large factor in the platform’s success within</st> <st c="50337">an organization.</st>
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: <st c="50353">Simple repeatable workflows</st>
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="50381">We talked about the</st> <st c="50402">importance of simple workflows
    for reducing cognitive load, and truly, this is a topic we could have stuck anywhere
    in this chapter.</st> <st c="50535">However, this aligns most with self-service,
    as it is a core feature.</st> <st c="50605">For a platform to deliver on the promise
    of self-service, it must be easy to use, and the uses must be easy</st> <st c="50713">to
    remember.</st>
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: <st c="50725">We refer again to our golden path.</st> <st c="50761">A developer
    building an app pushes a commit.</st> <st c="50806">The change makes its way through
    the CI/CD systems until, ultimately, the app install or upgrade lands in the application
    landing zone.</st> <st c="50942">The journey for that PR must be easy to understand,
    intuitive, and predictable for the development team.</st> <st c="51047">If the
    team needs to make changes to the CI jobs, or the CD logic specific to their application,
    then they should expect to have easy access to the governing systems to do</st>
    <st c="51219">just that.</st>
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: <st c="51229">Let’s bring back our teams for Financial One ACME.</st> <st c="51281">We
    can expand this example one step further and imagine again that the company includes
    multiple personas or user types.</st> <st c="51402">If we consider a development
    team and a corresponding docs team, what would each team need from the</st> <st
    c="51502">CI system?</st>
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: <st c="51512">It’s safe to say both teams need the ability to land their jobs
    within the system, to understand whether jobs are successful or failed, and to
    know whether the overall CI pipeline succeeded or failed.</st> <st c="51714">However,
    they may have different needs for interacting with the CI system.</st> <st c="51789">A
    developer or a DevOps engineer may prefer to use a CLI, whereas a docs team or
    a non-technical team may prefer</st> <st c="51901">a</st> **<st c="51904">graphical
    user interface</st>** <st c="51928">(</st>**<st c="51930">GUI</st>**<st c="51933">)
    to leverage</st> <st c="51948">a system.</st>
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: <st c="51957">The open source CI/CD projects Tekton and Argo CD both ship with
    a GUI.</st> <st c="52030">Both systems also can leverage CLI tools designed to
    interface with the project.</st> <st c="52111">For users of the systems, as long
    as they’ve been granted correct access, they can choose their own adventure for
    the actual interactions with these systems and can determine which is easier,
    keeping a CLI up to date locally or using a GUI occasionally.</st> <st c="52365">By
    being flexible, these tools and your IDP, should you adopt them, enable users
    to self-service based on</st> <st c="52471">their ease.</st>
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: <st c="52482">However, with something such as</st> <st c="52514">CI pipelines,
    which may take significant time to complete, other options such as API calls or
    Webhook integrations into common tools such as Slack may more easily meet the
    users where they are.</st> <st c="52709">Just as with inputs, the platform should
    meet users where they are for outputs, as the fewer times your users have to context-shift,
    the lower their cognitive load and the easier self-service goals</st> <st c="52907">are
    achieved.</st>
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: <st c="52920">Important note</st>
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: <st c="52935">A CI pipeline</st> <st c="52949">is typically a series of jobs;
    some run synchronously, and some run asynchronously to build and validate an application
    based on recent changes.</st> <st c="53095">This could be one PR at a time (CI
    at its core), but it could also be less frequent, such</st> <st c="53185">as daily.</st>
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: <st c="53194">Even highly technical users love a good GUI, and if they’re already
    interfacing with something such as GitHub or GitLab for a PR review, they may
    not feel like changing paradigms again.</st> <st c="53381">So, while the average
    user may never need to see the internals of the Kubernetes clusters they’re interacting
    with, we did say that the platform should drink its own champagne.</st> <st c="53558">This
    includes best practices such as meeting users where they are.</st> <st c="53625">Some
    Kubernetes solutions such as OpenShift ship with a GUI layer included.</st> <st
    c="53701">For the ones that do not, Lens (</st>[<st c="53733">https://k8slens.dev/</st>](https://k8slens.dev/)<st
    c="53754">) provides</st> <st c="53765">an</st> <st c="53769">easy-to-use GUI.</st>
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6: The Lens GUI connected to a local kind cluster representing an
    IDP](img/B31164_06_06.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
- en: '<st c="56728">Figure 6.6: The Lens GUI connected to a local kind cluster representing
    an IDP</st>'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: <st c="56806">To summarize, developer self-service is about meeting your users
    where they are and giving them the tools to be successful with a platform.</st>
    <st c="56947">Tshis means understanding their needs but also giving them the capabilities
    to integrate the platform to their way of working, not making their way of working
    fit</st> <st c="57110">the platform.</st>
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: <st c="57123">Landing, expanding, and integrating your IDP</st>
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="57168">If you followed our recommendations in</st> [*<st c="57208">Chapter
    3</st>*](B31164_03.xhtml#_idTextAnchor133)<st c="57217">, you’ve interviewed the
    users, you’ve mapped the use cases, and you’ve designed your platform.</st> <st
    c="57313">Now comes the fun part – turning it into</st> <st c="57354">something
    real.</st>
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: <st c="57369">Let’s look at the most basic IDP.</st> <st c="57404">What does
    it do?</st> <st c="57421">Most importantly, users can authenticate to it with
    appropriate access and permissions.</st> <st c="57509">It has a CI system, a CD
    system, at least some basic security tooling such as scanning, and these days,
    something to generate an SBOM.</st> <st c="57644">What about the production location
    for the software that the developers are writing?</st> <st c="57729">Where is
    that?</st> <st c="57744">How does the promotion process look?</st> <st c="57781">Let’s
    look again at our IDP golden path from earlier in</st> *<st c="57837">Figure 6</st>**<st
    c="57845">.3</st>*<st c="57847">.</st>
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: <st c="57848">There are a lot of pieces in this drawing, and software development
    should be iterative, which means we’re not going to be landing everything seen
    here all at once.</st> <st c="58014">So, let’s look at landing an IDP.</st> <st
    c="58048">What does the thinnest viable platform</st> <st c="58087">look like?</st>
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: <st c="58097">It’s probably something</st> <st c="58122">like this:</st>
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: <st c="58132">Authentication</st> <st c="58148">and RBAC</st>
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="58156">Security checks</st>
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="58172">CI/CD</st>
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="58178">An application</st> <st c="58194">landing zone</st>
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="58206">Technically, a CD system isn’t necessary, as long as there’s some
    promotion process for application features and enhancements to reach production.</st>
    <st c="58354">With such a scaled-down approach, or thinnest viable platform, it’s
    fairly easy to see how to land an IDP within an organization.</st> <st c="58484">The
    appeal of a new and shiny product may even drive users to play with it and help
    drive initial adoption.</st> <st c="58592">However, keeping those users engaged
    and attracting the more reticent will require expanding upon the initial offering
    and ensuring that what users use is easy to understand</st> <st c="58766">and
    performant.</st>
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: <st c="58781">Expanding your IDP, though – how does that look?</st> <st c="58831">Expansion
    may look something like capacity planning, but how will you scale and size your
    resources as the adoption of the platform grows?</st> <st c="58970">In Kubernetes,
    this will mean figuring out cluster sizing and/or</st> <st c="59035">cluster count.</st>
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: <st c="59049">The expansion will also include features and enhancements, as
    well as planning not just for the development and rollout but also the operations
    of those enhancements.</st> <st c="59217">What are the impacts on the platform
    of adding another feature or integration?</st> <st c="59296">How do you measure
    the success of an enhancement, and how do you use data to determine its return</st>
    <st c="59394">on investments?</st>
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: <st c="59409">Enforcement of platform-specific standards</st>
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="59452">If we refer back to the</st> <st c="59477">beginning of the chapter,
    we mentioned that it’s important that platform-specific standards are easy to
    consume for end users, helping to guarantee a low cognitive load, and that this
    must include the enforcement of</st> <st c="59693">those standards.</st>
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: <st c="59709">There’s no one set way to do this, since norms can differ from
    platform to platform.</st> <st c="59795">However, we have found that there are
    a few things that work well in terms of both process and technology for you to
    adapt to</st> <st c="59921">your organization.</st>
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: <st c="59939">Maturity models</st>
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="59955">Maturity models fall</st> <st c="59976">slightly more into the
    sociotechnical aspect of cognitive load reduction.</st> <st c="60051">Defining
    maturity models for software applications as they onboard to a platform can help
    developers know they’re building out their application in the right way.</st>
    <st c="60214">This also helps to ensure that the reduction of cognitive load doesn’t
    result in a worse experience for end users, due to something being overlooked
    or forgotten.</st> <st c="60377">Essentially, it ensures that the interests of
    both parties are aligned from a</st> <st c="60455">platform perspective.</st>
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: <st c="60476">An example of a standard for maturity would be that a new application
    would only onboard to a platform after it has been configured for high availability
    and disaster recovery, if it has unit tests, or if the team has written and committed
    their Prometheus queries and Grafana dashboards for application observability.</st>
    <st c="60796">These types of models can be enforced with CI jobs that check for
    the presence of whatever is deemed appropriate by the platform, or they could
    simply be published as guidelines for a team</st> <st c="60985">to follow.</st>
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: <st c="60995">Expanding a platform with common platform integrations</st>
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="61050">Taking a platform beyond the thinnest viable platform and into
    a robust system will require leveraging new integrations and better harnessing
    the initial feature sets.</st> <st c="61219">Some common and useful integrations
    are outlined in</st> <st c="61271">this section.</st>
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: <st c="61284">Static analysis</st>
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="61300">How does a user know whether they’re matching with expected maturity
    models and</st> <st c="61381">platform norms?</st> <st c="61397">How do they receive
    feedback if they are not?</st> <st c="61443">One method for establishing this
    enforcement and feedback loop with users is via static analysis.</st> <st c="61541">When
    the development team submits a PR, then CI jobs kick off.</st> <st c="61604">It
    is during the first CI jobs that a static analysis tool is best positioned; this
    way, if the PR fails, the check compute is not spent needlessly on running tests
    or generating SBOMs, and the feedback loop to the end user raises the error much
    faster.</st> <st c="61858">Reducing time to feedback helps to keep developer velocity
    high and cognitive load low, since developers don’t need to remember to check
    back with the platform after a</st> <st c="62026">significant delay.</st>
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: <st c="62044">Example</st> <st c="62052">static analysis tools that can be leveraged
    at PR time are security audits that compare image versions to known</st> **<st
    c="62165">Critical Vulnerability Exploits</st>** <st c="62196">(</st>**<st c="62198">CVEs</st>**<st
    c="62202">) to</st> <st c="62208">ensure that vulnerable code is not being pushed.</st>
    <st c="62257">At the time of writing,</st> **<st c="62281">Snyk</st>** <st c="62285">is
    a</st> <st c="62291">popular choice for this, as it is open source and has free</st>
    <st c="62350">options.</st> **<st c="62359">CodeQL</st>** <st c="62365">is another
    popular choice and is also free for open source projects, so it’s very easy to
    find examples of it in use.</st> <st c="62484">Both of these tools are popular
    because they integrate well with</st> <st c="62549">GitHub workflows.</st>
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: <st c="62566">For the enforcement of norms, however, there are also static</st>
    <st c="62627">analysis tools that verify whether an application conforms to cloud-native
    best practices.</st> <st c="62719">From the</st> **<st c="62728">StackRox</st>**
    <st c="62736">community,</st> **<st c="62748">KubeLinter</st>** <st c="62758">is
    an</st> <st c="62764">excellent example of this.</st> <st c="62792">It ships with
    a variety of checks but can be configured to skip checks that are not desired
    for a platform, or to accept</st> <st c="62913">custom checks.</st>
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: <st c="62927">Both the aforementioned static analysis tools leverage GitHub
    workflows, which are declarative YAML to define what actions should happen within
    a repository once a PR is raised.</st> <st c="63106">For example, to run KubeLinter
    against the main branch of a repository with GitHub workflows, a</st> `<st c="63202">.github/workflows</st>`
    <st c="63219">directory would be added to the GitHub repository, and then a YAML
    file would be committed to it.</st> <st c="63318">That YAML would look something
    like this</st> `<st c="63359">kubelint.yaml</st>` <st c="63372">file:</st>
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <st c="63834">Admission controllers and policy agents</st>
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="63874">Admission controllers</st> <st c="63896">are another feature of
    Kubernetes.</st> <st c="63932">They come in two flavors, validating and</st> <st
    c="63973">mutating Webhooks.</st> <st c="63992">Both reduce cognitive load and
    also enable self-service.</st> <st c="64049">However, they’re fairly advanced
    topics and may not be part of your platform MVP, or even in the top five integrations.</st>
    <st c="64169">As the platform itself evolves in maturity, these features can</st>
    <st c="64232">be adopted.</st>
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: <st c="64243">If a mutating Webhook allows a platform to enforce a norm such
    as an environment variable transparently to the user, this allows them to worry
    less about the platform itself and more about the application.</st> <st c="64450">Then,
    if the environment variable changes, the developer doesn’t need to do anything
    differently on their side.</st> <st c="64562">A validating Webhook checks that
    the object being applied matches the expected parameters.</st> <st c="64653">You
    can leverage both types against workloads, and generally, you should always use
    a validation Webhook if you’re using a mutating Webhook to ensure that nothing
    else has incorrectly modified the object after the Webhook</st> <st c="64875">has
    responded.</st>
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: <st c="64889">Admission controllers are</st> <st c="64916">powerful but somewhat
    complex.</st> <st c="64947">They require setting up a server to run the controller
    and the Webhooks and responses to be written.</st> <st c="65048">Due to their
    size and complexity, relative to other methods of enforcing platform norms, they’re
    not suitable for a new IDP, but for large organizations with many users, they
    can become a</st> <st c="65236">powerful tool.</st>
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: <st c="65250">Admission controllers can be bespoke, but open source</st> <st
    c="65304">policy agents such</st> <st c="65323">as</st> **<st c="65327">Open Policy
    Agent (OPA)</st>** <st c="65350">or</st> **<st c="65354">Kyverno</st>** <st c="65361">leverage</st>
    <st c="65371">the same features and can help simplify their usage.</st> <st c="65424">Leveraging
    policy-based norms can help platform performance and prevent collisions</st> <st
    c="65507">between workloads.</st>
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: <st c="65525">Observability</st>
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="65539">To be covered in greater depth in the next section, observability</st>
    <st c="65605">is something that should exist from day one in the IDP and can and
    will be expanded.</st> <st c="65691">Observability should be considered a living
    integration, meaning that it is always being grown and modified to match the life
    cycle of</st> <st c="65826">a platform.</st>
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: <st c="65837">Some common observability tools are</st> <st c="65874">Prometheus,
    Grafana, and Loki, and they can be used individually but are better configured
    in conjunction with</st> **<st c="65985">OpenTelemetry</st>** <st c="65998">(</st>**<st
    c="66000">Otel</st>**<st c="66004">) and the Otel protocol.</st> <st c="66030">When
    you combine these with Thanos for long-term storage, you can give yourself a little
    more data to analyze as well, which can be nice to understand the context and
    history of</st> <st c="66208">observability data.</st>
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: <st c="66227">Respectively, these tools specialize in metric queries against
    Kubernetes objects as well as analysis of those metrics, visualization of metrics,
    and log aggregation.</st> <st c="66395">Additionally, this toolset can be used
    by single tenants with multiple users, or as a multi-tenant tool.</st> <st c="66500">The
    user authentication and RBAC for the IDP can be leveraged for these, just as they
    could with the CI/CD solutions we</st> <st c="66620">discussed previously.</st>
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: <st c="66641">The MVP of a platform and its golden path should be the main focus
    of the initial observability implementation.</st> <st c="66754">Observability
    should be done in a way to measure user satisfaction, and</st> **<st c="66826">Service-Level
    Objectives</st>** <st c="66850">(</st>**<st c="66852">SLOs</st>**<st c="66856">)
    directly</st> <st c="66868">maps to a user’s success with the platform.</st> <st
    c="66912">Therefore, as a best practice, make sure that the core components of
    the golden path are available, have a set target for success and latency, and
    ensure that the platform team can leverage observability to make data-informed
    decisions, including tracking usage of certain features and the failure</st> <st
    c="67210">rates within.</st>
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: <st c="67223">As an example, let’s say that Financial One ACME initially shipped
    a new platform MVP, with Tekton included for CI and Argo CD for CD.</st> <st c="67359">But
    thanks to the observability stack, the platform team can see that only 1% of users
    leverage the Tekton integration.</st> <st c="67479">This is an indicator that
    the CI needs are being met elsewhere.</st> <st c="67543">Thanks to this data,
    the team can take the decision to deprecate the Tekton deployment and reclaim
    some cluster capacity, while letting users continue to work in their preferred
    way.</st> <st c="67726">Alternatively, they could work to understand why the feature
    of the platform isn’t being used and seek to help users adopt the new</st> <st
    c="67857">CI system.</st>
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: <st c="67867">Integrating your platform</st>
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="67893">Integration of the platform</st> <st c="67921">doesn’t just mean
    integrating components with each other; it also means integrating the IDP into
    a company’s way of working.</st> <st c="68047">This entails a service-first culture,
    user-centricity, feedback loops for operational excellence, and meeting users
    where</st> <st c="68169">they are.</st>
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: <st c="68178">Once again, we will go back to Financial One ACME.</st> <st c="68230">This
    company needs to balance both a new-age technology stack and a legacy stack.</st>
    <st c="68312">An opportunity exists here to meet these users where they are by
    integrating the existing workflows for authentication into the new platform.</st>
    <st c="68454">If they’re already using GitHub or GitLab, they’re likely using
    some kind of single sign-on, which should be compatible with any</st> <st c="68583">Kubernetes-based
    IDP.</st>
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: <st c="68604">Integration into a company’s way of working may mean certain options
    to solve some problems don’t meet the users’ needs at this time.</st> <st c="68739">For
    example, if the reason for low Tekton adoption in the Financial One ACME development
    team was because GitHub workflows with Argo CD are capable of handling all of
    their CI/CD needs, then that integration with Tekton may be an effort with a low
    return.</st> <st c="68995">Developers who are refactoring a monolith may find
    more benefit from being able to use a shared CI tool.</st> <st c="69100">This
    would help them to create a common set of tests, and checks between the old monolithic
    system and new system, ensuring that they’re maintaining parity during the transition.</st>
    <st c="69279">In the example of low Tekton adoption, an upfront analysis of the
    decision may prevent wasted time, instead that time may be better spent on the
    integration of a data transformation tool such as Apache Airflow or</st> <st c="69492">Argo
    Workflows.</st>
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: <st c="69507">Since successful IDP adoption is going to be data-driven, a key
    aspect of this will be</st> **<st c="69595">observability</st>**<st c="69608">.
    The</st> <st c="69613">observability of a platform will help to drive its value
    to consumers and the team that must</st> <st c="69707">maintain it.</st>
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: <st c="69719">Architectural considerations for observability in a platform</st>
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="69780">Self-service and cognitive load – we’ve already alluded to the
    importance of observability in these topics.</st> <st c="69889">Your platform
    cannot act in service to its users without observability prioritized.</st> <st
    c="69973">In other words, you should expect to watch and</st> <st c="70020">measure
    everything.</st>
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: <st c="70039">Observability</st> <st c="70054">comes in two flavors; the first
    is observability for the benefit of the platform team.</st> <st c="70141">This
    is the way the platform team will collect data and information to help build their
    reliability.</st> <st c="70242">Using the site reliability practices of SLOs,
    the platform team can measure customer satisfaction by setting SLOs for the platform
    and then creating observability in support</st> <st c="70416">of them.</st>
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: <st c="70424">The good news is that, in the Kubernetes world, this is easier
    because of objects and microservices.</st> <st c="70526">The bad news is that
    there are a lot more things to measure than ever before due to microservices,
    and it’s hard to know whether you’ve captured everything.</st> <st c="70683">Your
    observability should have a life cycle, like your software.</st> <st c="70748">Start
    with good, iterate to better, and realize that observability is a living thing
    that will likely never reach a</st> <st c="70864">completed state.</st>
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: <st c="70880">There’s a standard observability toolbox in Prometheus, Grafana,
    Loki, and other</st> **<st c="70962">Free Open Source Software</st>** <st c="70987">(</st>**<st
    c="70989">FOSS</st>**<st c="70993">) projects</st> <st c="71004">that help to
    observe and measure workloads and provide insights into their operations.</st>
    <st c="71092">Often, the consumers of observability data are</st> **<st c="71139">site
    reliability engineers</st>** <st c="71165">(</st>**<st c="71167">SREs</st>**<st
    c="71171">) or</st> <st c="71177">DevOps engineers, but any user who is concerned
    about the operational excellence of their application should be able to easily
    review and use</st> <st c="71319">this information.</st>
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: <st c="71336">Equally important observability tooling that is more applicable
    for troubleshooting a production issue of some kind includes networking tracing,
    liveness probes, and stack traces.</st> <st c="71517">A platform should supply
    the implementation and validation of this toolchain and make it available to users
    in a restricted fashion, ensuring security and compliance</st> <st c="71683">are
    upheld.</st>
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: <st c="71694">Naturally, the log and telemetry data retention policies introduce
    their own scaling concerns, and logging and backup systems can be the worst perpetrators
    of noisy neighbor behaviors.</st> <st c="71880">Thus, the care and operations
    of these systems fall to the platform team to ensure a smooth integration into
    the pre-production and production environments.</st> <st c="72037">Other best
    practices around observability, such as sanitizing logs and keeping platform and
    application logs quarantined from each other, are important, but we will cover
    these topics in more detail in</st> [*<st c="72239">Chapter 7</st>*](B31164_07.xhtml#_idTextAnchor381)
    <st c="72248">when building a</st> <st c="72265">secure platform.</st>
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: <st c="72281">Observability in a platform</st>
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="72309">Observability is, to put it simply, the way you</st> <st c="72358">measure
    your platform.</st> <st c="72381">In a service-based approach to a platform product,
    the SRE practice of an SLO or multiple SLOs is designed to uphold the golden path.</st>
    <st c="72515">If you think about your SDLC, that path should have been previously
    defined in the planning phase.</st> <st c="72614">An SLO that supports a user
    to ensure their success and happiness as they journey along a golden path represents
    a best practice for an</st> <st c="72750">observability strategy.</st>
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: <st c="72773">If we refer back to Financial One ACME, as well as the golden
    paths that we’ve defined for a successful IDP within this organization, we can
    see an observability strategy start to develop.</st> <st c="72963">The platform
    team can measure the Pod health for the most critical items in a workflow.</st>
    <st c="73051">If Argo CD is crash-looping or a component Pod is not ready, then
    you know that user expectations around CD are not</st> <st c="73167">being met.</st>
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: <st c="73177">If jobs are failing for security checks or SBOM generation, then
    the security and compliance systems need attention.</st> <st c="73295">This could
    block PRs from being merged and interrupt developer workflows as they try to determine
    why necessary checks aren’t succeeding.</st> <st c="73433">All along the golden
    path there is something we can measure that will help inform platform health and</st>
    <st c="73535">developer satisfaction.</st>
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: <st c="73558">Observability in a platform should be in support of SLOs.</st>
    <st c="73617">These measure customer satisfaction through the collection and analysis
    of data.</st> <st c="73698">When we discussed data-driven decision-making for
    platform evolution in</st> [*<st c="73770">Chapter 1</st>*](B31164_01.xhtml#_idTextAnchor014)<st
    c="73779">, we espoused the value of it as a way to maintain the product mindset
    for a platform.</st> <st c="73866">SLOs are a concrete, data-driven way to create
    a feedback loop that your team can</st> <st c="73948">iterate against.</st>
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: <st c="73964">If your organization cannot meet an SLO, then users are probably
    not happy.</st> <st c="74041">However, even if you’re meeting your SLO target,
    SLOs can still be improved.</st> <st c="74118">It’s reasonable to start with an
    SLO such as “</st>*<st c="74164">jobs will succeed 80% of the time</st>*<st c="74198">”
    and increase that number to 99.99%.</st> <st c="74237">This way, you can still
    evolve a platform without increasing the cognitive load</st> <st c="74317">on
    users.</st>
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: <st c="74326">Important note</st>
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: <st c="74341">100% is a bad SLO target because it’s an impossible metric; however,
    the concepts of three, four, or even five nines of availability can</st> <st c="74479">be
    applied.</st>
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="74490">For further reading on SLOs, we recommend</st> *<st c="74533">Site
    Reliability Engineering: How Google Runs</st>* *<st c="74579">Production Systems</st>*<st
    c="74597">.</st>'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: <st c="74598">Centralized observability – when and why you need it</st>
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="74651">What happens when a platform</st> <st c="74681">hits a critical
    failure?</st> <st c="74706">How do developers, DevOps teams, SREs, or whoever
    is responsible for responding to production</st> <st c="74799">outages figure
    out what’s happening?</st> <st c="74837">Immediately logging into the production
    system and debugging and troubleshooting is one option, but it’s not the most
    secure one.</st> <st c="74967">Ultimately, it may become necessary, but it should
    be considered a last resort, not the</st> <st c="75055">first step.</st>
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: <st c="75066">How do you know that your observability stack isn’t the man down?</st>
    <st c="75133">In a single-cluster IDP, these questions are easy to answer.</st>
    <st c="75194">But in a multi-cluster or multi-cloud IDP, those questions become
    more complicated.</st> <st c="75278">This is where a centralized observability
    stack becomes critical for the success of any application, including the IDP itself.</st>
    <st c="75405">A centralized observability stack allows for environment-agnostic
    observability.</st> <st c="75486">The centralized system can reach out to the
    IDP clusters and validate their liveness with probes, or it can simply alert on
    the absence of data.</st> <st c="75631">If the IDP clusters stop calling home
    or shipping logs, that’s a good indicator that there’s</st> <st c="75724">a problem.</st>
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: <st c="75734">Important metrics</st>
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="75752">Since a platform can be prescriptive about how and where workloads
    run, it can also be prescriptive about how workloads are measured.</st> <st c="75887">For
    example, the DORA DevOps metrics can be collected and used to give indicators
    of quality of service or service health.</st> <st c="76010">A platform can support
    this by making services available to expose the necessary data points, or it can
    enforce the calculation of the metrics by forcibly collecting the necessary metrics,
    since it’s the controlling entity of</st> <st c="76236">the environment.</st>
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: <st c="76252">While SLOs and service-level indicators cannot be fully standardized
    across multiple services, a platform should seek to support the collection, aggregation,
    and retention policies of any critical metrics for an application.</st> <st c="76478">Those
    metrics must then be made available easily and with proper RBAC.</st> <st c="76549">This
    allows users to self-service defining metrics and troubleshooting issues with</st>
    <st c="76632">the software.</st>
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: <st c="76645">Observability in service for developers</st>
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="76685">Observability for the consumers</st> <st c="76718">of a platform
    looks a little different from what the platform team might see and do.</st> <st
    c="76803">While the toolbox is roughly the same, the data needed is a little different.</st>
    <st c="76881">In addition to their application performance and uptime, developers
    on the platform will care more about failed CI jobs, DORA DevOps metrics, application
    logs, and exceptions.</st> <st c="77057">They need the ability to see all of their
    observability, with no platform-level observability or observability from other
    tenants.</st> <st c="77188">This not only helps maintain a security and compliance
    posture but also reduces cognitive load, since all the data from all the sources
    can make it hard for developers to understand what data they need and how to</st>
    <st c="77401">interpret it.</st>
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: <st c="77414">There are several ways to approach achieving this clean signal
    to developers.</st> <st c="77493">The observability offering Thanos is specifically
    designed to be a long-term storage solution for Prometheus metrics, natively supporting
    multi-tenancy.</st> <st c="77646">The query language is still Prometheus’ PROMQL,
    which creates a familiar way of interacting with observability data in Thamos.</st>
    <st c="77773">It does, however, expect a somewhat significant amount of dedicated
    cloud storage to support</st> <st c="77866">its operations.</st>
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: <st c="77881">When we get into the implications of storing and serving observability
    data in a platform, the issue of scaling the platform takes a new shape.</st>
    <st c="78026">We’ll dive into cost management more concretely in later chapters.</st>
    <st c="78093">However, there are a few high-level considerations we can take a
    look</st> <st c="78163">at now.</st>
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: <st c="78170">As setting up Thanos requires creating object storage and allowing
    access between it and a platform, it adds another layer of complexity to the platform.</st>
    <st c="78325">The storage must be set up, and the networking paths that connect
    it to the rest of the platform must also be created and maintained.</st> <st c="78459">This
    pays dividends for large-scale operations that need to keep observability data
    around for a long time, but it’s not ideal for smaller IDPs or early versions
    of the platform.</st> <st c="78638">Conversely, Prometheus can be used the same
    way, but it can also keep the data in a persistent volume via local mode or not
    persist the data at all, meaning that if the Prometheus Pod were to restart, the
    metrics it had known about would</st> <st c="78876">be lost.</st>
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: <st c="78884">It’s possible for teams within an IDP to have different needs
    for metric longevity; as such, there is a fairly common pattern of multiple instances
    of Prometheus</st> <st c="79047">using federation.</st>
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: <st c="79064">Federation is essentially one Prometheus instance that scrapes
    the data it needs from another.</st> <st c="79160">These instances can be on the
    same cluster or across different clusters.</st> <st c="79233">In the use case
    of a multi-tenant IDP, Prometheus federation is a logical choice.</st> <st c="79315">The
    platform owns the application landing zone and, therefore, will hold the source
    of truth for resource utilization within its observability.</st> <st c="79459">However,
    it’s not wise or secure to open that up to all users if the development team also
    uses Prometheus to measure their application health through things such as canary
    routes and synthetic probes.</st> <st c="79661">The developers may want to tie
    that data together with the data that the platform owns to get a full picture
    of their application performance.</st> <st c="79804">By giving the developer Prometheus
    instance federated access to the data it needs, developers can get that information
    without exceeding their</st> <st c="79946">RBAC.</st> <st c="79953">Additionally,
    this model keeps cognitive load low by creating a useful</st> **<st c="80024">signal-to-noise</st>**
    <st c="80039">ratio.</st> <st c="80047">A signal-to-noise ratio</st> <st c="80071">is
    the total number of signals that a developer receives and the number of signals
    that are actionable versus noise.</st> <st c="80188">The less noise a developer
    is exposed to, the more effectively they can parse the data they need</st> <st
    c="80285">to review.</st>
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: <st c="80295">The actual implementation for this isn’t very difficult; it’s
    a few new lines in the Prometheus YAML file.</st> <st c="80403">The important
    takeaway is that the applications can get information from the platform and any
    necessary shared services, but not from each other.</st> <st c="80549">Since application-level
    observability data is more likely to have personally identifying information or
    other sensitive data in it, this helps the platform team guarantee that security
    and compliance best practices or requirements</st> <st c="80780">are followed.</st>
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: <st c="80793">The recommended example for federation in this case would be cross-service
    federation.</st> <st c="80881">Here, the most common model is to have a central
    Prometheus server that does federation and is scraped by other Prometheus servers
    that may not</st> <st c="81025">support federation.</st>
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7: A Prometheus federation model](img/B31164_06_07.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
- en: '<st c="81381">Figure 6.7: A Prometheus federation model</st>'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: <st c="81422">The YAML for the</st> <st c="81440">platform Prometheus instance
    would look a little something</st> <st c="81499">like this:</st>
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: <st c="81987">In the</st> *<st c="81995">Figure 6</st>**<st c="82003">.7</st>*
    <st c="82005">example, there is a shared service, and it may be difficult to understand
    what kind of service would be important to multiple application observability
    stacks.</st> <st c="82166">One use case would be for DevOps DORA metrics.</st>
    <st c="82213">In DORA there are four key areas that a team would</st> <st c="82263">measure
    if they’re looking to implement a DORA</st> <st c="82311">maturity model:</st>
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="82326">Mean time to resolve</st>**<st c="82347">: How long it takes
    to recover from</st> <st c="82384">a failure</st>'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="82393">Change failure rate</st>**<st c="82413">: How often deployments
    lead</st> <st c="82443">to failures</st>'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="82454">Lead time to change</st>**<st c="82474">: How long it takes
    for a change to</st> <st c="82511">reach production</st>'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="82527">Deployment frequency</st>**<st c="82548">: How often changes</st>
    <st c="82569">are deployed</st>'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="82581">To get this data, the CI/CD systems would need to be queried,
    or they can be configured to send data via a Webhook, and using Prometheus to
    obtain and normalize said data, would allow all compared data to exist in the
    same format, which makes calculation easier.</st> <st c="82845">The implementation
    details for this would involve a Prometheus exporter.</st> <st c="82918">A Prometheus
    exporter is a service that queries data from systems that may not be immediately
    Prometheus-friendly but then transforms it so that it is in a compatible data
    format.</st> <st c="83098">For example, to calculate the lead time to change,
    a Prometheus exporter would get data from the CI system, normalize it, and make
    it available via either a query to the Prometheus API</st> <st c="83283">or federation.</st>
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: <st c="83297">Whatever observability implementation paths you ultimately use,
    the data and its criticality should be made available to everyone who can leverage
    it, for the success of the platform and the products it supports.</st> <st c="83511">Do
    this with care and also with an understanding that data is a key asset</st> <st
    c="83585">for users.</st>
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: <st c="83595">Opening your platform for community and collaboration</st>
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="83649">We often use the</st> <st c="83666">term</st> *<st c="83672">open
    source</st>*<st c="83683">, but open source doesn’t always mean free, and vice
    versa.</st> <st c="83743">However, when we discuss FOSS, the most important aspect
    of the software is not the technology but the community behind it.</st> <st c="83867">Open
    source communities foster collaboration and help to organically grow software
    in ways that revolutionize</st> <st c="83977">the industry.</st>
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: <st c="83990">When we previously discussed learning about your users, it was
    largely in the context of getting things off the ground, but you need to maintain
    that same user-centricity in order to keep the product running and relevant.</st>
    <st c="84213">The best way to harness the power of your users is to bring them
    to the table with the team, creating a community as seen in FOSS projects that
    invites collaboration, contribution, and communication.</st> <st c="84413">By
    doing so, you can have a data-driven, user-led platform that evolves with the
    organization it is intended to serve.</st> <st c="84532">Oftentimes, a project
    lifts off, but the roadmap beyond that is fuzzy.</st> <st c="84603">As the adrenaline
    of the initial push to an IDP fades, the risk of losing momentum and becoming
    complacent develops.</st> <st c="84720">The community aspect should then act as
    the fuel to keep the</st> <st c="84781">vehicle moving.</st>
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: <st c="84796">At this point, you’re likely asking, how do we go about creating
    this community?</st> <st c="84878">How do we bring people to the table without
    undoing the reduction of cognitive load we’ve been striving for with</st> <st
    c="84991">our platform?</st>
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: <st c="85004">There’s no one magic button solution for this but, rather, several
    things that can be done in concert, such as adding a contributor guide to a repository
    that sets expectations around what kind of contributions are desired and how contributions
    will</st> <st c="85255">be reviewed.</st>
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: <st c="85267">Another aspect is that some of the tools you might include in
    your platform can help to entice collaboration.</st> <st c="85378">Policy engines,
    for example, entice collaboration because users can propose new policies or adjustments
    to their policies.</st> <st c="85501">By having a repository for policies that
    is open to end users, you can invite PRs against the policies for users to propose
    new permissions or adjustments to existing permissions.</st> <st c="85681">As
    we discussed with self-service, this leverages a known useful workflow of Git
    PRs and</st> <st c="85770">peer review.</st>
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: <st c="85782">Similarly, the use of quotas for an environment is a configuration
    that can be managed with GitOps; a PR for more quotas and some GitHub workflows
    can be leveraged to help developers request quotas.</st> <st c="85982">In both
    examples, the leveraging of Git repos and PRs allows users to interact with a
    platform in a more intuitive way that fits with their workflows.</st> <st c="86133">Once
    again, meeting your “customers” where they are helps to reduce their cognitive
    load, while enticing collaboration is necessary to ensure that the platform continues
    to meet</st> <st c="86311">their needs.</st>
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: <st c="86323">A platform should drink</st> <st c="86348">its own champagne.</st>
    <st c="86367">If the product security team has demands on the application that
    a platform must support, such as the generations of SBOMs or automated penetration
    testing jobs, the platform itself should be evaluated against the same security
    standards.</st> <st c="86606">Doing this is not only an exercise in intellectual
    honesty, ensuring that the way security standards are enforced is reasonable and
    doesn’t interfere with serviceability and self-service, but also a pathway toward
    engagement from your internal community in the development and hardening of</st>
    <st c="86896">the platform.</st>
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: <st c="86909">A discerning reader may wonder, “</st>*<st c="86943">How do you
    reconcile the dichotomy between the reduction of cognitive load for users and
    their engagement in the</st>* *<st c="87057">platform experience?</st>*<st c="87077">”</st>
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: <st c="87079">This is an important question, as endless requests for feedback
    may result in silence, since the mental load of generating feedback may be high
    especially if users don’t feel that feedback will</st> <st c="87273">be actioned.</st>
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: <st c="87285">There is no single approach to gaining community engagement that
    is guaranteed to work, but when we look at some best practices from around the
    FOSS community, we can see there’s</st> <st c="87465">a trend.</st>
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: <st c="87473">Planning in the open</st>
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="87494">Regular planning meetings and community meetings that are attended
    by the platform team, as well as being open to anyone to attend, help to create
    and foster the open collaboration needed to grow a community culture around a
    platform.</st> <st c="87730">In a Kubernetes project, most of the project meetings
    are on a public calendar, and there are mailing lists that individuals can sign
    up for to keep abreast of the latest and greatest news coming from each project.</st>
    <st c="87945">Regular product updates and plans that are emailed out and transparent
    to a company will help to maintain interest and engagement, hopefully resulting
    in the proactive feedback necessary for the long-term success of</st> <st c="88161">the
    IDP.</st>
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: <st c="88169">Accepting contributions</st>
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="88193">Accepting contributions is probably one of the more logistically
    difficult sociotechnical aspects of landing and expanding an IDP.</st> <st c="88325">However,
    some open source IDP projects lend themselves very nicely to this paradigm.</st>
    <st c="88410">The recent open source darling Backstage provides, among many other
    features, a plugin-capable architecture.</st> <st c="88519">In other words, by
    laying down Backstage as the IDP framework when a team finds they’re missing functionality
    or would benefit from some additional quality-of-life features, they can leverage
    the plugin</st> <st c="88722">framework to propose the new feature via a PR to
    the internal</st> <st c="88784">IDP project.</st>
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: <st c="88796">While you don’t have to use this exact framework to achieve the
    same results, the pattern that Backstage exemplifies allows for easy contributions
    from users and a standardized way of proposing changes via hands on contribution,
    instead of just sending a request to the platform</st> <st c="89076">team’s backlog.</st>
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: <st c="89091">Summary</st>
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="89099">In this chapter, we looked at how to build for developers and
    the importance of cognitive load.</st> <st c="89196">Protecting users from undesired
    outcomes positively influences their cognitive load and gives them fewer concerns,
    and fewer things to debug if something goes wrong can help keep developers working
    efficiently.</st> <st c="89407">Additionally, the relationship between cognitive
    load and self-service was explored, and we took a look at some common tools and
    patterns to deliver a platform that meets the users where they are.</st> <st c="89604">If
    you were following along with a kind cluster, you may have even gained some hands-on
    experience with these recommendations.</st> <st c="89731">While we touched briefly
    on the security aspects of each of these topics, we’ll cover each of them and
    more topics in depth in the</st> <st c="89862">next chapter.</st>
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: <st c="0">Part 3 – Platforms as a Product Best Practices</st>
  id: totrans-296
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="47">In the last part, we will provide you with the tools to optimize
    your platform for cost efficiency, enabling your users to do the same.</st> <st
    c="184">We will achieve this by outlining the simple steps required to establish
    transparency within your cost landscape and by providing you with best practices
    to reduce your infrastructure expenses.</st> <st c="378">From infrastructure costs,
    we will move on to technical debts, which can negatively impact the maintenance
    costs of the selected technology stack if they are not dealt with correctly.</st>
    <st c="562">You will learn about tools and frameworks to evaluate technical debts
    and the importance of documenting what decisions you make.</st> <st c="691">Finally,
    we will take a look into the future.</st> <st c="737">You will learn about the
    imperative of change and why you have to become an active part of driving change.</st>
    <st c="844">You might discover a different perspective on your golden path and
    some ideas about future</st> <st c="935">relevant technologies.</st>
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: <st c="957">This part has the</st> <st c="976">following chapters:</st>
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[*<st c="995">Chapter 7</st>*](B31164_07.xhtml#_idTextAnchor381)<st c="1005">,</st>
    *<st c="1007">Building Secure and Compliant Products</st>*'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*<st c="1045">Chapter 8</st>*](B31164_08.xhtml#_idTextAnchor430)<st c="1055">,</st>
    *<st c="1057">Cost Management and Best Practices</st>*'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*<st c="1091">Chapter 9</st>*](B31164_09.xhtml#_idTextAnchor479)<st c="1101">,</st>
    *<st c="1103">Choosing Technical Debt to Unbreak Platforms</st>*'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*<st c="1147">Chapter 10</st>*](B31164_10.xhtml#_idTextAnchor507)<st c="1158">,</st>
    *<st c="1160">Crafting Platform Products for the Future</st>*'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
