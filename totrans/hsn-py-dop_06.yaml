- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security and DevSecOps with Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s a jungle out there. Disorder and confusion everywhere…
  prefs: []
  type: TYPE_NORMAL
- en: – Randy Newman
  prefs: []
  type: TYPE_NORMAL
- en: (If you know the rest of the song, good for you.)
  prefs: []
  type: TYPE_NORMAL
- en: 'What is the password that you use most frequently? Do you never re-use a password?
    Don’t lie to me and don’t lie to yourself in this situation, lest you get locked
    out of your accounts. I’m using passwords here because that is the easiest way
    to break the ice on this conversation about security, and passwords are the easiest
    way to think about security. They provide a secure way to distinguish accounts
    and users and allow each their own access parameters. What we are going to talk
    about in this chapter will be a little more complex (just a little) but the underlying
    principles are the same: it is about securing access and making sure only the
    right people have access.'
  prefs: []
  type: TYPE_NORMAL
- en: In **DevSecOps** (a branch of **DevOps** dedicated to security), the goal is
    to have security measures present and used before, during, and after any breach
    in security. This requires the use of best practices in securing access keys and
    other credentials, the use of best practices in securing infrastructure (such
    as containers), and the same for after a security incident has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Security is the responsibility of every single person on an application’s team
    and this responsibility obligates the team members to use tools and techniques
    that do not compromise on security and that can facilitate the automation of security
    processes to remove human error.
  prefs: []
  type: TYPE_NORMAL
- en: It just so happens we know a very good facilitator for that, don’t we? That’s
    right, **Python** is incredible at facilitating and supporting security and encryption
    and it is flexible and easy enough to use for security engineers even if they
    don’t have a lot of coding experience. Python’s Swiss Army knife property gives
    it the ability to integrate anywhere within this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s view the content that we are going to explore in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: We will find out how to secure and obfuscate sensitive codes, API keys, and
    passwords using Python
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will learn what validation of containers is and how Python can help double-check
    this process if needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will learn about the tools that Python has that can be used to facilitate
    incident monitoring and response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some requirements that will help you follow along with this chapter’s
    activities:'
  prefs: []
  type: TYPE_NORMAL
- en: A GitHub account to clone the repository containing sample code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An AWS account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Google Cloud account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google Colab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any environment with Python installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tolerance for my sarcastic prose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can access this book's repository at [https://github.com/PacktPublishing/Hands-On-Python-for-DevOps](https://github.com/PacktPublishing/Hands-On-Python-for-DevOps)
  prefs: []
  type: TYPE_NORMAL
- en: Securing API keys and passwords
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'API keys and passwords are valuable for the reason most things are valuable:
    they cost money and the data protected by them are valuable. If you’ve ever watched
    any heist movie (and if you haven’t, I’d recommend *Heat*, which is a great movie)
    you know that there is always some sort of access code, signature, or safe combination
    that the heist team must acquire. This is because the idea of a secret code, passphrase,
    or encryption is perpetual throughout human civilization as a barrier to accessing
    sensitive information. Passwords existed for tens of thousands of years before
    computers even came around.'
  prefs: []
  type: TYPE_NORMAL
- en: A heist team in the cyber domain will also try a similar strategy. They will
    attempt to extract passcodes and credentials from people who potentially have
    them so that they can acquire sensitive information. Sometimes, the information
    inside doesn’t even have to be sensitive, sometimes people just hack things because
    they are bored or like to social engineer people (I’m told there are people addicted
    to manipulating people, so that is quite scary). Either way, your information
    security is under constant attack, whether it is on the server side or the user
    side. So, precautionary measures and mechanisms for these kinds of attacks are
    necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we get to the Python part. We can try a couple of things with Python to
    implement this concept here. We can create environment variables and secrets that
    store variables that are sensitive in a separate folder or within the **operating
    system** (**OS**) configuration itself. We can also use Python (by itself or with
    some other tool or API) to extract and obfuscate **personally identifiable** **information**
    (**PII**).
  prefs: []
  type: TYPE_NORMAL
- en: Store environment variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Environment variables are stored as both a means of separating credentials from
    application code to prevent hardcoding and to make sure that an application can
    run with different credentials on different systems just by configuring those
    credentials into the OS or a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'That brings us to the two ways in which we can store and retrieve environment
    variables: we can store them as files or as variables defined in the OS. You can,
    of course, also do this in a Cloud Secret Manager or using a hardware device,
    but those are similar concepts to the ones we are discussing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the first way (files), you can create and read from `.env` files in the
    following way:'
  prefs: []
  type: TYPE_NORMAL
- en: 'These files are the standard for storing these environment variables and are
    usually ignored in practically every `.gitignore` file. To read these files, we
    must first install Python’s `python-dotenv` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After this, we can create a `.env` file and store variables and secrets within
    it. We separate these secrets based on the line that they are on. Here is a sample
    of a couple of lines of a `.``env` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remember, *all caps* are for constants. This approach helps consolidate these
    constants in one place so that you don’t have to worry about changing them in
    all the locations you need them in your code, and you don’t have to worry about
    missing one change somewhere.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s write the code by which our program can access the environment variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running this code will give you the API key and the secret key in their respective
    variables.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let’s try the same thing, but with environment variables exported and
    used directly from our own OS:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Linux – where most servers of this kind are prevalent – we can set up environment
    variables as we did in the previous example with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now comes the matter of accessing these values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You’ll see that we are still using the `os` library from the previous code.
    This method is a little bit simpler and perhaps a little more secure than the
    `.env` file for a fewer number of environment variables. But when using a large
    number of environment variables, a `.env` file is better at aggregation and easier
    to use and handle.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: These methods have taught you how to deal with sensitive information that you
    are responsible for and you yourself add to the code base. However, there comes
    a time when you will have to deal with the sensitive data of others. This data
    needs to be protected and you need to ensure that it doesn’t get into the wrong
    hands. The key to this? Making it useless for anything other than your purposes.
    We will talk about the obfuscation of PII next.
  prefs: []
  type: TYPE_NORMAL
- en: Extract and obfuscate PII
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A person’s sensitive personal information is one of the most valuable things
    they have: financially, socially, and intimately. Compromising the security of
    this information can result in great harm to the person in all three of these
    areas. The privacy of people is of utmost importance, and we must take all possible
    measures in order to preserve it, especially when they entrust some bit of that
    information to the services that we provide for them.'
  prefs: []
  type: TYPE_NORMAL
- en: So, what would be the best approach to start with this? Well, there are a lot
    of pre-built services such as Amazon Macie or Google Cloud’s **DLP** (short for
    **Data Loss Prevention**), and these services are handy, but you may not understand
    the inner workings of them since they are trained on certain machine learning
    algorithms that require very little input (if at all) from their users to redact
    and obfuscate a wide range of personal information.
  prefs: []
  type: TYPE_NORMAL
- en: But let’s say there is a piece of information that isn’t covered by these services,
    or you cannot use them because of compliance reasons. Then, you would have to
    begin creating your solution from scratch. Here again, Python is your friend.
    You can use Python to read files and find locations that contain sensitive information
    (based on certain criteria) and change that information in a way that hides or
    obfuscates it. This technique is the same as that for mining data by finding important
    patterns within the data, only in this case, instead of extracting the data, we
    are making sure that if some malicious actors tried to extract it, they would
    not be able to recover any vital information.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this, we are going to use a very simple **regex** or **regular
    expression** pattern for phone numbers to find them within a text and replace
    them with some form of redaction. We could try something a bit more complex, but
    it would still be the same concept, and if you are new to regex, I would suggest
    that you start somewhat slowly and discover the magic of regex. Truly, you will
    feel like a wizard.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enough posturing for now; let’s get down to business. First, we need a regex
    that can be used to capture the pattern of a phone number. Don’t try and make
    a regex yourself unless you’re really trying to dive deep into it. For most use
    cases, you can find a suitable regex pre-made for you on the internet. In most
    cases, you can use it as it is, and in some very specific cases, you might have
    to make a couple of adjustments. So, the regex that covers phone number patterns
    (both using country codes and not) can be written like this: `\d{3}-\d{3}-\d{4}''`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That probably looks like a bunch of gibberish to you, but it works, and you
    should trust that (someone probably lost their mind trying to get it just right).
    This works with dashes and without country codes (though, you can make a regex
    that works with both). Now, let’s implement the regex on a small passage that
    contains phone numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Well, there you have it; this code finds phone numbers using a regex pattern
    and subsequently obfuscates it by replacing the phone numbers.
  prefs: []
  type: TYPE_NORMAL
- en: This is by far one of the simplest and most accessible ways to get regex but
    you can get even more complex with it. You can use it to obfuscate social security
    numbers, passport numbers, and pretty much anything that matches a pre-defined
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have had security on the simplest, textual level. Now, we need to
    look towards security for our infrastructure. For this, we can look at container
    images since they are so prevalent, and validating them is so important. Let’s
    see how we can validate these images.
  prefs: []
  type: TYPE_NORMAL
- en: Validating and verifying container images with Binary Authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The amount of time I have now spent harping on about containers has probably
    clued you into the fact that containers may be somewhat important. Containers
    are, of course, an encapsulation of all the resource requirements and libraries
    that are specifically needed to run one service in an application. Containers
    being isolated from each other results in the elimination of conflict between
    the libraries required to run the services in each container, effectively creating
    an isolated system for each service in an overall large system or application.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this also presents a two-fold vulnerability: complexity and a larger
    threat vector in some circumstances. Handling all of these containers and the
    complex underlying libraries that lie within them (thus the need for Kubernetes)
    can be a difficult task. Managing these complex systems improperly can lead to
    the creation of structural and informational vulnerabilities in the system. At
    the same time, if multiple clusters are exposed to a public-facing setting or
    can be accessed in some way that gives an unauthorized user privileged access
    to your system, the threat to one container could threaten all the containers
    present in your system, as well as all your information.'
  prefs: []
  type: TYPE_NORMAL
- en: Python’s Docker libraries make sure that you can do this for every layer of
    your image in an automated manner. Python can also use a number of third-party
    image verification tools. We will explore one of those tools with Google’s Binary
    Authorization API and Workflow for Kubernetes. So, let’s see how to verify compliant
    images with Binary Authorization!
  prefs: []
  type: TYPE_NORMAL
- en: '**Compliance** is an interesting subject, much of it is in the eye of the beholder.
    The definition of compliance depends on how strict you want to be. In Kubernetes
    – specifically in **Google Kubernetes Engine** – there must be some sort of assurance
    or regulation that defines that the correct image has been used. The mechanic
    is known as **Binary Authorization**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Binary Authorization allows the Docker containers that are deployed in a Kubernetes
    cluster to be checked according to certain criteria. Authorization can be done
    either by using a compliance policy or an attestor. A compliance policy creates
    rules that allow only images that meet a certain criterion. Adding an attestor
    means adding an individual user in your project who can testify that the image
    that is going to be used is correct. In Binary Authorization, you can use one
    or both of these in order to authorize your images for your Kubernetes cluster.
    Let’s see how to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now going to write a script to create an attestor and assign that attestor
    to the Kubernetes engine. First, we must install the client libraries for containers
    and Binary Authorization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s write the script for the Binary Authorization of the cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will create an attestor that can attest your cluster requests.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we need to add the Binary Authorization to a cluster that has already
    been created or is about to be created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This script will update the Kubernetes cluster to start using our Binary Authorization
    method. That takes care of incidents within your infrastructure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, we will explore a couple of things that could help you with incidents outside
    of your infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Incident monitoring and response
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'How would one define an incident? Well, let me posit this to you: what would
    you do if a bear attacked you? Does this sound stupid? Are these way too many
    questions? Well, this question is a fairly direct way to understand an incident
    and how it is reacted to.'
  prefs: []
  type: TYPE_NORMAL
- en: The bear is attacking you; it is much larger than you and, well, you don’t want
    it to get you. In this case, the bear attack is the incident and the bear itself
    is just a vector for the incident. The result of the incident depends on the response,
    and to have a good response, you need a good head on your shoulders (you need
    to *monitor* the situation, get it?). The report of the response to the incident
    will happen one way or another. However, if you want to be the one writing the
    report, you need to have handled the incident correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Actual security incidents are not as brutal as that (not physically, anyway).
    Don’t worry. But they do work similarly. There is an incident, in which security
    is compromised in some way, there is a tool used to exploit a vulnerability, and
    when that vulnerability is exploited, it must be handled calmly and mitigated
    where possible. Once that is done and you have restored order, the incident response
    needs to be documented and distributed to the correct parties.
  prefs: []
  type: TYPE_NORMAL
- en: Now, here is where Python comes in. In order to respond to a security threat
    that potentially targets a fleet of virtual machines, Python can help run what
    is called a **runbook**, which is a series of commands that can be deployed to
    reset a system or to have it respond to some sort of threat. Another way to use
    Python in this capacity would be to look at monitoring data from the time of an
    incident and compare it to regular data in order to find some patterns that can
    be used to predict and get ahead of future incidents.
  prefs: []
  type: TYPE_NORMAL
- en: Running runbooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we talk about incident response, one of the most common responses to an
    incident that affects your resources is to turn it on and off again. This is effective
    maybe 97% of the time. Seriously. But sometimes people resent doing that, too.
    For me, when the Bluetooth malfunctions on my laptop, I have to restart it for
    some reason. It’s irrational and it irritates me irrationally, but it provides
    the solution (unlike the 500 other ways to restart Bluetooth that I find on the
    internet before I actually go through with it).
  prefs: []
  type: TYPE_NORMAL
- en: We’re going to play it smart; we are going to focus on that 97%, but at the
    same time, we are going to give you the blueprint to run more complex code and
    procedures that you may like to write. This one is particularly closely adapted
    to AWS, but similar fleet management and operations can be found on every major
    cloud as well as for most on-premises operations as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this exercise, we are using the **AWS EventBridge** to trigger a step function
    that will subsequently run a command on the desired EC2 instance that has triggered
    the event, restarting the instance from within. Again, we’re keeping the commands
    simple here, but if you want you can get more advanced with it. So, let’s get
    started:'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with a running instance. I have named mine `test1`. Very creative,
    I know.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.1 – A running instance](img/B21320_06_1.png)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – A running instance
  prefs: []
  type: TYPE_NORMAL
- en: Let’s live in a scenario where this is an instance that has a high amount of
    network traffic flowing through it. So high that, if it dropped below a certain
    level, it would indicate some sort of malfunction in the instance. In this case,
    that malfunction can be sorted through a simple restart using a runbook document.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make the structure for that command now in **AWS Lambda**. But first,
    we need the command that is to be sent, which is found in **Systems Manager**.
    Open **Systems Manager** and go to the **Documents** tab at the bottom of the
    sidebar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.2 – AWS Systems Manager](img/B21320_06_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – AWS Systems Manager
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the documents, search for the `AWS-RestartEC2Instance` document. This
    is the default document, and you can base a lot of other VM manipulation documents
    on it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Document to perform EC2 restarts](img/B21320_06_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Document to perform EC2 restarts
  prefs: []
  type: TYPE_NORMAL
- en: This is a simple baseline document and it can serve as a baseline for any sort
    of scripting action that you perform. Most other cloud providers also have something
    equivalent to this.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Detailed AWS-RestartEC2Instance document](img/B21320_06_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – Detailed AWS-RestartEC2Instance document
  prefs: []
  type: TYPE_NORMAL
- en: If we look at it a bit closer, we can see that this document stops and then
    starts a particular instance based on instance ID, which is what we are going
    to provide.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s write an EventBridge event that will trigger a Lambda function in
    the event of a decrease in network traffic over the course of five minutes. For
    that, let’s first go to Amazon CloudWatch and create an alarm that triggers under
    our condition. Go to **CloudWatch** | **Alarms** | **Create alarm**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Cloudwatch Alarms console](img/B21320_06_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – Cloudwatch Alarms console
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now create a separate alarm for our `test 1` instance and it will be
    shown graphically to give you an idea of what is happening with the metric currently:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Creating an alarm metric](img/B21320_06_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – Creating an alarm metric
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s set the condition for the trigger for the alarm to be under **20,000**
    bytes of network input over a period of five minutes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Setting a threshold for the alarm](img/B21320_06_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – Setting a threshold for the alarm
  prefs: []
  type: TYPE_NORMAL
- en: Name the alarm `test1-alarm` in the field asking you for the alarm name and
    we’re good to go.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we can look at the alarm on the **Details** tab and find the EventBridge
    rules, which we will need to set up the EventBridge trigger:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Alarm configuration details](img/B21320_06_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – Alarm configuration details
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, go to **Amazon EventBridge** in the AWS section, and then to the **Rules**
    tab, where you will create a new event. On the first page, select **Rule with
    an Event pattern** and then move on to the next page. Here, you will paste the
    EventBridge rule that you acquired from the alarm:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Pattern creation for event bridge](img/B21320_06_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – Pattern creation for event bridge
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the pattern, press **Next**, then in another tab, open AWS
    Lambda. Here, we will write our Python code to execute the restart of the EC2
    instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In AWS Lambda, choose the Python execution time and maintain all of the default
    settings otherwise. Then, add the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code will send the command of the playbook document to restart the EC2
    instance.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s select **Lambda function** as the target for the EventBridge:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.10 – Target Lambda function](img/B21320_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – Target Lambda function
  prefs: []
  type: TYPE_NORMAL
- en: Keep hitting **Next** until you create the EventBridge rule. When the alarm
    is triggered, that rule will trigger and run the Lambda function. This will restart
    the instance and keep doing so until the network input has been restored to acceptable
    levels.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, in this example, we saw an application that is based on an immediate reaction
    and implementation. This is good if your system is under some sort of attack meant
    to overwhelm it or to exploit something that you can’t patch. However, attacks
    don’t usually come in ones. They are targeted and frequent, constantly trying
    to find some sort of vulnerability from which to attack your workload. To help
    understand potential attack patterns and learn more about how your workload handles
    changes in general, you can use pattern analysis of monitored logs.
  prefs: []
  type: TYPE_NORMAL
- en: Pattern analysis of monitored logs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Monitored logs can give you insights into how an application has performed and
    if there are some unusual patterns detected within the timeline. For example,
    **distributed denial-of-service** (**DDoS**) attacks usually create a pattern
    of inexplicable high CPU usage in an application. It essentially causes the application
    to suffer from fake loads, which affect the actual loads in the application.
  prefs: []
  type: TYPE_NORMAL
- en: So, in order to detect these attacks, we must have an algorithm that can historically
    analyze your workload and potentially find such attacks. To find these patterns,
    Python has some great data science libraries.
  prefs: []
  type: TYPE_NORMAL
- en: Public datasets of server logs are difficult to find, but they can be recreated
    fairly easily. For this example, I will use the public dataset mocking service
    **Mockaroo**. It lets you create a dataset of 1,000 rows for free. I will only
    create a dataset with the CPU utilization and the timestamp.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 – Generating a mock dataset](img/B21320_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.11 – Generating a mock dataset
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the data has been generated, we will see that it hasn’t been sorted on
    the basis of time, so that is an extra step that we will add to our script. We
    will write our script using Google Colab. So, let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, install the `pandas` and `matplotlib` libraries. They are usually there
    already, but this step helps in other notebook applications:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.12 – Installation command](img/B21320_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.12 – Installation command
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, upload the CSV that Mockaroo created to Colab. To do this, click the
    folder icon in the side panel and then click the first icon within it to upload
    the data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.13 – Uploading mock data](img/B21320_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.13 – Uploading mock data
  prefs: []
  type: TYPE_NORMAL
- en: You will see here that I have already uploaded my data.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the next step is to read the data using pandas to create a dataframe and
    order it by time, because the mock data in the CSV was not pre-arranged in a sequence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.14 – Table for CPU utilization](img/B21320_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.14 – Table for CPU utilization
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to find the pattern in the data, we can begin by visualizing the data.
    Let’s visualize this data as a linear plot with the timestamp as the x-axis and
    CPU utilization as the y-axis:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.15 – Code to plot CPU utilization](img/B21320_06_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.15 – Code to plot CPU utilization
  prefs: []
  type: TYPE_NORMAL
- en: Now, the plot is sort of random, being randomly generated and all, so the diagram
    is not necessarily representative of what the actual diagram would look like.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16 – Diagram plotting CPU utilization over time](img/B21320_06_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.16 – Diagram plotting CPU utilization over time
  prefs: []
  type: TYPE_NORMAL
- en: So, this looks random, but that’s fine as it’s simply meant to be a representative
    of a bar graph over time. Let’s refine the dataset a little to create anomalies.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we are going to modify the dataset to have a constant utilization rate
    somewhere in the middle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.17 – Chart for modified dataset](img/B21320_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.17 – Chart for modified dataset
  prefs: []
  type: TYPE_NORMAL
- en: This is a little ridiculous, but I believe it illustrates the point of constant
    uptime. Most systems, when they are stable, do not have this kind of utilization.
    If your service is getting this kind of data, it either indicates a sudden spike
    of success or a DDoS attack. More often than not, it is the latter. So, if you
    find this kind of spike in your monitoring data, it is worth investigating.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have hopefully learned a thing or two about security. I
    also hope that you have figured out how to build your infrastructure in such a
    way that all of the access keys you use are secured.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, you have also learned some methods (among hundreds of thousands)
    that can be used to help secure your infrastructure. You may have also gotten
    some insights into how you can use data to drive the response to incidents and
    also find better insight into certain incidents and their properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, friends, I hope you enjoyed this chapter, which is all about security.
    I tried my best to explain a couple of concepts to you and I hope you found it
    interesting, at least. But now, it is time to flip the page and move on to the
    next chapter, where we will talk about one of my favorite topics: **automation**.'
  prefs: []
  type: TYPE_NORMAL
