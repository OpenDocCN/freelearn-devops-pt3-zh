- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Security and DevSecOps with Python
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Python进行安全和DevSecOps
- en: It’s a jungle out there. Disorder and confusion everywhere…
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 外面的世界一片混乱，四处都是无序和困惑…
- en: – Randy Newman
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: – Randy Newman
- en: (If you know the rest of the song, good for you.)
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: （如果你知道这首歌的其他部分，真棒。）
- en: 'What is the password that you use most frequently? Do you never re-use a password?
    Don’t lie to me and don’t lie to yourself in this situation, lest you get locked
    out of your accounts. I’m using passwords here because that is the easiest way
    to break the ice on this conversation about security, and passwords are the easiest
    way to think about security. They provide a secure way to distinguish accounts
    and users and allow each their own access parameters. What we are going to talk
    about in this chapter will be a little more complex (just a little) but the underlying
    principles are the same: it is about securing access and making sure only the
    right people have access.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 你最常用的密码是什么？你从不重复使用密码吗？在这种情况下，别对我撒谎，也别对自己撒谎，以免你被锁定在账户之外。我在这里提到密码，因为这是打开关于安全话题对话的最佳方式，密码也是最容易理解安全的方式。它们提供了一种安全的方式来区分账户和用户，并为每个用户设置独立的访问权限。本章将讨论的内容会稍微复杂一些（只是稍微复杂），但基本原理是一样的：我们讨论的是如何保护访问权限，确保只有正确的人才能访问。
- en: In **DevSecOps** (a branch of **DevOps** dedicated to security), the goal is
    to have security measures present and used before, during, and after any breach
    in security. This requires the use of best practices in securing access keys and
    other credentials, the use of best practices in securing infrastructure (such
    as containers), and the same for after a security incident has occurred.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在**DevSecOps**（一个专注于安全的**DevOps**分支）中，目标是在任何安全漏洞发生之前、期间和之后都能采取安全措施。这要求使用最佳实践来保护访问密钥和其他凭证，确保基础设施（如容器）的安全，以及在发生安全事件后同样采取相应的最佳实践。
- en: Security is the responsibility of every single person on an application’s team
    and this responsibility obligates the team members to use tools and techniques
    that do not compromise on security and that can facilitate the automation of security
    processes to remove human error.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 安全是应用团队中每个成员的责任，这个责任要求团队成员使用不会妥协安全的工具和技术，并能促进安全流程的自动化，从而减少人为错误。
- en: It just so happens we know a very good facilitator for that, don’t we? That’s
    right, **Python** is incredible at facilitating and supporting security and encryption
    and it is flexible and easy enough to use for security engineers even if they
    don’t have a lot of coding experience. Python’s Swiss Army knife property gives
    it the ability to integrate anywhere within this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 恰巧我们知道一个非常好的工具来实现这一点，不是吗？没错，**Python**在促进和支持安全性与加密方面非常强大，而且它灵活易用，即使是没有太多编程经验的安全工程师也能轻松上手。Python的瑞士军刀特性让它能够在本章中无缝整合到任何地方。
- en: 'So, let’s view the content that we are going to explore in this chapter:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们来看看本章将要探索的内容：
- en: We will find out how to secure and obfuscate sensitive codes, API keys, and
    passwords using Python
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将学习如何使用Python来保护和混淆敏感代码、API密钥和密码。
- en: We will learn what validation of containers is and how Python can help double-check
    this process if needed
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将了解容器验证是什么，以及Python如何在需要时帮助我们再次检查这个过程。
- en: We will learn about the tools that Python has that can be used to facilitate
    incident monitoring and response
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将了解Python提供的工具，如何利用这些工具促进事件监控和响应。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Here are some requirements that will help you follow along with this chapter’s
    activities:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些要求，帮助你跟上本章活动的进度：
- en: A GitHub account to clone the repository containing sample code
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个GitHub帐户，用于克隆包含示例代码的代码库
- en: An AWS account
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个AWS帐户
- en: A Google Cloud account
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个Google Cloud帐户
- en: Google Colab
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Colab
- en: Any environment with Python installed
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何安装了Python的环境
- en: Tolerance for my sarcastic prose
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 宽容我的讽刺语气
- en: You can access this book's repository at [https://github.com/PacktPublishing/Hands-On-Python-for-DevOps](https://github.com/PacktPublishing/Hands-On-Python-for-DevOps)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以访问本书的代码库：[https://github.com/PacktPublishing/Hands-On-Python-for-DevOps](https://github.com/PacktPublishing/Hands-On-Python-for-DevOps)
- en: Securing API keys and passwords
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护API密钥和密码
- en: 'API keys and passwords are valuable for the reason most things are valuable:
    they cost money and the data protected by them are valuable. If you’ve ever watched
    any heist movie (and if you haven’t, I’d recommend *Heat*, which is a great movie)
    you know that there is always some sort of access code, signature, or safe combination
    that the heist team must acquire. This is because the idea of a secret code, passphrase,
    or encryption is perpetual throughout human civilization as a barrier to accessing
    sensitive information. Passwords existed for tens of thousands of years before
    computers even came around.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: API 密钥和密码之所以有价值，是因为大多数东西之所以有价值，是因为它们需要付出金钱，而且它们所保护的数据也非常珍贵。如果你看过任何一部盗窃电影（如果你没看过，我推荐*Heat*，这是一部非常好的电影），你就会知道，盗窃团队总是需要获得某种访问代码、签名或保险箱密码。这是因为，秘密代码、密码或加密在整个人类文明中作为访问敏感信息的障碍的概念是永恒的。密码在计算机出现之前已经存在了数万年。
- en: A heist team in the cyber domain will also try a similar strategy. They will
    attempt to extract passcodes and credentials from people who potentially have
    them so that they can acquire sensitive information. Sometimes, the information
    inside doesn’t even have to be sensitive, sometimes people just hack things because
    they are bored or like to social engineer people (I’m told there are people addicted
    to manipulating people, so that is quite scary). Either way, your information
    security is under constant attack, whether it is on the server side or the user
    side. So, precautionary measures and mechanisms for these kinds of attacks are
    necessary.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络领域，一个盗窃团队也会尝试类似的策略。他们会试图从那些可能拥有密码和凭证的人那里提取信息，以便获取敏感数据。有时，这些信息本身并不一定是敏感的，有时人们只是因为无聊或者喜欢社会工程学（我听说有些人上瘾于操控别人，这让人感到相当可怕）。无论如何，你的信息安全始终受到攻击，无论是在服务器端还是用户端。因此，对于这类攻击的预防措施和机制是必要的。
- en: Now, we get to the Python part. We can try a couple of things with Python to
    implement this concept here. We can create environment variables and secrets that
    store variables that are sensitive in a separate folder or within the **operating
    system** (**OS**) configuration itself. We can also use Python (by itself or with
    some other tool or API) to extract and obfuscate **personally identifiable** **information**
    (**PII**).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们进入 Python 部分。我们可以尝试几种方法，通过 Python 来实现这个概念。我们可以创建环境变量和秘密，将敏感变量存储在单独的文件夹中或操作系统（**OS**）配置中。我们还可以使用
    Python（独立使用或与其他工具或 API 一起使用）来提取和模糊化**个人身份信息**（**PII**）。
- en: Store environment variables
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储环境变量
- en: Environment variables are stored as both a means of separating credentials from
    application code to prevent hardcoding and to make sure that an application can
    run with different credentials on different systems just by configuring those
    credentials into the OS or a file.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量的存储不仅是为了将凭证与应用代码分离，以防止硬编码，还为了确保应用程序可以在不同的系统上使用不同的凭证运行，只需将这些凭证配置到操作系统或文件中即可。
- en: 'That brings us to the two ways in which we can store and retrieve environment
    variables: we can store them as files or as variables defined in the OS. You can,
    of course, also do this in a Cloud Secret Manager or using a hardware device,
    but those are similar concepts to the ones we are discussing.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这将我们引入了两种存储和检索环境变量的方法：我们可以将它们存储为文件或在操作系统中定义的变量。当然，你也可以在云端密钥管理器中或使用硬件设备来完成，但这些概念与我们正在讨论的类似。
- en: 'For the first way (files), you can create and read from `.env` files in the
    following way:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一种方式（文件），你可以通过以下方式创建并读取`.env`文件：
- en: 'These files are the standard for storing these environment variables and are
    usually ignored in practically every `.gitignore` file. To read these files, we
    must first install Python’s `python-dotenv` library:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些文件是存储环境变量的标准，并且在几乎所有的`.gitignore`文件中都会被忽略。要读取这些文件，我们首先需要安装 Python 的`python-dotenv`库：
- en: '[PRE0]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After this, we can create a `.env` file and store variables and secrets within
    it. We separate these secrets based on the line that they are on. Here is a sample
    of a couple of lines of a `.``env` file:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后，我们可以创建一个`.env`文件，并将变量和秘密存储其中。我们根据它们所在的行来分隔这些秘密。以下是一个`.env`文件的几行示例：
- en: '[PRE1]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Remember, *all caps* are for constants. This approach helps consolidate these
    constants in one place so that you don’t have to worry about changing them in
    all the locations you need them in your code, and you don’t have to worry about
    missing one change somewhere.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住，*大写字母*是用于常量的。这种方法有助于将常量集中在一个地方，这样你就不必担心在代码中的多个位置更改它们，也不用担心某个地方漏掉了某个修改。
- en: 'Now, let’s write the code by which our program can access the environment variables:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写代码，让程序能够访问环境变量：
- en: '[PRE2]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Running this code will give you the API key and the secret key in their respective
    variables.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 运行此代码后，你将获得 API 密钥和密钥，在各自的变量中。
- en: 'Next, let’s try the same thing, but with environment variables exported and
    used directly from our own OS:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试相同的操作，但直接从我们自己的操作系统中导出并使用环境变量：
- en: 'In Linux – where most servers of this kind are prevalent – we can set up environment
    variables as we did in the previous example with the following commands:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Linux 中——这种服务器最为普遍——我们可以像在之前的例子中那样，使用以下命令设置环境变量：
- en: '[PRE3]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now comes the matter of accessing these values:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在的问题是如何访问这些值：
- en: '[PRE4]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You’ll see that we are still using the `os` library from the previous code.
    This method is a little bit simpler and perhaps a little more secure than the
    `.env` file for a fewer number of environment variables. But when using a large
    number of environment variables, a `.env` file is better at aggregation and easier
    to use and handle.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你会发现我们仍然在使用之前代码中的 `os` 库。对于较少数量的环境变量，这种方法相对更简单，也许比 `.env` 文件更安全。但是，当环境变量数量很大时，`.env`
    文件在聚合和使用管理方面会更加方便。
- en: These methods have taught you how to deal with sensitive information that you
    are responsible for and you yourself add to the code base. However, there comes
    a time when you will have to deal with the sensitive data of others. This data
    needs to be protected and you need to ensure that it doesn’t get into the wrong
    hands. The key to this? Making it useless for anything other than your purposes.
    We will talk about the obfuscation of PII next.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法教会了你如何处理你自己负责的敏感信息，并且这些信息是你自己添加到代码库中的。然而，终有一天，你会遇到需要处理他人敏感数据的情况。这些数据需要保护，你必须确保它不会落入不法之手。关键是什么？让这些数据对除你以外的任何用途都变得无用。接下来我们将讨论如何模糊处理个人身份信息（PII）。
- en: Extract and obfuscate PII
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取并模糊处理个人身份信息（PII）
- en: 'A person’s sensitive personal information is one of the most valuable things
    they have: financially, socially, and intimately. Compromising the security of
    this information can result in great harm to the person in all three of these
    areas. The privacy of people is of utmost importance, and we must take all possible
    measures in order to preserve it, especially when they entrust some bit of that
    information to the services that we provide for them.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一个人的敏感个人信息是他们拥有的最有价值的东西之一：无论是在财务上、社交上，还是亲密关系上。泄露这些信息的安全性可能会对个人造成极大的伤害，涉及这三方面的各类损失。人们的隐私至关重要，我们必须采取一切可能的措施来保护它，尤其是当他们将部分信息托付给我们提供的服务时。
- en: So, what would be the best approach to start with this? Well, there are a lot
    of pre-built services such as Amazon Macie or Google Cloud’s **DLP** (short for
    **Data Loss Prevention**), and these services are handy, but you may not understand
    the inner workings of them since they are trained on certain machine learning
    algorithms that require very little input (if at all) from their users to redact
    and obfuscate a wide range of personal information.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，开始这个工作的最佳方法是什么呢？有很多现成的服务，例如 Amazon Macie 或 Google Cloud 的 **DLP**（即 **数据丢失预防**）服务，这些服务非常方便，但你可能无法理解它们的内部运作，因为它们是基于某些机器学习算法进行训练的，这些算法几乎不需要用户输入（如果有的话），就能自动对各种个人信息进行删除和模糊处理。
- en: But let’s say there is a piece of information that isn’t covered by these services,
    or you cannot use them because of compliance reasons. Then, you would have to
    begin creating your solution from scratch. Here again, Python is your friend.
    You can use Python to read files and find locations that contain sensitive information
    (based on certain criteria) and change that information in a way that hides or
    obfuscates it. This technique is the same as that for mining data by finding important
    patterns within the data, only in this case, instead of extracting the data, we
    are making sure that if some malicious actors tried to extract it, they would
    not be able to recover any vital information.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 但假设有一条信息不被这些服务覆盖，或者由于合规原因你无法使用它们。那么，你就需要从头开始创建自己的解决方案。在这种情况下，Python就是你的好帮手。你可以使用Python读取文件，找到包含敏感信息的位置（基于某些标准），并以一种隐藏或模糊处理这些信息的方式修改它们。这种技术与通过数据挖掘找到重要模式来提取数据的方式相同，只不过在这种情况下，我们不是提取数据，而是确保如果一些恶意行为者尝试提取数据，他们无法恢复任何重要信息。
- en: To demonstrate this, we are going to use a very simple **regex** or **regular
    expression** pattern for phone numbers to find them within a text and replace
    them with some form of redaction. We could try something a bit more complex, but
    it would still be the same concept, and if you are new to regex, I would suggest
    that you start somewhat slowly and discover the magic of regex. Truly, you will
    feel like a wizard.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这个，我们将使用一个非常简单的**正则表达式**（**regex**）模式来查找文本中的电话号码，并将其替换为某种形式的遮掩。我们可以尝试一个稍微复杂一点的正则表达式，但本质上还是相同的概念。如果你是正则表达式的新手，我建议你从简单的开始，慢慢发现正则表达式的魔力。真的，你会觉得自己像个巫师。
- en: 'Enough posturing for now; let’s get down to business. First, we need a regex
    that can be used to capture the pattern of a phone number. Don’t try and make
    a regex yourself unless you’re really trying to dive deep into it. For most use
    cases, you can find a suitable regex pre-made for you on the internet. In most
    cases, you can use it as it is, and in some very specific cases, you might have
    to make a couple of adjustments. So, the regex that covers phone number patterns
    (both using country codes and not) can be written like this: `\d{3}-\d{3}-\d{4}''`.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不需要再做过多的姿态展示了；让我们开始进入正题。首先，我们需要一个正则表达式来捕获电话号码的模式。除非你真的想深入了解正则表达式，否则不要自己尝试写一个。对于大多数使用场景，你可以在互联网上找到一个适合的现成正则表达式。在大多数情况下，你可以直接使用它，而在一些非常特定的情况下，你可能需要进行一些调整。所以，覆盖电话号码模式（包括带有国家代码和不带国家代码的）正则表达式可以这样写：`\d{3}-\d{3}-\d{4}'`。
- en: 'That probably looks like a bunch of gibberish to you, but it works, and you
    should trust that (someone probably lost their mind trying to get it just right).
    This works with dashes and without country codes (though, you can make a regex
    that works with both). Now, let’s implement the regex on a small passage that
    contains phone numbers:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这对你来说可能看起来像一堆无意义的字符，但它有效，你应该相信这一点（可能有人为了让它完全正确而几乎疯掉）。这个正则表达式适用于带有和不带有国家代码的电话号码（尽管你也可以写一个适用于两者的正则表达式）。现在，让我们在一个包含电话号码的小段文本中实现这个正则表达式：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Well, there you have it; this code finds phone numbers using a regex pattern
    and subsequently obfuscates it by replacing the phone numbers.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，就这样；这段代码使用正则表达式模式找到电话号码，并通过替换电话号码来进行模糊处理。
- en: This is by far one of the simplest and most accessible ways to get regex but
    you can get even more complex with it. You can use it to obfuscate social security
    numbers, passport numbers, and pretty much anything that matches a pre-defined
    pattern.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这是迄今为止最简单且最容易获取正则表达式的方法，但你可以让它变得更加复杂。你可以用它来模糊处理社会保障号码、护照号码，以及几乎任何符合预定义模式的东西。
- en: So far, we have had security on the simplest, textual level. Now, we need to
    look towards security for our infrastructure. For this, we can look at container
    images since they are so prevalent, and validating them is so important. Let’s
    see how we can validate these images.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只在最简单的文本级别上进行了安全性处理。现在，我们需要关注基础设施的安全性。为此，我们可以看看容器镜像，因为它们非常普遍，而且验证它们非常重要。让我们看看如何验证这些镜像。
- en: Validating and verifying container images with Binary Authorization
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用二进制授权验证和验证容器镜像
- en: The amount of time I have now spent harping on about containers has probably
    clued you into the fact that containers may be somewhat important. Containers
    are, of course, an encapsulation of all the resource requirements and libraries
    that are specifically needed to run one service in an application. Containers
    being isolated from each other results in the elimination of conflict between
    the libraries required to run the services in each container, effectively creating
    an isolated system for each service in an overall large system or application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 目前为止我已经花了很多时间谈论容器，这可能已经让你意识到容器可能有些重要了。当然，容器是应用程序中运行一个服务所需的所有资源需求和库的封装体。容器之间的隔离导致了每个容器中运行的服务所需的库之间的冲突消除，有效地为整体大系统或应用程序中的每个服务创建了一个隔离的系统。
- en: 'However, this also presents a two-fold vulnerability: complexity and a larger
    threat vector in some circumstances. Handling all of these containers and the
    complex underlying libraries that lie within them (thus the need for Kubernetes)
    can be a difficult task. Managing these complex systems improperly can lead to
    the creation of structural and informational vulnerabilities in the system. At
    the same time, if multiple clusters are exposed to a public-facing setting or
    can be accessed in some way that gives an unauthorized user privileged access
    to your system, the threat to one container could threaten all the containers
    present in your system, as well as all your information.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这也带来了双重漏洞：在某些情况下会增加复杂性和更大的威胁向量。管理所有这些容器和其中复杂的底层库（因此需要Kubernetes）可能是一项艰巨的任务。不正确地管理这些复杂系统可能会导致系统中的结构性和信息性漏洞的产生。同时，如果多个集群暴露在面向公众的环境中，或者以某种方式可以被访问以赋予未经授权的用户对系统的特权访问，那么对一个容器的威胁可能会威胁到系统中存在的所有容器，以及所有您的信息。
- en: Python’s Docker libraries make sure that you can do this for every layer of
    your image in an automated manner. Python can also use a number of third-party
    image verification tools. We will explore one of those tools with Google’s Binary
    Authorization API and Workflow for Kubernetes. So, let’s see how to verify compliant
    images with Binary Authorization!
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Python的Docker库确保您可以以自动化方式处理镜像的每一层。Python还可以使用多种第三方镜像验证工具。我们将探讨其中一种工具与Google的二进制授权API和Kubernetes工作流。因此，让我们看看如何使用二进制授权验证合规性镜像！
- en: '**Compliance** is an interesting subject, much of it is in the eye of the beholder.
    The definition of compliance depends on how strict you want to be. In Kubernetes
    – specifically in **Google Kubernetes Engine** – there must be some sort of assurance
    or regulation that defines that the correct image has been used. The mechanic
    is known as **Binary Authorization**.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**合规性** 是一个有趣的主题，其中很大一部分取决于看客的眼光。合规性的定义取决于您希望多么严格。在Kubernetes - 特别是在**Google
    Kubernetes Engine**中 - 必须有某种保证或规定，以确保已使用正确的镜像。这个机制被称为**二进制授权**。'
- en: 'Binary Authorization allows the Docker containers that are deployed in a Kubernetes
    cluster to be checked according to certain criteria. Authorization can be done
    either by using a compliance policy or an attestor. A compliance policy creates
    rules that allow only images that meet a certain criterion. Adding an attestor
    means adding an individual user in your project who can testify that the image
    that is going to be used is correct. In Binary Authorization, you can use one
    or both of these in order to authorize your images for your Kubernetes cluster.
    Let’s see how to do that:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制授权允许检查在Kubernetes集群中部署的Docker容器是否符合某些标准。授权可以通过使用合规性策略或认证者来完成。合规性策略创建规则，只允许满足某些标准的镜像。添加认证者意味着在您的项目中添加一个个体用户，可以证明将要使用的镜像是正确的。在二进制授权中，您可以使用这两者中的一个或两者都使用，以授权您的Kubernetes集群中的镜像。让我们看看如何做到这一点：
- en: 'We are now going to write a script to create an attestor and assign that attestor
    to the Kubernetes engine. First, we must install the client libraries for containers
    and Binary Authorization:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将编写一个脚本来创建一个认证者，并将该认证者分配给Kubernetes引擎。首先，我们必须安装容器和二进制授权的客户端库：
- en: '[PRE6]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, let’s write the script for the Binary Authorization of the cluster:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们为集群的二进制授权编写脚本：
- en: '[PRE7]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will create an attestor that can attest your cluster requests.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将创建一个能对您的集群请求进行认证的认证者。
- en: 'Now, we need to add the Binary Authorization to a cluster that has already
    been created or is about to be created:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将二进制授权添加到已创建或即将创建的集群中：
- en: '[PRE8]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This script will update the Kubernetes cluster to start using our Binary Authorization
    method. That takes care of incidents within your infrastructure.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个脚本将更新 Kubernetes 集群，使其开始使用我们的二进制授权方法。这可以解决你基础设施内部的事件。
- en: Now, we will explore a couple of things that could help you with incidents outside
    of your infrastructure.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将探讨一些可以帮助你应对基础设施之外的事件的内容。
- en: Incident monitoring and response
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件监控与响应
- en: 'How would one define an incident? Well, let me posit this to you: what would
    you do if a bear attacked you? Does this sound stupid? Are these way too many
    questions? Well, this question is a fairly direct way to understand an incident
    and how it is reacted to.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何定义一个事件呢？让我问你这个问题：如果一只熊袭击了你，你会怎么做？听起来很傻吗？这些问题是不是太多了？嗯，这个问题实际上是一种直接理解事件以及如何反应的方式。
- en: The bear is attacking you; it is much larger than you and, well, you don’t want
    it to get you. In this case, the bear attack is the incident and the bear itself
    is just a vector for the incident. The result of the incident depends on the response,
    and to have a good response, you need a good head on your shoulders (you need
    to *monitor* the situation, get it?). The report of the response to the incident
    will happen one way or another. However, if you want to be the one writing the
    report, you need to have handled the incident correctly.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 熊正在袭击你，它比你大得多，嗯，你肯定不希望它抓到你。在这种情况下，熊的攻击就是事件，熊本身只是事件的一个载体。事件的结果取决于响应，而要有好的响应，你需要冷静（你需要*监控*局势，明白了吗？）。无论如何，事件响应的报告都会以某种方式出现。然而，如果你想成为那个写报告的人，你必须正确处理事件。
- en: Actual security incidents are not as brutal as that (not physically, anyway).
    Don’t worry. But they do work similarly. There is an incident, in which security
    is compromised in some way, there is a tool used to exploit a vulnerability, and
    when that vulnerability is exploited, it must be handled calmly and mitigated
    where possible. Once that is done and you have restored order, the incident response
    needs to be documented and distributed to the correct parties.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的安全事件并不像那样残酷（至少不在身体上）。别担心。但它们的工作方式类似。事件发生时，安全性在某种程度上受到威胁，存在用于利用漏洞的工具，而一旦漏洞被利用，就必须冷静处理并尽可能进行缓解。一旦完成并恢复了秩序，事件响应需要被记录并分发给相关方。
- en: Now, here is where Python comes in. In order to respond to a security threat
    that potentially targets a fleet of virtual machines, Python can help run what
    is called a **runbook**, which is a series of commands that can be deployed to
    reset a system or to have it respond to some sort of threat. Another way to use
    Python in this capacity would be to look at monitoring data from the time of an
    incident and compare it to regular data in order to find some patterns that can
    be used to predict and get ahead of future incidents.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Python 的作用就体现出来了。为了应对可能针对虚拟机群的安全威胁，Python 可以帮助运行所谓的**运行手册**，它是一系列命令，可以用来重置系统或让系统响应某种威胁。另一种使用
    Python 的方式是查看事件发生时的监控数据，并将其与常规数据进行对比，从中寻找可以预测并提前应对未来事件的模式。
- en: Running runbooks
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 执行运行手册
- en: When we talk about incident response, one of the most common responses to an
    incident that affects your resources is to turn it on and off again. This is effective
    maybe 97% of the time. Seriously. But sometimes people resent doing that, too.
    For me, when the Bluetooth malfunctions on my laptop, I have to restart it for
    some reason. It’s irrational and it irritates me irrationally, but it provides
    the solution (unlike the 500 other ways to restart Bluetooth that I find on the
    internet before I actually go through with it).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论事件响应时，最常见的响应方式之一就是重启受影响的资源。这种方法大约在97%的情况下有效。说真的。但有时人们也不愿意这么做。对我来说，当我的笔记本蓝牙出现故障时，我不得不重启它。虽然这不合逻辑，也让我莫名其妙地烦恼，但它确实能解决问题（不像我在网上找到的500种重新启动蓝牙的办法，最终我还是选择重启）。
- en: We’re going to play it smart; we are going to focus on that 97%, but at the
    same time, we are going to give you the blueprint to run more complex code and
    procedures that you may like to write. This one is particularly closely adapted
    to AWS, but similar fleet management and operations can be found on every major
    cloud as well as for most on-premises operations as well.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要聪明一点，集中精力解决那个97%的部分，同时，我们也会提供一个蓝图，让你能够运行更复杂的代码和过程，按照你的需要进行编写。这个文档特别适配了AWS，但类似的集群管理和操作也可以在所有主要云平台以及大多数本地操作中找到。
- en: 'For this exercise, we are using the **AWS EventBridge** to trigger a step function
    that will subsequently run a command on the desired EC2 instance that has triggered
    the event, restarting the instance from within. Again, we’re keeping the commands
    simple here, but if you want you can get more advanced with it. So, let’s get
    started:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们使用**AWS EventBridge**触发一个步骤函数，随后在触发事件的目标EC2实例上运行命令，从内部重启该实例。再次强调，我们保持命令简单，但如果你需要，也可以做得更复杂。那么，让我们开始吧：
- en: Let’s start with a running instance. I have named mine `test1`. Very creative,
    I know.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从一个正在运行的实例开始。我将我的命名为`test1`。很有创意吧，我知道。
- en: '![Figure 6.1 – A running instance](img/B21320_06_1.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 正在运行的实例](img/B21320_06_1.png)'
- en: Figure 6.1 – A running instance
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 正在运行的实例
- en: Let’s live in a scenario where this is an instance that has a high amount of
    network traffic flowing through it. So high that, if it dropped below a certain
    level, it would indicate some sort of malfunction in the instance. In this case,
    that malfunction can be sorted through a simple restart using a runbook document.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在一个场景中，这个实例有大量的网络流量通过。如果流量降到某个水平以下，就会表示实例出现故障。此时，可以通过一个简单的运行手册文档来解决这个故障，重启实例。
- en: 'Let’s make the structure for that command now in **AWS Lambda**. But first,
    we need the command that is to be sent, which is found in **Systems Manager**.
    Open **Systems Manager** and go to the **Documents** tab at the bottom of the
    sidebar:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们在**AWS Lambda**中创建该命令的结构。但首先，我们需要发送的命令，它可以在**Systems Manager**中找到。打开**Systems
    Manager**，然后在侧边栏底部转到**Documents**标签页：
- en: '![Figure 6.2 – AWS Systems Manager](img/B21320_06_2.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.2 – AWS Systems Manager](img/B21320_06_2.jpg)'
- en: Figure 6.2 – AWS Systems Manager
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – AWS Systems Manager
- en: 'Within the documents, search for the `AWS-RestartEC2Instance` document. This
    is the default document, and you can base a lot of other VM manipulation documents
    on it:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文档中，搜索`AWS-RestartEC2Instance`文档。这是默认文档，你可以基于它创建许多其他虚拟机操作文档：
- en: '![Figure 6.3 – Document to perform EC2 restarts](img/B21320_06_3.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.3 – 执行EC2重启的文档](img/B21320_06_3.jpg)'
- en: Figure 6.3 – Document to perform EC2 restarts
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 执行EC2重启的文档
- en: This is a simple baseline document and it can serve as a baseline for any sort
    of scripting action that you perform. Most other cloud providers also have something
    equivalent to this.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的基础文档，可以作为你执行任何脚本操作的基础。大多数其他云服务提供商也有类似的文档。
- en: '![Figure 6.4 – Detailed AWS-RestartEC2Instance document](img/B21320_06_4.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – 详细的AWS-RestartEC2Instance文档](img/B21320_06_4.jpg)'
- en: Figure 6.4 – Detailed AWS-RestartEC2Instance document
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 详细的AWS-RestartEC2Instance文档
- en: If we look at it a bit closer, we can see that this document stops and then
    starts a particular instance based on instance ID, which is what we are going
    to provide.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细观察一下，可以看到这个文档会根据实例ID停止并重新启动一个特定的实例，而实例ID就是我们需要提供的内容。
- en: Now, let’s write an EventBridge event that will trigger a Lambda function in
    the event of a decrease in network traffic over the course of five minutes. For
    that, let’s first go to Amazon CloudWatch and create an alarm that triggers under
    our condition. Go to **CloudWatch** | **Alarms** | **Create alarm**.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写一个EventBridge事件，该事件将在五分钟内网络流量下降时触发一个Lambda函数。为此，首先转到Amazon CloudWatch并创建一个在我们的条件下触发的报警。转到**CloudWatch**
    | **Alarms** | **Create alarm**。
- en: '![Figure 6.5 – Cloudwatch Alarms console](img/B21320_06_5.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.5 – Cloudwatch Alarms 控制台](img/B21320_06_5.jpg)'
- en: Figure 6.5 – Cloudwatch Alarms console
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – Cloudwatch Alarms 控制台
- en: 'We can now create a separate alarm for our `test 1` instance and it will be
    shown graphically to give you an idea of what is happening with the metric currently:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以为我们的`test 1`实例创建一个单独的报警，它将以图形形式显示，帮助你了解当前指标的变化情况：
- en: '![Figure 6.6 – Creating an alarm metric](img/B21320_06_6.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6 – 创建报警指标](img/B21320_06_6.jpg)'
- en: Figure 6.6 – Creating an alarm metric
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – 创建报警指标
- en: 'Next, let’s set the condition for the trigger for the alarm to be under **20,000**
    bytes of network input over a period of five minutes:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们为警报的触发条件设置网络输入低于**20,000**字节，且持续五分钟：
- en: '![Figure 6.7 – Setting a threshold for the alarm](img/B21320_06_7.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.7 – 设置警报的阈值](img/B21320_06_7.jpg)'
- en: Figure 6.7 – Setting a threshold for the alarm
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 – 设置警报的阈值
- en: Name the alarm `test1-alarm` in the field asking you for the alarm name and
    we’re good to go.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示你输入警报名称的字段中命名警报为 `test1-alarm`，然后就可以开始了。
- en: 'Now, we can look at the alarm on the **Details** tab and find the EventBridge
    rules, which we will need to set up the EventBridge trigger:'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们可以查看 **详情** 标签中的警报，找到 EventBridge 规则，我们需要用它来设置 EventBridge 触发器：
- en: '![Figure 6.8 – Alarm configuration details](img/B21320_06_8.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.8 – 警报配置详情](img/B21320_06_8.jpg)'
- en: Figure 6.8 – Alarm configuration details
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 – 警报配置详情
- en: 'Then, go to **Amazon EventBridge** in the AWS section, and then to the **Rules**
    tab, where you will create a new event. On the first page, select **Rule with
    an Event pattern** and then move on to the next page. Here, you will paste the
    EventBridge rule that you acquired from the alarm:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，进入 AWS 部分的 **Amazon EventBridge**，接着到 **规则** 标签页，在那里你将创建一个新事件。在第一页，选择 **带有事件模式的规则**，然后继续到下一页。在这里，你将粘贴从警报中获取的
    EventBridge 规则：
- en: '![Figure 6.9 – Pattern creation for event bridge](img/B21320_06_9.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.9 – 事件桥的模式创建](img/B21320_06_9.jpg)'
- en: Figure 6.9 – Pattern creation for event bridge
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 – 事件桥的模式创建
- en: Now that you have the pattern, press **Next**, then in another tab, open AWS
    Lambda. Here, we will write our Python code to execute the restart of the EC2
    instance.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你有了模式，点击 **下一步**，然后在另一个标签页中打开 AWS Lambda。在这里，我们将编写 Python 代码来执行 EC2 实例的重启操作。
- en: 'In AWS Lambda, choose the Python execution time and maintain all of the default
    settings otherwise. Then, add the following code:'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 AWS Lambda 中，选择 Python 执行环境并保持所有默认设置不变。然后，添加以下代码：
- en: '[PRE9]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code will send the command of the playbook document to restart the EC2
    instance.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这段代码将发送播放手册文档的命令来重启 EC2 实例。
- en: 'Now, let’s select **Lambda function** as the target for the EventBridge:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们选择 **Lambda 函数** 作为 EventBridge 的目标：
- en: '![Figure 6.10 – Target Lambda function](img/B21320_06_10.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.10 – 目标 Lambda 函数](img/B21320_06_10.jpg)'
- en: Figure 6.10 – Target Lambda function
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 – 目标 Lambda 函数
- en: Keep hitting **Next** until you create the EventBridge rule. When the alarm
    is triggered, that rule will trigger and run the Lambda function. This will restart
    the instance and keep doing so until the network input has been restored to acceptable
    levels.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不断点击 **下一步**，直到创建 EventBridge 规则。当警报被触发时，该规则将触发并运行 Lambda 函数。这将重启实例，并持续进行，直到网络输入恢复到可接受的水平。
- en: Now, in this example, we saw an application that is based on an immediate reaction
    and implementation. This is good if your system is under some sort of attack meant
    to overwhelm it or to exploit something that you can’t patch. However, attacks
    don’t usually come in ones. They are targeted and frequent, constantly trying
    to find some sort of vulnerability from which to attack your workload. To help
    understand potential attack patterns and learn more about how your workload handles
    changes in general, you can use pattern analysis of monitored logs.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在这个例子中，我们看到一个基于即时反应和执行的应用程序。如果你的系统受到某种攻击，目的是压垮它或利用你无法修补的漏洞，这种方式是有效的。然而，攻击通常不是单独发生的。它们是有针对性的并且频繁发生，不断尝试寻找某种漏洞以攻击你的工作负载。为了帮助理解潜在的攻击模式，并了解你的工作负载如何应对变化，你可以使用监控日志的模式分析。
- en: Pattern analysis of monitored logs
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控日志的模式分析
- en: Monitored logs can give you insights into how an application has performed and
    if there are some unusual patterns detected within the timeline. For example,
    **distributed denial-of-service** (**DDoS**) attacks usually create a pattern
    of inexplicable high CPU usage in an application. It essentially causes the application
    to suffer from fake loads, which affect the actual loads in the application.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 监控日志可以为你提供应用程序表现的洞察，并且如果在时间线中检测到一些异常模式，可以帮助你发现问题。例如，**分布式拒绝服务**（**DDoS**）攻击通常会在应用程序中形成无法解释的高
    CPU 使用模式。它基本上使应用程序遭受虚假的负载，这会影响到应用程序中的实际负载。
- en: So, in order to detect these attacks, we must have an algorithm that can historically
    analyze your workload and potentially find such attacks. To find these patterns,
    Python has some great data science libraries.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了检测这些攻击，我们必须有一个能够历史性地分析工作负载并潜在地发现这些攻击的算法。为了找到这些模式，Python 有一些很棒的数据科学库。
- en: Public datasets of server logs are difficult to find, but they can be recreated
    fairly easily. For this example, I will use the public dataset mocking service
    **Mockaroo**. It lets you create a dataset of 1,000 rows for free. I will only
    create a dataset with the CPU utilization and the timestamp.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器日志的公共数据集很难找到，但它们可以相对容易地重新创建。对于这个示例，我将使用公共数据集模拟服务**Mockaroo**。它允许你免费创建一个包含
    1,000 行的数据集。我将只创建包含 CPU 利用率和时间戳的数据集。
- en: '![Figure 6.11 – Generating a mock dataset](img/B21320_06_11.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.11 – 生成模拟数据集](img/B21320_06_11.jpg)'
- en: Figure 6.11 – Generating a mock dataset
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11 – 生成模拟数据集
- en: 'Once the data has been generated, we will see that it hasn’t been sorted on
    the basis of time, so that is an extra step that we will add to our script. We
    will write our script using Google Colab. So, let’s get started:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据生成，我们会看到它没有根据时间排序，因此这是我们将在脚本中添加的额外步骤。我们将使用 Google Colab 来编写我们的脚本。那么，让我们开始吧：
- en: 'First, install the `pandas` and `matplotlib` libraries. They are usually there
    already, but this step helps in other notebook applications:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，安装 `pandas` 和 `matplotlib` 库。它们通常已经存在，但这一步对于其他笔记本应用很有帮助：
- en: '![Figure 6.12 – Installation command](img/B21320_06_12.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.12 – 安装命令](img/B21320_06_12.jpg)'
- en: Figure 6.12 – Installation command
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12 – 安装命令
- en: 'Next, upload the CSV that Mockaroo created to Colab. To do this, click the
    folder icon in the side panel and then click the first icon within it to upload
    the data:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将 Mockaroo 创建的 CSV 文件上传到 Colab。为此，点击侧边面板中的文件夹图标，然后点击其中的第一个图标上传数据：
- en: '![Figure 6.13 – Uploading mock data](img/B21320_06_13.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.13 – 上传模拟数据](img/B21320_06_13.jpg)'
- en: Figure 6.13 – Uploading mock data
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.13 – 上传模拟数据
- en: You will see here that I have already uploaded my data.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到这里我已经上传了我的数据。
- en: Now, the next step is to read the data using pandas to create a dataframe and
    order it by time, because the mock data in the CSV was not pre-arranged in a sequence.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，下一步是使用 pandas 读取数据，创建数据框并按时间排序，因为 CSV 中的模拟数据并未预先按顺序排列。
- en: '![Figure 6.14 – Table for CPU utilization](img/B21320_06_14.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.14 – CPU 利用率表格](img/B21320_06_14.jpg)'
- en: Figure 6.14 – Table for CPU utilization
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.14 – CPU 利用率表格
- en: 'Now, to find the pattern in the data, we can begin by visualizing the data.
    Let’s visualize this data as a linear plot with the timestamp as the x-axis and
    CPU utilization as the y-axis:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为了发现数据中的模式，我们可以开始通过可视化数据。让我们将数据作为线性图进行可视化，以时间戳作为 x 轴，CPU 利用率作为 y 轴：
- en: '![Figure 6.15 – Code to plot CPU utilization](img/B21320_06_15.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.15 – 绘制 CPU 利用率的代码](img/B21320_06_15.jpg)'
- en: Figure 6.15 – Code to plot CPU utilization
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.15 – 绘制 CPU 利用率的代码
- en: Now, the plot is sort of random, being randomly generated and all, so the diagram
    is not necessarily representative of what the actual diagram would look like.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，图表看起来有些随机，因为数据是随机生成的，因此该图表不一定代表实际图表的样子。
- en: '![Figure 6.16 – Diagram plotting CPU utilization over time](img/B21320_06_16.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.16 – 绘制 CPU 利用率随时间变化的图表](img/B21320_06_16.jpg)'
- en: Figure 6.16 – Diagram plotting CPU utilization over time
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.16 – 绘制 CPU 利用率随时间变化的图表
- en: So, this looks random, but that’s fine as it’s simply meant to be a representative
    of a bar graph over time. Let’s refine the dataset a little to create anomalies.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这看起来很随机，但没关系，因为它只是为了代表一个随时间变化的条形图。让我们稍微调整一下数据集，制造一些异常。
- en: 'So, we are going to modify the dataset to have a constant utilization rate
    somewhere in the middle:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所以，我们将修改数据集，使其中间有一个恒定的利用率：
- en: '![Figure 6.17 – Chart for modified dataset](img/B21320_06_17.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.17 – 修改数据集的图表](img/B21320_06_17.jpg)'
- en: Figure 6.17 – Chart for modified dataset
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.17 – 修改数据集的图表
- en: This is a little ridiculous, but I believe it illustrates the point of constant
    uptime. Most systems, when they are stable, do not have this kind of utilization.
    If your service is getting this kind of data, it either indicates a sudden spike
    of success or a DDoS attack. More often than not, it is the latter. So, if you
    find this kind of spike in your monitoring data, it is worth investigating.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点荒谬，但我相信它说明了持续正常运行的重要性。大多数系统在稳定时，并不会有这种利用率。如果你的服务正在产生这种数据，这要么表示成功的突然暴涨，要么是一次DDoS攻击。大多数情况下，是后者。所以，如果你在监控数据中发现这种激增，值得进行调查。
- en: Summary
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have hopefully learned a thing or two about security. I
    also hope that you have figured out how to build your infrastructure in such a
    way that all of the access keys you use are secured.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你希望学到了一些关于安全的知识。我也希望你已经弄清楚了如何搭建基础设施，使得你所使用的所有访问密钥都能得到保障。
- en: In addition to this, you have also learned some methods (among hundreds of thousands)
    that can be used to help secure your infrastructure. You may have also gotten
    some insights into how you can use data to drive the response to incidents and
    also find better insight into certain incidents and their properties.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 除此之外，你还学习了一些方法（成千上万种方法中的一部分），可以用来帮助保护你的基础设施。你可能还获得了一些洞见，了解到如何利用数据来驱动事件响应，并更好地理解某些事件及其特性。
- en: 'So, friends, I hope you enjoyed this chapter, which is all about security.
    I tried my best to explain a couple of concepts to you and I hope you found it
    interesting, at least. But now, it is time to flip the page and move on to the
    next chapter, where we will talk about one of my favorite topics: **automation**.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，朋友们，我希望你们喜欢这一章，毕竟这是关于安全的内容。我尽力向你们解释了几个概念，希望你们至少觉得它有趣。但现在，是时候翻过这一页，进入下一章，我们将讨论我最喜欢的话题之一：**自动化**。
