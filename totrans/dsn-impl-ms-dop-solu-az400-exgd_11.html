<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer166">
<h1 class="chapter-number" id="_idParaDest-274"><a id="_idTextAnchor889"/>11</h1>
<h1 id="_idParaDest-275"><a id="_idTextAnchor890"/>Managing Security and Compliance</h1>
<p>As important as it is to ensure that your application performs the functions it needs to, you also need to ensure it doesn’t do things that it shouldn’t. In the previous chapter, you learned about quality and testing in order to continuously measure whether your application is doing what it is supposed to do. In this chapter, you will learn how to prevent any unwanted behavior. This is the subject of security and compliance. While increasing the flow of value to your end users – by deploying faster and shortened delivery cycles – you will still want to make sure that you are delivering secure and compliant software. In this chapter, you will learn how to address these concerns in your DevOps processes.</p>
<p>To do this, this chapter will start by discussing the perceived trade-off between speed and security, and it will explain how security is not decreased but might even be increased when embracing DevOps. Next, a specific dimension of security is addressed: how to handle secrets such as keys and passwords that your pipeline and application need securely. Following this, code-scanning tools for automatically identifying possible security risks in your application code and your dependencies are discussed. The chapter concludes by discussing how to keep your infrastructure and configuration deployments compliant, and how to detect runtime security risks and threats using Azure Security Center, now called Microsoft Defender for Cloud.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Applying DevOps principles to security and compliance </li>
<li>Working with secrets</li>
<li>Detecting application code vulnerabilities </li>
<li>Working with dependencies</li>
<li>Ensuring infrastructure compliance</li>
<li>Monitoring and detecting runtime security risks and threats </li>
<li>Other tools you can use<a id="_idTextAnchor891"/><a id="_idTextAnchor892"/></li>
</ul>
<h1 id="_idParaDest-276"><a id="_idTextAnchor893"/>Technical requirements</h1>
<p>To experiment with the techniques described in this chapter, you will need one or more of the following:</p>
<ul>
<li>An Azure DevOps project with access to build and release pipelines and the right to install extensions</li>
<li>An Azure subscription (to sign up for Azure, you can go to <a href="https://portal.azure.com">https://portal.azure.com</a> and follow the guide there if you do not have an account yet)</li>
<li>PowerShell with the Azure Az PowerShell module installed (instructions on how to install the PowerShell Azure module can be found at <a href="https://docs.microsoft.com/en-us/powershell/azure/install-az-ps?view=azps-7.3.0">https://docs.microsoft.com/en-us/powershell/azure/install-az-ps?view=azps-7.3.0</a>)</li>
<li>Optionally, subscriptions for WhiteSource Bolt, SonarCloud, or similar products</li>
</ul>
<p><a id="_idTextAnchor894"/>The preceding are all available for free or as a trial, for learning or evaluation purposes.</p>
<h1 id="_idParaDest-277"><a id="_idTextAnchor895"/>Applying DevOps principles to security and compliance</h1>
<p>Concerns about <a id="_idIndexMarker959"/><a id="_idIndexMarker960"/>security and compliance can be a reason for companies to be reluctant to accept a full DevOps mindset as it would hinder their ability to make releases very often. In the past, they used to have fewer releases that were all handed off for security or penetration testing before being deployed to production. This gave them the confidence that they were not shipping software that contained security vulnerabilities.</p>
<p>This practice of fewer releases and having a big final security test before the final release conflicts with a DevOps mindset, and this is where some companies struggle. They are looking for ways to ensure that they are delivering business value to their users with every release, but are not willing to compromise on security to do so. The question is whether this is a fair trade-off. Wouldn’t it be possible to have both speed and security? Might it not actually be the case that releasing faster and more often, in combination with rigorous automation, can help to increase the level of security in software development? To answer this question, it is good to first explore how security is often practiced in non-DevOps environments and how this needs to be changed when adopting DevOps.</p>
<h2 id="_idParaDest-278"><a id="_idTextAnchor896"/><a id="_idTextAnchor897"/><a id="_idTextAnchor898"/>Bringing developers and security engineers together</h2>
<p>In many companies, security engineers are <a id="_idIndexMarker961"/><a id="_idIndexMarker962"/>part of a different department compared to developers. The thought behind this separation is that it is beneficial to have some distance between those who are writing code (that is, the developers) and those who are checking it.</p>
<p>In the past, the same separation often existed between software developers and software testers. However, recent insights have shown that putting developers and testers closer together does not result in unwanted behaviors such as groupthink, only testing what is already known to be working, or trying to cheat the tests by developing only for known test cases. Both experience and research show that the opposite is true. Putting developers and testers together results in products of higher quality. It is for this reason that movements such as Agile recommend that development teams incorporate, among other things, the discipline of testing.</p>
<p>It is by this same <a id="_idIndexMarker963"/><a id="_idIndexMarker964"/>reasoning that the call for integrating security engineering into DevOps development teams is becoming louder. This movement is <a id="_idIndexMarker965"/><a id="_idIndexMarker966"/>often called <em class="italic">DevSecOps</em> or <em class="italic">rugged DevOps</em>. Both movements advocate that using DevOps principles such as shifting left and automating as much as possible can help to increase security. They advocate that pen tests or vulnerability <a id="_idIndexMarker967"/><a id="_idIndexMarker968"/>reviews of applications are no longer done manually, but that they are fully automated as part of the delivery pipeline. This enables automation, faster feedback loops, and continuous delivery and deployment practices.</p>
<p>It is also advocated that shipping software more often can also help to increase security further, for the following reasons:</p>
<ul>
<li>When a reliable mechanism for shipping software automatically is available, any change that addresses a security risk can be deployed swiftly. Being able to react quickly to a new finding is a great security improvement.</li>
<li>Speed itself can be a security measure. If the working of a system changes multiple times a day, it is significantly harder to figure out what its inner workings are at any given time and to misuse them. Applying the principle of immutable deployments and using infrastructure as code ensures that the infrastructure that is running an application is refreshed quite often. This is good mitigation of advanced persistent threats.</li>
</ul>
<p><a id="_idTextAnchor899"/>One of the things this chapter will explore is how to configure delivery pipelines to add security scanning. Please note that running these tools from a pipeline is a different discipline, which ensures that these tools are properly configured and apply the correct policies and requirements. For these activities, a security background and a close collaboration with security engineers are still essential. This is just another area where close collaboration can make a difference. Particularly on the subject of security, collaboration with other disciplines will be necessary – <a id="_idTextAnchor900"/>to automate all security checks and avoid (or minimize) any manual verification processes.</p>
<h2 id="_idParaDest-279"><a id="_idTextAnchor901"/>Security concerns</h2>
<p>The rest of this chapter will introduce a number of security concerns, but it is helpful to realize that some of the previous chapters have introduced security<a id="_idIndexMarker969"/> concerns already. As you already know from software development, security is not just something that you add in one place. Security should be applied everywhere. The following diagram shows different activities surrounding the creation and delivery of software. Next to each activity, the applicable security concerns are shown:</p>
<div>
<div class="IMG---Figure" id="_idContainer155">
<img alt="Figure 11.1 – Software development activities and security concerns " height="510" src="image/B18655_11_01.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.1 – Software development activities and security concerns</p>
<p>Let’s walk through a quick recap of the security concerns at each of these stages:</p>
<ul>
<li><strong class="bold">Branch-master merge</strong>: At this stage, the four-eyes principle<a id="_idIndexMarker970"/> is applied using pull requests. Pull requests allow another engineer to review the changes before they are merged into the main branch. Branch policies are used to make the use of pull requests mandatory, to ensure that code<a id="_idIndexMarker971"/> compiles and that the unit tests run. This was discussed in <a href="B18655_04.xhtml#_idTextAnchor069"><em class="italic">Chapter 4</em></a>, <em class="italic">Everything Starts with Source Control</em>, and <a href="B18655_05.xhtml#_idTextAnchor177"><em class="italic">Chapter 5</em></a>, <em class="italic">Moving to Continuous Integration</em>.</li>
<li><strong class="bold">Build</strong>: During this stage, a security<a id="_idIndexMarker972"/> scan of all source code and third-party dependencies is executed by adding additional tasks to the build pipeline. This prevents security risks from propagating unchecked. We will discuss how to do this in this chapter, in the <em class="italic">Working with secrets</em> sectio<a id="_idTextAnchor902"/>n.</li>
<li><strong class="bold">Release</strong>: During the release, approvers <a id="_idIndexMarker973"/>can be configured. An approver is a user who has to give their approval before the deployment to a specific stage can continue. Additionally, automated release gates are used to ensure (and further enforce) that certain criteria are met before a release can continue. We discussed how to do this in <a href="B18655_06.xhtml#_idTextAnchor330"><em class="italic">Chapter 6</em></a>, <em class="italic">Implementing Continuous Deployment and Release Management</em>.</li>
<li><strong class="bold">Deployment environment (target systems)</strong>: All applications will run in a target environment. This can<a id="_idIndexMarker974"/> be on-premises; however, in this book, the focus is on Azure. For runtime security and compliance concerns, this chapter will introduce Azure Policy and Microsoft Defender for Cloud, which<a id="_idIndexMarker975"/> was formerly known as Azure Security Center.</li>
<li><strong class="bold">Cross-cutting</strong>: All of the preceding points are only useful if there is sufficient<a id="_idIndexMarker976"/> access control within the Azure DevOps environment. While this is not in the scope of this book, it is an important angle to cover. Users should have enough rights to do their work, but they should not be able to make unauthorized changes to policies, builds, and deployment processes. Additionally, proper secret management is needed to keep secrets such as certificates, keys, and passwords secure during all phases of the delivery process. How we can do this is also covered in this chapter.</li>
</ul>
<p>Now, with an understanding of how software and security engineers can come together to work on an application, it is time to address the different aspects of this work <a id="_idTextAnchor903"/>in the following sections. The next section will discuss how to handle se<a id="_idTextAnchor904"/>crets.</p>
<h1 id="_idParaDest-280"><a id="_idTextAnchor905"/>Working with secrets</h1>
<p>An important security element<a id="_idIndexMarker977"/> is the handling of secrets. When deploying an application, there are always secrets involved. Especially when deploying to the cloud – that is, over the internet – handling these access keys in a secure way is very important. Besides the secrets that are necessary for deployment, there are also secrets that need to be inserted into the runtime configuration of an application. A common example is for accessing the database.</p>
<p>In <a href="B18655_08.xhtml#_idTextAnchor542"><em class="italic">Chapter 8</em></a>, <em class="italic">Implement</em> <em class="italic">Infrastructure and Configuration as Code</em>, multiple mechanisms for delivering application configurations were discussed, including <strong class="bold">Azure Resource Manager</strong> (<strong class="bold">ARM</strong>) templates. However, templates require<a id="_idIndexMarker978"/> the input of external secrets, since they cannot be stored in parameter files in source control.</p>
<p class="callout-heading">Important Note</p>
<p class="callout">Secrets should not be stored in source <a id="_idTextAnchor906"/>control.</p>
<p>If secrets cannot be stored in source control, then where should they be stored <a id="_idTextAnchor907"/>instead? Common options include storing secrets in service connections or variable<a id="_idTextAnchor908"/> groups.</p>
<h2 id="_idParaDest-281"><a id="_idTextAnchor909"/>Storing secrets in service connections</h2>
<p>The first group of secrets<a id="_idIndexMarker979"/> that are needed for the deployment of any application<a id="_idIndexMarker980"/> is those secrets that are required for connecting to the target system. No individual person should have access to these secrets, as they are only used during deployments. This is why Azure Pipelines allows you to store them securely in service connections.</p>
<p>A service connection is the abstraction of another system that can be connected to, for executing tasks in Azure Pipelines. Service connections have a specific type – that is, to specify the family of systems they can be used to connect to. There are out-of-the-box service connection types for connecting to Azure, GitHub, Jira, npm, NuGet, and over a dozen more systems. New service connection types can also be added through the Azure DevOps extension mechanism.</p>
<p>Service connections can contain a reference to the location of another system – often, a URL. Next to the location, they can contain an authorization token, a username, and/or a password, depending on the type of service connection. Secrets that are stored inside a service connection can never<a id="_idIndexMarker981"/> be retrieved again, not even<a id="_idIndexMarker982"/> by administrators. Also, whenever any details of the service connection are changed, the secret must be re-entered as well. This is to prevent a previously entered secret from being misused to access another location. These details indicate how service connections are designed to provide a secure location for storing connection credentials.</p>
<p>Service connections can be managed in a central location for each Azure DevOps project. You can create new connections, edit existing ones, alter user permissions, and much more. Practice this by following these steps:</p>
<ol>
<li>To open this view, navigate to <strong class="bold">Project Settings</strong>. A vertical list of various setting options will open.</li>
<li>From the list, click on <strong class="bold">Service connections</strong>. You will be able to view the various connections, as shown in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer156">
<img alt="Figure 11.2 – Creating a new service connection " height="924" src="image/B18655_11_02.jpg" width="1482"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.2 – Creating a new service<a id="_idTextAnchor910"/> connection</p>
<ol>
<li value="3">Now, click on the <strong class="bold">New service connection</strong> button at the top right of the screen if you wish to create new service connections.</li>
<li>To modify<a id="_idIndexMarker983"/> permissions, click on the <strong class="bold">More Actions</strong> submenu<a id="_idIndexMarker984"/> under <strong class="bold">Security</strong>. This will take you to a screen that is similar to the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer157">
<img alt="Figure 11.3 – Service connection security settings  " height="878" src="image/B18655_11_03.jpg" width="1161"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.3 – Service connection securi<a id="_idTextAnchor911"/>ty settings </p>
<p>From the <strong class="bold">Edit and Security</strong> view, you can now carry out these actions:</p>
<ul>
<li>Edit the service connection details.</li>
<li>Alter user permissions.</li>
<li>Restrict permissions.</li>
<li>Add more users or groups and specify, for each, whether they can use or administer the endpoint.</li>
<li>Specify which pipelines can use this servic<a id="_idTextAnchor912"/>e connection.</li>
</ul>
<p>Every pipeline<a id="_idIndexMarker985"/> in the project should not have access to use the service<a id="_idIndexMarker986"/> connection by default. Instead, each pipeline that wants to use the service connection must be authorized by a service connection admini<a id="_idTextAnchor913"/>strator first.</p>
<h2 id="_idParaDest-282"><a id="_idTextAnchor914"/>Storing secrets in variable groups</h2>
<p>There are more secrets involved<a id="_idIndexMarker987"/> in application development than those that are required<a id="_idIndexMarker988"/> to connect to other systems. Examples include license keys, which are required during application compilation, or database usernames and passwords, which need to be passed on to the application after deployment or as part of an ARM template deployment.</p>
<p>These secrets can be stored in pipeline variables or variable groups, which we covered in <a href="B18655_03.xhtml#_idTextAnchor049"><em class="italic">Chapter 3</em></a>, <em class="italic">Getting the Best Out of DevOps Tools</em>, in the <em class="italic">Creating a build definition in Azure DevOps</em> section. Microsoft will store all variables that are marked as secrets securely and make them non-retrievable through the user interface.</p>
<p>However, there might be reasons for not wanting to store secrets in Azure DevOps but in a specialized key store, such as Azure Key Vault, instead. Doing so will provide the extra guarantees that come with<a id="_idIndexMarker989"/> Key Vault and the ability to further control access policies using <strong class="bold">Azure role-based access control</strong> (<strong class="bold">Azure RBAC</strong>) and Key Vault access policies.</p>
<p>When storing secrets in an Azure key vault, they can still be used as a variable group as well, by connecting an empty variable group to the key vault through a service connection, as shown in the following screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer158">
<img alt="Figure 11.4 – Key Vault as the storage for a variable group " height="660" src="image/B18655_11_04.jpg" width="1151"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.4 – Key Vault as the storage for <a id="_idTextAnchor915"/>a variable group</p>
<p>To use a key vault as the storage<a id="_idIndexMarker990"/> for a variable group, perform the following actions:</p>
<ol>
<li value="1">Enable the <strong class="bold">Link secrets from an Azure key vault as variables</strong> second slider to load the secrets from the key vault.</li>
<li>Select an already existing ARM service connection from the drop-down menu or create a service connection with a new managed identity for Azure on the fly by selecting an Azure subscription from the list.</li>
<li>Type in the name of the key vault that the secrets should be loaded into. You can also select one from the drop-down menu. In this instance, only key vaults that are accessible by the selected service connection are shown.</li>
<li>Access for specific users can be configured using <a id="_idTextAnchor916"/>the <strong class="bold">Security</strong> tab.</li>
</ol>
<p>The proper authorizations<a id="_idIndexMarker991"/> for the service connection to Azure and<a id="_idIndexMarker992"/> the key vault can also be automatically created. Please note that both operations will make c<a id="_idTextAnchor917"/>hanges to the Azure security setup, so ensure that these a<a id="_idTextAnchor918"/><a id="_idTextAnchor919"/><a id="_idTextAnchor920"/><a id="_idTextAnchor921"/><a id="_idTextAnchor922"/>re (still) correct.</p>
<h1 id="_idParaDest-283"><a id="_idTextAnchor923"/>Detecting application code vulnerabilities</h1>
<p>The security assessments<a id="_idIndexMarker993"/> that were often conducted at regular intervals in the pre-DevOps era cannot be just left out when moving to a DevOps culture. This means that, instead of leaving them out, they must be conducted in some other way. There are two approaches to doing this.</p>
<p>The first approach is to keep doing pen tests, security reviews, and other security inspections at regular intervals just as before. However, instead of waiting for an okay from the tests before moving to production, code is deployed to production separate from the security assessment(s). This implies that there is an accepted risk that there might be vulnerabilities shipped to production that are found only during the next security scan, which will be addressed in the next release. Using this approach, it is possible to achieve speed, but then it also needs to be accepted that some vulnerabilities might exist for a while.</p>
<p>The second approach relies on making application security scanning part of the regular workflow for committing code to the source code repository. For example, security code reviews do not have to be done per increment or every two months. They can also be done per pull request – before the code gets merged. Now, all of a sudden, you are no longer detecting vulnerabilities but are instead preventing them. The same can be done with security vulnerability scans. They can become<a id="_idIndexMarker994"/> part of the delivery pipeline, or a full nightly <strong class="bold">Quality Assurance</strong> (<strong class="bold">QA</strong>) build that reports back on the quality of devel<a id="_idTextAnchor924"/>opment every morning.</p>
<p>Of course, it is often not as black and white as that, and many companies use a combination of these approaches. They use automated feedback mechanisms to detect whatever they can, make security code reviews part of the pull request workflow, and then combine this with manual pen testing at regular intervals. This way, the speed of delivery is increased, while there is no increase or even a decrease in security risk<a id="_idTextAnchor925"/>s, the latter being the consequence of the speed at which vulnerabilit<a id="_idTextAnchor926"/>ies can be mitigated.</p>
<h2 id="_idParaDest-284"><a id="_idTextAnchor927"/>OWASP Top 10</h2>
<p>When it comes to the security<a id="_idIndexMarker995"/> of web applications, there are several types of security issues<a id="_idIndexMarker996"/> that are both common and responsible for the vast majority of all security issues. These types of issues comprise the OWASP Top 10. This is<a id="_idIndexMarker997"/> a list of the 10 most common types of security issues, published by the <strong class="bold">Open Web Application Security Platform</strong> (<strong class="bold">OWASP</strong>). The list is reviewed every few years but has remained quite stable over the last couple of years.</p>
<p>Most of the errors in the OWASP Top 10<a id="_idIndexMarker998"/> can be prevented by implementing<a id="_idIndexMarker999"/> automated security tests, either by using static code<a id="_idIndexMarker1000"/> analysis for secur<a id="_idTextAnchor928"/>ity vulnerabilities or with dynamic testing using the <strong class="bold">OWASP Ze<a id="_idTextAnchor929"/>d Attack Proxy</strong> (<strong class="bold">OWASP ZAP</strong>).</p>
<h2 id="_idParaDest-285"><a id="_idTextAnchor930"/>Implementing automated vulnerability scanning</h2>
<p>In the previous chapter, in which continuous<a id="_idIndexMarker1001"/> testing was discussed, SonarCloud was introduced<a id="_idIndexMarker1002"/> as a code scanner for technical debt and code quality. Besides assessing the quality of application code, SonarCloud can also be used to scan for security vulnerabilities. In <a href="B18655_10.xhtml#_idTextAnchor760"><em class="italic">Chapter 10</em></a>, <em class="italic">Integrating Continuous Testing</em>, you learned how to add a SonarCloud scan to your pipeline. There are other more specialized tools available as well, which we will discuss in the last section of this chapter.</p>
<p>These tools assess an application based on static tests. They scan the code to identify any risky code. This is called a white-box approach<a id="_idIndexMarker1003"/> because they can see, inspect, and scan<a id="_idIndexMarker1004"/> all of the code. In other words, everything is visible. This is the opposite<a id="_idIndexMarker1005"/> of a black-box approach, where the running application is treated as a closed whole and is only tested by invoking it and observing the responses. One tool th<a id="_idTextAnchor931"/><a id="_idTextAnchor932"/><a id="_idTextAnchor933"/>at can do this is the OWASP ZAP.</p>
<h2 id="_idParaDest-286"><a id="_idTextAnchor934"/>The OWASP ZAP</h2>
<p>The OWASP ZAP<a id="_idIndexMarker1006"/> is a tool that can<a id="_idIndexMarker1007"/> perform the automated pen test of an application. This tool can run in two modes:</p>
<ul>
<li><strong class="bold">A baseline scan</strong>: The baseline scan takes only a few<a id="_idIndexMarker1008"/> minutes, and it is optimized to iterate<a id="_idIndexMarker1009"/> over as many security risks as possible within those few minutes. This makes the baseline scan quick enough to be run early on in the deployment pipeline. It is even possible to run the security scan after every deployment<a id="_idIndexMarker1010"/> to the first test environment, resulting in fast feedback to developers.</li>
<li><strong class="bold">A full active scan</strong>: The full active scan takes more<a id="_idIndexMarker1011"/> time. In this type of scan, the proxy<a id="_idIndexMarker1012"/> will examine every response from the application to identify other URLs that are part of the application, scanning them as well. In this way, the full application is discovered on the fly, using a spidering approach. This type of scan is more complete, but it also takes more time. For this reason, full scans are often run at intervals – for example, every night.</li>
</ul>
<p>The OWASP ZAP tries<a id="_idIndexMarker1013"/> to identify any possible security risks. Some of the most notable risks are SQL injections, JavaScript reflections, and path traversals.</p>
<p>The OWASP ZAP is an application that can be installed on any virtual machine. The disadvantage of this is that the virtual machine is always running, even when there is no scan running. This is more costly, and of course, the virtual machine itself needs to be patched and secured too. More recently, a containerized version of the proxy was also made available. This container can be run in Azure Container Instances, spinning up the proxy only when needed and tearing it down right after execution.</p>
<p>This completes our introduction<a id="_idIndexMarker1014"/> to code-scanning tools and their implementation. With the help of these tools, you can detect vulnerabil<a id="_idTextAnchor935"/>ities in your application and prevent any security issues. The next section will examine h<a id="_idTextAnchor936"/>ow you can scan application dependencies.</p>
<h1 id="_idParaDest-287"><a id="_idTextAnchor937"/>Working with dependencies</h1>
<p>Next to the security risks that application<a id="_idIndexMarker1015"/> code developed in-house poses, there is also a risk associated with components that are reused. Between 50% and 80% of modern application code is not developed in-house but is taken from other parties in the form of packages or dependencies. Some of these might be open source, but this is not necessarily the case. There can also be components that are bought from other development companies or bi<a id="_idTextAnchor938"/>naries taken from galleries such as NuGet.</p>
<p>Dependencies not only pose security risks but also licensing risks. What happens if a team starts using a component that is published under the GPL license for a closed source component? If anyone ever finds out, they can be forced to open source their product, or at least suffer public shame for not using the work of others according to the license.</p>
<p>To mitigate these risks, a number of tools<a id="_idIndexMarker1016"/> can be used to detect and scan all of the dependencies that are used when building an application. One of the tools available to do this is WhiteSource Bolt, which is avai<a id="_idTextAnchor939"/>lable as an e<a id="_idTextAnchor940"/>xtension from the Azure DevOps marketplace.</p>
<h2 id="_idParaDest-288"><a id="_idTextAnchor941"/>Working with WhiteSource Bolt</h2>
<p>To start executing scans<a id="_idIndexMarker1017"/> with WhiteSource Bolt, perform the following actions:</p>
<ol>
<li value="1">Install the WhiteSource Bolt extension from the Azure DevOps marketplace.</li>
<li>Navigate to the <strong class="bold">WhiteSource Bolt</strong> menu under <strong class="bold">Pipelines</strong>.</li>
<li>Sign up and accept the license terms.</li>
<li>Add the <strong class="bold">WhiteSource Bolt</strong> scanning task to build or release definitions, as shown in the following screenshot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer159">
<img alt="Figure 11.5 – A WhiteSource Bolt pipeline task " height="563" src="image/B18655_11_05.jpg" width="1189"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Fig<a id="_idTextAnchor942"/>ure 11.5 – A WhiteSource Bolt pipeline task</p>
<ol>
<li value="5">Once a pipeline with the WhiteSource Bolt task installed has run, the page with the build results will contain an extra tab called <strong class="bold">WhiteSource</strong> that shows similar results, as shown in the following screensh<a id="_idTextAnchor943"/>ot:</li>
</ol>
<div>
<div class="IMG---Figure" id="_idContainer160">
<img alt="Figure 11.6 – The WhiteSource report " height="432" src="image/B18655_11_06.jpg" width="880"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.6 – The WhiteSource report</p>
<p>This completes our discussion on dependency scanning. As mentioned earlier, you can use these tools to your advantage<a id="_idIndexMarker1018"/> to detect and s<a id="_idTextAnchor944"/>can all the dependencies that are used when building an application. In the next sectio<a id="_idTextAnchor945"/>n, infrastructure compliance is introduced.</p>
<h1 id="_idParaDest-289"><a id="_idTextAnchor946"/>Ensuring infrastructure compliance</h1>
<p>Another important topic<a id="_idIndexMarker1019"/> is that of compliance. In many countries or markets, there are sets of rules and policies that must be implemented or adhered to when creating software. A fair share of these policies relates to the infrastructure that the applications are running on. If this infrastructure is deployed and managed on the Azure platform, Azure Policy can be a powerful tool for ensuring that the infrastructure complies with regulations.</p>
<p>In <a href="B18655_08.xhtml#_idTextAnchor542"><em class="italic">Chapter 8</em></a>, <em class="italic">Implement Infrastructure and Configuration as Code</em>, the topic of ARM templates was discussed. ARM templates can be viewed as a technique for describing a complete Azure environment as a JSON array with many objects, each describing one resource in an application’s infrastructure.</p>
<p>Azure Policy allows you to write policies that query this document and the changes that are being made through any of the APIs or ARM templates. Whenever a resource is found that matches the query, it can be prevented from being created or the match can be added to a list of audit results. Azure Policy can remediate or modify insecure configurations to prevent mistakes.</p>
<p>Next to writing custom<a id="_idIndexMarker1020"/> policies, there are many policies readily available for all Azure users. These policies can be used to audit resources that do not comply with best practices or general advice. There are also<a id="_idIndexMarker1021"/> groups of policie<a id="_idTextAnchor947"/>s available, called initiatives, that desc<a id="_idTextAnchor948"/>ribe the applicable parts of market standards.</p>
<h2 id="_idParaDest-290"><a id="_idTextAnchor949"/>Assigning an Azure policy or initiative</h2>
<p>Policies can be assigned<a id="_idIndexMarker1022"/> at different levels within Azure, either<a id="_idIndexMarker1023"/> at the resource group level, subscription<a id="_idIndexMarker1024"/> level, or management group level. This can be done<a id="_idIndexMarker1025"/> through the p<a id="_idTextAnchor950"/>ortal, ARM templates or blueprints, or PowerShell.</p>
<p>To use PowerShell, the following series of commands can be used:</p>
<ol>
<li value="1">To retrieve a reference to the resource group and policy, use the following command:<p class="source-code"><strong class="bold">$rg = Get-AzResourceGroup -Name myResourceGroupName</strong></p><p class="source-code"><strong class="bold">$definition = Get-AzPolicyDefinition | Where-Object {</strong></p><p class="source-code"><strong class="bold">$_.Properties.DisplayName -eq 'Audit VMs that do not use managed disks' }</strong></p></li>
</ol>
<p>The policy that is chosen here is a built-in policy that will audit all virtual machines that do not use managed disks but have custom disks in storage accounts. This policy definition will be used in the command in the following assignment.</p>
<ol>
<li value="2">To assign the policy to the resource group, use the following command:<p class="source-code"><strong class="bold">New-AzPolicyAssignment -Name 'audit-vm-manageddisks' - DisplayName 'Audit VMs without managed disks Assignment' -Scope</strong></p><p class="source-code"><strong class="bold">$rg.ResourceId -PolicyDefinition $definition</strong></p></li>
</ol>
<p>Within 30 minutes of this assignment, the new policy will become active. At this point, a policy evaluation cycle is started, and<a id="_idIndexMarker1026"/> all of the resources within the assignment<a id="_idIndexMarker1027"/> scope will be evaluated<a id="_idIndexMarker1028"/> against the policy. At the time<a id="_idIndexMarker1029"/> of writing, there is no published SLA regarding how long such an evaluation cycle can take. Experience shows that this can be anything between 15 minutes and multiple<a id="_idTextAnchor951"/><a id="_idTextAnchor952"/> hours, depending on the size of the assignment scope.</p>
<h2 id="_idParaDest-291"><a id="_idTextAnchor953"/>Writing an Azure Policy</h2>
<p>While there are many built-in policies <a id="_idIndexMarker1030"/>available, there are many use cases<a id="_idIndexMarker1031"/> in which the creation of custom policies is needed. Just like any other Azure resource, a policy is written as a JSON document. The appropriate ARM resource type is called <strong class="source-inline">policyDefinitions</strong> and has the following structure:</p>
<pre class="source-code">
{
  "name": "string",
  "type": "Microsoft.Authorization/policyDefinitions", 
  "apiVersion": "2019-01-01",
   "properties": { 
    "parameters": {
     "location": { …}
   },
     "displayName": "…",
     "description": "…", 
     "policyRule": {
     "if": {
      "field": "location",
      "equals": "[parameters('location')]",
     },
     "then": {
     "effect": "&lt;audit|deny &gt;"
    }
  }
 }
}</pre>
<p>The <strong class="source-inline">parameters</strong> object can be used to specify <a id="_idIndexMarker1032"/>one or more parameters that need<a id="_idIndexMarker1033"/> to be specified when assigning the policy later on. These parameters follow the same syntax and work the same as the parameters of an ARM template.</p>
<p>The <strong class="source-inline">displayName</strong> and <strong class="source-inline">description</strong> properties can be used to give the policy definition a meaningful name and description for later reference.</p>
<p>The body of the definition contains two elements, as follows:</p>
<ul>
<li><strong class="bold">The</strong> <strong class="source-inline">if</strong> <strong class="bold">statement</strong> is used to specify a query that selects<a id="_idIndexMarker1034"/> the Azure resources that this policy should apply to. There is a specific syntax for writing complex queries in JSON that is detailed in the ARM template reference, which is linked at the end of this chapter.</li>
<li><strong class="bold">The</strong> <strong class="source-inline">then</strong> <strong class="bold">statement</strong> is used to describe the action that needs<a id="_idIndexMarker1035"/> to be taken for any resource that matches the condition. This can be <em class="italic">deny</em> – that is, to automatically deny the creation of any non-compliant resource. Another approach is not to deny non-compliant deployments but rather to audit them. While denying non-compliant deployments is very straightforward in theory, there is good cause for temporarily allowing non-compliant deployments. In such cases, an audit policy can help to keep tabs on these resources. All non-compliant deployments get audit records in their Azure activity log and can be viewed in the Azure portal, under <strong class="bold">Azure Policy</strong> in the <strong class="bold">Compliance</strong> tab. This is <a id="_idTextAnchor954"/><a id="_idTextAnchor955"/>as follows:</li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer161">
<img alt="Figure 11.7 – Azure policy compliance details " height="432" src="image/B18655_11_07.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.7 – Azure policy compliance details</p>
<p>After writing the policy definition, we need<a id="_idIndexMarker1036"/> to create it within<a id="_idIndexMarker1037"/> an Azure subscription for it to be usable. This can either be done through an ARM template or manually within the portal. From a DevOps perspective, writing policies in source control and delivering them through a pipeline as part of an ARM template is the recommended approach. This way, Azure policies are writt<a id="_idTextAnchor956"/>en in the same way as the application and can be reviewed and <a id="_idTextAnchor957"/>automatically deployed to Azure as part of a DevOps pipeline.</p>
<h2 id="_idParaDest-292"><a id="_idTextAnchor958"/>Initiatives</h2>
<p>When working with Azure Policy, many companies<a id="_idIndexMarker1038"/> find that they need to create <a id="_idIndexMarker1039"/>many policies to define all the rules that they want their software developers to adhere to. For this reason, it might be beneficial to group policies. Such a grouping is called an <em class="italic">initiative</em>, and these are defined in JSON as well:</p>
<pre class="source-code">
{
  "name": "string",
  "type": "Microsoft.Authorization/policySetDefinitions",  
  "apiVersion": "2019-01-01",
  "properties": { 
   "displayName": "string", 
   "description":  "string", 
   "parameters": { … }, 
   "policyDefinitions": [
   {
     "policyDefinitionId": "string", 
     "parameters": {}
   }
  ]
 }
}</pre>
<p>The body of an initiative is an array<a id="_idIndexMarker1040"/> of objects. Each object<a id="_idIndexMarker1041"/> must contain a <strong class="source-inline">policyDefinitionId</strong> property and, optionally, an object with <strong class="source-inline">parameters</strong> for the policy. The <strong class="source-inline">policyDefinitionId</strong> property must reference a valid <strong class="source-inline">policyDefinitions</strong> condition through its Azure resource ID. The <strong class="source-inline">parameters</strong> array should specify all of the parameters that the policy requires. Often, this is implemented by having the initiative specify the combined set of all parameters of all polic<a id="_idTextAnchor959"/>ies as an initiative parameter. The parameters for the individual policies <a id="_idTextAnchor960"/>are then specified with a reference to the initiative parameters.</p>
<h2 id="_idParaDest-293"><a id="_idTextAnchor961"/>Fetching audit results</h2>
<p>After assigning a policy<a id="_idIndexMarker1042"/> with the audit effect, the policy will automatically evaluate all of the resources within the scope of the assignment once it is active. There is no guarantee of how long this can take. For new resources, the results of policy evaluation are visible within 15 minutes, but often, this is faster.</p>
<p>Once the results are in, the compliance status for each policy or initiative can be viewed in the portal, resulting in an overview, as shown in the following screenshot:</p>
<div>
<div class="IMG---Figure" id="_idContainer162">
<img alt="Figure 11.8 – Azure Policy compliance status " height="678" src="image/B18655_11_08.jpg" width="1330"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.8 – Azure Policy compliance status</p>
<p>The difference between this report<a id="_idIndexMarker1043"/> and other reports, which are the result of a manual audit, is that this overview is constantly updated to reflect the actual, current state of compliance – it is not a snapshot of compliance at a specific point in time.</p>
<p>An important benefit of this type of compliance is that the rules or policies are applied continuously to all the existing resources and any incoming change. This means that it is possible to ensure that the application environment is always<a id="_idTextAnchor962"/> compliant and always adheres to any rules and policies that apply.</p>
<p>Contrast this with the often-used approach of having security and compliance audits only every other month. Often, this results in environments that are only compliant just before the audit and with their compliance slowly decaying afterward – until it is time for another audit, of course, at which point it rises close to 100% again. At many companies, this results in a compliance graph as follows:</p>
<div>
<div class="IMG---Figure" id="_idContainer163">
<img alt="Figure 11.9 – Compliance level maturity over time " height="905" src="image/B18655_11_09.jpg" width="1343"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.9 – Compliance level maturity over time</p>
<p>With this, we’ve discussed another <a id="_idIndexMarker1044"/>example of how DevOps practices can help increase security and compli<a id="_idTextAnchor963"/>ance – by ensuring infrastructure compliance. In the next section, several alternative tools previously mentioned in this chapter, such as De<a id="_idTextAnchor964"/>fender for Cloud, Sonar Cloud, and WhiteSource, will be discussed.</p>
<h1 id="_idParaDest-294"><a id="_idTextAnchor965"/>Monitoring and detecting runtime security risks  and threats</h1>
<p>All of the security tools<a id="_idIndexMarker1045"/> that have been discussed up to this point<a id="_idIndexMarker1046"/> have focused on preventing shipping vulnerable code to production environments. However, a complete, deployed software solution, including all its support infrastructure, is made out of so much more than just the code. On top of that, there are many interactions with a solution that may be unexpected or unplanned. Monitoring all of this continuously in production is necessary, not just to prevent security concerns but to also detect any security concerns that arise. In Azure, one of the tools available for doing just that is Azure Security Center. This and Azure Defender<a id="_idIndexMarker1047"/> are now called Microsoft Defender for Cloud. </p>
<p>The Defender for Cloud tool provides security posture management and threat protection, and pr<a id="_idTextAnchor966"/>otects workloads running in Azure, hybrid, and other cloud platforms.</p>
<p>Defender for Cloud fills<a id="_idIndexMarker1048"/> the following three needs <a id="_idIndexMarker1049"/>as you manage the security of resources<a id="_idIndexMarker1050"/> and workloads:</p>
<div>
<div class="IMG---Figure" id="_idContainer164">
<img alt="Figure 11.10 – Defender for Cloud " height="469" src="image/B18655_11_10.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.10 – Defender for Cloud</p>
<ul>
<li><strong class="bold">Continuous Assessment</strong> – the solution will provide<a id="_idIndexMarker1051"/> a brief overview of the current security posture.</li>
<li><strong class="bold">Security recommendation</strong> – the solution will harden<a id="_idIndexMarker1052"/> resources and services with the Azure Security Benchmark, and recommend prioritized hardening tasks with detailed remediation steps to improve security posture.</li>
<li><strong class="bold">Defend</strong> – the solution will detect<a id="_idIndexMarker1053"/> and resolve threats to resources, workloads, and services. These alerts appear in the Azure portal and can also be sent via email.</li>
</ul>
<p>The following example shows recommendations to harden security for your resources and improve overall security posture:</p>
<div>
<div class="IMG---Figure" id="_idContainer165">
<img alt="Figure 11.11 – Microsoft Defender recommendations  " height="866" src="image/B18655_11_11.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 11.11 – Microsoft Defender recommendations </p>
<p>There are many more capabilities within<a id="_idIndexMarker1054"/> Microsoft Defender for Cloud, and more are being added on an ongoing basis. When deploying in Azure, this is the place to identify and manage security risks.</p>
<p>This concludes<a id="_idIndexMarker1055"/> our discussion of the various techniques<a id="_idIndexMarker1056"/> for monitoring runtime environments for security risks. The next section looks at several alternative tools for pe<a id="_idTextAnchor967"/><a id="_idTextAnchor968"/><a id="_idTextAnchor969"/>rforming some of the scanning tasks that were mentioned in earlier sections.</p>
<h1 id="_idParaDest-295"><a id="_idTextAnchor970"/>Other tools you can use</h1>
<p>There are many tools available on the market for performing security scans of application code and dependencies. Some examples include WhiteSource, Black Duck, Veracode, and Checkmarx:</p>
<ul>
<li><strong class="bold">WhiteSource</strong> is the paid version of WhiteSource Bolt. It offers<a id="_idIndexMarker1057"/> the same services and more. For example, it doesn’t only report risks at the time of the dependency scan; it also gives you alerts when new risks become available for dependencies<a id="_idIndexMarker1058"/> that were present during the last scan of an application.</li>
<li><strong class="bold">Black Duck</strong> is a product that helps teams to manage<a id="_idIndexMarker1059"/> the risks associated with using open source software. The services it offers are comparable to WhiteSource.</li>
<li><strong class="bold">Veracode</strong> and <strong class="bold">Checkmarx</strong> are code-scanning tools that are used to<a id="_idIndexMarker1060"/> identify vulnerable<a id="_idIndexMarker1061"/> code. Whereas <strong class="bold">SonarQube</strong> checks both code quality and security<a id="_idIndexMarker1062"/> risks, these two products focus solely on security risks. In general, they are better at security scanning, with the downside being that they are more expensive.</li>
<li><strong class="bold">Sonar Cloud</strong> is a hosted environment for SonarQube<a id="_idIndexMarker1063"/> and provides similar functionality as SonarQube.</li>
<li><strong class="bold">CodeQL</strong> is a security scanning tool<a id="_idIndexMarker1064"/> to automate security checks. CodeQL treats code as data that can be queried and performs variant analysis. Variant analysis is a process that uses a known security vulnerability as a seed to find<a id="_idIndexMarker1065"/> similar problems in your code. <strong class="bold">Code scanning</strong> is a feature that allows you to scan code in a GitHub repository to detect security vulnerabilities and coding errors. If code scanning detects a potential vulnerability or error in your code<a id="_idTextAnchor971"/>, GitHub notifies developers and prohibits them from contributing additional issues. </li>
</ul>
<h1 id="_idParaDest-296"><a id="_idTextAnchor972"/>Summary</h1>
<p>In this chapter, you have learned that DevOps and security are not two conflicting goals and that DevOps practices can help you to reinforce security. First, you learned how to handle passwords and other secrets when working with continuous deployment pipelines. Next, you learned how to enhance your pipelines with code and dependency scanning tools, applying the shift-left principle to security as well. Finally, you learned how to use Azure Policy to define constraints and rules for your infrastructure and how you can have these automatically applied, or have non-compliant deployments audited or automatically denied.</p>
<p>With the knowledge you have gained, you are now able to have a conversation within your company about how to address security concerns within your DevOps teams. You can cooperate with security engineers to configure the tools you work with and receive automated feedback on the security implications of your work.</p>
<p>In the next chapter, you will learn about application monitoring. Additionally, you will learn how to mo<a id="_idTextAnchor973"/>nitor whether your application is running smoothly and how to gather runtime metrics.</p>
<h1 id="_idParaDest-297"><a id="_idTextAnchor974"/>Questions</h1>
<p>Here is a list of questions for you to test your knowledge regarding this chapter’s material. You will find the answers in the <em class="italic">Assessments</em> section of the <em class="italic">Appendix</em>:</p>
<ol>
<li value="1">True or false – securing the delivery of software is just a single step in a deployment pipeline.</li>
<li>Which tool can be used for security testing, where a proxy is used to identify valid application URLs and then perform different attacks, such as injections on an application?</li>
<li>True or false – in most modern applications, over 50% of the code base comes from open source libraries.</li>
<li>What are the secure locations for storing the secrets needed during deployment or for running an application? (You can choose more than one answer.)<ol><li>Azure Pipelines variables that are marked as secret</li><li>Azure Key Vault</li><li>Azure DevOps Key Vault</li><li>Azure variable groups</li><li>Azure DevOps secure variables</li><li>Azure DevOps service <a id="_idTextAnchor975"/>connection</li></ol></li>
<li>Which two Azure offerings can be used to detect security risks at runtime?</li>
</ol>
<h1 id="_idParaDest-298"><a id="_idTextAnchor976"/>Further reading</h1>
<ul>
<li>Microsoft Security Code Analysis tool: <a href="https://docs.microsoft.com/en-us/azure/security/develop/security-code-analysis-overview">https://docs.microsoft.com/en-us/azure/security/develop/security-code-analysis-overview</a>.</li>
<li>Code QL analysis engine: <a href="https://codeql.github.com/docs/codeql-overview/about-codeql/">https://codeql.github.com/docs/codeql-overview/about-codeql/</a>.</li>
<li>The OWASP Top 10 and the details of every type of risk can be found at https://owasp.org/www-project-top-ten/2017/.</li>
<li>A detailed walk-through on Azure Policy: <a href="https://docs.microsoft.com/en-us/azure/governance/policy/">https://docs.microsoft.com/en-us/azure/governance/policy/</a>.</li>
<li>WhiteSource Bolt can be found on the Azure DevOps Marketplace at <a href="https://marketplace.visualstudio.com/items?itemName=whitesource.ws-bolt">https://marketplace.visualstudio.com/items?itemName=whitesource.ws-bolt</a>.</li>
<li>A detailed walk-through on using the OWASP ZAP can be found at <a href="https://devblogs.microsoft.com/premier-developer/azure-devops-pipelines-leveraging-owasp-zap-in-the-release-pipeline/">https://devblogs.microsoft.com/premier-developer/azure-devops-pipelines-leveraging-owasp-zap-in-the-release-pipeline/</a>.</li>
<li>More information about the Azure Policy resource types and JSON specifications can be found as part of the ARM reference at <a href="https://docs.microsoft.com/en-us/azure/templates/microsoft.authorization/allversions">https://docs.microsoft.com/en-us/azure/templates/microsoft.authorization/allversions</a>.</li>
<li>More information about the Microsoft Security Code Analysis Extension can be found at <a href="https://secdevtools.azurewebsites.net/helpcredscan.xhtml">https://secdevtools.azurewebsites.net/helpcredscan.xhtml</a>.</li>
<li>More information about WhiteSource Bolt and WhiteSource can be found at <a href="https://bolt.whitesourcesoftware.com/">https://bolt.whitesourcesoftware.com/</a> and https://www.whitesourcesoftware.com.</li>
<li>More information about Black Duck can be found at <a href="https://www.blackducksoftware.com/">https://www.blackducksoftware.com/</a>.</li>
<li>More information about Veracode can be found at <a href="https://www.veracode.com/">https://www.veracode.com/</a>.</li>
<li> More information about Checkmarx can be found at <a href="https://checkmarx.com/">https://checkmarx.com/</a>.</li>
</ul>
</div>
</div>

<div id="sbo-rt-content"><div class="Content" id="_idContainer167">
<h1 id="_idParaDest-299"><a id="_idTextAnchor977"/>Part 4 – Closing the Loop </h1>
<p>DevOps is more than just accelerating the ability to ship quality products to production. Another very important aspect is to observe and measure the usage and other key performance indicators. The insights from the analytics offer critical feedback to shape the future of the product and even help prioritize other quality initiatives necessary to improve the overall reliability of the service. </p>
<p>This part will cover the process of effectively instrumenting applications in order to collect metrics that can be used to better understand application usage and user behavior. Another method for continual learning is to explicitly ask for feedback from within the product so that users get to share valuable suggestions as they use the software. Future improvements to the end user experience can be planned this way.</p>
<p>This part of the book comprises the following chapters:</p>
<ul>
<li><a href="B18655_12.xhtml#_idTextAnchor978"><em class="italic">Chapter 12</em></a>, <em class="italic">Application Monitoring</em></li>
<li><a href="B18655_13.xhtml#_idTextAnchor1071"><em class="italic">Chapter 13</em></a>, <em class="italic">Gathering User Feedback</em></li>
</ul>
</div>
</div></body></html>