- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: Continuous Integration with GitHub Actions and Jenkins
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 GitHub Actions 和 Jenkins 进行持续集成
- en: In the previous chapters, we looked at individual tools that will help us implement
    several aspects of modern DevOps. Now, it’s time to look at how we can combine
    all the tools and concepts we’ve learned about and use them to create a **continuous
    integration** (**CI**) pipeline. First, we will introduce a sample microservices-based
    blogging application, **Blog App**, and then look at some popular open source
    and SaaS-based tools that can get us started quickly with CI. We will begin with
    **GitHub Actions** and then move on to **Jenkins** with **Kaniko**. For every
    tool, we will implement CI for Blog App. We will try to keep the implementations
    cloud-agnostic. Since we’ve used the **GitOps** approach from the beginning, we
    will also use the same here. Finally, we will cover some best practices related
    to build performance.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了几个单独的工具，这些工具将帮助我们实现现代 DevOps 的多个方面。现在，是时候看看如何将我们学到的所有工具和概念结合起来，创建一个**持续集成**（**CI**）流水线了。首先，我们将介绍一个基于微服务的示例博客应用程序——**Blog
    App**，然后看看一些流行的开源和基于 SaaS 的工具，它们可以帮助我们快速启动 CI。我们将从**GitHub Actions**开始，然后转到**Jenkins**与**Kaniko**。对于每个工具，我们都会为
    Blog App 实现 CI。我们会尽量保持实现与云平台无关。由于我们从一开始就使用了**GitOps**方法，因此这里也将使用相同的方法。最后，我们将讨论一些与构建性能相关的最佳实践。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: The importance of automation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化的重要性
- en: Introduction to the sample microservices-based blogging application – Blog App
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 示例基于微服务的博客应用程序介绍——Blog App
- en: Building a CI pipeline with GitHub Actions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GitHub Actions 构建 CI 流水线
- en: Scalable Jenkins on **Kubernetes** with Kaniko
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**Kubernetes**上可扩展的 Jenkins 与 Kaniko
- en: Automating a build with triggers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用触发器自动化构建
- en: Build performance best practices
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建性能的最佳实践
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need to clone the following GitHub repository for
    some of the exercises: [https://github.com/PacktPublishing/Modern-DevOps-Practices-2e](https://github.com/PacktPublishing/Modern-DevOps-Practices-2e).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要克隆以下 GitHub 仓库，以便进行一些练习：[https://github.com/PacktPublishing/Modern-DevOps-Practices-2e](https://github.com/PacktPublishing/Modern-DevOps-Practices-2e)。
- en: 'Run the following command to clone the repository into your home directory,
    and `cd` into the `ch11` directory to access the required resources:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令，将仓库克隆到你的主目录，并`cd`进入`ch11`目录以访问所需的资源：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: So, let’s get started!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧！
- en: The importance of automation
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化的重要性
- en: 'Automation is akin to having an efficient team of robots at your disposal,
    tirelessly handling repetitive, time-consuming, and error-prone tasks. Let’s simplify
    the significance of automation:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化就像是有一支高效的机器人团队在为你工作，毫不疲倦地处理重复性、耗时且容易出错的任务。让我们简化一下自动化的意义：
- en: '**Efficiency**: Think of it as having a magical helper who completes tasks
    in a fraction of the time you would take. Automation accelerates repetitive tasks,
    executing actions, processing data, and running commands far more swiftly than
    humans.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**效率**：把它想象成拥有一个神奇的助手，可以在你完成任务的时间里迅速完成。自动化加速了重复性任务的执行，处理数据和运行命令比人类快得多。'
- en: '**Consistency**: Humans can tire or become distracted, leading to inconsistencies
    in task execution. Automation guarantees that tasks are consistently carried out
    according to predefined rules, every single time.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：人类可能会感到疲倦或分心，导致任务执行的不一致性。自动化保证任务每次都能按照预定规则一致地完成。'
- en: '**Accuracy**: Automation operates without the fatigue or lapses that humans
    may experience. It adheres to instructions with precision, minimizing the likelihood
    of errors that could result in costly repercussions.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**准确性**：自动化操作没有人类可能经历的疲劳或失误。它精确地遵循指令，最小化错误发生的可能性，从而避免可能带来高昂代价的后果。'
- en: '**Scale**: Whether managing one system or a thousand, automation effortlessly
    scales operations without additional human resources.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规模**：无论是管理一个系统还是一千个系统，自动化都能轻松扩展操作，而无需额外的人力资源。'
- en: '**Cost savings**: By reducing the reliance on manual labor, automation yields
    significant cost savings in terms of time and human resources.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节省成本**：通过减少对人工的依赖，自动化在时间和人力资源上带来了显著的成本节省。'
- en: '**Risk reduction**: Certain tasks, such as making data backups and performing
    security checks, are crucial but can be overlooked or skipped by humans. Automation
    ensures these tasks are consistently performed, mitigating risks.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**风险降低**：某些任务，例如数据备份和安全检查，虽然至关重要，但可能被人类忽视或跳过。自动化确保这些任务得到持续执行，从而减少风险。'
- en: '**Faster response**: Automation detects and responds to issues in real time.
    For instance, it can automatically restart a crashed server or adjust resource
    allocation during high traffic, ensuring uninterrupted user experiences.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更快的响应**：自动化能够实时检测并响应问题。例如，它可以自动重启崩溃的服务器，或在高流量期间调整资源分配，确保用户体验不间断。'
- en: '**Resource allocation**: Automating routine tasks liberates human resources
    to concentrate on more strategic and creative endeavors that require critical
    thinking and decision-making.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源分配**：自动化日常任务解放了人力资源，使其可以集中精力处理更具战略性和创造性的工作，这些工作需要批判性思维和决策能力。'
- en: '**Compliance**: Automation enforces and monitors compliance with policies and
    regulations, reducing the potential for legal and regulatory complications.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**合规性**：自动化执行并监控政策和法规的合规性，减少法律和监管方面的潜在问题。'
- en: '**Data analysis**: Automation processes and analyzes vast data volumes rapidly,
    enabling data-driven decision-making and insights.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据分析**：自动化迅速处理和分析大量数据，促进数据驱动的决策和洞察。'
- en: '**24/7 operations**: Automation operates tirelessly, 24/7, guaranteeing continuous
    operations and availability.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**24/7运营**：自动化不知疲倦地全天候工作，确保持续运营和可用性。'
- en: '**Adaptability**: Automation can be reprogrammed to adapt to evolving requirements
    and environments, making it versatile and future-proof.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适应性**：自动化可以重新编程以适应不断变化的需求和环境，使其具有灵活性和面向未来的能力。'
- en: In the tech realm, automation is the bedrock of modern IT operations, spanning
    from automating software deployments to managing cloud resources and configuring
    network devices. It empowers organizations to streamline processes, enhance reliability,
    and remain competitive in the fast-paced digital landscape.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在技术领域，自动化是现代IT运营的基石，涵盖了从自动化软件部署到管理云资源和配置网络设备。它使组织能够简化流程、提高可靠性，并在快速变化的数字化环境中保持竞争力。
- en: In essence, automation resembles an exceedingly efficient, error-free, round-the-clock
    workforce that empowers individuals and organizations to accomplish more with
    less effort.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，自动化类似于一个极其高效、无错误、全天候运作的劳动力，使个人和组织能够以更少的努力完成更多的工作。
- en: To benefit from automation, the project management function is quickly diluting,
    and software development teams are transitioning to Agile teams that deliver in
    Sprints iteratively. Therefore, if there is a new requirement, we don’t wait for
    the entire thing to be signed off before we start doing design, development, QA,
    and so on. Instead, we break software into workable features and deliver them
    in smaller chunks to get value and customer feedback quickly. That means rapid
    software development with less risk of failure.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了从自动化中获益，项目管理职能正在迅速被稀释，软件开发团队正在转型为敏捷团队，以迭代的方式交付Sprint。因此，如果有新的需求，我们不会等到整个需求签署完毕后才开始设计、开发、QA等工作。而是将软件拆解为可操作的功能模块，并以较小的部分交付，以便迅速获得价值和客户反馈。这意味着快速的软件开发，减少失败的风险。
- en: Well, the teams are agile, and they develop software faster. Still, many things
    in the **software development life cycle** (**SDLC**) process are conducted manually,
    such as the fact that some teams generate Code Builds only after completing the
    entire development for that cycle and later find numerous bugs. It becomes difficult
    to trace what caused that problem in the first place.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，团队已经变得更加敏捷，开发软件的速度更快了。但在**软件开发生命周期**（**SDLC**）的过程中，许多任务仍然是手动进行的，比如一些团队只有在完成整个开发周期后才生成代码构建，并在之后发现大量的错误。追踪最初是什么原因导致问题变得非常困难。
- en: What if you could know the cause of a broken Build as soon as you check the
    code into source control? What if you understand that the software fails some
    tests as soon as the builds are executed? Well, that’s CI for you in a nutshell.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在将代码提交到源代码控制系统时，就能知道构建失败的原因怎么办？如果你能在构建执行时立即理解软件未通过某些测试怎么办？嗯，这就是CI的精髓。
- en: CI is a process through which developers frequently check code into a source
    code repository, perhaps several times a day. Automated tooling behind the scenes
    can detect these commits and then build, run some tests, and tell you upfront
    whether the commit has caused any issues. This means that your developers, testers,
    product owners, operations team, and everyone comes to know what has caused the
    problem, and the developer can fix it quickly. This creates a feedback loop in
    software development. We always had a manual feedback loop within software development,
    which was slow. So, either you wait a long time before doing your next task or
    do the wrong thing until you realize it is too late to undo all of that. This
    adds to the rework effort of everything you have done hitherto.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成（CI）是一个过程，开发人员频繁地将代码提交到源代码仓库，可能一天多次。后台的自动化工具可以检测这些提交，然后构建、运行一些测试，并提前告知你提交是否引发了问题。这意味着开发人员、测试人员、产品负责人、运维团队以及所有相关人员都会知道是什么引发了问题，开发人员可以迅速修复。这在软件开发中形成了一个反馈循环。过去我们在软件开发中有一个手动的反馈循环，但它非常缓慢。所以，要么你得等很久才能开始下一任务，要么你做错了事情直到发现时已经为时太晚，无法撤销之前所做的所有工作。这样就增加了之前所有工作的返工量。
- en: As we all know, fixing a bug earlier in the SDLC cycle is cheaper than fixing
    it later. Therefore, CI aims to provide continuous feedback on the code quality
    early in the SDLC. This saves your developers and the organization a lot of time
    and money on fixing bugs they detect when most of your code is tested. Therefore,
    CI helps software development teams develop better software faster.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 众所周知，在SDLC（软件开发生命周期）中，越早修复漏洞成本越低。因此，持续集成（CI）的目标是尽早在SDLC中提供代码质量的持续反馈。这可以为开发人员和组织节省大量时间和金钱，避免在大部分代码已经经过测试时还需要修复发现的漏洞。因此，CI帮助软件开发团队更快地开发出更好的软件。
- en: Since we’ve mentioned Agile, let’s briefly discuss how it compares with DevOps.
    Agile is a way of working and is silent on the tools, techniques, and automation
    required to achieve it. DevOps is an extension of the Agile mindset and helps
    you implement it effectively. DevOps focuses heavily on automation and looks at
    avoiding manual work wherever possible. It also encourages software delivery automation
    and seeks to amplify or replace traditional tools and frameworks. With the advent
    of modern DevOps, specific tools, techniques, and best practices simplify the
    life of a developer, QA, and operator. Modern public cloud platforms and DevOps
    provide teams with ready-to-use dynamic infrastructure that helps businesses reduce
    the time to market and build scalable, elastic, high-performing infrastructure
    to keep enterprises live with minimal downtime.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们提到了敏捷开发，接下来简要讨论一下它与DevOps的比较。敏捷是一种工作方式，对于实现敏捷所需的工具、技术和自动化并未明确说明。DevOps是敏捷思维的延伸，帮助你有效地实施敏捷。DevOps高度关注自动化，力求在可能的情况下避免手动操作。它还鼓励软件交付的自动化，旨在加强或替代传统工具和框架。随着现代DevOps的出现，特定的工具、技术和最佳实践简化了开发人员、质量保证人员和运维人员的工作。现代公共云平台和DevOps为团队提供了即用型的动态基础设施，帮助企业减少上市时间，并构建可扩展、弹性强、性能优越的基础设施，确保企业的系统在最小的停机时间内持续运行。
- en: When introducing modern DevOps in the first chapter, we discussed that it usually
    applies to modern cloud-native applications. I’ve built an example microservices-based
    Blog App to demonstrate this. We will use this application in this and future
    chapters of this book to ensure seamless development and delivery of this application
    using modern DevOps tools and practices. We’ll look at the sample application
    in the next section.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章介绍现代DevOps时，我们提到它通常应用于现代云原生应用程序。为了演示这一点，我构建了一个基于微服务的博客应用示例。我们将在本书的这一章和未来的章节中使用该应用，以确保使用现代DevOps工具和实践无缝开发和交付该应用。接下来我们将查看这个示例应用。
- en: Introduction to the sample microservices-based blogging application – Blog App
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务架构博客应用介绍 – 博客应用
- en: Blog App is a sample modern microservices-based blogging web application that
    allows users to create, manage, and interact with blog posts. It caters to both
    authors and readers. Users can sign up to this platform using their email addresses
    and start writing blog posts. Readers can publicly view all blog posts created
    by several authors, and logged-in users can also provide reviews and ratings.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 博客应用是一个基于现代微服务架构的博客Web应用，允许用户创建、管理和互动博客帖子。它既适用于作者，也适用于读者。用户可以使用他们的电子邮件地址注册该平台，并开始写博客帖子。读者可以公开查看由多个作者创建的所有博客帖子，登录用户还可以提供评论和评分。
- en: 'The application is written in a popular Python-based web framework called **Flask**
    and uses **MongoDB** as the database. The application is split into several microservices
    for user, post, review, and rating management. There is a separate frontend microservice
    that allows for user interaction. Let’s look at each microservice:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用是用一个流行的基于Python的Web框架**Flask**编写的，并使用**MongoDB**作为数据库。该应用被拆分成多个微服务，用于用户、帖子、评论和评分管理。还有一个独立的前端微服务，供用户进行交互。让我们来看看每个微服务：
- en: '**User Management**: The User Management microservice provides endpoints to
    create a user account, update the profile (name and password), and delete a user
    account.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户管理**：用户管理微服务提供创建用户账户、更新个人资料（姓名和密码）和删除用户账户的接口。'
- en: '**Posts Management**: The Posts Management microservice provides endpoints
    to create, list, get, update, and delete posts.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**帖子管理**：帖子管理微服务提供创建、列出、获取、更新和删除帖子的接口。'
- en: '**Reviews Management**: The Reviews Management microservice allows users to
    add reviews on posts and update and delete them. Internally, it interacts with
    the Ratings Management microservice to manage the ratings provided, along with
    the reviews.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**评论管理**：评论管理微服务允许用户在帖子上添加评论，并对其进行更新和删除。它在内部与评分管理微服务交互，以管理与评论一起提供的评分。'
- en: '**Ratings Management**: The Ratings Management microservice manages ratings
    for posts associated with a particular review. This microservice is called from
    the Reviews Management microservice internally and is not exposed to the Frontend
    microservice.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**评分管理**：评分管理微服务管理与特定评论相关联的帖子评分。该微服务在内部由评论管理微服务调用，并不会暴露给前端微服务。'
- en: '**Frontend**: The Frontend microservice is a Python Flask user interface application
    built using **Bootstrap**, which provides users with a rich and interactive user
    interface. It allows users to sign up, log in, view, and navigate between posts,
    edit their posts, add and update reviews, and manage their profiles. The microservice
    interacts with the backend microservices seamlessly using HTTP requests.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前端**：前端微服务是一个基于**Bootstrap**构建的Python Flask用户界面应用，为用户提供丰富的交互式界面。它允许用户注册、登录、查看帖子并在帖子之间导航、编辑帖子、添加和更新评论以及管理个人资料。该微服务通过HTTP请求与后端微服务无缝交互。'
- en: The **users**, **posts**, **reviews**, and **ratings** microservices interact
    with **MongoDB** as the database.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**用户**、**帖子**、**评论**和**评分**微服务与**MongoDB**数据库进行交互。'
- en: 'The following service diagram shows the interactions graphically:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了各服务之间的交互关系：
- en: '![Figure 11.1 – Blog App services and interactions](img/B19877_11__1.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图11.1 – 博客应用服务与交互](img/B19877_11__1.jpg)'
- en: Figure 11.1 – Blog App services and interactions
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.1 – 博客应用服务与交互
- en: As we can see, the individual microservices are fairly decoupled from each other
    and, therefore, can independently scale. It is also robust because the other parts
    of the application will work if a particular microservice is not working. The
    individual microservices can be independently developed and deployed as separate
    components, adding to the application’s flexibility and maintainability. This
    application is an excellent example of leveraging microservices to build a modern,
    feature-rich web application.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，单个微服务之间相互解耦，因此可以独立扩展。它也很健壮，因为如果某个特定微服务出现故障，应用的其他部分仍然可以继续工作。各个微服务可以作为独立的组件进行开发和部署，从而增强了应用的灵活性和可维护性。这个应用是利用微服务构建现代功能丰富的Web应用的一个优秀示例。
- en: Now, let’s implement CI for this application. To implement CI, we will need
    a CI tool. We’ll look at some of the popular tools and the options you have in
    the next section.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为这个应用实现持续集成（CI）。为了实现CI，我们需要一个CI工具。在接下来的部分中，我们将介绍一些流行的工具以及你可以选择的选项。
- en: Building a CI pipeline with GitHub Actions
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GitHub Actions构建CI管道
- en: '**GitHub Actions** is a SaaS-based tool that comes with **GitHub**. So, when
    you create your GitHub repository, you get access to this service out of the box.
    Therefore, GitHub Actions is one of the best tools for people new to CI/CD and
    who want to get started quickly. GitHub Actions helps you automate tasks, build,
    test, and deploy your code, and even streamline your workflow, making your life
    as a developer much easier.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**GitHub Actions** 是一款基于SaaS的工具，随**GitHub**提供。因此，当你创建GitHub仓库时，开箱即用即可访问此服务。因此，GitHub
    Actions是适合CI/CD新手的最佳工具之一，特别适合那些想要快速入门的人。GitHub Actions可以帮助你自动化任务、构建、测试和部署代码，甚至简化工作流程，极大地简化开发者的工作。'
- en: 'Here’s what GitHub Actions can do for you:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是GitHub Actions能为你做的事情：
- en: '**CI**: GitHub Actions can automatically build and test your code whenever
    you push changes to your repository. This ensures that your code remains error-free
    and ready for deployment.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CI**：GitHub Actions可以在你推送更改到仓库时自动构建和测试代码。这确保了你的代码始终无误，并准备好进行部署。'
- en: '**CD**: You can use GitHub Actions to deploy your application to various hosting
    platforms, such as AWS, Azure, and GCP. This allows you to deliver updates to
    your users quickly and efficiently.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CD**：你可以使用GitHub Actions将应用程序部署到各种托管平台，如AWS、Azure和GCP。这使你能够快速高效地向用户交付更新。'
- en: '**Workflow automation**: You can create custom workflows using GitHub Actions
    to automate repetitive tasks in your development process. For example, you can
    automatically label and assign issues, trigger builds on specific events, or send
    notifications to your team.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作流自动化**：你可以使用GitHub Actions创建自定义工作流，自动化开发过程中的重复任务。例如，你可以自动标记和分配问题，在特定事件触发时启动构建，或向团队发送通知。'
- en: '**Custom scripts**: GitHub Actions allows you to run custom scripts and commands,
    giving you full control over your automation tasks. Whether you need to compile
    code, run tests, or execute deployment scripts, GitHub Actions can handle it.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义脚本**：GitHub Actions允许你运行自定义脚本和命令，完全控制自动化任务。无论是需要编译代码、运行测试还是执行部署脚本，GitHub
    Actions都能处理。'
- en: '`npm` to deploying to popular cloud providers. You can easily incorporate these
    actions into your workflow.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`npm`用于部署到流行的云提供商。你可以轻松地将这些操作集成到你的工作流中。'
- en: '**Scheduled jobs**: You can schedule actions to run at specific times or intervals.
    This is handy for tasks such as generating reports, sending reminders, or performing
    maintenance during non-peak hours.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定时任务**：你可以安排在特定时间或间隔运行某些操作。这对于生成报告、发送提醒或在非高峰时段进行维护等任务非常有用。'
- en: '**Multi-platform support**: GitHub Actions supports various programming languages,
    operating systems, and cloud environments, which means you can build and deploy
    applications for different platforms with ease.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多平台支持**：GitHub Actions支持多种编程语言、操作系统和云环境，这意味着你可以轻松构建和部署面向不同平台的应用程序。'
- en: '**Integration**: GitHub Actions seamlessly integrates with your GitHub repositories,
    making it a natural extension of your development environment. You can define
    workflows by using YAML files directly in your repository.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成**：GitHub Actions与GitHub仓库无缝集成，使其成为开发环境的自然扩展。你可以直接在仓库中使用YAML文件定义工作流。'
- en: GitHub Actions revolutionizes the way developers work by automating routine
    tasks, ensuring code quality, and streamlining the SDLC. It’s a valuable tool
    for teams and individual developers looking to enhance productivity and maintain
    high-quality code.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions通过自动化日常任务、确保代码质量并简化软件开发生命周期（SDLC），彻底改变了开发人员的工作方式。它是提升生产力和保持高质量代码的团队和个人开发者的宝贵工具。
- en: Now, let’s create a CI pipeline for our sample Blog App. Blog App consists of
    multiple microservices, and each microservice runs on an individual **Docker**
    container. We also have unit tests written for each microservice, which we can
    run to verify the code changes. If the tests pass, the build will pass; otherwise,
    it will fail.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为我们的示例博客应用创建一个 CI 管道。博客应用由多个微服务组成，每个微服务都运行在单独的**Docker**容器中。我们还为每个微服务编写了单元测试，可以运行这些测试来验证代码更改。如果测试通过，构建就会通过；否则，它将失败。
- en: 'To access the resources for this section, `cd` into the following directory:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本节的资源，请`cd`进入以下目录：
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This directory contains multiple microservices and is structured as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 该目录包含多个微服务，其结构如下：
- en: '[PRE2]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `frontend` directory contains files for the `app.py` (the Flask application
    code), `app.test.py` (the unit tests for the Flask application), `requirements.txt`
    (which contains all Python modules required by the app), and `Dockerfile`. It
    also includes a few other directories catering to the user interface elements
    of this app.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`frontend`目录包含`app.py`（Flask应用程序代码）、`app.test.py`（Flask应用程序的单元测试）、`requirements.txt`（包含应用所需的所有Python模块）和`Dockerfile`。它还包括一些其他目录，供此应用的用户界面元素使用。'
- en: The `app.py`, `app.test.py`, `requirements.txt`, and `Dockerfile` files.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`app.py`、`app.test.py`、`requirements.txt`和`Dockerfile`文件。'
- en: 'So, let’s start by switching to the `posts` directory:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们从切换到`posts`目录开始：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As we know that Docker is inherently CI-compliant, we can run the tests using
    `Dockerfile` itself. Let’s investigate the Dockerfile of the posts service:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道Docker本身符合CI标准，我们可以使用`Dockerfile`本身来运行测试。让我们来研究一下posts服务的Dockerfile：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This `Dockerfile` starts with the `python:3.7-alpine` base image, installs the
    requirements, and copies the code into the working directory. It runs the `app.test.py`
    unit test to check whether the code would work if we deploy it. Finally, the `CMD`
    command defines a `flask run` command to run when we launch the container.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Dockerfile`以`python:3.7-alpine`基础镜像开始，安装依赖，并将代码复制到工作目录。它运行`app.test.py`单元测试，检查如果我们部署代码是否能正常工作。最后，`CMD`命令定义了一个`flask
    run`命令，当我们启动容器时执行。
- en: 'Let’s build our `Dockerfile` and see what we get:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建我们的`Dockerfile`，看看会得到什么：
- en: '[PRE5]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we can see, it built the container, executed a test on it, and responded
    with `Ran 8 tests in 0.026s` and an `OK` message. Therefore, we could use `Dockerfile`
    to build and test this app. We used the `--progress=plain` argument with the `docker
    build` command. This is because we wanted to see the stepwise output of the logs
    rather than Docker merging progress into a single message (this is now a default
    behavior).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，它构建了容器，执行了测试，并返回了`Ran 8 tests in 0.026s`和`OK`消息。因此，我们可以使用`Dockerfile`来构建和测试这个应用程序。我们在`docker
    build`命令中使用了`--progress=plain`参数。这是因为我们希望看到逐步的日志输出，而不是Docker将进度合并为一条消息（这现在是默认行为）。
- en: Now, let’s look at GitHub Actions and how we can automate this step.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看GitHub Actions，以及我们如何自动化这一步骤。
- en: Creating a GitHub repository
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个GitHub仓库
- en: Before we can use GitHub Actions, we need to create a GitHub repository. As
    we know that each microservice can be independently developed, we will place all
    of them in separate Git repositories. For this exercise, we will focus only on
    the **posts** microservice and leave the rest to you as an exercise.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够使用GitHub Actions之前，我们需要创建一个GitHub仓库。因为我们知道每个微服务可以独立开发，所以我们将它们放在单独的Git仓库中。对于本次练习，我们将只关注**posts**微服务，其余部分留给你作为练习。
- en: To do so, go to [https://github.com/new](https://github.com/new) and create
    a new repository. Give it an appropriate name. For this exercise, I am going to
    use `mdo-posts`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，请访问[https://github.com/new](https://github.com/new)并创建一个新的仓库。为其起一个合适的名字。对于本次练习，我将使用`mdo-posts`。
- en: 'Once you’ve created it, clone the repository by using the following command:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完成后，使用以下命令克隆仓库：
- en: '[PRE6]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, change the directory into the repository directory and copy the `app.py`,
    `app.test.py`, `requirements.txt`, and `Dockerfile` files into the repository’s
    directory using the following commands:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下命令将目录切换到仓库目录，并将`app.py`、`app.test.py`、`requirements.txt`和`Dockerfile`文件复制到仓库目录中：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, we need to create a GitHub Actions workflow file. We’ll do this in the
    next section.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建一个GitHub Actions工作流文件。我们将在下一部分进行操作。
- en: Creating a GitHub Actions workflow
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建GitHub Actions工作流
- en: 'A GitHub Actions workflow is a simple YAML file that contains the build steps.
    We must create this workflow in the `.github/workflows` directory within the repository.
    We can do this using the following command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub Actions工作流是一个简单的YAML文件，包含了构建步骤。我们必须在仓库的`.github/workflows`目录下创建此工作流。我们可以使用以下命令执行此操作：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will use the following GitHub Actions workflow file, `build.yaml`, for this
    exercise:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下GitHub Actions工作流文件`build.yaml`进行本次练习：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This file comprises the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件包含以下内容：
- en: '`name`: The workflow’s name – `Build and Test App` in this case.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：工作流的名称——在这种情况下是`Build and Test App`。'
- en: '`on`: This describes when this workflow will run. In this case, it will run
    if a `push` or `pull` request is sent on the `main` branch.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on`：这描述了此工作流何时运行。在这种情况下，如果在`main`分支上发送了`push`或`pull`请求，它将会运行。'
- en: '`jobs`: A GitHub Actions workflow contains one or more jobs that run in parallel
    by default. This attribute includes all jobs.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jobs`：GitHub Actions工作流包含一个或多个作业，默认情况下，它们会并行运行。此属性包括所有作业。'
- en: '`jobs.build`: This is a job that does the container build.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jobs.build`：这是一个执行容器构建的作业。'
- en: '`jobs.build.runs-on`: This describes where the build job will run. We’ve specified
    `ubuntu-latest` here. This means that this job will run on an Ubuntu VM.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jobs.build.runs-on`：这描述了构建作业将在哪个环境中运行。我们在这里指定了`ubuntu-latest`。这意味着该作业将在Ubuntu虚拟机上运行。'
- en: '`jobs.build.steps`: This consists of the steps that run sequentially within
    the job. The build job consists of four build steps: `checkout`, which will check
    out the code from your repository; `login`, which will log in to Docker Hub; `build`,
    which will run a Docker build on your code; and `push`, which will push your Docker
    image to **Docker Hub**. Note that we tag the image with the Git commit SHA. This
    relates the build with the commit, making Git the single source of truth.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jobs.build.steps`：这包含在作业中按顺序运行的步骤。构建作业由四个构建步骤组成：`checkout`，它将从您的仓库检出代码；`login`，它将登录
    Docker Hub；`build`，它将在您的代码上运行 Docker 构建；以及 `push`，它将您的 Docker 镜像推送到 **Docker Hub**。请注意，我们使用
    Git 提交的 SHA 来标记镜像。这将构建与提交关联，使 Git 成为唯一的真实来源。'
- en: '`jobs.build.steps.uses`: This is the first step and describes an action you
    will run as a part of your job. Actions are reusable pieces of code that you can
    execute in your pipeline. In this case, it runs the `checkout` action. It checks
    out the code from the current branch where the action is triggered.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jobs.build.steps.uses`：这是第一步，描述了您将在作业中运行的一个 action。Actions 是可以在管道中执行的可重用代码块。在此情况下，它运行
    `checkout` action。它将从当前触发 action 的分支中检出代码。'
- en: Tip
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Always use a version with your actions. This will prevent your build from breaking
    if a later version is incompatible with your pipeline.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 始终使用带版本的 actions。这将防止您的构建因后续版本与管道不兼容而中断。
- en: '`jobs.build.steps.name`: This is the name of your build step.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jobs.build.steps.name`：这是您构建步骤的名称。'
- en: '`jobs.build.steps.id`: This is the unique identifier of your build step.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jobs.build.steps.id`：这是您构建步骤的唯一标识符。'
- en: '`jobs.build.steps.run`: This is the command it executes as part of the build
    step.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jobs.build.steps.run`：这是它在构建步骤中执行的命令。'
- en: The workflow also contains variables within `${{ }}`. We can define multiple
    variables within the workflow and use them in the subsequent steps. In this case,
    we’ve used two variables – `${{ secrets.DOCKER_USER }}` and `${{ secrets.DOCKER_PASSWORD
    }}`. These variables are sourced from **GitHub secrets**.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 工作流中还包含 `${{ }}` 内的变量。我们可以在工作流中定义多个变量，并在后续步骤中使用它们。在此案例中，我们使用了两个变量 – `${{ secrets.DOCKER_USER
    }}` 和 `${{ secrets.DOCKER_PASSWORD }}`。这些变量来自 **GitHub secrets**。
- en: Tip
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: It is best practice to use GitHub secrets to store sensitive information. Never
    store these details directly in the repository with code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是使用 GitHub secrets 来存储敏感信息。切勿将这些详细信息直接存储在包含代码的仓库中。
- en: 'You must define two secrets within your repository using the following URL:
    `https://github.com/<your_user>/mdo-posts/settings/secrets/actions`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须使用以下 URL 在仓库中定义两个 secrets：`https://github.com/<your_user>/mdo-posts/settings/secrets/actions`。
- en: 'Define two secrets within the repository:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在仓库中定义两个 secrets：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let’s move this `build.yml` file to the `workflows` directory by using
    the following command:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过以下命令将 `build.yml` 文件移到 `workflows` 目录：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we’re ready to push this code to GitHub. Run the following commands to
    commit and push the changes to your GitHub repository:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备将代码推送到 GitHub。运行以下命令将更改提交并推送到您的 GitHub 仓库：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, go to the `https://github.com/<your_user>/mdo-posts/actions`. You should
    see something similar to the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，前往 `https://github.com/<your_user>/mdo-posts/actions`。您应该会看到类似以下内容：
- en: '![Figure 11.2 – GitHub Actions](img/B19877_11__2.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.2 – GitHub Actions](img/B19877_11__2.jpg)'
- en: Figure 11.2 – GitHub Actions
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – GitHub Actions
- en: 'As we can see, GitHub has run a build using our workflow file, and it has built
    the code and pushed the image to **Docker Hub**. Upon visiting your Docker Hub
    account, you should see your image present in your account:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，GitHub 使用我们的工作流文件运行了一个构建，并且已经构建了代码并将镜像推送到**Docker Hub**。访问您的 Docker Hub
    账户时，您应该能在账户中看到您的镜像：
- en: '![Figure 11.3 – Docker Hub image](img/B19877_11__3.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.3 – Docker Hub 镜像](img/B19877_11__3.jpg)'
- en: Figure 11.3 – Docker Hub image
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – Docker Hub 镜像
- en: Now, let’s try to break our code somehow. Let’s suppose that someone from your
    team changed the `app.py` code, and instead of returning `post` in the `create_post`
    response, it started returning `pos`. Let’s see what would happen in that scenario.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试以某种方式破坏我们的代码。假设您的团队中的某个人更改了 `app.py` 代码，并且在 `create_post` 响应中不再返回 `post`，而是返回
    `pos`。我们来看看在这种情况下会发生什么。
- en: 'Make the following changes to the `create_post` function in the `app.py` file:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `app.py` 文件中的 `create_post` 函数进行以下更改：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, commit and push the code to GitHub using the following commands:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用以下命令将代码提交并推送到 GitHub：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, go to GitHub Actions and find the latest build. You will see that the
    build will error out and give the following output:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，前往 GitHub Actions，查找最新的构建。你将看到该构建会出错，并给出以下输出：
- en: '![Figure 11.4 – GitHub Actions – build failure](img/B19877_11__4.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.4 – GitHub Actions – 构建失败](img/B19877_11__4.jpg)'
- en: Figure 11.4 – GitHub Actions – build failure
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – GitHub Actions – 构建失败
- en: 'As we can see, the `app.test.py` execution failed. This is because of a test
    case failure with `AssertionError: ''post'' not found in {''pos'': ''60458fb603c395f9a81c9f4a''}`.
    As the expected `post` key was not found in the output, `{''pos'': ''60458fb603c395f9a81c9f4a''}`,
    the test case failed, as shown in the following screenshot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '正如我们所看到的，`app.test.py` 执行失败。这是由于测试用例失败，错误信息为 `AssertionError: ''post'' not
    found in {''pos'': ''60458fb603c395f9a81c9f4a''}`。由于预期的 `post` 键未在输出 `{''pos'':
    ''60458fb603c395f9a81c9f4a''}` 中找到，测试用例失败，正如下面的截图所示：'
- en: '![Figure 11.5 – GitHub Actions – test failure](img/B19877_11__5.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5 – GitHub Actions – 测试失败](img/B19877_11__5.jpg)'
- en: Figure 11.5 – GitHub Actions – test failure
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5 – GitHub Actions – 测试失败
- en: We uncovered the error when someone pushed the buggy code to the Git repository.
    Are you able to see the benefits of CI already?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现错误是在有人将有问题的代码推送到 Git 仓库时发生的。你现在能看到 CI 的好处了吗？
- en: Now, let’s fix the code and commit the code again.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修复代码并再次提交代码。
- en: 'Modify the `create_post` function of `app.py` so that it looks as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 `app.py` 中的 `create_post` 函数，使其如下所示：
- en: '[PRE15]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then, `commit` and `push` the code to GitHub using the following commands:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下命令将代码 `commit` 并 `push` 到 GitHub：
- en: '[PRE16]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This time, the build will be successful:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，构建将成功：
- en: '![Figure 11.6 – GitHub Actions – build success](img/B19877_11__6.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.6 – GitHub Actions – 构建成功](img/B19877_11__6.jpg)'
- en: Figure 11.6 – GitHub Actions – build success
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 – GitHub Actions – 构建成功
- en: Did you see how simple this was? We got started with CI quickly and implemented
    GitOps behind the scenes since the config file required to build and test the
    code also resided with the application code.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到这有多简单吗？我们很快就开始了 CI，并在幕后实现了 GitOps，因为构建和测试代码所需的配置文件也与应用程序代码一起存放。
- en: As an exercise, repeat the same process for the **reviews**, **users**, **ratings**,
    and **frontend** microservices. You can play around with them to understand how
    it works.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，针对 **reviews**、**users**、**ratings** 和 **frontend** 微服务重复相同的过程。你可以通过操作它们来理解其工作原理。
- en: 'Not everyone uses GitHub, so the SaaS offering might not be an option for them.
    Therefore, in the next section, we’ll look at the most popular open source CI
    tool: Jenkins.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是每个人都使用 GitHub，因此对于他们来说，SaaS 提供的服务可能不是一个选择。因此，在下一节中，我们将看看最流行的开源 CI 工具：Jenkins。
- en: Scalable Jenkins on Kubernetes with Kaniko
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Kubernetes 上可扩展的 Jenkins 与 Kaniko
- en: 'Imagine you’re running a workshop where you build all sorts of machines. In
    this workshop, you have a magical conveyor belt called Jenkins for assembling
    these machines. But to make your workshop even more efficient and adaptable, you’ve
    got a team of tiny robot workers called Kaniko that assist in constructing the
    individual parts of each machine. Let’s draw parallels between this workshop analogy
    and the technology world:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你正在运行一个车间，在这里你构建各种各样的机器。在这个车间里，你有一个神奇的传送带，叫做 Jenkins，用来组装这些机器。但是，为了让你的车间更加高效和适应性更强，你还有一支叫做
    Kaniko 的小型机器人团队，帮助构建每台机器的各个部件。让我们把这个车间类比与技术世界进行对比：
- en: '**Scalable Jenkins**: Jenkins is a widely used automation server that helps
    automate various tasks, particularly those related to building, testing, and deploying
    software. “Scalable Jenkins” means configuring Jenkins in a way that allows it
    to efficiently handle a growing workload, much like having a spacious workshop
    capable of producing numerous machines.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展的 Jenkins**：Jenkins 是一个广泛使用的自动化服务器，有助于自动化各种任务，特别是与构建、测试和部署软件相关的任务。“可扩展的
    Jenkins”意味着以一种配置 Jenkins 的方式，使其能够高效处理日益增长的工作负载，就像一个宽敞的车间，能够生产大量的机器。'
- en: '**Kubernetes**: Think of Kubernetes as the workshop manager. It’s an orchestration
    platform that automates the process of deploying, scaling, and managing containerized
    applications. Kubernetes ensures that Jenkins and the team of tiny robots (Kaniko)
    work seamlessly together and can adapt to changing demands.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes**：将 Kubernetes 想象成车间经理。它是一个编排平台，自动化部署、扩展和管理容器化应用程序的过程。Kubernetes
    确保 Jenkins 和一队小型机器人（Kaniko）无缝协作，并能适应变化的需求。'
- en: '**Kaniko**: Kaniko is equivalent to your team of miniature robot workers. In
    the context of containerization, Kaniko is a tool that aids in building container
    images, which are akin to the individual parts of your machines. What makes Kaniko
    special is that it can do this without needing elevated access to the Docker daemon.
    Unlike traditional container builders, Kaniko doesn’t require special privileges,
    making it a more secure choice for constructing containers, especially within
    a Kubernetes environment.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kaniko**：Kaniko相当于你的微型机器人团队。在容器化的背景下，Kaniko是一个帮助构建容器镜像的工具，就像机器的各个部件一样。Kaniko的特别之处在于，它无需对Docker守护进程有高级访问权限就能完成这一任务。与传统的容器构建工具不同，Kaniko不需要特权，使得它成为构建容器时，尤其是在Kubernetes环境中，更安全的选择。'
- en: 'Now, let’s combine the three tools and see what we can achieve:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这三种工具结合起来，看看我们能取得什么成果：
- en: '**Building containers at scale**: Your workshop can manufacture multiple machines
    simultaneously, thanks to Jenkins and the tiny robots. Similarly, with Jenkins
    on Kubernetes using Kaniko, you can efficiently and concurrently create container
    images. This ability to scale is crucial in modern application development, where
    containerization plays a pivotal role.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大规模构建容器**：你的车间可以同时制造多个机器，这要归功于Jenkins和小型机器人。同样地，借助基于Kubernetes的Jenkins与Kaniko，你可以高效并行地构建容器镜像。这种可扩展性在现代应用程序开发中至关重要，因为容器化在其中扮演了重要角色。'
- en: '**Isolation and security**: Just as Kaniko’s tiny robots operate within a controlled
    environment, Kaniko ensures that container image building takes place in an isolated
    and secure manner within a Kubernetes cluster. This means that different teams
    or projects can use Jenkins and Kaniko without interfering with each other’s container-building
    processes.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离性和安全性**：就像Kaniko的小型机器人在受控环境中运行一样，Kaniko确保容器镜像的构建在Kubernetes集群中以隔离且安全的方式进行。这意味着不同的团队或项目可以使用Jenkins和Kaniko而不会相互干扰各自的容器构建过程。'
- en: '**Consistency and automation**: Similar to how the conveyor belt (Jenkins)
    guarantees consistent machine assembly, Jenkins on Kubernetes with Kaniko ensures
    uniform container image construction. Automation is at the heart of this setup,
    simplifying the process of building and managing container images for applications.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性和自动化**：就像传送带（Jenkins）保证了机器组装的一致性一样，Kubernetes上的Jenkins与Kaniko结合确保了容器镜像构建的一致性。自动化是这一配置的核心，简化了为应用程序构建和管理容器镜像的过程。'
- en: To summarize, scalable Jenkins on Kubernetes with Kaniko refers to the practice
    of setting up Jenkins to efficiently build and manage container images using Kaniko
    within a Kubernetes environment. It enables consistent, parallel, and secure construction
    of container images, aligning perfectly with modern software development workflows.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，基于Kubernetes的可扩展Jenkins与Kaniko的结合，指的是在Kubernetes环境中设置Jenkins，通过Kaniko高效构建和管理容器镜像的实践。它能够实现容器镜像的持续、一致且安全的构建，完美契合现代软件开发的工作流。
- en: So, the analogy of a workshop with Jenkins, Kubernetes, and Kaniko vividly illustrates
    how this setup streamlines container image building, making it scalable, efficient,
    and secure for contemporary software development practices. Now, let’s dive deeper
    into Jenkins.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将Jenkins、Kubernetes和Kaniko类比为一个工作车间，生动地展示了这一配置如何简化容器镜像的构建，使其在当代软件开发实践中具备可扩展性、高效性和安全性。现在，让我们更深入地了解Jenkins。
- en: '**Jenkins** is the most popular CI tool available in the market. It is open
    source, simple to install, and runs with ease. It is a Java-based tool with a
    plugin-based architecture designed to support several integrations, such as with
    a source code management tool such as *Git*, *SVN*, and *Mercurial*, or with popular
    artifact repositories such as *Nexus* and *Artifactory*. It also integrates well
    with well-known build tools such as *Ant*, *Maven*, and *Gradle*, aside from the
    standard shell scripting and Windows batch file executions.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jenkins**是市场上最受欢迎的CI工具。它是开源的，安装简单，运行顺畅。Jenkins是一个基于Java的工具，采用插件化架构，设计用于支持多种集成，例如与源代码管理工具如*Git*、*SVN*和*Mercurial*的集成，或与流行的构件库如*Nexus*和*Artifactory*的集成。它还与知名的构建工具如*Ant*、*Maven*和*Gradle*兼容，此外，还支持标准的Shell脚本和Windows批处理文件执行。'
- en: 'Jenkins follows a *controller-agent* model. Though technically, you can run
    all your builds on the controller machine itself, it makes sense to offload your
    CI builds to other servers in your network to have a distributed architecture.
    This does not overload your controller machine. You can use it to store the build
    configurations and other management data and manage the entire CI build cluster,
    something along the lines of what’s shown in the following diagram:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 遵循*控制器-代理*模型。尽管从技术上讲，你可以在控制器机器本身上运行所有构建，但将 CI 构建任务分配给你网络中的其他服务器，形成分布式架构，显然更有意义。这样做可以避免控制器机器的过载。你可以用它来存储构建配置和其他管理数据，并管理整个
    CI 构建集群，类似于以下图示的方式：
- en: '![Figure 11.7 – Scalable Jenkins](img/B19877_11__7.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.7 – 可扩展的 Jenkins](img/B19877_11__7.jpg)'
- en: Figure 11.7 – Scalable Jenkins
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7 – 可扩展的 Jenkins
- en: In the preceding diagram, multiple static Jenkins agents connect to a Jenkins
    controller. Now, this architecture works well, but it needs to be more scalable.
    Modern DevOps emphasizes resource utilization, so we only want to roll out an
    agent machine when we want to build. Therefore, automating your builds to roll
    out an agent machine when required is a better way to do it. This might be overkill
    when rolling out new virtual machines, as it takes some minutes to provision a
    new VM, even when using a prebuilt image with Packer. A better alternative is
    to use a container.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的图示中，多个静态的 Jenkins 代理连接到 Jenkins 控制器。现在，这种架构运行良好，但它的可扩展性不足。现代 DevOps 强调资源的利用率，所以我们只希望在需要构建时才部署代理机器。因此，自动化构建流程，在需要时自动部署代理机器，是更好的做法。当部署新虚拟机时，这可能显得有些过头，因为即便是使用
    Packer 制作的预构建镜像，配置新虚拟机也需要几分钟时间。更好的替代方案是使用容器。
- en: 'Jenkins integrates quite well with Kubernetes, allowing you to run your build
    on a Kubernetes cluster. That way, whenever you trigger a build on Jenkins, Jenkins
    instructs Kubernetes to create a new agent container that will then connect with
    the controller machine and run the build within itself. This is *build on-demand*
    at its best. The following diagram shows this process in detail:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 与 Kubernetes 集成得相当好，允许你在 Kubernetes 集群上运行构建。这样，每当你在 Jenkins 上触发构建时，Jenkins
    会指示 Kubernetes 创建一个新的代理容器，容器将连接到控制器机器并在其中运行构建。这就是最好的*按需构建*。以下图示详细展示了这一过程：
- en: '![Figure 11.8 – Scalable Jenkins CI workflow](img/B19877_11__8.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.8 – 可扩展的 Jenkins CI 工作流](img/B19877_11__8.jpg)'
- en: Figure 11.8 – Scalable Jenkins CI workflow
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.8 – 可扩展的 Jenkins CI 工作流
- en: This sounds great, and we can go ahead and run this build, but there are issues
    with this approach. We must understand that the Jenkins controller and agents
    run as containers and aren’t full-fledged virtual machines. Therefore, if we want
    to run a Docker build within the container, we must run the container in privileged
    mode. This isn’t a security best practice, and your admin should already have
    turned that off. This is because running a container in privileged mode exposes
    your host filesystem to the container. A hacker who can access your container
    will have full access so that they can do whatever they want in your system.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这听起来很棒，我们可以继续运行这个构建，但这种方法也存在问题。我们必须理解，Jenkins 控制器和代理作为容器运行，而不是完整的虚拟机。因此，如果我们想在容器内运行
    Docker 构建，我们必须以特权模式运行该容器。这不是安全的最佳实践，而且你的管理员应该已经关闭了这个功能。这是因为以特权模式运行容器会将主机文件系统暴露给容器。一个能够访问你容器的黑客将拥有完全的访问权限，从而可以在系统中做任何事情。
- en: To solve that problem, you can use a container build tool such as **Kaniko**.
    Kaniko is a build tool provided by Google that helps you build your containers
    without access to the Docker daemon, and you do not even need Docker installed
    in your container. It is a great way to run your builds within a **Kubernetes
    cluster** and create a scalable CI environment. It is effortless, not hacky, and
    provides a secure method of building your containers, as we will see in the subsequent
    sections.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你可以使用如**Kaniko**这样的容器构建工具。Kaniko 是由 Google 提供的构建工具，帮助你在没有 Docker 守护进程的情况下构建容器，甚至不需要在容器中安装
    Docker。这是运行构建的一个很好的方法，特别是在**Kubernetes 集群**中，能够创建一个可扩展的 CI 环境。它简单易用，不需要黑客手段，并且提供了一种安全的构建容器方式，正如我们将在后续章节中看到的那样。
- en: This section will use **Google Kubernetes Engine** (**GKE**). As mentioned previously,
    Google Cloud provides a free trial worth $300 for 90 days. You can sign up at
    [https://cloud.google.com/free](https://cloud.google.com/free) if you have not
    already done so.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将使用**Google Kubernetes Engine**（**GKE**）。如前所述，Google Cloud 提供价值 $300 的90天免费试用。如果您尚未注册，可以在[https://cloud.google.com/free](https://cloud.google.com/free)注册。
- en: Spinning up Google Kubernetes Engine
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动 Google Kubernetes Engine
- en: Once you’ve signed up and are in your console, open the **Google Cloud Shell**
    CLI to run the following commands.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您注册并进入控制台，打开**Google Cloud Shell** CLI 来运行以下命令。
- en: 'You need to enable the Kubernetes Engine API first using the following command:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要首先使用以下命令启用 Kubernetes Engine API：
- en: '[PRE17]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To create a two-node autoscaling GKE cluster that scales from *one* to *five*
    nodes, run the following command:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个从*一个*节点扩展到*五个*节点的两节点自动扩展 GKE 集群，请运行以下命令：
- en: '[PRE18]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: And that’s it! The cluster will be up and running.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！集群将启动并运行。
- en: 'You must also clone the following GitHub repository for some of the exercises
    provided: [https://github.com/PacktPublishing/Modern-DevOps-Practices-2e](https://github.com/PacktPublishing/Modern-DevOps-Practices-2e).'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您还必须克隆以下 GitHub 仓库，以获取提供的一些练习：[https://github.com/PacktPublishing/Modern-DevOps-Practices-2e](https://github.com/PacktPublishing/Modern-DevOps-Practices-2e)。
- en: 'Run the following command to clone the repository into your home directory
    and `cd` into the following directory to access the required resources:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令将仓库克隆到您的主目录，然后`cd`进入以下目录以访问所需的资源：
- en: '[PRE19]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We will use the **Jenkins Configuration as Code** feature to configure Jenkins
    as it is a declarative way of managing your configuration and is also GitOps-friendly.
    You need to create a simple YAML file with all the required configurations and
    then copy the file to the Jenkins controller after setting an environment variable
    that points to the file. Jenkins will then automatically configure all aspects
    defined in the YAML file on bootup.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**Jenkins 配置即代码**（JCasC）功能来配置 Jenkins，因为它是一种声明性方式来管理您的配置，同时也支持 GitOps。您需要创建一个简单的
    YAML 文件，包含所有必需的配置，然后将该文件复制到 Jenkins 控制器，在设置一个指向文件的环境变量后，Jenkins 将在启动时自动配置 YAML
    文件中定义的所有方面。
- en: Let’s start by creating the `casc.yaml` file to define our configuration.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建`casc.yaml`文件来定义我们的配置。
- en: Creating the Jenkins CaC (JCasC) file
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Jenkins CaC（JCasC）文件
- en: The `casc.yaml` file for that purpose, and I will explain parts of it. Let’s
    start by defining **Jenkins** **Global Security**.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 用于此目的的`casc.yaml`文件，我将解释其中的部分内容。让我们首先定义**Jenkins** **全局安全性**。
- en: Configuring Jenkins Global Security
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 Jenkins 全局安全性
- en: 'By default Jenkins is insecure – that is, if you fire up a vanilla Jenkins
    from the official Docker image and expose it, anyone can do anything with that
    Jenkins instance. To ensure that we protect it, we need the following configuration:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Jenkins 是不安全的——也就是说，如果您从官方 Docker 镜像启动一个基础版 Jenkins 并暴露它，任何人都可以对该 Jenkins
    实例进行任何操作。为了确保我们保护它，我们需要以下配置：
- en: '[PRE20]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the preceding configuration, we’ve defined the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的配置中，我们定义了以下内容：
- en: '`remotingSecurity`: We’ve enabled this feature, which will secure the communication
    between the Jenkins controller and agents that we will create dynamically using
    Kubernetes.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`remotingSecurity`：我们启用了此功能，它将确保 Jenkins 控制器与我们将动态创建的 Kubernetes 代理之间的通信安全。'
- en: '`securityRealm`: We’ve set the security realm to `local`, which means that
    the Jenkins controller itself will do all authentication and user management.
    We could have also offloaded this to an external entity such as LDAP:'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`securityRealm`：我们已将安全领域设置为`local`，这意味着 Jenkins 控制器本身将负责所有认证和用户管理。我们也可以将其卸载到外部实体，如
    LDAP：'
- en: '`allowsSignup`: This is set to `false`. This means you don’t see a sign-up
    link on the Jenkins home page, and the Jenkins admin should manually create users.'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allowsSignup`：此设置为`false`。这意味着您在 Jenkins 首页上看不到注册链接，Jenkins 管理员应手动创建用户。'
- en: '`users`: We’ll create a single user with `id` and `password` sourced from two
    environment variables called `JENKINS_ADMIN_ID` and `JENKINS_ADMIN_PASSWORD`,
    respectively.'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`users`：我们将创建一个用户，其`id`和`password`分别来自两个环境变量，分别是`JENKINS_ADMIN_ID`和`JENKINS_ADMIN_PASSWORD`。'
- en: '`authorizationStrategy`: We’ve defined a matrix-based authorization strategy
    where we provide administrator privileges to `admin` and read privileges to `authenticated`
    non-admin users.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`authorizationStrategy`：我们定义了基于矩阵的授权策略，在该策略中，我们为`admin`提供管理员权限，为`authenticated`的非管理员用户提供读取权限。'
- en: 'Also, as we want Jenkins to execute all their builds in the agents and not
    the controller machine, we need to specify the following settings:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，由于我们希望Jenkins在代理中执行所有构建而不是在控制器机器上执行，因此我们需要指定以下设置：
- en: '[PRE21]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We’ve set `numExecutors` to `0` to allow no builds on the controller and also
    set `systemMessage` on the Jenkins welcome screen.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`numExecutors`设置为`0`，以允许在控制器上不执行任何构建，并在Jenkins欢迎界面上设置了`systemMessage`。
- en: Now that we’ve set up the security aspects of the Jenkins controller, we will
    configure Jenkins to connect with the Kubernetes cluster.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经设置了Jenkins控制器的安全方面，我们将配置Jenkins与Kubernetes集群连接。
- en: Connecting Jenkins with the cluster
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将Jenkins与集群连接
- en: We will install the Kubernetes plugin to connect the Jenkins controller with
    the cluster. We’re doing this because we want Jenkins to dynamically spin up agents
    for builds as Kubernetes **pods**.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将安装Kubernetes插件以将Jenkins控制器与集群连接起来。我们这样做是因为我们希望Jenkins动态为构建启动代理，作为Kubernetes
    **pod**。
- en: 'We will start by creating a `kubernetes` configuration under `jenkins.clouds`,
    as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先在`jenkins.clouds`下创建一个`kubernetes`配置，如下所示：
- en: '[PRE22]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As we have a placeholder called `<kubernetes_control_plane_ip>` within the
    configuration, we must replace this with the Kubernetes control plane’s IP address.
    Run the following command to fetch the control plane’s IP address:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 由于配置中有一个名为`<kubernetes_control_plane_ip>`的占位符，我们必须将其替换为Kubernetes控制平面的IP地址。运行以下命令获取控制平面的IP地址：
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, replace the `<kubernetes_control_plane_ip>` placeholder with the actual
    IP address you obtained from the preceding command by using the following command:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请使用以下命令将`<kubernetes_control_plane_ip>`占位符替换为您从前面命令中获取的实际IP地址：
- en: '[PRE24]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let’s look at each attribute in the config file:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看配置文件中的每个属性：
- en: '`serverUrl`: This denotes the Kubernetes control plane server URL, allowing
    the Jenkins controller to communicate with the Kubernetes API server.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`serverUrl`: 这表示Kubernetes控制平面的服务器URL，允许Jenkins控制器与Kubernetes API服务器通信。'
- en: '`jenkinsUrl`: This denotes the Jenkins controller URL. We’ve set it to http://jenkins-service:8080.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jenkinsUrl`: 这表示Jenkins控制器的URL。我们将其设置为http://jenkins-service:8080。'
- en: '`jenkinsTunnel`: This describes how the agent pods will connect with the Jenkins
    controller. As the JNLP port is `50000`, we’ve set it to `jenkins-service:50000`.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jenkinsTunnel`: 这描述了代理Pod如何与Jenkins控制器连接。由于JNLP端口是`50000`，我们将其设置为`jenkins-service:50000`。'
- en: '`podLabels`: We’ve also set up some pod labels, `key=jenkins` and `value=agent`.
    These will be set on the agent pods.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`podLabels`: 我们还设置了一些Pod标签，`key=jenkins`和`value=agent`。这些将设置在代理Pod上。'
- en: Other attributes are also set to their default values.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 其他属性也设置为它们的默认值。
- en: 'Every Kubernetes cloud configuration consists of multiple pod `templates` describing
    how the agent pods will be configured. The configuration looks like this:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Kubernetes云配置都包括多个Pod `templates`，描述了代理Pod的配置方式。配置如下：
- en: '[PRE25]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, we’ve defined the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了以下内容：
- en: The template’s `name` and `label`. We set both to `jenkins-agent`.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板的`name`和`label`。我们将它们都设置为`jenkins-agent`。
- en: '`hostNetwork`: This is set to `false` as we don’t want the container to interact
    with the host network.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hostNetwork`: 这被设置为`false`，因为我们不希望容器与主机网络交互。'
- en: '`seviceAccount`: We’ve set this to `jenkins` as we want to use this service
    account to interact with Kubernetes.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seviceAccount`: 我们将其设置为`jenkins`，因为我们希望使用此服务账号与Kubernetes交互。'
- en: '`imagePullSecrets`: We have also provided an image pull secret called `regcred`
    to authenticate with the container registry to pull the `jnlp` image.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`imagePullSecrets`: 我们还提供了一个名为`regcred`的镜像拉取秘钥，用于与容器注册表进行身份验证以拉取`jnlp`镜像。'
- en: 'Every pod template also contains a **container template**. We can define that
    using the following configuration:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Pod模板还包含一个**容器模板**。我们可以使用以下配置来定义它：
- en: '[PRE26]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Here, we have specified the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经指定了以下内容：
- en: '`name`: Set to `jnlp`.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`: 设置为`jnlp`。'
- en: '`image`: Here, we’ve specified the *Docker agent image* we will build in the
    next section. Ensure that you replace the `<your_dockerhub_user>` placeholder
    with your Docker Hub user by using the following command:'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image`: 在这里，我们指定了我们将在下一节构建的*Docker代理镜像*。请确保您使用以下命令将`<your_dockerhub_user>`占位符替换为您的Docker
    Hub用户名：'
- en: '[PRE27]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`workingDir`: Set to `/home/jenkins/agent`.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`workingDir`: 设置为`/home/jenkins/agent`。'
- en: We’ve set the `command` and `args` fields to blank as we don’t need to pass
    them.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将`command`和`args`字段都设置为空，因为我们不需要传递它们。
- en: '`livenessProbe`: We’ve defined a liveness probe for the agent pod.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`livenessProbe`: 我们为代理Pod定义了一个活动探针。'
- en: '`volumes`: We’ve mounted the `regcred` secret to the `kaniko/.docker` file
    as a volume. As `regcred` contains the Docker registry credentials, Kaniko will
    use this to connect with your container registry.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volumes`：我们已经将 `regcred` 密钥挂载到 `kaniko/.docker` 文件作为卷。由于 `regcred` 包含 Docker
    仓库凭证，Kaniko 将使用此凭证连接到容器注册表。'
- en: Now that our configuration file is ready, we’ll go ahead and install Jenkins
    in the next section.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的配置文件已经准备好，我们将在下一节安装 Jenkins。
- en: Installing Jenkins
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Jenkins
- en: As we’re running on a Kubernetes cluster, we only need the latest official Jenkins
    image from Docker Hub. We will customize the image according to our requirements.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是在 Kubernetes 集群上运行，我们只需要 Docker Hub 上最新的官方 Jenkins 镜像。我们将根据需求定制镜像。
- en: 'The following `Dockerfile` file will help us create the image with the required
    plugins and the initial configuration:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 `Dockerfile` 文件将帮助我们创建包含所需插件和初始配置的镜像：
- en: '[PRE28]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `Dockerfile` starts from the Jenkins base image. Then, we declare two environment
    variables – `CASC_JENKINS_CONFIG`, which points to the `casc.yaml` file we defined
    in the previous section, and `JAVA_OPTS`, which tells Jenkins not to run the setup
    wizard. Then, we copy the `casc.yaml` and `plugins.txt` files to their respective
    directories within the Jenkins container. Finally, we run `jenkins-plugins-cli`
    on the `plugins.txt` file, which installs the required plugins.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile` 从 Jenkins 基础镜像开始。接着，我们声明了两个环境变量——`CASC_JENKINS_CONFIG`，它指向我们在上一节中定义的
    `casc.yaml` 文件，以及 `JAVA_OPTS`，它告诉 Jenkins 不运行设置向导。然后，我们将 `casc.yaml` 和 `plugins.txt`
    文件复制到 Jenkins 容器内的相应目录。最后，我们在 `plugins.txt` 文件上运行 `jenkins-plugins-cli`，以安装所需的插件。'
- en: The `plugins.txt` file contains a list of all Jenkins plugins that we will need
    in this setup.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`plugins.txt` 文件包含了我们在此设置中所需的所有 Jenkins 插件的列表。'
- en: Tip
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can customize and install more plugins for the controller image based on
    your requirements by updating the `plugins.txt` file.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以根据需要通过更新 `plugins.txt` 文件来定制并安装更多插件，以满足控制器镜像的需求。
- en: 'Let’s build the image from the `Dockerfile` file using the following command:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用以下命令从 `Dockerfile` 文件构建镜像：
- en: '[PRE29]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now that we’ve built the image, use the following command to log in and push
    the image to Docker Hub:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建了镜像，使用以下命令登录并将镜像推送到 Docker Hub：
- en: '[PRE30]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We must also build the Jenkins agent image to run our builds. Remember that
    Jenkins agents need all the supporting tools you need to run your builds. You
    can find the resources for the agents in the following directory:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要构建 Jenkins 代理镜像以运行我们的构建。请记住，Jenkins 代理需要所有支持工具才能运行构建。你可以在以下目录找到代理所需的资源：
- en: '[PRE31]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We will use the following `Dockerfile` to do that:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下 `Dockerfile` 来实现：
- en: '[PRE32]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This `Dockerfile` uses a multi-stage build to take the `kaniko` base image
    and copy the `kaniko` binary from the `kaniko` base image to the `inbound-agent`
    base image. Let’s go ahead and build and push the container using the following
    commands:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `Dockerfile` 使用多阶段构建，从 `kaniko` 基础镜像开始，并将 `kaniko` 二进制文件从 `kaniko` 基础镜像复制到
    `inbound-agent` 基础镜像中。让我们使用以下命令构建并推送容器：
- en: '[PRE33]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To deploy Jenkins on our Kubernetes cluster, we will first create a `jenkins`
    service account. A Kubernetes `cluster-admin` using a cluster role binding. A
    Kubernetes `jenkins-sa-crb.yaml` manifest describes this. To access these resources,
    run the following command:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 Kubernetes 集群上部署 Jenkins，我们将首先创建一个 `jenkins` 服务账号。通过集群角色绑定，一个 Kubernetes
    `cluster-admin`。一个 Kubernetes `jenkins-sa-crb.yaml` 清单描述了这一点。要访问这些资源，请运行以下命令：
- en: '[PRE34]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To apply the manifest, run the following command:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用清单，运行以下命令：
- en: '[PRE35]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The next step involves creating a **PersistentVolumeClaim** resource to store
    Jenkins data to ensure that the Jenkins data persists beyond the pod’s life cycle
    and will exist even when we delete the pod.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个 **PersistentVolumeClaim** 资源来存储 Jenkins 数据，以确保 Jenkins 数据在 pod 生命周期之外仍然存在，并且即使删除
    pod 后数据也会存在。
- en: 'To apply the manifest, run the following command:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用清单，运行以下命令：
- en: '[PRE36]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Then, we will create a Kubernetes `regcred` to help the Jenkins pod authenticate
    with the Docker registry. Use the following command to do so:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个 Kubernetes `regcred` 来帮助 Jenkins pod 与 Docker 仓库进行身份验证。使用以下命令来实现：
- en: '[PRE37]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, we’ll define a `jenkins-deployment.yaml`, that will run the Jenkins container.
    The pod uses the `jenkins` service account and defines a `jenkins-pv-storage`
    using the `PersistentVolumeClaim` resource called `jenkins-pv-claim` that we defined.
    We define the Jenkins container that uses the Jenkins controller image we created.
    It exposes HTTP port `8080` for the *Web UI*, and port `50000` for *JNLP*, which
    the agents would use to interact with the Jenkins controller. We will also mount
    the `jenkins-pv-storage` volume to `/var/jenkins_home` to persist the Jenkins
    data beyond the pod’s life cycle. We specify `regcred` as the `imagePullSecret`
    attribute in the pod image. We also use `initContainer` to assign ownership to
    `jenkins` for `/var/jenkins_home`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将定义一个`jenkins-deployment.yaml`，它将运行Jenkins容器。Pod使用`jenkins`服务账户，并通过名为`jenkins-pv-claim`的`PersistentVolumeClaim`资源定义一个`jenkins-pv-storage`，这是我们之前定义的。我们定义了一个Jenkins容器，使用我们创建的Jenkins控制器镜像。它暴露了HTTP端口`8080`供*Web
    UI*使用，暴露了端口`50000`供*JNLP*使用，代理将使用该端口与Jenkins控制器进行交互。我们还将把`jenkins-pv-storage`卷挂载到`/var/jenkins_home`，以便在Pod生命周期之外持久化Jenkins数据。我们在Pod镜像中指定`regcred`作为`imagePullSecret`属性。我们还使用`initContainer`将`/var/jenkins_home`的所有权分配给`jenkins`。
- en: 'As the file contains placeholders, replace `<your_dockerhub_user>` with your
    Docker Hub user and `<jenkins_admin_pass>` with a Jenkins admin password of your
    choice using the following commands:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 由于文件包含占位符，请使用以下命令将`<your_dockerhub_user>`替换为你的Docker Hub用户名，将`<jenkins_admin_pass>`替换为你选择的Jenkins管理员密码：
- en: '[PRE38]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Apply the manifest using the following command:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令应用清单：
- en: '[PRE39]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'As we’ve created the deployment, we can expose the deployment on a `jenkins-svc.yaml`
    manifest. This service exposes ports `8080` and `50000` on a load balancer. Use
    the following command to apply the manifest:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经创建了部署，我们可以通过`jenkins-svc.yaml`清单暴露该部署。此服务在负载均衡器上暴露端口`8080`和`50000`。使用以下命令应用该清单：
- en: '[PRE40]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let’s get the service to find the external IP to use that to access Jenkins:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们让服务找到外部IP并使用它来访问Jenkins：
- en: '[PRE41]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, to access the service, go to `http://<LOAD_BALANCER_EXTERNAL_IP>:8080`
    in your browser window:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，要访问服务，请在浏览器窗口中输入`http://<LOAD_BALANCER_EXTERNAL_IP>:8080`：
- en: '![Figure 11.9 – Jenkins login page](img/B19877_11_9.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图11.9 – Jenkins登录页面](img/B19877_11_9.jpg)'
- en: Figure 11.9 – Jenkins login page
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9 – Jenkins登录页面
- en: 'As we can see, we’re greeted with a login page. This means Global Security
    is working correctly. Let’s log in using the admin username and password we set:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们被迎接到了一个登录页面。这意味着全球安全功能正常。让我们使用我们设置的管理员用户名和密码登录：
- en: '![Figure 11.10 – Jenkins home page](img/B19877_11_10.jpg)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![图11.10 – Jenkins首页](img/B19877_11_10.jpg)'
- en: Figure 11.10 – Jenkins home page
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.10 – Jenkins首页
- en: As we can see, we’ve successfully logged in to Jenkins. Now, let’s go ahead
    and create our first Jenkins job.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们已成功登录到Jenkins。现在，让我们继续创建我们的第一个Jenkins作业。
- en: Running our first Jenkins job
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行我们的第一个Jenkins作业
- en: Before we create our first job, we’ll have to prepare our repository to run
    the job. We will reuse the `mdo-posts` repository for this. We will copy a `build.sh`
    file to the repository, which will build the container image for the **posts**
    microservice and push it to Docker Hub.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建我们的第一个作业之前，我们需要准备好仓库以运行该作业。我们将重用`mdo-posts`仓库。我们将把一个`build.sh`文件复制到仓库，该文件将为**posts**微服务构建容器镜像，并将其推送到Docker
    Hub。
- en: 'The `build.sh` script takes `IMAGE_ID` and `IMAGE_TAG` as arguments. It passes
    them to the `Dockerfile` and pushes it to Docker Hub using the following code:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`build.sh`脚本接受`IMAGE_ID`和`IMAGE_TAG`作为参数。它将这些参数传递给`Dockerfile`，并使用以下代码将其推送到Docker
    Hub：'
- en: '[PRE42]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We will need to copy this file to our local repository using the following
    commands:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用以下命令将此文件复制到我们的本地仓库：
- en: '[PRE43]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Once you’ve done this, `cd` into your local repository – that is, `~/mdo-posts`
    – and commit and push your changes to GitHub. Once you’ve done this, you’ll be
    ready to create a job in Jenkins.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，进入本地仓库，即`~/mdo-posts`，然后提交并推送更改到GitHub。完成此操作后，你就可以准备在Jenkins中创建一个作业了。
- en: To create a new job in Jenkins, go to the Jenkins home page and select **New
    Item** | **Freestyle Job**. Provide a job name (preferably the same as the Git
    repository name), then click **Next**.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 要在Jenkins中创建一个新作业，进入Jenkins首页并选择**New Item** | **Freestyle Job**。提供一个作业名称（最好与Git仓库名称相同），然后点击**Next**。
- en: 'Click on **Source Code Management**, select **Git**, and add your Git repository
    URL, as shown in the following example. Specify the branch from where you want
    to build:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**Source Code Management**，选择**Git**，并添加你的Git仓库URL，如下所示。指定你希望构建的分支：
- en: '![Figure 11.11 – Jenkins Souce Code Management configuration](img/B19877_11_11.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.11 – Jenkins 源代码管理配置](img/B19877_11_11.jpg)'
- en: Figure 11.11 – Jenkins Souce Code Management configuration
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.11 – Jenkins 源代码管理配置
- en: 'Go to **Build Triggers**, select **Poll SCM**, and add the following details:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 进入**构建触发器**，选择**轮询 SCM**，并添加以下详细信息：
- en: '![Figure 11.12 – Jenkins – Build Triggers configuration](img/B19877_11__12.jpg)'
  id: totrans-281
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.12 – Jenkins – 构建触发器配置](img/B19877_11__12.jpg)'
- en: Figure 11.12 – Jenkins – Build Triggers configuration
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12 – Jenkins – 构建触发器配置
- en: 'Then, click on `build.sh` script with the `<your_dockerhub_user>/<image>` argument
    and the image tag. Change the details according to your requirements. Once you’ve
    finished, click **Save**:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，点击`build.sh`脚本，使用`<your_dockerhub_user>/<image>`参数和镜像标签。根据你的要求更改详细信息。完成后，点击**保存**：
- en: '![Figure 11.13 – Jenkins – Execute shell configuration](img/B19877_11__13.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.13 – Jenkins – 执行 Shell 配置](img/B19877_11__13.jpg)'
- en: Figure 11.13 – Jenkins – Execute shell configuration
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.13 – Jenkins – 执行 Shell 配置
- en: 'Now, we’re ready to build this job. To do so, you can either go to your job
    configuration and click **Build Now** or push a change to GitHub. You should see
    something like the following:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好构建这个任务了。为此，你可以进入任务配置并点击**立即构建**，或者推送一个更改到 GitHub。你应该能看到类似以下的内容：
- en: '![Figure 11.14 – Jenkins job page](img/B19877_11_14.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.14 – Jenkins 任务页面](img/B19877_11_14.jpg)'
- en: Figure 11.14 – Jenkins job page
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.14 – Jenkins 任务页面
- en: 'Jenkins will successfully create an agent pod in Kubernetes, where it will
    run this job, and soon, the job will start building. Click **Build** | **Console
    Output**. If everything is OK, you’ll see that the build was successful and that
    Jenkins has built the **posts** service and executed a unit test before pushing
    the Docker image to the registry:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 会成功创建一个 Kubernetes 中的代理 Pod，并在其中运行此任务，很快，任务就会开始构建。点击**构建** | **控制台输出**。如果一切正常，你会看到构建成功，并且
    Jenkins 已经构建了**posts**服务并在推送 Docker 镜像到注册表之前执行了单元测试：
- en: '![Figure 11.15 – Jenkins console output](img/B19877_11_15.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.15 – Jenkins 控制台输出](img/B19877_11_15.jpg)'
- en: Figure 11.15 – Jenkins console output
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.15 – Jenkins 控制台输出
- en: With that, we’re able to run a Docker build using a scalable Jenkins server.
    As we can see, we’ve set up polling on the SCM settings to look for changes every
    minute and build the job if we detect any. However, this is resource-intensive
    and does not help in the long run. Just imagine that you have hundreds of jobs
    interacting with multiple GitHub repositories, and the Jenkins controller is polling
    them every minute. A better approach would be if GitHub could trigger a **post-commit
    webhook** on Jenkins. Here, Jenkins can build the job whenever there are changes
    in the repository. We’ll look at that scenario in the next section.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就能够使用可扩展的 Jenkins 服务器运行 Docker 构建。如我们所见，我们已经在 SCM 设置中设置了轮询，每分钟检查一次是否有更改，如果有则构建任务。然而，这种方法消耗资源，并且从长远来看并不理想。试想一下，如果你有数百个任务与多个
    GitHub 仓库交互，而 Jenkins 控制器每分钟都在轮询它们。更好的方法是，GitHub 可以在 Jenkins 上触发一个**提交后 webhook**。在这种情况下，Jenkins
    会在仓库发生更改时构建任务。我们将在下一节中查看这种场景。
- en: Automating a build with triggers
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用触发器自动化构建
- en: The best way to allow your CI build to trigger when you make changes to your
    code is to use a post-commit webhook. We looked at such an example in the GitHub
    Actions workflow. Let’s try to automate the build with triggers in the case of
    Jenkins. We’ll have to make some changes on both the Jenkins and the GitHub sides
    to do so. We’ll deal with Jenkins first; then, we’ll configure GitHub.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 触发 CI 构建的最佳方法是使用提交后 webhook。当我们查看 GitHub Actions 工作流时，已经看到过类似的例子。现在，让我们尝试通过
    Jenkins 的触发器来自动化构建。为此，我们需要在 Jenkins 和 GitHub 两端进行一些更改。我们首先处理 Jenkins，然后配置 GitHub。
- en: 'Go to **Job configuration** | **Build Triggers** and make the following changes:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 进入**任务配置** | **构建触发器**，并进行以下更改：
- en: '![Figure 11.16 – Jenkins GitHub hook trigger](img/B19877_11__16.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.16 – Jenkins GitHub 钩子触发器](img/B19877_11__16.jpg)'
- en: Figure 11.16 – Jenkins GitHub hook trigger
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.16 – Jenkins GitHub 钩子触发器
- en: 'Save the configuration by clicking **Save**. Now, go to your GitHub repository,
    click **Settings** | **Webhooks** | **Add Webhook**, and add the following details.
    Then, click **Add Webhook**:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击**保存**保存配置。现在，进入你的 GitHub 仓库，点击**设置** | **Webhooks** | **添加 Webhook**，并添加以下详细信息。然后，点击**添加
    Webhook**：
- en: '![Figure 11.17 – GitHub webhook](img/B19877_11__17.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.17 – GitHub webhook](img/B19877_11__17.jpg)'
- en: Figure 11.17 – GitHub webhook
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.17 – GitHub webhook
- en: 'Now, push a change to the repository. The job on Jenkins will start building:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，推送更改到代码库。Jenkins 上的任务将开始构建：
- en: '![Figure 11.18 – Jenkins GitHub webhook trigger](img/B19877_11__18.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.18 – Jenkins GitHub webhook 触发器](img/B19877_11__18.jpg)'
- en: Figure 11.18 – Jenkins GitHub webhook trigger
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.18 – Jenkins GitHub webhook 触发器
- en: This is automated build triggers in action. Jenkins is one of the most popular
    open source CI tools on the market. The most significant advantage of it is that
    you can pretty much run it anywhere. However, it does come with some management
    overhead. You may have noticed how simple it was to start with GitHub Actions,
    but Jenkins is slightly more complicated.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是自动化构建触发器的实际操作。Jenkins 是市场上最流行的开源 CI 工具之一。它的最大优点是几乎可以在任何地方运行。然而，它也有一定的管理开销。你可能已经注意到，使用
    GitHub Actions 启动构建是多么简单，但 Jenkins 稍微复杂一些。
- en: Several other SaaS platforms offer CI and CD as a service. For instance, if
    you are running on AWS, you’d get their inbuilt CI with **AWS Code Commit** and
    **Code Build**; Azure provides an entire suite of services for CI and CD in their
    **Azure DevOps** offering; and GCP provides **Cloud Build** for that job.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一些 SaaS 平台也提供 CI 和 CD 服务。例如，如果你在 AWS 上运行，你可以使用其内置的 CI 服务，**AWS Code Commit**
    和 **Code Build**；Azure 提供了完整的 CI 和 CD 服务套件，在其 **Azure DevOps** 中；GCP 提供了 **Cloud
    Build** 来完成这项工作。
- en: CI follows the same principle, regardless of the tooling you choose to implement.
    It is more of a process and a cultural change within your organization. Now, let’s
    look at some of the best practices regarding CI.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择使用哪种工具，CI 都遵循相同的原则。它更多的是一个过程和你组织内的文化变革。现在，让我们来看看有关 CI 的一些最佳实践。
- en: Building performance best practices
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建性能最佳实践
- en: CI is an ongoing process, so you will have a lot of parallel builds running
    within your environment at a given time. In such situations, we can optimize them
    using several best practices.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: CI 是一个持续的过程，因此在任何给定时间，你的环境中会有许多并行的构建在运行。在这种情况下，我们可以通过一些最佳实践来优化这些构建。
- en: Aim for faster builds
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标是更快速的构建
- en: The faster you can complete your build, the quicker you will get feedback and
    run your next iteration. A slow build slows down your development team. Take steps
    to ensure that builds are faster. For example, in Docker’s case, it makes sense
    to use smaller base images as it will download the code from the image registry
    every time it does a build. Using a single base image for most builds will also
    speed up your build time. Using tests will help, but make sure that they aren’t
    long-running. We want to avoid a CI build that runs for hours. Therefore, it would
    be good to offload long-running tests into another job or use a pipeline. Run
    activities in parallel if possible.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 你完成构建的速度越快，得到反馈的速度就越快，下一次迭代也能更迅速地进行。构建缓慢会拖慢你的开发团队的速度。采取措施确保构建更快速。例如，在 Docker
    的情况下，使用较小的基础镜像是合理的，因为每次构建时都会从镜像注册表中下载代码。大多数构建使用相同的基础镜像也能加速构建时间。使用测试有帮助，但要确保它们不是长时间运行的。我们希望避免
    CI 构建持续几个小时。因此，将长时间运行的测试卸载到另一个作业中，或者使用管道将是一个不错的选择。如果可能的话，可以并行运行活动。
- en: Always use post-commit triggers
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 始终使用提交后的触发器
- en: Post-commit triggers help your team significantly. They will not have to log
    in to the CI server and trigger the build manually. That completely decouples
    your development team from CI management.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 提交后的触发器对你的团队帮助巨大。团队成员不需要登录 CI 服务器手动触发构建。这完全解耦了你的开发团队与 CI 管理。
- en: Configure build reporting
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置构建报告
- en: You don’t want your development team to log in to the CI tool and check how
    the build runs. Instead, all they want to know is the result of the build and
    the build logs. Therefore, you can configure build reporting to send your build
    status via email or, even better, using a **Slack** channel.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 你不希望开发团队登录到 CI 工具并检查构建的运行情况。他们只想知道构建的结果和构建日志。因此，你可以配置构建报告，通过电子邮件或更好的方式（如使用 **Slack**
    频道）发送构建状态。
- en: Customize the build server size
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义构建服务器的大小
- en: Not all builds work the same in similar kinds of build machines. You may want
    to choose machines based on what suits your build environment best. If your builds
    tend to consume more CPU than memory, it will make sense to choose such machines
    to run your builds instead of the standard ones.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 并不是所有构建在相似类型的构建机器上都能以相同的方式工作。你可能需要根据构建环境的需求来选择机器。如果你的构建倾向于消耗更多的 CPU 而不是内存，那么选择这种机器来运行你的构建，而不是标准机器，将更为合理。
- en: Ensure that your builds only contain what you need
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保你的构建只包含你需要的内容
- en: Builds move across networks. You download base images, build your application
    image, and push that to the container registry. Bloated images not only take a
    lot of network bandwidth and time to transmit but also make your build vulnerable
    to security issues. Therefore, it is always best practice to only include what
    you require in the build and avoid bloat. You can use Docker’s **multi-stage builds**
    for these kinds of situations.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 构建在网络间传输。你下载基础镜像，构建应用镜像，然后将其推送到容器注册中心。臃肿的镜像不仅占用大量网络带宽和传输时间，还可能使你的构建面临安全问题。因此，最佳实践始终是仅在构建中包含所需的内容，避免臃肿。你可以使用
    Docker 的**多阶段构建**来处理这种情况。
- en: Parallelize your builds
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行化构建
- en: Run tests and build processes concurrently to reduce overall execution time.
    Leverage distributed systems or cloud-based CI/CD platforms for scalable parallelization,
    allowing you to handle larger workloads efficiently.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 同时运行测试和构建过程，以减少整体执行时间。利用分布式系统或基于云的 CI/CD 平台进行可扩展并行化，帮助高效处理更大的工作负载。
- en: Make use of caching
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用缓存
- en: Cache dependencies and build artifacts to prevent redundant downloads and builds,
    saving valuable time. Implement caching mechanisms such as Docker layer caching
    or use your package manager’s built-in caches to minimize data transfer and build
    steps.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存依赖项和构建工件，以防止冗余的下载和构建，节省宝贵的时间。实现缓存机制，如 Docker 层缓存，或使用包管理器的内置缓存来最小化数据传输和构建步骤。
- en: Use incremental building
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用增量构建
- en: Configure your CI/CD pipeline to perform incremental builds, rebuilding only
    what has changed since the last build. Maintain robust version control practices
    to accurately track and identify changes.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 CI/CD 流水线以执行增量构建，仅重建自上次构建以来发生变化的部分。保持强大的版本控制实践，以准确追踪和识别更改。
- en: Optimize testing
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化测试
- en: Prioritize and optimize tests by running quicker unit tests before slower integration
    or end-to-end tests. Use testing frameworks such as TestNG, JUnit, or PyTest to
    categorize and parallelize tests effectively.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 优先运行较快的单元测试，然后再运行较慢的集成或端到端测试。使用 TestNG、JUnit 或 PyTest 等测试框架来有效分类和并行化测试。
- en: Use artifact management
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用工件管理
- en: Efficiently store and manage build artifacts, preferably in a dedicated artifact
    repository such as Artifactory or Nexus. Implement artifact versioning and retention
    policies to maintain a clean artifact repository.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 高效地存储和管理构建工件，最好将其存储在专用的工件仓库中，如 Artifactory 或 Nexus。实施工件版本控制和保留策略，以保持工件仓库的整洁。
- en: Manage application dependencies
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理应用程序依赖关系
- en: Keep a clean and minimal set of dependencies to reduce build and test times.
    Regularly update dependencies to benefit from performance improvements and security
    updates.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 保持干净且简洁的依赖关系，以减少构建和测试时间。定期更新依赖项，以受益于性能提升和安全更新。
- en: Utilize Infrastructure as Code
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用基础设施即代码
- en: Utilize **Infrastructure as Code** (**IaC**) to provision and configure build
    and test environments consistently. Optimize IaC templates to minimize resource
    utilization, ensuring efficient resource allocation.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 利用**基础设施即代码**（**IaC**）来一致性地配置和提供构建及测试环境。优化 IaC 模板，以最小化资源利用，确保高效的资源分配。
- en: Use containerization to manage build and test environments
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用容器化管理构建和测试环境
- en: Containerize applications and utilize container orchestration tools such as
    Kubernetes to manage test environments efficiently. Leverage container caching
    to accelerate image builds and enhance resource utilization.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 容器化应用程序，并利用容器编排工具如 Kubernetes 高效管理测试环境。利用容器缓存加速镜像构建，提升资源利用率。
- en: Utilize cloud-based CI/CD
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用基于云的 CI/CD
- en: Consider adopting cloud-based CI/CD services such as AWS CodePipeline, Google
    Cloud Build, Azure DevOps, or Travis CI for enhanced scalability and performance.
    Harness on-demand cloud resources to expand parallelization capabilities and adapt
    to varying workloads.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑采用基于云的 CI/CD 服务，如 AWS CodePipeline、Google Cloud Build、Azure DevOps 或 Travis
    CI，以提升可扩展性和性能。利用按需云资源扩展并行化能力，适应不同的工作负载。
- en: Monitor and profile your CI/CD pipelines
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控和分析 CI/CD 流水线
- en: Implement performance monitoring and profiling tools to identify bottlenecks
    and areas for improvement within your CI/CD pipeline. Regularly analyze build
    and test logs to gather insights for optimizing performance.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 实施性能监控和分析工具，以识别 CI/CD 流水线中的瓶颈和改进领域。定期分析构建和测试日志，收集优化性能的洞察。
- en: Pipeline optimization
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流水线优化
- en: Continuously review and optimize your CI/CD pipeline configuration for efficiency
    and relevance. Remove unnecessary steps or stages that do not contribute significantly
    to the process.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 持续审查并优化 CI/CD 管道配置，提高效率和相关性。删除不再有显著贡献的多余步骤或阶段。
- en: Implement automated cleanup
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实施自动化清理
- en: Implement automated cleanup routines to remove stale artifacts, containers,
    and virtual machines, preventing resource clutter. Regularly purge old build artifacts
    and unused resources to maintain a tidy environment.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 实施自动化清理程序，删除过时的构建产物、容器和虚拟机，避免资源堆积。定期清理旧的构建产物和未使用的资源，以保持环境整洁。
- en: Documentation and training
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文档和培训
- en: Document best practices and performance guidelines for your CI/CD processes,
    ensuring that the entire team follows these standards consistently. Provide training
    and guidance to team members to empower them to implement and maintain these optimization
    strategies effectively.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的 CI/CD 流程编写最佳实践和性能指南，确保整个团队始终如一地遵循这些标准。为团队成员提供培训和指导，使他们能够有效地实施和维护这些优化策略。
- en: By implementing these strategies, you can significantly enhance the speed, efficiency,
    and reliability of your CI/CD pipeline, ultimately leading to smoother software
    development and delivery processes. These are some of the best practices at a
    high level, and they are not exhaustive, but they are good enough so that you
    can start optimizing your CI environment.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实施这些策略，你可以显著提升 CI/CD 管道的速度、效率和可靠性，从而促进更顺畅的软件开发和交付过程。这些是高层次的最佳实践，虽然不完全，但足够让你开始优化
    CI 环境。
- en: Summary
  id: totrans-346
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter covered CI, and you understood the need for CI and the basic CI
    workflow for a container application. We then looked at GitHub Actions, which
    we can use to build an effective CI pipeline. Next, we looked at the Jenkins open
    source offering and deployed a scalable Jenkins on Kubernetes with Kaniko, setting
    up a Jenkins controller-agent model. We then understood how to use hooks for automating
    builds, both in the GitHub Actions-based workflow and the Jenkins-based workflow.
    Finally, we learned about build performance best practices and dos and don’ts.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了持续集成（CI），你理解了持续集成的必要性以及容器应用程序的基本 CI 工作流。接着，我们了解了 GitHub Actions，使用它可以构建一个有效的
    CI 管道。然后，我们探讨了 Jenkins 开源工具，并在 Kubernetes 上部署了一个可扩展的 Jenkins，结合 Kaniko 设置了 Jenkins
    控制器-代理模式。接着，我们了解了如何在基于 GitHub Actions 和基于 Jenkins 的工作流中使用钩子来自动化构建。最后，我们学习了构建性能的最佳实践以及需要避免的事项。
- en: By now, you should be familiar with CI and its nuances, along with the various
    tooling you can use to implement it.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你应该已经熟悉 CI 及其细节，并了解可以用来实现 CI 的各种工具。
- en: In the next chapter, we will delve into continuous deployment/delivery in the
    container world.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将深入探讨容器世界中的持续部署/交付。
- en: Questions
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题，测试你对本章内容的理解：
- en: Which of the following are CI tools? (Choose three)
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些是 CI 工具？（选择三个）
- en: A. Jenkins
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. Jenkins
- en: B. GitHub Actions
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. GitHub Actions
- en: C. Kubernetes
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. Kubernetes
- en: D. AWS Code Build
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. AWS Code Build
- en: It is a best practice to configure post-commit triggers. (True/False)
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置提交后触发器是一种最佳实践。 (正确/错误)
- en: Jenkins is a SaaS-based CI tool. (True/False)
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jenkins 是基于 SaaS 的 CI 工具。 (正确/错误)
- en: Kaniko requires Docker to build your containers. (True/False)
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kaniko 需要 Docker 来构建容器。 (正确/错误)
- en: Jenkins agents are required for which of the following reasons? (Choose three)
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Jenkins 代理节点需要哪些原因？（选择三个）
- en: A. They make builds more scalable
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. 它们使构建更具可扩展性
- en: B. They help offload the management function from the Jenkins controller
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. 它们帮助将管理功能从 Jenkins 控制器上卸载
- en: C. They allow for parallel builds
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. 它们允许并行构建
- en: D. They keep the Jenkins controller less busy
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. 它们让 Jenkins 控制器更少忙碌
- en: Which of the following is required for a scalable Jenkins server, as described
    in the example in this chapter? (Choose three)
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些是构建可扩展 Jenkins 服务器所需的？（选择三个）
- en: A. Kubernetes cluster
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. Kubernetes 集群
- en: B. Jenkins controller node
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. Jenkins 控制器节点
- en: C. Jenkins agent node
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. Jenkins 代理节点
- en: D. Credentials to interact with the container registry
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. 与容器注册表交互的凭证
- en: Answers
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'The following are the answers to this chapter’s questions:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章问题的答案：
- en: A, B, D
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A, B, D
- en: 'True'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: 'False'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: 'False'
  id: totrans-375
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 错误
- en: A, C, D
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A, C, D
- en: A, B, D
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A, B, D
