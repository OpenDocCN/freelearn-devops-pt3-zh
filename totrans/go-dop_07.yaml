- en: 'Chapter 6: Interacting with Remote Data Sources'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章：与远程数据源交互
- en: In the last chapter, we talked about dealing with common data formats and showed
    how we can read and write data in those formats. But in that chapter, we were
    simply dealing with data that was accessible through a filesystem.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了如何处理常见的数据格式，并展示了如何读取和写入这些格式的数据。但在那一章中，我们仅仅处理了可以通过文件系统访问的数据。
- en: While the filesystem may actually have files that exist on remote devices through
    services such as the **Network File System** (**NFS**) or the **Server Message
    Block** (**SMB**), other remote data sources exist.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然文件系统实际上可能通过**网络文件系统**（**NFS**）或**服务器消息块**（**SMB**）等服务，拥有存储在远程设备上的文件，但也存在其他远程数据源。
- en: In this chapter, we will look at some common ways to send and receive data in
    remote data sources. This will focus on accessing data on remote systems using
    the **Structured Query Language** (**SQL**), **REpresentational State Transfer**
    (**REST**), and **Google Remote Procedure Call** (**gRPC**). You will learn how
    to access common SQL data stores, with a focus on PostgreSQL. We will also explore
    how **Remote Procedure Call** (**RPC**) services are created and queried using
    REST- and gRPC-style RPC methodologies.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论一些常见的方式，用于在远程数据源中发送和接收数据。本章将重点介绍如何使用**结构化查询语言**（**SQL**）、**表述性状态转移**（**REST**）和**Google
    远程过程调用**（**gRPC**）来访问远程系统中的数据。你将学习如何访问常见的 SQL 数据存储，重点是 PostgreSQL。我们还将探讨如何使用 REST
    和 gRPC 风格的 RPC 方法创建和查询**远程过程调用**（**RPC**）服务。
- en: With the skills you gain here, you will be able to connect and query data in
    a SQL database, add new entries to the database, request a remote action from
    a service, and gather information from a remote service.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在这里学到的技能，你将能够连接并查询 SQL 数据库中的数据，向数据库添加新条目，向服务请求远程操作，并从远程服务获取信息。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论以下主题：
- en: Accessing SQL databases
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问 SQL 数据库
- en: Developing REST services and clients
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发 REST 服务和客户端
- en: Developing gRPC services and clients
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发 gRPC 服务和客户端
- en: In the next section, we will dive into utilizing data in one of the oldest formats,
    **Comma-Separated Values** (**CSV**).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将深入探讨使用最古老的数据格式之一——**逗号分隔值**（**CSV**）。
- en: Let's get started!
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code files for this chapter can be downloaded from [https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/6/grpc](https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/6/grpc)
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以从[https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/6/grpc](https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/6/grpc)下载。
- en: Accessing SQL databases
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问 SQL 数据库
- en: DevOps engineers commonly have a need to access data stored in database systems.
    **SQL** is a standard for communicating with database systems that a DevOps engineer
    will encounter in their day-to-day lives.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps 工程师通常需要访问存储在数据库系统中的数据。**SQL** 是与数据库系统通信的标准，是 DevOps 工程师在日常工作中会遇到的内容。
- en: Go provides a standard library for interacting with SQL-based systems called
    `database/sql`. The interfaces provided by that package, with the addition of
    a database driver, allow a user to work with several different SQL databases.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Go 提供了一个标准库，用于与基于 SQL 的系统交互，称为`database/sql`。该包提供的接口，结合数据库驱动程序，允许用户与多种不同的 SQL
    数据库进行操作。
- en: In this section, we will look at how we can access a Postgres database to perform
    basic SQL operations using Go.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何使用 Go 访问 Postgres 数据库，以执行基本的 SQL 操作。
- en: Important Note
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Examples in this section will require you to set up a Postgres database. This
    is beyond the scope of this book. This will not be a guide to SQL. Some basic
    SQL knowledge is required.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的示例将要求你设置一个 Postgres 数据库。此内容超出了本书的范围。本书并不讲解 SQL。需要具备一些基本的 SQL 知识。
- en: You can find information regarding how to install Postgres for your OS at [https://www.postgresql.org/download/](https://www.postgresql.org/download/).
    If you prefer to run Postgres in a local Docker container, you can find that information
    at [https://hub.docker.com/_/postgres](https://hub.docker.com/_/postgres).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://www.postgresql.org/download/](https://www.postgresql.org/download/)找到关于如何为你的操作系统安装
    Postgres 的信息。如果你更倾向于在本地 Docker 容器中运行 Postgres，可以在[https://hub.docker.com/_/postgres](https://hub.docker.com/_/postgres)找到相关信息。
- en: Connecting to a Postgres database
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到 Postgres 数据库
- en: To connect to a Postgres database will require using a database driver for Postgres.
    The currently recommended third-party package is `github.com/jackc/pgx`. This
    package implements a SQL driver for `database/sql` and provides its own methods/types
    for Postgres-specific features.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接到Postgres数据库，需要使用Postgres的数据库驱动程序。目前推荐的第三方包是`github.com/jackc/pgx`。该包实现了一个适用于`database/sql`的SQL驱动程序，并提供了自己的方法/类型来支持Postgres特定功能。
- en: The choice to use `database/sql` or Postgres-specific types will depend on whether
    you need to ensure compatibility between different databases. Using `database/sql`
    allows you to write functions that work on any SQL database, while using Postgres-specific
    features removes compatibility and makes migration to another database more difficult.
    We will discuss how to perform our examples using both methods.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`database/sql`或Postgres特定类型的选择取决于是否需要确保不同数据库之间的兼容性。使用`database/sql`允许你编写适用于任何SQL数据库的函数，而使用Postgres特定功能则移除了兼容性，使迁移到其他数据库变得更加困难。我们将讨论如何使用这两种方法执行我们的示例。
- en: 'Here is how to connect using a standard SQL package without extra Postgres
    features:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何使用标准SQL包连接而不使用额外的Postgres功能：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, we open a connection to Postgres using the `pgx` driver that will be
    registered when you import the following package:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`pgx`驱动程序打开一个Postgres连接，该驱动程序将在导入以下包时注册：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is an anonymous import, meaning we are not using `stdlib` directly. This
    is done when we want a *side effect*, such as when registering a driver with the
    `database/sql` package.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个匿名导入，意味着我们没有直接使用`stdlib`。这是在我们想要产生*副作用*时使用的，例如在使用`database/sql`包注册驱动程序时。
- en: The `Open()` call doesn't test our connection. You will see `conn.PingContext()`
    to test that we will be able to make calls to the database.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`Open()`调用不会测试我们的连接。你会看到`conn.PingContext()`来测试我们是否能够向数据库发起请求。'
- en: 'When you want to use `pgx-specific` types for Postgres, the setup is slightly
    different, starting with a different package import:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要使用`pgx-specific`类型来操作Postgres时，设置略有不同，从不同的包导入开始：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To create that connection, type the following:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建该连接，请键入以下内容：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This uses a connection pool to connect to the database for performance. You
    will notice that we don't have a `PingContext()` call, as the native connection
    tests the connection as part of `Connect()`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用连接池连接到数据库，以提高性能。你会注意到我们没有`PingContext()`调用，因为本地连接会在`Connect()`过程中自动测试连接。
- en: Now that you know how to connect to Postgres, let's look at how we can make
    queries.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你知道如何连接到Postgres了，接下来我们来看看如何进行查询。
- en: Querying a Postgres database
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询Postgres数据库
- en: Let's consider making a call to your SQL database to fetch some information
    about a user that is held in a table.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下如何向你的SQL数据库发起请求，获取存储在表中的用户信息。
- en: 'Using the standard library, type the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准库，键入以下内容：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This example does the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例执行了以下操作：
- en: Creates `UserRec` to store SQL data for a user
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建`UserRec`以存储用户的SQL数据
- en: Creates a query statement called `query`
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`query`的查询语句
- en: Queries our database for a user with the requested ID
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询我们的数据库，获取请求的ID对应的用户
- en: Returns `UserRec` and an error if we had one
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回`UserRec`和一个错误（如果有的话）
- en: 'We can increase the efficiency of this example by using a prepared statement
    in an object instead of just a function:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在对象中使用预准备语句，而不是仅仅使用函数来提高此示例的效率：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This example does the following:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例执行了以下操作：
- en: Creates a reusable object
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个可重用的对象
- en: Stores `*sql.Stmt`, which increases the efficiency when doing repeated queries
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储`*sql.Stmt`，这可以提高重复查询时的效率
- en: Defines a `NewStorage` constructor that creates our object
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个`NewStorage`构造函数来创建我们的对象
- en: Because of the generic nature of using the standard library, in these examples,
    any implementation of `*sql.DB` could be used. Switching Postgres for MariaDB
    would work as long as MariaDB had the same table names and format.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用标准库的通用性，在这些示例中，任何`*sql.DB`的实现都可以使用。只要MariaDB有相同的表名和格式，切换Postgres为MariaDB也是可行的。
- en: 'If we use the Postgres-specific library, the same code is written like so:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用Postgres特定的库，代码将如下所示：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This implementation looks and works in a similar way to the standard library.
    But the `conn` object here is a different, non-interface `pgxpool.Conn` type and
    not `sql.Conn`. And while the functionality looks similar, the `pgxpool.Conn`
    object supports queries with Postgres-specific types and syntax, such as `jsonb`,
    that `sql.Conn` does not.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这种实现方式看起来和工作方式与标准库类似。但这里的 `conn` 对象是一个不同的非接口类型 `pgxpool.Conn`，而不是 `sql.Conn`。尽管功能相似，`pgxpool.Conn`
    对象支持 Postgres 特有的类型和语法，例如 `jsonb`，而 `sql.Conn` 不支持。
- en: There is no need to use a prepared statement for non-transactions when using
    Postgres-specific calls. The call information is automatically cached.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Postgres 特有的调用时，不需要为非事务操作使用预处理语句。调用信息会自动缓存。
- en: 'The preceding example was simplistic in that we were pulling a specific entry.
    What if we wanted to also have a method to retrieve all users with IDs between
    two numbers? We could define this using the standard library:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例比较简单，我们只是拉取了一个特定的条目。如果我们想要一个方法来检索所有 ID 在两个数字之间的用户呢？我们可以使用标准库来定义：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The Postgres-specific syntax is the same; it just switches `s.usersBetweenStmt()`
    for `conn.QueryRow()`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Postgres 特有的语法保持不变，只是将 `s.usersBetweenStmt()` 替换成了 `conn.QueryRow()`。
- en: Null values
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空值
- en: SQL has a concept of null values for basic types such as Booleans, strings,
    and int32\. Go doesn't have the convention; instead, it provides zero values for
    those types.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: SQL 有一个空值概念，适用于布尔值、字符串和 int32 等基本类型。Go 没有这个约定；相反，它为这些类型提供了零值。
- en: 'When SQL allows a column to have a null value, the standard library provides
    special null types in `database/sql`:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当 SQL 允许某列具有空值时，标准库提供了在 `database/sql` 中的特殊空类型：
- en: '`sql.NullBool`'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sql.NullBool`'
- en: '`sql.NullByte`'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sql.NullByte`'
- en: '`sql.NullFloat64`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sql.NullFloat64`'
- en: '`sql.NullInt16`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sql.NullInt16`'
- en: '`sql.NullInt32`'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sql.NullInt32`'
- en: '`sql.NullInt64`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sql.NullInt64`'
- en: '`sql.NullString`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sql.NullString`'
- en: '`sql.NullTime`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sql.NullTime`'
- en: When you design your schema, it is better to use zero values instead of null
    values. But sometimes, you need to tell the difference between a value being set
    and the zero value. In those cases, you can use these special types in place of
    the standard type.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计你的模式时，最好使用零值而不是空值。但有时，你需要区分一个值是否已设置与零值。在这种情况下，你可以使用这些特殊类型代替标准类型。
- en: 'For example, if our `UserRec` could have a null `DisplayName`, we can change
    the `string` type to `sql.NullString`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们的 `UserRec` 可能有一个空的 `DisplayName`，我们可以将 `string` 类型更改为 `sql.NullString`：
- en: '[PRE8]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can see an example of how the server sets these values depending on the
    value that the column holds for `DisplayName` here: [https://go.dev/play/p/KOkYdhcjhdf](https://go.dev/play/p/KOkYdhcjhdf).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里查看服务器如何根据 `DisplayName` 列的值设置这些值的示例：[https://go.dev/play/p/KOkYdhcjhdf](https://go.dev/play/p/KOkYdhcjhdf)。
- en: Writing data to Postgres
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向 Postgres 写入数据
- en: 'Writing data into a database is simple but requires some consideration of the
    syntax. The two major operations that a user wants when writing data are as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 向数据库写入数据很简单，但需要考虑语法。用户写入数据时最常见的两个操作如下：
- en: Updating an existing entry
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新现有条目
- en: Inserting a new entry
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插入新条目
- en: In standard SQL, you cannot do an *update entry if it exists; insert if not*.
    As this is a common operation, each database offers some way to do this with its
    own special syntax. When using the standard library, you must choose between doing
    an update or an insert. If you do not know whether the entry exists, you will
    need to use a transaction, which we will detail in a bit.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准 SQL 中，你不能执行 *如果存在则更新条目；如果不存在则插入*。由于这是一个常见操作，每个数据库都有自己独特的语法来完成此操作。在使用标准库时，你必须在执行更新或插入之间做出选择。如果你不知道条目是否存在，你将需要使用事务，稍后我们会详细说明。
- en: 'Doing an update or insert is simply using a different SQL syntax and the `ExecContext()`
    call:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 执行更新或插入只是使用不同的 SQL 语法和 `ExecContext()` 调用：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In this example, we have added two methods:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们添加了两个方法：
- en: '`AddUser()` adds a new user into the system.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddUser()` 将新用户添加到系统中。'
- en: '`UpdateDisplayName()` updates the display name of a user with a specific ID.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UpdateDisplayName()` 更新具有特定 ID 的用户的显示名称。'
- en: Both use the `sql.Stmt` type, which would be a field in the object, similar
    to `getUserStmt`.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两者都使用 `sql.Stmt` 类型，它将作为对象中的一个字段，类似于 `getUserStmt`。
- en: 'The major difference when implementing using the Postgres-native package is
    the method name that is called and the lack of a prepared statement. Implementing
    `AddUser()` would look like the following:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Postgres 原生包实现时的主要区别在于调用的方法名称，以及没有预处理语句。实现 `AddUser()` 的代码如下：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Sometimes, it is not enough to just do a read or a write to the database. Sometimes,
    we need to do multiple actions atomically and treat them as a single action. So,
    in the next section, we will talk about how to do this with transactions.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，仅仅对数据库进行读写操作是不够的。有时，我们需要原子性地执行多个操作，并将它们视为一个整体。因此，在下一节中，我们将讨论如何使用事务来实现这一点。
- en: Transactions
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事务
- en: Transactions provide a sequence of SQL operations that are executed on the server
    as one piece of work. This is commonly used to provide some type of atomic operation
    where a read and a write are required or to extract data on a read before doing
    a write.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 事务提供了一系列在服务器上作为一个整体执行的 SQL 操作。它通常用于提供某种类型的原子操作，其中需要执行读和写，或者在执行写操作之前先读取数据。
- en: 'Transactions are easy to create in Go. Let''s create an `AddOrUpdateUser()`
    call that will look to see whether a user exists before adding or updating our
    data:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，事务很容易创建。让我们创建一个 `AddOrUpdateUser()` 调用，在添加或更新数据之前检查用户是否存在：
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This code does the following:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码执行了以下操作：
- en: Creates a transaction with an isolation level of `LevelSerializable`
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个隔离级别为 `LevelSerializable` 的事务。
- en: 'Uses a `defer` statement to determine whether we had an error:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `defer` 语句来判断是否发生了错误：
- en: If we did, we roll back the entire transaction.
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找到了用户，我们会回滚整个事务。
- en: If not, we attempt to commit the transaction.
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有找到用户，我们尝试提交事务。
- en: 'Queries to find whether the user exists:'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查询用于查找用户是否存在：
- en: It determines this by checking the error type.
  id: totrans-97
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过检查错误类型来确定这一点。
- en: If the error is `sql.ErrNoRows`, we did not find the user.
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果错误是 `sql.ErrNoRows`，说明我们没有找到该用户。
- en: If the error is anything else, it was a system error.
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果错误是其他类型，则表示系统错误。
- en: Executes an insert statement if we didn't find the user
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们没有找到该用户，则执行插入语句。
- en: Executes an update statement if we did find the user
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们找到了该用户，则执行更新语句。
- en: 'The keys to a transaction are the following:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 事务的关键要素如下：
- en: '`conn.BeginTx`, which starts the transaction'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`conn.BeginTx`，用于开始事务'
- en: '`tx.Commit()`, which commits our changes'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tx.Commit()`，用于提交我们的更改'
- en: '`tx.Rollback()`, which reverts our changes'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`tx.Rollback()`，用于回滚我们的更改'
- en: A `defer` statement is an excellent way to handle either `Commit()` or `Rollback()`
    once the transaction has been created. It ensures that when the function ends,
    either one or the other is executed.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`defer` 语句是一种很好的方式来处理创建事务后执行 `Commit()` 或 `Rollback()`。它确保在函数结束时，无论如何都会执行其中一个操作。'
- en: The isolation level is important for a transaction as it affects the performance
    and reliability of your system. Go provides multiple levels of isolation; however,
    not all database systems will support all levels of isolation.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离级别对事务很重要，因为它会影响系统的性能和可靠性。Go 提供了多个隔离级别；然而，并非所有数据库系统都支持所有的隔离级别。
- en: 'You can read more about isolation levels here: [https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels](https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels).'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里了解更多关于隔离级别的内容：[https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels](https://en.wikipedia.org/wiki/Isolation_(database_systems)#Isolation_levels)。
- en: Postgres-specific types
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特定于 Postgres 的类型
- en: So far in our examples, we have shown you how to use both the standard library
    and Postgres-specific objects to interact with Postgres. But we haven't really
    shown a compelling reason to use Postgres objects.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经向你展示了如何使用标准库和特定于 Postgres 的对象与 Postgres 交互。但我们还没有真正展示使用 Postgres 对象的充分理由。
- en: 'Postgres objects shine when you need to use types or capabilities that aren''t
    a part of the SQL standard. Let''s rewrite our transaction example, but instead
    of storing data across standard columns, let''s have our Postgres database only
    have two columns:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要使用不是 SQL 标准的一部分的类型或功能时，Postgres 对象非常有用。让我们重写我们的事务示例，但这次我们不通过标准列来存储数据，而是让我们的
    Postgres 数据库只包含两个列：
- en: An ID of the `int` type
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int` 类型的 ID'
- en: Data of the `jsonb` type
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`jsonb` 类型的数据'
- en: '`jsonb` is not part of the SQL standard and cannot be implemented with the
    standard SQL library. `jsonb` can greatly simplify your life, as it allows you
    to store JSON data while querying using JSON fields:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`jsonb` 不是 SQL 标准的一部分，不能使用标准 SQL 库实现。`jsonb` 可以极大简化你的工作，因为它允许你在查询时使用 JSON 字段来存储
    JSON 数据：'
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This example is different in a few ways:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例在几个方面有所不同：
- en: It has additional `AccessMode` and `DeferableMode` parameters.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有额外的 `AccessMode` 和 `DeferableMode` 参数。
- en: We can pass our object, `UserRec`, as our `Data` `jsonb` column.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以将我们的对象 `UserRec` 作为 `Data` `jsonb` 列传递。
- en: The access and deferable modes add extra constraints that are not available
    directly with the standard library.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 访问模式和可延迟模式增加了额外的约束，这些约束在标准库中无法直接使用。
- en: Using `jsonb` is a boon. Now, we can do searches on our tables with `WHERE`
    clauses that can filter on the `jsonb` field values.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`jsonb`是一个福音。现在，我们可以在我们的表上使用`WHERE`子句进行搜索，这些子句可以过滤`jsonb`字段的值。
- en: You will also notice that `pgx` is smart enough to know our column type and
    automatically convert our `UserRec` into JSON.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会注意到，`pgx`足够聪明，能够识别我们的列类型，并自动将我们的`UserRec`转换为JSON。
- en: If you'd like to know more about Postgres value types, you can visit [https://www.postgresql.org/docs/9.5/datatype.html](https://www.postgresql.org/docs/9.5/datatype.html).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于Postgres值类型的信息，可以访问[https://www.postgresql.org/docs/9.5/datatype.html](https://www.postgresql.org/docs/9.5/datatype.html)。
- en: If you'd like to know more about `jsonb` and functions to access its values,
    visit [https://www.postgresql.org/docs/9.5/functions-json.html](https://www.postgresql.org/docs/9.5/functions-json.html).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于`jsonb`以及访问其值的函数，可以访问[https://www.postgresql.org/docs/9.5/functions-json.html](https://www.postgresql.org/docs/9.5/functions-json.html)。
- en: Other options
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他选项
- en: Besides the standard library and database-specific packages are **Object-Relational
    Mappings** (**ORMs**). ORMs are a popular model for managing data between your
    services and data storage.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 除了标准库和特定数据库的包之外，**对象关系映射**（**ORMs**）也是常见的工具。ORM是管理服务和数据存储之间数据的流行模式。
- en: 'Go''s most popular ORM is called **GORM**, which can be found here: [https://gorm.io/index.html](https://gorm.io/index.html).'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Go最流行的ORM叫做**GORM**，你可以在这里找到：[https://gorm.io/index.html](https://gorm.io/index.html)。
- en: 'Another popular framework that also includes support for REST and web services
    is Beego, which you can find here: [https://github.com/beego/beego](https://github.com/beego/beego).'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个流行的框架是Beego，它也包括对REST和Web服务的支持，你可以在这里找到：[https://github.com/beego/beego](https://github.com/beego/beego)。
- en: Storage abstractions
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 存储抽象
- en: 'Many developers are tempted to use storage systems directly in their code,
    passing around a connection to a database. This is not optimal in that it can
    cause problems when you need to do the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 许多开发者倾向于直接在代码中使用存储系统，传递一个数据库连接。这并不是最优的做法，因为它可能会导致以下问题：
- en: Add caching layers before storage access.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在存储访问之前添加缓存层。
- en: Migrate to a new storage system for your service.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的服务迁移到一个新的存储系统。
- en: Abstracting storage behind an internal **Application Programming Interface**
    (**API**) of interfaces will allow you to change storage layers later by simply
    implementing the interfaces with the new backend. You can then plug in the new
    backend at any time.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象存储在一个内部**应用程序编程接口**（**API**）接口的背后将允许你通过简单地实现接口并使用新的后端，来以后更换存储层。你可以随时插入新的后端。
- en: 'A simple example of this might be adding an interface for getting user data:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个简单的例子，可能是为获取用户数据添加一个接口：
- en: '[PRE13]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This interface allows you to implement your storage backend using Postgres,
    local files, SQLite, Azure Cosmos DB, in-memory data structures, or any other
    storage medium.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个接口允许你使用Postgres、本地文件、SQLite、Azure Cosmos DB、内存数据结构或任何其他存储介质来实现你的存储后端。
- en: This has the benefit of allowing migration from one storage medium to another
    by plugging in a new implementation. As a side benefit, you can decouple tests
    from using a database. Instead, most tests can use an in-memory data structure.
    This allows you to test your functionality without bringing up and tearing down
    infrastructure, which would be necessary with a real database.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做的好处是能够通过插入一个新的实现来实现从一个存储介质到另一个存储介质的迁移。作为附加好处，你可以将测试与数据库解耦。大多数测试可以使用内存数据结构，这样可以测试你的功能，而无需启动和拆除基础设施，这对于真实数据库是必要的。
- en: Adding a cache layer becomes a simple exercise of writing a `UserStorage` implementation
    that calls the cache on reads and when not found calls your data store implementation.
    You can replace the original and everything keeps working.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 添加缓存层变成了一个简单的练习，只需要编写一个`UserStorage`实现，它在读取时调用缓存，当缓存中未找到时，调用你的数据存储实现。你可以替换原有实现，一切保持正常工作。
- en: Note that everything described here for abstraction behind an interface applies
    to access to service data. A SQL API should only be used for your application
    to store and read data. Other services should use a stable RPC interface. This
    provides the same type of abstraction, allowing you to move data backends without
    migrating users.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里描述的所有关于通过接口进行抽象的内容适用于对服务数据的访问。SQL API应该仅用于您的应用程序存储和读取数据。其他服务应使用稳定的RPC接口。这提供了相同类型的抽象，使您可以在不迁移用户的情况下更改数据后端。
- en: Case study – data migration of an orchestration system – Google
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 案例研究——一个编排系统的数据迁移——Google
- en: One of the systems I was involved with during my tenure at Google was an orchestration
    system for automating network changes. The system received automation instructions
    and executed them against various targets. These operations might involve pushing
    files via **Secure File Transfer Protocol** (**SFTP**), interacting with network
    routers, updating authoritative data stores, or running state verifications.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在我任职于Google期间，我参与的一个系统是用于自动化网络变更的编排系统。该系统接收自动化指令并执行这些指令，针对各种目标进行操作。这些操作可能包括通过**安全文件传输协议**（**SFTP**）推送文件、与网络路由器交互、更新权威数据存储或运行状态验证。
- en: With operations, it is critical that data representing the state of a workflow
    is always up to date. This includes not only the currently running workflows but
    also the states of previous workflows, which are used to create new workflows.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作中，确保表示工作流状态的数据始终是最新的至关重要。这不仅包括当前正在运行的工作流，还包括用于创建新工作流的先前工作流的状态。
- en: To ease our operational burden, we wanted to move the storage system for workflows
    from Bigtable to Spanner. Bigtable required a more complicated setup to handle
    failover to a backup cell when problems occurred, while Spanner was designed to
    handle this as part of the system design. This removed the need for us to intervene
    when cells had problems.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减轻我们的操作负担，我们希望将工作流的存储系统从Bigtable迁移到Spanner。Bigtable需要更复杂的设置来处理发生问题时的故障切换到备份单元，而Spanner的设计就包括了这一功能。这使我们在单元出现问题时无需干预。
- en: The storage layer was hidden behind a storage interface. Storage was initialized
    in our `main()` and passed around to other modules that required it. This meant
    that we could replace the storage layer with a new implementation.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 存储层被隐藏在存储接口背后。存储在我们的`main()`函数中初始化，并传递给其他需要它的模块。这意味着我们可以用新的实现替换存储层。
- en: We implemented a new storage interface that wrote data to both Bigtable and
    Spanner while reading from them both, using the latest data stamp and updating
    the records if needed.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个新的存储接口，将数据同时写入Bigtable和Spanner，并从它们两个中读取数据，使用最新的数据戳，并在需要时更新记录。
- en: This allowed us to operate using both data stores while our historical data
    was being transferred. Once synchronization was complete, we moved our binaries
    to a version that only had a Spanner implementation. Our migration was complete
    with no service downtime while thousands of critical operations were running.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们在历史数据传输期间可以同时使用两个数据存储。一旦同步完成，我们将二进制文件迁移到仅包含Spanner实现的版本。我们的迁移完成了，且在成千上万的关键操作运行时没有发生服务停机。
- en: So far in this chapter, we have learned about how to use `database/sql` to access
    generic data stores and Postgres specifically. We learned how to read and write
    to Postgres and implement transactions. The benefits of using `database/sql` versus
    a database-specific library such as `pgx` were discussed. And finally, we showed
    how hiding your implementations behind interface abstractions can allow you to
    change storage backends more easily and test code relying on storage hermetically.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经学习了如何使用`database/sql`访问通用数据存储，并特别讨论了Postgres。我们学习了如何读取和写入Postgres，并实现事务。我们还讨论了使用`database/sql`与使用数据库特定库（如`pgx`）之间的优劣。最后，我们展示了如何通过将实现隐藏在接口抽象背后，使您能够更轻松地更改存储后端，并对依赖于存储的代码进行封闭测试。
- en: Next, we will look into accessing RPC services using REST or gRPC.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将研究如何使用REST或gRPC访问RPC服务。
- en: Developing REST services and clients
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发REST服务和客户端
- en: Before the web and distributed systems that now permeate the cloud space, standards
    for communicating between systems were not in widespread use. This communication
    is often called an RPC. This simply means that a program on one machine has a
    method to call a function running on a different machine and receive any output.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在互联网和现如今充斥云空间的分布式系统之前，系统间通信的标准并未广泛应用。这种通信通常称为 RPC。简单来说，这意味着一台机器上的程序调用运行在另一台机器上的函数并接收输出。
- en: Monolithic applications were the norm and servers tended to either be silo'd
    per application and vertically scaled or were run as jobs on larger, more specialized
    hardware from companies such as IBM, Sun, SGI, or Cray. When systems did need
    to communicate with each other, they tended to use their own custom wire formats,
    such as what you would see with Microsoft SQL Server.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用曾是常态，服务器通常要么按应用程序进行隔离并垂直扩展，要么作为作业运行在更大、更专业的硬件上，这些硬件来自 IBM、Sun、SGI 或 Cray
    等公司。当系统需要相互通信时，它们往往使用自己的定制协议格式，例如你在 Microsoft SQL Server 中看到的格式。
- en: With the web defining the internet of the 2000s, large monolithic systems could
    not provide the compute power behind services such as Google Search or Facebook
    at any reasonable cost point. To power these services, companies needed to treat
    large collections of standard PCs as a single system. Where a single system could
    communicate between processes using Unix sockets or shared memory calls, companies
    needed common and secure ways to communicate between processes running on different
    machines.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 2000 年代互联网的定义，单体大系统无法以合理的成本为像 Google 搜索或 Facebook 这样的服务提供计算能力。为了为这些服务提供支持，企业需要将大量标准
    PC 视为一个整体系统。单一系统可以使用 Unix 套接字或共享内存调用在进程之间进行通信，但企业需要在不同机器上运行的进程之间有共同且安全的通信方式。
- en: As HTTP became the de facto standard for communication between systems, RPC
    mechanisms of today use some form of HTTP for data transport. This allows the
    RPC to transit systems more easily, such as load balancers, and easily utilize
    security standards, such as **Transport Layer Security** (**TLS**). It also means
    that as the HTTP transport is upgraded, these RPC frameworks can leverage the
    hard work of hundreds if not thousands of engineers.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 HTTP 成为系统间通信的事实标准，当今的 RPC 机制使用某种形式的 HTTP 来进行数据传输。这使得 RPC 可以更轻松地穿越系统，如负载均衡器，并轻松利用安全标准，如**传输层安全性**（**TLS**）。这还意味着，随着
    HTTP 传输的升级，这些 RPC 框架可以借助数百甚至成千上万名工程师的努力。
- en: In this section, we are going to talk about one of the most popular RPC mechanisms,
    REST. REST uses HTTP calls and whatever messaging format you want, although the
    majority of cases use JSON for messaging.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将讨论最流行的 RPC 机制之一——REST。REST 使用 HTTP 调用和你选择的任何消息格式，尽管大多数情况下使用 JSON 作为消息格式。
- en: REST for RPCs
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于 RPC 的 REST
- en: Writing REST clients in Go is fairly simple. Chances are that if you have been
    developing applications in the last 10 years, you have either used a REST client
    or written one. Cloud APIs for services such as Google Cloud Platform's Cloud
    Spanner, Microsoft's Azure Data Explorer, or Amazon DynamoDB use REST to communicate
    with the services via their client libraries.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中编写 REST 客户端相当简单。如果你在过去的 10 年里一直在开发应用程序，那么你要么已经使用过 REST 客户端，要么已经编写过一个。像
    Google Cloud Platform 的 Cloud Spanner、Microsoft 的 Azure Data Explorer 或 Amazon
    DynamoDB 等云服务的 API 都使用 REST 通过它们的客户端库与服务进行通信。
- en: 'REST clients can do the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: REST 客户端可以执行以下操作：
- en: Use `GET`, `POST`, `PATCH`, or any other type of HTTP method.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `GET`、`POST`、`PATCH` 或任何其他类型的 HTTP 方法。
- en: Support any serialization format (although this is normally JSON).
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持任何序列化格式（尽管通常是 JSON）。
- en: Allow for data streaming.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许数据流传输。
- en: Support query variables.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持查询变量。
- en: Support multiple versions of an API using URL standards.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 URL 标准支持多个版本的 API。
- en: REST in Go also has the luxury of not requiring any framework to implement on
    the server side. Everything that is required lives in the standard library.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Go 中的 REST 也不需要任何框架即可在服务器端实现。所需的一切都包含在标准库中。
- en: Writing a REST client
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写一个 REST 客户端
- en: Let's write a simple REST client that accesses a server and receives a `POST`
    – `/v1/qotd`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一个简单的 REST 客户端，访问服务器并接收一个 `POST` 请求 – `/v1/qotd`。
- en: 'First, let''s define the message we need to send to the server:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义需要发送到服务器的消息：
- en: '[PRE14]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Let''s talk about what each of these does:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来讨论一下这些操作的作用：
- en: '`getReq` details the arguments to the server''s `/v1/qotd` function call.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getReq` 详细说明了服务器 `/v1/qotd` 函数调用的参数。'
- en: '`getResp` is what we expect as a return from the server''s function call.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getResp`是我们期望从服务器函数调用中返回的内容。'
- en: 'We are using field tags to allow conversion from lowercase keys into our public
    variables that are capitalized. For the `encoding/json` package to see these values
    for serialization, they must be public. Private fields will not be serializable:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用字段标签来允许将小写键转换为我们的公共变量（这些变量首字母大写）。为了让`encoding/json`包能看到这些值并进行序列化，它们必须是公共的。私有字段将无法被序列化：
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This defines a custom error type. This way, we can store error codes to return
    to the user. This code is defined next to our response object, but it isn't used
    until much later in the code we are defining.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个自定义错误类型。通过这种方式，我们可以存储错误代码并返回给用户。这个代码在我们的响应对象旁边定义，但直到稍后的代码中才会使用。
- en: 'Let''s now define a QOTD client and a constructor that does some basic checks
    on the address and creates an HTTP client to allow us to send data to the server:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义一个QOTD客户端和一个构造函数，进行一些基本的地址检查并创建一个HTTP客户端，以便我们能够向服务器发送数据：
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The next step is to make a generic function for making REST calls. Because
    REST is so open-ended, it is hard to make one that can handle any type of REST
    call. A best practice to use when writing REST servers is to only support the
    `POST` method; never use query variables and simple URLs. However, in practice,
    you will deal with a wide variety of REST call types if you don''t control the
    service:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个通用函数，用于进行REST调用。由于REST非常开放，难以编写一个可以处理所有类型REST调用的函数。编写REST服务器时的最佳实践是只支持`POST`方法；永远不要使用查询变量和简单的URL。然而，在实际应用中，如果你不控制服务，你将处理各种各样的REST调用类型：
- en: '[PRE17]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This code does the following:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码执行了以下操作：
- en: 'Checks our context for a deadline:'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查我们的上下文是否有截止时间：
- en: If it has one, it is honored
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果它有值，则会被尊重。
- en: If not, a default one is set
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有设置，则会设置一个默认值。
- en: '`cancel()` is called after the call is done'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在调用完成后，调用`cancel()`。
- en: Marshals a request into JSON.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将请求转换为JSON。
- en: 'Creates a new `*http.Request` that does the following:'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的`*http.Request`，执行以下操作：
- en: Uses the `POST` method
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`POST`方法。
- en: Talks to an endpoint
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与端点进行通信。
- en: Has `io.Reader` storing the JSON request
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有一个`io.Reader`，用于存储JSON请求。
- en: Uses the client to send a request and get a response.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用客户端发送请求并获取响应。
- en: Retrieves the response from the body of `http.Response`.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`http.Response`的正文中获取响应。
- en: Unmarshals JSON into the response object.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将JSON反序列化为响应对象。
- en: You will notice that `req` and `resp` are both `interface{}`. This allows us
    to use this routine with any struct that will represent a JSON request or response.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到`req`和`resp`都是`interface{}`类型。这使得我们可以将这个例程与任何表示JSON请求或响应的结构体一起使用。
- en: 'Now, we will use that in a method that gets a QOTD by an author:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在一个方法中使用它，通过作者获取QOTD（每日名言）：
- en: '[PRE18]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This code does the following:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码执行了以下操作：
- en: Defines an endpoint for our `get` function on the server.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的`get`函数定义一个端点。
- en: 'Calls our `restCall()` method, which does the following:'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用我们的`restCall()`方法，执行以下操作：
- en: Uses `path.Join()` to unite our server address and URL endpoint.
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`path.Join()`将我们的服务器地址和URL端点连接起来。
- en: Creates a `getReq` object as the `req` argument of `restCall()`.
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`getReq`对象作为`restCall()`的`req`参数。
- en: Reads the response into our `resp` response object.
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将响应读取到我们的`resp`响应对象中。
- en: If `*http.Client` returns an error, we return that error.
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`*http.Client`返回一个错误，我们就返回那个错误。
- en: If `resp.Error` is set, we return it.
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`resp.Error`被设置，我们返回它。
- en: Returns the response's quote.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回响应中的引用内容。
- en: 'To see this running now, you can go here: [https://play.golang.org/p/Th0PxpglnXw](https://play.golang.org/p/Th0PxpglnXw).'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看它的运行效果，你可以访问这里：[https://play.golang.org/p/Th0PxpglnXw](https://play.golang.org/p/Th0PxpglnXw)。
- en: We have shown how to make a base REST client here using HTTP `POST` calls and
    JSON. However, we have only scratched the surface of making a REST client. You
    may need to add authentication to the header in the form of a **JSON Web Token**
    (**JWT**). This used HTTP and not HTTPS, so there was no transport security. We
    did not try to use compression such as Deflate or Gzip.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里展示了如何使用HTTP `POST`请求和JSON来创建一个基础的REST客户端。然而，我们仅仅触及了创建REST客户端的表面。你可能需要向头部添加认证信息，使用**JSON
    Web Token**（**JWT**）。这使用了HTTP而不是HTTPS，因此没有传输安全性。我们没有尝试使用压缩，如Deflate或Gzip。
- en: 'While using `http.Client` is easy to do, you may want a more intelligent wrapper
    that handles many of these features for you. One that is worth looking at would
    be `resty`, which can be found here: [https://github.com/go-resty/resty](https://github.com/go-resty/resty).'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用`http.Client`很容易，但你可能需要一个更智能的封装器，它为你处理这些功能。值得一看的一个库是`resty`，可以在这里找到：[https://github.com/go-resty/resty](https://github.com/go-resty/resty)。
- en: Writing a REST service
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写一个REST服务
- en: 'Now that we have a client written, let''s write a REST service endpoint that
    can receive the request and send the user the output:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经写好了客户端，接下来我们写一个REST服务端点来接收请求并将输出发送给用户：
- en: '[PRE19]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This code does the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码执行了以下操作：
- en: Creates the server `struct`, `which` will act as our server
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了服务器`struct`，`which`将充当我们的服务器
- en: Uses `*http.Server` to server HTTP content
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`*http.Server`来提供HTTP内容
- en: Has `quotes`, which stores authors as keys and values that are a slice of quotes
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有`quotes`，它存储作者作为键，值是一个名言切片
- en: 'Now, we need a constructor:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个构造函数：
- en: '[PRE20]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This code does the following:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码执行了以下操作：
- en: 'Creates a `newServer` constructor:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个`newServer`构造函数：
- en: This has an argument of `port`, which is the port to run the server on.
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这有一个`port`参数，指定运行服务器的端口。
- en: 'Creates a `server` instance:'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`server`实例：
- en: Makes an instance of `*http.Server` running at `:[port]`
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个`*http.Server`实例，运行在`:[port]`端口上
- en: Populates our `quotes map`
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填充我们的`quotes map`
- en: Adds `*http.ServeMux` to map URLs to methods.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加`*http.ServeMux`来将URL映射到方法。
- en: Note
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: We will create the `qotdGet` method in a moment.
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们稍后将创建`qotdGet`方法。
- en: Creates a method called `start()` that will start our HTTP server.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为`start()`的方法，用于启动我们的HTTP服务器。
- en: '`*http.ServeMux` implements the `http.Handler` interface that is used by `*http.Server`.
    `ServeMux` uses pattern matching to determine which method is called for which
    URL. You can read about pattern-matching syntax here: [https://pkg.go.dev/net/http#ServeMux](https://pkg.go.dev/net/http#ServeMux).'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`*http.ServeMux`实现了`http.Handler`接口，`*http.Server`使用该接口。`ServeMux`通过模式匹配来决定哪个方法与哪个URL匹配。你可以在这里了解模式匹配的语法：[https://pkg.go.dev/net/http#ServeMux](https://pkg.go.dev/net/http#ServeMux)。'
- en: 'Now, let''s create the method to answer our REST endpoint:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个方法来回答我们的REST端点请求：
- en: '[PRE21]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This code does the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码执行了以下操作：
- en: Implements the `http.Handler` interface.
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现了`http.Handler`接口。
- en: 'Reads the HTTP request body and marshals it to our `getReq`:'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取HTTP请求体并将其序列化到我们的`getReq`中：
- en: This uses HTTP error codes with `http.Error()` if the request was bad
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果请求有问题，这段代码会使用`http.Error()`返回HTTP错误代码。
- en: If the request did not contain an "author," randomly chooses an author's quotes.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果请求中没有包含“author”字段，则随机选择一个作者的名言。
- en: 'Otherwise, finds the author and retrieves their quotes:'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，查找作者并获取他们的名言：
- en: If that author did not exist, responds with `getResp` containing an error
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果该作者不存在，则响应`getResp`并包含一个错误信息。
- en: Randomly chooses a quote and returns it to the client.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机选择一句名言并返回给客户端。
- en: 'Now, we have a REST endpoint that can answer our client''s RPCs. You can see
    this code running here: [https://play.golang.org/p/Th0PxpglnXw](https://play.golang.org/p/Th0PxpglnXw).'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了一个REST端点，它能够回答客户端的RPC请求。你可以在这里看到这段代码的运行：[https://play.golang.org/p/Th0PxpglnXw](https://play.golang.org/p/Th0PxpglnXw)。
- en: This just scratches the surface of building a REST service. You can build authentication
    and compression on top of this, performance tracing, and so on
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是构建REST服务的一个简单示例。你可以在此基础上构建认证、压缩、性能追踪等功能。
- en: 'To help with bootstrapping features and removing some boilerplate, here are
    a few third-party packages that might be helpful:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助快速启动并减少一些样板代码，以下是一些可能有用的第三方包：
- en: 'Gin: [https://github.com/gin-gonic/gin](https://github.com/gin-gonic/gin):'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Gin: [https://github.com/gin-gonic/gin](https://github.com/gin-gonic/gin)：'
- en: 'A REST example: [https://golang.org/doc/tutorial/web-service-gin](https://golang.org/doc/tutorial/web-service-gin)'
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个REST示例：[https://golang.org/doc/tutorial/web-service-gin](https://golang.org/doc/tutorial/web-service-gin)
- en: 'Revel: [https://revel.github.io](https://revel.github.io)'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Revel: [https://revel.github.io](https://revel.github.io)'
- en: Now that we have talked about using REST for RPCs, let's take a look at the
    faster alternative that is being adopted by large companies everywhere, gRPC.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论过使用REST进行RPC，那么让我们来看看被全球大公司广泛采用的更快速的替代方案——gRPC。
- en: Developing gRPC services and clients
  id: totrans-242
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发gRPC服务和客户端
- en: gRPC provides an entire framework for RPCs based on HTTP and utilizing Google's
    protocol buffer format, a binary format that can convert into JSON but provides
    both a schema and, in many cases, a 10x performance improvement over JSON.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 提供了一个基于 HTTP 的 RPC 框架，并使用 Google 的协议缓冲区格式，这是一种二进制格式，可以转换为 JSON，但提供了架构，并且在许多情况下比
    JSON 提供了 10 倍的性能提升。
- en: There are other formats in this space, such as Apache's Thrift, Cap'n Proto,
    and Google's FlatBuffers. However, these are not as popular and well supported,
    or satisfy a particular niche, while also being hard to use.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这个领域还有其他格式，例如 Apache 的 Thrift、Cap'n Proto 和 Google 的 FlatBuffers。然而，这些格式并不如协议缓冲区流行且得到广泛支持，或者只满足某些特定领域的需求，而且也较难使用。
- en: gRPC, like REST, is a client/server framework for making RPC calls. Where gRPC
    differs is that it prefers a binary message format called **protocol buffers**
    (**proto** for short).
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 和 REST 一样，是一种客户端/服务器框架，用于发起 RPC 调用。gRPC 的不同之处在于，它更倾向于使用一种叫做**协议缓冲区**（简称**proto**）的二进制消息格式。
- en: This format has a schema stored in a `.proto` file that is used to generate
    the client, server, and messages in a native library for the language of your
    choice using a compiler. When a proto message is marshaled for transport on the
    wire, the binary representation will be the same for all languages.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 该格式有一个存储在 `.proto` 文件中的架构，用于通过编译器生成客户端、服务器和消息，以适应你选择的语言的本地库。当 proto 消息被序列化用于在网络上传输时，二进制表示在所有语言中都是一样的。
- en: Let's talk more about protocol buffers, gRPC's message format of choice.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解协议缓冲区，gRPC 选择的消息格式。
- en: Protocol buffers
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协议缓冲区
- en: 'Protocol buffers define RPC messages and services in one location and can generate
    a library for every language with the proto compiler. Protocol buffers have the
    following advantages:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 协议缓冲区在一个位置定义 RPC 消息和服务，并可以使用 proto 编译器为每种语言生成一个库。协议缓冲区具有以下优点：
- en: They write once and generate for every language.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们编写一次，生成适用于每种语言的代码。
- en: Messages can be converted to JSON as well as binary.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息可以转换为 JSON 以及二进制格式。
- en: gRPC can use a reverse proxy to provide REST endpoints, which is great for web
    apps.
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: gRPC 可以使用反向代理来提供 REST 端点，这对于 Web 应用程序来说非常好。
- en: Binary protocol buffers are smaller and can encode/decode at 10x the rate of
    JSON.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 二进制协议缓冲区更小，且编码/解码速度是 JSON 的 10 倍。
- en: 'However, protocol buffers do have some negatives:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，协议缓冲区也有一些缺点：
- en: You must regenerate the messages on any change to the `.proto` file to get the
    changes.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你必须在对 `.proto` 文件进行任何更改后重新生成消息，才能获得更改。
- en: Google's standard proto compiler is painful and confusing to use.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google 的标准 proto 编译器使用起来既痛苦又令人困惑。
- en: JavaScript does not have native support for gRPC, even though it supports protocol
    buffers.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 原生不支持 gRPC，尽管它支持协议缓冲区。
- en: Tooling can help with some of the negatives, and we will be using the new **Buf**
    tools, [https://buf.build](https://buf.build), to help with proto generation.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 工具可以帮助解决一些负面问题，我们将使用新的**Buf**工具，[https://buf.build](https://buf.build)，来帮助生成
    proto 文件。
- en: 'Let''s take a look at what a protocol buffer `.proto` file looks like for a
    QOTD service:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个用于 QOTD 服务的协议缓冲区 `.proto` 文件长什么样：
- en: '[PRE22]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `syntax` keyword defines which version of the proto language we are using.
    The most common version is `proto3`, the third iteration of the language. All
    three have the same wire format but have different feature sets and generate different
    language packages.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`syntax` 关键字定义了我们正在使用的 proto 语言的版本。最常见的版本是 `proto3`，它是该语言的第三个版本。三者的 wire 格式相同，但具有不同的特性集，且生成不同的语言包。'
- en: '`package` defines the proto package name, which allows this protocol buffer
    to be imported by another package. We have put `[repo]` as a placeholder to represent
    the GitHub repository.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`package` 定义了 proto 包名，这使得该协议缓冲区可以被其他包导入。我们用 `[repo]` 作为占位符来表示 GitHub 仓库。'
- en: '`go_package` defines the package name specifically when generating Go files.
    While this is marked as `option`, it is not optional when compiling for Go.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '`go_package` 在生成 Go 文件时专门定义了包名。尽管这被标记为 `option`，但在为 Go 编译时它是必需的。'
- en: '`message` defines a new message type, which in Go is generated as `struct`.
    Entries inside `message` detail the fields. `string author = 1` creates a field
    in `struct` `GetReq` called `Author` of the `string` type. `1` is the field position
    in the proto. You cannot have repeated field numbers in a message, a field number
    should never change, and a field should not be removed (although it can be deprecated).'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`message`定义了一种新的消息类型，在Go中被生成为`struct`。`message`中的条目详细说明了字段。`string author =
    1`在`struct` `GetReq`中创建了一个名为`Author`的`string`类型字段。`1`是proto中的字段位置。你不能在消息中有重复的字段号，字段号永远不应该更改，字段也不应该被删除（尽管可以弃用）。'
- en: '`service` defines a gRPC service with one RPC endpoint, `GetQOTD`. This call
    receives `GetReq` and returns `GetResp`.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`service`定义了一个gRPC服务，包含一个RPC端点`GetQOTD`。这个调用接收`GetReq`并返回`GetResp`。'
- en: Now that we have defined this protocol buffer file, we can use a proto compiler
    to generate packages for languages we are interested in. This will include all
    of our messages and the code needed to use the gRPC client and server.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经定义了这个协议缓冲文件，我们可以使用proto编译器为我们感兴趣的语言生成相应的包。这将包含我们所有的消息以及使用gRPC客户端和服务器所需的代码。
- en: Let's look at generating the Go packages from the protocol buffer file.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下如何从协议缓冲文件生成Go包。
- en: Stating the prerequisites
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 说明先决条件
- en: 'To use protocol buffers in this tutorial, you will need to install the following:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中使用协议缓冲时，您需要安装以下内容：
- en: 'The protocol buffer compiler: [https://grpc.io/docs/protoc-installation/](https://grpc.io/docs/protoc-installation/)'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协议缓冲编译器：[https://grpc.io/docs/protoc-installation/](https://grpc.io/docs/protoc-installation/)
- en: 'The Go plugins for the compiler: [https://grpc.io/docs/languages/go/quickstart/](https://grpc.io/docs/languages/go/quickstart/)'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go编译器插件：[https://grpc.io/docs/languages/go/quickstart/](https://grpc.io/docs/languages/go/quickstart/)
- en: 'The Buf tooling: [https://docs.buf.build/installation](https://docs.buf.build/installation)'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Buf工具：[https://docs.buf.build/installation](https://docs.buf.build/installation)
- en: With these installed, you will be able to generate code for C++ and Go. Other
    languages require additional plugins.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 安装了这些之后，您将能够为C++和Go生成代码。其他语言需要额外的插件。
- en: Generating your packages
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成您的包
- en: 'The first file we need to create is the `buf.yaml` file. We can generate the
    `buf.yaml` file inside the `proto` directory by entering it and issuing the following
    command:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建的第一个文件是`buf.yaml`文件。我们可以通过进入`proto`目录并执行以下命令来生成`buf.yaml`文件：
- en: '[PRE23]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This should generate a file that has the following content:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该生成一个包含以下内容的文件：
- en: '[PRE24]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next, we need a file that tells us what output to generate. Create a file called
    `buf.gen.yaml` and give it the following contents:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个文件来告诉我们生成什么输出。创建一个名为`buf.gen.yaml`的文件，并给它以下内容：
- en: '[PRE25]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This indicates that we should generate our `go` and `go-grpc` files in the same
    directory as our `.proto` file.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 这表示我们应该在与`.proto`文件相同的目录中生成`go`和`go-grpc`文件。
- en: 'Now, we should test that our proto will build. We can do this by issuing the
    following command:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们应该测试我们的proto文件是否能成功构建。我们可以通过执行以下命令来做到这一点：
- en: '[PRE26]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If there is no output, then our proto file should compile. Otherwise, we will
    get a list of errors that we need to fix.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有输出，那么我们的proto文件应该能够成功编译。否则，我们将得到一个错误列表，需要我们去修复。
- en: 'Finally, let''s generate our proto files:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们生成我们的proto文件：
- en: '[PRE27]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'If you named the proto file `qotd.proto`, this should generate the following:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将proto文件命名为`qotd.proto`，这将生成以下内容：
- en: '`qotd.pb.go`, which will contain all your messages'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qotd.pb.go`，它将包含你所有的消息'
- en: '`qotd_grpc.pb.go`, which will contain all the gRPC stubs'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`qotd_grpc.pb.go`，它将包含所有的gRPC存根'
- en: Now that we have our proto package, let's build a client.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了proto包，让我们构建一个客户端。
- en: Writing a gRPC client
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写一个gRPC客户端
- en: 'In the root folder of your repository, let''s create two directories:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在您仓库的根目录中，让我们创建两个目录：
- en: '`client/`, which will hold our client code'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`client/`，它将包含我们的客户端代码'
- en: '`internal/server/`, which will hold our server code'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`internal/server/`，它将包含我们的服务器代码'
- en: 'Now, let''s create a `client/client.go` file with the following:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个`client/client.go`文件，内容如下：
- en: '[PRE28]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is a simple wrapper around the generated client with our connection to
    the server established in our `New()` constructor:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这是围绕生成的客户端的一个简单包装，我们通过`New()`构造函数建立了与服务器的连接：
- en: '`grpc.Dial()` connects to the server''s address:'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grpc.Dial()`连接到服务器的地址：'
- en: '`grpc.WithInsecure()` allows us to not use TLS. (In real services, you need
    to use TLS!)'
  id: totrans-299
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grpc.WithInsecure()`允许我们不使用TLS。（在实际服务中，您需要使用TLS！）'
- en: '`pb.NewQOTDClient()` takes a gRPC connection and returns our generated client.'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pb.NewQOTDClient()`接受一个gRPC连接并返回我们生成的客户端。'
- en: '`QOTD()` uses the client to make a call defined in our `GetQOTD()` proto:'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This defines a timeout if one was not defined. The server receives this timeout.
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This uses the generated client to call the server.
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a wrapper to use as a client isn't strictly required. Many developers
    prefer to have the user directly interact with the service using the generated
    client.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: In our opinion, this is fine for simple clients. More complicated clients generally
    should ease the burden by either moving logic to the server or having custom client
    wrappers that are more language-friendly.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have defined a client, let's create our server package.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: Writing a gRPC server
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create a server file at `internal/server/server.go`.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add the following content:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This code does the following:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'Defines our API server:'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pb.UnimplementedQOTDServer` is a generated interface that contains all the
    methods that our server must implement. This is required.'
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`addr` is the address our server will run on.'
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`quotes` contains quotes the server is storing.'
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Defines a `New()` constructor:'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This creates an instance of our `API` server.
  id: totrans-317
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This registers the instance with our `grpcServer`.
  id: totrans-318
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s add methods to start and stop our `API` server:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This code does the following:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'Defines `Start()` to start our server, which does the following:'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses `Mutex` to prevent stops and starts concurrently
  id: totrans-323
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a TCP listener on the address passed in `New()`
  id: totrans-324
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Starts the gRPC server using our listener
  id: totrans-325
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Defines `Stop()` to stop our server, which does the following:'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses `Mutex` to prevent stops and starts concurrently
  id: totrans-327
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Tells the gRPC server to stop gracefully
  id: totrans-328
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s implement the `GetQOTD()` method:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This code does the following:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Defines the `GetQOTD()` method that the client will call
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Includes similar logic to our REST server
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses gRPC's error type defined in the `google.golang.org/grpc/status` package
    to return gRPC error codes
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have our client and server packages, let's create a server binary
    to run our service.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: Creating a server binary
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a file called `qotd.go` that will hold our server''s `main()` function:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This code does the following:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Creates a flag, `addr`, that the caller passes to set the address that the server
    runs on.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates an instance of our server.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writes that we are starting the server.
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starts the server.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the server exists, the error is printed to the screen:'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This might be something saying the port is already in use.
  id: totrans-345
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can run this binary by using this command:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: If you do not pass the `--addr` flag, this will default to `127.0.0.1:80`.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see the following on your screen:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Now, let's create a binary that uses the client to fetch a QOTD.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Creating a client binary
  id: totrans-352
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Create a file called `client/bin/qotd.go`. Then, add the following:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'This code does the following:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Sets up a flag for the address of the server
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sets up a flag for the author of the quote you want
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creates a new instance of `client.QOTD`
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calls the server using the `QOTD()`client method
  id: totrans-359
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prints the results or an error to the terminal
  id: totrans-360
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将结果或错误打印到终端
- en: 'You can run this binary by using this command:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令运行这个二进制文件：
- en: '[PRE36]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This will contact the server running at this address. If you are running the
    server at a different address, you will need to change this to match.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这将联系运行在此地址的服务器。如果你在其他地址运行服务器，你需要更改此地址以匹配。
- en: If you do not pass the `--author` flag, this randomly chooses an author.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有传递`--author`标志，将随机选择一个作者。
- en: 'You should see the following on your screen:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在屏幕上看到以下内容：
- en: '[PRE37]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now we've seen how to use gRPC to make a simple client and server application.
    But this is just the beginning of the features available to you in gRPC.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何使用gRPC创建一个简单的客户端和服务器应用程序。但这只是gRPC功能的开始。
- en: We are just scratching the surface
  id: totrans-368
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们仅仅是刚刚触及表面
- en: 'gRPC is a key piece of infrastructure for cloud technology such as Kubernetes.
    It was built after years of experience with Stubby, Google''s internal predecessor.
    We have only scratched the surface of what gRPC can do. Here are some additional
    features:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC是云技术（如Kubernetes）的关键基础设施组件。它是在多年的Stubby经验后构建的，Stubby是谷歌的内部前身。我们仅仅触及了gRPC可以做的冰山一角。这里有一些额外的功能：
- en: Running a gRPC gateway to export REST endpoints
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行gRPC网关以导出REST端点
- en: Providing interceptors that can deal with security and other needs
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供能够处理安全性和其他需求的拦截器
- en: Providing streaming data
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供流式数据
- en: TLS support
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持TLS
- en: Metadata and trailers for extra information
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于附加信息的元数据和尾部信息
- en: Client-side server load balancing
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端服务器负载均衡
- en: 'Here are just a few of the big companies that have made the switch:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是已经进行切换的一些大型公司：
- en: Square
  id: totrans-377
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Square
- en: Netflix
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Netflix
- en: IBM
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IBM
- en: CoreOS
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CoreOS
- en: Docker
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: CockroachDB
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CockroachDB
- en: Cisco
  id: totrans-383
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cisco
- en: Juniper Networks
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Juniper Networks
- en: Spotify
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spotify
- en: Zalando
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Zalando
- en: Dropbox
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dropbox
- en: Let's talk a little about how best to provide REST or gRPC services inside your
    company.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来聊聊如何在公司内部最佳地提供REST或gRPC服务。
- en: Company-standard RPC clients and servers
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公司标准的RPC客户端和服务器
- en: One of the keys to Google's tech stack success has been a consolidation around
    technologies. While there is certainly a lot of duplication in technology, Google
    standardizes on certain software and infrastructure components. Inside Google,
    it is rare to see a client/server not using Stubby (Google's internal gRPC).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 谷歌技术栈成功的关键之一是围绕技术的整合。尽管技术中确实存在大量重复，谷歌在某些软件和基础设施组件上进行了标准化。在谷歌内部，很少看到不使用Stubby（谷歌的内部gRPC）的客户端/服务器。
- en: 'The libraries that engineers use for RPC are written to work the same in every
    language. In recent years, there have been pushes by **Site Reliability Engineering**
    (**SRE**) organizations to have wrappers around Stubby that offer a breadth of
    features and best practices to prevent every team from reinventing the wheel.
    This includes features such as the following:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 工程师用于RPC的库被编写成在每种语言中都能一致工作。近年来，**站点可靠性工程**（**SRE**）组织推动围绕Stubby构建的包装器，提供一系列功能和最佳实践，以防止每个团队重新发明轮子。这些功能包括：
- en: Authentication
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 身份验证
- en: Compression handling
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩处理
- en: Distributed service rate limiting
  id: totrans-394
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分布式服务速率限制
- en: Retries with backoff (or circuit breaking)
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带回退的重试（或断路器）
- en: This removes a lot of threats to infrastructure by having clients retrying without
    any backoffs, removing the cost of teams figuring out a security model, and allowing
    fixes to these items to be done by experts. Changes to these libraries benefit
    everyone and lower the cost of discovering already-made services.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 通过让客户端在没有回退的情况下重试，这消除了许多基础设施的威胁，去除了团队自行设计安全模型的成本，并允许专家对这些项目进行修复。对这些库的修改使每个人受益，降低了发现已经构建好的服务的成本。
- en: As a DevOps engineer or SRE who likely carries a pager, pushing for standardization
    in your RPC layer can provide innumerable benefits, such as not being paged!
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个可能携带寻呼机的DevOps工程师或SRE，推动RPC层的标准化可以带来无数的好处，例如避免接到寻呼机！
- en: While choice is often seen as a good thing, having limited choices can allow
    development teams and operators to continue to focus on their product and not
    infrastructure, which is key in having robust products.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管选择常常被视为好事，有限的选择可以让开发团队和运维人员继续专注于他们的产品，而不是基础设施，这对于打造健壮的产品至关重要。
- en: 'If you decide on providing a REST framework, here are a few recommended practices:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定提供一个REST框架，以下是一些推荐的实践：
- en: Only use `POST`.
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅使用`POST`。
- en: Do not use query variables.
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用查询变量。
- en: Use JSON only.
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅使用JSON。
- en: Have all arguments inside your request.
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保所有的参数都在你的请求中。
- en: This will greatly reduce the needed code within your framework.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 这将大大减少你在框架中需要编写的代码量。
- en: In this section, we learned what RPC services are and how to write clients using
    two popular methods, REST and gRPC. You also learned how REST has a looser set
    of guidelines while gRPC prefers schema types and generates the components required
    to use the system.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了什么是 RPC 服务以及如何使用两种流行的方法，REST 和 gRPC，来编写客户端。你还了解了 REST 有一套较为宽松的指南，而
    gRPC 更倾向于使用 schema 类型，并自动生成使用系统所需的组件。
- en: Summary
  id: totrans-406
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This ends our chapter on interacting with remote data sources. We looked at
    how to connect to SQL databases with examples using Postgres. We looked at what
    RPCs are and talked about the two most popular types of RPC services, REST and
    gRPC. Finally, we have written servers and clients for both frameworks.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束了我们关于与远程数据源交互的内容。我们讨论了如何通过使用 Postgres 的示例连接到 SQL 数据库，了解了 RPC 是什么，并讨论了两种最流行的
    RPC 服务类型，REST 和 gRPC。最后，我们为这两种框架编写了服务器和客户端。
- en: This chapter has given you the ability to connect to the most popular databases
    and cloud services to get and retrieve data. Now you can write your own RPC services
    to develop cloud applications.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使你能够连接到最流行的数据库和云服务，以获取和检索数据。现在你可以编写自己的 RPC 服务来开发云应用。
- en: In the next chapter, we will utilize this knowledge to build tooling that controls
    jobs on remote machines.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将利用这些知识构建工具，控制远程机器上的任务。
- en: So, without further ado, let's jump into how to write command-line tools.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，不再多说，让我们直接进入如何编写命令行工具。
