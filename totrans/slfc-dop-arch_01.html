<html><head></head><body>
		<div id="_idContainer006">
			<h1 class="chapter-number" id="_idParaDest-14"><a id="_idTextAnchor013"/>1</h1>
			<h1 id="_idParaDest-15"><a id="_idTextAnchor014"/>A Brief History of Deploying Salesforce Changes</h1>
			<p>With Salesforce’s own delivery model coming in the form of three major releases per year, the platform has evolved substantially since it was first made available back in 2000. From its early days as a predominantly sales tool, Salesforce has evolved to become a development platform in its own right. With this change came the need to bring true development best practices to your customizations and the need to deliver <span class="No-Break">them effectively.</span></p>
			<p>In this chapter, we’ll be looking at the history of making and delivering changes on the Salesforce platform, to understand the current shortcomings of the built-in tools. This will help set the context for the necessity of a DevOps process and where the current state of the art sits today. We’ll be covering the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>The beginnings of <span class="No-Break">customizing Salesforce</span></li>
				<li>Apex <span class="No-Break">and Visualforce</span></li>
				<li>Sandboxes and <span class="No-Break">change sets</span></li>
				<li>SFDX and <span class="No-Break">scratch orgs</span></li>
				<li><span class="No-Break">DevOps Center</span></li>
			</ul>
			<p>Unlike the rest of this book, this chapter does not necessarily provide actionable steps or best practice guidance that you can apply to your Salesforce implementations. However, one of the fundamental principles of being a good Salesforce architect is to understand the <em class="italic">why</em> of our decisions. By looking at the history of Salesforce as a development platform, and how it has continued to steer toward contemporary software development approaches and tooling, we can better understand the need for DevOps in the <span class="No-Break">Salesforce ecosystem.</span></p>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>An introduction to the history of Salesforce as a development platform</h1>
			<p>For any sufficiently complex IT system, it is important to consider the full range of architectural considerations in both the implementation phase and the day-to-day running of the system. These considerations are not just technical aspects but those that sit at the business level as well – strong governance, accurate and up-to-date documentation, definable metrics, and a demonstrable return on investment to <span class="No-Break">the business.</span></p>
			<p>As<a id="_idIndexMarker000"/> Salesforce has grown, so has the need to apply these architectural factors to the work we do on the platform. Salesforce has become a <em class="italic">first-class citizen</em> in many organizations, acting as the digital hub to run a business. A proper change management process is therefore critical to avoid interruptions of service, and DevOps<a id="_idIndexMarker001"/> is the perfect approach to that requirement. DevOps promises faster, more accurate software releases, fewer errors, less downtime, and a faster path to recovery when <span class="No-Break">problems occur.</span></p>
			<p>We can reasonably pinpoint Salesforce first becoming a development platform in 2003. At the company’s inaugural edition of Dreamforce, their flagship conference that continues annually to the present day, they announced a fundamental shift in how customers can customize the platform. Dubbed <strong class="bold">sforce 2.0</strong>, it was initially positioned as an <em class="italic">on-demand application server</em> and included <a id="_idIndexMarker002"/>some key capabilities, which we’ll <span class="No-Break">explore next.</span></p>
			<h2 id="_idParaDest-17"><a id="_idTextAnchor016"/>Custom objects</h2>
			<p>The first major<a id="_idIndexMarker003"/> innovation introduced at this time was the ability to create additional custom objects, much like database tables, to complement the built-in objects provided by Salesforce for their core CRM capabilities. These custom objects could themselves contain custom fields and together provided the early framework for developing custom business applications on <span class="No-Break">the platform.</span></p>
			<p>Suddenly, Salesforce had moved from being just a sales CRM system and started moving toward becoming a platform to develop custom business applications. Salesforce teams were now able to start tailoring processes and applications to the core needs of their business, regardless of which industry they worked in. For example, some Salesforce customers would leverage this capability to start building out the ability to handle support cases for their business – something that didn’t become a core platform capability until the announcement of Service Cloud <span class="No-Break">in 2009.</span></p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>S-Controls</h2>
			<p>S-Controls (initially called <em class="italic">sforce controls</em>) were one of the two programmatic elements of the new customization <a id="_idIndexMarker004"/>capabilities. Combining both functionality and user interface elements in one container, S-Controls could contain any items that could be displayed in a browser, such as Java applets, ActiveX controls, and <span class="No-Break">web forms.</span></p>
			<p>While they’ve been long since deprecated, S-Controls were the first method made available for developers to customize the platform in a programmatic way, and they allowed them to bring skillsets and programming languages from other non-Salesforce development into the platform. They enabled Salesforce developers to harness HTML and JavaScript for the creation of custom pages and user interface components. In this sense, they could be potentially viewed as an early forerunner of Lightning Web Components but without much of the best practice we <span class="No-Break">use today.</span></p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>SOQL</h2>
			<p>Sforce 2.0 also<a id="_idIndexMarker005"/> introduced <strong class="bold">Sforce Object Query Language</strong> (<strong class="bold">SOQL</strong>), which provided a means of querying data from both standard and custom objects, with a syntax like the industry standard, SQL. This provided developers with a powerful mechanism with which to query the data in their Salesforce organization programmatically and act upon the results of <span class="No-Break">these queries.</span></p>
			<p>If we were to look at SOQL from an architect’s perspective, we can see how this aligns with the need to ensure that your data quality is of as high a standard as your metadata. Clean, actionable data to drive business decisions should always be one of the key deliverables for an architect. SOQL provided an additional means of working with this data, whether operationally for the day-to-day business or as the beginning of a means to extract data from the platform for archival purposes. This latter use case is something that we’ll explore later as we look at the importance of backups in a well-architected Salesforce <span class="No-Break">DevOps strategy.</span></p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Sforce web services</h2>
			<p>One of the other fundamental <a id="_idIndexMarker006"/>new capabilities of sforce 2.0 was the ability to integrate Salesforce with other platforms, thanks to the exposing of the object model and business logic via web service APIs. Using the standards at the time, SOAP and WSDL, it was now possible to interact with your Salesforce organization from more traditional development environments and systems, over <span class="No-Break">a network.</span></p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>Workflows</h2>
			<p>The last major element introduced with <a id="_idIndexMarker007"/>sforce 2.0 was a business process automation engine called workflows. By defining workflow rules that responded to changes in your data, business logic could be triggered for things such as escalations, notifications, and automatic updates to data in response to events. Workflows were still very much a config, not code, means of delivering functionality, but as we’ll see later, being a low-code solution does not mean that it should be ignored when it comes <span class="No-Break">to DevOps.</span></p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Apex and Visualforce</h2>
			<p>At the 2006 edition of Dreamforce, Salesforce’s flagship conference, co-founder Parker Harris revealed the most significant change to the Salesforce platform to date. Customers were now able to develop custom solutions using Salesforce’s own programming language, called <strong class="bold">Apex</strong>, right within <a id="_idIndexMarker008"/><span class="No-Break">Salesforce itself.</span></p>
			<p>A variant of the popular Java programming language, Apex enabled automation through code for the first time. Originally limited to triggers only, developers could now take a programmatic approach to responding to <span class="No-Break">data changes.</span></p>
			<p>Later in the evolution of the platform, Apex would adopt more of the object-oriented paradigm with the arrival of Apex classes, allowing developers to build a more structured, decoupled implementation than triggers alone <span class="No-Break">could deliver.</span></p>
			<p>Alongside Apex, the other major innovation to the<a id="_idIndexMarker009"/> Salesforce platform was Visualforce, introduced in 2008. Taking cues from other contemporary UI languages such as ASP or PHP, Visualforce blended HTML with programmatic elements and markup that connected back to your logic written in Apex. Visualforce went on to quickly supersede the S-Controls that were previously introduced, becoming the standard way to write custom user interfaces and pages in your <span class="No-Break">Salesforce implementation.</span></p>
			<p>With all these advances in the platform for development and customization, Salesforce then turned its attention to how to deliver them. Let’s look at how this was initially introduced in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor022"/>Sandboxes and change sets</h1>
			<p>As Salesforce continued to mature, the need to be able to safely make changes outside of production and move them across when ready became obvious. However, the pace of DevOps innovation did not seem to keep up with the rise of Salesforce as a <span class="No-Break">development platform.</span></p>
			<p>Sandboxes<a id="_idIndexMarker010"/> were introduced in the winter 2006 release, allowing customers to try out changes and enhancements in a safe environment away from production – but with a catch. The original implementation of sandboxes did not allow you to move those changes <em class="italic">back</em> to production, meaning that you had to recreate those changes again in your production environment manually. This would be both time-consuming <span class="No-Break">and error-prone.</span></p>
			<p>In recognition of this shortcoming, change sets<a id="_idIndexMarker011"/> were initially introduced in beta for the winter 2010 release, some four years after sandboxes, and finally, they became generally available in the Spring 2011 release. Change sets finally allowed the code and configuration work done in sandbox environments to be packaged up and moved between environments, whether from sandbox to sandbox, sandbox to production, or even production to sandbox. This opened up new possibilities to plan Salesforce environments as part of a mature application development life cycle – you could now have dev, QA, UAT, and staging environments ahead of production go-live. This was the first significant step toward achieving a DevOps process that matched those on other <span class="No-Break">development platforms.</span></p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor023"/>Metadata and Tooling APIs</h1>
			<p>To open the platform to better tooling for development and deployment, Salesforce introduced two important APIs – Metadata API<a id="_idIndexMarker012"/> in the Spring 2008 release and Tooling API<a id="_idIndexMarker013"/> in the Spring 2013 release. While they both fulfilled similar functions, there were some important differences in their aims <span class="No-Break">and functionality.</span></p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Metadata API</h2>
			<p>At the simplest level, metadata<a id="_idIndexMarker014"/> is data that describes the <em class="italic">structure</em> of your data, but for the Salesforce platform, that is a bit of an oversimplification. The term <em class="italic">metadata</em> covers many of the configuration and<a id="_idIndexMarker015"/> customization elements of Salesforce as well – at the time of writing, Salesforce’s own Metadata Coverage Report, available<a id="_idIndexMarker016"/> at <a href="https://developer.salesforce.com/docs/metadata-coverage">https://developer.salesforce.com/docs/metadata-coverage</a>, indicates 601 metadata types in the platform, the vast majority of which are covered in <span class="No-Break">Metadata API.</span></p>
			<p>Metadata API can be used to move this metadata between environments. You can retrieve the metadata as XML files from one Salesforce organization and deploy it into another. Much like change sets, the source and target for these operations can be sandboxes, production, or, as we’ll learn about shortly, <span class="No-Break">scratch orgs.</span></p>
			<p>Additionally, Metadata API allows you to create, update, and delete metadata within a Salesforce org, and this unlocks a fundamental capability for both Salesforce development and to adopt a DevOps approach on <span class="No-Break">the platform.</span></p>
			<p>The Metadata API underpins most DevOps tools on the platform, whether that’s Salesforce’s own SFDX, the new DevOps Center, or the various third-party Salesforce DevOps solutions available. They all leverage Metadata API to coordinate the movement of your code and config <span class="No-Break">between environments.</span></p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Tooling API</h2>
			<p>While Metadata API did much of the heavy work of managing metadata, Salesforce introduced Tooling API to provide further capabilities that better aligned to DevOps practices, such as smaller and more focused metadata retrieval and deployment, the ability to run unit tests and view both the test results and the associated code coverage, and support for some additional code <span class="No-Break">debugging capabilities.</span></p>
			<p>Being able to manage unit test cycles makes <a id="_idIndexMarker017"/>Tooling API another strong candidate for use in DevOps processes and tools. As architects, we need to ensure that we not only deliver code <em class="italic">quickly</em> but also that it is of the right quality – it doesn’t break in isolation, it doesn’t break existing code, it fulfills the requirements for which it was created, and it deploys between Salesforce organizations seamlessly. These are all factors of the Change Failure Rate, one of the fundamental DevOps metrics that we’ll explore in the next chapter as we look at what the key considerations to develop a DevOps culture as <span class="No-Break">architects are.</span></p>
			<p>Tooling API is primarily targeted at those wishing to create additional development tools or apps for the platform, and its arrival heralded Salesforce development support in some of the popular IDEs of the day, which we will look <span class="No-Break">at next.</span></p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/>The Force.com IDE and Mavensmate</h1>
			<p>With new tools that <a id="_idIndexMarker018"/>leveraged Metadata and Tooling APIs, it was no longer necessary to develop for the Salesforce platform from within the platform. To assist developers with this approach, Salesforce started looking at how best to deliver a standardized developer experience that matched the<a id="_idIndexMarker019"/> standards of the time. Let’s run through the tools available at <span class="No-Break">that time.</span></p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/>The Force.com IDE</h2>
			<p>One of the early<a id="_idIndexMarker020"/> IDEs that took advantage of this was Salesforce’s own <span class="No-Break">Force.com IDE.</span></p>
			<p>Built on top of the modular plugin architecture of the popular Eclipse development environment that was predominantly used for Java, the Force.com IDE took advantage of the new APIs to allow developers to not only code with a proper editor but also to save their changes back in their development organizations, directly from the IDE, without having to switch back to the Salesforce <span class="No-Break">user interface.</span></p>
			<p>The Force.com IDE became very popular very quickly, as it was the first attempt to provide a modern environment for Salesforce developers, with some of the niceties that developers on other platforms such as Java or .NET had come to expect. However, it developed a reputation for being slow and unstable equally <span class="No-Break">as quickly.</span></p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>Mavensmate</h2>
			<p>As an antidote<a id="_idIndexMarker021"/> to the heavyweight installation of Eclipse and the plugin, and as a potential means to improve speed and stability, 2013 saw the arrival of another development tool for Salesforce – <span class="No-Break">Mavensmate.</span></p>
			<p>Mavensmate took the same plugin approach as the Force.com IDE, in that it effectively extended another editor <a id="_idIndexMarker022"/>called <strong class="bold">Sublime Text</strong> (and later, support was added for the rival Atom editor), but both the underlying editor and the Mavensmate plugin on the top were considerably more lightweight. This made working with Salesforce development easier, faster, and more stable than ever before, and Mavensmate <a id="_idIndexMarker023"/>became the choice of Salesforce developers everywhere on the basis of its speed and ease of use – not just for development but also to deploy changes, thanks to the use of the Metadata and <span class="No-Break">Tooling APIs.</span></p>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/>Introducing SFDX</h1>
			<p>The state of Salesforce change management had largely remained stable for several years. For the majority of Salesforce developers and admins, change sets remained the definitive means of delivering change from sandbox <span class="No-Break">to production.</span></p>
			<p>All this changed again when Salesforce released its SFDX toolchain<a id="_idIndexMarker024"/> in 2018. SFDX offered the promise of modern development and deployment practices, seen on other platforms, delivered through a command-line tool. Suddenly, the potential existed for advanced, scriptable deployments, more robust IDE integration, and a new way to manage changes. Most importantly, it represented the move toward a source-driven development model for Salesforce, rather than the traditional <span class="No-Break">organization-based model.</span></p>
			<p>The SFDX <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>) was<a id="_idIndexMarker025"/> coupled with the introduction of scratch orgs. These are ephemeral development environments that can be spun up and torn down easily from SFDX, created using different configurations (or <em class="italic">org shapes</em>), and populated with test data. The ability to create them from a command lent itself to a new era of automated testing, as we shall see later, but it also reinforced the principle that organizations are now secondary to source code. If a scratch org expires, it’s not a major issue because another one can be easily recreated from the <span class="No-Break">source code.</span></p>
			<p>Finally, Salesforce had recognized the need for tight integration with development tools and provided extensions for the<a id="_idIndexMarker026"/> popular <strong class="bold">Visual Studio</strong> (<strong class="bold">VS</strong>) Code environment, easing both development and deployment on the Salesforce platform, right from the IDE. Additionally, by building on open standards such as the <strong class="bold">Open Command Line Interface Framework</strong> (<strong class="bold">OCLIF</strong>), it <a id="_idIndexMarker027"/>opened the tool up to extension via plugins, which were contributed from both inside and outside Salesforce, extending the capabilities of the SFDX CLI and filling some of the gaps that the tool didn’t <span class="No-Break">cover natively.</span></p>
			<p>SFDX continues<a id="_idIndexMarker028"/> to be the Salesforce-recommended approach for developers working with the platform, especially around integrating it into CI/CD pipelines and other automation. As of December 2022, Salesforce is continuing a drive toward a unified CLI that combines the SFDX command line and the newer SF command line, which introduced a newer structure and a cleaner approach. This consolidation will hopefully result in an even more efficient command-line toolset that will increase the ease of building a robust <span class="No-Break">DevOps pipeline.</span></p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor030"/>DevOps Center</h1>
			<p>Salesforce has long acknowledged that the platform has outgrown change sets, but SFDX was (and still is) perceived by its customers as a tool solely for developers and those comfortable with the command line, despite the VS Code extensions that made it easier to work with. A considerable ecosystem of third-party providers such as Gearset, Copado, AutoRABIT, and Flosum had sprung up to provide platforms for robust <a id="_idIndexMarker029"/>DevOps that better matched the wider IT industry’s best practices. These tools gave Salesforce developers and admins capabilities such as organization-to-organization comparisons, version control capabilities, static code analysis, and <span class="No-Break">deployment pipelines.</span></p>
			<p>Salesforce entered this space with the release of DevOps Center, which became generally available in December 2022. While not as feature-rich as the incumbent solutions from the third-party ecosystem, it represented a change of messaging from Salesforce to all users – a move away from change set deployments to something that was easy enough to work with, whether you were a low-code or pro-code admin <span class="No-Break">or developer.</span></p>
			<p>We’ll be exploring the specifics of DevOps Center (and indeed, the leading solutions in the third-party Salesforce DevOps space) in a later chapter, but it’s important to see how much of a fundamental shift in thinking this new product is, particularly when viewed in the context of the history of creating and delivering changes to the platform <span class="No-Break">described earlier.</span></p>
			<p>DevOps Center introduces much of the best practice in Salesforce DevOps that’s slowly been established, incrementally, over the years and packages it up in an easy-to-understand native interface, right within <span class="No-Break">the platform:</span></p>
			<ul>
				<li>It guides Salesforce practitioners toward a model in which source control is the version of truth for changes, rather than <span class="No-Break">sandbox organizations</span></li>
				<li>It encourages the concept of isolated, incremental change through work items, or user stories – a concept popularized by the agile movement and popular in the DevOps strategy of many other platforms <span class="No-Break">and organizations</span></li>
				<li>Most importantly, it gives<a id="_idIndexMarker030"/> better visibility and accountability for <span class="No-Break">change delivery</span></li>
			</ul>
			<p>These are factors of the overall architecture of a DevOps process, which we shall delve into later in this book. It doesn’t cover every aspect thoroughly in the initial release, and it should very much be considered a DevOps <em class="italic">tool</em> rather than a DevOps <em class="italic">solution</em>, but as a means of educating Salesforce users on the basics of DevOps and weaning them off change sets, it’s a very <span class="No-Break">solid start.</span></p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/>Summary</h1>
			<p>In this chapter, we looked at the history of Salesforce as a development platform and saw how features were added over the years. We also explored the approach to delivering those changes on Salesforce, from change sets, through the various APIs and tools that utilized them, to the arrival of <span class="No-Break">DevOps Center.</span></p>
			<p>Armed with this knowledge, we can not only better appreciate how far the platform has come but also understand the reasoning behind some of the design choices we have today, gaining a little knowledge of older implementations, which can often prove useful when faced with having to work on older <span class="No-Break">Salesforce organizations.</span></p>
			<p>As architects, it’s important to not take DevOps tooling for granted, and having the ability to work with a variety of different approaches and solutions, no matter how old, will help us to work with and improve the state of Salesforce DevOps for the implementations we deliver. In subsequent chapters, we’ll look at some of the most recent tooling and, more importantly, the techniques and processes that shape modern <span class="No-Break">Salesforce DevOps.</span></p>
		</div>
	</body></html>