<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer104">
			<h1 id="_idParaDest-195" class="chapter-number"><a id="_idTextAnchor205"/>8</h1>
			<h1 id="_idParaDest-196"><a id="_idTextAnchor206"/>Packaging and Deploying Code</h1>
			<p><a id="_idTextAnchor207"/>In the previous chapters, you learned how to use GitLab for source code management, as well as to set up CI/CD pipelines that build, test, and perform security scanning against the code you’ve checked in. You have hopefully now developed a confident understanding of both the infrastructure around GitLab CI/CD and the syntax used to <span class="No-Break">author pipelines.</span></p>
			<p>In this chapter, we will continue our journey through the stages of software development, focusing now on packaging and deploying code. We will use a combination of GitLab’s built-in features and common industry tools to deploy our code to an endpoint or environment. The goal is to answer the question, <em class="italic">how do we make the application we have built and tested available to </em><span class="No-Break"><em class="italic">our users?</em></span></p>
			<p>This chapter will introduce new vocabulary, adding to our knowledge of GitLab CI/CD syntax. It will also mention, and the examples will use, third-party tools such as Docker, as well as cloud service providers such as Google Cloud Platform. Since this book’s core focus is on GitLab’s features and we don’t have the space for a technical deep dive into every tool that could be used with GitLab, you may be unfamiliar with some of the technologies referenced in this chapter. We will therefore strive to use industry-standard language, focus on each tool’s integration with GitLab, and provide examples that can be replicated without requiring further knowledge from the reader. After completing this chapter, you will be equipped with the skills needed to use GitLab’s native package and container registry features for hosting completed builds. You will also extend your knowledge of GitLab CI/CD to include deploying to review and production environments, using traditional or <span class="No-Break">cloud-native infrastructures.</span></p>
			<p>Here is how we’ll cover the topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Storing code in GitLab’s package registry for <span class="No-Break">later re-use</span></li>
				<li>Storing code in GitLab’s container and package registries for <span class="No-Break">later deployment</span></li>
				<li>Deploying to different environments using <span class="No-Break">GitLab Flow</span></li>
				<li>Deploying to a review app <span class="No-Break">for testing</span></li>
				<li>Deploying to real-world <span class="No-Break">production environments</span></li>
				<li>Deploying to a <span class="No-Break">Kubernetes cluster</span></li>
			</ul>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor208"/>Technical requirements</h1>
			<p>Like the previous chapters, you’ll get the most out of this chapter if you have an account on a GitLab instance (SaaS or self-managed). Moreover, the topics and examples in this chapter will increasingly focus on deploying to environments that live outside GitLab. The infrastructure tools that are referenced include <span class="No-Break">the following:</span></p>
			<ul>
				<li>A server hosting GitLab (<span class="No-Break">or GitLab.com)</span></li>
				<li>Self-hosted runners (or SaaS runners hosted <span class="No-Break">on GitLab.com)</span></li>
				<li>Docker (also available on SaaS runners hosted <span class="No-Break">on Gitlab.com)</span></li>
				<li><span class="No-Break">Kubernetes</span></li>
				<li>Cloud platform services (such as Amazon Web Services, Google Cloud Platform, <span class="No-Break">or Heroku)</span></li>
			</ul>
			<p>If you wish to minimize the amount of tooling you need to install and maintain yourself, we recommend using GitLab.com with SaaS runners. We also recommend creating an account on a cloud service platform if you wish to practice deploying to live or complex infrastructure. Just be aware of the potential charges when using <span class="No-Break">these services.</span></p>
			<h1 id="_idParaDest-198"><a id="_idTextAnchor209"/>Storing code in GitLab’s package registry for later re-use</h1>
			<p>As part of the goal of serving as<a id="_idIndexMarker619"/> a complete DevOps platform, GitLab includes the option to enable package and container registries in each project. The package registry supports hosting software packages and language packs in a variety of formats, and the container registry serves as a repository of purpose-built container images. These features allow teams to conveniently host, organize, and version-control completed builds alongside their source code. We will discuss the package and container registries <span class="No-Break">in turn.</span></p>
			<h2 id="_idParaDest-199"><a id="_idTextAnchor210"/>Locating GitLab’s container and package registries</h2>
			<p>GitLab projects technically support three types of built-in registries. They are package, container, and infrastructure registries that can be used to store completed code, whether for use by end <a id="_idIndexMarker620"/>users or other software projects. This book will focus on the package and container registries; the infrastructure registry is a recent addition to GitLab that is specifically for hosting Terraform modules. GitLab also supports pushing artifacts to external or third-party registries, though that is beyond the scope of what we will <span class="No-Break">cover here.</span></p>
			<p><span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.1</em> shows where GitLab’s packages and container registries can be found at both the project and group level, under <strong class="bold">Packages and registries</strong> in the left <span class="No-Break">navigation pane.</span></p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/B18073_08_1.jpg" alt="Figure 8.1 – Packages and registries in the left sidebar" width="428" height="920"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Packages and registries in the left sidebar</p>
			<p>When you<a id="_idIndexMarker621"/> hover over <strong class="bold">Packages and registries</strong>, you will see that each of the package, container, and infrastructure registries have a dedicated page to navigate to, as shown in <span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="image/B18073_08_2.jpg" alt="Figure 8.2 – Packages and registries sub-menu items" width="914" height="367"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Packages and registries sub-menu items</p>
			<p>If we have not yet configured or pushed artifacts to any of the registries, we will see an appropriate message <a id="_idIndexMarker622"/>when we navigate to the registry page. <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.3</em> shows the message we see on the <strong class="bold">Package Registry</strong> page, along with a reference to the GitLab documentation for using the <span class="No-Break">package registry.</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="image/B18073_08_3.jpg" alt="Figure 8.3 – Project package registry with no packages" width="1101" height="543"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – Project package registry with no packages</p>
			<p><span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.4</em> shows us an unpopulated <strong class="bold">Container Registry</strong>. Here, GitLab suggests Docker commands we could use to build a containerized version of our application that we then push to the <span class="No-Break">container registry.</span></p>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="image/B18073_08_4.jpg" alt="Figure 8.4 – Project container registry with no container images" width="1100" height="719"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – Project container registry with no container images</p>
			<p>We will soon see that<a id="_idIndexMarker623"/> a typical way to push to GitLab’s registries is to configure CI/CD jobs that execute commands to build an artifact, authenticate it with the registry, and push the artifact to the registry, often using <span class="No-Break">GitLab’s API.</span></p>
			<h2 id="_idParaDest-200"><a id="_idTextAnchor211"/>Getting started with the package registry</h2>
			<p>The package registry is enabled by <a id="_idIndexMarker624"/>default in GitLab, though it can be disabled by GitLab administrators at the instance level. In project settings, you can also choose to toggle the package registry feature on or off under <strong class="bold">Settings</strong> | <strong class="bold">General</strong> | <strong class="bold">Visibility, project features, permissions</strong>. If <strong class="bold">Packages</strong> is toggled off, the feature will not be available in the left sidebar.  <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.5</em> shows where the package registry can be enabled or disabled in the <span class="No-Break">project settings.</span></p>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="image/B18073_08_5.jpg" alt="Figure 8.5 – Enabling the package registry in project settings" width="1247" height="702"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.5 – Enabling the package registry in project settings</p>
			<p>The question now arises, how <a id="_idIndexMarker625"/>do we use the package registry? That is, how do we populate it with our software? There are two primary steps to populate the package registry: authenticate to the registry, and build and upload packages using CI/CD jobs. But before diving into those steps, let’s first list the package formats supported <span class="No-Break">by GitLab.</span></p>
			<h2 id="_idParaDest-201"><a id="_idTextAnchor212"/>Supported package formats</h2>
			<p>As of this writing, the<a id="_idIndexMarker626"/> following package manager formats are generally available and fully supported in GitLab’s <span class="No-Break">package registry:</span></p>
			<ul>
				<li><span class="No-Break">Generic packages</span></li>
				<li><span class="No-Break">Maven</span></li>
				<li><span class="No-Break">npm</span></li>
				<li><span class="No-Break">NuGet</span></li>
				<li><span class="No-Break">PyPI</span></li>
			</ul>
			<p>The following package formats are either behind a feature flag or have known issues with <span class="No-Break">their use:</span></p>
			<ul>
				<li><span class="No-Break">Composer</span></li>
				<li><span class="No-Break">Conan</span></li>
				<li><span class="No-Break">Debian</span></li>
				<li><span class="No-Break">Go</span></li>
				<li><span class="No-Break">Helm</span></li>
				<li><span class="No-Break">Ruby Gems</span></li>
			</ul>
			<p>Each package manager has<a id="_idIndexMarker627"/> its own configuration format and syntax. To maintain consistency, as well as to keep our focus on the concepts underlying GitLab’s package, we will show examples using generic package formats. We will start with authenticating to GitLab’s <span class="No-Break">package registry.</span></p>
			<h2 id="_idParaDest-202"><a id="_idTextAnchor213"/>Authenticating to the registry</h2>
			<p>We mentioned earlier in this<a id="_idIndexMarker628"/> chapter that working with GitLab’s registries takes place largely through CI/CD jobs. The actions of authenticating, uploading to, and using packages from the package registry should be represented by job tasks defined in GitLab CI/CD configurations. In general, you can authenticate to GitLab’s package registry with one of the following four types <span class="No-Break">of credentials:</span></p>
			<ul>
				<li>A personal access token, to authenticate with a <span class="No-Break">user’s permissions</span></li>
				<li>A project deploy token, for accessing all packages in <span class="No-Break">a project</span></li>
				<li>A group deploy token, for accessing all packages in all projects in a group or <span class="No-Break">its subgroups</span></li>
				<li>A job token, for accessing packages in the project for which the CI/CD job <span class="No-Break">is defined</span></li>
			</ul>
			<p class="callout-heading">Deploy tokens and job tokens are not tied to users</p>
			<p class="callout">Unlike personal access tokens, deploy tokens and job tokens are special kinds of GitLab credentials that are not tied to a particular user, but rather can serve as an alternative way to authenticate without specifying user credentials. Deploy tokens and job tokens are often used to programmatically access a repository, or in our case, read and write to the <span class="No-Break">package registry.</span></p>
			<p>In our example, we’ll create a project-level deploy token in the Hats for Cats project. <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.6</em> shows where we can create a new deploy token under project <strong class="bold">Settings</strong> | <strong class="bold">Repository</strong> | <strong class="bold">Deploy Tokens</strong>. Here, we can give the token a human-readable name, an optional expiration <a id="_idIndexMarker629"/>date, and an optional username that’s specific to the token (if we don’t enter an optional username, GitLab will auto-generate one <span class="No-Break">for us).</span></p>
			<p>Finally, we select which permissions we want to grant the token. The permission names can appear slightly ambiguous, but <strong class="source-inline">read_registry</strong> and <strong class="source-inline">write_registry</strong> refer to reading and writing to the <em class="italic">container</em> registry only, while <strong class="source-inline">read_package_registry</strong> and <strong class="source-inline">write_package_registry</strong> refer to reading and writing to the <span class="No-Break">package registry.</span></p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/B18073_08_6.jpg" alt="Figure 8.6 – Creating a new deploy token" width="1054" height="808"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.6 – Creating a new deploy token</p>
			<p>Once we create a deploy token, GitLab will provide a password that we’ll need to save somewhere safe (see <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.7</em>). We will use the deploy token password to authenticate our commands to the package or <span class="No-Break">container registry.</span></p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/B18073_08_7.jpg" alt="Figure 8.7 – Deploy token password" width="1076" height="324"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.7 – Deploy token password</p>
			<p class="callout-heading">Don’t forget to save your deploy token!</p>
			<p class="callout">Be sure to save the password for the deploy token somewhere safe and secure! Once you leave the page, you will not be able to recover the password, as GitLab will not persistently store <span class="No-Break">the credential.</span></p>
			<p>After you finish creating<a id="_idIndexMarker630"/> the deploy token and saving the password, GitLab will show the token and its details under <strong class="bold">Active Deploy Tokens</strong>, as shown in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.8</em>. A project maintainer or owner can choose to revoke the token if it should no longer <span class="No-Break">be used.</span></p>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="image/B18073_08_8.jpg" alt="Figure 8.8 – Active deploy tokens" width="1089" height="201"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.8 – Active deploy tokens</p>
			<p>We can now use the token we created to authenticate to the registry. The exact syntax we’d use for authentication would depend on our package manager, that is, the type of package we are creating or using. In the simplest case, we may include our credentials in the header of a <strong class="source-inline">curl</strong> command, as <span class="No-Break">shown here:</span></p>
			<pre class="console">
curl --user "hfc-generic-build:&lt;deploy token password&gt;" ${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/stable-releases/0.0.1/my_app.tar.gz</pre>
			<p>When run in a CI/CD job, the <a id="_idIndexMarker631"/>preceding command authenticates to the project’s package registry in which the pipeline is running. The authentication credentials are provided by the <strong class="source-inline">--user</strong> flag, where we provide the username and password (shown as a placeholder here) for our deploy key. The output of the command will be to download the <span class="No-Break"><strong class="source-inline">my_app.tar.gz</strong></span><span class="No-Break"> package.</span></p>
			<p>Using a deploy key is a programmatic way to pull or download from the registry. Downloading package files can also be done via the UI. <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.9</em> shows an example of a <strong class="source-inline">stable_releases</strong> package, version 0.0.1, that has been added to the <span class="No-Break">package registry.</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer087" class="IMG---Figure">
					<img src="image/B18073_08_9.jpg" alt="Figure 8.9 – Entry in the package registry" width="1138" height="585"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.9 – Entry in the package registry</p>
			<p>If we click on <strong class="bold">stable_releases</strong>, we see downloadable application files under the <strong class="bold">Assets</strong> heading (see <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.10</em>). We see the filenames (and file types by their extensions), size, and creation date. Selecting the filename downloads the file to your local computer. Under <strong class="bold">History</strong>, we see when it was published to the registry, which pipeline build pushed<a id="_idIndexMarker632"/> the package, which commit launched the pipeline, and the package name <span class="No-Break">and version.</span></p>
			<div>
				<div id="_idContainer088" class="IMG---Figure">
					<img src="image/B18073_08_10.jpg" alt="Figure 8.10 – Package files and build history" width="1100" height="683"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.10 – Package files and build history</p>
			<p>Now that we understand how to authenticate to and access packages in the package registry, we will now use CI/CD jobs to build, push, and update packages in <span class="No-Break">the registry.</span></p>
			<h2 id="_idParaDest-203"><a id="_idTextAnchor214"/>Building and pushing packages to the package registry</h2>
			<p>As we’ve mentioned several times <a id="_idIndexMarker633"/>already, GitLab recommends using CI/CD jobs to build and publish to the registry. Technically, writing to the registry can just take place via API calls, so GitLab CI/CD isn’t strictly required. However, build and artifact management is well suited to GitLab Flow, and it is helpful to have the process standardized in a similar manner to your other software development workflows. For that reason, we will create a CI/CD pipeline to build and push to <span class="No-Break">the registry.</span></p>
			<p>The exact job syntax will be dependent on the programming languages and package managers you use to build software. The GitLab documentation has specific syntax examples for authenticating, reading, and writing to the registry using Python, Maven, and other tools. To keep things conceptual, and because we don’t have the space to showcase every <a id="_idIndexMarker634"/>supported language or tool, we will use generic packages as our example, and our commands will be <strong class="source-inline">curl</strong>-style <span class="No-Break">API calls.</span></p>
			<p>A CI/CD configuration may look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
stages:
  - build
  - publish
build_app:
  stage: build
  script:
    - make my_app
    - tar -czvf my_app.tar.gz .
  artifacts:
    paths:
      - my_app.tar.gz
publish_to_registry:
  stage: publish
  script:
    - $PACKAGE_FILE=$(ls | grep *.tar.gz)
    - curl --user "hfc-generic-build:&lt;deploy token password&gt;" --upload-file my_app.tar.gz "${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/stable_releases/0.0.1/$PACKAGE_FILE"
  dependencies:
    - build_app</pre>
			<p>The preceding example <strong class="source-inline">.gitlab-ci.yml</strong> content contains two stages: a <strong class="source-inline">build</strong> stage that compiles a C-style application and a <strong class="source-inline">publish</strong> stage that pushes the build artifact to the package registry. The <strong class="source-inline">build</strong> stage contains one job that builds our code. We then create an archive file containing the completed build and supporting files. The archive file is specified as an artifact in the build job so that the downstream <strong class="source-inline">publish</strong> job will have access <span class="No-Break">to it.</span></p>
			<p>The <strong class="source-inline">publish_to_registry</strong> job authenticates to the registry and uploads the build artifact. Note the presence of some dynamic CI/CD variables in the <strong class="source-inline">curl</strong> command (that is, the terms<a id="_idIndexMarker635"/> beginning with <strong class="source-inline">CI_</strong>). These variables are a convenient way to reference the correct URL and path to the registry in your project. Note we also categorize the build as a generic package, part of “stable release” <span class="No-Break">version 0.0.1.</span></p>
			<p>We might also add a Unix timestamp to distinguish between different builds in the registry. We can modify the build job as follows to include a timestamp in the <span class="No-Break">artifact filename:</span></p>
			<pre class="source-code">
build_app:
  stage: build
  script:
    - make my_app
    - TIMESTAMP=$(date +%s)
    - tar -czvf my_app_$TIMESTAMP.tar.gz .
  artifacts:
  paths:
    - ./*.tar.gz</pre>
			<p><span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.11</em> shows the updated file asset in the registry. Note the timestamp in the filename in the <strong class="source-inline">tar</strong> command in the build script. The archive size and creation date are also shown. A developer can then click the filename to download the archive, which they can then unpack on their <span class="No-Break">local system.</span></p>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/B18073_08_11.jpg" alt="Figure 8.11 – File in the package registry with a timestamp" width="1196" height="195"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.11 – File in the package registry with a timestamp</p>
			<h2 id="_idParaDest-204"><a id="_idTextAnchor215"/>Building and pushing packages to the container registry</h2>
			<p>GitLab also has a container<a id="_idIndexMarker636"/> registry for storing Docker images. Like the package registry, Docker images can be created and pushed to the registry with CI/CD jobs. Authentication is conceptually similar to the package registry, but you’d use container platform tools such as Docker to authenticate, build, push, and pull <span class="No-Break">container images.</span></p>
			<p>The following Docker command can be used to authenticate to the container registry, using our deploy token from earlier. We will use similar Docker commands to also build a containerized version of our application and push it to <span class="No-Break">the registry:</span></p>
			<pre class="console">
docker login -–username "hfc-generic-build" --password "eBYj_qvLTFSMcFrS-4tA" $CI_REGISTRY</pre>
			<p>Our CI/CD job for “containerizing” our application and pushing it to the registry might look like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
publish_to_container_registry:
  stage: publish
  image: docker:stable
  services:
    - docker:dind
  variables:
    IMAGE: $CI_REGISTRY_IMAGE/my_app/0.0.1
  script:
    - docker login -u "hfc-generic-build" -p "&lt;deploy token password&gt;" $CI_REGISTRY
    - docker build -t $IMAGE .
    - docker push $IMAGE</pre>
			<p>Let’s explain what is happening<a id="_idIndexMarker637"/> in the preceding CI/CD job, step <span class="No-Break">by step:</span></p>
			<ol>
				<li>We name the job <strong class="source-inline">publish_to_container_registry</strong> as part of the<strong class="bold"> </strong><span class="No-Break"><strong class="bold">publish</strong></span><span class="No-Break"> stage.</span></li>
				<li>We then include two containers in the CI/CD job runtime environment: a container with the official Docker tooling (<strong class="source-inline">image: docker:stable</strong>) and a service container with “Docker-in-Docker” tooling (<strong class="source-inline">docker:dind</strong>). The latter container type allows us to build containers inside our already-containerized CI/CD job environment (hence the <span class="No-Break">Docker-</span><span class="No-Break"><em class="italic">in</em></span><span class="No-Break">-Docker moniker).</span></li>
				<li>Next, we define a variable called <strong class="source-inline">IMAGE</strong> that will specify the name of our container image, as well as its destination endpoint in the container registry. The <strong class="source-inline">IMAGE</strong> variable will be referenced as arguments to the <span class="No-Break"><strong class="source-inline">docker</strong></span><span class="No-Break"> command.</span></li>
				<li>Finally, the script section of our CI/CD job contains <span class="No-Break">three commands:</span><ul><li>The first command, <strong class="source-inline">docker login</strong>, authenticates to the container registry using our <span class="No-Break">deploy token</span></li><li>The second command, <strong class="source-inline">docker build</strong>, builds a containerized version of <span class="No-Break">our application</span></li><li>The final command, <strong class="source-inline">docker push</strong>, then pushes the newly built container image to the <span class="No-Break">container registry</span></li></ul></li>
			</ol>
			<p class="callout-heading">Be careful when building containers with Docker-in-Docker</p>
			<p class="callout">While it’s simple and straightforward, Docker-in-Docker uses the <strong class="source-inline">--docker-privileged</strong> flag by default, which can give the service running the containers root access to the host machine. If this is a security concern, GitLab also provides instructions for using a build tool called <strong class="bold">kaniko</strong> to build <a id="_idIndexMarker638"/>container images from a Dockerfile. See the GitLab documentation for <span class="No-Break">more details.</span></p>
			<p>It turns out that if we just add the preceding job to our CI/CD pipeline configuration and then run the pipeline, the job will fail. That is because we are missing another required component of building a <a id="_idIndexMarker639"/>container image. A file in our repository called <strong class="source-inline">Dockerfile</strong> is required to act as a “recipe” for how our container image will be built and what it should contain. Normally, a Dockerfile will contain instructions such as dependencies that should be installed, services that should be started, or ports that should be open. In this example, we will keep the Dockerfile extremely simple. A very minimal Dockerfile might contain <span class="No-Break">the following:</span></p>
			<pre class="source-code">
FROM alpine:latest
# copy all of the files in this project into the Docker image
RUN mkdir public-app/
ADD . public-app/
WORKDIR public-app</pre>
			<p>The preceding Dockerfile does <span class="No-Break">the following:</span></p>
			<ul>
				<li>It uses a minimal Linux distribution called Alpine Linux as the base operating system for the container we <span class="No-Break">are building</span></li>
				<li>It creates a directory in the container <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">public-app/</strong></span></li>
				<li>It puts all our repository files in the <span class="No-Break"><strong class="source-inline">public-app/</strong></span><span class="No-Break"> directory</span></li>
				<li>It makes <strong class="source-inline">public-app/</strong> the working directory when the container <span class="No-Break">is launched</span></li>
			</ul>
			<p><span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.12</em> shows how our project repository might look after we update our <strong class="source-inline">.gitlab-ci.yml</strong> file and create <span class="No-Break">the Dockerfile.</span></p>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="image/B18073_08_12.jpg" alt="Figure 8.12 – Our repository with the Dockerfile" width="1197" height="659"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.12 – Our repository with the Dockerfile</p>
			<p>Now, when we run a CI/CD pipeline, we<a id="_idIndexMarker640"/> can see the Docker commands represented in the <strong class="source-inline">publish_to_container_registry</strong> job log, as shown in the following screenshot (<span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.13</em>). Notice how the output of the <strong class="source-inline">docker build</strong> command shows it following the recipe we specified in <strong class="source-inline">Dockerfile</strong>. The job script ends with confirmation that the container image was pushed to the project’s <span class="No-Break">container registry.</span></p>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<img src="image/B18073_08_13.jpg" alt="Figure 8.13 – Job log for publishing to the container registry" width="1300" height="941"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.13 – Job log for publishing to the container registry</p>
			<p>Checking the container<a id="_idIndexMarker641"/> registry, we in fact see a reference to the container name as we specified in the CI/CD job (<span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.14</em></span><span class="No-Break">).</span></p>
			<div>
				<div id="_idContainer092" class="IMG---Figure">
					<img src="image/B18073_08_14.jpg" alt="Figure 8.14 – Image repository in the container registry" width="1182" height="578"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.14 – Image repository in the container registry</p>
			<p>If we click on the <a id="_idIndexMarker642"/>container name, we can see the builds themselves (<span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.15</em></span><span class="No-Break">).</span></p>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<img src="image/B18073_08_15.jpg" alt="Figure 8.15 – Latest artifact in the project container registry" width="1197" height="591"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.15 – Latest artifact in the project container registry</p>
			<p>So far, everything we<a id="_idIndexMarker643"/> have discussed covers finding, authenticating to, and writing to GitLab’s package and container registries. In the next section of this chapter, we will actually use and deploy the assets we have created <span class="No-Break">and uploaded.</span></p>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor216"/>Storing code in GitLab’s container and package registries for later deployment</h1>
			<p>GitLab’s package and container registries are useful not only for making software available for users to <a id="_idIndexMarker644"/>download but also for storing packages and libraries<a id="_idIndexMarker645"/> for use in CI/CD pipelines, or for deployment to an environment. In this section, we will discuss how to programmatically interact with the registries via <span class="No-Break">CI/CD jobs.</span></p>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor217"/>Using images from the container registry</h2>
			<p>In the previous section, we <a id="_idIndexMarker646"/>built a containerized version of our app and pushed the image to GitLab’s container registry. Recall that the CI/CD jobs we used to build the container image themselves run in containers, hence the reference to terms such as <strong class="source-inline">docker:stable</strong> and <strong class="source-inline">docker:dnd</strong>. In this example, we are pulling from a public container registry, that is, <span class="No-Break">Docker Hub.</span></p>
			<p>However, we can also pull<a id="_idIndexMarker647"/> container images we have pushed to GitLab’s container registry and use them as the basis for running our CI/CD jobs. We can use them in our pipelines just as we did with public container images, using the <strong class="source-inline">image</strong> keyword, like in the <span class="No-Break">following snippet:</span></p>
			<pre class="source-code">
use_container_from_registry:
  stage: run
  image: registry.gitlab.com/nlotz1/pet-fashion/hats-for-cats/my_app/0.0.1:latest
  script:
    - ls –al      # Show the current directory as our container's working directory</pre>
			<p><span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.16</em> shows our job output when we pull our container from the local registry to run <span class="No-Break">our job.</span></p>
			<p class="IMG---Figure">.</p>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="image/B18073_08_16.jpg" alt="Figure 8.16 – Using a local container in a CI/CD job" width="1056" height="550"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.16 – Using a local container in a CI/CD job</p>
			<p>Note that the job log shows GitLab pulling the image from the container registry, as well as the contents of the container’s filesystem (that is, the files we included when we built the container in the<a id="_idIndexMarker648"/> <span class="No-Break">first place).</span></p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor218"/>Using packages from the package registry</h2>
			<p>Using packages in the<a id="_idIndexMarker649"/> package registry follows a similar theme as publishing packages to the registry. The exact step and syntax for pulling from the registry will depend on the package type. In general, you’ll be required to specify the group and project where the package lives (i.e., the namespace in GitLab), the package name, and the package version. Consistent with the example from earlier, we might use a CI/CD job to pull down and run a generic package from <span class="No-Break">our registry:</span></p>
			<pre class="source-code">
use_package_from_registry:
  stage: run_package
  script:
    - 'wget --header="JOB-TOKEN: $CI_JOB_TOKEN" ${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/stable_releases/0.0.1/my_app_1665515895.tar.gz'
    - tar -xvf my_app_1665515895.tar.gz
    - ./my_app</pre>
			<p>The job log in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.17</em> shows the output of authenticating and pulling down the package file via GitLab’s API. In this example, the package is then extracted from its archive file <span class="No-Break">and run.</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="image/B18073_08_17.jpg" alt="Figure 8.17 – Using the package from the registry in a CI/CD job" width="1042" height="1070"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.17 – Using the package from the registry in a CI/CD job</p>
			<p>GitLab’s documentation <a id="_idIndexMarker650"/>shows different steps to authenticate and download packages for different package managers, but the principles remain <span class="No-Break">the same.</span></p>
			<p>Now that we understand how we can publish download packages in the context of CI/CD jobs, we will next incorporate these steps into a typical GitLab <span class="No-Break">development workflow.</span></p>
			<h1 id="_idParaDest-208"><a id="_idTextAnchor219"/>Deploying to different environments using GitLab Flow</h1>
			<p>We have so far discussed <a id="_idIndexMarker651"/>how to store and use our completed code by publishing to and pulling from GitLab’s package and container registries. Now, we will learn about some of GitLab’s features for organizing deployments of code to <span class="No-Break">particular environments.</span></p>
			<p>GitLab has<a id="_idIndexMarker652"/> two terms, <strong class="bold">environments</strong> and <strong class="bold">deployments</strong>, that are used to describe <a id="_idIndexMarker653"/>and categorize the location and version of a deployed application. An environment is represented by a name and a URL, which serve as organizational labels inside GitLab. Whenever an application is deployed to that environment via CI/CD, GitLab creates and categorizes it as a <span class="No-Break">new deployment.</span></p>
			<p>Environments are created via the <strong class="bold">environment</strong> keyword in a CI/CD job. That prompts GitLab CI/CD to associate the job and resulting deployment with that environment, along with the specified name and URL. In the following example, we’ve modified two of our previously created jobs to deploy our app to testing and production environments, respectively. The container version of the app is deployed to an environment called <strong class="source-inline">testing</strong>, and the generic app to an environment <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">production</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
use_package_from_registry:
  stage: run_package
  script:
    - 'wget --header="JOB-TOKEN: $CI_JOB_TOKEN" ${CI_API_V4_URL}/projects/${CI_PROJECT_ID}/packages/generic/stable_releases/0.0.1/my_app_1665515895.tar.gz'
    - tar -xvf my_app_1665515895.tar.gz
    - ./my_app
  environment:
    name: testing
    url: <a href="https://test.example.com">https://test.example.com</a>
use_container_from_registry:
  stage: run_container
  image: registry.gitlab.com/nlotz1/pet-fashion/hats-for-cats/my_app/0.0.1:latest
  script:
    - ls -la
  environment:
    name: production
    url: <a href="https://prod.example.com">https://prod.example.com</a></pre>
			<p><span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.18</em> shows that <a id="_idIndexMarker654"/>environments are represented in the GitLab UI under <strong class="bold">Deployments</strong> | <span class="No-Break"><strong class="bold">Environments</strong></span><span class="No-Break">.</span></p>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<img src="image/B18073_08_18.jpg" alt="Figure 8.18 – Environments in the GitLab UI" width="1340" height="781"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.18 – Environments in the GitLab UI</p>
			<p>Each environment is updated when a new commit creates a pipeline with a CI/CD job deploying to that environment. The GitLab UI shows the commit SHA for the latest deployment, the GitLab<a id="_idIndexMarker655"/> user who triggered the commit, the branch it was triggered on, and the CI/CD job deploying to that environment. The <strong class="bold">Open</strong> button on the top right serves as a link to the URL specified when the environment was defined (<span class="No-Break">e.g., </span><a href="https://prod.example.com"><span class="No-Break"><strong class="source-inline">https://prod.example.com</strong></span></a><span class="No-Break">).</span></p>
			<p>We can see that by integrating environments into GitLab CI/CD, we can set up more advanced workflows, such as using CI/CD keywords like <strong class="bold">rules</strong> to ensure certain environments are only updated when code changes on certain branches. The next section in this chapter will show such <span class="No-Break">an example.</span></p>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor220"/>Deploying to a review app for testing</h1>
			<p>GitLab has a feature <a id="_idIndexMarker656"/>called a <strong class="bold">review app</strong> that allows developers to preview their changes directly within a merge request. Review apps use a special kind of <a id="_idIndexMarker657"/>environment called <strong class="bold">dynamic environments</strong>, whose names and URLs are set and changed based on the value of CI/CD variables. If you look back at <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.18</em>, you will notice a button that says <strong class="bold">Enable review app</strong> on the top right of the <strong class="bold">Environments</strong> page. <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.19</em> shows that selecting the button provides a block of code you can paste into your <strong class="source-inline">.gitlab-ci.yml</strong> file that creates a job that deploys to a review <span class="No-Break">app environment.</span></p>
			<div>
				<div id="_idContainer097" class="IMG---Figure">
					<img src="image/B18073_08_19.jpg" alt="Figure 8.19 – Enable Review App" width="876" height="445"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.19 – Enable Review App</p>
			<p>There are two key items to note in the job content. The first is the use of predefined CI/CD variables to specify the environment name and URL. The name of the review environment will be dynamically updated based on the triggering branch, and the URL will be updated based on the dynamic environment name. This is useful for spinning up temporary ad hoc <a id="_idIndexMarker658"/>environments during the <span class="No-Break">development process.</span></p>
			<p>The second item to note in the review app CI/CD job is its <strong class="source-inline">only</strong>/<strong class="source-inline">except</strong> keywords. The review app environment will <em class="italic">only </em>be deployed when a pipeline is triggered on a Git branch, <em class="italic">except </em>the main branch. The logic is that a branch represents a development line, but the main branch might be a more stable staging or production environment that is static rather <span class="No-Break">than dynamic.</span></p>
			<p>One other useful element of review apps is their easy accessibility from a merge request. If a merge request pipeline has a review app job defined for the triggering branch, a link to the review app’s URL will be accessible from the merge request page (see <span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.20</em></span><span class="No-Break">).</span></p>
			<div>
				<div id="_idContainer098" class="IMG---Figure">
					<img src="image/B18073_08_20.jpg" alt="Figure 8.20 – View review app from a merge request" width="1023" height="139"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.20 – View review app from a merge request</p>
			<p>The link to the review environment can also be seen on the CI/CD job log (see <span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.21</em></span><span class="No-Break">).</span></p>
			<div>
				<div id="_idContainer099" class="IMG---Figure">
					<img src="image/B18073_08_21.jpg" alt="Figure 8.21 – Review app CI/CD job log" width="1265" height="680"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.21 – Review app CI/CD job log</p>
			<p>To summarize, review <a id="_idIndexMarker659"/>apps simply extend our understanding of environments to include dynamic creation and updates. They are best used to represent rapidly changing development environments and are easily accessible for developers and reviewers to preview the latest version of <span class="No-Break">their applications.</span></p>
			<p>Now that we have learned about previewing changes with review apps, let’s finally turn to how we might deploy <span class="No-Break">into production.</span></p>
			<h1 id="_idParaDest-210"><a id="_idTextAnchor221"/>Deploying to real-world production environments</h1>
			<p>In the examples <a id="_idIndexMarker660"/>presented so far, we have shown that environments are simply organizational categories in GitLab with associated names and URLs. In the real world, however, environments represent actual infrastructure, be it your computer’s or someone else’s. That means recognizing the constraints on the available resources and the importance of proper security and <span class="No-Break">access control.</span></p>
			<p>In this day and age, it is increasingly common to use cloud service providers such as AWS, Microsoft <a id="_idIndexMarker661"/>Azure, and Google Cloud Platform for application hosting. These services not only outsource the need for infrastructure management but they also provide programmatic interfaces for managing <span class="No-Break">your environments.</span></p>
			<p>Moreover, suites of developer tools for managing these resources have accompanied the rise of cloud service providers, apart from the cloud vendor-provided tools. Software such as Terraform, Ansible, and Chef is available to declaratively manage cloud resources. That is, they let you store descriptions of infrastructure as text in a Git repository. Thus, similar workflows for infrastructure change management can be used as those for managing <span class="No-Break">application development.</span></p>
			<p>There is more to cloud service utilization than we could possibly cover within this one chapter. However, it is worth pointing out how GitLab can assist with one of the most important aspects of application environment administration: secret management. We’ve already explained the concept of CI/CD variables and how they can be used in CI/CD configurations and exported to the environments where jobs run. For variables of a sensitive nature, such as deploy keys, GitLab provides a special place in group- or project-level settings so that their values are not exposed in the <span class="No-Break">project’s repository.</span></p>
			<p>Say, for example, you wish to deploy to an environment hosted in AWS. You will be required to provide credentials to authenticate to AWS, generally in the form of an AWS access key and a secret key. However, you would not want to directly enter those values into your CI/CD deployment scripts, as that leaks your credentials into the code base and its <span class="No-Break">version history.</span></p>
			<p>You can instead navigate to your project’s <strong class="bold">Settings</strong> | <strong class="bold">CI/CD</strong> and expand the <strong class="bold">Variables</strong> section, as shown in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.22</em>. Here, you can create variables that you can reference in your <strong class="source-inline">.gitlab-ci.yml</strong> file, just like any other variable, without having to hardcode their values into <span class="No-Break">the configuration.</span></p>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="image/B18073_08_22.jpg" alt="Figure 8.22 – Project-level CI/CD variables" width="1263" height="723"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.22 – Project-level CI/CD variables</p>
			<p>Importantly, creating a variable in this way provides some additional gatekeeping on its use and exposure. Aside from setting the variable’s name and value, you can limit the environments in which it can be used. You can also choose to limit the variable to protected branches and tags (that is, branches and tags with restrictions on who can contribute to or modify them). And <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.23</em> shows you can also mask the variable, meaning that job logs would only display asterisks or <strong class="bold">[MASKED]</strong> if there were an attempt to leak <span class="No-Break">its value.</span></p>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="image/B18073_08_23.jpg" alt="Figure 8.23 – Project-level CI/CD variable settings" width="1100" height="622"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.23 – Project-level CI/CD variable settings</p>
			<p>These explanations only scratch the surface of deployment considerations in real-world environments. However, in these security-conscious times, we found it best to focus on the key area of secret management to demonstrate how GitLab can make the deployment process seamless and secure. In the next and final section, we’ll learn about GitLab’s integration with Kubernetes for <span class="No-Break">cloud-native deployments.</span></p>
			<h1 id="_idParaDest-211"><a id="_idTextAnchor222"/>Deploying to a Kubernetes cluster</h1>
			<p>We previously <a id="_idIndexMarker662"/>discussed the ubiquity of cloud services as alternatives to self-hosted infrastructure. In a similar vein, container orchestration systems such as Kubernetes have become increasingly popular as alternatives to the manual management of bare-metal servers or <span class="No-Break">container hosts.</span></p>
			<p>Deploying to Kubernetes with GitLab CI/CD can be conceptually similar to the workflows we have covered thus far. You can set up a GitLab runner with a Kubernetes executor, which communicates to the clusters using the Kubernetes API. Alternatively, GitLab optionally offers an<a id="_idIndexMarker663"/> additional approach called the <strong class="bold">GitOps workflow</strong>, which is not wholly reliant on CI/CD pipelines. We will summarize each of them <span class="No-Break">in turn.</span></p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor223"/>The CI/CD workflow</h2>
			<p>Using the <a id="_idIndexMarker664"/>concepts so far, you can use a normal CI/CD setup to deploy containerized applications to Kubernetes. This requires a runner registered with the Kubernetes executor. During runner registration, information such as cluster host and authentication information is provided. The CI/CD script will then include direct API calls in the cluster, specifying commands to build, test, or deploy <span class="No-Break">your code.</span></p>
			<p>Because this workflow involves runners sending imperative commands to a Kubernetes cluster, we call this a <strong class="bold">push-based</strong> workflow. It’s <a id="_idIndexMarker665"/>convenient in that there are no additional dependencies required to interact with Kubernetes. However, we can run into issues if the cluster or deployments have changed in any way outside the CI/CD workflow, causing potential problems if the cluster is in a state other than what the CI/CD <span class="No-Break">jobs expect.</span></p>
			<p>For this reason, GitLab increasingly recommends a different approach to working with Kubernetes called a <span class="No-Break">GitOps workflow.</span></p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor224"/>A GitOps workflow</h2>
			<p>GitLab provides an <a id="_idIndexMarker666"/>alternative method of<a id="_idIndexMarker667"/> Kubernetes integration that does not use CI/CD directly. Rather, it uses an agent installed on a Kubernetes cluster that communicates back to the GitLab instance. These steps can be performed by navigating to <strong class="bold">Infrastructure</strong> | <strong class="bold">Kubernetes clusters</strong> in your project and then selecting <strong class="bold">Connect a cluster</strong> to follow the provided instructions for creating and registering a new agent (see <span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.24</em></span><span class="No-Break">).</span></p>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="image/B18073_08_24.jpg" alt="Figure 8.24 – Connecting a Kubernetes cluster to GitLab" width="679" height="575"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.24 – Connecting a Kubernetes cluster to GitLab</p>
			<p>Once a connection is established, the <a id="_idIndexMarker668"/>agent will automatically detect changes when configuration and deployment files are updated in the repository and will change the cluster state<a id="_idIndexMarker669"/> accordingly. This is due to the bidirectional streaming between the cluster agent and GitLab server. Essentially, the agent initiates all communication to work around any networking restrictions that obstruct the Kubernetes cluster (see <span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.25</em></span><span class="No-Break">).</span></p>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="image/B18073_08_25.jpg" alt="Figure 8.25 – GitLab agent for Kubernetes architecture" width="789" height="929"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.25 – GitLab agent for Kubernetes architecture</p>
			<p>GitLab therefore<a id="_idIndexMarker670"/> refers to the GitOps workflow as a <strong class="bold">pull-based approach</strong>, one that is<a id="_idIndexMarker671"/> increasingly favored over traditional pushes by <span class="No-Break">CI/CD pipelines.</span></p>
			<h1 id="_idParaDest-214"><a id="_idTextAnchor225"/>Summary</h1>
			<p>In this chapter, we described various ways of packaging and deploying our code. This included making use of GitLab’s package and container registries, CI/CD environments, and methods for interacting with <span class="No-Break">cloud-native infrastructure.</span></p>
			<p>Even if you may not use all of the discussed features or services in your day-to-day work, we hope this chapter provided a useful bridge to more practical, real-world use cases of <span class="No-Break">GitLab’s features.</span></p>
			<p>The next chapter will build upon what we’ve learned already. It will also introduce advanced features for improving CI/CD speed and performance, increasing developer productivity, and optimizing your ability to quickly build and <span class="No-Break">ship software.</span></p>
		</div>
		<div>
			<div id="_idContainer105" class="IMG---Figure">
			</div>
		</div>
	</div>
</div>


<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer106" class="Content">
			<h1 id="_idParaDest-215"><a id="_idTextAnchor226"/>Part 3 Next Steps for Improving Your Applications with GitLab</h1>
		</div>
		<div id="_idContainer107">
			<p>This part of the book leads you through advanced CI/CD pipeline topics. These include speeding up pipelines using directed acyclic graphs, integrating third-party tools into pipelines, using pipelines to spot performance problems in your code, and many other topics. You will also get a chance to review everything you’ve learned so far with an end-to-end example demonstrating how to use GitLab to take a realistic software project through the entire software development life cycle. Finally, you’ll learn how to fix common problems with GitLab pipelines and get a peek at where GitLab might be going in <span class="No-Break">the future.</span></p>
			<p>This section comprises the <span class="No-Break">following chapters:</span></p>
			<ul>
				<li><a href="B18073_09.xhtml#_idTextAnchor227"><em class="italic">Chapter 9</em></a>, <em class="italic">Enhancing the Speed and Maintainability of CI/CD Pipelines</em></li>
				<li><a href="B18073_10.xhtml#_idTextAnchor250"><em class="italic">Chapter 10</em></a>, <em class="italic">Extending the Reach of CI/CD Pipelines</em></li>
				<li><a href="B18073_11.xhtml#_idTextAnchor268"><em class="italic">Chapter 11</em></a>, <em class="italic">End-to-End Example</em></li>
				<li><a href="B18073_12.xhtml#_idTextAnchor300"><em class="italic">Chapter 12</em></a>, <em class="italic">Troubleshooting and the Road Ahead with GitLab</em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer108">
			</div>
		</div>
		<div>
			<div id="_idContainer109">
			</div>
		</div>
	</div>
</div>
</body></html>