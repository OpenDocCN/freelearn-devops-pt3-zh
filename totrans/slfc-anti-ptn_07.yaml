- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keeping the Development Life Cycle from Going Off Track
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will examine how modern DevOps practices, particularly **continuous
    integration and continuous deployment** ( **CI/CD** ), relate to various anti-patterns
    in software development. We will begin by identifying significant process-level
    anti-patterns, and then discuss how CI/CD influences software packaging. Finally,
    we will examine a common anti-pattern associated with testing. At the end of the
    chapter, we will summarize the key takeaways for real-life applications and the
    CTA Review Board exam.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How you can avoid big-picture mistakes in the delivery of your project, such
    as how you structure releases and deal with key trade-offs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to avoid structuring your packages in a way that may be organizationally
    convenient but architecturally problematic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How you can avoid falling into the trap of compromising on code and deployment
    quality when under pressure to deliver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After completing this chapter, you will have understood the ways in which common
    mistakes affect the development life cycle and related activities and mastered
    some tools to help you keep that from happening.
  prefs: []
  type: TYPE_NORMAL
- en: Misaligning the process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at two anti-patterns that in different ways make
    the development life cycle go off the rails. First, we will look at how big-bang
    releases can lead to disastrous outcomes in many cases. Second, we will look at
    project pieism—the disastrous belief that you can avoid making important trade-offs.
  prefs: []
  type: TYPE_NORMAL
- en: Big-Bang Release
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*The Big-Bang Release anti-pattern places the release of all functionalities
    in a single event at the end of a* *long-running project.*'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: RollerCo, a major manufacturer of roller skates and skateboards, is going through
    a major business transformation centered on creating a digitally enabled business
    that better meets the needs of today’s buyers. While not the be-all and end-all
    of the transformation, several system replacement projects are planned as part
    of the journey to provide more agility on the IT side.
  prefs: []
  type: TYPE_NORMAL
- en: Anandh is leading the project that aims to replace the legacy, home-grown CRM
    that RollerCo has been using for the past 15 years. The system will be replaced
    with a combination of Salesforce Sales Cloud and Service Cloud, but due to the
    high level of customization in the legacy system, it has proven impossible to
    keep the Salesforce design close to standard.
  prefs: []
  type: TYPE_NORMAL
- en: Another consequence of the high-level customization required is that the entire
    system will need to go live as a single unit. It won’t be possible to release
    smaller **minimum viable product** ( **MVP** ) increments prior to full go-live
    as that would make life too complex for the customer support staff.
  prefs: []
  type: TYPE_NORMAL
- en: Shortly after the project kicks off, Anandh is informed that the board of directors
    has OKed an **enterprise resource planning** ( **ERP** ) upgrade to SAP S/4HANA.
    As the CRM and ERP are closely coupled for several processes, that means that
    not only will Anandh have to contend with an increased integration backlog, but
    the rollout plans for the two systems will also need to be coordinated so that
    both can go live at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: It quickly turns out that the added complexity from the ERP upgrade means the
    original Salesforce implementation plans will have to slip. In particular, the
    integrations are proving to be more complex than anyone anticipated.
  prefs: []
  type: TYPE_NORMAL
- en: The CIO, after meeting a trusted vendor representative, announces that to address
    the issues regarding the CRM/ERP integration, RollerCo will invest in a new strategic
    middleware platform. This will replace the legacy middleware and go-live with
    the overall CRM/ERP timeline.
  prefs: []
  type: TYPE_NORMAL
- en: While Anandh and his team are busy redesigning all the integrations to fit with
    the new middleware platform, yet another discovery is made. The team responsible
    for RollerCo’s web shop determines that it will be next to impossible to get it
    to work with the new CRM/ERP setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'It would require changing the fundamental architecture of the application’s
    data layer, and the developer who built that years ago is no longer with the company.
    No one else is able to figure out how to do it, so a new e-commerce application
    is also added to the overall program backlog. For convenience, the timeline is
    aligned with the overall CRM/ERP rollout:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – RollerCo’s new platform](img/B30991_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – RollerCo’s new platform
  prefs: []
  type: TYPE_NORMAL
- en: The program suffers never-ending delays. While some areas suffer more than others,
    none of the major platforms come out of the implementation phase looking good.
    Three years go by, and finally, an initial release is nearing completion.
  prefs: []
  type: TYPE_NORMAL
- en: RollerCo has built an elaborate deployment pipeline and cutover plan to be able
    to handle the multi-system go-live, all slated to happen during a weekend in the
    company’s low season. The testing prior to go-live takes more than three months
    to complete and requires a number of scope reductions and hotfixes.
  prefs: []
  type: TYPE_NORMAL
- en: Even after that, no one working on the project dares say unequivocally that
    the system will work as expected. The number of moving parts is simply too large.
  prefs: []
  type: TYPE_NORMAL
- en: The go-live weekend starts promisingly, with the successful completion of required
    data migration activities. However, as soon as real business users are brought
    into the systems, issues start cropping up.
  prefs: []
  type: TYPE_NORMAL
- en: By Sunday night, the number of issues has reached a volume that makes going
    forward seem excessively risky. While no individual issue has so far been a showstopper,
    the total disruption caused by small issues is significant. On a late-night call,
    the steering committee makes the decision to roll back and postpone going live.
  prefs: []
  type: TYPE_NORMAL
- en: The fallout is significant. After all, the program has already had three years
    to complete its work. However, it quickly becomes clear that the issues cannot
    be fixed in a matter of weeks. There is still much to be done.
  prefs: []
  type: TYPE_NORMAL
- en: The teams come together to find a solution over the next six months. Throughout
    this period, they focus on reducing the scope and simplifying features to make
    the rollout process easier to manage.
  prefs: []
  type: TYPE_NORMAL
- en: Eventually, the combined platform with CRM, ERP, middleware, and e-commerce
    goes live. However, it does so with a large list of known issues and workarounds
    and a much-reduced scope from the one originally designed.
  prefs: []
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Big-Bang Release is an anti-pattern that usually tries to solve the problem
    of how to handle complex dependencies in the release process. That can be dependencies
    between systems or inside them. It most frequently occurs where there isn’t strong
    leadership of a digital transformation, and the leadership that there is is highly
    risk-averse.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies are usually linked to certain business processes that have a legacy
    of being carried out in a certain way, which means that a large amount of functionality
    has to be deployed as a unit. Sometimes, as in our example, this can lead to massive
    dependencies even at the system level.
  prefs: []
  type: TYPE_NORMAL
- en: Disaggregating existing business processes and coming up with transition architectures
    (that accommodate the need to get work done while a partial solution is in place)
    can be quite difficult, as can MVP subsets of functionality that will deliver
    value on their own. Big-Bang Release avoids those issues by simply pushing everything
    to one big event in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Proposed solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Big-Bang Release anti-pattern proposes to just do one big release for all
    linked functionality at the end of a long delivery process. That can mean several
    years of work go live at the same time without any intermediate feedback.
  prefs: []
  type: TYPE_NORMAL
- en: 'This solution can be highly attractive to both the delivery team and the customer
    for a variety of reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: It reduces the entire system to a single deployment quantum that can be managed
    as a unit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It simplifies the planning process as you don’t have to plan for multiple releases,
    partial data migrations, and co-existence scenarios. That means the overall architecture
    is also simplified as there is no need to come up with transition architectures
    for the scope of the project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You also avoid tough decisions about what to include when and which business
    needs you can accommodate, and at what times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s easy to understand both for the delivery team and the customer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You successfully push the problem down the line, making it something to deal
    with later. In some cases, there may even be other people doing it by then.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can, therefore, understand why—even at a time when small releases and DevOps
    thinking have become the leading paradigm—many projects still end up being deployed
    with a big bang. Unfortunately, it doesn’t tend to go well.
  prefs: []
  type: TYPE_NORMAL
- en: Results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The fundamental problem with the Big-Bang Release anti-pattern is that you—often
    inadvertently—take on a massive amount of risk. Technical risk doesn’t grow linearly
    with the number of components to deploy. Rather, it grows much faster due to the
    superlinear growth of interconnections and dependencies that come with a larger
    number of components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Put simply, if you deploy one component, you only have the risk of that component
    failing to deal with. If you have just two interconnected components, you now
    have up to four failure modes to contend with:'
  prefs: []
  type: TYPE_NORMAL
- en: Component 1 failing independently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component 2 failing independently
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component 1 failing and triggering a subsidiary failure in component 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Component 2 failing and triggering a subsidiary failure in component 1
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All four may present unique symptoms and the root cause may not be obvious.
    Consider how many potential failure modes you’d have if you deployed 20 components
    together with a large number of interconnections between them.
  prefs: []
  type: TYPE_NORMAL
- en: A pipeline in software development is like a factory assembly line for code,
    where each step automatically flows into the next. Just as a car moves through
    different stations for assembly, testing, and quality control, code moves through
    various stages of building, testing, and deployment. DevOps, which combines “development”
    and “operations,” is a set of practices that brings together software development
    and IT operations teams to enable faster, more reliable software delivery. Think
    of it as breaking down the traditional walls between the people who write code
    and those who maintain the systems where that code runs.
  prefs: []
  type: TYPE_NORMAL
- en: Modern DevOps practices heavily emphasize automated testing and deployment pipelines,
    which act as safeguards against the risks of “big-bang” deployments (releasing
    many changes at once). When developers make changes to the code, these changes
    automatically trigger a series of tests—unit tests check individual components,
    integration tests verify different parts work together, and system tests ensure
    the entire application functions correctly. This automation, known as continuous
    integration, helps teams catch and fix problems early, before they can affect
    the entire system. Continuous delivery then takes these verified changes and automatically
    prepares them for release, ensuring every change is deployment-ready.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of CI/CD frameworks transforms the traditional approach of
    infrequent, large releases into a stream of smaller, more manageable updates.
    Instead of saving up dozens of changes for a major release (which can be risky,
    like trying to change multiple parts of an engine at once), teams can deploy individual
    updates as soon as they’re ready and verified. This incremental approach makes
    it easier to identify and fix problems—if something goes wrong, teams can quickly
    pinpoint which specific change caused the issue and either fix it or roll back
    that single change, rather than having to undo multiple updates at once. The result
    is more stable software systems, as teams can monitor each small change’s impact
    and address any issues before they become major problems.
  prefs: []
  type: TYPE_NORMAL
- en: Because the number of failure modes on a large deployment is so large, that
    means that testing becomes an enormous task, and often, you can test for weeks
    and still not be sure whether you have really tested all the important cases.
    Debugging errors is also much harder because tracing the potential knock-on effects
    between components is much harder than simply finding an error in a single component.
  prefs: []
  type: TYPE_NORMAL
- en: The same difficulties also apply to rolling out and rolling back any other cutover
    tasks that need to be done. Even training and change management become harder
    in a big-bang scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the bigger the release, the more risk there is of it becoming a serious
    failure. Unless you are a gambler, you shouldn’t go down that route.
  prefs: []
  type: TYPE_NORMAL
- en: Better solutions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If big releases are the problem, it stands to reason that small releases are
    the solution. From a risk management perspective, the ideal amount of functionality
    to release at a time is a single feature or a single user story. That is the premise
    of **continuous delivery** ( **CD** ), as practiced by leading DevOps-focused
    organizations.
  prefs: []
  type: TYPE_NORMAL
- en: However, we must acknowledge that not all organizations have the scale or technological
    sophistication to adopt the pure DevOps setup that would allow CD of a single
    feature at a time. However, if you aspire to the ideal of small releases, at least
    you will start to mitigate the problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Smaller releases have the following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: Less risky
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easier to test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easier to debug
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easier to fix errors once found
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easier to roll out and roll back
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deliver value quicker to business users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Facilitate and increase system adoption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make change management easier to control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, once you do the necessary technical and business process work to enable
    smaller releases, there are few—if any—downsides.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, aiming for a greater degree of resilience will be helpful in avoiding
    the problems sketched in this chapter. A good place to start is with the well-architected
    framework: [https://architect.salesforce.com/well-architected/adaptable/resilient](https://architect.salesforce.com/well-architected/adaptable/resilient)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: Project Pieism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Project Pieism fails to contend with key architectural trade-offs, insisting
    instead that you can have your pie and eat* *it too.*'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: ConglomoCo is a large, diversified conglomerate that counts many **business
    units** ( **BUs** )—some related to business lines, others to geography. Most
    BUs operate quite independently both operationally and with respect to IT infrastructure.
    In addition, BU heads have a lot of power relative to **headquarters** ( **HQ**
    ) staff as they are effectively the masters of their own businesses.
  prefs: []
  type: TYPE_NORMAL
- en: When ConglomoCo’s CIO decides to push for a global rollout of Salesforce, they
    are therefore met by staunch resistance on the part of several division heads
    who have their own CRM strategies and don’t want HQ to get involved. However,
    as part of a new initiative, the CEO and CFO have requested a consolidated view
    of the global pipeline, which the CIO is leveraging for their Salesforce strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Kim, a senior IT project manager with ConglomoCo’s HQ staff, is therefore given
    the responsibility to drive the global rollout of Salesforce Sales Cloud and CPQ.
    The CIO wants to use this as an opportunity to standardize the core sales process
    across BUs and simplify the reporting of sales data.
  prefs: []
  type: TYPE_NORMAL
- en: After corresponding with his architects, Kim, therefore, proposes a plan based
    on a single org with a standard process. There will be local variations within
    the BUs, but these are to be kept limited in scope.
  prefs: []
  type: TYPE_NORMAL
- en: As Kim starts presenting this plan to stakeholders, he finds that it is clearly
    not what they were expecting. The BUs have separate processes, UX expectations,
    local integrations, and reporting needs that they are expecting a new system to
    cater to.
  prefs: []
  type: TYPE_NORMAL
- en: 'At a senior leaders workshop, many of these issues come to light, and a compromise
    is reached at the highest level. The new system must be able to cater to separate
    sales processes, automations, and local integrations and accommodate some level
    of customization of the UX for each BU:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – ConglomoCo org](img/B30991_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – ConglomoCo org
  prefs: []
  type: TYPE_NORMAL
- en: However, all of this must still reside within the same Salesforce org and leverage
    the same data model to make reporting across BUs simpler. It is understood that
    this will lead to a more customized implementation and have a cost implication,
    but the CIO would still like the implementation to be as close to standard as
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation is long and slow. By necessity, it includes many separate
    streams related to the different BUs. Every stream seems to have its own complexities,
    and coordinating between streams is an ongoing and uphill battle. It is fair to
    say that as the implementation goes on, a level of attrition sets in, and everybody
    lowers their expectations for the future system, seeing it more as a necessary
    evil than a driver of positive change.
  prefs: []
  type: TYPE_NORMAL
- en: Kim negotiates with the business and manages to get two of the smaller areas
    to go live in a pilot fashion. They go live without much fanfare and with a lot
    of bugs. Worse than the bugs, however, is the low adoption. The salespeople in
    the BUs seem to do everything possible to avoid putting data in the system, and
    when they do, it is of low quality.
  prefs: []
  type: TYPE_NORMAL
- en: Given the unpromising early results, the rest of the rollout is put on hold.
    Instead, a management consultancy is brought in to investigate why adoption is
    so poor and what could be done better going forward.
  prefs: []
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Project Pieism is an anti-pattern that has its root cause in an aspiration to
    avoid having to make difficult trade-offs when implementing a system. That may
    be because of political difficulties or weak project leadership, but it always
    involves a failure to acknowledge a key trade-off that needs a decision.
  prefs: []
  type: TYPE_NORMAL
- en: In a sense, most engineering problems in software architecture and in general
    are about balancing a set of trade-offs. However, those trade-offs are often uncomfortable
    and will involve not pleasing all stakeholders.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it’s perfectly understandable that many projects proceed without
    making the necessary trade-offs in the hope that a solution may be found later
    or simply by closing their eyes to the facts. In any case, it is an anti-pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Proposed solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Project Pieism suggests as a solution to one or more important trade-offs in
    your solution that the trade-off is not real, that you don’t really have to compromise,
    and that you can in fact have your pie and eat it too. Sometimes this is done
    by ignoring the trade-off or sweeping it under the rug; sometimes it is acknowledged
    but special pleading is deployed to suggest that this case is somehow special
    and therefore the trade-off does not apply.
  prefs: []
  type: TYPE_NORMAL
- en: This position is attractive for obvious reasons. When there are key trade-offs
    to be made in an implementation project, you will probably have to disappoint
    one or more groups of stakeholders. If those groups are powerful within your organization,
    that may not be an easy or pleasant thing to do. You can even find yourself in
    situations where you are forced into Project Pieism because of corporate politics.
  prefs: []
  type: TYPE_NORMAL
- en: However, not even the most powerful executive in your organization can change
    the basic facts of software architecture. There are always trade-offs. Whenever
    you have a situation on a technical project where there doesn’t seem to be a trade-off
    in the decision you are making, you should be worried.
  prefs: []
  type: TYPE_NORMAL
- en: Results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The result of Project Pieism is the return of the trade-off you’ve tried to
    ignore. Murphy’s law being what it is, that will probably happen at the most inconvenient
    point in your project life cycle and cause major damage to your project.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the specific damage will depend on the trade-off you have been ignoring.
    In our preceding example, we ignored trade-offs between the priority of global
    and local processes and the level of standard functionality versus customization.
  prefs: []
  type: TYPE_NORMAL
- en: ConglomoCo attempted to have a standard system with a global process that also
    accommodated all relevant local variations. That led to a system that no one wanted
    to use because it met no one’s needs well enough.
  prefs: []
  type: TYPE_NORMAL
- en: Other trade-offs will have different consequences, but you can count on adverse
    consequences if you fail to make important decisions about the key trade-offs
    that drive your architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Better solutions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The way to a less pieist future lies in openly acknowledging the trade-offs
    to be made and engaging constructively with stakeholders about the options. Often,
    there are ways of giving stakeholders more of what they all want, but it may come
    at an additional cost or a longer timeline.
  prefs: []
  type: TYPE_NORMAL
- en: One way to formalize this engagement is to set up good architectural governance
    early in a project and discuss the key architectural trade-offs in both architecture
    forums and business forums to ensure that all perspectives are taken into account.
    In our example, a competent architecture board might well have pointed out that
    there was no way of making a single org strategy work well in the ConglomoCo scenario.
  prefs: []
  type: TYPE_NORMAL
- en: As architects, we need to be honest with the business about what is and isn’t
    possible. We are the people who know the art of the possible on the technical
    side, and we shouldn’t pretend that our favorite technologies somehow transcend
    the need to make hard choices. Stand firm, be constructive, give options, and
    don’t ignore important trade-offs.
  prefs: []
  type: TYPE_NORMAL
- en: Infrequent Check-In
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Infrequent Check-In is an anti-pattern where developers work in isolation
    for extended periods without integrating their changes into the main code base,
    leading to significant integration challenges, reduced visibility, and potential*
    *project delays.*'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CloudTech, a rapidly growing technology company, has been developing a custom
    Salesforce solution to manage their complex partner ecosystem. The project involves
    multiple teams working on different aspects of the solution, including partner
    onboarding, certification management, and revenue-sharing calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Sarah, a senior developer, is assigned to build the revenue-sharing calculation
    engine, a critical component that needs to interface with multiple parts of the
    system. Given the complexity of the calculations and the numerous business rules
    involved, she decides to work on the complete feature before integrating it with
    the main code base.
  prefs: []
  type: TYPE_NORMAL
- en: The project manager, Tom, is comfortable with this approach as he believes it
    will allow Sarah to focus entirely on getting the complex calculations right without
    being distracted by integration issues. The team’s technical lead, Marcus, expresses
    some concerns about the lengthy isolation period but ultimately agrees, given
    Sarah’s experience and the critical nature of the component.
  prefs: []
  type: TYPE_NORMAL
- en: Sarah spends six weeks working on the calculation engine. During this time,
    she makes significant progress and regularly updates the team during stand-ups
    about her work. However, she keeps all changes in her local development environment,
    believing this is the safest approach until the feature is complete and thoroughly
    tested.
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, other team members continue their work. The partner onboarding team
    implements several changes to the data model. The certification team adds new
    validation rules that affect partner status. The integration team modifies several
    APIs that the calculation engine needs to interact with.
  prefs: []
  type: TYPE_NORMAL
- en: When Sarah finally completes the calculation engine and prepares to integrate
    it with the main code base, several issues emerge. The data model changes made
    by the partner onboarding team conflict with Sarah’s assumptions about the schema
    structure. The new validation rules affect how partner status is determined, which
    is a key input for the calculation engine. The modified APIs require different
    parameters and return structures than what Sarah’s code expects.
  prefs: []
  type: TYPE_NORMAL
- en: The team now faces a crisis. The sprint deadline is approaching, but integrating
    Sarah’s code will require significant refactoring. The code review process becomes
    overwhelming as team members struggle to understand and validate the massive changeset.
    Several critical bugs are discovered during testing, but fixing them is complicated
    by the interconnected nature of the changes.
  prefs: []
  type: TYPE_NORMAL
- en: After three additional weeks of intensive effort to resolve the integration
    issues, the feature is finally merged into the main code base. However, the delay
    has impacted other dependent features, and the project timeline needs to be adjusted.
    The team also discovers that some of Sarah’s work duplicated solutions already
    implemented by other team members during her isolation period.
  prefs: []
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Infrequent Check-In anti-pattern emerges when developers work in isolation
    for extended periods without integrating their changes into the main code base.
    This pattern often appears tempting in scenarios involving complex features or
    critical components, where teams believe isolation will lead to better focus and
    fewer disruptions.
  prefs: []
  type: TYPE_NORMAL
- en: The anti-pattern manifests itself through developers working for weeks or months
    without merging code, resulting in large, monolithic changesets that are difficult
    to review and test. It creates limited visibility into development progress and
    isolation from evolving code base changes and team decisions.
  prefs: []
  type: TYPE_NORMAL
- en: While this approach might seem logical for complex features, it fundamentally
    misunderstands the collaborative nature of software development and the importance
    of CI.
  prefs: []
  type: TYPE_NORMAL
- en: Proposed solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Infrequent Check-In approach suggests that complex features are best developed
    in isolation. Proponents argue that developers can focus entirely on their tasks
    without worrying about integration issues, keeping their code “clean” and unaffected
    by ongoing changes until it’s ready. They believe testing can be more thorough
    when the feature is complete, and code reviews will be more meaningful when examining
    the complete feature. Project management appears simpler by treating the feature
    as a single unit of work.
  prefs: []
  type: TYPE_NORMAL
- en: This solution appears attractive because it promises to reduce complexity by
    avoiding the overhead of CI and dealing with ongoing changes in the code base.
    It suggests that quality will be higher because developers can focus solely on
    their specific features without external distractions.
  prefs: []
  type: TYPE_NORMAL
- en: Result
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Infrequent Check-In anti-pattern leads to several significant problems.
    Integration becomes a major challenge, with massive merge conflicts when finally
    integrating with the main code base. Significant refactoring is often required
    to accommodate changes made during the isolation period, and there’s an increased
    risk of integration errors and bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Visibility suffers throughout the development process. Teams have limited insight
    into actual development progress, making it difficult to identify potential issues
    early and reducing the ability to make informed project decisions.
  prefs: []
  type: TYPE_NORMAL
- en: Collaboration issues arise as team members work in isolation. Knowledge sharing
    and peer learning become limited, and feedback on design decisions and implementation
    approaches is delayed. This often results in the duplication of effort as different
    team members solve similar problems without awareness of each other’s work.
  prefs: []
  type: TYPE_NORMAL
- en: Quality impact becomes evident through overwhelming code reviews that may miss
    critical issues. Comprehensive testing becomes difficult due to large changesets,
    and there’s an increased likelihood of bugs slipping through due to complex integration
    scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Project delays are common, with extended integration periods not accounted for
    in initial timelines. This creates cascading delays affecting dependent features
    and additional time needed for resolving conflicts and issues.
  prefs: []
  type: TYPE_NORMAL
- en: Technical debt accumulates through architectural misalignments due to divergent
    development. Teams often find duplicated solutions and inconsistent approaches,
    along with difficulty in maintaining code history and understanding change rationale.
  prefs: []
  type: TYPE_NORMAL
- en: Better solutions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To avoid the Infrequent Check-In anti-pattern, teams should implement true CI.
    This means establishing automated build and test processes, requiring developers
    to integrate changes at least daily, setting up monitoring and alerts for integration
    issues, and using feature toggles to manage incomplete features in the main code
    base.
  prefs: []
  type: TYPE_NORMAL
- en: Complex features need to be broken down into smaller, more manageable chunks.
    Teams should plan incremental development with clear integration points, identify
    dependencies early, and manage them proactively. Clear acceptance criteria for
    each component help maintain focus while allowing for regular integration.
  prefs: []
  type: TYPE_NORMAL
- en: Clear integration policies are essential. Teams should define the maximum acceptable
    time between integrations and guidelines for changeset sizes. Code review processes
    should encourage frequent, smaller reviews, and standards should exist for feature
    toggle usage.
  prefs: []
  type: TYPE_NORMAL
- en: Communication and visibility must be prioritized through regular design reviews
    during development and pair programming for complex features. Teams should maintain
    up-to-date documentation of architectural decisions and hold frequent team sync-ups
    to discuss technical challenges.
  prefs: []
  type: TYPE_NORMAL
- en: Modern development practices play a crucial role in preventing this anti-pattern.
    Trunk-based development minimizes long-lived branches, while comprehensive automated
    testing helps catch issues early. Feature flags manage incomplete features effectively,
    and proper monitoring and observability ensure teams can quickly identify and
    resolve issues.
  prefs: []
  type: TYPE_NORMAL
- en: Team culture is fundamental to success. Organizations should encourage knowledge-sharing
    and collaboration while promoting collective code ownership. Continuous learning
    and improvement should be supported, and teams should create a safe environment
    for early feedback.
  prefs: []
  type: TYPE_NORMAL
- en: The key to avoiding this anti-pattern is recognizing that software development
    is inherently collaborative and iterative. Success comes not from avoiding integration
    challenges but from making them small enough to manage effectively through frequent
    integration and clear communication. By implementing these solutions, teams can
    maintain high quality while avoiding the pitfalls of isolated development.
  prefs: []
  type: TYPE_NORMAL
- en: Unpacking the pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will introduce a key DevOps anti-pattern related to how you should
    structure your packages for package-based development.
  prefs: []
  type: TYPE_NORMAL
- en: Using Packages to Create Silos
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Using Packages to Create Silos divides up the packages for your Salesforce
    project based on team structure without considering* *architectural concerns.*'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MillCo, a producer of CNC milling machines with subsidiaries across Europe and
    North America, is implementing Salesforce for its B2B sales. This includes Sales
    Cloud, CPQ, and B2B Commerce.
  prefs: []
  type: TYPE_NORMAL
- en: Abigail is the CRM tech lead from MillCo, a role she has recently taken up after
    leading a CRM implementation project in another B2B manufacturing company. Her
    principal job is to ensure that the technical delivery from the three different
    vendors that are implementing the different elements of the new system is consistent
    and of high quality.
  prefs: []
  type: TYPE_NORMAL
- en: At project kick-off, Abigail invites all three vendor teams along with internal
    stakeholders and emphasizes many times that while people are working for different
    companies, everyone should think of themselves as being on the same team. MillCo
    wants everyone on the same page and working together toward a common goal.
  prefs: []
  type: TYPE_NORMAL
- en: That turns out to have been all for naught. Once work commences for real, the
    three suppliers are quickly at each other’s throats. Abigail finds it impossible
    to get them to agree to any common approach and standard.
  prefs: []
  type: TYPE_NORMAL
- en: While she can mandate certain things, she has no team behind her, and there
    is only so much she can do if the vendors don’t cooperate. She escalates the issue
    but is told to find a solution that allows work to continue as planned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution she decides to go with is to isolate each vendor in a separate
    package. That way, they can build in isolation, except for cases where their work
    directly clashes with one another on key elements of the platform. Abigail takes
    it upon herself to monitor and mediate these disputes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Package structure](img/B30991_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Package structure
  prefs: []
  type: TYPE_NORMAL
- en: She ends up spending most of her time on the project mediating these kinds of
    inter-vendor conflicts. That also means she has very little time to investigate
    the general approaches used by the vendors in areas that aren’t subject to acrimony.
  prefs: []
  type: TYPE_NORMAL
- en: However, in the end, the system is built. As each vendor has been working in
    their own environment with only occasional deploys to a thinly tested integration
    environment, the first step to prepare for **user acceptance testing** ( **UAT**
    ) is to deploy all the packages to a common environment and test the basic processes.
    Each package has been thoroughly tested in its own environment, but no systematic
    testing has been done across packages.
  prefs: []
  type: TYPE_NORMAL
- en: Even before the test results start coming in, the situation starts to deteriorate.
    It turns out that there are incompatible system and package settings between the
    vendors—for instance, on the CPQ-managed package. This means the deployment stalls
    until a workaround can be found.
  prefs: []
  type: TYPE_NORMAL
- en: When the testers actually get started, things go from bad to worse. There are
    many subtle incompatibilities between the packages. For instance, there are different
    interpretations and uses of common fields, duplicate fields used by different
    packages for the same purpose, and custom objects that have a partially overlapping
    scope and the creation of redundant data. There is also a wide range of different
    automation patterns in use between the three vendors, despite this being an area
    where Abigail specified the standard upfront.
  prefs: []
  type: TYPE_NORMAL
- en: All in all, the differences are too large to reconcile quickly, and the project
    has to back off. Abigail’s boss negotiates an extension to the timeline in order
    to refactor the packages and bring them in line. While she is happy about the
    extension, Abigail does not relish the wrangling it will take to get the vendors
    to actually do this.
  prefs: []
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, you want to allow teams to work independently without having to depend
    on or coordinate with other teams. In a Salesforce context, that may be because
    the teams are working on different clouds, come from different vendors, or represent
    different departments or BUs within your organization.
  prefs: []
  type: TYPE_NORMAL
- en: This is very understandable as coordination problems can be hard to resolve.
    However, when that becomes the basis for dividing up your Salesforce platform
    into packages, it becomes a DevOps anti-pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Proposed solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The proposed solution of Using Packages to Create Silos is to give each team
    its own package to work in, reflecting what it is going to be working on. That
    avoids coordination issues but creates a host of other problems.
  prefs: []
  type: TYPE_NORMAL
- en: That means you structure the package setup for your project based on organizational
    needs rather than architecture. That can seem like a good idea at the outset and
    obviously works for the teams in the short term, but unfortunately means that
    hidden conflicts are likely and can remain hidden for a long time.
  prefs: []
  type: TYPE_NORMAL
- en: Results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The likely result of Using Packages to Create Silos is that you will have hidden
    conflicts that only become apparent on the integration of the packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'These conflicts include cases such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Different use of data models—for instance, fields and objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Issues in the security model where conflicting configurations are used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conflicting flows, validation rules, or other business logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deviation from best practice, for instance, multiple triggers on the same object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different automation patterns used on the same object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conflicting assumptions about system settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replicated functionality in different packages that is often only partially
    overlapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This can lead to serious issues and can be a real mess to refactor, which is
    both costly and time-consuming.
  prefs: []
  type: TYPE_NORMAL
- en: Better solutions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In general, package design should be taken quite seriously. Package-based development
    is the way to go for most large-scale Salesforce projects, not least because it
    scales better than the alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid falling into the Using Packages to Create Silos anti-pattern, follow
    these guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: Design your package structure with your architecture in mind. For instance,
    in a typical architecture that’s split by service lines, you could place common
    functionality in a “Common” package that all other packages depend on and then
    have separate packages for each service line containing relevant components. You
    might also have higher-level packages cutting across service lines for things
    such as common integrations and you could have separate packages split out for
    cross-cutting functionality, although that can be a bit tricky to manage. The
    point is that you should ensure that you manage dependencies cleanly and don’t
    have potentially conflicting overlaps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be careful with dependencies; a layered approach can work well to only have
    dependencies go in one direction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Have teams work across packages when needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider having certain teams own certain packages and others request work from
    them if they need anything.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coordinate via technical governance forums—for example, an architecture board.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In modern DevOps workflows, leveraging tools such as the Salesforce CLI is essential
    for effective source tracking and version control. The Salesforce CLI streamlines
    the integration process, allowing developers to easily manage and deploy changes
    across environments. By utilizing source-tracking capabilities, teams can ensure
    consistency and accuracy in their development processes, enhancing collaboration
    and reducing errors. This approach enables the efficient management of metadata
    and code changes, aligning with best practices in agile development.
  prefs: []
  type: TYPE_NORMAL
- en: Salesforce DX unlocked packages are a crucial component of modern development
    workflows in the Salesforce ecosystem. They enable developers to create modular
    and reusable components, facilitating code organization and improving team collaboration.
    With the ability to manage package versions and dependencies effectively, teams
    can streamline their CI/CD processes. Unlocked packages also support a more granular
    approach to source tracking, allowing teams to work on different features without
    affecting the entire code base. By utilizing unlocked packages, organizations
    can enhance their development practices, making them more agile and responsive
    to changes in business requirements.
  prefs: []
  type: TYPE_NORMAL
- en: In general, you don’t want to mistake package design for something else. Build
    your package structure so that it makes sense for your architecture and is workable
    for your developers.
  prefs: []
  type: TYPE_NORMAL
- en: Testing without testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is a critical activity within any large software project. In this section,
    we will see how trying to avoid writing the necessary unit tests can cause major
    issues in the mid-to-long term.
  prefs: []
  type: TYPE_NORMAL
- en: Dummy Unit Tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*The Dummy Unit Tests anti-pattern gets around the built-in requirement for
    unit testing in Salesforce by writing dummy tests that optimize for coverage but*
    *do nothing* .'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TruckCo is a start-up automotive company that focuses on building next-generation
    EV trucks. It sees itself as more of a technology company than a manufacturing
    company and therefore invests heavily in top-range solutions to keep its technological
    edge.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, TruckCo tends toward heavy customization and intense agile projects
    with long hours and short timelines. The supply chain application TruckCo is currently
    building on Salesforce is no exception to this rule.
  prefs: []
  type: TYPE_NORMAL
- en: The application will integrate their B2B commerce portal with order management
    and their supply chain backend systems. It will enable **just-in-time** ( **JIT**
    ) ordering from spare parts vendors and in general significantly reduce the **quote-to-cash**
    ( **QTC** ) process for spare part orders.
  prefs: []
  type: TYPE_NORMAL
- en: In order to achieve these aims, TruckCo plans to integrate half a dozen key
    backend systems with Salesforce, build a custom **user interface** ( **UI** )
    optimized for their special processes, and build a set of cross-platform, AI-enabled
    automations that drive efficiencies in the ordering process.
  prefs: []
  type: TYPE_NORMAL
- en: Because the application is expected to be code-heavy and development-focused,
    TruckCo repurposes a team of Java developers from its permanent staff to work
    on it, figuring that Apex is close enough for them to pick it up as they go along.
    Yana is the only traditional Salesforce person on the project, and her role is
    to guide the rest of the team in the ways of Salesforce.
  prefs: []
  type: TYPE_NORMAL
- en: Matt, the team lead, is a bit of a maverick, and the same is true of the rest
    of the team. While they use unit tests, they do not do so consistently, often
    preferring to have bugs reported by users and then fix them afterward. Inside
    TruckCo, there is an unstated but strong preference for releasing products on
    time, even if that means releasing something buggy and incomplete.
  prefs: []
  type: TYPE_NORMAL
- en: Coming from the Java world, the developers quickly start to get annoyed with
    the mandated 75% unit test coverage enforced by Salesforce and built into the
    deployment tooling for the platform. Yana accidentally mentions some ways to fool
    the Salesforce unit test calculation by creating dummy tests while having lunch
    with the rest of the team.
  prefs: []
  type: TYPE_NORMAL
- en: Although she mentioned it jokingly, much to her chagrin, she finds that a few
    days after, dummy unit tests are starting to appear in the code base. When she
    calls out Matt on this, he simply shrugs and says that they’re behind schedule,
    so they don’t have time to spend all their time coding tests.
  prefs: []
  type: TYPE_NORMAL
- en: Yana, however, is not deterred, and at the next project board, she raises the
    issue formally. She refers to the guidance provided by Salesforce and supported
    by the company’s own Salesforce architect.
  prefs: []
  type: TYPE_NORMAL
- en: The project sponsor promises to have someone investigate the issue. Unfortunately,
    that’s the last Yana hears of it. It seems that Matt had indicated that major
    delays would happen to the project if they had to retroactively write a complete
    set of unit tests. In keeping with TruckCo’s normal way of operating, this is
    seen as unacceptable, and the dummy unit test issue is ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the practice keeps accelerating as the project falls more behind,
    and toward go-live, almost every new unit test written is a dummy. While the automated
    scanner lists an impressive 90% coverage, Yana doubts whether the real number
    is any higher than 10%.
  prefs: []
  type: TYPE_NORMAL
- en: A few weeks before go-live, a list of last-minute changes comes in from business
    stakeholders. Yana can’t see any way that they can be incorporated, but Matt agrees
    to deliver them.
  prefs: []
  type: TYPE_NORMAL
- en: The last period is a flurry of changes back and forth with lots of bugs discovered
    by testers, followed by fixes that often lead to further regression issues. This
    continues unabated into the actual UAT period, which finds another large number
    of issues. However, no one makes the decision to halt the go-live, and on the
    appointed day, the supply chain application goes live.
  prefs: []
  type: TYPE_NORMAL
- en: As users start onboarding on the application, several breaking bugs are discovered
    in the main flows. These occur in areas that had been tested and found working
    just weeks before go-live and had also been part of user training.
  prefs: []
  type: TYPE_NORMAL
- en: The application must be taken down, and an escalation meeting is called. Here,
    the fundamental soundness and quality of the application are put into serious
    question and a new initiative is agreed upon to look into the quality issues and
    devise a way of fixing them before the application can be brought back online.
  prefs: []
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Dummy unit tests seek to address a very simple question: how do you get around
    the hard 75% unit test limit for production deployment in Salesforce? It’s common
    for long-running Salesforce projects to find that they are under the limit either
    for a specific deployment or in general.'
  prefs: []
  type: TYPE_NORMAL
- en: Many teams find this limit annoying. This is especially true when developers
    are coming to the platform from other technologies where no such limit existed,
    when under pressure, or when they are doing something “simple.”
  prefs: []
  type: TYPE_NORMAL
- en: Proposed solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The solution proposed is to create dummy unit tests that just optimize for
    code coverage and don’t really test anything. This is another of the few anti-patterns
    that edge close to just being bad practice. You can see an example of a dummy
    test in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: However, it is something that can be tempting and that otherwise serious Salesforce
    practitioners sometimes may engage in. When you are under pressure to meet a sprint
    goal or deployment deadline, it can seem like a waste of time to write a bunch
    of unit tests just to get the coverage up.
  prefs: []
  type: TYPE_NORMAL
- en: 'But obviously, this attitude fails to acknowledge the real value provided by
    unit tests and the reason why the coverage is mandatory: code without good unit
    tests is much more brittle and prone to regression errors than code that has them.
    Therefore, skipping them, even when you are under pressure, is a genuinely bad
    idea.'
  prefs: []
  type: TYPE_NORMAL
- en: Results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This pattern tends to lead to a death by a thousand cuts. While you probably
    won’t experience ill effects in the short term, after a while, you won’t have
    any real unit tests to rely on.
  prefs: []
  type: TYPE_NORMAL
- en: Even worse, you may still psychologically project a false sense of security,
    if you still think you’ve only cut the corners in a few places and generally can
    rely on your testing. Basically, you are cheating the system and probably releasing
    poor-quality code. Also, you are creating a major amount of technical debt that
    the organization will at some point have to pay off.
  prefs: []
  type: TYPE_NORMAL
- en: Better solutions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The solution to this anti-pattern is simple: build good unit tests and always
    meet the minimum thresholds. You should never compromise on the minimum bar as
    it will lead to deteriorating code quality and hence delivery quality over time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a lot of guidance available on building good unit tests, so let us
    just repeat a few basic points:'
  prefs: []
  type: TYPE_NORMAL
- en: A unit test should test a single functionality in the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test should be written before the code it is testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test should be written in such a way that it can be easily repeated
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test should be independent of other tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test should not rely on org data but should create its own test data, ideally
    using a test data factory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test should be concise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assertions should be used to check that the expected results are obtained
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test should test both positive and negative cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test should be run often, preferably automatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The test should be easy to understand and maintain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to traditional testing methods, consider incorporating modern testing
    frameworks such as ApexMocks, Jest, and Mocha. These frameworks offer powerful
    features for unit testing and mocking in various programming environments, facilitating
    more efficient and effective testing processes. Familiarizing yourself with these
    tools can significantly enhance your testing strategy and improve code quality.
  prefs: []
  type: TYPE_NORMAL
- en: It is a rare anti-pattern that can be avoided just by following good practice,
    so be sure to avoid this one.
  prefs: []
  type: TYPE_NORMAL
- en: The challenge of DevOps integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As Salesforce platforms grow more complex and organizations push for faster
    delivery cycles, many teams find themselves grappling with the integration of
    modern DevOps practices into their architectural approach. While the promise of
    DevOps is compelling—faster releases, higher quality, and more reliable deployments—the
    reality often falls short of these aspirations, particularly in the Salesforce
    ecosystem where traditional development patterns can clash with DevOps principles.
  prefs: []
  type: TYPE_NORMAL
- en: Consider FinTechCo, a rapidly growing financial technology company implementing
    Salesforce as their new customer engagement platform. Like many organizations,
    they begin their DevOps journey with great enthusiasm, implementing all the right
    tools—Git repositories, CI/CD pipelines, automated deployments, and Salesforce
    DX for development. Their lead architect, Sarah, meticulously sets up the technical
    infrastructure, confident that this will transform their delivery process.
  prefs: []
  type: TYPE_NORMAL
- en: However, as the project progresses, the team discovers that having DevOps tools
    in place isn’t enough. Developers continue making changes directly in sandboxes,
    only committing to Git when reminded. The automated test suite remains sparse,
    with most testing still performed manually. The CI/CD pipeline frequently breaks
    because different team members follow different processes. Integration between
    environments becomes increasingly problematic—what works in one developer’s scratch
    org fails in another’s, and changes that pass all automated tests in the pipeline
    sometimes break functionality in integration environments.
  prefs: []
  type: TYPE_NORMAL
- en: This scenario plays out frequently across the Salesforce ecosystem, where organizations
    implement DevOps tooling without fully embracing the cultural and architectural
    changes required. The challenge lies not in the tools themselves but in the fundamental
    shifts needed in how teams approach development and deployment. Teams often find
    themselves caught between the immediate pressure to deliver features and the longer-term
    need to build sustainable delivery practices.
  prefs: []
  type: TYPE_NORMAL
- en: The situation typically deteriorates gradually. Teams start bypassing DevOps
    processes for emergency fixes, making direct changes in higher environments. Environment
    states become inconsistent, and tracking changes becomes increasingly difficult.
    What starts as the occasional deviation from the process becomes common practice,
    undermining the very benefits DevOps was meant to deliver.
  prefs: []
  type: TYPE_NORMAL
- en: At FinTechCo, this comes to a head during a critical deployment that fails repeatedly
    during a planned release window. The team discovers various components have different
    versions across environments, and nobody can confidently say which version should
    be considered correct. The release has to be postponed while the team manually
    reconciles the differences—exactly the sort of situation DevOps is supposed to
    prevent.
  prefs: []
  type: TYPE_NORMAL
- en: The root cause often lies in approaching DevOps as a technical transformation
    rather than an architectural and organizational one. Teams implement tools without
    redesigning their development processes and solution architecture to support modern
    delivery practices. This creates a disconnect between the ideal process and the
    practical reality teams face daily.
  prefs: []
  type: TYPE_NORMAL
- en: Success with DevOps in Salesforce requires rethinking architectural approaches
    from the ground up. This means considering how your metadata will be packaged
    and deployed, how environments will be managed, how testing will be automated,
    and how changes will be tracked and versioned. It means making architectural decisions
    that support continuous delivery—for instance, designing features to be independently
    deployable and building automated testing into the development process from the
    start.
  prefs: []
  type: TYPE_NORMAL
- en: Organizations need to recognize that DevOps isn’t just about faster deployments—it’s
    about building quality and reliability into the development process itself. This
    might mean making architectural trade-offs, such as sacrificing some flexibility
    in how changes can be made in exchange for more reliable deployments. It might
    mean redesigning features to support partial deployments rather than requiring
    all-or-nothing releases.
  prefs: []
  type: TYPE_NORMAL
- en: The path forward typically involves starting small and scaling gradually. Rather
    than attempting a complete transformation overnight, successful organizations
    often begin with a single team or project, allowing practices to mature before
    expanding. This approach allows teams to learn and adapt while managing risk appropriately.
    It also provides opportunities to demonstrate success, building organizational
    support for broader adoption.
  prefs: []
  type: TYPE_NORMAL
- en: Most importantly, organizations need to recognize that DevOps transformation
    is a journey rather than a destination. It requires ongoing commitment to improvement,
    willingness to learn from failures, and patience as teams develop new skills and
    habits. The goal isn’t perfect DevOps implementation, but rather building a sustainable
    approach to delivery that balances speed and reliability.
  prefs: []
  type: TYPE_NORMAL
- en: Success comes from aligning architectural decisions with delivery practices,
    building robust automated testing approaches, establishing clear governance around
    development processes, and investing in team training and cultural change. This
    means making hard choices about standardization versus flexibility, where to enforce
    processes and where to allow deviation, and how to balance immediate delivery
    needs with long-term sustainability.
  prefs: []
  type: TYPE_NORMAL
- en: By approaching DevOps as an architectural challenge rather than just a tooling
    one, organizations can avoid the common pitfalls of superficial adoption and build
    delivery practices that truly support their business needs. This requires careful
    thought about how architectural decisions impact delivery capabilities and how
    delivery practices influence architectural choices. Only by addressing both aspects
    together can organizations achieve the true benefits of modern DevOps practices
    in their Salesforce implementations.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the takeaways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will abstract a bit from the specific patterns and instead
    try to pull out the wider learning points you can use in your day-to-day work
    as a Salesforce architect or in preparing for the CTA Review Board exam.
  prefs: []
  type: TYPE_NORMAL
- en: 'When architecting Salesforce solutions, you should be mindful of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Don’t put all your eggs in one basket. Plan smaller releases wherever possible
    to de-risk and get feedback.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Confront the tough decisions that can come from having to break down functionality
    into smaller buckets. Don’t just accept a statement that everything must be there
    from day one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always confront the key architectural trade-offs early on in your project timeline.
    They usually don’t get easier to manage as time goes by.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicate clearly and openly about the trade-offs that need to be made and
    the options for doing so. Trying to please everybody and sweep things under the
    rug is a recipe for disaster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t allow team rivalries or organizational silos to dictate your development
    model, whether for package-based development or otherwise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead, ensure that your development model is consistent with the architecture
    you are pursuing and that components and packages are structured accordingly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Integrate modern DevOps practices including CI/CD pipelines, automated testing,
    and version control to improve delivery quality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing is a requirement in Salesforce for a reason. Don’t compromise just
    because you are under pressure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing good-quality unit tests will ensure that you have higher code quality
    and fewer regression issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In preparing for the CTA Review Board exam, you should be mindful of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Prefer an agile, multi-release process when faced with a big, complex scenario,
    rather than a single big-bang release.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some scenarios, however, do seem written more for a waterfall/big-bang approach.
    This may be an area where best practices for the board and reality can diverge.
    In today’s rapidly evolving tech landscape, it is increasingly crucial for CTAs
    to understand DevOps and modern development practices. This knowledge not only
    enhances collaboration between development and operations teams but also enables
    CTAs to better support organizations in implementing agile methodologies, CI,
    and continuous delivery, ultimately driving innovation and efficiency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should be very clear about the trade-offs you are making and include them
    in your justification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you fail to make an appropriate choice, it will with near certainty make
    your solution unravel during the Q&A.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package-based development is the up-and-coming development model for Salesforce
    projects, but that doesn’t mean it will be right for your scenario. If it is,
    having some words to say about a good package structure will potentially give
    you some extra kudos.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Know the minimum limits for unit testing and when they are applied so that you
    can answer if asked.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, be prepared to answer general questions about what makes good unit tests
    and how to use them to improve code quality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have now covered the material for this chapter and are ready to proceed to
    the next one. First, however, we will summarize our learning.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen examples of how the development life cycle can
    be impacted by anti-patterns at different levels of abstraction. At the highest
    level, how you deal with key trade-offs and how you structure your releases have
    a huge impact on the potential success of your project.
  prefs: []
  type: TYPE_NORMAL
- en: However, we also saw that technical elements such as how you structure your
    packages and whether you write good unit tests can be major contributors to project
    success or failure. That means you must master all of these levels to be a successful
    architect in this domain.
  prefs: []
  type: TYPE_NORMAL
- en: For many architects, this domain can be a bit of a lower priority relative to
    solution architecture or the hardcore technical domains. However, paying insufficient
    attention to these issues can lead to serious project failures just as easily
    as a badly designed solution.
  prefs: []
  type: TYPE_NORMAL
- en: With that being said, we will now continue to our last domain—namely, communication—and
    see how we can mess up our Salesforce projects by communicating in the wrong way.
  prefs: []
  type: TYPE_NORMAL
