- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keeping Integration Straight
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter examines anti-patterns related to integrations with other systems,
    a critical aspect of modern Salesforce implementations. The first part of the
    chapter explores anti-patterns in the integration landscape and integration patterns,
    the second part addresses potential pitfalls in the design and use of interfaces,
    and the third focuses on issues with integration styles. As always, we conclude
    the chapter by distilling the key takeaways.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to not misuse technology to avoid overcomplicating your systems landscape
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it is and isn’t appropriate to create custom services for integrations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to avoid common failures in designing interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use event-based integrations well
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use integration patterns appropriately
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How AI will impact integration patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After completing this chapter, you will have a good idea about how to better
    select integration patterns and structure your integration architecture by learning
    about various ways in which it can go terribly wrong. As Salesforce continues
    to evolve, understanding these integration anti-patterns becomes increasingly
    crucial for architects and developers working with the platform.
  prefs: []
  type: TYPE_NORMAL
- en: Messing up the integration landscape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section covers two anti-patterns that in different ways can create havoc
    in your integration landscape. We will start by looking at how not to use middleware.
  prefs: []
  type: TYPE_NORMAL
- en: Middleware in name only (MINO)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using middleware to create point-to-point connections rather than using its
    extended capabilities
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PumpCo is a large B2B company that specializes in the production of pumps for
    industrial production. It operates in more than 30 markets and has historically
    underinvested in IT systems and used largely manual processes for sales that have
    varied substantially between countries and product lines.
  prefs: []
  type: TYPE_NORMAL
- en: Over the past year, they have started to implement Salesforce Sales Cloud and
    CPQ to drive standardization of the sales process globally. Their one major IT
    platform that has received substantial investment in the past is SAP and, fundamentally,
    SAP runs all key parts of the business today.
  prefs: []
  type: TYPE_NORMAL
- en: Michelle is brought in as an integration architect on the Salesforce implementation
    at an early stage. The integration roadmap is very ambitious as the business wants
    to see all relevant data and processes seamlessly operate across the Salesforce/SAP
    boundary. Fundamentally, they want to be able to access all the relevant back-office
    data and processes directly in Salesforce without the need for a context switch.
  prefs: []
  type: TYPE_NORMAL
- en: Once the initial mapping has been completed, there are 75 discrete integration
    points covering everything from pricing and logistics to HR that would need to
    be implemented to give the full experience that the business is looking for. The
    good news, however, is that many of these integration points can be grouped into
    similar areas, such as a *customer* or *order interface* .
  prefs: []
  type: TYPE_NORMAL
- en: The architects from the Salesforce and SAP sides discuss a number of alternative
    architectures and implementation approaches for creating a small number of stable
    interfaces that would cater to the majority of use cases, but unfortunately, progress
    is slow and there is no real agreement between stakeholders and architects. There
    is a large number of potential solutions in play as well as several technologies
    that could potentially do the job, and the willingness to compromise is low.
  prefs: []
  type: TYPE_NORMAL
- en: The two sides instead agree to let the middleware team manage the process. PumpCo
    has just bought a new middleware platform, and the team there is looking for opportunities
    to get started.
  prefs: []
  type: TYPE_NORMAL
- en: The middleware team will expose services to Salesforce and translate the calls
    to SAP. Any modifications to the APIs will also be its responsibility. Thus, the
    two platform teams don’t have to agree on an approach and can work independently.
  prefs: []
  type: TYPE_NORMAL
- en: As the project progresses, Michelle makes a count of the interfaces Salesforce
    is calling on the middleware. She counts 45. Not quite the original 75, but then
    the scope has also been somewhat reduced as they have gone along.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a diagram of PumpCo’s integration architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – PumpCo integration architecture](img/B30991_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – PumpCo integration architecture
  prefs: []
  type: TYPE_NORMAL
- en: From what she can see, most of these middleware interfaces do little other than
    simply forward a call from Salesforce to SAP and back again. She wonders if that
    is really the best approach, but it’s not her problem anymore.
  prefs: []
  type: TYPE_NORMAL
- en: However, over time, as Salesforce starts seeing more use, issues start occurring
    with the integrations. The error rate is high, there are performance issues, and
    maintenance is getting increasingly complex. Integrations, overall, are causing
    the majority of technical issues on the platform.
  prefs: []
  type: TYPE_NORMAL
- en: A consultant is brought in to assess the situation, and they recommend rationalizing
    the integration architecture as the current setup effectively consists of 45 increasingly
    customized point-to-point connections via the middleware. This creates a lot of
    potential for failure and is generally hard to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Michelle is asked to participate in the redesign process, and after several
    weeks of design work, they end up with a proposal not too far away from one of
    the iterations that were done during the initial project implementation. When
    a senior stakeholder pointedly asks why this wasn’t done in the first place, no
    one is really able to give a convincing answer.
  prefs: []
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The MINO anti-pattern tries to reduce the complexity of creating a good integration
    architecture by introducing middleware. However, it does so in a way that fails
    to leverage the capabilities of a middleware platform, instead simply recreating
    flows via the middleware that might have been found in a point-to-point scenario.
  prefs: []
  type: TYPE_NORMAL
- en: It tends to occur in organizations that have complex system landscapes with
    many interfaces and touchpoints between systems. However, in these organizations,
    there is often little technical governance coordinating between different silos,
    leading to a messy integration architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Other characteristics that are often found with the MINO anti-pattern include
    the presence of dated and inflexible system APIs on key platforms and difficulty
    in agreeing on standard representations of core business entities across those
    key platforms, making it impossible to settle on common interfaces or APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Proposed solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The solution proposed by MINO is simply to introduce a middleware platform without
    paying too close attention to how it is used. By introducing a modern middleware
    platform, the complexities and inflexibilities of legacy systems can at least
    be partially hidden, which leads to good initial results.
  prefs: []
  type: TYPE_NORMAL
- en: That is to say, MINO often seems right on the surface, but if the middleware
    implementation only replicates the existing mess in a new format, relatively little
    is gained. Not nothing, mind you; you may still get some basic middleware capabilities
    such as better error logging, a retry mechanism, or some easier-to-use protocol
    conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Another, and often more influential, reason to go down the road of this anti-pattern
    is that it decouples teams on core platforms from having to deal directly with
    each other. You can often have very different views of the world if you’re working
    on the CRM side than if you are working on the ERP side of a key integration.
  prefs: []
  type: TYPE_NORMAL
- en: MINO allows different teams to only have to deal with the common middleware
    team, who are then given the responsibility for managing the rest. That, unfortunately,
    tends to lead to architectures that don’t really move much beyond the basics.
  prefs: []
  type: TYPE_NORMAL
- en: Results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The result of MINO is often turning your system landscape into an even greater
    spaghetti-like mess than it was before. Now, after all, you have middleware in
    the center, so you can pay less attention to the details of the integration.
  prefs: []
  type: TYPE_NORMAL
- en: 'This lack of attention usually has the following consequences:'
  prefs: []
  type: TYPE_NORMAL
- en: Hard-to-understand integration architecture with too many individual interfaces
    and point-to-point connections, albeit mediated by the middleware
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increased maintenance costs as the complexity is still high and there are now
    more teams involved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lack of technical governance and a potential lack of awareness that such governance
    is even needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increasing error rates on integrations and a commensurately increased fix time
    as teams try to track down errors across platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decreasing performance as there is a more complex flow in place that spans more
    platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, if all you are going to do with your middleware is proxy point-to-point
    connections, you are probably better off not using it at all.
  prefs: []
  type: TYPE_NORMAL
- en: Better solutions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What the MINO anti-pattern teaches is that there is no shortcut you can take
    to get your integration architecture right. You have to carefully consider the
    linkages and dependencies between systems, the business requirements both today
    and going forward, how your master data is distributed, which core capabilities
    your key platforms have, and how you can structure interfaces and patterns to
    best support all these elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some common middleware capabilities are shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Common middleware capabilities](img/B30991_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Common middleware capabilities
  prefs: []
  type: TYPE_NORMAL
- en: With that in mind, you can select the right tools for the job, which may very
    well be a middleware tool. However, before you have thought about which interfaces
    you will need to support across the business and which integration patterns you
    can and must support for different scenarios, and determined how you are going
    to do technical governance across different teams, you shouldn’t be jumping at
    any tool, no matter how cool it looks. We will now move on to the next anti-pattern,
    service proliferation syndrome.
  prefs: []
  type: TYPE_NORMAL
- en: Service proliferation syndrome
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Service proliferation syndrome is an anti-pattern where an excessive number
    of custom services are created, often without proper justification or consideration*
    *of alternatives.*'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: OmniCo has consistently positioned itself as a technology leader and deploys
    many cutting-edge software platforms across its many diversified service lines.
    The company was an early adopter of **service-oriented architecture** ( **SOA**
    ), which they still use to great advantage combined with an **event-driven architecture**
    ( **EDA** ) for high-velocity data and processes.
  prefs: []
  type: TYPE_NORMAL
- en: OmniCo is now implementing Salesforce as a replacement for its old Siebel CRM
    system, which served as an integration hub for many other systems. The Siebel
    CRM was heavily customized to OmniCo processes, and the company is expecting that
    the new Salesforce system will be as well. While their implementation partner
    has made a reasoned argument for staying with standard capabilities, this goes
    against the grain of how OmniCo has historically done things, and they are not
    really looking to change their approach as part of the CRM project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what the old Siebel setup looked like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Old Siebel setup at OmniCo](img/B30991_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Old Siebel setup at OmniCo
  prefs: []
  type: TYPE_NORMAL
- en: For Erhat, the consulting manager in charge of the integration part of the implementation
    project, this is causing a lot of anxiety. He is being pushed by a number of senior
    stakeholders from OmniCo toward building a range of special business services
    that would fit into the OmniCo SOA.
  prefs: []
  type: TYPE_NORMAL
- en: Erhat has tried building customized APIs on vanilla Salesforce in the past,
    and the experience, while ultimately successful, was neither straightforward nor
    fast. In fact, given the number of custom services that are being mentioned, he
    is in doubt about the basic feasibility, given constraints on time, budget, and
    people with the necessary skillsets.
  prefs: []
  type: TYPE_NORMAL
- en: After some pushback, he agrees with stakeholders to deliver two crucial services
    using interfaces similar to the ones exposed by the old Siebel system that are
    used in order management, and that would take a lot of time to re-engineer on
    a different pattern.
  prefs: []
  type: TYPE_NORMAL
- en: These are delivered but prove difficult to get through testing, partially because
    the testing protocols for the services are incomplete and partially because the
    complexity is extraordinarily high.
  prefs: []
  type: TYPE_NORMAL
- en: As the first two services are near completion, a crisis meeting is called by
    OmniCo’s enterprise architecture board. They have just realized that not all the
    business services provided by Siebel will be available in the new Salesforce setup.
    In the view of several members of the board, this will fundamentally undermine
    a range of business processes as other systems would need to change their integration
    approach substantially or switch to manual processing of certain steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Erhat, not knowing the processes at OmniCo very well, finds himself unable
    to argue on the merits of the case. The members of the board present him with
    definitions for an additional 13 services that cover different parts of the lead-to-cash
    process and that were available in the previous Siebel setup. Here’s a schematic
    view of the integrations:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Schematic view of OmniCo Salesforce integrations, not including
    ESB](img/B30991_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – Schematic view of OmniCo Salesforce integrations, not including
    ESB
  prefs: []
  type: TYPE_NORMAL
- en: Erhat can only really push back on a practical level, which he does, arguing
    that the services are outside the scope and are not included in pricing and that
    he doesn’t have the team to deliver the solution. OmniCo grumbles a bit and there
    are a few escalation meetings. However, Erhat is eventually told not to worry—they
    will solve it some other way.
  prefs: []
  type: TYPE_NORMAL
- en: That way turns out to be bringing in a team of disparate contractors to quickly
    build the services alongside the main consulting partner’s team. Erhat can only
    wait and observe as the contractors run into the inevitable technical complexities.
    He leaves the project prior to going live with something of a bad taste in his
    mouth.
  prefs: []
  type: TYPE_NORMAL
- en: Twelve months later, he is back at OmniCo. He has been brought in as an expert
    on the company’s Salesforce APIs, which have proved very error-prone and expensive
    to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: OmniCo are looking for the rationale for why it was built like this in the first
    place and what to do to fix it. They are also considering different approaches
    such as changing integration patterns or bringing in some middleware. Erhat takes
    a deep breath and starts planning the analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The problem that service proliferation syndrome constitutes is how to fit Salesforce
    into an existing enterprise architecture that will have preexisting expectations
    of the capabilities delivered by its key systems. That may be an SOA, as in our
    example, or a different organizing principle, but typically, one that requires
    very specific things from key platforms.
  prefs: []
  type: TYPE_NORMAL
- en: This anti-pattern is common across a variety of platforms as it will potentially
    affect any newcomer to an integration landscape. In the past, it would have been
    more common as organizations were busily building SOAs, often without a lot of
    thought as to the organization of specific services.
  prefs: []
  type: TYPE_NORMAL
- en: This anti-pattern often arises from a misunderstanding of microservices architecture
    or a desire to solve every integration challenge with a custom service.
  prefs: []
  type: TYPE_NORMAL
- en: Today, it is perhaps most commonly encountered when old systems are replaced
    and interfaces are required that don’t quite fit with the standard capabilities
    of built-in system APIs. While Salesforce has extensive APIs, they are very data
    model-centric, and many integration architectures are built along different principles,
    such as coarse-grained business services, which aren’t aligned at all.
  prefs: []
  type: TYPE_NORMAL
- en: Proposed solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Service proliferation syndrome addresses the issue of navigating the integration
    landscape by advocating for the unnecessary creation of new custom services for
    each integration need. This approach overlooks the potential of leveraging existing
    services or standard APIs, which could adequately meet these requirements without
    adding unnecessary complexity.
  prefs: []
  type: TYPE_NORMAL
- en: This is another anti-pattern that can seem deceptively rational as you are,
    after all, directly delivering business value and sometimes in line with expectations
    from cross-company technical governance forums. Therefore, you can be under a
    lot of pressure to go down this route, knowing full well the damage it is going
    to do to your platform in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: Because the capabilities are there on the platform and the need is there in
    the enterprise environment, fighting this anti-pattern can sometimes be impossible.
    This is even more true because the costs only really accumulate over time.
  prefs: []
  type: TYPE_NORMAL
- en: Results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first issue you are likely to see with service proliferation syndrome is
    increased complexity and build costs. Custom services on Salesforce, while feasible
    and sometimes the right choice, are complex to get right. Salesforce isn’t inherently
    an API platform, which is a large reason why they acquired MuleSoft a few years
    back.
  prefs: []
  type: TYPE_NORMAL
- en: The increased complexity will over time lead to increased maintenance costs
    and not just on Salesforce. The various teams using the proliferation of services
    may also face ongoing costs to rework and upgrade their connections.
  prefs: []
  type: TYPE_NORMAL
- en: In a DevOps context, service proliferation poses significant challenges to CI/CD
    pipelines by introducing increased complexity that makes automation and orchestration
    more difficult. This complexity can lead to more frequent deployment failures,
    as the interactions between numerous services can be unpredictable. Furthermore,
    the expanded surface area for potential issues extends recovery times, as teams
    must navigate a greater number of components to diagnose and resolve failures.
    As a result, organizations may find it harder to achieve the speed and reliability
    that DevOps aims to deliver, ultimately impacting the overall efficiency of software
    delivery.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, a custom service can be the right choice, and the benefits can outstrip
    the costs both for the initial build and for the maintenance. That is rarely—if
    ever—the case for 15 custom services as in our example. If you think you need
    that, you probably need to rethink your approach.
  prefs: []
  type: TYPE_NORMAL
- en: Better solutions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first piece of advice is to start by looking at standard integration patterns
    to see whether you can find a standard piece of technology that fits the bill.
    Maybe there is a way of using standard APIs. Maybe you can use a batch process.
    Maybe you can emit events and have other systems subscribe to them.
  prefs: []
  type: TYPE_NORMAL
- en: You should look broadly and not immediately jump to a custom interface, even
    if that seems like a good initial fit. The danger is that you go for the gold-plated
    solution, not realizing the real long-run costs of the decision.
  prefs: []
  type: TYPE_NORMAL
- en: If you do decide that a large number of custom APIs are required—and there are
    situations where that can be justified—you should use a platform that is built
    for this purpose to implement. MuleSoft would be the canonical choice for Salesforce,
    but there are others in the marketplace that can fill this niche.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enhance our service offerings, we can take a step-by-step approach:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify core business capabilities.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Map existing services and APIs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify gaps in our services.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Consider standard solutions before opting for custom services.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additionally, we can consider implementing a robust API management strategy
    to promote the reuse of services and discourage unnecessary service creation.
  prefs: []
  type: TYPE_NORMAL
- en: In a DevOps context, service proliferation can lead to increased complexity
    in CI/CD pipelines and more challenging release management. Therefore, adopting
    a more disciplined approach to service creation is essential, as it aligns better
    with the DevOps principles of simplicity and automation. This ensures streamlined
    processes and enhances overall operational efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, you run the risk of overcomplicating both your Salesforce interface
    and your integration landscape by indiscriminately building services. As always,
    consider the hard trade-offs and make a decision based on a real view of the pros
    and cons. We will now move on to the next section, where we discuss anti-patterns
    that relate specifically to the design of interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Interfacing indecently
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at two common anti-patterns that affect the design
    of integrations at a concrete level. The first, fat interface, looks at a problem
    with interface design, while the second, chatty integration, looks at a problem
    with how interfaces are used.
  prefs: []
  type: TYPE_NORMAL
- en: Fat interface
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a single interface starts doing too many things, you run into a host of
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Joe works as an integration architect for a small Salesforce partner that specializes
    in complex implementations often requiring substantial amounts of code or other
    kinds of customization. He has just started a new contract with RealCo, a major
    real estate investment company that uses Salesforce as the key system of engagement
    across the entire business.
  prefs: []
  type: TYPE_NORMAL
- en: The work he is initially contracted to do includes building a custom interface
    for accessing information about valuations that is used by RealCo’s partners as
    part of making deals. The information is held in RealCo’s Salesforce org and needs
    to be available in real time.
  prefs: []
  type: TYPE_NORMAL
- en: Joe sets up the API constituting the interface on RealCo’s middleware platform
    and orchestrates calls to a few different Salesforce standard APIs and a single
    custom one as part of the implementation. However, close to the go-live of the
    new interface, a bunch of new use cases drops on his desk.
  prefs: []
  type: TYPE_NORMAL
- en: These include not just extensions to the valuation API, such as getting historical
    valuations and trend data, but also entirely different categories of property
    data, including real-time updates through platform events, changes in data streams
    using **Change Data Capture** ( **CDC** ), information about the structure of
    the building, access to key metrics from various assessments, and insights from
    feedback collected during viewings conducted by RealCo partners.
  prefs: []
  type: TYPE_NORMAL
- en: Joe pushes back a bit on the customer, saying that if he’d known that this much
    new functionality would be coming, he might have structured the API differently
    and might have done some things in a suboptimal way to include it with the current
    go-live.
  prefs: []
  type: TYPE_NORMAL
- en: RealCo’s manager listens attentively to Joe but says that ultimately, the decision
    is to go ahead with the additional functionality. RealCo is aware of the potential
    downsides, and it can live with them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The day before the go-live, the same thing happens again. This time, the information
    includes more property-related information but also entirely different classes
    of information, such as demographics and segmentation data related to the area
    in which the property is located, as illustrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – View of RealCo PropertyService](img/B30991_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – View of RealCo PropertyService
  prefs: []
  type: TYPE_NORMAL
- en: Nothing can be done to include this in a day, which RealCo begrudgingly accepts.
    However, it wants a plan from Joe to include it posthaste. Given the immense pressure,
    Joe simply extends the current interface, which is now becoming enormous with
    calls to dozens of Salesforce services, both standard and custom.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, both the initial go-live and the subsequent update go relatively
    well. The teams at RealCo’s partner organizations grumble a bit about the complexity
    of the interface and log a number of bugs. But it works, and they can get on with
    the various applications that the interface needs to drive.
  prefs: []
  type: TYPE_NORMAL
- en: The barrage of change requests keeps happening. And somehow, the changes are
    always exceptionally urgent and needed for critical use cases in one partner or
    another. What’s worse is that an increasing number of teams are relying on the
    interface, which makes upgrades increasingly hard.
  prefs: []
  type: TYPE_NORMAL
- en: Even with good API versioning, the changes between versions are proving quite
    strenuous for the partner teams who are complaining quite loudly about both the
    frequent version changes and the high error rate that has crept into the API implementation.
  prefs: []
  type: TYPE_NORMAL
- en: The final straw comes when a critical bug is found just prior to a new release.
    Joe, having been told to prioritize getting the new functionality out, includes
    a hotfix with the new version, which effectively forces an upgrade on all the
    major partners.
  prefs: []
  type: TYPE_NORMAL
- en: However, it turns out that there are additional breaking bugs in the new API
    version, which means the key partners lose access to key functionality for over
    a week until Joe can get the situation under control.
  prefs: []
  type: TYPE_NORMAL
- en: An escalation meeting is called where the partners can voice their various complaints.
    Joe tries as best he can to explain the history and the reasons for the current
    situation, but unfortunately, the complexities get lost in the general din.
  prefs: []
  type: TYPE_NORMAL
- en: Joe is told that his contract won’t be renewed and that another consultant will
    be brought in to refactor and restructure the interface. He breathes a sigh of
    relief and starts looking forward to his next engagement.
  prefs: []
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The problem posed by the fat interface is fundamentally one of the interface
    structure—that is to say, where to place functionality so that it can be called
    by clients that have a need for the services the interface provides.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Originally, this anti-pattern was applied more to interfaces in the sense of
    the word used in **object-oriented programming** ( **OOP** ). However, it applies
    equally in an integration setting.
  prefs: []
  type: TYPE_NORMAL
- en: There are several different philosophies on interface design. These days, most
    people have an instinctual preference for microservices, which are smallish services
    that carry out a single well-defined and coherent set of functionalities. An example
    could be a notification service that does nothing but send notifications.
  prefs: []
  type: TYPE_NORMAL
- en: A few years back, however, the preference was for coarse-grained business services
    that provided an entry point to a business process—for example, processing an
    order. This was the foundational style associated with SOA, which we have mentioned
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: With a fat interface, however, you are violating a fundamental tenet of interface
    design that is common to most—if not all—of these philosophies. That tenet is
    called interface segregation and holds that clients should never be forced to
    depend on methods that it doesn’t need.
  prefs: []
  type: TYPE_NORMAL
- en: Proposed solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Fat interface proposes to simply continue to add logic to an existing interface
    because it is the easiest thing to do. Designing well-segregated interfaces can
    take work and careful thought, and putting all your functionality into a single
    basket simplifies the problem.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, you can sometimes convince yourself that all the functionality
    really does belong together because there are some tangential commonalities between
    them, and this can be especially true if you have consumers that use substantial
    parts of the functionality you expose.
  prefs: []
  type: TYPE_NORMAL
- en: Often, this anti-pattern is simply the consequence of drift over time. The code
    starts to do one thing, then it does another, and another, and at the end of the
    day, it does everything and walks the dog.
  prefs: []
  type: TYPE_NORMAL
- en: That would be all well and good if it weren’t for the fact that it comes with
    a number of hidden costs that have to be taken into account. We’ll explore these
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The results of the fat interface anti-pattern will be familiar if you have been
    reading this book straight through. It resembles the consequences of poor structure
    that can occur in a multitude of domains.
  prefs: []
  type: TYPE_NORMAL
- en: 'When your interface has grown to the extent that it becomes a fat interface—that
    is to say, it now includes so much diverse functionality that it has effectively
    become unmanageable—you are likely to see some or all of the following consequences:'
  prefs: []
  type: TYPE_NORMAL
- en: Increased complexity, leading to increased cost of change, cycle times, and
    error rates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increased maintenance costs as errors have additional repercussions, clients
    depend on a variety of existing parts of the interface, and the code base is large
    and hard to understand
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only certain developers can make changes to the fat interface because the interdependencies
    and consequences for users of the interface of making changes require in-depth
    knowledge of the entire code base
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bugs in the interface can affect clients that do not even use the kind of functionality
    exposed in the failing method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A large number of client dependencies on the interface make disentangling the
    status quo difficult
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, while this pattern can seem like a minor code smell at a glance, in
    fact, it can create serious issues for your companywide integration landscape
    if you have a failing fat interface in a central position.
  prefs: []
  type: TYPE_NORMAL
- en: Better solutions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This anti-pattern is one of the few that can consistently be avoided by applying
    good practice and discipline to your development processes. If you diligently
    follow your interface standards and apply the interface segregation principle
    whenever you are adding new functionality, this anti-pattern will never occur.
  prefs: []
  type: TYPE_NORMAL
- en: While it may be tempting to take shortcuts, and they might not have serious
    consequences in the short term, you should know the long-term consequences and
    apply sound design and programming practice. This is also an area where an architect
    or developer may have a lot to say as it is too technical an area for most business
    users to really take a position.
  prefs: []
  type: TYPE_NORMAL
- en: The difficulty is, of course, in maintaining the required level of discipline
    when you are under serious pressure to deliver. However, hopefully, making the
    kinds of points raised in this description will help you push back on quick-fix
    thinking.
  prefs: []
  type: TYPE_NORMAL
- en: Chatty integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Chatty integration is an anti-pattern where integration of arbitrary patterns
    makes an unduly large number of calls to one or more interfaces, often resulting
    in performance degradation.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: WoodCo is a furniture maker with a long legacy of making top-tier bespoke furniture
    for well-off clients. They have been growing rapidly over the past years due to
    the launch of an e-commerce platform, built on Salesforce Experience Cloud with
    B2B commerce, that connects their customer community directly with furniture makers
    assigned to their projects.
  prefs: []
  type: TYPE_NORMAL
- en: That way, customers and makers can connect directly and discuss requirements
    for the bespoke builds. Customers can also follow the progress of their furniture
    throughout its life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: WoodCo project manages the builds, including the budgets, and ensures that any
    conflicts are resolved amicably wherever possible. They track these projects in
    an old project control module that they also use to manage their own business.
  prefs: []
  type: TYPE_NORMAL
- en: This project module has recently been extended with a custom-built REST API
    that sits on top of the legacy application. The vendor has built this API specifically
    for WoodCo at great expense, but it’s considered a no-brainer as it will allow
    the direct integration of the portal into the project control module, replacing
    the current manual process where everything is rekeyed into the project control
    module by data entry professionals.
  prefs: []
  type: TYPE_NORMAL
- en: Lina is hired by WoodCo to head up digital projects, the first of which is to
    connect the e-commerce platform to the project control module. She commissions
    a specialist Salesforce partner to lead the work.
  prefs: []
  type: TYPE_NORMAL
- en: They put in place a lightweight middleware platform that subscribes to events
    from Salesforce and translates them into REST calls in the format of the new REST
    API. The REST API doesn’t support any aggregation, so it’s strictly one event
    to one call.
  prefs: []
  type: TYPE_NORMAL
- en: On the Salesforce side, events are initially only fired on status updates or
    when key pieces of standing information, such as a project title, are entered
    or changed. However, over time, this should be extended to tracking the status
    of activities within the project and the communication between maker and customer.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see an overview of the WoodCo integration architecture here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – WoodCo integration architecture](img/B30991_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – WoodCo integration architecture
  prefs: []
  type: TYPE_NORMAL
- en: The integration launches successfully, and everyone in WoodCo cheers. However,
    the full benefit is not yet realized as the activities and customer communication
    are still only in the customer portal, and WoodCo staff still use a combination
    of rekeying and working in multiple systems to get around the constraint.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the day of the update, which will include the full synchronization,
    arrives and everybody waits excitedly for the go-live. However, within minutes
    of the launch, the project module crashes.
  prefs: []
  type: TYPE_NORMAL
- en: The vendor investigates and attributes the error to scalability issues related
    to the initial synchronization. The rollout is deferred to the weekend, and after
    many restarts, the initial data is indeed synchronized.
  prefs: []
  type: TYPE_NORMAL
- en: Monday comes, and people start using the system in anger. There are some complaints
    about slowness in the project control module, but at least the integration seems
    to be working and bringing the critical data across.
  prefs: []
  type: TYPE_NORMAL
- en: Then, on Tuesday morning, an administrator is running some routine batch jobs
    on the customer portal. Near instantly, the project control module comes crashing
    down again and the new integration is taken offline in order to get it back up.
  prefs: []
  type: TYPE_NORMAL
- en: A crisis meeting is called for that evening by WoodCo’s CIO. This has reached
    the level of CEO attention, and something needs to be done. Lina entrusts Aki,
    her most technically gifted subordinate, to figure out the root cause.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, both vendors are blaming each other for the failure and are digging
    their heels in, refusing to take unilateral action to fix the problem. Aki, therefore,
    dives right into the middle of the technical setup.
  prefs: []
  type: TYPE_NORMAL
- en: He examines log files and code from Salesforce, the middleware, and the project
    control module, and after a few hours, he is confident that he has found the root
    cause. The problem is caused by a recursive update rule that applies certain updates
    to a parent project, such as a change of billing code, to all activities in that
    project’s scope.
  prefs: []
  type: TYPE_NORMAL
- en: Before the new update, this didn’t matter as changes on the activity level weren’t
    synchronized. However, with the update, each such change triggers hundreds of
    update events on Salesforce, each of which triggers a callout to the project control
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see an overview of the WoodCo project structure here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – WoodCo project structure](img/B30991_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.7 – WoodCo project structure
  prefs: []
  type: TYPE_NORMAL
- en: This legacy system can handle maybe one or two such updates at the same time
    while also serving users normally, but anything more than that causes issues—first,
    performance degradation, and eventually, a crash. When the administrator launched
    a batch job to reassign a number of **project identifiers** ( **PIDs** ), this
    triggered updates for dozens of projects and their activity trees, crashing the
    project control module in the process.
  prefs: []
  type: TYPE_NORMAL
- en: At the evening’s meeting, the mood is somber. However, as Aki explains the facts
    of the matter, no one can really disagree. The decision is taken to temporarily
    disable the activity level and for Aki to lead a team to redesign the integration
    so that it avoids overloading the project control module.
  prefs: []
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The chatty integration anti-pattern is a byproduct of the solution to some other
    integration problem that for some reason requires very frequent communication
    between systems. Often, as in our example, that problem involves the transfer
    of state between two or more systems.
  prefs: []
  type: TYPE_NORMAL
- en: It is an anti-pattern that can be hard to spot during development as it tends
    to only become problematic with scale. After all, in most test scenarios, except
    explicit performance tests, we don’t update enough data to really reach a problematic
    number of integration calls.
  prefs: []
  type: TYPE_NORMAL
- en: The problematic implementation can be due to bad practices, such as firing separate
    callouts for every record in a loop, or it can be more insidious, as in our example,
    where subscribed events are mapped 1:1 to REST calls in the middleware. Whichever
    way it occurs, it is at best wasteful and at worst catastrophic.
  prefs: []
  type: TYPE_NORMAL
- en: Proposed solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As noted, chatty integration tends to be a byproduct of the solution to another
    problem; therefore, it doesn’t quite fit our schema. However, in so far as we
    can say it proposes a solution, that solution is to make as many calls across
    system boundaries as necessary to support the business use case without any concern
    for system limitations.
  prefs: []
  type: TYPE_NORMAL
- en: This is usually done for reasons of simplicity. Once you start introducing bulkification,
    queuing, systematic delays, aggregation of calls, throttling, or any other mechanism
    you might consider to limit the rate of calling other interfaces, you also introduce
    complexity in the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: You will have noted from other anti-patterns that complexity is often a driver
    of serious negative consequences, so avoiding it will usually seem like a good
    thing. This, however, is a case where the adage *make the solution as simple as
    possible but no* *simpler* applies.
  prefs: []
  type: TYPE_NORMAL
- en: With chatty integration, you are actually making the solution too simple as
    it doesn’t meet the basic functional requirement without the additional complexity.
    That may mean you need more time and additional tools to get your solution to
    work, but there really is no way around it in this kind of scenario.
  prefs: []
  type: TYPE_NORMAL
- en: This is still true even when using low-code integration tools, sold to make
    your life easy. If you get the integration strategy wrong, the integration won’t
    work as intended. Architecture is about trade-offs, after all.
  prefs: []
  type: TYPE_NORMAL
- en: Results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The results of chatty integration form a spectrum:'
  prefs: []
  type: TYPE_NORMAL
- en: Often, there are no immediate consequences if the target systems are able to
    cope with the extraordinary volume of calls and you stay within Salesforce limits
    as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, you see performance degradation. That can happen on the Salesforce
    side if you make too many async callouts over a time period, and it can obviously
    happen on the target side if you start overloading its capacity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance degradation can turn into periodic errors if you start experiencing
    timeouts or the target servers get temporarily overloaded.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, you can sometimes crash the target system altogether, leading to a
    critical error.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can refer to the following diagram for a visual demonstration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – Chatty integration spectrum](img/B30991_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.8 – Chatty integration spectrum
  prefs: []
  type: TYPE_NORMAL
- en: That doesn’t mean this isn’t an anti-pattern if you happen to be lucky enough
    to be on the left side of the spectrum. It just means that for now, you have gotten
    away with it.
  prefs: []
  type: TYPE_NORMAL
- en: Better solutions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The general advice to follow in order to avoid the chatty integration anti-pattern
    is to understand and design with system limits in mind. We are not creating theoretical
    architectures for theoretical systems. If we were, we would be in academia.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you design an integration as an architect, you are generally doing so
    with a well-defined target environment in mind. That means you should be mindful
    of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand the hard constraints, such as system limits—for example, the maximum
    number of calls supported over a time period
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get information on the actual performance of target systems under whatever level
    of duress they currently experience
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t just fire off calls without consideration of the performance implications
    of doing so
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To mitigate this anti-pattern, organizations can leverage Salesforce’s bulk
    API to efficiently handle large volumes of records and the composite API to make
    multiple related calls in a single request. This approach minimizes the number
    of separate transactions and improves overall performance while ensuring data
    integrity and reducing potential errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, use one or more of the following strategies to ensure that the target
    system can cope:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Bulkification** : Send multiple logical calls in the same message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consolidation** : Combine multiple updates in a single call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Aggregation** : Combine changes to multiple areas into one call covering
    several areas.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Delay** : Introduce a delay in sending off a call when performance is spiky.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduce frequency** : Send updates less often.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Buffer** : Add your calls to a queue that is gradually drained as the target
    system has capacity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event** : Consider using Salesforce’s Streaming API to reduce the number
    of callouts and implement a more event-driven architecture. By leveraging the
    Streaming API, you can listen for changes to Salesforce records in real time,
    allowing your applications to react swiftly to data changes without the need for
    frequent polling. This approach enhances efficiency and responsiveness in data
    handling, making it a valuable integration for modern applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, a chatty integration has the potential to level your integration landscape
    if you are unlucky. Therefore, it should be avoided even when you don’t believe
    you will run into trouble in the short term.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the patterns wrong
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we look at how becoming too obsessed with a single integration
    style can cause serious problems by looking at the integration pattern monomania
    anti-pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Integration pattern monomania
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Integration pattern monomania happens when a single integration pattern is used
    to the exclusion of all others, regardless of whether it is a good fit for the
    requirements under consideration.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'WineCo has been a heavy user of Salesforce technology for more than a decade.
    It has a large estate of many orgs across core clouds: Marketing Cloud and Commerce
    Cloud.'
  prefs: []
  type: TYPE_NORMAL
- en: They have developed a custom approach to building on Salesforce, including a
    range of frameworks and libraries that they use consistently across projects.
    Many of these could use an update, but they are still preferred for the sake of
    consistency.
  prefs: []
  type: TYPE_NORMAL
- en: Clare is brought in from a leading consultancy to lead the build of a new app
    that WineCo is building for its distributors. The app will include communications
    between WineCo managers and the distributors, e-commerce for standard items, rebate
    management, custom pricing logic, joint opportunity management, and the ability
    to request quotes for special requirements.
  prefs: []
  type: TYPE_NORMAL
- en: To deliver the required level of functionality and realize the business value
    attributed to the distributor portal, Clare will need to ensure that integrations
    are in place to many systems.
  prefs: []
  type: TYPE_NORMAL
- en: She must funnel all communications through the central notification service
    that ensures all communications are appropriately logged and have the right footers
    in place. Then, she must integrate with the existing rebate management system
    that calculates the rebates due to distributors based on their segment and historical
    orders.
  prefs: []
  type: TYPE_NORMAL
- en: Pricing will come from Salesforce CPQ but in a different org, requiring a Salesforce-to-Salesforce
    integration. Content for the portal web pages will come from the corporate CMS.
    However, there are also services for user and behavior tracking that must be integrated
    from the CMS into the portal website.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the ERP system needs to be updated with any custom quotes and standard
    orders that are made through the distributor portal. The distributor portal will
    also need to get a substantial amount of data about distributors, their existing
    orders, and standing data about them from the ERP system. All in all, while the
    basic build on Salesforce is complex, the integration landscape is even more complex.
  prefs: []
  type: TYPE_NORMAL
- en: 'The proposed architecture is represented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – Proposed integration architecture for WineCo](img/B30991_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.9 – Proposed integration architecture for WineCo
  prefs: []
  type: TYPE_NORMAL
- en: Further complexity is added by WineCo’s corporate integration standard. It states
    that all integrations from Salesforce must be implemented using the company’s
    integration library. That would be fine; however, the only patterns supported
    by this library are synchronous or asynchronous REST callouts, limiting the options
    for the integration design considerably.
  prefs: []
  type: TYPE_NORMAL
- en: Clare and her team get on with it, regardless. They complete much of the core
    Salesforce build ahead of schedule, but the integrations are lagging behind. They
    run into several different problems.
  prefs: []
  type: TYPE_NORMAL
- en: First, the rebate system doesn’t support any kind of bulkification, leading
    to large numbers of calls to its APIs. The system owner questions whether the
    current setup will scale in a go-live scenario, and eventually, four new servers
    need to be procured to give the business comfort that the system can handle the
    load.
  prefs: []
  type: TYPE_NORMAL
- en: Second, there are too many queries to the ERP system, leading to slow response
    time and long wait times in the UI. This proves unsolvable under the current architecture,
    and a decision is made to handle it as a training issue.
  prefs: []
  type: TYPE_NORMAL
- en: Third, the CMS services prove hard to call from the server side, and a compromise
    is made to include the tracking code via JavaScript, although this requires a
    formal exception and causes substantial delay.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the notification service is a bad fit for many of the messaging requirements
    that the distributor portal has and results in weirdly formatted messages that
    are hard to reply to in many cases. That is also accepted and consigned to be
    handled as a training issue.
  prefs: []
  type: TYPE_NORMAL
- en: The project is completed and goes live without much fanfare. The internal users
    dislike the new interface and distributor adoption is lukewarm. Clare makes a
    final argument for redesigning the basic integration architecture to something
    more suitable, before moving on to the next project.
  prefs: []
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Integration pattern monomania seeks to address the problem that designing a
    good integration architecture is fundamentally hard, as is determining the right
    patterns, design, and implementation characteristics of concrete integrations.
  prefs: []
  type: TYPE_NORMAL
- en: It is, therefore, attempting to simplify the problem by focusing on a single
    approach that works well in many cases. That way, you can define a standard way
    of doing things without having to grapple with the exact details of each individual
    case.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is attractive for several reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: First, standards often work. In many cases, having a standard way of doing things
    is the right way to go. However, an entire integration architecture is too broad
    a target for such an approach.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, once you have chosen an approach, you can create supporting assets,
    such as code libraries and frameworks for logging and error handling, that will
    work across integrations, which is generally beneficial.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third, you only really need developers to know how to do a single thing. That
    reduces development complexity, training, and onboarding needs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of that would be great if it weren’t for the inconvenient fact that no single
    integration pattern is universally applicable.
  prefs: []
  type: TYPE_NORMAL
- en: Proposed solution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Integration pattern monomania proposes to use a single integration pattern for
    all—or at least, nearly all—concrete integrations needed in an integration architecture.
    It can either be explicitly set via a corporate standard or be implicit in the
    way the architects and developers work and think. In either case, when such a
    preference becomes excessively strong, you have an anti-pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The aims of integration pattern monomania are usually quite sensible:'
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the complexity of integrations by limiting the choices architects and
    developers need to make
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforcing consistency in the enterprise architecture to avoid unwanted side
    effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make developers’ lives easier by giving them a clear way forward and supporting
    them with relevant tools and frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The issue is that not all concrete integrations will fit a given pattern. Characteristics
    such as the velocity of updates, acceptable latency, data volumes, and the needs
    of the **user experience** ( **UX** ), among other concerns, mean that overreliance
    on a single integration pattern is detrimental in the long term. We will explore
    this next.
  prefs: []
  type: TYPE_NORMAL
- en: Results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The problems caused by integration pattern monomania boil down to technical
    misfits. This is something we have seen in other anti-patterns—for instance, Golden
    Hammer. While some positives may apply in specific cases, overall you are likely
    to see some of the following consequences:'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of decreasing complexity as intended, your integration landscape becomes
    more complex due to a variety of workarounds needed to accommodate the limitations
    of the integration pattern that is being used exclusively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some integrations may not function within their intended quality parameters
    because of poor technical fit. That may mean periodic errors, poor performance,
    or similar.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These factors generally imply a burden of higher maintenance and support on
    an ongoing basis to correct the issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, the UX in some areas will be underwhelming to end users as the pattern
    can’t meet expectations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overall, you don’t get the anticipated benefits and instead end up with a bit
    of a mess.
  prefs: []
  type: TYPE_NORMAL
- en: Better solutions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The solution to integration pattern monomania is simple. Don’t get overly fixated
    on a single integration pattern, whether that is RESTful callouts, EDA, or batch
    transfers.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, you can give good guidance to application developers and architects
    about which patterns are appropriate in which circumstances. It is fine to have
    a preference where all else is equal, but in practice, things rarely are.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an overview of Salesforce integration patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – Overview of Salesforce integration patterns](img/B30991_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.10 – Overview of Salesforce integration patterns
  prefs: []
  type: TYPE_NORMAL
- en: A certain level of conservatism toward choosing integration patterns can be
    warranted. That can give you some of the benefits that come from having a consistent
    approach, such as leveraging standard frameworks and libraries.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use middleware to create a certain commonality of integration stance
    between systems, although that just moves the complexity onto another platform.
    However, when push comes to shove, if a certain approach is the right one for
    your integrations, then you should use it.
  prefs: []
  type: TYPE_NORMAL
- en: Event hell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*When event based architecture goes bad, it results in this anti-pattern, involving
    failing scalability* *and control.*'
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SalesCo, a mid-sized company specializing in custom manufacturing equipment,
    has been using Salesforce as their CRM for several years. Their implementation
    has grown organically, starting with basic lead and opportunity management and
    gradually expanding to include custom objects for managing complex product configurations,
    quotes, and order fulfillment.
  prefs: []
  type: TYPE_NORMAL
- en: As the business grows, SalesCo’s leadership decides to modernize their approach
    to system integration. They have heard about the benefits of EDA and want to leverage
    Salesforce’s event capabilities to create a more responsive and integrated system
    landscape.
  prefs: []
  type: TYPE_NORMAL
- en: Sarah, a senior Salesforce developer at SalesCo, is tasked with implementing
    this new event-driven approach. She is excited about the potential of using platform
    events to decouple various processes and create a more flexible system.
  prefs: []
  type: TYPE_NORMAL
- en: Sarah starts by identifying key business processes that could benefit from an
    event-driven approach. She creates platform events for various stages of the sales
    process, product configuration updates, quote generation, and order fulfillment.
    The idea is to have different parts of the system react to these events, rather
    than having tightly coupled, synchronous processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, when a sales representative marks an opportunity as **Closed Won"**
    , an **OpportunityClosedEvent** would be fired. This event would trigger several
    actions:'
  prefs: []
  type: TYPE_NORMAL
- en: The order fulfillment team would receive a notification to start processing
    the order.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The finance system would be notified to generate an invoice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The inventory management system would reserve the required products.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The customer success team would be alerted to initiate onboarding.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, when a product configuration is updated, a **ProductConfigChangedEvent**
    would be emitted, triggering recalculations of quotes, updates to related opportunities,
    and notifications to relevant sales representatives.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, this approach seems to work well. The system becomes more responsive,
    and different teams can work more independently. Encouraged by this success, Sarah
    and her team continue to add more events and event-driven processes.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, as the number of events and event handlers grows, problems begin to
    emerge:'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging becomes increasingly difficult. When issues arise, it is challenging
    to trace the exact sequence of events and handlers that led to the problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance starts to degrade. With multiple handlers firing for each event,
    and some handlers triggering additional events, the system begins to slow down,
    especially during peak usage times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data inconsistencies start to appear. With multiple processes updating related
    records based on events, it becomes hard to maintain data integrity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development velocity decreases. As the event-driven system grows more complex,
    even small changes require careful consideration of potential ripple effects across
    the entire system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Onboarding new team members becomes challenging, as understanding the full system
    behavior requires knowledge of numerous events and their handlers spread across
    different parts of the code base.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Despite these issues, the SalesCo team is reluctant to move away from their
    event-driven approach. They have invested significant time and resources into
    this architecture, and many of their processes now rely on it. Sarah finds herself
    in a difficult position, trying to maintain and extend a system that has become
    unwieldy and hard to manage.
  prefs: []
  type: TYPE_NORMAL
- en: Problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The event hell anti-pattern occurs when a system becomes overly reliant on events
    for communication between components, leading to a complex and difficult-to-maintain
    code base. This anti-pattern is particularly prevalent in systems that embrace
    EDA without fully understanding its implications or establishing proper guidelines
    for its use.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of Salesforce, event hell often manifests through the overuse
    of platform events, the Streaming API, and trigger-based automations. While these
    technologies offer powerful capabilities for building responsive and decoupled
    systems, their misuse can lead to a tangled web of event emissions and handlers
    that obscures the system’s behavior and makes it challenging to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Key characteristics of event hell include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Excessive event usage** : Events are used for nearly all inter-component
    communication, even for simple, synchronous operations that don’t require the
    complexity of event-driven design.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complex event flows** : As the number of events and handlers increases, the
    flow of control becomes increasingly difficult to follow. A single user action
    might trigger a cascade of events, making it hard to predict or understand the
    full impact of any given operation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lack of clear ownership** : In an event hell scenario, it often becomes unclear
    which component or process is responsible for specific data or functionality.
    Multiple components may emit or react to the same events, leading to confusion
    about where certain operations actually occur.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Debugging difficulties** : Tracing the execution path in an event hell scenario
    is extremely challenging. When an issue arises, developers may need to sift through
    numerous event handlers across multiple components to understand what’s happening.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance issues** : The constant emission and handling of events can lead
    to performance degradation, especially in systems with high transaction volumes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data inconsistencies** : With multiple processes updating related records
    based on events, maintaining data integrity becomes increasingly difficult.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing challenges** : Event hell makes unit testing particularly difficult,
    as components often rely on complex event interactions that are hard to mock or
    simulate in isolation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the Salesforce ecosystem, event hell can be particularly problematic due
    to the platform’s governor limits. Excessive event publishing and handling can
    quickly consume CPU time, SOQL query limits, and DML operations, leading to system
    timeouts and failures.
  prefs: []
  type: TYPE_NORMAL
- en: Proposed solution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **event hell anti-pattern** often emerges as a proposed solution to legitimate
    architectural challenges. It promises to deliver a highly decoupled, responsive,
    and scalable system by leveraging the power of EDA. The allure of this approach
    is strong, particularly in the Salesforce ecosystem, where platform events and
    the Streaming API offer powerful capabilities for building event-driven systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Proponents of this approach argue that by using events for most inter-component
    communication, you can achieve the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Loose coupling** : Components only need to know about the events they publish
    or consume, not about other components in the system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability** : Event-driven systems can theoretically handle increased load
    by adding more event consumers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adaptability** : New functionality can be added by creating new event consumers
    without modifying existing code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Real-time responsiveness** : Events allow for immediate reactions to changes
    in the system state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration simplification** : Events can serve as a universal language for
    integrating diverse systems and services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the context of Salesforce, the proposed solution often involves the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Using platform events for most inter-object and inter-process communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing numerous Apex triggers to publish events in response to record
    changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating multiple Apex classes to subscribe to and handle various events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing Process Builder or Flow to react to events and update records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating external systems primarily through event publication and consumption
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This approach seems to solve many common architectural challenges. It appears
    to reduce direct dependencies between different parts of the system, allow for
    easy extension of functionality, and provide a clear mechanism for real-time updates
    and integrations.
  prefs: []
  type: TYPE_NORMAL
- en: However, as we’ll see in the next section, this solution often creates more
    problems than it solves when applied indiscriminately.
  prefs: []
  type: TYPE_NORMAL
- en: Results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When the event hell anti-pattern takes hold, the result is a system that, despite
    its promise of flexibility and decoupling, becomes increasingly brittle, hard
    to understand, and difficult to maintain. The consequences of event hell in a
    Salesforce implementation can be severe:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reduced system stability** : As the web of events and handlers grows, the
    system becomes more prone to unexpected behavior. A small change in one part of
    the system can have far-reaching and unforeseen consequences, leading to increased
    bug rates and system instability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance degradation** : The constant publishing and handling of events
    can put a significant strain on system resources. In Salesforce, this can quickly
    lead to governor limit exceptions, especially in high-volume scenarios. Users
    may experience slower response times and more frequent timeout errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Debugging nightmares** : When issues occur, tracking down the root cause
    becomes extremely challenging. Developers must trace through complex chains of
    event publications and handlers, often spread across multiple objects and classes.
    This significantly increases the time and effort required to resolve problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data integrity issues** : With multiple processes updating related records
    based on events, maintaining data consistency becomes a major challenge. Race
    conditions can occur when multiple event handlers attempt to update the same records
    simultaneously, leading to data conflicts and integrity problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reduced developer productivity** : As the system complexity increases, even
    small changes or feature additions require careful consideration of potential
    ripple effects across the entire event-driven landscape. This slows down development
    and increases the risk associated with each change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Onboarding difficulties** : New team members struggle to understand the system’s
    behavior, as the logic is distributed across numerous event handlers rather than
    being centralized in more traditional service layers or controllers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing challenges** : Writing comprehensive unit tests becomes extremely
    difficult, as individual components are tightly coupled to the event system. Integration
    tests become more critical but are also more complex to set up and maintain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability issues** : Ironically, while EDAs are often adopted for their
    perceived scalability benefits, event hell can lead to the opposite result. As
    the volume of events increases, the system may struggle to keep up, leading to
    event backlogs and processing delays.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increased operational costs** : The complexity introduced by event hell often
    requires more powerful (and expensive) computing resources to maintain acceptable
    performance levels. It may also necessitate more sophisticated monitoring and
    alerting systems to track the flow of events and identify issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Limited visibility** : Understanding the current state of the system becomes
    challenging, as important business logic and data transformations happen as side
    effects of events rather than through more visible and traceable direct operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration complexity** : While events can simplify some aspects of integration,
    event hell can make it harder to maintain a clear contract between systems. Changes
    to event structures or handling logic can have unexpected impacts on integrated
    systems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Governance challenges** : In regulated industries, event hell can make it
    difficult to provide clear audit trails and demonstrate compliance, as the sequence
    of operations that led to a particular system state can be hard to reconstruct.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the Salesforce context, these issues are often exacerbated by platform-specific
    limitations. For example, the inability to control the order of trigger execution
    can lead to race conditions between event publishers and handlers. Similarly,
    the platform’s governor limits can be quickly exceeded in complex event-driven
    scenarios, leading to runtime errors and incomplete transaction processing.
  prefs: []
  type: TYPE_NORMAL
- en: Better solutions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To avoid falling into the event hell anti-pattern while still leveraging the
    benefits of EDA in Salesforce, consider the following strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: Reserve events for genuinely asynchronous or decoupled operations. Not every
    state change or business process needs to be event-driven. Use direct method calls
    or synchronous operations for simple, linear processes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Establish well-defined domains within your Salesforce org and use events primarily
    for cross-domain communication. Within a domain, prefer more direct forms of interaction.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Put thought into your event structures. Use versioned events and include only
    the necessary information in each event. This can help manage system evolution
    and reduce the coupling between event producers and consumers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For complex domains where you need a complete history of state changes, consider
    implementing event sourcing. This pattern can provide better traceability and
    make it easier to reason about the system’s state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use platform event triggers to centralize event-handling logic, making it easier
    to manage and debug compared to having multiple separate handler classes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use circuit breaker patterns to prevent event handling from overwhelming the
    system during high-load situations or when experiencing downstream system failures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For complex domains, consider separating read and write models using **Command
    Query Responsibility Segregation** ( **CQRS** ). This can simplify your event-handling
    logic and improve performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accept that in some cases, eventual consistency is sufficient. This can help
    reduce the complexity of your event-handling logic and improve system performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement consistent error handling and dead-letter queues for event processing.
    This can help identify and resolve issues more quickly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep clear, up-to-date documentation of your event schemas, producers, and consumers.
    Consider using tools to generate visual representations of your event flows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Salesforce’s event monitoring features and consider implementing additional
    logging to track event publication and consumption. This can help identify performance
    issues and aid in debugging.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use event-storming sessions with your team to model complex business processes
    before implementing them. This can help identify appropriate boundaries and event
    usage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For some scenarios, other integration patterns, such as request-response or
    publish-subscribe, might be more appropriate than a purely event-driven approach.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For complex event handling that may approach governor limits, consider using
    Queueable Apex to break the processing into manageable chunks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use Salesforce’s platform cache to store frequently accessed data that’s derived
    from events, reducing the need for repeated complex event processing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use feature flags to gradually roll out event-driven features and to quickly
    disable problematic event flows if issues arise in production.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By applying these strategies, you can create a more maintainable and performant
    event-driven system in Salesforce, avoiding the pitfalls of event hell while still
    reaping the benefits of reactive, decoupled architectures. Remember, the goal
    is to use events as a powerful tool in your architectural toolkit, not as a one-size-fits-all
    solution to every integration and communication challenge.
  prefs: []
  type: TYPE_NORMAL
- en: We will now take a slight detour to look at the general impact of new AI technologies
    on integration anti-patterns.
  prefs: []
  type: TYPE_NORMAL
- en: AI’s impact on integrations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As AI continues to evolve and permeate various aspects of software development
    and system integrations, it’s crucial to consider both the potential benefits
    and risks it introduces. This section explores how AI might influence integration
    practices, potentially giving rise to new anti-patterns while also offering opportunities
    to avoid existing ones.
  prefs: []
  type: TYPE_NORMAL
- en: The integration landscape is on the cusp of a significant transformation as
    AI technologies become more prevalent. While the promise of AI-driven integrations
    is enticing, it’s important to approach this new frontier with a critical eye.
    As with any technological advancement, the introduction of AI into integration
    practices may give rise to new anti-patterns that could potentially undermine
    the very efficiencies they aim to create.
  prefs: []
  type: TYPE_NORMAL
- en: One potential anti-pattern that may emerge is what we might call *AI overreliance
    syndrome* . This occurs when organizations become excessively dependent on AI-powered
    integration tools, neglecting human oversight and domain expertise. For instance,
    consider a scenario where a company implements an AI-powered integration platform
    that promises to automatically map data fields and optimize data flows between
    Salesforce and their legacy ERP system. Impressed by the initial results, they
    might reduce their integration team and rely entirely on the AI system. However,
    the AI could fail to understand nuanced business rules and complex data relationships,
    leading to critical errors in inventory management and order processing. This
    overreliance could result in a loss of human expertise and context, potential
    for systemic errors due to misunderstood business logic, and difficulty in troubleshooting
    and resolving complex integration issues.
  prefs: []
  type: TYPE_NORMAL
- en: Another potential anti-pattern we might see is *black-box integration* . This
    could emerge when AI models used in integrations become so complex that they’re
    incomprehensible to human developers and architects. Imagine a company employing
    a sophisticated machine learning model to manage real-time data synchronization
    between Salesforce and multiple external systems. The model continuously evolves
    based on data patterns. Over time, the integration behavior might become unpredictable,
    and the team could struggle to explain or control certain data transformations.
    This lack of transparency and auditability could lead to difficulties in maintaining
    compliance with data regulations and increase the risk of unexpected behavior
    in critical business processes.
  prefs: []
  type: TYPE_NORMAL
- en: We might also encounter what we could call *training data bias amplification*
    . This anti-pattern could occur when AI models used in integrations are trained
    on biased or incomplete datasets, leading to skewed results and potentially discriminatory
    outcomes. For example, a financial services company might use an AI model to integrate
    customer data from Salesforce with their credit scoring system. If the model is
    trained primarily on historical data from urban areas, it might fail to accurately
    assess creditworthiness for rural customers, leading to unfair loan rejections.
    This could result in the perpetuation and amplification of existing biases, potential
    legal and ethical issues, and erosion of trust in AI-driven integration systems.
  prefs: []
  type: TYPE_NORMAL
- en: While these potential anti-patterns paint a cautionary picture, it’s important
    to note that AI also offers significant opportunities to mitigate existing integration
    anti-patterns. For instance, AI could help prevent the *fat interface* anti-pattern
    by analyzing usage patterns and suggesting optimal interface structures. It could
    also address *integration pattern monomania* by suggesting the most appropriate
    integration patterns based on real-time system behavior and requirements. Moreover,
    AI models could help prevent *chatty integration* by predicting potential performance
    bottlenecks and suggesting optimizations.
  prefs: []
  type: TYPE_NORMAL
- en: To harness the benefits of AI in integrations while avoiding potential pitfalls,
    a balanced approach is crucial. This might involve combining AI recommendations
    with human expertise for critical integration decisions, prioritizing AI models
    and tools that provide clear explanations for their decisions, implementing robust
    monitoring systems to track AI-driven integration performance, ensuring AI models
    are trained on diverse, representative datasets to minimize bias, and conducting
    periodic audits of AI-driven integration systems.
  prefs: []
  type: TYPE_NORMAL
- en: As AI continues to reshape the integration landscape, it’s crucial for Salesforce
    architects and developers to stay informed about both the opportunities and risks
    it presents. The journey of AI in the realm of integrations is just beginning,
    and it’s likely that new anti-patterns and solutions will emerge as the technology
    evolves. Staying adaptable, critical, and informed will be key to navigating this
    exciting yet challenging landscape.
  prefs: []
  type: TYPE_NORMAL
- en: We have now completed our coverage of the patterns in this chapter and will
    continue to the key takeaways.
  prefs: []
  type: TYPE_NORMAL
- en: Knowing the takeaways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will abstract a bit from the specific patterns and instead
    try to pull out the wider learning points you can use in your day-to-day work
    as a Salesforce architect or in preparing for the CTA Review Board.
  prefs: []
  type: TYPE_NORMAL
- en: 'When architecting Salesforce solutions, you should be mindful of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Middleware can be a great way to create order and improve the structure of your
    system landscape. However, you can also use it in ways that do more harm than
    good.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If all you are doing is replacing point-to-point connections with equivalent
    one-to-one flows through the middleware, you are probably in anti-pattern territory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom services can be a great addition to your Salesforce org in certain cases.
    However, they come with considerable added complexity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should never reflexively add lots of custom services because they seem to
    be what the business is calling for. Instead, take a step back and look at the
    big picture of requirements to see what options you have for realizing the specific
    integration flows required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are building custom interfaces, whether on Salesforce or on your middleware
    platform, have appropriate governance in place to avoid ending up with a fat interface
    that does everything.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid excessively frequent integration calls if possible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you do need high-frequency state transfer, consider using a dedicated technology
    such as CDC.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, always design integrations with system limitations explicitly considered.
    Don’t assume an old ERP can handle unlimited calls, for example. Salesforce, of
    course, also has defined limits.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep a flexible approach to integration architecture. Don’t fall in love with
    a particular style and use it for everything. Just because event-driven microservices
    are hot, doesn’t mean they are right for every scenario. Consider leveraging Salesforce’s
    *Integration Patterns* guide for guidance on selecting appropriate integration
    patterns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do give good guidance on how to select integration patterns for both members
    of your team and external partners. Don’t assume that they will make the right
    decisions by themselves.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In preparing for the CTA Review Board, you should be mindful of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Almost every scenario will have a requirement for middleware. You should know
    the key capabilities of common platforms such as MuleSoft and be able to talk
    intelligently about how they fit into the system landscape.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While you may not see enough integrations to create a problem along the lines
    of the MINO pattern in the scenario, it is still worth thinking about the specific
    value the middleware is adding to each of the integration flows you are funneling
    through it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Don’t reflexively just funnel every integration through the middleware—there
    are often exceptions that may require different treatment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Suggesting a custom web service is a major piece of customization and would
    need a strong justification to include in a review board architecture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you need a custom interface, it is more likely that you should be building
    and exposing via the middleware in most scenarios.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While you are not likely to face a situation with a fat interface in a review
    board situation, it is worth considering how you are structuring your integration
    interfaces and whether it is balanced.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to consider the potential performance implications of the designs you
    suggest. Often, scenarios will have high-volume requirements that, if specified
    in an obvious way, will lead to performance issues similar to the chatty integration
    pattern.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be prepared to discuss how DevOps practices can be applied to manage and deploy
    complex integrations in a Salesforce context.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Review the key objectives of the CTA Review Board and be ready to articulate
    how your experience aligns with those objectives.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Familiarize yourself with the latest Salesforce features and best practices
    relevant to your project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure you have all supporting documentation and artifacts ready for presentation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may get quizzed on integration limits for the Salesforce platform, so it’s
    worth having these memorized for the board.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should know all the common integration patterns on the Salesforce platform
    inside out. This includes the decision guidance on when to choose what pattern.
    You are likely to need several at the board, and you should be able to clearly
    articulate why you have chosen as you have.
  prefs: []
  type: TYPE_NORMAL
- en: We have now covered the material for this chapter and are ready to proceed.
    First, however, we will summarize our learning.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have reviewed five different anti-patterns that in very
    different ways can contribute to failing integration architecture. It is worth
    keeping these in mind.
  prefs: []
  type: TYPE_NORMAL
- en: The integration domain is exceedingly complex and there is scope for getting
    things wrong at multiple levels. From choosing the wrong integration patterns
    or misusing your middleware to the technical details of your concrete implementation,
    there are anti-patterns that can potentially cause serious problems not only to
    your project but also at an enterprise architecture level.
  prefs: []
  type: TYPE_NORMAL
- en: This complexity underscores why seasoned architects approach integrations with
    caution. They are one of the most common causes of project failures, both on Salesforce
    and in general.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth reiterating that this chapter is the only one where all the anti-patterns
    apply not just to Salesforce but to all enterprise software systems. Having covered
    this material, you are hopefully slightly better prepared to tackle the challenges
    ahead of you in the integration domain.
  prefs: []
  type: TYPE_NORMAL
- en: Having now covered the integration domain, we will continue to talk about anti-patterns
    that apply to your deployment processes and governance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Process and Communication Anti-Patterns'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part will teach you how to identify and mitigate anti-patterns around process,
    governance, and communication.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B30991_07.xhtml#_idTextAnchor105) , *Keeping the Development
    Life Cycle from Going Off Track*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B30991_08.xhtml#_idTextAnchor118) , *Communication without Mistranslation*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B30991_09.xhtml#_idTextAnchor142) , *Conclusion*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
