- en: <st c="0">10</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="3">Enabling Pro-Dev Extensibility in Power Platform</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="52">This chapter focuses on the capabilities provided by Power Platform
    to professional developers to extend the experience of business solutions built
    on top of Power Platform.</st> <st c="227">We will take a look at how Power Platform
    ensures the smooth integration of these extensibility options with ALM/DevOps
    processes in order to support the software development life cycle of</st> <st
    c="416">these components.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="433">We will start the chapter by looking into connectors and continue
    our work on custom connectors.</st> <st c="531">In the previous chapter, we showed
    how pro developers can build web APIs and deploy them to Power Platform directly
    from Visual Studio; here, we will explore the concept of using the PAC CLI to
    ensure we enable ALM for custom connectors.</st> <st c="769">We will also look
    into the other aspects of the custom connectors, such as environmental variables
    and connection references, and explain their role when moving solutions across
    different</st> <st c="957">target environments.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="977">After that, we will discuss canvas components in Power Apps and
    the key benefits of using them.</st> <st c="1074">From there, we will delve into
    the Power Platform code components, more specifically the Power Apps component
    framework.</st> <st c="1195">For both canvas components and code components, we
    will explain the process of including them in the</st> <st c="1296">ALM process.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1308">We will close this chapter with coverage of Power Pages, how pro
    developers can extend Power Pages with custom code, and how the ALM process can</st>
    <st c="1454">be implemented.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1469">We will cover the following</st> <st c="1498">main topics:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1510">Enabling the power of integration –</st> <st c="1547">connectors</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1557">Overview of canvas components and the</st> <st c="1596">component
    library</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1613">Getting to know the</st> <st c="1634">code components</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1649">ALM for</st> <st c="1658">Power Pages</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1669">Technical requirements</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1692">To follow this chapter, you need</st> <st c="1726">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="1740">Power Platform subscription</st>**<st c="1768">: You can sign
    up for a Power Platform development plan (</st>[<st c="1826">https://powerapps.microsoft.com/en-us/developerplan/</st>](https://powerapps.microsoft.com/en-us/developerplan/)<st
    c="1879">) if you already have a Microsoft Entra ID work account, or you can join
    the Microsoft 365 developer</st> <st c="1981">program (</st>[<st c="1990">https://developer.microsoft.com/en-us/microsoft-365/dev-program</st>](https://developer.microsoft.com/en-us/microsoft-365/dev-program)<st
    c="2054">).</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="2057">Visual Studio Code</st>**<st c="2076">: We recommend using Visual
    Studio Code or Visual Studio with the Power Platform Tools extension, or the IDE
    of your choice.</st> <st c="2202">Visual Studio Code can be found here:</st> [<st
    c="2240">https://code.visualstudio.com/</st>](https://code.visualstudio.com/)<st
    c="2270">. Visual Studio is also available as a free Community</st> <st c="2324">edition:</st>
    [<st c="2333">https://visualstudio.microsoft.com/vs/community/</st>](https://visualstudio.microsoft.com/vs/community/)<st
    c="2381">.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="2382">Power Platform CLI</st>**<st c="2401">: We will be using the
    PAC CLI inside the command line or terminal.</st> <st c="2470">Installation guidance
    can be found</st> <st c="2505">here:</st> [<st c="2511">https://learn.microsoft.com/en-us/power-platform/developer/cli/introduction?tabs=windows</st>](https://learn.microsoft.com/en-us/power-platform/developer/cli/introduction?tabs=windows)<st
    c="2599">.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="2600">Azure DevOps or GitHub</st>**<st c="2623">: We can create an
    Azure DevOps service organization any time</st> *<st c="2686">for free</st>* <st
    c="2694">(</st>[<st c="2696">https://learn.microsoft.com/en-us/azure/devops/user-guide/sign-up-invite-teammates</st>](https://learn.microsoft.com/en-us/azure/devops/user-guide/sign-up-invite-teammates)<st
    c="2778">).</st> <st c="2782">We can also create a GitHub handle and public repository
    (</st>[<st c="2840">https://github.com/signup</st>](https://github.com/signup)<st
    c="2866">), which is also</st> *<st c="2884">free</st>* <st c="2888">for</st>
    <st c="2893">public repositories.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="2913">Node.js</st>**<st c="2921">: To build PCF code components, you
    require Node.js.</st> <st c="2975">The LTS version is</st> <st c="2994">recommended
    (</st>[<st c="3007">https://nodejs.org/en</st>](https://nodejs.org/en)<st c="3029">).</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="3072">msbuild</st>` <st c="3079">(part of Visual Studio) or</st> `<st
    c="3107">dotnet build</st>` <st c="3119">tools (part of the .NET</st> <st c="3144">SDK:</st>
    [<st c="3149">https://learn.microsoft.com/en-us/dotnet/core/sdk</st>](https://learn.microsoft.com/en-us/dotnet/core/sdk)<st
    c="3198">).</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="3201">Enabling the power of the integration – connectors</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="3252">This section provides a deeper look into how connectors and custom
    connectors can be reused across environments with the help of ALM.</st> <st c="3387">We
    will take a look at the concepts of environmental variables and connection references,
    which are two important concepts for when we plan to scale.</st> <st c="3537">We
    will learn how solutions can be used to wrap connectors for potential reuse across</st>
    <st c="3623">different environments.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3646">Connectors</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="3657">We were introduced to</st> <st c="3680">connectors in</st> [*<st
    c="3694">Chapter 2</st>*](B22208_02.xhtml#_idTextAnchor030)<st c="3703">. Our
    discussion on connectors so far has covered that connectors enable us to connect
    to different services and data sources from within our applications, flows, and
    chatbots.</st> <st c="3880">Connectors can be either certified ones, which connect
    to first- or third-party services, or they can be custom ones.</st> <st c="3998">Certified
    connectors are prebuilt and cannot be changed, whereas custom connectors give
    us the freedom to create our own connectors to connect to either our own custom
    services/APIs or other services for which a prebuilt connector does not</st> <st
    c="4238">yet exist.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4248">Connectors act as wrappers around sets of API operations, which
    are categorized as either triggers</st> <st c="4348">or actions.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="4359">Triggers</st>** <st c="4368">are</st> <st c="4373">operations
    in a connector that respond to a certain event, for example, a SharePoint list
    item being created.</st> <st c="4483">Two types of triggers exist: polling triggers</st>
    <st c="4528">and pushing triggers.</st> **<st c="4551">Polling</st>** <st c="4558">triggers</st>
    <st c="4568">proactively check for changes.</st> <st c="4599">They repeatedly,
    at regular intervals, perform calls of the specified service endpoint to look
    for new data.</st> **<st c="4708">Pushing</st>** <st c="4715">triggers, or webhook
    triggers, are able to react to external events.</st> <st c="4785">When a certain
    event occurs, the service endpoint notifies the trigger via the</st> <st c="4864">callback
    URL.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="4877">Actions</st>** <st c="4885">are</st> <st c="4889">operations
    that help us perform methods (retrieve, create, update, and delete) specified
    in an API definition file.</st> <st c="5006">Operations are performed over the
    data in a service that a connector is connected to, for example, getting all SharePoint
    lists from</st> <st c="5139">a site.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5146">We worked with custom connectors in</st> [*<st c="5183">Chapter
    9</st>*](B22208_09.xhtml#_idTextAnchor149)<st c="5192">. They give us the ability
    to define our own triggers and actions based on the API operations of</st> <st
    c="5289">our service.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5301">Microsoft Power Platform’s open source repository</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5351">Microsoft published an open source repository that allows anyone
    to review existing certified and custom connectors as well as collaborate by submitting
    new connectors to the repository.</st> <st c="5539">The list of predefined connectors
    and custom connectors with the corresponding definition files is published in
    Microsoft’s GitHub repository, which is open to anyone for</st> <st c="5710">contributions:</st>
    [<st c="5725">https://github.com/microsoft/PowerPlatformConnectors/</st>](https://github.com/microsoft/PowerPlatformConnectors/)<st
    c="5778">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5779">Anyone who wants to certify a connector can follow the step-by-step
    approach, described</st> <st c="5868">here:</st> [<st c="5874">https://learn.microsoft.com/en-us/connectors/custom-connectors/submit-certification</st>](https://learn.microsoft.com/en-us/connectors/custom-connectors/submit-certification)<st
    c="5957">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5958">When planning to deploy applications to different target environments,
    we must ensure that our connectors utilize connections that exist in the target
    environments.</st> <st c="6124">To be able to switch to the right connection in
    a target environment in an automated way using pipelines, we recommend using connection
    references.</st> <st c="6272">Let us now take a look at what connection references
    are and how they can</st> <st c="6346">be used.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6354">Connection references</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="6376">When a connector is used in an application or flow to run a certain
    connector operation, a</st> **<st c="6468">connection</st>** <st c="6478">for
    the connector is created in the specific environment.</st> <st c="6537">Connections
    are bound to an environment and store authentication credentials to perform</st>
    <st c="6625">the operation.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6639">Since connections are not solution-aware and do not provide an
    option of decoupling our business solution from the connection, connection references</st>
    <st c="6789">were introduced.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="6805">Connection references</st>** <st c="6827">are</st> <st c="6832">solution
    components that point to a connection for a specific connector.</st> <st c="6905">Using
    connection references allows us to build flexible solutions that enable us to
    programmatically change the connection information in applications and flows.</st>
    <st c="7067">This simplifies the deployment of our solution to different target
    environments when using the DevOps approach, as it allows us to connect to resources
    that are relevant to the</st> <st c="7244">target environment.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7263">Let’s explore another method for parameterizing solution configuration:</st>
    <st c="7336">environment variables.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7358">Environment variables</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="7380">Environment variables act as</st> <st c="7410">configuration parameters
    for solution components, allowing us to dynamically change configuration values
    specific to the target environment.</st> <st c="7551">Environment variables are
    well known in traditional application development, where developers use them to
    decouple the configuration from the application.</st> <st c="7706">This allows
    developers to adapt the application to the target environment without changing
    the application code.</st> <st c="7819">In Power Platform, we follow the same
    concept to use the application components across different target environments
    by only changing the environmental variables.</st> <st c="7982">This way, we can
    connect to a data source or set of APIs that is specific to the</st> <st c="8063">target
    environment.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8082">Environmental variables are usually stored in the format of key-value
    pairs, with values stored outside of the</st> <st c="8193">application source
    code in a secure location, such as</st> **<st c="8248">Azure App Configuration</st>**
    <st c="8271">or</st> **<st c="8275">Azure Key Vault</st>**<st c="8290">, so that
    the values are not easily accessible.</st> <st c="8338">During application</st>
    <st c="8357">runtime or CI/CD pipeline execution, the values are retrieved from
    these services and</st> <st c="8443">used accordingly.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="8460">Utilizing such an approach allows us to enable one of the DevOps
    best practices: parameterizing as much as possible to enable the flexibility of
    our applications.</st> <st c="8624">Hardcoding values in the application source
    code could lead not only to maintenance issues but also to potential</st> <st
    c="8737">security vulnerabilities.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8762">In summary, here are some of the</st> <st c="8796">benefits of
    using</st> <st c="8814">environment variables:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8836">We can decouple the application from the configuration, allowing
    us to easily change the configuration values for data sources and other secrets.</st>
    <st c="8983">For example, we can change the connection to the data sources, such
    as API keys and server URLs, as we deploy our application to different</st> <st
    c="9122">target environments.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="9142">We can reuse environment variables across other solution components.</st>
    <st c="9212">For example, we can create an environment variable that will be used
    in both Power Automate and Power Apps, which</st> <st c="9326">simplifies configuration.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="9351">We can improve security by separating the secrets from the solution
    components and</st> <st c="9435">storing them in a key vault to reduce the risk</st>
    <st c="9482">of misuse.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="9492">When we add environment variables to our solution, Power Platform
    automatically creates entries in two Dataverse tables:</st> **<st c="9614">Environment
    Variable Value</st>** <st c="9640">and</st> **<st c="9645">Environment Variable
    Definition</st>**<st c="9676">. To use environment variables in Power Apps applications,
    we should use a lookup function on these two tables and obtain the values based
    on the names of the environment variables that we create, as seen in the</st>
    *<st c="9888">Introducing feature flags</st>* <st c="9913">exercise in</st> [*<st
    c="9926">Chapter 8</st>*](B22208_08.xhtml#_idTextAnchor134)<st c="9935">. In Power
    Automate, we are able to access environment variables by using the dynamic</st>
    <st c="10021">content selector.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10038">To better understand how we can streamline this operation and
    follow DevOps best practices, we will take a closer look at this approach through</st>
    <st c="10183">an example.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10194">Example – Decoupling configuration from the application</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="10250">In this example, we will be</st> <st c="10278">utilizing connection
    references and environment variables to decouple a configuration from our</st>
    <st c="10374">business solution.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10392">First, we need to create a solution and add all components that
    are part of our business solution, including new environment variables and connection
    references.</st> <st c="10555">Then, we will create a deployment settings file,
    which will decouple the configuration settings from our actual application.</st>
    <st c="10680">This will allow us to configure the values specific to the target
    environment.</st> <st c="10759">We will use the deployment settings file to import
    the solution to a target environment with the relevant</st> <st c="10865">configuration
    values.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10886">Preparing a solution</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="10907">Let us explore the first step of</st> <st c="10940">preparing
    the solution with</st> <st c="10969">configuration settings:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10992">On the Power Apps (</st>[<st c="11012">https://make.powerapps.com</st>](https://make.powerapps.com)<st
    c="11039">) or Power Automate (</st>[<st c="11061">https://make.powerautomate.com</st>](https://make.powerautomate.com)<st
    c="11092">) home page, we can find a</st> **<st c="11120">Solutions</st>** <st
    c="11129">option in the left navigation bar.</st> <st c="11165">Selecting it will
    open a screen with a list of all solutions in the</st> <st c="11233">current environment.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="11253">We either click</st> `<st c="11541">pac solution init</st>` <st
    c="11558">and</st> `<st c="11563">pac solution</st>` `<st c="11576">import</st>`
    <st c="11582">commands.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="11592">Once we are in the solution object explorer, we can add a new
    connection reference by clicking</st> **<st c="11688">New</st>** <st c="11691">|</st>
    **<st c="11694">More</st>** <st c="11698">|</st> **<st c="11701">Connection Reference</st>**<st
    c="11721">.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="11722">To add an</st> <st c="11732">existing connection reference, we
    click on</st> **<st c="11776">Add existing</st>** <st c="11788">|</st> **<st c="11791">More</st>**
    <st c="11795">|</st> **<st c="11798">Connection Reference</st>**<st c="11818">,
    select the existing connection reference, and click</st> **<st c="11872">Next</st>**<st
    c="11876">, as we can see in</st> *<st c="11895">Figure 10</st>**<st c="11904">.1\.</st>*
    <st c="11908">This will add any existing components to</st> <st c="11949">the</st>
    <st c="11953">solution:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Adding components in the solution object explorer](img/B22208_10_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="12421">Figure 10.1 – Adding components in the solution object explorer</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12484">Whenever we are creating new connection references, the</st> **<st
    c="12541">New Connection Reference</st>** <st c="12565">screen will open, as can
    be seen in</st> *<st c="12602">Figure 10</st>**<st c="12611">.2</st>*<st c="12613">.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="12614">Here we must provide the</st> **<st c="12640">Display name</st>**<st
    c="12652">,</st> **<st c="12654">Name</st>**<st c="12658">,</st> **<st c="12660">Connector</st>**
    <st c="12669">values, as well as a</st> **<st c="12691">Connection</st>** <st
    c="12701">value for the selected connector.</st> <st c="12736">Providing a description
    is optional but is recommended to have a better understanding of the use of</st>
    <st c="12836">connection references:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="12858">If there are no connections for a selected connector in the environment,
    we need to create a new one by selecting</st> **<st c="12973">+ New connection</st>**<st
    c="12989">, which opens a new connections screen with a pop-up box for our selected
    connector.</st> <st c="13074">We need to provide all required parameters for the
    connection and click</st> **<st c="13146">Create</st>** <st c="13152">to create</st>
    <st c="13163">a connection.</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="13176">Going back</st> <st c="13187">to the previous</st> **<st c="13204">New
    Connection Reference</st>** <st c="13228">screen, we can now click the</st> **<st
    c="13258">Refresh</st>** <st c="13265">button next to the drop-down list of connections,
    as can be seen in</st> *<st c="13334">Figure 10</st>**<st c="13343">.2</st>*<st
    c="13345">, which will update the list of connections and show the newly created
    connection.</st> <st c="13428">We can select it and proceed by clicking</st> **<st
    c="13469">Create</st>**<st c="13475">, which creates a new component in</st> <st
    c="13510">our</st> <st c="13513">solution.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Creating a new connection reference](img/B22208_10_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="13745">Figure 10.2 – Creating a new connection reference</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13794">To add an</st> <st c="13805">environment variable, we follow similar
    steps to those mentioned in</st> *<st c="13873">step 3</st>*<st c="13879">. This
    time, we select</st> **<st c="13902">New</st>** <st c="13905">|</st> **<st c="13908">More</st>**
    <st c="13912">|</st> **<st c="13915">Environment variable</st>**<st c="13935">.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="13936">A new screen will appear, which will require us to provide more
    information about the environment variable, such as</st> **<st c="14053">Display
    name</st>**<st c="14065">,</st> **<st c="14067">Name</st>**<st c="14071">,</st>
    **<st c="14073">Description</st>**<st c="14084">, and</st> **<st c="14090">Data
    Type</st>**<st c="14099">:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**<st c="14101">Data Type</st>** <st c="14110">specifies the type of our environment
    variable.</st> <st c="14159">This could be</st> **<st c="14173">Decimal number</st>**<st
    c="14187">,</st> **<st c="14189">Yes/No</st>**<st c="14195">,</st> **<st c="14197">Text</st>**<st
    c="14201">,</st> **<st c="14203">Data source</st>**<st c="14214">,</st> **<st
    c="14216">Secret</st>**<st c="14222">, and so on.</st> <st c="14235">After selecting
    a data type, we can configure the default and current value, as can be seen in</st>
    *<st c="14330">Figure 10.3</st>*<st c="14341">. If we are creating an environment
    variable of type</st> **<st c="14394">Data source</st>**<st c="14405">, we get
    the possibility of</st> <st c="14433">selecting</st> **<st c="14443">Connector</st>**<st
    c="14452">.</st>'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Adding a new environment variable](img/B22208_10_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="14836">Figure 10.3 – Adding a new environment variable</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="14883">Default Value</st>** <st c="14897">is not a</st> <st c="14906">required
    field; however, it is something that is used when no</st> **<st c="14969">Current
    Value</st>** <st c="14982">setting is configured.</st> **<st c="15006">Current
    Value</st>** <st c="15019">overrides</st> **<st c="15030">Default Value</st>**
    <st c="15043">and is something that is very useful when deploying to different</st>
    <st c="15109">target environments.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="15129">Once we have configured the environment variable as needed, we
    can click</st> **<st c="15203">Save</st>** <st c="15207">to store the configuration,
    which adds a new component to</st> <st c="15266">our solution.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15279">If we need to add existing environment variables to our solution,
    we can do so by clicking</st> **<st c="15371">Add existing</st>**<st c="15383">|</st>
    **<st c="15386">More</st>** <st c="15390">|</st> **<st c="15393">Environment variable</st>**
    <st c="15413">in the solution object explorer, selecting the existing variables
    from the list, and clicking</st> **<st c="15508">Next</st>**<st c="15512">. The
    next screen shows us the selected environment variables, and for each, we have
    options to select</st> **<st c="15615">Include definition</st>** <st c="15633">and</st>
    **<st c="15638">Include current value</st>** <st c="15659">checkboxes.</st> <st
    c="15672">We can review the existing selected</st> <st c="15708">environment variable
    and click</st> **<st c="15739">Add</st>** <st c="15742">to have it added to</st>
    <st c="15763">our solution.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15776">Current limitations of environment variables</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15821">There are still some limitations when using environment variables;
    for example, data source environment variables cannot currently be managed using
    Microsoft Power Platform Build Tools.</st> <st c="16008">Please make sure to review
    limitations and use environment variables accordingly.</st> <st c="16090">Refer
    to the updated information about the limitations</st> <st c="16145">here:</st>
    [<st c="16151">https://learn.microsoft.com/en-us/power-apps/maker/data-platform/environmentvariables</st>](https://learn.microsoft.com/en-us/power-apps/maker/data-platform/environmentvariables)<st
    c="16236">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16237">Now that we have prepared our solution, we can deploy it to different
    environments.</st> <st c="16322">When importing a solution manually, the import
    process will check whether any connection already exists in the environment for
    the defined connection reference.</st> <st c="16483">If so, import process will
    link it to that connection; if not, it will offer us the chance to automatically
    create and link the connection .</st> <st c="16624">Once the connections are configured,
    the next step allows us to update environment variables with the actual values
    for the</st> <st c="16748">target environment.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16767">To decouple the settings and allow our solution to be imported
    in a more programmatic way, we will take a look at how a deployment settings file
    can be generated</st> <st c="16930">and used.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16939">Building a deployment settings file</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="16975">A</st> **<st c="16977">deployment settings file</st>** <st c="17002">is
    a</st> <st c="17008">JSON-format file that stores the information about the connection
    references and environment variables that are being used in our solution.</st>
    <st c="17148">This same file will be used during the solution import process with
    Power Platform Build Tools or the PAC CLI.</st> <st c="17259">We touched on it
    briefly in</st> [*<st c="17287">Chapter 8</st>*](B22208_08.xhtml#_idTextAnchor134)<st
    c="17296">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17298">We should</st> <st c="17307">export our solution or clone it.</st>
    <st c="17341">We need to</st> <st c="17351">have either a solution ZIP file or
    an unpacked solution folder to which we can point to generate a settings file.</st>
    <st c="17466">We can do this in</st> <st c="17484">two ways:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="17493">By selecting the solution, clicking</st> `<st c="17615">pac solution
    clone --name <solution-name></st>` <st c="17656">or</st> `<st c="17660">pac solution
    export --name <name></st>`<st c="17693">, which means the solution folder will
    be cloned locally or the solution ZIP file will be</st> <st c="17783">downloaded
    locally</st>
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="17801">Now that we</st> <st c="17813">have exported the solution package</st>
    <st c="17849">file, we are ready to create the deployment settings file, using
    the</st> <st c="17918">following approach.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="17937">Generating a deployment setting file can be done by using the
    following PAC</st> <st c="18014">CLI command:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="18496">An example of the structure of the</st> `<st c="18532">deploymentSettings.json</st>`
    <st c="18555">file is present in the</st> [*<st c="18579">Chapter 10</st>*](B22208_10.xhtml#_idTextAnchor172)
    <st c="18589">folder of this book’s GitHub repository.</st> <st c="18631">In the
    file, we can see the structure of the environment variables and connection references
    with the</st> <st c="18733">respective values.</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="18751">For each environment variable in the file, there is a</st> `<st
    c="18806">Value</st>` <st c="18811">property.</st> <st c="18822">Initially, it
    is an empty string that we update with the value for the target environment.</st>
    <st c="18913">The same should be done for the connection references, where the</st>
    `<st c="18978">ConnectionId</st>` <st c="18990">property is initially empty and
    needs to</st> <st c="19032">be provided.</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="19044">To update the connection reference values, we can use the PAC
    CLI to connect to the target environment and list all connections.</st> <st c="19174">This
    will allow us to see whether any of the connections for the given connector already
    exist there.</st> <st c="19276">Once we are pointing the PAC CLI at the target
    environment, we can use the</st> `<st c="19351">pac connection list</st>` <st
    c="19370">command to list all connections established in the selected environment.</st>
    <st c="19444">If a connection exists, copy the</st> `<st c="19477">Id</st>` <st
    c="19479">value of the connection into the deployment settings file under the
    right connection reference</st> `<st c="19575">ConnectionId</st>` <st c="19587">value,
    as shown in</st> [*<st c="19607">Chapter 8</st>*](B22208_08.xhtml#_idTextAnchor134)<st
    c="19616">; otherwise, a create</st> <st c="19639">new connection.</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="19654">Now that we have prepared the deployment settings file for the
    solution, we can proceed with the solution import process, including the specified
    deployment settings file.</st> <st c="19827">If no environment value or path is
    provided with the command, the current environment and the current folder structure
    will be used for the</st> <st c="19966">solution</st> <st c="19976">import:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="20071">The preceding approach presents a programmatic approach for generating
    a deployment settings file, editing it, and importing the solution to the target
    environment.</st> <st c="20237">To follow the DevOps approach, we can use extra
    tasks in the pipelines to manage the deployment settings file and deploy to the</st>
    <st c="20365">target environment.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20384">The deployment settings file and the DevOps approach</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="20437">In</st> [*<st c="20441">Chapter 8</st>*](B22208_08.xhtml#_idTextAnchor134)<st
    c="20450">, we saw how</st> <st c="20462">the deployment settings</st> <st c="20486">file
    can be used within DevOps.</st> <st c="20519">In order to keep things automated,
    we can add an extra task in the pipeline, which will create a deployment settings
    file and store it in the repository, next to our exported solution.</st> <st c="20704">We
    can do that using the PAC CLI.</st> <st c="20738">We have to make sure that when
    we use the Power Platform Tool Installer task in our export pipeline, we add the
    PAC CLI to the</st> `<st c="20865">PATH</st>` <st c="20869">environment variable.</st>
    <st c="20892">The following example shows how it can be done in</st> <st c="20942">Azure
    DevOps:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: <st c="21042">To generate a deployment settings file, we will use a</st> **<st
    c="21097">Command line</st>** <st c="21109">task, with a command that we are now</st>
    <st c="21147">familiar with:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: <st c="21375">The</st> `<st c="21380">git commit</st>` <st c="21390">command</st>
    <st c="21399">that we have as part of our export pipeline will now make sure that
    this new deployment settings file will be added to our repository.</st> <st c="21534">If
    we are creating an artifact within the export pipeline, we should make sure that
    we add the deployment settings file to the artifact using a</st> **<st c="21678">Copy
    files</st>** <st c="21688">task in</st> <st c="21697">the pipeline.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="21710">Now that we have</st> <st c="21727">the deployment settings file
    in our repository, it is time to update the values in the files.</st> <st c="21822">As
    we do not want to keep any sensitive information in our source code, and these
    values can be readable, we recommend parameterizing the values for environmental
    variables and connection IDs for connection references.</st> <st c="22041">As
    an example, in the deployment settings file, we could have values of environment
    variables written like this:</st> `<st c="22154">„Value": „#{ENV_NAME}#"</st>`<st
    c="22177">, and values of connection IDs for connection references written like
    this:</st> `<st c="22253">„ConnectionId": „#{CONN_O365OUTLOOK}#</st>`<st c="22290">.
    A similar approach was shown in</st> [*<st c="22324">Chapter 8</st>*](B22208_08.xhtml#_idTextAnchor134)<st
    c="22333">.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22334">As part of our</st> <st c="22349">deployment pipeline, where we
    import the solution to the environment, we can update the values to be correct.</st>
    <st c="22460">We can do that using a task/action in our DevOps pipeline that searches
    for the tokens with the right prefix and suffix, in our case</st> `<st c="22593">#{
    … }#</st>`<st c="22600">, and replaces those tokens with the actual value stored
    in the variables within the DevOps tool or a secure key vault.</st> <st c="22720">As
    an example, in Azure DevOps and GitHub, we can achieve this with a</st> **<st
    c="22790">Replace</st>** **<st c="22798">tokens</st>** <st c="22804">task/action.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22817">Once the tokens have been replaced with the actual values during
    the deployment pipeline, the next step is to import the solution using the</st>
    **<st c="22958">Power Platform Import Solution</st>** <st c="22988">task, which
    is</st> <st c="23004">part of Power Platform Build Tools.</st> <st c="23040">This</st>
    <st c="23045">allows us to reference the deployment settings file when importing
    the solution.</st> <st c="23126">Here, we can see an example of such a task in
    an Azure</st> <st c="23181">DevOps pipeline:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: <st c="23509">Now that we have a better understanding of how our solutions can
    have configuration settings files that make them reusable across environments,
    this will also help us with building other components, such as canvas components
    and code components.</st> <st c="23756">We will start with canvas components and</st>
    <st c="23797">component libraries.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23817">Overview of canvas components and component libraries</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="23871">When developing applications in Power Apps, app makers use various
    controls for application building blocks.</st> <st c="23981">In order to avoid
    repetition and to build reusable parts of the application that can be used across
    the same application or across multiple apps, app makers should look to canvas
    components.</st> <st c="24172">This section introduces a canvas component together
    with a component library and will help you understand their differences and how
    they fit into the</st> <st c="24322">ALM process.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24334">Canvas components</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**<st c="24352">Canvas components</st>** <st c="24370">serve as</st> <st c="24379">individual
    modular building blocks that encapsulate specific functionality or elements of
    the user interface.</st> <st c="24490">Canvas components are reusable across Power
    Apps canvas apps and model-driven apps.</st> <st c="24574">Not only do these components
    play a crucial role in creating larger and more complex enterprise-grade applications,
    but they are also significant when it comes to working in a larger team in a co-development
    environment, as developers can divide tasks and focus each individual component
    when building a business solution.</st> <st c="24897">An additional benefit of
    creating canvas components is that they can be updated centrally in one place,
    with all updates being reflected in all instances within</st> <st c="25058">the
    application.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25074">Creating canvas</st> <st c="25090">components is done inside Power
    Apps Studio while building a canvas application.</st> <st c="25172">In the left
    navigation bar, under</st> **<st c="25206">Tree view</st>**<st c="25215">, we
    can see all the screens and components that are part of our application.</st>
    <st c="25293">Clicking</st> **<st c="25302">Components</st>** <st c="25312">allows
    us to see all existing components as well as create new ones, by clicking</st>
    **<st c="25394">New component</st>**<st c="25407">. This creates a blank canvas
    component to which we can</st> <st c="25463">add controls:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Creating a canvas component in Power Apps](img/B22208_10_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="25536">Figure 10.4 – Creating a canvas component in Power Apps</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25591">Each component can hold custom properties.</st> <st c="25635">Custom
    properties allow components to either receive values from the application, known
    as input properties, or send data or state from the component to the app, known
    as output properties.</st> <st c="25825">No matter the property type (input/output),
    a custom property can hold data of any data type, spanning from traditional data
    types, such as text and number, to more Power Apps-specific types, such as screen,
    color, and table.</st> <st c="26051">Using custom properties allows the sharing
    of information between the component and the app host.</st> <st c="26149">There
    is one more setting on the canvas component level,</st> **<st c="26206">Access
    app scope</st>**<st c="26222">, and it can be found in the properties of the component
    itself.</st> <st c="26287">It can be turned on or off to allow access to a greater
    set of information</st> <st c="26362">available within the application, such as
    global variables, collections, and controls within the application.</st> <st c="26472">This
    is only applicable to the canvas components within the application and not to
    the components within the component library.</st> <st c="26600">We can turn off
    this setting and feed the information to the component through the</st> <st c="26683">custom
    properties.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26701">Component libraries</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="26721">Since canvas components can only be used within one application,
    in order to reuse the components across applications in the environment, we can
    create a component library.</st> <st c="26895">A</st> **<st c="26897">component
    library</st>** <st c="26914">serves</st> <st c="26921">as a repository for component
    definitions.</st> <st c="26965">This allows an application to manage dependencies
    on the components that it utilizes, which means that whenever a component update
    is available, the app maker will be informed about it.</st> <st c="27151">The
    information about the available update will appear when editing the application
    in Power Apps Studio or by manually clicking a refresh button to check for the
    component</st> <st c="27324">library updates.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27340">Creating a component library is</st> <st c="27372">different from
    creating a</st> <st c="27399">canvas component:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27416">Component libraries can be found by navigating to the Power Apps
    home screen and selecting</st> **<st c="27508">Component libraries</st>** <st
    c="27527">from the left navigation panel.</st> <st c="27560">If you do not see
    this option in the left navigation panel, click on</st> **<st c="27629">More</st>**
    <st c="27633">|</st> **<st c="27636">Discover all</st>**<st c="27648">, where
    you can f</st><st c="27665">ind it under</st> **<st c="27679">App enhancements</st>**<st
    c="27695">:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Accessing Component libraries](img/B22208_10_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="28983">Figure 10.5 – Accessing Component libraries</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29026">Once we are on the</st> <st c="29046">component libraries screen,
    we can click on</st> **<st c="29090">+ New component library</st>** <st c="29113">to
    create a blank canvas for adding</st> <st c="29150">app components.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="29165">Here we can import existing components or create new ones by following
    the same process as with the regular canvas component.</st> <st c="29292">Each
    component that is created or imported in a component library allows makers to
    make customizations in the target environment.</st> **<st c="29422">Allow customization</st>**
    <st c="29441">is a property of the component inside Power Apps Studio.</st> <st
    c="29499">If customization is allowed, then once the app maker starts making changes
    to the component in the application, this will break the reference to the component
    library and create a local copy of the component.</st> <st c="29708">In order
    to maintain control over components and allow component changes only from within
    the component library, turning off this component setting is a</st> <st c="29861">good
    practice.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="29875">Once all components are added to the component library, we need
    to publish the changes.</st> <st c="29964">The publishing process is the same
    as with any other canvas component or canvas app.</st> <st c="30049">If the component
    library is not published, it cannot</st> <st c="30102">be reused.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="30112">Once published, we are ready to reuse the components from the
    library in our application.</st> <st c="30203">To do so, we open our canvas app
    in Power Apps Studio and, in the left navigation panel, click on</st> **<st c="30301">Insert</st>**<st
    c="30307">, which opens an option for adding controls</st> <st c="30351">and components.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="30366">We click on the icon that</st> <st c="30392">represents directory
    search, which opens an</st> **<st c="30437">Import components</st>** <st c="30454">screen.</st>
    <st c="30463">Here we can find our component library and all components that are
    part of the library.</st> <st c="30551">We can select those that we need and</st>
    <st c="30588">click</st> **<st c="30594">Import</st>**<st c="30600">:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 10.6 – Importing components from a component library](img/B22208_10_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="31035">Figure 10.6 – Importing components from a component library</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31094">Components from the component library will appear in the left
    navigation panel under the</st> **<st c="31184">Insert</st>** <st c="31190">option.</st>
    <st c="31199">We can find them in a</st> **<st c="31221">Library components</st>**
    <st c="31239">group, just underneath the</st> **<st c="31267">Custom</st>** <st
    c="31273">category, which holds locally created can</st><st c="31315">vas components,
    as</st> <st c="31335">shown here:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Accessing components from the added component library](img/B22208_10_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="31417">Figure 10.7 – Accessing components from the added component library</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31484">Now that we have learned how to build canvas components and component
    libraries that support the reusability of the components across canvas applications
    in an environment, let’s investigate how we can manage the component library</st>
    <st c="31716">life cycle.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31727">Managing the life cycle of the component library</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="31776">As we saw earlier, in</st> <st c="31799">order to reuse components
    across multiple apps, they need to be added to the component library.</st> <st
    c="31895">Once added to the library, they can be inserted into the application.</st>
    <st c="31965">With that, the application creates a dependency on the selected
    component from the component library and simplifies our</st> <st c="32085">solution
    management.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32105">To deploy our application with a component dependency into a different
    environment, we have to make sure that the component library exists in the target
    environment prior to deploying the application.</st> <st c="32307">Otherwise,
    the import solution process will not succeed.</st> <st c="32364">It is on us to
    make sure that the component library is either bundled together with the application
    inside the solution or moved to the target environment in a separate solution,
    prior to deploying the application that has a</st> <st c="32589">component dependency.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32610">We can check whether the application has any dependencies by navigating
    to</st> **<st c="32686">Solutions</st>**<st c="32695">, selecting our solution,
    clicking</st> **<st c="32730">Object</st>**<st c="32736">, clicking on the three
    dots next to the name of the application, clicking</st> **<st c="32811">Advanced</st>**<st
    c="32819">, and clicking</st> **<st c="32834">Show dependen</st><st c="32847">cies</st>**<st
    c="32852">, as shown in</st> *<st c="32866">Figure 10</st>**<st c="32875">.8</st>*<st
    c="32877">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Checking application dependencies](img/B22208_10_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="33489">Figure 10.8 – Checking application dependencies</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33536">There we will find a tab</st> <st c="33561">called</st> **<st
    c="33569">Uses</st>**<st c="33573">, which shows which objects are being used
    by our application.</st> <st c="33636">Selecting the three dots next to the name
    of the component library will redirect us to</st> **<st c="33723">Default Solution</st>**<st
    c="33739">. It is important to note that component libraries are placed in the
    default solution within the environment.</st> <st c="33849">This will be the same
    when we have moved to the target environment, as long as the environment has</st>
    <st c="33948">Dataverse enabled.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33966">Adding a component library to the solution where our application
    resides can be easily achieved by going to our solution, clicking on</st> **<st
    c="34101">Objects</st>**<st c="34108">, and either creating a new component library
    or adding an existing one.</st> <st c="34181">Creating a new one is done by clicking</st>
    **<st c="34220">New</st>** <st c="34223">|</st> **<st c="34226">More</st>** <st
    c="34230">|</st> **<st c="34233">Component Library</st>**<st c="34250">. Adding
    an existing component library can be done through</st> **<st c="34309">Add existing</st>**
    <st c="34321">|</st> **<st c="34324">More</st>** <st c="34328">|</st> **<st c="34331">Component
    Library</st>**<st c="34348">. Once the component library is added to the solution,
    we can enable/disable the option that allows customizations in the target environment.</st>
    <st c="34490">This setting is available inside the solution explorer.</st> <st
    c="34546">We select our component library, click on the three dots next to its
    name, and then click</st> **<st c="34636">Advanced</st>** <st c="34644">|</st>
    **<st c="34647">Managed properties</st>**<st c="34665">. This will open a screen
    for editing the managed properties of the component library.</st> <st c="34752">Here
    we can toggle on or off the option to allow customizations in the</st> <st c="34823">target
    environment:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – Enabling/disabling customization in the target environment](img/B22208_10_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="35736">Figure 10.9 – Enabling/disabling customization in the target environment</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="35808">Once we have added our component library with all components
    in the solution, we can follow the ALM process that we are already familiar with:
    export the solution from Power Apps using the export pipeline, followed by an
    import pipeline to the target environment, with all other relevant steps in between</st>
    <st c="36114">for testing.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36126">Should we wish to</st> <st c="36144">update the component library
    separately from the application, it makes sense to have a separate pipeline process
    just for updating the component libraries.</st> <st c="36301">We can create a
    separate solution and add one or more component libraries that we would like to
    manage the application life cycles of separately.</st> <st c="36447">We need to
    keep in mind that the component library has to be deployed to the target environment
    prior to importing the solution that has reference to that component library.</st>
    <st c="36621">Once the component is updated, the app maker will be informed about
    the updates through the component update process (automatically</st> <st c="36753">or
    proactively).</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36769">Now that we have learned about canvas components and their reusability,
    we will go further and look what additional customizations are possible with the</st>
    <st c="36923">code components.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36939">Getting to know code components</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="36971">Going one step further in pro-dev extensibility, the</st> **<st
    c="37025">Power Apps component framework</st>** <st c="37055">(</st>**<st c="37057">PCF</st>**<st
    c="37060">) allows</st> <st c="37070">professional developers to create code components
    that enrich the user experience whenever the look and feel of the built-in components
    is not sufficient.</st> <st c="37225">The PCF is such a big topic that it could
    have its own chapter in this book.</st> <st c="37302">In this section, we will
    try to give you at least an initial understanding of what the PCF is, how the
    PAC CLI can help us to build code components, and how to perform ALM using</st>
    <st c="37480">DevOps tools.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="37493">The PCF</st> <st c="37502">is a unified framework that allows
    developers to build custom code components that are reusable across applications
    in Power Apps and websites in Power Pages.</st> <st c="37661">This opens a great
    opportunity for organizations to build code components and leverage them across
    business solutions.</st> <st c="37780">Using the PCF, we can develop code components
    that will include not only information about the visual appearance of the component
    but also the business logic.</st> <st c="37939">This allows us to make applications
    and websites more appealing and customized to the business problem.</st> <st c="38043">The
    PCF is a successor of HTML web resources, which were used prior to PCF to render
    custom UI components inside model-driven applications.</st> <st c="38183">The
    PCF is more optimized for performance compared to HTML web resources, making it
    suitable for complex</st> <st c="38288">business solutions.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38307">Custom pages in model-driven apps</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38341">Custom pages</st> <st c="38354">are flexible and powerful type
    of pages in model-driven apps that enable us to bring the experience from building
    canvas apps to model-driven apps.</st> <st c="38503">We can add canvas and code
    components to a custom page, which can be shown in a model-driven app as a main
    page, center dialog screen, or side dialog view.</st> <st c="38659">This gives
    us a great range of flexibility for building the experience of our</st> <st c="38737">business
    application.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38758">Currently, we know two types of PCF</st> <st c="38795">components:</st>
    **<st c="38807">standard</st>** <st c="38815">and</st> **<st c="38820">virtual</st>**<st
    c="38827">. Both types of components leverage</st> <st c="38863">HTML, CSS, and
    TypeScript.</st> <st c="38890">However, virtual components use two platform-provided
    libraries, React and Fluent UI.</st> <st c="38976">They are added to the parent
    virtual</st> **<st c="39013">Document Object Model</st>** <st c="39034">(</st>**<st
    c="39036">DOM</st>**<st c="39039">), which</st> <st c="39048">means that there
    is no need to instantiate a React virtual DOM separately with each component.</st>
    <st c="39144">Although React and Fluent UI can be used with standard PCF components,
    doing so requires the developer to package libraries individually within the components.</st>
    <st c="39304">In the case of virtual components, we are able to use platform-provided
    libraries, which allows us to improve the performance of our applications using
    these code components.</st> <st c="39479">It is important to note that even if
    we start with a standard code component, we can later convert it to a</st> <st
    c="39586">virtual component.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="39604">Depending on how the component will be used, we can differentiate
    between two types of</st> <st c="39692">PCF components:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="39707">Field</st>**<st c="39713">, where a code component can be bound
    to a field in</st> <st c="39765">a form</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="39771">Dataset</st>**<st c="39779">, which is a code component that
    is bound to a view, dataset, or collection in a canvas app and works with the
    rows of data from</st> <st c="39908">a dataset</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="39917">Using these two types of PCF components, developers can build
    custom fields, columns, and views over datasets and dashboards that can replace
    built-in components in our</st> <st c="40087">business applications.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="40109">Community resources for the PCF</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="40141">For those who are willing to learn</st> <st c="40177">more about
    the PCF and would like to see some examples that the wider community has developed
    using the PCF, Microsoft offers a set of links (to videos, blogs, and a code component
    gallery) that can be used for this purpose.</st> <st c="40402">For more information,
    go</st> <st c="40427">to:</st> [<st c="40431">https://learn.microsoft.com/en-us/power-apps/developer/component-framework/community-resources</st>](https://learn.microsoft.com/en-us/power-apps/developer/component-framework/community-resources)<st
    c="40525">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="40526">Code component composition</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="40553">No matter which control type or kind of component we decide to
    build, code components consist of three main elements—a manifest file, a component
    implementation, and</st> <st c="40720">resource files.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="40735">Manifest file</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="40749">A control manifest</st> <st c="40768">is an XML file that is used
    to register and manage the code component.</st> <st c="40840">The</st> <st c="40844">name
    of the manifest file</st> <st c="40870">is</st> `<st c="40873">ControlManifest.Input.xml</st>`<st
    c="40898">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="40899">It holds all information about the code component, such as</st>
    <st c="40959">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="40973">The component</st> <st c="40988">metadata information</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="41008">Information about the control type (standard</st> <st c="41054">or
    virtual)</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="41065">Whether any external services are going to be used (which would
    require</st> <st c="41138">premium licensing)</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="41156">Properties that are available</st> <st c="41187">for use</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="41194">Used resources</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="41209">Other</st> <st c="41216">metadata and</st> <st c="41229">config
    data</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="41240">The properties available in the code component can then be either
    manually entered or dynamically set to a value or data from other components in</st>
    <st c="41387">the application.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41403">Component implementation</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="41428">Code component logic is</st> <st c="41452">implemented in a file
    called</st> `<st c="41482">index.ts</st>`<st c="41490">. Here we are able to place
    the code that will define the behavior of our code component.</st> <st c="41580">This
    is the place where we can find methods that control the life cycle of our</st>
    <st c="41659">code component.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41674">The life cycle of the code component can be divided into four</st>
    <st c="41737">main methods:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="41750">init</st>`<st c="41755">: This method is used to initialize
    the component instance.</st> <st c="41816">This function not only configures the
    component but can also register any event listeners or add other functionalities
    for the component to properly behave.</st> <st c="41973">This method is required
    to be implemented in the code</st> <st c="42027">implementation file.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="42047">updateView</st>`<st c="42058">: This method gets called when
    any value in the component’s properties or component metadata changes.</st> <st
    c="42161">It is used to reflect the changes in the component’s UI.</st> <st c="42218">This
    method is required to be implemented in the code</st> <st c="42272">implementation
    file.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="42292">getOutputs</st>`<st c="42303">: This method gets called prior
    to a component receiving new data.</st> <st c="42371">This method is optional
    in the code</st> <st c="42407">implementation file.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="42427">destroy</st>`<st c="42435">: This method gets called when the
    component is to be removed from the DOM tree.</st> <st c="42517">It should be
    used to perform any cleanup operation and release any memory that the component
    is using.</st> <st c="42620">This method is required to be implemented in the
    code</st> <st c="42674">implementation file.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="42694">Resource files</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="42709">In the manifest file, one of the</st> <st c="42743">nodes that
    defines code components is</st> `<st c="42781">resources</st>`<st c="42790">.
    This node holds the information about the code resource, which is our</st> `<st
    c="42862">index.ts</st>` <st c="42870">file, which contains code logic.</st> <st
    c="42904">Next to the</st> `<st c="42916">code</st>` <st c="42920">resource, we
    have static files that define the visual appearance of the code component.</st>
    <st c="43009">Here we can find a</st> **<st c="43028">Cascading Style Sheets</st>**
    <st c="43050">(</st>**<st c="43052">CSS</st>**<st c="43055">) file</st> <st c="43062">that
    contains code that controls the visual representation of</st> <st c="43125">the
    component.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43139">Since code components can be reused across applications and environments,
    support for localization is beneficial, as it allows us to share components across
    applications where there might be other language requirements.</st> <st c="43360">The
    PCF supports localization.</st> <st c="43391">Localized strings can be stored
    in RESX web resource files and registered in the manifest file.</st> <st c="43487">Other
    files, for images, icons, or anything else that is required for the component
    to work properly, can be added.</st> <st c="43603">Files are usually stored in
    a separate folder structure, registered in the manifest file, and referenced in
    the</st> <st c="43715">code logic.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43726">Now that we have learned what the file structure of the code components
    looks like, let us go ahead and create our simple</st> <st c="43849">code component.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43864">Creating your code component</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="43893">In this exercise, we will be creating a</st> <st c="43934">virtual
    (React) control type, since this will be the recommended control type</st> <st
    c="44012">going forward.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44026">Prerequisites</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="44040">In order to build the code</st> <st c="44068">component, we need
    to have installed the tools mentioned in the</st> *<st c="44132">Technical</st>*
    *<st c="44142">requirements</st>* <st c="44154">section.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44163">To get the .NET build tools, Visual Studio 2019 or higher (Visual
    Studio 2022) should be installed.</st> <st c="44264">Instead of installing the
    complete Visual Studio, we can select just the .NET build tools as the workload
    during the installation wizard.</st> <st c="44402">An alternative to this is to
    install the .NET 8.0 SDK.</st> <st c="44457">Currently, .NET 8.0 is the latest
    long-term</st> <st c="44501">support version.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44517">Initializing the project</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="44542">First, we need to initialize the</st> <st c="44576">project.</st>
    <st c="44585">For this, we will be using the PAC CLI and its set of commands specific
    to the PCF.</st> <st c="44669">We can achieve this using the</st> <st c="44699">following
    command:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: <st c="44855">Two parameters stand out –</st> `<st c="44883">template</st>`
    <st c="44891">and</st> `<st c="44896">framework</st>`<st c="44905">. Now,</st>
    `<st c="44912">template</st>` <st c="44920">describes whether we will be creating
    a code component that will be used with fields or datasets.</st> `<st c="45019">framework</st>`
    <st c="45028">defines which framework will we be using.</st> <st c="45071">If
    using</st> `<st c="45080">React</st>`<st c="45085">, then this will be marked
    as a virtual control type; otherwise, it will be a standard control type.</st>
    <st c="45186">If we do not provide a</st> `<st c="45209">--run-npm-install</st>`
    <st c="45226">or</st> `<st c="45230">--npm</st>` <st c="45235">switch in the command,
    we will need to run the</st> `<st c="45283">npm install</st>` <st c="45294">command
    separately, to install the</st> <st c="45330">project dependencies.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45351">In our example, we used the</st> <st c="45380">following command
    to initialize the project of a folder structure with some</st> <st c="45456">supporting
    files:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: <st c="45574">Here is the</st> <st c="45587">folder structure:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – Folder structure of the PCF initialized project](img/B22208_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="45716">Figure 10.10 – Folder structure of the PCF initialized project</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45778">Now that we have initialized the project and have files and a
    folder structure, we can move on to start implementing the</st> <st c="45900">code
    logic.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45911">Implementing the code component</st>
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="45943">As we can see in the</st> <st c="45964">folder structure of our
    code component, our manifest file is also present in the</st> <st c="46046">PCF
    project.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="46058">Inside the</st> `<st c="46070">ControlManifest.Input.xml</st>`
    <st c="46095">file, we can see the</st> `<st c="46117">control</st>` <st c="46124">element,
    which includes information about our code component, including the control type
    being set</st> <st c="46224">to</st> `<st c="46227">virtual</st>`<st c="46234">:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: <property name="sampleProperty" display-name-key="Property_Display_Key" description-key="Property_Desc_Key"
    <st c="46761">of-type="Whole.None"</st> usage="bound" required="true" />
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: pac solution init
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: pac solution add-reference --path <LOCATION_TO_PCFPROJ_FILE>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: <ItemGroup>
  prefs: []
  type: TYPE_NORMAL
- en: <ProjectReference Include="..\SamPCF\SamPCF.pcfproj" />
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </ItemGroup>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: dotnet build /t:build /restore
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: pac pcf push –solution-unique-name <SOLUTION_NAME>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: pac pcf push -pp <PUBLISHER_PREFIX>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: <PropertyGroup>
  prefs: []
  type: TYPE_NORMAL
- en: <Name>PCF</Name>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <ProjectGuid>e71d2e10-908c-4123-9f29-3283cbd224ab</ProjectGuid>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <OutputPath>$(MSBuildThisFileDirectory)out\controls</OutputPath>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <PcfBuildMode>production</PcfBuildMode>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </PropertyGroup>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: <PropertyGroup>
  prefs: []
  type: TYPE_NORMAL
- en: <SolutionPackageType>Managed</SolutionPackageType>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </PropertyGroup>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: <control namespace="SimpleReactNS" constructor="SimpleReactPCF" <st c="60190">version="0.0.1"</st>
    display-name-key="SimpleReactPCF" description-key="SimpleReactPCF description"
    control-type="virtual" >
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: pac pcf version --strategy manifest
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: pac pcf version --patchversion <PATCH VERSION>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '# Show all Power Pages websites'
  prefs: []
  type: TYPE_NORMAL
- en: pac pages list
  prefs: []
  type: TYPE_NORMAL
- en: download content of a website with Website Id from Power Pages to a selected
    location. pac pages download -id <PAGES_WEB_ID> -p <DOWNLOAD_LOCATION>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: we perform changes to the file and decide to upload the changes, using the deployment
    profiles. pac pages upload –path <PATH_LOCATION> --environment <ENVIRONMENT_ID>
    --deploymentProfile <PROFILETAG>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '- task: PowerPlatformToolInstaller@2'
  prefs: []
  type: TYPE_NORMAL
- en: 'inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'DefaultVersion: true'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- task: PowerPlatformDownloadPaportal@2'
  prefs: []
  type: TYPE_NORMAL
- en: 'inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'authenticationType: ''PowerPlatformSPN'''
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'PowerPlatformSPN: ''PP-DevUS-SPN'''
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'DownloadPath: ''Portal/'''
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'WebsiteId: ''$(WebsiteID)'''
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- task: CmdLine@2'
  prefs: []
  type: TYPE_NORMAL
- en: 'inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'script: |'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: echo commit all changes
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: git config user.email "<EMAIL@DOMAIN.COM>"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: git config user.name "<USER_NAME>"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: git init
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: git checkout -B main
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: git add --all
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: git commit -m "code commit"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: git push --set-upstream origin main
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'git -c http.extraheader="AUTHORIZATION: bearer $(System.AccessToken)" push
    -f origin HEAD:main'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '- task: PowerPlatformToolInstaller@2'
  prefs: []
  type: TYPE_NORMAL
- en: 'inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'DefaultVersion: true'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- task: PowerPlatformUploadPaportal@2'
  prefs: []
  type: TYPE_NORMAL
- en: 'inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'authenticationType: ''PowerPlatformSPN'''
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'PowerPlatformSPN: ''PP-DevUS-SPN'''
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'UploadPath: ''Portal/$(WebsiteName)'''
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'DeploymentProfile: ''$(profileTag)'''
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
