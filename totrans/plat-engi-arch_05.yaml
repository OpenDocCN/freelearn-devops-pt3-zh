- en: <st c="0">5</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2">Integration, Delivery, and Deployment – Automation is Ubiquitous</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[*<st c="66">Chapter 2</st>*](B31164_02.xhtml#_idTextAnchor055) <st c="76">included
    a reference architecture of a platform highlighting layers such as</st> *<st c="153">Developer
    Experience</st>*<st c="173">,</st> *<st c="175">Automation and Orchestration</st>*<st
    c="203">, and</st> *<st c="209">Observability Plane</st>*<st c="228">.</st> [*<st
    c="230">Chapter 3</st>*](B31164_03.xhtml#_idTextAnchor133) <st c="239">ended with
    a different perspective on this reference architecture using a top-down approach
    from</st> *<st c="337">Purpose</st>*<st c="344">,</st> *<st c="346">User Interface</st>*<st
    c="360">,</st> *<st c="362">Core Platform Components</st>*<st c="386">,</st> *<st
    c="388">Platform as a Product</st>*<st c="409">, and</st> *<st c="415">Success
    KPIs</st>*<st c="427">.</st>'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: <st c="428">Most platforms are built with the purpose of making it easier for
    development teams to ship software without having to deal with all the complexity
    around building, deploying, testing, validating, securing, operating, releasing,
    or scaling software.</st> <st c="679">In this chapter, we will dive into those
    layers and components of our platform so we understand how we can centralize and
    automate the expertise it takes to ship software and provide it as</st> <st c="868">a
    self-service.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: <st c="883">By the end of this chapter, we will have learned how to define an
    end-to-end release process for software artifacts, align the</st> **<st c="1011">continuous
    integration / continuous deployment</st>** <st c="1057">(</st>**<st c="1059">CI/CD</st>**<st
    c="1064">) process with the artifact life cycle phases, automate the phases using
    tools for CI, CD, and continuous release, integrate those tools into your existing
    process, observe the automation, and scale through</st> <st c="1272">an IDP.</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1279">As such, we will cover the following main topics in</st> <st c="1332">the
    chapter:</st>
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1344">An introduction to</st> <st c="1364">Continuous X</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '<st c="1376">GitOps: Moving from pushing to pulling the</st> <st c="1420">desired
    state</st>'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1433">Understanding the importance of container and artifact registries
    as</st> <st c="1503">entry points</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1515">Defining the release process</st> <st c="1545">and management</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1559">Achieving sustainable CI/CD for DevOps – application life</st>
    <st c="1618">cycle orchestration</st>
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="1637">Internal Developer Platforms</st>** <st c="1666">(</st>**<st
    c="1668">IDPs</st>**<st c="1672">) – the automation Kraken in</st> <st c="1702">the
    platform</st>'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1714">An introduction to Continuous X</st>
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1746">If this is the first time you are hearing</st> <st c="1789">about</st>
    **<st c="1795">Continuous Integration</st>** <st c="1817">(</st>**<st c="1819">CI</st>**<st
    c="1821">) or</st> **<st c="1827">Continuous Delivery</st>** <st c="1846">(</st>**<st
    c="1848">CD</st>**<st c="1850">), then we suggest checking out some of the great
    literature that</st> <st c="1916">exists on these basic concepts.</st> *<st c="1949">Jez
    Humble</st>* <st c="1959">is the maintainer of</st> [<st c="1981">https://continuousdelivery.com/</st>](https://continuousdelivery.com/)
    <st c="2012">and has co-authored the original</st> *<st c="2046">Continuous Delivery</st>*
    <st c="2065">book with</st> *<st c="2076">Dave Farley</st>*<st c="2087">. If you
    need a crash course on this topic, then please have a look at their material.</st>
    <st c="2174">There are also several recorded talks that give a great overview,
    such as the one titled</st> *<st c="2263">Continuous Delivery Sounds Great But
    It Won’t Work</st>* *<st c="2314">Here</st>*<st c="2318">:</st> [<st c="2321">https://vimeo.com/193849732</st>](https://vimeo.com/193849732)<st
    c="2348">.</st>
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1746">如果这是你第一次听说</st> <st c="1789">关于</st> **<st c="1795">持续集成</st>**
    <st c="1817">(</st>**<st c="1819">CI</st>**<st c="1821">) 或</st> **<st c="1827">持续交付</st>**
    <st c="1846">(</st>**<st c="1848">CD</st>**<st c="1850">)，那么我们建议你查看一些关于这些基本概念的优秀文献。</st>
    *<st c="1949">Jez Humble</st>* <st c="1959">是</st> [<st c="1981">https://continuousdelivery.com/</st>](https://continuousdelivery.com/)
    <st c="2012">的维护者，并且是</st> *<st c="2046">《持续交付》</st>* <st c="2065">一书的共同作者，</st>
    *<st c="2076">Dave Farley</st>*<st c="2087">。如果你需要这个主题的速成课程，请查看他们的资料。</st> <st
    c="2174">也有一些录制的讲座，提供了很好的概述，比如题为</st> *<st c="2263">持续交付听起来很棒，但它行不通</st>* *<st
    c="2314">这里</st>*<st c="2318">：</st> [<st c="2321">https://vimeo.com/193849732</st>](https://vimeo.com/193849732)<st
    c="2348">。</st>
- en: <st c="2349">So that we all have the same common understanding, let us quickly
    recap what the building blocks are and why this is important in</st> <st c="2480">software
    delivery</st><st c="2497">.</st>
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2349">为了确保我们有相同的理解，让我们快速回顾一下构建模块是什么以及为什么它在</st> <st c="2480">软件交付</st><st
    c="2497">中很重要。</st>
- en: <st c="2498">High-level definition of Continuous X</st>
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="2498">持续 X 的高层次定义</st>
- en: '<st c="2536">The</st> <st c="2540">basic foundation of automating software
    delivery is to have proper</st> *<st c="2608">configuration management</st>* <st
    c="2632">of all assets required to build, deploy, validate, operate, and scale
    our systems: code, tests, deployment and infrastructure definitions, dependencies,
    observability, ownership, and more.</st> <st c="2822">Putting all those assets
    into version control allows us to generate repeatable and reliable output, gives
    us auditability, allows us to revert breaking changes, and gives us disaster</st>
    <st c="3005">recovery capabilities.</st>'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2536">自动化软件交付的</st> <st c="2540">基本基础是正确的</st> *<st c="2608">配置管理</st>*
    <st c="2632">，包括构建、部署、验证、操作和扩展我们系统所需的所有资产：代码、测试、部署和基础设施定义、依赖关系、可观测性、所有权等。</st>
    <st c="2822">将所有这些资产放入版本控制中，可以生成可重复且可靠的输出，提供审计能力，允许我们回滚破坏性更改，并提供灾难</st> <st c="3005">恢复能力。</st>
- en: <st c="3027">Git, or any</st> <st c="3039">type of Git flavor, is most likely
    what can be found today in software organizations for version control.</st> <st
    c="3146">Depending on the Git solution you use, you will see additional built-in
    capabilities such as cross-team collaboration (issue tracking, resolving merge
    conflicts, etc.), automation (commit checks, delivery pipelines, etc.), or reporting
    (efficiency or</st> <st c="3397">DORA metrics).</st>
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3027">Git，或任何</st> <st c="3039">类型的 Git 版本，今天最有可能在软件组织中用于版本控制。</st> <st
    c="3146">根据你使用的 Git 解决方案，你将看到额外的内建功能，如跨团队协作（问题跟踪、解决合并冲突等）、自动化（提交检查、交付流水线等）或报告（效率或</st>
    <st c="3397">DORA 指标）。</st>
- en: <st c="3411">Now that we have established the foundation, let’s dive into</st>
    <st c="3473">Continuous</st> <st c="3483">X.</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3411">现在我们已经建立了基础，让我们深入探讨</st> <st c="3473">持续</st> <st c="3483">X。</st>
- en: <st c="3486">CI</st>
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="3486">CI</st>
- en: '**<st c="3489">CI</st>** <st c="3492">is the</st> <st c="3499">practice that
    emphasizes frequent and automated integration of code changes into a shared repository.</st>
    <st c="3602">When multiple developers work on the same code base, it’s important
    to bring those changes together frequently to validate that the code integrates
    well and produces an artifact (a container image, a binary) that can be deployed
    into an environment.</st> <st c="3852">Key aspects of CI include</st> <st c="3878">the
    following:</st>'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="3489">持续集成</st>** <st c="3492">是</st> <st c="3499">一种强调频繁和自动化地将代码变更集成到共享代码库中的实践。</st>
    <st c="3602">当多个开发人员在同一个代码库上工作时，定期将这些变更合并非常重要，以验证代码是否能良好集成，并生成可以部署到环境中的工件（如容器镜像或二进制文件）。</st>
    <st c="3852">持续集成的关键方面包括</st> <st c="3878">以下内容：</st>'
- en: '**<st c="3892">Automated builds</st>**<st c="3909">: Code</st> <st c="3916">commits
    in version</st> <st c="3935">control trigger an automated build process that compiles,
    runs tests, and</st> <st c="4010">generates artifacts</st>'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="3892">自动化构建</st>**<st c="3909">：代码</st> <st c="3916">提交到版本控制系统时，会触发一个自动化构建过程，该过程会编译代码、运行测试，并且</st>
    <st c="4010">生成工件</st>'
- en: '**<st c="4029">Test automation</st>**<st c="4045">: Unit tests, integration
    tests, and other checks are executed during the build</st> <st c="4126">process</st>
    <st c="4134">marking the build broken if any tests</st> <st c="4172">should fail</st>'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="4029">测试自动化</st>**<st c="4045">：单元测试、集成测试以及其他检查会在构建</st> <st c="4126">过程中执行</st>
    <st c="4134">如果有任何测试失败，构建会被标记为失败</st> <st c="4172">。</st>'
- en: '**<st c="4183">Feedback loop</st>**<st c="4197">: This provides</st> <st c="4214">rapid
    feedback to</st> <st c="4232">developers to quickly fix issues, leading to overall
    higher code quality</st> <st c="4305">and</st> <st c="4308">stability</st>'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="4183">反馈回路</st>**<st c="4197">：这为</st> <st c="4214">开发人员提供了快速反馈，以便快速修复问题，从而提高整体代码质量</st>
    <st c="4232">和</st> <st c="4305">稳定性</st>'
- en: <st c="4318">Continuous testing and validation of observability</st>
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="4318">持续测试和可观察性的验证</st>
- en: <st c="4369">While CI already highlights the</st> <st c="4401">importance of
    automated unit and integration tests, we want to stress the fact that more automated
    testing and validation early in the life cycle will result in better quality and
    stability.</st> <st c="4593">Assuming the built software provides REST APIs or
    a UI, basic validation against those interfaces should be done to validate the
    accurate functionality (e.g, do APIs return proper responses, are the correct
    HTTP status codes used when testing with invalidated parameters, are there any
    timeouts in API calls, or are any HTTP</st> <st c="4918">errors returned?).</st>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4369">尽管持续集成已经强调了</st> <st c="4401">自动化单元测试和集成测试的重要性，但我们要强调的是，在生命周期早期进行更多自动化测试和验证，将带来更好的质量和稳定性。</st>
    <st c="4593">假设构建的软件提供了REST API或UI接口，应该针对这些接口进行基本验证，以确保功能的准确性（例如，API是否返回正确的响应，使用无效参数时是否返回正确的HTTP状态码，API调用是否有超时，或是否返回任何HTTP</st>
    <st c="4918">错误？）</st>
- en: '**<st c="4936">Observability</st>** <st c="4950">is essential</st> <st c="4964">to
    validate if systems are healthy and provides the data to troubleshoot problems
    faster.</st> <st c="5054">As part of the continuous validation</st> <st c="5090">process,
    we must validate that the tested build is producing valid and expected observability
    data.</st> <st c="5191">We should validate that all expected metrics, logs, or
    traces are produced and that there is no obvious anomaly or outlier present after
    running those basic unit, integration, or</st> <st c="5370">API tests.</st>'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="4936">可观察性</st>** <st c="4950">对验证系统健康至关重要</st> <st c="4964">，并提供了更快排查问题所需的数据。</st>
    <st c="5054">作为持续验证</st> <st c="5090">过程的一部分，我们必须验证已测试的构建是否生成有效且预期的可观察性数据。</st>
    <st c="5191">我们应该验证是否生成了所有预期的指标、日志或跟踪数据，并且在运行这些基本的单元测试、集成测试或</st> <st c="5370">API测试后，是否没有明显的异常或离群值。</st>'
- en: <st c="5380">We have been stressing that</st> <st c="5409">observability has
    to be a non-functional requirement of modern software.</st> <st c="5482">This
    is why the CI should already validate if the expected data is produced.</st> <st
    c="5559">If not, then this is just like a failing unit or integration test and
    you should mark the build</st> <st c="5655">as broken!</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5380">我们一直在强调，</st> <st c="5409">可观察性必须是现代软件的非功能性要求。</st> <st c="5482">这就是为什么持续集成应该验证是否生成了预期的数据。</st>
    <st c="5559">如果没有，那么这就像是一个失败的单元或集成测试，你应该将构建</st> <st c="5655">标记为失败！</st>
- en: <st c="5665">For Financial One ACME and its critical financial services, we
    should validate</st> <st c="5745">the following:</st>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5665">对于 Financial One ACME 及其关键财务服务，我们应验证</st> <st c="5745">以下内容：</st>
- en: <st c="5759">Will the API properly validate the access control of the caller
    (e.g., not be able to query financial data from</st> <st c="5872">other users)?</st>
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="5759">API 是否能正确验证调用者的访问控制（例如，不能查询</st> <st c="5872">其他用户的财务数据）？</st>
- en: <st c="5885">Will the API not log any confidential data, such as credit card
    numbers, usernames,</st> <st c="5970">or tokens?</st>
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="5885">API 是否不会记录任何机密数据，如信用卡号、用户名</st> <st c="5970">或令牌？</st>
- en: <st c="5980">Will the API properly generate metrics for failed attempts so this
    can be used in production to alert on potential</st> <st c="6095">hack attacks?</st>
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="5980">API 是否能正确生成失败尝试的指标，以便在生产中用于警报潜在的</st> <st c="6095">黑客攻击？</st>
- en: <st c="6109">Continuous delivery</st>
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="6109">持续交付</st>
- en: <st c="6129">As defined on the continuous delivery site (</st>[<st c="6174">https://continuousdelivery.com/</st>](https://continuousdelivery.com/)<st
    c="6206">), “</st>*<st c="6211">Continuous Delivery is the ability to get changes
    of all types—including new features, configuration changes, bug fixes and experiments—into
    production, or into the hands of users, safely and quickly in a sustainable way</st>*<st
    c="6432">.” The goal is to take the fear of failure out of</st> <st c="6482">deployments.</st>
    <st c="6495">Instead of infrequent big bang releases, deployments should become
    routine as they continuously happen.</st> <st c="6599">Additionally, applying
    new deployment patterns such as blue/green, canary, or feature flagging allows
    us to reduce the risk even further.</st> <st c="6737">These will be discussed
    further in the section about deployments</st> <st c="6802">versus releases!</st>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6129">在持续交付网站上定义（</st>[<st c="6174">https://continuousdelivery.com/</st>](https://continuousdelivery.com/)<st
    c="6206">），“</st>*<st c="6211">持续交付是将所有类型的变更——包括新特性、配置更改、错误修复和实验——以安全、快速且可持续的方式投入生产，或交到用户手中的能力。</st>*<st
    c="6432">”目标是消除</st> <st c="6482">部署中的失败恐惧。</st> <st c="6495">与其进行不频繁的大规模发布，部署应该成为常规操作，持续发生。</st>
    <st c="6599">此外，采用新的部署模式，如蓝绿部署、金丝雀部署或特性标记，可以进一步降低风险。</st> <st c="6737">这些将在关于部署</st>
    <st c="6802">与发布的章节中进一步讨论！</st>
- en: <st c="6818">Some aspects of continuous delivery are</st> <st c="6859">as follows:</st>
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6818">持续交付的一些方面如下：</st>
- en: '**<st c="6870">Automated deployments</st>**<st c="6892">: New</st> <st c="6899">artifacts
    that come</st> <st c="6918">out of CI are bundled with other changes and get automatically
    deployed.</st> <st c="6992">Deployment definitions are declarative and version-controlled
    and therefore allow a more predictable, repeatable, and low-risk way of updating
    in</st> <st c="7138">any environment.</st>'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="6870">自动化部署</st>**<st c="6892">：来自 CI 的新</st> <st c="6899">工件与其他更改捆绑，并自动部署。</st>
    <st c="6918">部署定义是声明式的并且受版本控制，因此允许在任何环境中以更可预测、可重复和低风险的方式进行更新。</st> <st c="7138">环境。</st>'
- en: '**<st c="7154">Deployment pipelines</st>**<st c="7175">: Pipelines</st> <st
    c="7188">allow higher-level testing and deployment validation as compared to CI.</st>
    <st c="7260">Here</st> <st c="7264">is where performance, security, scalability,
    resiliency, and user experience tests get executed.</st> <st c="7362">This validates
    not just a single artifact but the full deployment</st> <st c="7428">change set!</st>'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="7154">部署流水线</st>**<st c="7175">：与 CI 相比，流水线允许更高级别的测试和部署验证。</st> <st
    c="7260">在此，执行性能、安全性、可扩展性、韧性和用户体验等测试。</st> <st c="7362">这不仅验证单一工件，而是整个部署</st>
    <st c="7428">变更集！</st>'
- en: '**<st c="7439">Quality gates and promotion</st>**<st c="7467">: At the end
    of a deployment pipeline, all test results act as a quality gate</st> <st c="7545">before
    promoting</st> <st c="7562">that change into the next environment: from development</st>
    <st c="7618">to</st> **<st c="7622">Quality Assurance</st>** <st c="7639">(</st>**<st
    c="7641">QA</st>**<st c="7643">,) from QA to staging, from staging</st> <st c="7679">to
    production.</st>'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="7439">质量门控与晋升</st>**<st c="7467">：在部署流水线的末尾，所有测试结果充当质量门控</st> <st
    c="7545">，然后将变更晋升到下一个环境：从开发</st> <st c="7618">到</st> **<st c="7622">质量保证</st>**
    <st c="7639">（</st>**<st c="7641">QA</st>**<st c="7643">），从 QA 到暂存，从暂存</st> <st
    c="7679">到生产。</st>'
- en: '**<st c="7693">Rolling back versus rolling forward</st>**<st c="7729">: If
    the quality gate fails in production, a rollback</st> <st c="7783">can be triggered
    by reverting back to the previous version-controlled deployment</st> <st c="7864">configuration.</st>
    <st c="7880">Another strategy is rolling forward, which means that problems</st>
    <st c="7942">are fixed, and thanks to automated deployments, the fix can be deployed
    quickly to avoid</st> <st c="8031">the need for</st> <st c="8045">a rollback.</st>'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="7693">回滚与向前滚动</st>**<st c="7729">：如果生产环境中的质量门槛未通过，可以通过回滚至先前版本控制的部署配置来触发回滚。</st>
    <st c="7783">另一种策略是向前滚动，意味着问题被修复，</st> <st c="7864">并且由于自动化部署，修复可以迅速部署，以避免</st>
    <st c="8031">需要回滚。</st>'
- en: <st c="8056">Continuous deployments – decoupling deployments from releases</st>
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="8056">持续部署 – 将部署与发布解耦</st>
- en: <st c="8118">CD deploys changes in an automated and fast way.</st> <st c="8168">However,
    there is still a risk that a change results in a failure, requiring either rolling
    backward or rolling forward, as</st> <st c="8292">explained earlier.</st>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8118">CD 以自动化和快速的方式部署更改。</st> <st c="8168">然而，仍然存在更改导致失败的风险，需要回滚或向前滚动，正如</st>
    <st c="8292">前面所解释的那样。</st>
- en: <st c="8310">Continuous deployments</st> <st c="8334">go a step further and
    embrace new deployment patterns that favor the separation of the deployment of
    a change and releasing the new feature set to the end users.</st> <st c="8496">The
    current well-established patterns are</st> <st c="8538">as follows:</st>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="8310">持续部署</st> <st c="8334">更进一步，采用了新的部署模式，倾向于将更改的部署与向最终用户发布新功能集分离。</st>
    <st c="8496">目前已经成熟的模式如下：</st> '
- en: '**<st c="8549">Blue/green deployments</st>**<st c="8572">: The new</st> <st
    c="8583">deployment (commonly labeled</st> *<st c="8612">blue</st>*<st c="8616">)
    will be done</st> <st c="8632">in parallel to the existing deployment (commonly
    labeled</st> *<st c="8689">green</st>*<st c="8694">).</st> <st c="8698">Through
    a load balancer, traffic can be switched to blue.</st> <st c="8756">If there is
    a problem with blue, traffic can be switched back to the still-running instance,
    therefore eliminating the need for a rollback while minimizing the impact on the</st>
    <st c="8929">end user.</st> <st c="8940">If all goes well, green becomes blue
    until the next deployment</st> <st c="9003">comes along.</st>'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="8549">蓝绿部署</st>**<st c="8572">：新的</st> <st c="8583">部署（通常标记为</st>
    *<st c="8612">蓝色</st>*<st c="8616">）将与现有部署（通常标记为</st> *<st c="8689">绿色</st>*<st
    c="8694">）并行进行。</st> <st c="8698">通过负载均衡器，可以将流量切换到蓝色。</st> <st c="8756">如果蓝色出现问题，流量可以切换回仍在运行的实例，从而避免了回滚，并最小化了对</st>
    <st c="8929">最终用户的影响。</st> <st c="8940">如果一切顺利，绿色将变为蓝色，直到下次部署</st> <st c="9003">来临。</st>'
- en: '**<st c="9015">Canary deployments</st>**<st c="9034">: Similar to blue/green
    deployments but on a more granular level.</st> <st c="9101">It’s the practice</st>
    <st c="9119">of a staged deployment of the new version besides the old version.</st>
    <st c="9186">First, it is deployed to a small subset of users or a</st> <st c="9240">percentage
    of the traffic.</st> <st c="9267">If everything is good, the staged rollout continues
    until all user traffic has the new version.</st> <st c="9363">If a problem occurs
    during the stages, the old version will receive</st> <st c="9431">the traffic.</st>'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="9015">金丝雀部署</st>**<st c="9034">：类似于蓝绿部署，但在更精细的层次上。</st> <st c="9101">这是新版本与旧版本并行部署的做法。</st>
    <st c="9119">首先，它会部署到一小部分用户或一部分流量。</st> <st c="9186">如果一切正常，分阶段的推出将继续，直到所有用户流量都使用新版本。</st>
    <st c="9267">如果在阶段过程中出现问题，流量将切换回旧版本。</st>'
- en: '**<st c="9443">Feature flagging</st>**<st c="9460">: Instead of load-balanced
    side-by-side deployments of the old and new versions, feature flagging</st> <st
    c="9558">allows developers to “hide” new code</st> <st c="9595">behind a switch/toggle.</st>
    <st c="9620">During a deployment, the new version gets deployed over the old one
    without executing the new hidden code.</st> <st c="9727">Through fine-grained
    configuration, features can be turned on for individual users, user types, geographical
    regions, or any other attribute of a consumer of a service.</st> <st c="9896">If
    a feature has a problem, it only takes a runtime configuration change and that
    code becomes</st> <st c="9991">inactive again.</st>'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="9443">特性标志</st>**<st c="9460">：与旧版本和新版本的负载均衡并排部署不同，特性标志</st> <st c="9558">允许开发者“隐藏”新代码</st>
    <st c="9595">在开关/切换后面。</st> <st c="9620">在部署期间，新版本会覆盖旧版本，但不会执行隐藏的新代码。</st> <st
    c="9727">通过细粒度的配置，可以为单个用户、用户类型、地理区域或任何其他服务消费者属性启用特性。</st> <st c="9896">如果某个特性有问题，只需进行一次运行时配置更改，代码就会</st>
    <st c="9991">重新变为非活动状态。</st>'
- en: <st c="10006">Decoupling deployments from releases allows teams to better control
    the rollout of new features of their software and with that, minimize risk.</st>
    <st c="10151">There is more to explain about implementation details as well as
    challenges but that’s beyond the scope of this book.</st> <st c="10269">If you
    are interested in learning more, look into</st> *<st c="10319">OpenFeature</st>*
    *<st c="10330">[1]</st>*<st c="10334">, a</st> **<st c="10338">Cloud Native Computing
    Foundation</st>** <st c="10371">(</st>**<st c="10373">CNCF</st>**<st c="10377">)
    incubating project.</st> <st c="10400">OpenFeature provides a standard, feature-flag</st>
    <st c="10446">management, vendor-agnostic way for developers to implement feature
    flags.</st> <st c="10521">The community around it also has a lot of best practices
    around progressive delivery, which includes all</st> <st c="10625">the patterns</st>
    <st c="10639">discussed previously.</st>
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10006">将部署与发布解耦，使团队能够更好地控制新功能的推出，从而最小化风险。</st> <st c="10151">还有更多关于实现细节以及挑战的内容，但超出了本书的范围。</st>
    <st c="10269">如果你有兴趣了解更多，可以查看</st> *<st c="10319">OpenFeature</st>* *<st c="10330">[1]</st>*<st
    c="10334">，一个</st> **<st c="10338">云原生计算基金会</st>** <st c="10371">（</st>**<st c="10373">CNCF</st>**<st
    c="10377">）孵化的项目。</st> <st c="10400">OpenFeature 提供了一种标准的、特性标志管理、供应商无关的方式供开发者实现特性标志。</st>
    <st c="10446">围绕它的社区也有很多关于渐进式交付的最佳实践，其中包括前面讨论的所有</st> <st c="10625">模式</st> <st
    c="10639">。</st>
- en: <st c="10660">Continuous X for infrastructure</st>
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="10660">基础设施的持续X</st>
- en: <st c="10692">Continuous X</st> <st c="10705">is not only relevant for application
    code or configuration.</st> <st c="10766">The same concepts should be applied
    to any infrastructure definition.</st> <st c="10836">As a platform, we will need
    certain infrastructure components.</st> <st c="10899">Whether that’s virtual machines,
    Kubernetes nodes, load</st> <st c="10955">balancers,</st> **<st c="10966">Domain
    Name System</st>** <st c="10984">(</st>**<st c="10986">DNS</st>**<st c="10989">),
    file storage, databases, virtual networks, serverless, or any other component
    that allows us to run our core platform as well as the applications that will
    be deployed, operated, and managed through our</st> <st c="11196">platform self-services.</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10692">持续X</st> <st c="10705">不仅仅与应用程序代码或配置相关。</st> <st c="10766">相同的概念应适用于任何基础设施定义。</st>
    <st c="10836">作为平台，我们将需要某些基础设施组件。</st> <st c="10899">无论是虚拟机、Kubernetes节点、负载均衡器、**<st
    c="10966">域名系统</st>** <st c="10984">（</st>**<st c="10986">DNS</st>**<st c="10989">）、文件存储、数据库、虚拟网络、无服务器计算，还是其他任何允许我们运行核心平台以及将通过我们的</st>
    <st c="11196">平台自服务部署、操作和管理的应用程序的组件。</st>
- en: <st c="11219">Just like with application code, we want to configure our infrastructure
    requirements as code, version control them, and apply the same CI and continuous
    testing, validation,</st> <st c="11395">and delivery.</st>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11219">就像应用程序代码一样，我们希望将基础设施需求配置为代码，进行版本控制，并应用相同的 CI 和持续测试、验证、</st> <st
    c="11395">和交付。</st>
- en: '**<st c="11408">GitOps</st>** <st c="11415">is also</st> <st c="11423">a term
    that emerged over the past years and it focuses on automating the process of provisioning
    infrastructure from a desired state defined declaratively and version-controlled
    in Git.</st> <st c="11610">We will cover GitOps in more detail in a later section
    of this chapter.</st> <st c="11682">First, let’s</st> <st c="11695">discuss the
    basics by star</st><st c="11721">ting with</st> **<st c="11732">infrastructure
    as</st>** **<st c="11750">code</st>** <st c="11754">(</st>**<st c="11756">IaC</st>**<st
    c="11759">).</st>'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="11408">GitOps</st>** <st c="11415">也是近几年出现的一个术语，它专注于自动化根据声明性定义的期望状态，通过Git进行版本控制来配置基础设施的过程。</st>
    <st c="11610">我们将在本章的后续部分更详细地介绍GitOps。</st> <st c="11682">首先，</st> <st c="11695">让我们从</st>
    **<st c="11732">基础设施即代码</st>** **<st c="11750">（IaC）</st>**<st c="11754">开始，讨论一些基础知识。</st>'
- en: <st c="11762">IaC</st>
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="11762">IaC</st>
- en: '<st c="11766">There are</st> <st c="11777">many different tools that enable</st>
    **<st c="11810">IaC</st>** <st c="11813">and most likely, you already have one
    or several</st> <st c="11863">in your organization: Terraform, Ansible, Puppet,
    Chef, CloudFormation, and</st> **<st c="11939">AWS</st>** **<st c="11942">Cloud
    Development Kit</st>** <st c="11964">(</st>**<st c="11966">CDK</st>**<st c="11969">)
    just to name</st> <st c="11985">a few.</st>'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11766">有许多不同的工具可以实现</st> **<st c="11810">IaC</st>** <st c="11813">，而且你很可能已经在你的组织中使用了一个或多个工具：Terraform、Ansible、Puppet、Chef、CloudFormation以及</st>
    **<st c="11939">AWS</st>** **<st c="11942">云开发工具包</st>** <st c="11964">(</st>**<st
    c="11966">CDK</st>**<st c="11969">)仅举几个例子。</st>
- en: <st c="11991">Here is a very simple Terraform snippet that would create an EC2
    instance of</st> <st c="12069">type</st> `<st c="12074">c5.large</st>`<st c="12082">:</st>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11991">这是一个非常简单的Terraform代码片段，用于创建一个类型为</st> <st c="12069">c5.large</st>`<st
    c="12074">的EC2实例</st>`<st c="12082">：</st>
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="12226">Here is one more example of creating an AWS S3 bucket</st> <st
    c="12281">using Ansible:</st>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12226">这里有一个使用Ansible创建AWS S3存储桶的例子：</st>
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="12560">IaC</st> <st c="12565">enables us to define the desired state
    of our IaC.</st> <st c="12616">This is code that can be version-controlled, such
    as application code, and once deployed, it results in the desired infrastructure
    being provisioned.</st> <st c="12766">Like with application code, we can use</st>
    <st c="12805">the following:</st>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12560">IaC</st> <st c="12565">使我们能够定义我们期望的IaC状态。</st> <st c="12616">这段代码可以进行版本控制，类似于应用程序代码，一旦部署，就会实现期望的基础设施配置。</st>
    <st c="12766">与应用程序代码类似，我们可以使用</st> <st c="12805">以下内容：</st>
- en: '**<st c="12819">CI</st>**<st c="12822">: Use this to validate that all our
    IaC is valid.</st> <st c="12873">IaC tools typically have features to “dry run”
    and validate that there is no mistake and that all config files have no conflict
    or</st> <st c="13004">dependency issues.</st>'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="12819">CI</st>**<st c="12822">：用来验证我们所有的IaC是否有效。</st> <st c="12873">IaC工具通常具有“干运行”功能，可以验证是否没有错误，所有配置文件是否没有冲突或</st>
    <st c="13004">依赖问题。</st>'
- en: '**<st c="13022">Testing and deployment validation</st>**<st c="13056">: After
    IaC is deployed, we can validate that we really got our desired state (e.g., ensuring
    that the EC2 instance is really up and running, that the S3 buckets are</st> <st
    c="13223">accessible, etc.).</st>'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="13022">测试和部署验证</st>**<st c="13056">：在IaC部署后，我们可以验证我们是否真正达到了期望的状态（例如，确保EC2实例已启动并运行，S3存储桶可以</st>
    <st c="13223">访问，等等）。</st>'
- en: '**<st c="13241">Rollback or revert</st>**<st c="13260">: IaC gives us the option
    to roll back changes or revert to a previous version because everything</st> <st
    c="13359">is version-controlled!</st>'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="13241">回滚或恢复</st>**<st c="13260">：IaC让我们可以回滚更改或恢复到先前的版本，因为一切</st>
    <st c="13359">都被版本控制！</st>'
- en: <st c="13381">For more details on</st> <st c="13401">IaC, including version
    control strategies (where IaC lives), the authors recommend looking i</st><st
    c="13494">nto existing books and blogs on</st> <st c="13527">that topic.</st>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13381">关于</st> <st c="13401">IaC的更多细节，包括版本控制策略（IaC的存储位置），作者建议参考现有的书籍和博客，了解</st>
    <st c="13494">该主题。</st>
- en: <st c="13538">Crossplane – IaC for platform and applications</st>
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="13538">Crossplane – 平台和应用的IaC</st>
- en: <st c="13585">IaC is not limited to the</st> <st c="13612">core platform services
    but is also relevant for the applications that we allow our development teams
    to deploy through our platform self-services.</st> <st c="13759">A new application
    may need file storage, a database, and a public DNS, or need to deploy a third-party
    solution; it depends on its own virtual machine, which is accessible from the
    deployed app that may reside</st> <st c="13969">on K8s.</st>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13585">基础设施即代码（IaC）不仅仅局限于核心平台服务，它还适用于我们允许开发团队通过平台自服务部署的应用程序。</st> <st
    c="13612">一个新的应用程序可能需要文件存储、数据库和公共DNS，或需要部署第三方解决方案；这取决于其虚拟机，而该虚拟机可以从部署的应用程序访问，这些应用程序可能会驻留在</st>
    <st c="13969">K8s上。</st>
- en: <st c="13976">You can provide templates for Terraform, Ansible, and CDK, which
    your developers can add to their own code repositories, and which are then applied
    as part of the Continuous X of</st> <st c="14156">their application.</st>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13976">你可以为Terraform、Ansible和CDK提供模板，开发人员可以将其添加到自己的代码库中，然后作为其应用程序持续X的一部分进行应用。</st>
- en: <st c="14174">One tool that has emerged in the cloud native space to cover both
    application and infrastructure orchestration is the</st> **<st c="14293">CNCF
    project Crossplane</st>** *<st c="14316">[2]</st>*<st c="14320">. Besides coming
    with a lot of different</st> <st c="14361">providers for all major cloud vendors
    or even Terraform, it comes with Compositions.</st> **<st c="14446">Compositions</st>**
    <st c="14458">are a template for creating multiple managed resources as a single
    object.</st> <st c="14534">This allows the platform team to define such templates
    for common application architectures and then have the application team simply
    use that template to instantiate the correct infrastructure and deploy</st> <st
    c="14739">the application.</st>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14174">在云原生领域中，出现了一种工具来覆盖应用程序和基础设施编排，它就是</st> **<st c="14293">CNCF项目Crossplane</st>**
    *<st c="14316">[2]</st>*<st c="14320">。除了提供许多不同的云供应商或甚至Terraform的提供程序外，它还提供了Compositions。</st>
    **<st c="14446">Compositions</st>** <st c="14458">是一个用于创建多个托管资源作为单一对象的模板。</st>
    <st c="14534">这使得平台团队能够为常见的应用程序架构定义这样的模板，然后让应用程序团队仅使用该模板来实例化正确的基础设施并部署</st> <st
    c="14739">应用程序。</st>
- en: <st c="14755">One of our self-service use cases discussed in</st> [*<st c="14803">Chapter
    2</st>*](B31164_02.xhtml#_idTextAnchor055) <st c="14812">was the automated provisioning
    of a performance test environment.</st> <st c="14879">We could define a composition
    that would be as easy to use by the development teams as the one shown in</st>
    <st c="14983">this example:</st>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14755">我们在</st> [*<st c="14803">第2章</st>*](B31164_02.xhtml#_idTextAnchor055)
    <st c="14812">中讨论了一个自服务使用案例——自动化性能测试环境的配置。</st> <st c="14879">我们可以定义一个组成模板，使开发团队能够像使用下面示例中的模板一样轻松使用它：</st>
    <st c="14983">这个例子：</st>
- en: '[PRE2]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="15330">The Composition</st> <st c="15347">definition of</st> `<st c="15361">PerformanceTestCluster</st>`
    <st c="15383">would have been created by the platform engineering team in combination
    with those experts who know how to install the load testing and observability
    tools.</st> <st c="15541">In the preceding example, a new medium-sized K8s cluster
    would be provisioned, the requested app would be installed using the referenced
    Helm chart, observability data would be captured (e.g., Prometheus and log scraping
    configured) and the load testing tool would be deployed to be able to run spike
    load scenarios.</st> <st c="15858">Once everything is ready, a Slack notification
    with the environment details will be sent to the team.</st> <st c="15960">Last
    but not least, the environment would also be shut down after 12 hours as specified
    in the mandatory</st> `<st c="16065">leaseTime</st>` <st c="16074">field.</st>
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15330">这个Composition</st> <st c="15347">的定义是</st> `<st c="15361">PerformanceTestCluster</st>`
    <st c="15383">由平台工程团队与那些知道如何安装负载测试和可观察性工具的专家共同创建。</st> <st c="15541">在前面的例子中，一个新的中型K8s集群将被配置，所请求的应用程序将使用引用的Helm
    chart进行安装，捕获可观察性数据（例如，配置Prometheus和日志抓取），并且将部署负载测试工具，以便能够运行尖峰负载场景。</st> <st c="15858">一旦一切准备就绪，带有环境详情的Slack通知将发送给团队。</st>
    <st c="15960">最后但同样重要的是，该环境将在12小时后根据强制性</st> `<st c="16065">leaseTime</st>` <st
    c="16074">字段的规定自动关闭。</st>
- en: <st c="16081">The preceding example already shows the power of IaC when i</st><st
    c="16141">ntegrating this into our Continuous</st> <st c="16178">X efforts!</st>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16081">前面的例子已经展示了将IaC集成到我们的持续</st> <st c="16141">X工作中时的强大功能！</st>
- en: <st c="16188">Continuous X as a system-critical component in our platform</st>
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="16188">Continuous X 作为我们平台中的系统关键组件</st>
- en: '<st c="16248">There are many different tools we can</st> <st c="16287">choose
    from to implement Continuous X: Jenkins, GitLab, Tekton, Argo CD, Flux, Keptn,
    Crossplane, Selenium, and</st> `<st c="16399">k6</st>`<st c="16401">, to just
    name a few.</st> <st c="16423">Whatever tools we choose, those tools need to be
    available, resilient, and secure all of the time, as they are the backbone of
    our platform.</st> <st c="16564">Those tools are as business-critical as any software
    that powers the business we are in.</st> <st c="16653">Think about Financial One
    ACME.</st> <st c="16685">If the developers need to push out a fix to a critical
    production issue on their financial software, they need Continuous X to</st> <st
    c="16812">work perfectly.</st>'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16248">我们可以从许多不同的工具中选择来实施 Continuous X：Jenkins、GitLab、Tekton、Argo CD、Flux、Keptn、Crossplane、Selenium
    和</st> `<st c="16399">k6</st>`<st c="16401">，仅举几例。</st> <st c="16423">无论我们选择哪种工具，这些工具需要始终可用、具备弹性并且安全，因为它们是我们平台的支柱。</st>
    <st c="16564">这些工具与任何支撑我们业务的软件同样重要。</st> <st c="16653">想想 Financial One ACME。</st>
    <st c="16685">如果开发人员需要发布一个修复，解决其金融软件中的关键生产问题，他们需要 Continuous X</st> <st c="16812">能够完美运行。</st>
- en: <st c="16827">To ensure that those components are available when they are needed,
    we need to apply the same best practices as we put on our</st> <st c="16954">business-critical
    apps:</st>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16827">为了确保在需要时这些组件能够可用，我们需要应用与我们业务关键应用相同的最佳实践：</st>
- en: '**<st c="16977">Secure by default</st>**<st c="16995">: If attackers find their
    way into our Continuous X toolkit, they have open doors to enter any system that
    is managed by our platform.</st> <st c="17131">Because of this criticality,</st>
    [*<st c="17160">Chapter 7</st>*](B31164_07.xhtml#_idTextAnchor381) <st c="17169">is
    fully dedicated to building secure and</st> <st c="17212">compliant products.</st>'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="16977">默认安全</st>**<st c="16995">：如果攻击者能够进入我们的 Continuous X 工具包，他们将打开进入我们平台管理的任何系统的大门。</st>
    <st c="17131">由于这一关键性，</st> [*<st c="17160">第7章</st>*](B31164_07.xhtml#_idTextAnchor381)
    <st c="17169">完全致力于构建安全和</st> <st c="17212">合规的产品。</st>'
- en: '**<st c="17231">Test every change we make</st>**<st c="17257">: Let’s assume
    we use GitLab as one of our tools for Git and CI.</st> <st c="17323">We must version
    control the deployment configuration of GitLab and run it through the same Continuous
    X process to validate every new version or configuration change.</st> <st c="17490">If
    necessary, we will roll back or roll forward in case an update is</st> <st c="17559">causing
    issues!</st>'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="17231">测试我们所做的每一个更改</st>**<st c="17257">：假设我们使用 GitLab 作为我们的 Git 和
    CI 工具之一。</st> <st c="17323">我们必须对 GitLab 的部署配置进行版本控制，并通过相同的 Continuous X 流程运行，以验证每个新版本或配置更改。</st>
    <st c="17490">如果必要，我们将回滚或前进，以防更新</st> <st c="17559">引发问题！</st>'
- en: '**<st c="17574">Deploy highly available</st>**<st c="17598">: Follow the deployment
    guidelines for those tools for high availability.</st> <st c="17673">If we have
    globally distributed teams, we want to make sure to deploy certain components
    as close as possible to our end users.</st> <st c="17801">Also, look into zero-downtime
    upgrade options and</st> <st c="17851">follow them.</st>'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="17574">部署高可用性</st>**<st c="17598">：遵循这些工具的部署指南，以确保高可用性。</st> <st c="17673">如果我们有全球分布的团队，我们需要确保将某些组件尽可能部署到离终端用户最近的地方。</st>
    <st c="17801">另外，考虑零停机时间的升级选项并</st> <st c="17851">遵循这些选项。</st>'
- en: '**<st c="17863">Observe each component</st>**<st c="17886">: Every tool provides
    some type of telemetry data that indicates health.</st> <st c="17960">Argo CD,
    for instance, exposes Prometheus metrics for work queue length, Git requests,
    and sync activity.</st> <st c="18066">Those give an indication of whether Argo
    CD is still able to do its job.</st> <st c="18139">A constantly increasing work
    queue depth is a sign that Argo CD can’t keep up with all requests, which needs
    to be</st> <st c="18254">looked into.</st>'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="17863">观察每个组件</st>**<st c="17886">：每个工具都提供某种类型的遥测数据，用以指示健康状态。</st>
    <st c="17960">例如，Argo CD 会暴露 Prometheus 指标，用于工作队列长度、Git 请求和同步活动。</st> <st c="18066">这些数据能指示
    Argo CD 是否仍然能够正常工作。</st> <st c="18139">持续增加的工作队列深度表明 Argo CD 无法跟上所有请求，需要</st>
    <st c="18254">进行排查。</st>'
- en: '**<st c="18266">Service-level agreements (SLAs) and alerting on problems</st>**<st
    c="18323">: We – the platform team – must know that something is wrong before
    our end users report it to us.</st> <st c="18423">That’s why we need to set up</st>
    <st c="18451">SLAs for each component and configure proper alerting in case systems
    are not working as expected.</st> <st c="18551">The simplest way to do this is
    to set up synthetic checks against the key API endpoints of each tool (e.g., validate
    that Jenkins UI is responsive</st> <st c="18697">with a synthetic check that runs
    every five minutes; this gives us an early warning signal in case Jenkins starts
    having problems before anyone else</st> <st c="18847">notices it).</st>'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="18266">服务级协议（SLAs）和故障警报</st>**<st c="18323">：我们——平台团队——必须在最终用户报告问题之前就知道存在问题。</st>
    <st c="18423">这就是为什么我们需要为每个组件设置SLAs，并在系统未按预期工作时配置适当的警报。</st> <st c="18451">实现这一点的最简单方法是设置针对每个工具的关键API端点的合成检查（例如，通过每五分钟运行一次的合成检查来验证
    Jenkins UI 是否响应，这为我们提供了一个提前警告信号，以防 Jenkins 在其他人注意到之前就开始出现问题）。</st>'
- en: <st c="18859">The following is an example dashboard highlighting key health
    indicators of tools, such as Argo CD.</st> <st c="18960">The</st> <st c="18963">same
    must be applied to all other tools that make up our core</st> <st c="19026">platform
    capabilities!</st>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18859">以下是一个示例仪表板，突出显示了工具的关键健康指标，例如 Argo CD。</st> <st c="18960">同样的原则必须应用于构成我们核心平台能力的所有其他工具！</st>
- en: '![Figure 5.1: Monitor and observe every tool part of the platform](img/B31164_05_01.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1：监控并观察平台中每个工具的情况](img/B31164_05_01.jpg)'
- en: '<st c="19787">Figure 5.1: Monitor and observe every tool part of the platform</st>'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19787">图 5.1：监控并观察平台中每个工具的情况</st>
- en: <st c="19850">Platform Components are as business-critical as your critical
    apps</st>
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19850">平台组件与您的关键应用程序同样至关重要</st>
- en: <st c="19917">The core of the platform will revolve around deploying changes
    into various environments.</st> <st c="20008">All tools that support those use
    cases – especially those for Continuous X – need to be highly available, resilient,
    and secure.</st> <st c="20137">Make sure to apply the same engineering best practices
    to all components of</st> <st c="20213">the platform!</st>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19917">平台的核心将围绕将更改部署到各种环境展开。</st> <st c="20008">所有支持这些用例的工具——尤其是那些用于连续X的工具——需要具有高度可用性、弹性和安全性。</st>
    <st c="20137">确保将相同的工程最佳实践应用于平台的所有组件！</st>
- en: <st c="20226">Now that we have recapped the core concepts of Continuous X (integration,
    testing, validation, delivery, deployment, and release) and discussed that all
    configurations (code, deployment config, infrastructure, observability, etc.)
    must follow the same principles, it’s time to have a look into how these concepts
    can be used to provide self-service autonom</st><st c="20583">y to teams that
    leverage this through</st> <st c="20622">a platform.</st>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20226">现在我们已经回顾了连续X（集成、测试、验证、交付、部署和发布）的核心概念，并讨论了所有配置（代码、部署配置、基础设施、可观测性等）必须遵循相同的原则，接下来是时候探讨如何利用这些概念为通过平台实现自主服务的团队提供支持。</st>
- en: <st c="20633">GitOps – Moving from pushing to pulling the desired state</st>
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="20633">GitOps – 从推送到拉取期望状态的转变</st>
- en: '**<st c="20691">CI/CD</st>** <st c="20697">has</st> <st c="20701">been around
    for many years.</st> <st c="20730">The</st> *<st c="20734">Continuous Delivery</st>*
    <st c="20753">book was initially released back in 2010 – years before the emergence
    of containers (made popular through Docker, starting in 2013) and container orchestration
    platforms (such as Kubernetes, starting</st> <st c="20954">in 2014).</st>'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="20691">CI/CD</st>** <st c="20697">已经存在多年。</st> <st c="20701">《持续交付》一书最初发布于2010年——容器（通过Docker推广，从2013年开始）和容器编排平台（如Kubernetes，从2014年开始）出现之前的几年。</st>'
- en: <st c="20963">Fast forward to 2024 when this book was initially published; we
    live in a world where the following is</st> <st c="21067">the case:</st>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20963">快速推进到2024年，当本书首次发布时；我们生活在一个以下情况的世界：</st> <st c="21067">现状是：</st>
- en: '**<st c="21076">Git</st>** <st c="21080">is the source</st> <st c="21095">of
    truth.</st> <st c="21105">It contains everything as code: source code, tests,
    infrastructure and deployment definitions, observability, ownership, and</st>
    <st c="21230">so on.</st>'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="21076">Git</st>** <st c="21080">是事实的源头</st> <st c="21095">。</st> <st
    c="21105">它包含了所有的内容作为代码：源代码、测试、基础设施和部署定义、可观测性、所有权等。</st>'
- en: '**<st c="21236">CI/CD</st>** <st c="21242">is building, testing, and</st> <st
    c="21268">packaging container /</st> **<st c="21291">Open Container Initiative</st>**
    <st c="21316">(</st>**<st c="21318">OCI</st>**<st c="21321">) images</st> <st
    c="21331">from a source code Git repository and publishing them to an artifact
    registry (</st><st c="21410">e.g., Harbor).</st>'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="21236">CI/CD</st>** <st c="21242">是构建、测试并</st> <st c="21268">打包容器
    /</st> **<st c="21291">开放容器倡议</st>** <st c="21316">(</st>**<st c="21318">OCI</st>**<st
    c="21321">) 镜像</st> <st c="21331">来自源代码 Git 仓库，并将它们发布到工件注册中心（</st><st c="21410">例如，Harbor）</st>。'
- en: '**<st c="21425">GitOps</st>** <st c="21432">continuously attempts to apply
    the latest desired state as declared in a deployment</st> <st c="21517">Git repository
    (e.g., Helm Charts) on the target Kubernetes environment and pushes any additional
    configuration (e.g., observability to the</st> <st c="21657">respective tools).</st>'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="21425">GitOps</st>** <st c="21432">持续尝试应用部署 Git 仓库（例如 Helm 图表）中声明的最新期望状态，并将任何额外的配置（例如，观测性）推送到</st>
    <st c="21657">相应的工具中。</st>'
- en: <st c="21675">The preceding description is not a one-size-fits-all model.</st>
    <st c="21736">GitOps will be implemented slightly differently in every organization.</st>
    <st c="21807">If you search for</st> `<st c="21825">What is GitOps?</st>`<st c="21840">,
    you will find many different variations, such as</st> <st c="21891">the following:</st>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21675">上述描述并不是适用于所有情况的统一模型。</st> <st c="21736">GitOps 在每个组织中的实施方式都会有所不同。</st>
    <st c="21807">如果你搜索</st> `<st c="21825">什么是 GitOps？</st>`<st c="21840">，你会找到许多不同的变体，如</st>
    <st c="21891">以下内容：</st>
- en: '**<st c="21905">Separate CI and CD</st>**<st c="21924">: CI publishing containers
    and CD publishing packaged artifacts, such as</st> <st c="21998">Helm charts</st>'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="21905">分离 CI 和 CD</st>**<st c="21924">：CI 负责发布容器，CD 负责发布打包后的工件，如</st>
    <st c="21998">Helm 图表</st>'
- en: '**<st c="22009">Single Git</st>**<st c="22020">: Everything as code (source,
    test, deployment, observability, etc.) in a single</st> <st c="22102">Git repository</st>'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="22009">单一 Git</st>**<st c="22020">：将一切作为代码（源代码、测试、部署、观测性等）存储在单一的</st>
    <st c="22102">Git 仓库中</st>'
- en: '**<st c="22116">Push GitOps</st>**<st c="22128">: Pushing</st> <st c="22138">the
    desired state through pipelines or workflows versus pulling changes into the target
    environment through</st> <st c="22247">GitOps operators</st>'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="22116">推送 GitOps</st>**<st c="22128">：通过流水线或工作流推送期望的状态，而不是通过</st>
    <st c="22247">GitOps 操作员</st> <st c="22138">将更改拉入目标环境</st>'
- en: <st c="22263">In the following section, we will shine the light on one flavor
    of GitOps that favors the</st> **<st c="22354">pull</st>** <st c="22358">(</st>*<st
    c="22360">pulling</st>* <st c="22367">a configuration into the target environment)
    model over the</st> **<st c="22428">push</st>** <st c="22432">(</st>*<st c="22434">pushing</st>*
    <st c="22441">a configuration from an external tool into the target environment)
    model, which can be implemented with CNCF tools, such as Flux or Argo CD, as shown
    in the following illustration taken from Codefresh’s Learning Center on</st> <st
    c="22664">GitOps:</st> [<st c="22672">https://codefresh.io/learn/gitops/</st>](https://codefresh.io/learn/gitops/)<st
    c="22706">.</st>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22263">在接下来的章节中，我们将重点介绍一种偏向于</st> **<st c="22354">拉取</st>** <st c="22358">(</st>*<st
    c="22360">将配置拉入目标环境</st>* <st c="22367">) 模型，而不是</st> **<st c="22428">推送</st>**
    <st c="22432">(</st>*<st c="22434">从外部工具推送配置到目标环境</st>* <st c="22441">) 模型，该模型可以使用
    CNCF 工具（如 Flux 或 Argo CD）实现，如下图所示，该图取自 Codefresh 学习中心的</st> <st c="22664">GitOps</st>：[<st
    c="22672">https://codefresh.io/learn/gitops/</st>](https://codefresh.io/learn/gitops/)<st
    c="22706">。</st>
- en: '![Figure 5.2: Basic GitOps flow as promoted by GitOps tools such as Argo CD
    or Flux](img/B31164_05_02.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2：GitOps 流程基础，如 Argo CD 或 Flux 等 GitOps 工具所推广的那样](img/B31164_05_02.jpg)'
- en: '<st c="22940">Figure 5.2: Basic GitOps flow as promoted by GitOps tools such
    as Argo CD or Flux</st>'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22940">图 5.2：GitOps 流程基础，如 Argo CD 或 Flux 等 GitOps 工具所推广的那样</st>
- en: <st c="23021">It’s your choice as to whether you favor the Push model using
    automated pipelines or workflows to push changes into your target Kubernetes environments!</st>
    <st c="23175">To make the decision easier, let’s dig into more detail on the individual
    phases and learn about</st> <st c="23272">some best practices that should happen
    in</st> <st c="23314">every phase!</st>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23021">是否选择使用自动化流水线或工作流推送更改到目标 Kubernetes 环境是由你决定的！</st> <st c="23175">为了让决策更容易，我们将深入探讨每个阶段的更多细节，并了解</st>
    <st c="23272">在每个阶段中应该遵循的一些最佳实践！</st>
- en: <st c="23326">Phase 1 – from source code to container image</st>
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="23326">阶段 1 – 从源代码到容器镜像</st>
- en: <st c="23372">Moving to GitOps doesn’t</st> <st c="23398">change anything about
    how we are building our applications from source code that is version-controlled
    in Git.</st> <st c="23509">Before building new artifacts, a good practice is to
    automate dependency checks and updates.</st> <st c="23602">Tools, such as</st>
    **<st c="23617">Renovate Bot</st>** *<st c="23629">[3]</st>*<st c="23633">, integrate
    with</st> <st c="23650">Git and create Pull Requests in case outdated dependencies,
    third-party libraries, or other dependencies</st> <st c="23755">are found.</st>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23372">迁移到GitOps并不</st> <st c="23398">改变我们如何从Git中版本控制的源代码构建应用程序。</st>
    <st c="23509">在构建新工件之前，一个好的做法是自动化依赖检查和更新。</st> <st c="23602">例如，</st> **<st c="23617">Renovate
    Bot</st>** *<st c="23629">[3]</st>*<st c="23633">工具可以与Git集成，并在发现过时的依赖、第三方库或其他依赖项时创建Pull
    Requests。</st> <st c="23755">这些工具非常有用。</st>
- en: '<st c="23765">Once we have our up-to-date code in Git,</st> **<st c="23807">CI</st>**
    <st c="23809">has the</st> <st c="23817">same job as it always had: it creates
    an artifact, most likely a container image, that gets pushed to a container registry!</st>
    <st c="23942">That CI can be triggered on demand, on commits to certain branches,
    on Pull Requests, or on any other trigger that makes sense for</st> <st c="24073">the
    organization!</st>'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23765">一旦我们在Git中更新了代码，</st> **<st c="23807">CI</st>** <st c="23809">就有了和以前一样的任务：它创建一个工件，最有可能是一个容器镜像，并将其推送到容器注册表！</st>
    <st c="23942">这个CI可以根据需要触发，或者在某些分支的提交、Pull Requests，或者任何其他合理的触发条件下触发。</st> <st
    c="24073">这是对组织来说非常重要的！</st>
- en: '<st c="24090">There are many different tools available that can do the job:
    Jenkins, GitLab, Azure DevOps, GitHub Actions, Bitbucket Pipelines, and many more.</st>
    <st c="24236">There are also various container registry options.</st> <st c="24287">We
    will talk about container registries and the importance of them a bit later in
    this book as they are – like all the components of our platform – critical to
    the success of our</st> <st c="24466">future platform!</st>'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24090">有很多不同的工具可以完成这项工作：Jenkins、GitLab、Azure DevOps、GitHub Actions、Bitbucket
    Pipelines等等。</st> <st c="24236">也有各种容器注册表选项。</st> <st c="24287">稍后我们将在本书中讨论容器注册表及其重要性，它们和我们平台的所有组件一样，都是我们</st>
    <st c="24466">未来平台成功的关键！</st>
- en: <st c="24482">Once the CI</st> <st c="24495">has successfully compiled the source
    code, executed unit tests, and run any additional quality checks on the code,
    it’s time to package the binary into a container image.</st> <st c="24666">There
    are many best practices out there for building container images; from just packaging
    a single service into a container, being careful to use public base images, to
    building the smallest image possible.</st> <st c="24874">Following all those rules
    will lead to a higher rate of success as the container image moves from CI all
    the way into production.</st> <st c="25004">Here are two obvious but very important
    practices that we want to mention in this chapter (for more information, please
    refer to the books</st> <st c="25143">previously mentioned):</st>
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24482">一旦CI</st> <st c="24495">成功编译源代码、执行单元测试，并对代码进行任何额外的质量检查后，便可以将二进制文件打包成容器镜像。</st>
    <st c="24666">构建容器镜像有很多最佳实践；从只将单个服务打包到容器中、谨慎使用公共基础镜像，到构建尽可能小的镜像。</st> <st c="24874">遵循所有这些规则将提高容器镜像从CI到生产环境的成功率。</st>
    <st c="25004">这里有两个显而易见但非常重要的实践，我们希望在本章提到（更多信息，请参阅之前提到的书籍）：</st>
- en: '`<st c="25293">finoneacme/fund-transfer:2.34.3</st>`<st c="25324">, where</st>
    `<st c="25332">finoneacme/fund-transfer</st>` <st c="25356">is the name and</st>
    `<st c="25373">2.34.3</st>` <st c="25379">is the tag).</st> <st c="25393">When
    you build an image, it’s up to you to tag it properly but you should follow a
    consistent policy.</st> <st c="25495">There are two common ways to do this that
    are used in</st> <st c="25549">the industry:</st>'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="25293">finoneacme/fund-transfer:2.34.3</st>`<st c="25324">，其中</st>
    `<st c="25332">finoneacme/fund-transfer</st>` <st c="25356">是名称，</st> `<st c="25373">2.34.3</st>`
    <st c="25379">是标签。</st> <st c="25393">在你构建镜像时，标签由你决定，但你应该遵循一致的命名规则。</st> <st c="25495">行业中有两种常见的做法：</st> '
- en: '`<st c="25738">MAJOR.MINOR.PATCH</st>`<st c="25755">. Every minor or patch
    version number must be for a backward-compatible change.</st> <st c="25835">In
    combination with the version name</st> `<st c="25872">latest</st>`<st c="25878">,
    which is the default to point to the latest available version, you can provide
    easy access to a specific image (e.g.,</st> `<st c="25998">X.Y.Z</st>`<st c="26003">).</st>
    <st c="26007">It also allows for the selection of the latest patch release for
    a specific minor release (e.g.,</st> `<st c="26104">X.Y</st>`<st c="26107">) or
    the latest minor and patch version for a major release (</st><st c="26169">e.g.,</st>
    `<st c="26176">X</st>`<st c="26177">).</st>'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="25738">MAJOR.MINOR.PATCH</st>`<st c="25755">。每个次要或修补版本号必须是向后兼容的更改。</st>
    <st c="25835">结合版本名称</st> `<st c="25872">latest</st>`<st c="25878">，这是指向最新可用版本的默认值，你可以方便地访问特定的镜像（例如，</st>
    `<st c="25998">X.Y.Z</st>`<st c="26003">）。</st> <st c="26007">它还允许选择特定次版本的最新修补版本（例如，</st>
    `<st c="26104">X.Y</st>`<st c="26107">）或某个主版本的最新次版本和修补版本（</st><st c="26169">例如，</st>
    `<st c="26176">X</st>`<st c="26177">）。</st>'
- en: '`<st c="26287">git commit</st>` <st c="26297">hash as version instead of keeping
    track of semantic versioning.</st> <st c="26363">The commit hash</st> <st c="26378">on
    the image also immediately tells us which source code commit was responsible for
    producing this container image.</st> <st c="26495">For our image, this could mean
    it’s tagged like</st> <st c="26543">this:</st> `<st c="26549">financeoneacme/fund-transfer:d85aaef</st>`<st
    c="26585">.</st>'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="26287">git commit</st>` <st c="26297">哈希作为版本，而不是跟踪语义版本。</st> <st c="26363">提交哈希</st>
    <st c="26378">在镜像上也立即告诉我们是哪个源代码提交负责生成了这个容器镜像。</st> <st c="26495">对于我们的镜像，这可能意味着它被标记为</st>
    <st c="26543">这样：</st> `<st c="26549">financeoneacme/fund-transfer:d85aaef</st>`<st
    c="26585">。</st>'
- en: '`<st c="27201">log4j</st>` <st c="27206">vulnerability.</st> <st c="27222">This
    is why security must go beyond the static checks in the CI process and continue
    throughout the life cycle of an artifact.</st> <st c="27349">This will be</st>
    <st c="27361">explored more in</st> [*<st c="27379">Chapter 7</st>*](B31164_07.xhtml#_idTextAnchor381)<st
    c="27388">, which dives deeper into building and operating</st> <st c="27437">secure
    products.</st>'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="27201">log4j</st>` <st c="27206">漏洞。</st> <st c="27222">这就是为什么安全性必须超越
    CI 流程中的静态检查，并贯穿整个工件的生命周期。</st> <st c="27349">这一点将在</st> <st c="27361">[*第7章*](B31164_07.xhtml#_idTextAnchor381)中进一步探讨</st>
    <st c="27388">，该章节深入探讨了构建和运营</st> <st c="27437">安全产品。</st>'
- en: <st c="27453">Now that we have a container image uploaded to our</st> <st c="27505">container
    registry, we can use it in a</st> <st c="27544">deployment definition.</st>
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27453">现在我们已经将容器镜像上传到我们的</st> <st c="27505">容器注册表中，我们可以在</st> <st c="27544">部署定义中使用它。</st>
- en: <st c="27566">Phase 2 – from container image to metadata-enriched deployment
    artifact</st>
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="27566">第2阶段 – 从容器镜像到富含元数据的部署工件</st>
- en: <st c="27638">The container image now needs to find its way into a deployment
    definition.</st> <st c="27715">Looking at Kubernetes, we would need a manifest
    file that defines our deployment definition, which we can later apply to our</st>
    <st c="27840">K8s cluster.</st>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27638">容器镜像现在需要找到进入部署定义的路径。</st> <st c="27715">看 Kubernetes，我们需要一个清单文件来定义我们的部署定义，之后可以将其应用到我们的</st>
    <st c="27840">K8s 集群。</st>
- en: <st c="27852">In</st> [*<st c="27856">Chapter 3</st>*](B31164_03.xhtml#_idTextAnchor133)<st
    c="27865">, we highlighted that adding</st> <st c="27894">metadata (ownership,
    observability level, notifications) to our deployment file will benefit lots of
    the self-service use cases, such as the</st> *<st c="28035">Requesting Logs as
    Self-Service</st>* <st c="28066">use case.</st> <st c="28077">Besides our source
    code, we therefore also need to version control our deployment definition and
    should enforce a minimum set of metadata.</st> <st c="28216">This enables our
    platform self-service use cases (e.g., who has deployed which services belong
    to which application) as well as following general infrastructure best</st> <st
    c="28382">practices (e.g., defining request and resource limits), as you can see
    in the</st> <st c="28460">following manifest:</st>
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27852">在</st> [*<st c="27856">第3章</st>*](B31164_03.xhtml#_idTextAnchor133)<st
    c="27865">中，我们强调了将</st> <st c="27894">元数据（所有权、可观察性级别、通知）添加到我们的部署文件中，将有利于许多自助服务用例，例如</st>
    *<st c="28035">作为自助服务请求日志</st>* <st c="28066">的用例。</st> <st c="28077">因此，除了我们的源代码，我们还需要对我们的部署定义进行版本控制，并且应强制执行最小元数据集。</st>
    <st c="28216">这使我们的平台自助服务用例（例如，谁部署了哪些服务，属于哪个应用程序）以及遵循一般基础设施最佳</st> <st c="28382">实践（例如，定义请求和资源限制）成为可能，正如你在以下清单中看到的：</st>
- en: <st c="28479">mainfest.yaml (Kubernetes Deployment)</st>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28479">mainfest.yaml（Kubernetes 部署文件）</st>
- en: '[PRE3]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="29126">The deployment definition can be a manifest or a set of manifest
    files, as we likely also need additional K8s resources, such as a service or Ingress
    definition.</st> <st c="29289">Instead of plain manifest files that we organize
    in a subfolder next to the source code of our service, there are options to leverage
    templating or</st> <st c="29436">packaging frameworks and tools, such</st> <st
    c="29473">as</st> **<st c="29477">Kustomize</st>** *<st c="29486">[5]</st>* <st
    c="29490">or</st> **<st c="29494">Helm</st>** *<st c="29498">[6]</st>*<st c="29502">.</st>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29126">部署定义可以是一个清单文件或一组清单文件，因为我们可能还需要额外的 K8s 资源，例如服务或 Ingress 定义。</st>
    <st c="29289">与我们将清单文件组织在与服务源代码相邻的子文件夹中的做法不同，我们可以选择使用模板化或</st> <st c="29436">打包框架和工具，如</st>
    **<st c="29477">Kustomize</st>** *<st c="29486">[5]</st>* <st c="29490">或</st>
    **<st c="29494">Helm</st>** *<st c="29498">[6]</st>*<st c="29502">。</st>
- en: <st c="29503">It is important to consider how to organize and version control
    all of our everything as code files.</st> <st c="29605">There are several strategies
    with pros and cons that are well documented.</st> <st c="29679">To learn more,
    the authors suggest reading up on the different patterns for repositories and
    directory structures.</st> <st c="29794">The following section is just a quick
    overview of wha</st><st c="29847">t you must know to continue your in-depth research
    on</st> <st c="29902">this topic!</st>
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29503">考虑如何组织和版本控制所有“作为代码”的文件是非常重要的。</st> <st c="29605">有几种策略，每种策略都有优缺点，并且都有很好的文档支持。</st>
    <st c="29679">如果想深入了解，作者建议阅读关于仓库和目录结构的不同模式。</st> <st c="29794">以下部分只是对你在深入研究这一主题时必须知道的内容的简要概述！</st>
- en: <st c="29913">Monorepo versus polyrepo</st>
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="29913">单一仓库与多仓库</st>
- en: <st c="29938">When designing your git repository structure, you have two general
    options which the industry refers to as monorepo</st> <st c="30054">or polyrepo;
    a single Git repository or multiple repositories split by teams</st> <st c="30131">or
    functions:</st>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29938">在设计 Git 仓库结构时，你有两个常见的选择，业界称之为单一仓库（monorepo）</st> <st c="30054">或多仓库（polyrepo）；一个
    Git 仓库或多个由团队</st> <st c="30131">或职能划分的仓库：</st>
- en: '![Figure 5.3: Mono versus polyrepo – pros and cons for both patterns](img/B31164_05_03.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3：单一仓库与多仓库——两种模式的优缺点](img/B31164_05_03.jpg)'
- en: '<st c="30266">Figure 5.3: Mono versus polyrepo – pros and cons for both patterns</st>'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30266">图 5.3：单一仓库与多仓库——两种模式的优缺点</st>
- en: '**<st c="30332">Monorepo</st>**<st c="30341">: In the</st> <st c="30350">monorepo
    pattern, all configuration files (code, infrastructure, observability, etc.) are
    stored in a single Git repository.</st> <st c="30476">This pattern applies to
    every potential environment (dev, testing, staging, production)—meaning every
    configuration is in a single Git repo, separated</st> <st c="30627">by folders.</st>'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="30332">单一仓库</st>**<st c="30341">：在单一仓库模式中，所有配置文件（代码、基础设施、可观察性等）都存储在一个
    Git 仓库中。</st> <st c="30476">这种模式适用于每一个潜在的环境（开发、测试、预发布、生产），也就是说，所有配置都在同一个 Git 仓库中，通过文件夹来区分。</st>'
- en: <st c="30638">The benefit of a</st> <st c="30655">monorepo is that everything
    is in one place.</st> <st c="30701">The downside is that this repo will eventually
    become very large, resulting in potential performance issues when tools like ArgoCD
    or Flux need to constantly scan the entire repo for changes.</st> <st c="30893">It
    also makes it harder to separate the concerns between application and</st> <st
    c="30966">infrastructure owners.</st>
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="30638">单一仓库的好处是所有内容都集中在一个地方。</st> <st c="30655">缺点是，这个仓库最终会变得非常庞大，当像
    ArgoCD 或 Flux 这样的工具需要不断扫描整个仓库以检查变化时，可能会引发性能问题。</st> <st c="30701">它还使得应用程序和基础设施拥有者之间的关注点分离变得更加困难。</st>
- en: '**<st c="30988">Polyrepo</st>**<st c="30997">: In the</st> <st c="31007">polyrepo
    pattern, we have multiple repositories, which makes it easier to separate concerns.</st>
    <st c="31100">These can be repositories per team (app team A, B, C), per environment
    (dev, staging, prod, etc.), per tenant (in multi-tenancy systems), or per organizational
    boundary (app teams, platform</st> <st c="31290">teams, etc.).</st>'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="30988">多仓库</st>**<st c="30997">：在多仓库模式中，我们有多个仓库，这使得分离关注点变得更加容易。</st>
    <st c="31100">这些可以是按团队划分的仓库（例如，应用团队 A、B、C），按环境划分的仓库（开发、测试、生产等），按租户划分的仓库（在多租户系统中），或者按组织边界划分的仓库（如应用团队、平台团队等）。</st>'
- en: <st c="31303">The</st> <st c="31308">benefit is a better separation of concerns.</st>
    <st c="31352">The downside is that we eventually end up managing a large number
    of Git repositories, which makes it harder to ensure consistency and overall validity
    across all configuratio</st><st c="31527">ns spread across multiple repos that
    make up the</st> <st c="31577">entire configuration.</st>
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="31598">Directory structure – follow the DRY principle</st>
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="31645">Whether mono or polyrepo, the individual</st> <st c="31686">Git
    repository will need to have a good directory structure.</st> <st c="31748">Typically,
    we see it reflecting the organizational structure separating the development teams
    from the teams that manage the underlying infrastructure or platform.</st> <st
    c="31912">A good practice is to follow</st> <st c="31941">the</st> **<st c="31945">don’t
    repeat yourself</st>** <st c="31966">(</st>**<st c="31968">DRY</st>**<st c="31971">)</st>
    *<st c="31974">[7]</st>* <st c="31977">principle.</st> <st c="31989">The idea
    is to find the best structure to avoid copying/pasting common YAML settings in
    different places.</st> <st c="32095">This is where tools such as Helm and</st>
    <st c="32132">Kustomize help.</st>
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32147">The following structure example was inspired by a GitOps blog</st>
    <st c="32209">from</st> **<st c="32215">Red Hat</st>** *<st c="32222">[8]</st>*
    <st c="32226">and shows the configuration for the platform administrator and the
    configuration for an application team using a templating tool such</st> <st c="32361">as
    Kustomize.</st> <st c="32375">This structure could either be used in a single
    monorepo separated by a folder, or it could be put into individual repos following
    the</st> <st c="32510">polyrepo pattern.</st>
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '| **<st c="32527">Platform Team</st>** | **<st c="32541">Development Team</st>**
    |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
- en: '| `<st c="32558">├──</st>` `<st c="32563">bootstrap</st>``<st c="32572">│ ├──</st>`
    `<st c="32579">base</st>``<st c="32583">│ └──</st>` `<st c="32590">overlays</st>``<st
    c="32598">│ └──</st>` `<st c="32605">default</st>``<st c="32612">├──</st>` `<st
    c="32617">cluster-config</st>``<st c="32631">│</st>``**<st c="32633">├──</st>**`
    **`<st c="32637">gitops-controller</st>`** **`<st c="32654">│ ├──</st>` `<st c="32661">identity-provider</st>`'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="32678">│ └──</st>` `<st c="32685">image-scanner</st>`'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="32698">└──</st>` `<st c="32703">components</st>`'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '`**<st c="32713">├──</st>**` **`<st c="32718">applicationsets</st>`**'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '**`<st c="32733">├──</st>` `<st c="32738">applications</st>`'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '`**<st c="32750">└──</st>**` **`<st c="32755">argocdproj</st>`******  | `<st
    c="32765">└──</st>` `<st c="32770">deploy</st>``<st c="32776">├──</st>` `<st c="32781">base</st>``<st
    c="32785">└──</st>` `<st c="32790">overlays</st>``<st c="32798">├──</st>` `<st
    c="32803">dev</st>``<st c="32806">├──</st>` `<st c="32811">prod</st>``<st c="32815">└──</st>`
    `<st c="32820">stage</st>` |'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="32825">Table 5.1: One possible directory structure used by tools such
    as Kustomize</st>'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32901">Now that we have learned about the different ways to organize
    our repositories and directory structures, we need to learn how the new container
    image in</st> *<st c="33055">Phase 1</st>* <st c="33062">makes it to our deployment
    definition in</st> <st c="33104">our repositories!</st>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33121">Updating manifest with new container image version</st>
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="33172">The last piece to</st> *<st c="33191">Phase 2</st>* <st c="33198">is
    to promote a</st> <st c="33214">new image version that came out of CI into our
    deployment files.</st> <st c="33280">This could be updating the deployment manifest,
    as shown in the preceding example, or updating a</st> `<st c="33377">values.yaml</st>`
    <st c="33388">file when using</st> <st c="33405">Helm charts.</st>
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33417">As those configuration files are version-controlled in a Git repository
    (mono or poly, it doesn’t matter), we should follow the regular Git workflow and
    create a Pull Request to promote the update of that image.</st> <st c="33630">We
    can automate the creation of that Pull Request in</st> <st c="33683">two ways:</st>
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="33692">Step in CI pipeline</st>**<st c="33712">: As the last step
    in CI, a Pull Request</st> <st c="33753">can be opened, promoting the new image
    tag to the respective deployment definition repo and the right directory structure
    (for example, updating the values in the development overlay directory if this
    is a newly</st> <st c="33966">built image)</st>'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="33978">Webhook in a container registry</st>**<st c="34010">: When
    the registry receives a new image from CI, it can trigger a webhook, which allows</st>
    <st c="34100">us to create that same Pull Request in our deployment</st> <st c="34154">Git
    repository</st>'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="34168">The following shows the updated version information of the</st>
    *<st c="34228">Kubernetes Deployment</st>* <st c="34249">that we have seen in
    the earlier example.</st> <st c="34292">You can compare this with the values of
    the</st> <st c="34336">previous example:</st>
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="34780">Now, we know how a new image that is built by CI makes it into
    the deployment definition in our respective repositories.</st> <st c="34902">We
    already saw the GitOps operator in an image earlier in this chapter.</st> <st
    c="34974">Now, it’s time to dive into what the GitOps operator really does to
    apply our desired state from Git to our</st> <st c="35082">target cluster</st><st
    c="35096">s!</st>
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: <st c="35099">Phase 3 – GitOps – keeping your desired deployment state</st>
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="35156">Now that we have everything as code in Git, it’s time to talk
    about how to apply that configuration to our target environments.</st> <st c="35285">One
    way is to use the same push model as we use for CI.</st> <st c="35341">We could
    have delivery pipelines get triggered on changes in our Git repository and then
    have the latest version of the manifests or helm charts applied to the target
    environment.</st> <st c="35521">In this chapter, we, however, focus on and favor
    the Pull model, which is implemented by GitOps operators or GitOps agents, such
    as Argo CD, Flux, and some</st> <st c="35677">commercial offering</st><st c="35696">s.</st>
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: <st c="35699">GitOps operators in a nutshell – sync Git to K8s</st>
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="35748">GitOps operators</st> <st c="35765">continuously reconcile and
    ensure that the desired state declared in our repositories matches the actual
    state running in our target environments.</st> <st c="35913">The operator detects
    an</st> *<st c="35937">out-of-sync</st>* <st c="35948">if the state in Git does
    not match the one on the target environment.</st> <st c="36019">This could happen
    if the Git configuration was changed (e.g., a new image is available and causes
    a manifest update).</st> <st c="36137">It can also happen if somebody changes
    the configuration in K8s (e.g., through a manual update or a different automation
    tooling).</st> <st c="36268">The following is a high-level overview showing the
    role of the</st> <st c="36331">GitOps operator:</st>
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4: GitOps operator synchronizes the desired state in Git with the
    actual state in K8s](img/B31164_05_04.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
- en: '<st c="36448">Figure 5.4: GitOps operator synchronizes the desired state in
    Git with the actual state in K8s</st>'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36542">Depending on the GitOps operator tool, there will be different
    configuration options in the reconciliation process.</st> <st c="36659">It’s worth
    checking out the documentation of the two prominent tools in the cloud native</st>
    <st c="36748">ecosystem:</st> **<st c="36759">Argo CD</st>** *<st c="36766">[9]</st>*
    <st c="36770">and</st> **<st c="36775">Flux</st>** *<st c="36779">[10]</st>*<st
    c="36784">. Also, make</st> <st c="36797">yourself familiar with the configuration
    elements, as some tools have a concept of projects and applications, whereas others
    just have a concept of</st> <st c="36945">a sou</st><st c="36950">rce.</st>
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36955">Understanding reconciliation – keeping K8s in sync with Git</st>
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '<st c="37015">Essentially, the GitOps operator will fetch the desired state
    for a project or application from a source (Git repository, a folder in the Git
    repository, the OCI repository, S3 buckets, etc.) and compare it with the current
    state running on the target K8s cluster.</st> <st c="37281">The two states can
    either be</st> *<st c="37310">synced</st>* <st c="37316">or</st> *<st c="37320">out-of-sync</st>*<st
    c="37331">. When the state is</st> *<st c="37351">out-of-sync</st>*<st c="37362">,
    there are different options for the GitOps operator to synchronize the states
    – meaning: bring the current state to match the</st> <st c="37490">desired state:</st>'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="37504">Manual sync</st>**<st c="37516">: Either via</st> <st c="37529">a</st>
    **<st c="37532">command-line interface</st>** <st c="37554">(</st>**<st c="37556">CLI</st>**<st
    c="37559">) or a</st> <st c="37566">UI, one can trigger the GitOps operator to
    synchronize the</st> <st c="37626">two states.</st>'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="37637">Auto sync</st>**<st c="37647">: Once a</st> <st c="37657">system
    is out-of-sync, the GitOps operator tries to</st> <st c="37709">automatically
    synchronize.</st>'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="37735">Sync schedules/windows</st>**<st c="37758">: There might</st>
    <st c="37772">be times when you want or don’t want syncs to happen.</st> <st c="37827">This
    is where sync schedules or sync windows come in, which either block or allow syncs</st>
    <st c="37915">to happen.</st>'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="37925">Sync failed</st>**<st c="37937">: It can happen</st> <st c="37954">that
    the GitOps operator can’t apply the desired state.</st> <st c="38010">This could
    be because of configuration file mistakes (e.g., referencing an invalid image).</st>
    <st c="38101">It could be because of an infrastructure issue (e.g., K8s doesn’t
    have enough resources).</st> <st c="38191">It could also be because of competing
    tools (e.g., auto-scaling tools, such as HPA/KEDA, changing replicas or resource
    limits).</st> <st c="38319">It’s important to be aware of this state and handle
    it correctly.</st> <st c="38385">See the section on best practices for some</st>
    <st c="38428">additional input!</st>'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="38445">Now that we are aware of the synchronization basics, let’s have
    a look at different GitOps operator</st> <st c="38546">deployment</st> <st c="38557">patterns!</st>
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38566">GitOps operator patterns – single, hub and spoke, and many-to-many</st>
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="38633">The simplest version – and</st> <st c="38660">probably the model
    that many start with – is the monorepo approach with GitOps operators pulling
    into a single target environment, as we have seen in</st> *<st c="38811">Figure
    5</st>**<st c="38819">.3</st>* <st c="38821">for both patterns.</st> <st c="38841">While
    the single target is a common pattern, especially as you are getting started with
    GitOps, we have other patterns that we want to</st> <st c="38976">quickly highlight.</st>
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: <st c="38994">GitOps can also be set up where we have a central GitOps operator
    that keeps the desired state as declared in Git and synchronizes with several
    target environments by pushing out those changes.</st> <st c="39189">This is called</st>
    <st c="39203">the</st> **<st c="39208">hub-and-spoke model</st>**<st c="39227">.
    Another option is the</st> **<st c="39251">many-to-many model</st>**<st c="39269">,
    where each target environment has its own GitOps</st> <st c="39320">operator that
    continuously synchronizes the desired state with the state on its own cluster,
    as shown in the</st> <st c="39429">following figure:</st>
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5: Hub-and-spoke and many-to-many GitOps operator pattern](img/B31164_05_05.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
- en: '<st c="39503">Figure 5.5: Hub-and-spoke and many-to-many GitOps operator pattern</st>'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: <st c="39569">Now that we have discussed the major phases in GitOps, let’s recap
    and have a quick look into some</st> <st c="39669">best</st> <st c="39673">practices.</st>
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: <st c="39684">GitOps best practices</st>
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: <st c="39706">This list is not complete but should</st> <st c="39744">give you
    a good starting point when defining your</st> <st c="39793">GitOps process:</st>
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="39809">Separate config from source code repositories/folders</st>**<st
    c="39863">: It’s recommended to separate the actual source code from the deployment
    definitions.</st> <st c="39951">Either in separate repositories or, within the
    repo, in separate folders.</st> <st c="40025">Why is that?</st> <st c="40038">It’s
    a clean separation of concerns and access.</st> <st c="40086">It makes Git-triggered
    actions easier as a change in a deployment config file should trigger different
    actions than in the source code files.</st> <st c="40228">It avoids a potentially
    infinite loop of change if CI changes the same repository!</st> <st c="40311">The
    smaller the repository, the less work for GitOps tools to scan all files to determine
    the</st> <st c="40405">desired state.</st>'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="40419">Proper sync settings – poll versus webhook</st>**<st c="40462">:
    GitOps tools provide different sync settings for both scanning the source systems
    (e.g., Git) and scheduling the triggering of synchronizations.</st> <st c="40610">For
    scanning, make yourself familiar with the default poll frequency (e.g., Argo CD,
    by default, pulls all Git repos every three minutes).</st> <st c="40749">Both
    Argo CD and Flux can also be changed to receive webhooks from the Git system,
    which replaces the pull into a push mechanism!</st> <st c="40879">This is very
    important to understand, as with an increase in the number of source systems (Git,
    artifact repositories, S3 buckets, etc.), the number of API calls from your GitOps
    tool to those systems increases.</st> <st c="41091">It’s a good practice to monitor
    the number of calls made from the GitOps tool to those external systems to get
    alerted in case the behavior drastically changes.</st> <st c="41252">A change
    in behavior could be caused by an accidental configuration change of default settings.</st>
    <st c="41348">Most tools provide Prometheus or OpenTelemetry metrics that can
    be observed by your</st> <st c="41432">observability tool!</st>'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="41451">The authors have seen configurations that ended in API rate limits
    and even crashing Git systems due to too much load produced by the GitOps tools
    during</st> <st c="41606">a sync!</st>
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**<st c="41613">Not every config must be in a manifest</st>**<st c="41652">:
    As GitOps keeps track of desired versus actual state, it’s important to leave
    some configuration out of your manifest that might be managed by different tools.</st>
    <st c="41815">Take replicas as an example.</st> <st c="41844">If you are using
    tools such as HPA or KEDA to auto-scale your pods, you do not want a static replicas
    count in your manifest.</st> <st c="41970">This would lead the GitOps tool to
    detect out-of-syncs for any change that HPA/KEDA does.</st> <st c="42060">This,
    therefore, results in two automation tools competing with</st> <st c="42124">each
    other.</st>'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="42135">GitOps notifications to handle sync states</st>**<st c="42178">:
    GitOps tools provide notifications when sync status changes.</st> <st c="42242">This
    would be when GitOps detects an out-of-sync, when it finishes a sync, or when
    there is an issue and a sync fails.</st> <st c="42361">In all those cases, it’s
    important to get notified as you want to make sure that you handle sync failures
    or send information back to the development</st> <st c="42511">team when the latest
    update has successfully</st> <st c="42556">been</st> <st c="42560">synced.</st>'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="42568">To get notified, GitOps tools will create Kubernetes events that
    you can ingest into your observability solution and then react/alert on them.</st>
    <st c="42712">GitOps tools also typically provide some type of native notification
    feature where an external tool can be triggered in the case of a special event.</st>
    <st c="42861">Flux, for instance, provides Alerts, whereas Argo CD provides a
    concept of notifications.</st> <st c="42951">Both allow you to, for example, send
    Slack messages or trigger other external tools in the case of certain events that</st>
    <st c="43070">need attention!</st>
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43085">GitOps – changing from push to pull</st>
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43121">GitOps expands the power of Git from application code to everything
    as code.</st> <st c="43199">While CI/CD still focuses on building artifacts, GitOps
    provides an elegant way to pull the desired deployment state into any target environment
    along the software development life cycle.</st> <st c="43387">Changes to a system
    can only be done through Git with the benefit of traceability of changes, revertability
    to a previous version, and enforcing review processes through</st> <st c="43557">Pull
    Requests.</st>
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43571">Now that we have covered the basics of GitOps, we should see how
    this can benefit us in building modern platforms.</st> <st c="43687">As platform
    teams, we can centrally enforce best practices (version control, policies, etc.)
    by using automation in CI/CD and the container registry to reduce the chance of
    a bad change request.</st> <st c="43882">With Git, every change and deployment
    is traceable back to a Git commit, making troubleshooting much easier, and it
    also provides an additional level of self-service (e.g., notify development teams
    when their change has been synchronized to the target environment or notify them
    when their latest version (via the</st> `<st c="44196">git commit</st>` <st c="44206">hash)
    has</st> <st c="44217">any issues).</st>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44229">Now, let’s go on and spend some time on container registries as,
    without them, we wouldn’t be able to publish or distribute any of the images that
    are being produced by the development teams that leverage the platform as</st>
    <st c="44451">a self-service.</st>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44466">Understanding the importance of container and artifact registries
    as entry points</st>
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="44548">Container and artifact registries deserve their own chapter as
    they are one of the core building blocks of modern cloud-native platforms.</st>
    <st c="44687">However, we will try to provide the relevant knowledge that should
    help you follow along with what’s to come in the later chapters of</st> <st c="44821">this
    book.</st>
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44831">We differentiate between public and</st> <st c="44868">private
    registries:</st>
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="44887">Public registries</st>** <st c="44905">are commonly</st> <st
    c="44919">used by individuals or small teams that want to get up and running with
    their registries as quickly as possible.</st> <st c="45032">However, at some point,
    it’s worth looking at</st> <st c="45078">private registries.</st>'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="45097">Private registries</st>** <st c="45116">provide</st> <st c="45124">several
    critical capabilities, such as efficient storage of images, scanning for vulnerabilities,
    replicating images to other registries, enforcing access control when images get
    pulled, and notifying other tools about updates, with the ultimate goal of making
    images fast and easily accessible to those environments that need to</st> <st
    c="45455">deploy them.</st>'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="45467">While private container registries are typically only accessed
    internally to push new builds and have them pulled by our GitOps tools, we can
    also open the registry to the</st> *<st c="45639">public</st>*<st c="45646">.
    With the</st> *<st c="45657">public</st>*<st c="45663">, we mean</st> <st c="45672">allowing
    third-party vendors the option to push their latest images or deployment artifacts.</st>
    <st c="45766">As organizations rely on third-party software – think about any
    off-the-shelf software product you deploy yourself – we can leverage the same
    process of vulnerability scanning, replication, and access control before that
    software gets deployed on the internal systems.</st> <st c="46035">Financial One
    ACME, for instance, could allow their third-party vendors for a Development Ticketing
    System to push new versions to that public endpoint.</st> <st c="46188">Once scanned
    and validated, it can be deployed to the internal K8s clusters that run all the</st>
    <st c="46281">development tooling.</st>
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: <st c="46301">The following illustration is a very high-level overview of how
    container registries integrate into the end-to-end delivery process that starts
    with pushing a new artifact (third-party or CI/CD) until that new artifact gets
    deployed to the</st> <st c="46542">target environments:</st>
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6: Container registries – the heartbeat of our platform](img/B31164_05_06.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: '<st c="46750">Figure 5.6: Container registries – the heartbeat of our platform</st>'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: <st c="46814">While there is a lot of in-depth information available from the
    different open source and commercial registry vendors, we want to give a quick
    overview of how registries fit into our platform engineering architecture, why
    certain concepts are important, and how we can best make container registries
    available to our end users as an easy to</st> <st c="47156">use self-service!</st>
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: <st c="47173">From container to artifact registry</st>
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="47209">Before diving into the</st> <st c="47233">process, we need to
    quickly highlight that container registries – while the name implies it – are
    not limited to container images.</st> <st c="47364">Most container registries
    typically support the OCI</st> *<st c="47416">[11]</st>* <st c="47420">image standard.</st>
    <st c="47437">Over the past years, container registries expanded to support non-container
    artifacts such as Helm Charts, zipped versions of Manifests, or Kustomize-based
    templates.</st> <st c="47604">That expansion also came with a name change for
    artifact registries as those tools manage artifacts in general and not just</st>
    <st c="47728">container images.</st>
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: <st c="47745">But that is not all.</st> <st c="47767">Artifact registries, open
    source, or</st> **<st c="47804">SaaS</st>** <st c="47808">(short for</st> **<st
    c="47820">Software as a Service</st>**<st c="47841">) services, often come</st>
    <st c="47865">with additional features, such as access control, regional replication,
    audit logging, policy enforcement, security scanning, notificatio</st><st c="48002">ns,
    and</st> <st c="48011">even more.</st>
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48021">Building and pushing artifacts to the registry</st>
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*<st c="48068">Uploading</st>* <st c="48078">(</st>*<st c="48080">pushing</st>*<st
    c="48087">) and</st> *<st c="48094">downloading</st>* <st c="48105">(</st>*<st
    c="48107">pulling</st>*<st c="48114">) images can be done</st> <st c="48136">using
    Docker (or other tools, such as Podman) commands.</st> <st c="48192">Before doing
    so, you need to authenticate against the registry (your private or public registry,
    such as Docker Hub).</st> <st c="48310">Once authenticated, it’s easy to push
    and pull, as shown in the</st> <st c="48374">following code:</st>'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: <st c="48389">Interacting with the container registry via docker commands</st>
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="48778">When building new images as part of the CI process, it’s important
    to follow best practices around image labels and metadata.</st> <st c="48905">The
    OCI therefore also has a list of suggested annotations</st> *<st c="48964">[12]</st>*
    <st c="48968">as part of their image spec that should be used, such as</st> `<st
    c="49026">created</st>`<st c="49033">,</st> `<st c="49035">authors</st>`<st c="49042">,</st>
    `<st c="49044">url</st>`<st c="49047">, and</st> `<st c="49053">documentation</st>`
    <st c="49066">(all prefixed</st> <st c="49081">with</st> `<st c="49086">org.opencontainers.image.</st>`<st
    c="49111">).</st>
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: <st c="49114">Next to an API interface, registries typically also provide</st>
    <st c="49174">a</st> **<st c="49177">user interface</st>** <st c="49191">(</st>**<st
    c="49193">UI</st>**<st c="49195">) that makes it easier to see what images are
    uploaded, how much space they consume, and – depending on the management features
    of the registry – also provides the configurational aspects of all those capabilities
    (e.g., creating projects, managing users, specifying policies, configu</st><st
    c="49480">ring</st> <st c="49486">webhooks, etc.).</st>
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: <st c="49502">Managing uploaded artifacts</st>
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="49530">Registries typically</st> <st c="49551">manage artifacts in projects.</st>
    <st c="49582">Projects can be private or public within the registry, meaning that
    artifacts in a public project can be accessed by anyone who can reach the registry,
    while private projects can only be reached by authorized users.</st> <st c="49798">That
    brings us to user management and access controls, which can be defined on a project
    level, and can also feed into access logs.</st> <st c="49930">Registries will
    create logs for every push and pull to have a good audit trail.</st> <st c="50010">The
    CNCF Harbor</st> <st c="50025">is a very popular container registry that also
    provides good documentation about all those features.</st> <st c="50127">Instead
    of going into detail here, we suggest you read up on the publicly available documentation</st>
    *<st c="50225">[13]</st>* <st c="50229">for all those features.</st> <st c="50254">What
    is important to remember is how to organize your images into projects and who
    you give access to.</st> <st c="50357">If we also want to allow external third
    parties to push their images to our registries, you can create specific users
    for them that allow them to upload to the respect</st><st c="50524">ive</st> <st
    c="50529">container projects!</st>
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: <st c="50548">Vulnerability scanning</st>
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[*<st c="50571">Chapter 7</st>*](B31164_07.xhtml#_idTextAnchor381) <st c="50581">focuses
    on security in more detail but it’s important to mention here that a central component,
    such as an artifact registry where every artifact has to pass through, is a perfect
    place for static vulnerability checking.</st> <st c="50803">Registries often provide
    out-of-the-box</st> <st c="50842">scanning capabilities or allow the integration
    of additional tools depending on the artifact type.</st> <st c="50942">Those tools
    would then be called either during the upload of a new image to get scanned as
    images arrive or on a schedule to make sure that images get scanned and rescanne</st><st
    c="51113">d on a</st> <st c="51121">continuous basis.</st>'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: <st c="51138">Subscribing to the life cycle events of an artifact in the registry</st>
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="51206">An artifact typically runs</st> <st c="51233">through different
    life cycle stages from the initial upload (push), security scan, replication to
    other repositories, and downloads (pull) until an artifact is deleted as it is
    no longer needed.</st> <st c="51429">Looking at Harbor as an example registry,
    we can also subscribe to all of those life cycle stages using webhooks.</st> <st
    c="51543">This enables a lot of interesting use cases, such as</st> <st c="51596">the
    following:</st>
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="51610">Security</st>**<st c="51619">: Notify security team on</st>
    <st c="51646">new vulnerabilities</st>'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="51665">Storage</st>**<st c="51673">: Clean up old images in case storage
    quotas</st> <st c="51719">are reached</st>'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="51730">Deploy</st>**<st c="51737">: New images uploaded from CI/CD
    or</st> <st c="51774">third-party vendors</st>'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="51793">Audit</st>**<st c="51799">: Keep track of who is pulling</st>
    <st c="51831">which artifacts</st>'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="51846">For reference, here is the full list of available life cycle events
    that can be used with webhooks:</st> `<st c="51947">artifact deleted</st>`<st
    c="51963">,</st> `<st c="51965">artifact pulled</st>`<st c="51980">,</st> `<st
    c="51982">artifact pushed</st>`<st c="51997">,</st> `<st c="51999">chart deleted</st>`<st
    c="52012">,</st> `<st c="52014">chart downloaded</st>`<st c="52030">,</st> `<st
    c="52032">chart uploaded</st>`<st c="52046">,</st> `<st c="52048">quota exceeded</st>`<st
    c="52062">,</st> `<st c="52064">quote near threshold</st>`<st c="52084">,</st>
    `<st c="52086">replication finished</st>`<st c="52106">,</st> `<st c="52108">scanning
    faile</st><st c="52122">d</st>`<st c="52124">, and</st> `<st c="52130">scanning
    finished</st>`<st c="52147">.</st>
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: <st c="52148">Retention and immutability</st>
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="52175">Repositories can grow really</st> <st c="52205">quickly – potentially</st>
    <st c="52226">leading to high storage costs if you don’t have a good cleanup strategy.</st>
    <st c="52300">This is why it is advisable to clean old images that are no longer
    needed.</st> <st c="52375">Some registries, therefore, provide out-of-the-box
    retention policies where you can define the images that match certain rules that
    will be retained and for how long.</st> <st c="52542">Once images fall out of
    the retention period, they will</st> <st c="52598">be deleted.</st>
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: <st c="52609">Another use case is that, by</st> <st c="52638">default, everyone
    can upload a new image with the same</st> <st c="52693">image tag, leaving the
    previous image version tagless.</st> <st c="52749">To prevent this, some registries
    provide immutability rules, which prevent tags from being</st> <st c="52840">removed
    from</st> <st c="52853">existing images!</st>
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: <st c="52869">Monitoring our registries</st>
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="52895">As registries are the heartbeat</st> <st c="52927">of our platform,
    we need to make sure they stay healthy.</st> <st c="52985">If registries stop
    processing push or pull requests, can’t execute vulnerability checks, and can’t
    replicate to other registries or send out notifications, then we have a problem!</st>
    <st c="53165">It means that critical updates won’t make it into the target environments
    fast enough.</st> <st c="53252">This could mean that a security vulnerability
    – while fixed through a new image – can’t be remediated as the new image can’t
    be delivered to the infected environment.</st> <st c="53419">It can also mean
    that we can’t ship new features in the time</st> <st c="53480">we promised.</st>
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: <st c="53492">To observe the health of our registries, we can monitor their
    various health metrics.</st> <st c="53579">In self-hosted registries, those metrics
    are often exposed via Prometheus or a custom REST API.</st> <st c="53675">In SaaS-hosted
    registries, those metrics are typically exposed via the vendor’s monitoring service
    API, such as</st> <st c="53787">AWS CloudWatch.</st>
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: <st c="53802">A good reference is Harbor, the CNCF project we mentioned earlier.</st>
    <st c="53870">It exposes lots of important metrics</st> <st c="53907">via</st>
    **<st c="53911">Prometheus</st>** *<st c="53921">[14]</st>*<st c="53926">, including
    the number of projects and repositories within a project, storage used, number
    of tasks executed and queued as well as performance metrics on the Harbor APIs
    (e.g., how long it takes to push or</st> <st c="54132">pull artifacts).</st>
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7: Monitoring our registry to identify potential problems early](img/B31164_05_07.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
- en: '<st c="54225">Figure 5.7: Monitoring our registry to identify potential problems
    early</st>'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: <st c="54297">Harbor</st> <st c="54304">is also an early adopter of OpenTelemetry,
    the CNCF project that initially introduced a standard for distributed tracing
    to the cloud-native community.</st> <st c="54457">Harbor provides</st> <st c="54473">an</st>
    **<st c="54476">OpenTelemetry exporter</st>** *<st c="54498">[15]</st>*<st c="54503">,
    generating traces with even more detailed information that can be used for both
    health monitoring as well</st> <st c="54611">as troubleshooting!</st>
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: <st c="54630">Registries – the central hub for all our artifacts</st>
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="54681">Container or artifact registries</st>** <st c="54714">are the
    central</st> <st c="54731">hub of all software that gets built and deployed.</st>
    <st c="54781">It</st> <st c="54783">provides a central way to manage, scan, distribute,
    and enforce access to all software before it gets deployed.</st> <st c="54896">It
    must, therefore, be treated as a highly critical component that must be observed
    to ensure availability and resiliency, and must be secure</st> <st c="55038">in
    itself!</st>'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: <st c="55048">Now that we have talked about the importance of our artifact registry,
    let’s continue to see how all of those components integrate</st> <st c="55179">with
    our</st> <st c="55189">end-to-release process.</st>
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: <st c="55212">Defining the release process and management</st>
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="55256">We have covered all of the building blocks it takes to build and
    deploy software.</st> <st c="55339">CI builds new container images or artifacts
    and pushes them to a registry.</st> <st c="55414">We know that registries have
    the power to scan for vulnerabilities, replicate to other registries, notify other
    tools about any activity, and enforce</st> <st c="55564">access control.</st>
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: <st c="55579">We also learned about GitOps and its pull approach of ensuring
    the desired deployment state (manifest files, Helm charts, Kustomize, etc.), as
    defined in a Git repository on the</st> <st c="55758">target environment.</st>
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: <st c="55777">What we are discussing now is how to define and enforce a full
    end-to-end release process and how to manage the life cycle of artifacts from
    the initial creation, initial deployment, promotion into other stages, and updates
    to new versions until a potential retirement when the software is no</st> <st
    c="56071">longer required!</st>
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: <st c="56087">The following illustration highlights that pushing a new image
    and replicating it to other registries is just one piece of the puzzle.</st> <st
    c="56223">The new version of the image also needs to be referenced in the deployment
    definition that is managed in mono or poly Git repositories.</st> <st c="56359">When
    having multiple stages (development, QA, production) and having multiple regions
    or clusters in a stage, we also need to promote that new version between each
    stage and</st> <st c="56533">each region/cluster!</st>
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8: Release process – from initial push to deploy and promote, from
    stage to stage](img/B31164_05_08.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
- en: '<st c="56764">Figure 5.8: Release process – from initial push to deploy and
    promote, from stage to stage</st>'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: <st c="56854">In the preceding figure,</st> `<st c="56880">values.yaml</st>`
    <st c="56891">represents the values for a Helm chart.</st> <st c="56932">It is,
    of course, simplified as there would be many more of the values that we discussed
    earlier (e.g., ownership, application context, log level,</st> `<st c="57079">git
    commit</st>` <st c="57089">hash, container</st> <st c="57106">registry, etc.).</st>
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: <st c="57122">Now, let’s have a look into how those deployment updates can be
    done, what should happen between the stages, what rollout options we have, and
    how to best keep track of a live inventory to know what is d</st><st c="57326">eployed
    where, when, and</st> <st c="57352">by whom!</st>
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: <st c="57360">Updating deployment to a new version</st>
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="57397">There are</st> <st c="57408">different ways that</st> `<st c="57428">values.yaml</st>`
    <st c="57439">can be updated for the initial development stage and how it then
    gets promoted to the next stages.</st> <st c="57539">Depending on the tooling
    and the level of maturity or processes that organizations have in place, this
    can be implemented in various ways.</st> <st c="57678">The options would be</st>
    <st c="57699">as follows:</st>
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="57710">Updated as part of the CI</st>**<st c="57736">: Once the CI
    publishes a new image to the registry, it could open a Pull Request to update
    the version in the repository for the</st> <st c="57867">first stage.</st>'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="57879">Updated through a registry webhook</st>**<st c="57914">: When
    a new image is uploaded to the registry, a webhook can be used to open a Pull
    Request.</st> <st c="58009">This approach is similar to having the CI do it.</st>
    <st c="58058">However, it decouples the process.</st> <st c="58093">This also
    works independently of which tool (e.g., CI) or creator (e.g., third-party vendor)
    pushes a new</st> <st c="58199">image version.</st>'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="58213">Scheduled updates</st>**<st c="58231">: Every hour, every day
    at 8 a.m., or any other schedule can be used to create a Pull Request with the
    latest version information from the registry.</st> <st c="58381">This provides
    continuous updates as well as batch changes on</st> <st c="58442">a schedule.</st>'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="58453">Manual Pull Requests</st>**<st c="58474">: As a precursor to
    automating the Pull Requests, or to enforce</st> <st c="58538">mandatory manual
    approval, the versio</st><st c="58576">n update can also be</st> <st c="58598">done
    manually.</st>'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="58612">Batching changes to combat dependencies</st>
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="58652">When dealing with simple applications or microservices that can
    be deployed independently, a single file update might be enough.</st> <st c="58782">Often,
    we have to combine multiple changes into a single change request.</st> <st c="58855">This
    is when changes have dependencies on changes in other components.</st> <st c="58926">An
    example for our Finance One ACME could be that the new version of the</st> `<st
    c="58999">fund-transfer</st>` <st c="59012">service also requires a new version
    of the</st> `<st c="59056">account-info</st>` <st c="59068">service, which requires
    an infrastructure change.</st> <st c="59119">You can see that it can easily become
    complex and it becomes harder to</st> <st c="59190">fully automate.</st>
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: <st c="59205">Those changes are hard to automate and often fall back to some
    release management team that resolves those</st> <st c="59313">dependencies manually.</st>
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: <st c="59335">There are other ways of solving this.</st> <st c="59374">One approach
    is using package managers, such as Helm, where a Helm chart can</st> <st c="59451">contain
    all configurations needed to deploy a full app.</st> <st c="59507">Helm charts</st>
    <st c="59518">can then also become artifacts uploaded to</st> <st c="59562">a
    registry.</st>
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: <st c="59573">Another approach that we have seen in an earlier section is using
    tools such as Crossplane, which</st> <st c="59672">provides IaC and application
    as code.</st> <st c="59710">The following is an example of using a composition
    for an application that contains several components, such as the business logic,
    a cache, an ingress, and</st> <st c="59867">a database:</st>
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="60232">As we can see, there are different ways to solve this application</st>
    <st c="60299">dependency problem.</st>
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: <st c="60318">Where this becomes trickier is when we have cross-application
    dependencies or dependencies to shared services that are independently deployed
    and updated.</st> <st c="60474">Following best practices to define good and clear
    APIs between those services and ensuring backward compatibility between major
    versions will make this easier.</st> <st c="60634">To learn more, have a look
    at existing literature or the work the CNCF</st> **<st c="60705">TAG App Delivery</st>**
    *<st c="60721">[16]</st>* <st c="60726">does on</st> <st c="60735">managing a</st><st
    c="60745">pplication and</st> <st c="60761">deployment dependencies.</st>
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: <st c="60785">Pre- and post-deployment checks</st>
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="60817">Once we have all our deployment configuration changes ready and
    committed to Git, we will be ready to deploy into the target cluster.</st> <st
    c="60952">As explained earlier in this chapter, we can either use a Push model
    (e.g., a delivery pipeline deploys our changes) or a Pull model (e.g., a GitOps
    operator synchronizes the latest version in Git to the</st> <st c="61156">target
    cluster).</st>
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: <st c="61172">With both approaches, we want to do some pre- and post-deployment
    checks to answer questions, such as</st> <st c="61275">the following:</st>
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="61289">Pre-deployment: Are we ready to deploy</st>** **<st c="61329">that
    change?</st>**'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="61341">Are all</st> <st c="61350">external</st> <st c="61358">dependencies
    ready?</st>
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="61378">Have all new images been successfully scanned and have</st> <st
    c="61434">no vulnerabilities?</st>
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="61453">Is there no ongoing maintenance or deployment quarantine in the</st>
    <st c="61518">target environment?</st>
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="61537">Has everyone that needs to approve a deployment</st> <st c="61586">approved
    it?</st>
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="61598">Post-deployment: Was the</st>** **<st c="61624">deployment
    successful?</st>**'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="61646">Are</st> <st c="61650">updated services available and successfully</st>
    <st c="61695">handling requests?</st>
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="61713">Does the system meet all functional and</st> <st c="61754">non-functional
    requirements?</st>
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="61782">Do all services meet their SLAs</st> <st c="61815">and</st> **<st
    c="61819">service-level</st>** **<st c="61833">objectives</st>** <st c="61843">(</st>**<st
    c="61845">SLOs</st>**<st c="61849">)?</st>
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="61852">Was everyone notified about</st> <st c="61881">the deployment?</st>
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="61896">Can the deployment be promoted to the</st> <st c="61935">next
    stage?</st>
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="61946">The pre-deployment checks can be implemented in various ways.</st>
    <st c="62009">Some can be implemented as part of the Pull Request flow (e.g.,
    Pull Requests cannot be merged when not all pre-deployment checks are fulfilled).</st>
    <st c="62155">They can also be validated within a deployment pipeline or implemented
    as a pre-sync hook in</st> <st c="62248">GitOps tools.</st>
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: <st c="62261">The post-deployment checks can be implemented after the deployment
    is done from the deployment pipeline as well as through post-sync hooks in</st>
    <st c="62404">GitOps tools.</st>
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: <st c="62417">One tool that enables pre- and post-deployment checks on Kubernetes
    independent of how the deployment is done is the CNCF project, Keptn.</st> **<st
    c="62556">Keptn</st>** <st c="62561">can stop Kubernetes deployments if the pre-deployment</st>
    <st c="62616">checks are not successful.</st> <st c="62643">Keptn can also execute
    post-deployment checks, such as executing tests, evaluating SLOs, or</st> <st
    c="62735">notifying teams.</st>
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: <st c="62751">To learn mo</st><st c="62763">re about Keptn, check the</st> <st
    c="62790">documentation</st> *<st c="62804">[17]</st>*<st c="62808">.</st>
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: <st c="62809">Deployment notifications</st>
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="62834">Once we are aware of a new</st> <st c="62861">deployment that
    has either succeeded or failed the post-deployment check, we can use this information
    and notify those people or tools that can benefit from this information.</st>
    <st c="63037">Whether using tools such as Keptn, the notifications of the GitOps
    tools, or doing this from the pipeline, here are some examples of where to send</st>
    <st c="63184">this information:</st>
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="63201">A chat</st>**<st c="63208">: Notify development teams in their
    Slack channel that their latest deployment is either ready or has failed</st>
    <st c="63318">the checks</st>'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="63328">A ticket</st>**<st c="63337">: Update the Pull Request or a
    Jira ticket with the information about the</st> <st c="63412">deployment status</st>'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="63429">A status page</st>**<st c="63443">: Keep a deployment status
    page with version, environment, and health information up</st> <st c="63529">to
    date</st>'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="63536">An observability backend</st>**<st c="63561">: Send a deployment
    event to your</st> <st c="63596">observability backend</st>'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="63617">Deployment events to observability backend</st>
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: <st c="63660">Observability tools not only track metrics, logs, and traces,
    but they can also track events such as</st> <st c="63761">deployment or</st> <st
    c="63775">configuration change events.</st> <st c="63805">Many observability tools
    (</st>**<st c="63831">Dynatrace</st>**<st c="63841">,</st> **<st c="63843">Datadog</st>**<st
    c="63850">,</st> **<st c="63852">New Relic</st>**<st c="63861">, etc.) can use
    those events and correlate them</st> <st c="63908">with a change in the app’s
    behavior.</st> <st c="63946">This can significantly improve incident response
    as it can</st> <st c="64004">be correlated with a specific</st> <st c="64035">deployment
    change.</st>
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: <st c="64053">Promotions between stages</st>
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="64079">Assuming we have a new</st> <st c="64102">release in development
    that successfully passed all post-deployment checks, how do those changes get
    promoted from development to QA and then into production?</st> <st c="64262">Does
    every change have to get promoted all the way into production or not?</st> <st
    c="64337">Do new releases get rolled out to all production environments at once
    or are there better strategies</st> <st c="64438">for it?</st>
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: <st c="64445">Here are some strategies that we have seen in organizations we
    have worked with in the past.</st> <st c="64539">For all those strategies, it
    means that a Pull Request is created to promote the new deployment definition
    from the Git location of the lower stage to the Git location of the</st> <st c="64714">higher
    stage:</st>
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="64727">Automated</st>**<st c="64737">: Often seen between development
    and QA environments.</st> <st c="64792">Every time the post-deployment checks
    are successful, it can trigger an automated Pull Request.</st> <st c="64888">This
    ensures that all development changes that have made it through the basic checks
    are quickly promoted to an environment used for more</st> <st c="65026">thorough
    testing.</st>'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="65043">Scheduled</st>**<st c="65053">: For instance, once a day, promote
    the latest version from development or QA into a special test environment (e.g.,
    a performance testing environment).</st> <st c="65207">This ensures that the team
    gets daily feedback on performance behavior changes of their updates from the
    previous</st> <st c="65321">24 hours.</st>'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="65330">Controlled/manual</st>**<st c="65348">: This typically happens
    the closer you get into production.</st> <st c="65410">Changes that made it successfully
    through QA and performance testing are marked to be safe to promote into higher-level
    environments.</st> <st c="65544">The actual promotion typically happens manually
    while the Pull Request itself might already be automatically created (but not
    auto-approved) from those versions that successfully made it through, for example,
    the performance</st> <st c="65769">testing phase!</st>'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="65783">Multi-stage in production</st>**<st c="65809">: When having
    multiple production clusters, it is common practice to roll out the changes into
    one cluster first.</st> <st c="65924">Then, validate if everything works and keep
    rolling out the rest.</st> <st c="65990">This first cluster could be for internal
    usage only or for users who know that they receive updates first (e.g., friends
    and family or members of an early access group).</st> <st c="66160">When deploying
    into multiple regions or multiple SaaS vendors, it is also advisable to define
    a</st> <st c="66255">clear sequence (e.g., start in Europe first and then roll
    out to</st> <st c="66321">the US).</st>'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '<st c="66329">Using multiple quality gated stages and a staged rollout strategy
    in our various production environments has</st> <st c="66438">one goal: reducing
    the risk of</st> <st c="66470">failed deployments!</st>'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: <st c="66489">Blue/green, canary, and feature flagging</st>
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="66530">While using multiple</st> <st c="66552">stages with pre- and</st>
    <st c="66572">post-deployment checks already</st> <st c="66604">reduces risk,
    there is more we can do for each individual deployment:</st> **<st c="66674">progressive
    delivery</st>** <st c="66694">strategies, such as</st> <st c="66715">blue/green,
    canary, or feature flags.</st> <st c="66753">We have already discussed what those
    things are in more detail in the</st> *<st c="66823">Continuous deployment – decoupling
    deployments from</st>* *<st c="66875">releases</st>* <st c="66883">section.</st>
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: <st c="66892">In the context of the release process, this is an important topic,
    as there are several</st> <st c="66981">open questions:</st>
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: <st c="66996">Who is receiving the new version?</st> <st c="67031">Is it a certain
    percentage of users or a</st> <st c="67072">specific group?</st>
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="67087">How do you measure and validate whether the rollout</st> <st c="67140">was
    successful?</st>
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="67155">Who is responsible for making the roll-forward or</st> <st c="67206">rollback
    decision?</st>
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="67224">Just like validating a deployment through post-deployment checks,
    we can do the same with progressive delivery.</st> <st c="67337">Open</st> <st
    c="67342">source tools, such</st> <st c="67361">as</st> **<st c="67364">Argo Rollouts</st>**
    *<st c="67377">[18]</st>* <st c="67382">and</st> **<st c="67387">Flagger</st>**
    *<st c="67394">[19]</st>*<st c="67399">, or commercial tools provide automated
    analysis between the progressive rollout phases.</st> <st c="67488">This usually
    works by querying data from the observability platform; for example, Prometheus,
    to validate if the new version doesn’t differ from the existing version for key
    service-level indicators, such as request failure rate, response time, memory,
    and CPU consumption.</st> <st c="67762">For more details, it’s recommended to
    check the documentation of the</st> <st c="67831">respective tooling that is used
    for</st> <st c="67867">progressive rollouts.</st>
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: <st c="67888">Release inventory</st>
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="67906">The value proposition of automating the deployment and release
    process is that engineering teams can release updates more frequently into the
    various target environments.</st> <st c="68078">The easier we make this automation
    available through our platform, the more teams will end up deploying</st> <st
    c="68182">more releases.</st>
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="68196">Release inventories allow</st> <st c="68223">us to keep track
    of which versions are currently released in which environments by which teams.</st>
    <st c="68319">From a platform engineering perspective, we can enforce a consistent
    definition of exactly that information: version, environment, and ownership.</st>
    <st c="68465">If everything is configured as code, it means that this information
    is available in Git.</st> <st c="68554">When using Kubernetes as the target platform,
    we can also add this information as annotations on our Kubernetes objects (Deployments,</st>
    <st c="68688">Pods, Ingress).</st>'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: <st c="68703">In previous examples, we already highlighted some of the standard
    K8s annotations.</st> <st c="68787">Here is a snippet of a</st> <st c="68810">deployment
    definition:</st>
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="69083">With this information in K8s, we</st> <st c="69117">can simply
    query the K8s API of each K8s cluster to get an overview of all deployments by
    those labels.</st> <st c="69221">We could then get an overview</st> <st c="69251">like
    this:</st>
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '| **<st c="69261">Cluster</st>** | **<st c="69269">Release</st>** | **<st c="69277">Part-Of</st>**
    | **<st c="69285">Owner</st>** |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
- en: '| `<st c="69291">dev</st>` | `<st c="69295">fund-transfer:1.5.1</st>` | `<st
    c="69315">backend</st>` | `<st c="69323">team-at</st>` |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
- en: '| `<st c="69331">dev</st>` | `<st c="69335">account-info:1.17.2</st>` | `<st
    c="69355">backend</st>` | `<st c="69363">team-ae</st>` |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
- en: '| `<st c="69371">qa</st>` | `<st c="69374">fund-transfer:1.4.9</st>` | `<st
    c="69394">backend</st>` | `<st c="69402">team-at</st>` |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
- en: '| `<st c="69410">qa</st>` | `<st c="69413">account-info:1.17.1</st>` | `<st
    c="69433">backend</st>` | `<st c="69441">team-ae</st>` |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
- en: '| `<st c="69449">prod-eu</st>` | `<st c="69457">fund-transfer:1.4.7</st>` |
    `<st c="69477">backend-tenant-1</st>` | `<st c="69494">team-de</st>` |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
- en: '| `<st c="69502">prod-eu</st>` | `<st c="69510">account-info:1.17.1</st>` |
    `<st c="69530">backend-tenant-1</st>` | `<st c="69547">team-de</st>` |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
- en: '| `<st c="69555">prod-us</st>` | `<st c="69563">fund-transfer:1.4.6</st>` |
    `<st c="69583">backend-tenant-2</st>` | `<st c="69600">team-us</st>` |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
- en: '| `<st c="69608">prod-us</st>` | `<st c="69616">account-info:1.17.0</st>` |
    `<st c="69636">backend-tenant-2</st>` | `<st c="69653">team-us</st>` |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
- en: '<st c="69661">Table 5.2: Release inventory based on metadata on deployed artifacts</st>'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: <st c="69730">Observability tools often provide this feature as they already
    pull the K8s APIs to observe cluster health, events, and objects including</st>
    <st c="69869">this metadata.</st>
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: <st c="69883">Another approach is to parse this information directly from Git.</st>
    <st c="69949">Tools such as Backstage do exactly this and with that information,
    provide an easy-to-search</st> <st c="70042">software catalog.</st>
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: <st c="70059">Release management – from launch to mission control</st>
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="70111">For many organizations, the release</st> <st c="70148">process
    ends with the actual deployment of a new release into production when operations
    teams take over all aspects of keeping the software running.</st> <st c="70298">These
    two phases are also often called</st> **<st c="70337">launch</st>** <st c="70343">and</st>
    **<st c="70348">mission control</st>**<st c="70363">, borrowed from how NASA manages
    their</st> <st c="70402">space missions.</st>
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: <st c="70417">Many years ago, the DevOps movement was fueled by prominent examples,
    such as the AWS platform, which promoted the</st> *<st c="70533">you built it,
    you run it!</st>* <st c="70558">approach.</st> <st c="70569">This meant that the
    responsibility of developers didn’t end with building an artifact and then throwing
    it over the so-called “Ops Wall.” Developers had to take full responsibility and
    ownership of their code from development all the way into production.</st> <st
    c="70824">They had to handle incidents and updates until their code eventually</st>
    <st c="70893">got retired.</st>
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: <st c="70905">When looking at today’s complex environments, it is very hard
    to own every aspect (code and infrastructure).</st> <st c="71015">With platform
    engineering, we try to bring the promise of DevOps back by providing self-services
    to reduce the complexity and giving teams the chance to own more of the end-to-end
    life cycle of</st> <st c="71209">their software.</st>
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: <st c="71224">When building future platforms, our focus must be to provide self-services
    to orchestrate the whole life cycle of an artifact.</st> <st c="71352">In fact,
    orchestrating the whole life cycle of an application as a single artifact is typically
    just a fraction of an application.</st> **<st c="71483">Life cycle orchestration</st>**
    <st c="71507">includes</st> <st c="71516">building, deploying, and releasing,
    but also all use cases needed for production support.</st> <st c="71607">This
    includes resiliency through scaling, incident management, access to the right
    observability data for troubleshooting, and automated delivery to push fixes</st>
    <st c="71767">and updates.</st>
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: <st c="71779">In the next section, we dive into life cycle orchestration, how
    to increase transparency by making our life cycles observable, and how an event-driven
    model can help reduce the complexity of pipeline and</st> <st c="71984">orchestration
    code</st><st c="72002">.</st>
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: <st c="72003">Achieving sustainable CI/CD for DevOps – application life cycle
    orchestration</st>
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="72081">From building, to publishing, to promoting, to deploying, to releasing,
    to fixing.</st> <st c="72165">That’s a lot of tasks that have to be automated
    to orchestrate the whole life cycle of our artifacts and applications.</st> <st
    c="72284">The challenge that we have seen with teams that take end-to-end responsibility
    is that the majority of those scripts deal with</st> <st c="72411">the following:</st>
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: <st c="72425">Triggering a certain (</st><st c="72448">hardcoded) tool</st>
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="72464">Doing so in a certain (</st><st c="72488">hardcoded) environment</st>
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="72511">Then, waiting for the tool to complete</st> <st c="72551">its
    job</st>
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="72558">Parsing the specific</st> <st c="72580">result format</st>
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="72593">Based on the parsing result, deciding what to do</st> <st c="72643">next
    (hardcoded)</st>
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="72659">That script code then often gets copied and pasted between different
    projects, slightly modified, and adapted.</st> <st c="72771">Fixes or adaptations
    to a single script are hard to promote to all the other variations as there is
    no easy tracking of all those scripts.</st> <st c="72910">This leads to high effort
    in maintenance, makes it inflexible to change the process or tools used in those
    scripts, and takes away time from engineers doing their</st> <st c="73073">regular
    jobs.</st>
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: <st c="73086">There is nothing wrong with using the power of pipeline scripting.</st>
    <st c="73154">Many of the pipeline automation tools also provide abstractions,
    code reuse through libraries, and other features to reduce code duplication and
    increase reusability.</st> <st c="73321">So, depending on the tools you use, make
    sure to follow those</st> <st c="73383">best practices!</st>
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: <st c="73398">There exists a different approach that fits in the event-driven
    nature of modern cloud-native applications and</st> <st c="73509">cloud-native
    environments:</st> **<st c="73537">life cycle</st>** **<st c="73548">event-driven
    orchestration</st>**<st c="73574">!</st>
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: <st c="73575">In the next section, we will dive into this approach as it provides
    a lot of flexibility and centralized observability and will lead to a more sustainable
    way to automate CI/CD</st> <st c="73752">and operation</st><st c="73765">s!</st>
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: <st c="73768">Artifact life cycle event observability</st>
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '<st c="73808">The basics for event-driven</st> <st c="73837">orchestration
    are life cycle events, such as those discussed in</st> [*<st c="73901">Chapter
    3</st>*](B31164_03.xhtml#_idTextAnchor133)<st c="73910">. It’s about observing
    the full life cycle of an artifact: from the initial Git commit of code, the building
    and pushing of container images to a registry, to the releasing into every stage
    until the artifact gets updated or retired, including all the steps</st> <st c="74168">in
    between.</st>'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: <st c="74179">So far in this chapter, we discussed many of those life cycle
    steps and also highlighted how to extract some of those life</st> <st c="74303">cycle
    events:</st>
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="74316">CI/CD pipelines</st>** <st c="74332">can emit events when they</st>
    *<st c="74359">build</st>* <st c="74364">or</st> *<st c="74368">deploy</st>*'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="74374">Artifact registries</st>** <st c="74394">provide webhooks when
    containers get</st> *<st c="74432">pushed</st>*<st c="74438">,</st> *<st c="74440">pulled</st>*<st
    c="74446">,</st> <st c="74448">or</st> *<st c="74451">scanned</st>*'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="74499">PreSync</st>`<st c="74506">,</st> `<st c="74508">Sync</st>`<st
    c="74512">,</st> `<st c="74514">PostSync</st>`<st c="74522">,</st> <st c="74524">and</st>
    `<st c="74528">SyncFailed</st>`'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="74538">Git</st>** <st c="74542">workflows can be used to send events
    when code</st> *<st c="74590">changes</st>* <st c="74597">or</st> <st c="74601">gets</st>
    *<st c="74606">promoted</st>*'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="74614">Tools such as</st> **<st c="74629">Keptn</st>** <st c="74634">provide</st>
    <st c="74642">pre- and post-deployment events for individual deployments as well
    as</st> <st c="74713">complex applications</st>
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="74733">Container</st>** <st c="74743">platforms, such as Kubernetes,
    expose events about</st> *<st c="74795">deployment health</st>*'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="74812">CDEvents</st>** *<st c="74821">[20]</st>*<st c="74826">, a
    project</st> <st c="74837">from the Continuous Delivery Foundation, extends the
    CloudEvents specification, which is already a graduated CNCF project with wide
    ecosystem adoption.</st> <st c="74990">CDEvents was initially started to standardize
    events for all life cycle phases for building, testing, and deploying.</st> <st
    c="75107">It has recently expanded to also cover the life cycle phases of deployments
    in operations such as</st> <st c="75205">production incidents.</st>'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: <st c="75226">The idea is that tools that adhere to those event standards are
    easier to integrate with all other tools in the ecosystem.</st> <st c="75350">Instead
    of having to manage and maintain hard code integrations between tools, those tools
    communicate via open standard APIs and Events.</st> <st c="75488">Tools can emit
    those events; for example, Jenkins has created a new artifact and other tools
    can subscribe to them (e.g., GitLab can subscribe and trigger a workflow to scan
    and publish the container).</st> <st c="75690">That life cycle phase would also
    generate a</st> <st c="75734">standardized event.</st>
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: <st c="75753">All events have a minimum set of properties to identify the phase,
    the artifact, and the tool that was involved, as well as the additional properties
    that are mandatory (e.g., initial</st> `<st c="75938">git commit</st>`<st c="75948">,
    version, environment, and</st> <st c="75976">responsible team).</st>
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: <st c="75994">When all those events are sent to a central event hub, it enables
    a fully event-driven orchestration of the life cycle</st> <st c="76114">of artifacts.</st>
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: <st c="76127">For example, if you decide to notify development teams about new
    deployments in their Slack, you can easily subscribe to the deployment events
    and forward that event to Slack.</st> <st c="76304">If you change the chat tool
    to something else, simply change that event subscription.</st> <st c="76390">No
    need to find all code in all pipelines that currently send notifications as this
    happens through a simple event</st> <st c="76505">subscription change.</st>
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: <st c="76525">To sum it up, using a well-defined set of life cycle events across
    all tools and phases enables many capabilities in our platform</st> <st c="76656">engineering
    approach:</st>
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="76677">Traceability</st>**<st c="76690">: We can trace every artifact
    from its initial creation until its end of the life cycle.</st> <st c="76780">This
    allows us to see where artifacts are (release inventory), where they are stuck,
    and who is responsible for letting an artifact into a</st> <st c="76919">certain
    environment.</st>'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="76939">Measurement</st>**<st c="76951">: We can measure how many artifacts
    flow through the life cycle and how long it takes.</st> <st c="77039">This is
    the basis for reporting the DORA</st> <st c="77080">Efficiency metrics!</st>'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="77099">Interoperability</st>**<st c="77116">: We can easily integrate
    new tools or replace them if they all adhere to the same standards (e.g., switching
    from one notification tool to another is just a matter of changing an</st> <st
    c="77297">event subscription).</st>'
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="77317">Flexibility</st>**<st c="77329">: Like</st> <st c="77336">replacing
    tools, we can easily adapt our delivery processes by having additional tools add
    work on certain events (e.g., adding an additional mandatory security scan for
    deployments in certain environments can be done by an event subscription of a
    security</st> <st c="77594">scan tool).</st>'
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="77605">Let’s have a quick overview of the building blocks of such an
    event-driven system as compared to having to create and maintain lengthy complex
    automation scripts to include a lot of</st> <st c="77788">process</st> <st c="77796">logic.</st>
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: <st c="77802">Working with events</st>
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="77822">The first step is that the tools we</st> <st c="77859">use along
    the artifact life cycle emit those events.</st> <st c="77912">Looking at</st>
    <st c="77923">CDEvents (which extends CloudEvents), there are several tools in
    the ecosystem that already provide out-of-the-box support for them, such as Jenkins,
    Tekton, Keptn, Tracetest, Spinnaker,</st> <st c="78110">and others.</st>
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: <st c="78121">Those tools that are not integrated yet can easily emit those
    events using the available SDKs.</st> <st c="78217">The following is a code example
    using Python, which creates a Pipeline Run Finished Event (</st>`<st c="78308">cdevents.new_pipelinerun_finished</st>`<st
    c="78342">_event) with metadata, identifying the pipeline, artifact,</st> <st
    c="78402">or owner:</st>
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <st c="79161">The preceding Python code example creates a new</st> `<st c="79210">pipelinerun_finished_event</st>`<st
    c="79236">, which indicates the finished execution of a pipeline.</st> <st c="79292">The
    additional context data indicates which pipeline and when it was built, and it
    allows us to provide additional metadata, such as ownership, artifact, or which
    application this pipeline</st> <st c="79481">belongs to.</st>
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: <st c="79492">Whether you use the</st> <st c="79513">CDEvents standard proposal
    or send your own life cycle events, it is a</st> <st c="79584">good idea to base
    it on CloudEvents as that project already has a lot of industry integrations that
    can either emit or consume CloudEvents, with Knative as</st> <st c="79740">on</st><st
    c="79742">e example!</st>
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: <st c="79753">Subscribing to events to orchestrate</st>
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="79790">Once all our tools are</st> <st c="79814">emitting standardized
    events, we can more easily orchestrate our artifact life cycle process by having
    tools we want to participate in the process subscribe to those events they want
    to</st> <st c="80000">act upon.</st>
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: <st c="80009">We discussed the same concept earlier in this chapter when we
    talked about using the webhook capabilities of tools such as Argo CD or Harbor
    to act upon when a new artifact is available or when a new deployment was</st>
    <st c="80225">successfully synced.</st>
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: <st c="80245">The benefit of a standard event model is that tools no longer
    need to subscribe to a specific webhook of a specific tool (e.g., Argo CD webhooks).</st>
    <st c="80393">Instead, we can subscribe to a central event hub that receives all
    standardized life cycle events from all involved tools, as</st> <st c="80519">visualized
    here:</st>
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9: All tools emit and subscribe to standardized life cycle events](img/B31164_05_09.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_IMG
- en: '<st c="80607">Figure 5.9: All tools emit and subscribe to standardized life
    cycle events</st>'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: <st c="80681">Having everything</st> <st c="80700">based on an event standard
    eliminates the need for point-to-point tool integrations or hardcoded tool integrations
    in pipeline scripts.</st> <st c="80836">As an example, instead of sending a notification
    to Slack or Mattermost from every pipeline that deploys a new build, we can simply
    subscribe to the</st> `<st c="80985">dev.cdevents.service.published</st>` <st
    c="81015">event and have the details about that service forwarded to our</st>
    <st c="81079">chat tool.</st>
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: <st c="81089">If that tool is Slack today, and at a later time, we decide to
    move to another tool, we simply change</st> <st c="81192">that subscription.</st>
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: <st c="81210">Another use case is to have different tools as part of the process
    active in different environments.</st> <st c="81312">As those standardized events
    contain a lot of metadata (e.g., which environment a service gets deployed into),
    we can subscribe to events for a certain environment.</st> <st c="81477">The following
    is a table that shows</st> <st c="81513">some examples:</st>
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '| **<st c="81527">Source Tool</st>** | **<st c="81539">Event Properties</st>**
    | **<st c="81556">Subscribed By</st>** | **<st c="81570">Action</st>** |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
- en: '| <st c="81577">Argo</st> | `<st c="81590">service.deployed</st>``<st c="81621">staging</st>``<st
    c="81640">fund-transfer:2.3</st>``<st c="81666">team-backend</st>` | <st c="81678">K6
    when</st> `<st c="81687">environment == "</st>``<st c="81703">staging"</st>` |
    <st c="81712">Execute</st> <st c="81721">simple load</st> |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
- en: '| <st c="81732">.</st> |  | <st c="81733">Slack when</st> `<st c="81744">Owner
    ==</st>` `<st c="81754">team-backend</st>` | <st c="81766">Send a notification
    to the team’s backend</st> <st c="81809">Slack channel</st> |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
- en: '|  |  | <st c="81822">OTel Collector</st> | <st c="81837">Collecting all events
    to forward to the</st> <st c="81878">observability backend</st> |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
- en: '<st c="81899">Table 5.3: The same event from Argo can be subscribed by various
    tools for various actions</st>'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: <st c="81990">Some tools already provide</st> <st c="82018">out-of-the-box support
    for CloudEvents where they can either subscribe to a CloudEvent source or provide
    an API endpoint that can consume CloudEvents.</st> <st c="82169">For others, it
    will be necessary to build a slim integration layer where one subscribes to those
    events and then forwards them to the target tool.</st> <st c="82316">It’s also
    possible to implement this using event bus systems that</st> <st c="82382">support
    CloudEvents.</st>
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: <st c="82402">Analyzing events</st>
  id: totrans-360
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="82419">Now that we know how events are</st> <st c="82452">sent and how
    they can be subscribed by other tools, we can discuss how we can leverage them
    to analyze how well our life cycle processes</st> <st c="82589">actually work.</st>
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: <st c="82603">Well-defined</st> <st c="82617">events that have a timestamp,
    a life cycle phase definition (</st>`<st c="82678">=event type</st>`<st c="82690">),
    and some context (artifact, environment, owner) can be analyzed to answer questions,
    such as</st> <st c="82787">the following:</st>
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: <st c="82801">How many deployments happen in a</st> <st c="82835">given environment?</st>
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="82853">How many deployments are done for a particular application</st>
    <st c="82913">or tenant?</st>
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="82923">How active is a team based on the</st> <st c="82958">ownership
    information?</st>
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="82980">How many artifacts make it from development</st> <st c="83025">to
    production?</st>
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="83039">Which artifacts take a long time and where are they blocked on
    the way</st> <st c="83111">to production?</st>
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="83125">Are there certain artifacts that cause more security vulnerabilities
    or production problems</st> <st c="83218">than others?</st>
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="83230">Which tools involved in the process are consuming most of</st>
    <st c="83289">the time?</st>
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="83298">Are there tools that are most often the reason for a slow</st>
    <st c="83357">end-to-end process?</st>
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="83376">There are probably many more questions that we can all answer
    by analyzing</st> <st c="83452">those events.</st>
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: <st c="83465">How can we analyze them?</st> <st c="83491">You can stream all
    those events to a database or your observability platform.</st> <st c="83569">In</st>
    *<st c="83572">Figure 5</st>**<st c="83580">.9</st>*<st c="83582">, we included
    OpenTelemetry, as events can just be ingested and forwarded to your observability
    backend and</st> <st c="83690">analyzed there.</st>
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: <st c="83705">Bringing transparency into CI/CD through event observability</st>
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: <st c="83766">Having all events in a single spot with all that metadata and
    clearly defined types that represent the life cycle stages allows us to get a
    lot of transparency into the integration, delivery, and operations processes.</st>
    <st c="83985">This data allows us to optimize our processes, which will result
    in</st> <st c="84053">more sustainability.</st>
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: <st c="84073">Building automation for CI/CD and operations typically results
    in a lot of customized code that needs to be maintained across all projects it
    was copied to.</st> <st c="84231">What we learned in this section is that moving
    to an event-driven approach for artifact life cycle management can address a lot
    of the complexity problems that are otherwise hidden in custom scripts or hardcoded</st>
    <st c="84443">tool-to-tool integrations.</st>
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: <st c="84469">In</st> [*<st c="84473">Chapter 9</st>*](B31164_09.xhtml#_idTextAnchor479)<st
    c="84482">, we will cover additional aspects of how to reduce technical debt in
    all our platform components by making the right</st> <st c="84600">architectural
    decision</st><st c="84622">s.</st>
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: <st c="84625">IDPs – the automation Kraken in the platform</st>
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="84670">In this chapter so</st> <st c="84689">far, we have learned a lot
    about the basic building blocks to automate the end-to-end build, delivery, deployment,
    and release process.</st> <st c="84826">We have talked about new approaches to
    deploying the desired state with GitOps where the desired state is pulled from
    within the target environment versus pushed from an external tool, such as</st>
    <st c="85019">a pipeline.</st>
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: <st c="85030">We discussed the end-to-end release processes on what happens
    from the first commit until releasing software to the end users.</st> <st c="85158">Finally,
    we talked about applying an event-driven approach to orchestrating our artifact
    life cycle, which provides a centralized event hub to make everything that happens
    more transparent and observable.</st> <st c="85363">It also gives us more flexibility
    as we can remove the complexity of tool integrations and process definitions from
    pipeline or bash scripts into event subscriptions and</st> <st c="85533">event-driven
    workflows.</st>
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: <st c="85556">In this last section, we want to have a brief look into which
    of those concepts can be implemented with existing tools that you may already
    have, which new approaches exist to solve some of the challenges we discussed,
    and where you may want to look as some new tools have emerged over the last years
    – both open source and commercial – that take some of that work off</st> <st c="85926">our
    shoulders.</st>
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: <st c="85940">We will do so by putting ourselves into the shoes of our users,
    our developers, or our development teams, as they are the ones who will need to
    apply to a new way</st> <st c="86104">of worki</st><st c="86112">ng.</st>
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: <st c="86116">Providing templates as Golden Paths for easier starts!</st>
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="86171">We try to enforce a lot of new practices, such as ensuring the
    right metadata on the deployments (version, application context, ownership, etc.)
    or having security vulnerability checks as part of every build pipeline.</st>
    <st c="86390">In the platform engineering community, those are also referred to</st>
    <st c="86456">as</st> *<st c="86459">Golden Paths</st>*<st c="86471">. To ensure
    that those practices can easily be followed by teams that start new projects,
    we need to make them easily accessible</st> <st c="86600">and adoptable!</st>
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: <st c="86614">The easiest and most impactful approach is to provide software
    or repository templates.</st> <st c="86703">These are templates in the forms of
    manifest files, pipelines, automation scripts, and so on that developers can find
    in a template repository, which they can then take and apply to</st> <st c="86885">their
    projects.</st>
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: <st c="86900">While this approach works, it doesn’t force engineers to really
    use those templates; plus, it’s an additional manual step that can also lead</st>
    <st c="87042">to mistakes.</st>
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: <st c="87054">One way to make this easier and automated is to either provide
    a CLI or a UI to initialize new or update existing git repositories with best-practice
    templates.</st> <st c="87216">This can either be custom-built or we can look into
    existing solutions, such as</st> **<st c="87296">Backstage</st>**<st c="87305">,
    a CNCF</st> <st c="87313">project that was donated</st> <st c="87339">by Spotify.</st>
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: <st c="87350">Backstage’s</st> **<st c="87363">Software Templates</st>** <st
    c="87381">feature</st> <st c="87390">was built to make Golden Path templates the
    entry point for every developer’s journey as they are building new software components.</st>
    <st c="87522">Templates can be defined by subject matter experts who know how
    to properly configure pipelines, enable automated testing and deployment, and
    enforce</st> <st c="87672">security checks.</st>
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: <st c="87688">Once templates are defined, they are available through an easy-to-use
    wizard that prompts the developer for some critical input data, such as what type
    of service they implement, ownership information, the requirements on observability
    or security, and so on – all of that input will then impact the creation of a
    new repository or the update of an existing one with the files and configurations
    from</st> <st c="88090">the template.</st>
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: <st c="88103">To learn more about templating, check out the detailed documentation
    and examples on the</st> **<st c="88193">Backstage</st>** **<st c="88203">website</st>**
    *<st c="88210">[21]</st>*<st c="88215">.</st>
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: <st c="88216">Abstractions through Crossplane</st>
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="88248">Another simplification and way to enforce best practices is to
    provide an additional layer of abstraction when defining your</st> <st c="88374">application
    or services.</st> <st c="88399">In K8s, we have to define our deployments, services,
    Ingress,</st> **<st c="88461">Persistent Volume Claims</st>** <st c="88485">(</st>**<st
    c="88487">PVCs</st>**<st c="88491">), and even more when we need to deploy dependent
    services, such as a database, a cache, or any other required</st> <st c="88603">software
    components.</st>
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: <st c="88623">In the earlier section on IaC, we introduced the CNCF project,
    Crossplane.</st> **<st c="88699">Crossplane</st>** <st c="88709">orchestrates</st>
    <st c="88723">both infrastructure and application deployment through code and
    provides a concept of</st> <st c="88809">so-called</st> **<st c="88819">composites</st>**<st
    c="88829">. We will not spend more time here on this as we already provided several
    examples earlier on how to use composites to provision a performance test environment
    as well as one to define a financial backend type of application where the developer
    only needs to specify the versions of services that will then be deployed together.</st>
    <st c="89158">The following are just the first two lines of that composite definition.</st>
    <st c="89231">See the rest in the</st> *<st c="89251">Crossplane – IaC for platform
    and</st>* *<st c="89285">applications</st>* <st c="89297">section:</st>
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <st c="89379">When providing abstractions, it is important to make them known
    to developers.</st> <st c="89459">This can be done by providing educational material
    or simply providing them through the same templating approach, as discussed earlier,
    using a tool such</st> <st c="89613">as B</st><st c="89617">ackstage.</st>
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
- en: <st c="89627">Everything Git-flow-driven</st>
  id: totrans-395
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="89654">Well, it should be no surprise that Git</st> <st c="89694">is
    our source of truth – we have established this early in the chapter.</st> <st
    c="89767">However, most Git solutions provide additional capabilities that we
    can use to also enforce standards and processes (e.g., GitHub workflows).</st>
    <st c="89909">Workflows can be triggered on a schedule or as part of many different
    events that can happen in the end to end flow of a Git driven process (e.g.,</st>
    *<st c="90056">push</st>*<st c="90060">,</st> *<st c="90062">pull</st>* *<st c="90067">requests</st>*<st
    c="90075">,</st> *<st c="90077">release</st>*<st c="90084">).</st>
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: <st c="90087">This allows us to enforce our standards as well before artifacts
    get built and pushed; for instance, validating mandatory metadata files we expect
    for every deployment (e.g., ownership information).</st> <st c="90287">We can
    also use this to automatically do code scans and generate scorecards or we can
    use it to validate that all dependencies are safe and don’t have any known</st>
    <st c="90448">security vulnerabilities.</st>
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: <st c="90473">Depending on the Git tool that is chosen, you will typically find
    a marketplace or best practice catalog of workflows and actions that can and should
    be executed for certain types of projects.</st> <st c="90667">Make sure you make
    yourself familiar with all that is possible based on your</st> <st c="90744">to</st><st
    c="90746">ol choice.</st>
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: <st c="90757">Software catalog</st>
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="90774">Once we enable developers to build more software that follows
    all our processes, we will hopefully see the result in a lot of new services being
    developed.</st> <st c="90931">Those are services that other developers also need
    to know about so that we avoid the problem of development teams building duplicated
    services and encouraging developers to build more capabilities on top of existing
    services</st> <st c="91157">and APIs.</st>
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: <st c="91166">A</st> **<st c="91169">software catalog</st>** <st c="91185">that</st>
    <st c="91190">gives an overview of all available services and APIs and ideally
    also provides some documentation is what we are</st> <st c="91304">aiming for.</st>
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: <st c="91315">As</st> <st c="91319">Git is the source of truth, we can extract
    most of this information straight from Git.</st> <st c="91406">Depending on which
    Git solution we choose, a software catalog might already be part of the offering.</st>
    <st c="91507">However, there are more services and APIs that are part of the software
    catalog that an organization owns and can develop against (e.g., external APIs
    or third-party software</st> <st c="91682">deployed on-premises).</st>
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: <st c="91704">Backstage, the tool that</st> <st c="91729">also provides the
    templating feature discussed earlier, also comes with a software catalog.</st>
    <st c="91822">It gets its data from parsing specific metadata files in Git repositories
    but also allows external data sources to provide entity information.</st> <st
    c="91965">The following illustration is taken from the Backstage blog and shows
    what Spotify’s software catalog in Backstage</st> <st c="92080">looks like:</st>
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10: Software catalog extracted from entity metadata in Git](img/B31164_05_10.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
- en: '<st c="93405">Figure 5.10: Software catalog extracted from entity metadata
    in Git</st>'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: <st c="93472">As we can see from the preceding screenshot, software catalogs
    are a powerful way to understand what software components are available within
    an organization, what type of software it is, who owns it, where to find the source
    code, and</st> <st c="93709">additional information.</st>
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: <st c="93732">Tools such as Backstage</st> <st c="93756">are not the full IDP;
    however, they represent a portal – a graphical UI – into all the data relevant
    for the majority of the users of</st> <st c="93891">an IDP.</st>
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: <st c="93898">While Backstage is one option, there are many other options out
    there.</st> <st c="93970">Everything from homegrown to other open source or commercial
    tools, such as Cortex, Humanitec, Por</st><st c="94068">t,</st> <st c="94072">or
    Kratix.</st>
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: <st c="94082">Summary</st>
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="94090">In this chapter, we learned a lot about the underlying automation
    and processes to get an artifact from the initial creation all the way into production.</st>
    <st c="94245">For modern platforms, a GitOps approach where we pull versus push
    changes should be a key consideration.</st> <st c="94350">We learned about Git
    as the source of truth and artifacts (container or OCI-compliant images) as of
    our business logic into our</st> <st c="94478">target environments.</st>
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: <st c="94498">As an organization grows, it’s important to enforce good processes
    and best practices.</st> <st c="94586">For enforcement to work, it needs to be
    easily accessible and should be available end-to-end as a self-service to not
    impact the flow of creativity</st> <st c="94734">of engineers.</st>
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="94747">This also brings us to the topic of the next chapter.</st> <st
    c="94802">In</st> [*<st c="94805">Chapter 6</st>*](B31164_06.xhtml#_idTextAnchor341)<st
    c="94814">, we dive into the importance of focusing on self-service capabilities
    that really address the needs of our target users: our developers.</st> <st c="94952">We
    will discuss how to bring those Golden Paths’ best practices into our platform
    to significantly improve the way developers can get their</st> <st c="95092">work
    done.</st>'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: <st c="95102">Further reading</st>
  id: totrans-413
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="95118">[1] OpenFeature –</st> [<st c="95137">https://openfeature.dev/</st>](https://openfeature.dev/)
  id: totrans-414
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="95161">[2] Crossplane –</st> [<st c="95179">https://www.crossplane.io/</st>](https://www.crossplane.io/)
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="95205">[3] Renovate Bot –</st> [<st c="95225">https://github.com/renovatebot/renovate</st>](https://github.com/renovatebot/renovate)
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="95264">[4] Semantic Versioning –</st> [<st c="95291">https://semver.org/</st>](https://semver.org/)
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="95310">[5] Kustomize –</st> [<st c="95327">https://kustomize.io/</st>](https://kustomize.io/)
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="95348">[6] Helm –</st> [<st c="95360">https://helm.sh/</st>](https://helm.sh/)
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="95376">[7]</st> *<st c="95381">The Pragmatic Programmer</st>* <st c="95405">–
    the DRY principle –</st> [<st c="95428">https://media.pragprog.com/titles/tpp20/dry.pdf</st>](https://media.pragprog.com/titles/tpp20/dry.pdf)
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="95475">[8]</st> *<st c="95480">How to set up GitOps directory structure</st>*
    <st c="95520">–</st> [<st c="95523">https://developers.redhat.com/articles/2022/09/07/how-set-your-gitops-directory-structure#directory_structures</st>](https://developers.redhat.com/articles/2022/09/07/how-set-your-gitops-directory-structure#directory_structures)
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="95633">[9] Argo CD –</st> [<st c="95648">https://argo-cd.readthedocs.io/en/stable/</st>](https://argo-cd.readthedocs.io/en/stable/)
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="95689">[10] Flux –</st> [<st c="95702">https://fluxcd.io/flux/</st>](https://fluxcd.io/flux/)
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="95725">[11] Open Container Initiative –</st> [<st c="95759">https://opencontainers.org/</st>](https://opencontainers.org/)
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="95786">[12] Suggested container annotations –</st> [<st c="95826">https://github.com/opencontainers/image-spec/blob/main/annotations.md</st>](https://github.com/opencontainers/image-spec/blob/main/annotations.md)
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="95895">[13] Harbor –</st> [<st c="95910">https://goharbor.io/</st>](https://goharbor.io/)
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="95930">[14] Harbor Prometheus metrics –</st> [<st c="95964">https://goharbor.io/docs/2.10.0/administration/metrics/</st>](https://goharbor.io/docs/2.10.0/administration/metrics/)
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="96019">[15] Harbor distributed tracing –</st> [<st c="96054">https://goharbor.io/docs/2.10.0/administration/distributed-tracing/</st>](https://goharbor.io/docs/2.10.0/administration/distributed-tracing/)
  id: totrans-428
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="96121">[16]</st> *<st c="96127">CNCF TAG App Delivery</st>* <st c="96148">–</st>
    [<st c="96151">https://tag-app-delivery.cncf.io/</st>](https://tag-app-delivery.cncf.io/)
  id: totrans-429
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="96184">[17] Keptn –</st> [<st c="96198">https://keptn.sh/</st>](https://keptn.sh/)
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="96215">[18]</st> *<st c="96221">Argo Rollouts</st>* <st c="96234">–</st>
    [<st c="96237">https://argoproj.github.io/rollouts/</st>](https://argoproj.github.io/rollouts/)
  id: totrans-431
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="96273">[19] Flagger –</st> [<st c="96289">https://flagger.app/</st>](https://flagger.app/)
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="96309">[20] CDEvents –</st> [<st c="96326">https://github.com/cdevents</st>](https://github.com/cdevents)
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="96353">[21] Backstage –</st> [<st c="96371">https://backstage.io/</st>](https://backstage.io/)
  id: totrans-434
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
