<html><head></head><body>
<div id="_idContainer187">
<h1 class="chapter-number" id="_idParaDest-139"><a id="_idTextAnchor141"/><span class="koboSpan" id="kobo.1.1">7</span></h1>
<h1 id="_idParaDest-140"><a id="_idTextAnchor142"/><span class="koboSpan" id="kobo.2.1">Accelerate Productivity with AI</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this chapter, we embark on a journey to explore the exciting realm of AI-powered software development. </span><span class="koboSpan" id="kobo.3.2">In reality, although the application of large language models in coding is gradually becoming more apparent, it remains largely in the research and development phase. </span><span class="koboSpan" id="kobo.3.3">While we have focused on practical content so far, this chapter shifts our attention to the theories that facilitate a wonderful collaboration with AI. </span><span class="koboSpan" id="kobo.3.4">We aim to provide insights that will help you understand the context of AI in development correctly and master its use. </span><span class="koboSpan" id="kobo.3.5">With this foundation, let’s explore the world of AI-powered </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">coding together.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">The essence of AI’s role in coding fundamentally boils down to the age-old notion of </span><em class="italic"><span class="koboSpan" id="kobo.6.1">how to write good code</span></em><span class="koboSpan" id="kobo.7.1">, which, in turn, relies on knowledge, skills, and experience. </span><span class="koboSpan" id="kobo.7.2">If you are looking for a universal magical technique to make AI write remarkable code, you might find that, in reality, such a thing probably does not exist. </span><span class="koboSpan" id="kobo.7.3">Furthermore, even when mentioning specific product features, it is important to recognize that the rapid pace of evolution in this field may quickly render newly acquired </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">skills obsolete.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">This book has consistently focused on the theme of collaboration. </span><span class="koboSpan" id="kobo.9.2">In this context, we maintain that focus, aiming to understand how to collaborate effectively with AI. </span><span class="koboSpan" id="kobo.9.3">The gateway to all communication starts with understanding your counterpart. </span><span class="koboSpan" id="kobo.9.4">By gaining a correct understanding of AI, setting appropriate expectations, and focusing on extracting the right information from AI, you will be able to refine your interactions with AI tools, regardless of how these tools evolve. </span><span class="koboSpan" id="kobo.9.5">As the author, it is my belief that we should aim to fundamentally understand AI rather than focusing solely on individual tips </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">and tricks.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">We will explore best practices for engaging with AI tools, with an emphasis on the subtleties of coding with AI assistance. </span><span class="koboSpan" id="kobo.11.2">AI-powered coding represents an exciting frontier with many uncharted territories. </span><span class="koboSpan" id="kobo.11.3">We encourage you to grasp the fundamentals and embark on coding </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">alongside AI.</span></span></p>
<p><span class="koboSpan" id="kobo.13.1">We will cover the following main headings in </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.15.1">AI innovation </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">in coding</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Exploring the capabilities and interaction with AI </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">in coding</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Strategies for maximizing </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">AI efficiency</span></span></li>
</ul>
<h1 id="_idParaDest-141"><a id="_idTextAnchor143"/><span class="koboSpan" id="kobo.21.1">AI innovation in coding</span></h1>
<p><span class="koboSpan" id="kobo.22.1">The introduction of </span><a id="_idIndexMarker752"/><span class="koboSpan" id="kobo.23.1">LLMs by OpenAI has marked a pivotal moment in the evolution of software development. </span><span class="koboSpan" id="kobo.23.2">We delve into the aftermath of this groundbreaking innovation, exploring how it has reshaped the </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">coding landscape.</span></span></p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor144"/><span class="koboSpan" id="kobo.25.1">The impact of LLMs on coding</span></h2>
<p><span class="koboSpan" id="kobo.26.1">We can say the advent of </span><a id="_idIndexMarker753"/><span class="koboSpan" id="kobo.27.1">LLMs has fundamentally changed how programming is approached and executed. </span><span class="koboSpan" id="kobo.27.2">With the capacity to understand and generate </span><a id="_idIndexMarker754"/><span class="koboSpan" id="kobo.28.1">human-like text, these models have opened up new avenues in coding, making it more efficient and accessible. </span><span class="koboSpan" id="kobo.28.2">LLMs have significantly sped up the process of writing code. </span><span class="koboSpan" id="kobo.28.3">Developers can now leverage AI to quickly generate code snippets, reducing the time spent on routine or repetitive coding tasks. </span><span class="koboSpan" id="kobo.28.4">The introduction of LLMs has enabled developers to tackle coding challenges more creatively. </span><span class="koboSpan" id="kobo.28.5">By providing suggestions and alternative solutions, these models have become valuable tools in the problem-solving arsenal </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">of programmers.</span></span></p>
<p><span class="koboSpan" id="kobo.30.1">LLMs have introduced a new realm of AI-powered development, where developers collaborate with AI tools to enhance their coding workflow. </span><span class="koboSpan" id="kobo.30.2">This collaboration ranges from generating code snippets to offering insights into complex coding problems. </span><span class="koboSpan" id="kobo.30.3">For novice developers, AI serves as an educational tool, helping them learn coding patterns and best practices. </span><span class="koboSpan" id="kobo.30.4">This reduces the entry barriers to programming, making it more approachable for beginners. </span><span class="koboSpan" id="kobo.30.5">Additionally, for experienced developers, this AI integration is a powerful catalyst, enabling them to achieve more by augmenting their skills with advanced code suggestions, automating routine tasks, and providing deeper insights into code optimization and problem-solving. </span><span class="koboSpan" id="kobo.30.6">The combination of seasoned developer expertise and AI efficiency creates a synergy that pushes the boundaries of what can be accomplished in </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">software development.</span></span></p>
<p><span class="koboSpan" id="kobo.32.1">The introduction of modern </span><a id="_idIndexMarker755"/><span class="koboSpan" id="kobo.33.1">LLMs has revolutionized coding, transforming it from a purely manual endeavor to a more collaborative, efficient, and innovative process. </span><span class="koboSpan" id="kobo.33.2">This change has not only accelerated development but has also opened up new possibilities for creativity and problem-solving in the realm of software engineering. </span><span class="koboSpan" id="kobo.33.3">Additionally, this area is being extended right now to a variety of tasks, not only coding but also </span><a id="_idIndexMarker756"/><span class="koboSpan" id="kobo.34.1">review </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">and documentation.</span></span></p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor145"/><span class="koboSpan" id="kobo.36.1">Understanding LLMs – A basic introduction</span></h2>
<p><span class="koboSpan" id="kobo.37.1">In the context of AI-powered programming, LLMs</span><a id="_idIndexMarker757"/><span class="koboSpan" id="kobo.38.1"> have emerged as a pivotal innovation, reshaping our approach to software development. </span><span class="koboSpan" id="kobo.38.2">But what are LLMs? </span><span class="koboSpan" id="kobo.38.3">Let’s get to know </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">this first.</span></span></p>
<p><span class="koboSpan" id="kobo.40.1">LLMs are advanced AI models designed to understand, interpret, and generate human-like text. </span><span class="koboSpan" id="kobo.40.2">These models are large not only in their size (often comprising billions of parameters) but also in their scope of training data </span><span class="No-Break"><span class="koboSpan" id="kobo.41.1">and capabilities.</span></span></p>
<p><span class="koboSpan" id="kobo.42.1">LLMs such as </span><strong class="bold"><span class="koboSpan" id="kobo.43.1">Generative Pre-trained Transformer</span></strong><span class="koboSpan" id="kobo.44.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.45.1">GPT</span></strong><span class="koboSpan" id="kobo.46.1">) are trained on vast datasets comprising a wide range of</span><a id="_idIndexMarker758"/><span class="koboSpan" id="kobo.47.1"> internet text. </span><span class="koboSpan" id="kobo.47.2">This training enables them to predict and generate text based on the input they receive, making them highly versatile in language understanding and generation. </span><span class="koboSpan" id="kobo.47.3">The core technology behind LLMs involves neural network architectures, specifically transformer models, which have</span><a id="_idIndexMarker759"/><span class="koboSpan" id="kobo.48.1"> revolutionized </span><strong class="bold"><span class="koboSpan" id="kobo.49.1">Natural Language Processing</span></strong><span class="koboSpan" id="kobo.50.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.51.1">NLP</span></strong><span class="koboSpan" id="kobo.52.1">). </span><span class="koboSpan" id="kobo.52.2">These networks are adept at handling sequential data, making them ideal for </span><span class="No-Break"><span class="koboSpan" id="kobo.53.1">language tasks.</span></span></p>
<p><span class="koboSpan" id="kobo.54.1">To fully harness their potential, it is essential to understand what LLMs are fundamentally designed to do and what they are not. </span><span class="koboSpan" id="kobo.54.2">While AI may seem like magic, it is more akin to a mirror reflecting your own input; it is not a panacea that solves everything. </span><span class="koboSpan" id="kobo.54.3">You must approach it with the right expectations, guide it properly, and cleverly extract value. </span><span class="koboSpan" id="kobo.54.4">Now it is time to take a look at the essential characteristics </span><span class="No-Break"><span class="koboSpan" id="kobo.55.1">of LLMs:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.56.1">Word prediction engines</span></strong><span class="koboSpan" id="kobo.57.1">: At their core, LLMs </span><a id="_idIndexMarker760"/><span class="koboSpan" id="kobo.58.1">are sophisticated engines designed to predict the next word in a sequence. </span><span class="koboSpan" id="kobo.58.2">This prediction capability is based on the extensive training they receive from vast datasets, enabling them to generate contextually relevant and </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">coherent text.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.60.1">Probabilistic, not deterministic</span></strong><span class="koboSpan" id="kobo.61.1">: Unlike deterministic models that always produce the same output for a given input, LLMs are probabilistic models. </span><span class="koboSpan" id="kobo.61.2">This means that they predict what comes next based on the probability of various possible continuations, leading to potential variations in output for the same input. </span><span class="koboSpan" id="kobo.61.3">This aspect underscores the inherently stochastic nature of LLMs, highlighting that the same “</span><em class="italic"><span class="koboSpan" id="kobo.62.1">context</span></em><span class="koboSpan" id="kobo.63.1">” or input can lead to different outcomes, depending on the probabilistic determination of what </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">comes next.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.65.1">Not a Google search alternative</span></strong><span class="koboSpan" id="kobo.66.1">: It is crucial to note that LLMs are not replacements for search engines such as Google. </span><span class="koboSpan" id="kobo.66.2">They do not learn in the traditional sense or retain information for future output. </span><span class="koboSpan" id="kobo.66.3">Each response generated by a typical </span><a id="_idIndexMarker761"/><span class="koboSpan" id="kobo.67.1">LLM is based on the input provided at that moment, without any memory of </span><span class="No-Break"><span class="koboSpan" id="kobo.68.1">past interactions.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.69.1">Generation, not retrieval</span></strong><span class="koboSpan" id="kobo.70.1">: LLMs operate by generating responses each time rather than retrieving stored information. </span><span class="koboSpan" id="kobo.70.2">This means that their outputs are created anew based on the</span><a id="_idIndexMarker762"/><span class="koboSpan" id="kobo.71.1"> patterns they have learned </span><span class="No-Break"><span class="koboSpan" id="kobo.72.1">during training.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.73.1">LLMs have a critical role in the context of coding, primarily due to their ability to predict the next sequence of characters or words. </span><span class="koboSpan" id="kobo.73.2">These models are not just versatile in handling natural languages, such as English, but extend their capabilities to a wide array of programming languages. </span><span class="koboSpan" id="kobo.73.3">In fact, the application of LLMs to programming languages is where their effectiveness is most recognized and </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">highly anticipated.</span></span></p>
<p><span class="koboSpan" id="kobo.75.1">LLMs’ adaptability to</span><a id="_idIndexMarker763"/><span class="koboSpan" id="kobo.76.1"> different programming languages stems from their training on diverse datasets, which include not only natural language texts but also vast repositories of code. </span><span class="koboSpan" id="kobo.76.2">This enables them to understand the syntax and semantics of various programming languages, making them incredibly useful for tasks such as code completion, bug fixing, and even generating entire blocks of </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">functional code.</span></span></p>
<p><span class="koboSpan" id="kobo.78.1">Moreover, LLMs can assist developers in translating requirements into code, providing suggestions based on best practices, and even offering creative solutions to complex programming challenges. </span><span class="koboSpan" id="kobo.78.2">Their predictive ability ensures that they can recommend the most relevant code snippets, streamline the coding process, and significantly enhance coding efficiency </span><span class="No-Break"><span class="koboSpan" id="kobo.79.1">and accuracy.</span></span></p>
<p><span class="koboSpan" id="kobo.80.1">In addition to the key capability, understanding the limitations and handling misconceptions is </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">also important:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.82.1">Not infallible</span></strong><span class="koboSpan" id="kobo.83.1">: The </span><a id="_idIndexMarker764"/><span class="koboSpan" id="kobo.84.1">accuracy of LLMs is not absolute. </span><span class="koboSpan" id="kobo.84.2">While they can produce remarkably relevant and sophisticated outputs, there are instances where their predictions can be off the mark. </span><span class="koboSpan" id="kobo.84.3">They can sometimes create outputs that seem plausible but are actually inaccurate or nonsensical; a phenomenon</span><a id="_idIndexMarker765"/><span class="koboSpan" id="kobo.85.1"> sometimes referred to </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">as </span></span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.87.1">hallucination</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.89.1">Need for human oversight</span></strong><span class="koboSpan" id="kobo.90.1">: This potential for error underscores the importance of human oversight. </span><span class="koboSpan" id="kobo.90.2">Users of LLMs should be vigilant and discerning, capable of identifying and correcting instances where the model’s output may be misleading </span><span class="No-Break"><span class="koboSpan" id="kobo.91.1">or incorrect.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.92.1">Appropriate use and expectation setting</span></strong><span class="koboSpan" id="kobo.93.1">: Understanding these limitations is key to setting realistic expectations and finding the most effective use cases for LLMs. </span><span class="koboSpan" id="kobo.93.2">They should be viewed as tools that augment and assist in tasks such as coding or text generation rather than as standalone solutions that operate with complete autonomy </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">and</span></span><span class="No-Break"><a id="_idIndexMarker766"/></span><span class="No-Break"><span class="koboSpan" id="kobo.95.1"> accuracy.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.96.1">In essence, LLM is a powerful innovation, offering significant capabilities in text generation and language understanding. </span><span class="koboSpan" id="kobo.96.2">However, their effective use requires an awareness of their limitations and the critical role of human oversight in guiding </span><span class="No-Break"><span class="koboSpan" id="kobo.97.1">their output.</span></span></p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor146"/><span class="koboSpan" id="kobo.98.1">Application of LLMs in coding</span></h2>
<p><span class="koboSpan" id="kobo.99.1">The integration of</span><a id="_idIndexMarker767"/><span class="koboSpan" id="kobo.100.1"> LLMs in the world of coding has seen one of its most </span><a id="_idIndexMarker768"/><span class="koboSpan" id="kobo.101.1">significant applications in the form of AI-powered </span><a id="_idIndexMarker769"/><span class="koboSpan" id="kobo.102.1">coding tools such as GitHub Copilot. </span><span class="koboSpan" id="kobo.102.2">This section explores how AI is redefining the </span><span class="No-Break"><span class="koboSpan" id="kobo.103.1">coding experience.</span></span></p>
<p><span class="koboSpan" id="kobo.104.1">AI-powered tools designed to assist developers in writing code leverage the power of LLMs to provide real-time code suggestions, automating some aspects of coding and enhancing overall productivity. </span><span class="koboSpan" id="kobo.104.2">These tools, trained on a vast array of code repositories, interpret the context from the current coding environment and offer suggestions for the next lines of code, function implementations, or even entire classes </span><span class="No-Break"><span class="koboSpan" id="kobo.105.1">and modules.</span></span></p>
<p><span class="koboSpan" id="kobo.106.1">The fundamental capability of these AI tools is that they work as plugins to editors such as Visual Studio Code, providing AI assistance as you code within the editor. </span><span class="koboSpan" id="kobo.106.2">The vision behind these tools includes integrating AI into all phases of the software development cycle, with a significant focus on their integration into the editor as a major feature. </span><span class="koboSpan" id="kobo.106.3">This approach represents a broader effort to harness AI for enhancing software development processes, aiming to make coding more efficient and accessible to developers at all </span><span class="No-Break"><span class="koboSpan" id="kobo.107.1">skill levels.</span></span></p>
<h3><span class="koboSpan" id="kobo.108.1">Transforming the coding process</span></h3>
<p><span class="koboSpan" id="kobo.109.1">AI-powered tools assist in enhancing the</span><a id="_idIndexMarker770"/><span class="koboSpan" id="kobo.110.1"> development process by streamlining a variety of coding tasks. </span><span class="koboSpan" id="kobo.110.2">Traditionally, coding involves research, reading documentation, and ensuring the correctness of the code. </span><span class="koboSpan" id="kobo.110.3">These tools help optimize these activities in several </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">key areas:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.112.1">Increasing speed and efficiency</span></strong><span class="koboSpan" id="kobo.113.1">: Developers can speed up the coding process with these tools. </span><span class="koboSpan" id="kobo.113.2">They help reduce the time spent on repetitive code patterns and offer quick solutions and suggestions, freeing up developers to tackle more complex and </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">innovative work.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.115.1">Facilitating learning and exploration</span></strong><span class="koboSpan" id="kobo.116.1">: For newcomers or those delving into new programming languages or frameworks, these AI tools serve as educational aids. </span><span class="koboSpan" id="kobo.116.2">They provide syntactically accurate code snippets and show best practices </span><span class="No-Break"><span class="koboSpan" id="kobo.117.1">in action.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.118.1">Reducing cognitive load</span></strong><span class="koboSpan" id="kobo.119.1">: AI-powered tools tackle the more routine aspects of coding, alleviating the mental burden developers face. </span><span class="koboSpan" id="kobo.119.2">This reduction in cognitive load enables developers to concentrate their mental energy on tackling more intricate and </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">challenging problems.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.121.1">Expanding possibilities</span></strong><span class="koboSpan" id="kobo.122.1">: Through their suggestions, these tools not only assist with code completion but also stimulate creative thinking. </span><span class="koboSpan" id="kobo.122.2">They introduce developers to alternative problem-solving approaches and expose them to new coding patterns and practices they might not have previously encountered or considered. </span><span class="koboSpan" id="kobo.122.3">This expansion of possibilities can lead to more innovative solutions and a broadening</span><a id="_idIndexMarker771"/><span class="koboSpan" id="kobo.123.1"> of the developer’s </span><span class="No-Break"><span class="koboSpan" id="kobo.124.1">skill set.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.125.1">By minimizing the need for</span><a id="_idIndexMarker772"/><span class="koboSpan" id="kobo.126.1"> frequent diversions to look up information and by offering pertinent code suggestions, these AI-powered tools support a more focused and efficient workflow. </span><span class="koboSpan" id="kobo.126.2">This not only leads to better code quality but also enhances developer productivity, establishing these tools as essential components in contemporary </span><a id="_idIndexMarker773"/><span class="No-Break"><span class="koboSpan" id="kobo.127.1">software development.</span></span></p>
<h3><span class="koboSpan" id="kobo.128.1">Collaborative code creation</span></h3>
<p><span class="koboSpan" id="kobo.129.1">When comparing code completion </span><a id="_idIndexMarker774"/><span class="koboSpan" id="kobo.130.1">tools to chat-based tools, it is clear that each provides a unique set of offerings to developers. </span><span class="koboSpan" id="kobo.130.2">Here are the </span><span class="No-Break"><span class="koboSpan" id="kobo.131.1">major differences:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.132.1">Code completion experience</span></strong><span class="koboSpan" id="kobo.133.1">: Tools equipped with code completion capabilities can predict the next words or code blocks directly within the editor. </span><span class="koboSpan" id="kobo.133.2">They offer incremental suggestions that users can quickly accept or reject, streamlining the coding process. </span><span class="koboSpan" id="kobo.133.3">This is somewhat similar to mob programming alongside an experienced engineer or engaging in pair programming with real-time screen sharing, which promotes an interactive and dynamic </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">coding environment:</span></span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer185">
<span class="koboSpan" id="kobo.135.1"><img alt="Figure 7.1 – Code completion experience in GitHub Copilot" src="image/B21203_07_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.136.1">Figure 7.1 – Code completion experience in GitHub Copilot</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.137.1">Chat experience</span></strong><span class="koboSpan" id="kobo.138.1">: In contrast, the</span><a id="_idIndexMarker775"/><span class="koboSpan" id="kobo.139.1"> chat experience resembles </span><a id="_idIndexMarker776"/><span class="koboSpan" id="kobo.140.1">consulting with a senior engineer via platforms such as Slack or Teams or even</span><a id="_idIndexMarker777"/><span class="koboSpan" id="kobo.141.1"> delegating implementation tasks. </span><span class="koboSpan" id="kobo.141.2">Some tools also feature a chat interface, enabling developers to tap into both direct code assistance and </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">conversational guidance:</span></span></li>
</ul>
<div>
<div class="IMG---Figure" id="_idContainer186">
<span class="koboSpan" id="kobo.143.1"><img alt="Figure 7.2 – Chat experience in GitHub Copilot" src="image/B21203_07_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.144.1">Figure 7.2 – Chat experience in GitHub Copilot</span></p>
<p><span class="koboSpan" id="kobo.145.1">GitHub Copilot, the</span><a id="_idIndexMarker778"/><span class="koboSpan" id="kobo.146.1"> developer-centric designed tool, supports both chat and code completion experiences. </span><span class="koboSpan" id="kobo.146.2">ChatGPT, known for its versatility beyond coding, requires users to carefully</span><a id="_idIndexMarker779"/><span class="koboSpan" id="kobo.147.1"> craft prompts to guide their responses. </span><span class="koboSpan" id="kobo.147.2">In contrast, AI-powered developer tools stand out for enhancing the developer experience within the editor, focusing on how engineers can seamlessly integrate their </span><a id="_idIndexMarker780"/><span class="koboSpan" id="kobo.148.1">current </span><a id="_idIndexMarker781"/><span class="koboSpan" id="kobo.149.1">work context with </span><span class="No-Break"><span class="koboSpan" id="kobo.150.1">AI assistance.</span></span></p>
<p><span class="koboSpan" id="kobo.151.1">They are engineered to</span><a id="_idIndexMarker782"/><span class="koboSpan" id="kobo.152.1"> support developers by intuitively understanding the context of their work and making it easier to communicate this context to the AI with fewer prompts. </span><span class="koboSpan" id="kobo.152.2">The more code developers write, the more these tools can tailor their assistance to align with the developers’ objectives and the specifics of their </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">work context.</span></span></p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor147"/><span class="koboSpan" id="kobo.154.1">Prompt and context</span></h2>
<p><span class="koboSpan" id="kobo.155.1">The </span><a id="_idIndexMarker783"/><span class="koboSpan" id="kobo.156.1">concept of </span><strong class="bold"><span class="koboSpan" id="kobo.157.1">prompts</span></strong><span class="koboSpan" id="kobo.158.1"> has </span><a id="_idIndexMarker784"/><span class="koboSpan" id="kobo.159.1">gained widespread attention with the advent of generative AI technologies. </span><span class="koboSpan" id="kobo.159.2">Among the various terms you might have encountered, “Prompt Engineering” stands out as a particularly common reference. </span><span class="koboSpan" id="kobo.159.3">However, what is prompt engineering really? </span><span class="koboSpan" id="kobo.159.4">Prompt engineering is the art of designing inputs or prompts for AI models to generate desired outputs. </span><span class="koboSpan" id="kobo.159.5">It is about crafting questions or statements in a way that guides the AI to understand and respond in a specific manner. </span><span class="koboSpan" id="kobo.159.6">This is crucial because the quality and relevance of AI outputs are highly dependent on how the prompts are structured. </span><span class="koboSpan" id="kobo.159.7">At the same time, however, it is also true that there are excessive expectations for this, and it was treated like a buzzword in the </span><span class="No-Break"><span class="koboSpan" id="kobo.160.1">early days.</span></span></p>
<p><span class="koboSpan" id="kobo.161.1">The term prompt engineering seems to me to be a mixture of diverse things. </span><span class="koboSpan" id="kobo.161.2">I will explain </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">them here.</span></span></p>
<h3><span class="koboSpan" id="kobo.163.1">Two types of prompt engineering</span></h3>
<p><span class="koboSpan" id="kobo.164.1">In the evolution of AI and</span><a id="_idIndexMarker785"/><span class="koboSpan" id="kobo.165.1"> machine learning, prompt engineering has emerged as an important discipline that shapes how we interact with and extract value from AI models. </span><span class="koboSpan" id="kobo.165.2">There are two types of prompt engineering. </span><span class="koboSpan" id="kobo.165.3">Although not an academic</span><a id="_idIndexMarker786"/><span class="koboSpan" id="kobo.166.1"> classification, I will refer to them </span><a id="_idIndexMarker787"/><span class="koboSpan" id="kobo.167.1">here as </span><strong class="bold"><span class="koboSpan" id="kobo.168.1">reusable prompt engineering</span></strong><span class="koboSpan" id="kobo.169.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.170.1">disposable prompt engineering</span></strong><span class="koboSpan" id="kobo.171.1">, each for different</span><a id="_idIndexMarker788"/><span class="koboSpan" id="kobo.172.1"> applications </span><a id="_idIndexMarker789"/><span class="koboSpan" id="kobo.173.1">and requirements. </span><span class="koboSpan" id="kobo.173.2">It is important to recognize the difference between these and to know and use these objectives in your daily interactions with </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">the AI.</span></span></p>
<h4><span class="koboSpan" id="kobo.175.1">Reusable prompt engineering</span></h4>
<p><span class="koboSpan" id="kobo.176.1">Reusable</span><a id="_idIndexMarker790"/><span class="koboSpan" id="kobo.177.1"> prompt engineering is designed for scenarios </span><a id="_idIndexMarker791"/><span class="koboSpan" id="kobo.178.1">where prompts are repeatedly used in similar contexts. </span><span class="koboSpan" id="kobo.178.2">This is common in consumer-facing AI applications, automated systems, and AI-to-machine interactions. </span><span class="koboSpan" id="kobo.178.3">The aim here is to create prompts that consistently elicit accurate and relevant responses from AI, regardless of minor variations in input </span><span class="No-Break"><span class="koboSpan" id="kobo.179.1">or context.</span></span></p>
<p><span class="koboSpan" id="kobo.180.1">In reusable prompt engineering, near-perfect accuracy is essential. </span><span class="koboSpan" id="kobo.180.2">This is particularly true for machine consumers, where AI responses trigger other functions or processes. </span><span class="koboSpan" id="kobo.180.3">Similarly, in B2C applications, high accuracy is crucial to maintain user engagement and prevent frustration </span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">or confusion.</span></span></p>
<p><span class="koboSpan" id="kobo.182.1">The primary </span><a id="_idIndexMarker792"/><span class="koboSpan" id="kobo.183.1">challenge in this type of prompt engineering is maintaining stability and consistency in AI responses. </span><span class="koboSpan" id="kobo.183.2">This often requires a deep understanding of the AI model’s capabilities and limitations. </span><span class="koboSpan" id="kobo.183.3">Engineers who build prompts must also consider the variability in user inputs and contexts, ensuring that the AI can handle these variations without significant loss </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">of accuracy.</span></span></p>
<p><span class="koboSpan" id="kobo.185.1">In reusable prompt engineering, the emphasis is primarily on </span><em class="italic"><span class="koboSpan" id="kobo.186.1">how</span></em><span class="koboSpan" id="kobo.187.1">—crafting prompts to ensure reliable and accurate responses. </span><span class="koboSpan" id="kobo.187.2">This focus is critical because the </span><em class="italic"><span class="koboSpan" id="kobo.188.1">what</span></em><span class="koboSpan" id="kobo.189.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.190.1">why</span></em><span class="koboSpan" id="kobo.191.1"> can often be unpredictable, particularly in scenarios involving a broad and diverse user base. </span><span class="koboSpan" id="kobo.191.2">The prompts must be designed to handle a wide range of inputs from an unspecified number of users, each with their unique needs and ways of interacting with the </span><span class="No-Break"><span class="koboSpan" id="kobo.192.1">AI system.</span></span></p>
<p><span class="koboSpan" id="kobo.193.1">The term</span><a id="_idIndexMarker793"/><span class="koboSpan" id="kobo.194.1"> prompt engineering in the world is used in this context, especially in a narrow sense. </span><span class="koboSpan" id="kobo.194.2">It is about how to refine the instructions to the </span><a id="_idIndexMarker794"/><span class="koboSpan" id="kobo.195.1">AI in order to extract information from it with a high degree of accuracy. </span><span class="koboSpan" id="kobo.195.2">However, in the actual development field, there is no need to spend time refining prompts that are used only once. </span><span class="koboSpan" id="kobo.195.3">Prompt engineering in development requires a </span><span class="No-Break"><span class="koboSpan" id="kobo.196.1">different context.</span></span></p>
<h4><span class="koboSpan" id="kobo.197.1">Disposable prompt engineering</span></h4>
<p><span class="koboSpan" id="kobo.198.1">Disposable prompt</span><a id="_idIndexMarker795"/><span class="koboSpan" id="kobo.199.1"> engineering is characterized </span><a id="_idIndexMarker796"/><span class="koboSpan" id="kobo.200.1">by the creation of one-time-use prompts. </span><span class="koboSpan" id="kobo.200.2">These are typically crafted by developers or users for specific, often unique, situations. </span><span class="koboSpan" id="kobo.200.3">Here, the emphasis shifts from broad applicability and consistency to specificity and </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">immediate relevance.</span></span></p>
<p><span class="koboSpan" id="kobo.202.1">This type involves a high degree of creativity and adaptability. </span><span class="koboSpan" id="kobo.202.2">Developers create prompts on the fly, tailoring them to specific tasks or problems. </span><span class="koboSpan" id="kobo.202.3">This requires a deep understanding of the context and objectives (the why and what) and a flexible approach to interacting with </span><span class="No-Break"><span class="koboSpan" id="kobo.203.1">the AI.</span></span></p>
<p><span class="koboSpan" id="kobo.204.1">In disposable prompt engineering, context is king. </span><span class="koboSpan" id="kobo.204.2">The prompts are often designed to address specific issues or to generate unique outputs. </span><span class="koboSpan" id="kobo.204.3">As such, the engineer must provide the AI with sufficient context to understand and respond appropriately to the task at hand. </span><span class="koboSpan" id="kobo.204.4">In the context of development, you will need to give new instructions to the AI each time you do something creative with each development task. </span><span class="koboSpan" id="kobo.204.5">After all, you will find that when you use AIs </span><a id="_idIndexMarker797"/><span class="koboSpan" id="kobo.205.1">in your development, you have little need to master each and every type of</span><a id="_idIndexMarker798"/><span class="koboSpan" id="kobo.206.1"> prompt engineering. </span><span class="koboSpan" id="kobo.206.2">What is more important is </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">the context.</span></span></p>
<p><span class="koboSpan" id="kobo.208.1">In summary, it is important to acknowledge that mastering the intricate techniques of prompt engineering may not be efficient for every goal. </span><span class="koboSpan" id="kobo.208.2">Again, for daily tasks requiring fresh ideas and essentially serving as one-off needs, dedicating extensive time to perfecting prompts might not be essential. </span><span class="koboSpan" id="kobo.208.3">Conversely, in projects such as developing an app infused with AI, the quality of prompts is crucial. </span><span class="koboSpan" id="kobo.208.4">In these instances, it is beneficial to continually refine them to ensure optimal interaction with the AI component. </span><span class="koboSpan" id="kobo.208.5">This process often involves trial and error, along with a sophisticated understanding of how the AI model may</span><a id="_idIndexMarker799"/><span class="koboSpan" id="kobo.209.1"> interpret </span><span class="No-Break"><span class="koboSpan" id="kobo.210.1">various prompts.</span></span></p>
<h3><span class="koboSpan" id="kobo.211.1">The importance of context</span></h3>
<p><span class="koboSpan" id="kobo.212.1">In AI-powered </span><a id="_idIndexMarker800"/><span class="koboSpan" id="kobo.213.1">development, particularly in programming, the context in</span><a id="_idIndexMarker801"/><span class="koboSpan" id="kobo.214.1"> which a piece of code exists is paramount. </span><span class="koboSpan" id="kobo.214.2">Context includes the surrounding information and environment of the code, extending beyond the immediate codebase to encompass project specifications, coding standards, and intended functionality. </span><span class="koboSpan" id="kobo.214.3">The effectiveness of AI hinges on its ability to interpret and respond to </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">this context.</span></span></p>
<p><span class="koboSpan" id="kobo.216.1">The context provided to an AI system determines the relevance and accuracy of its responses and suggestions. </span><span class="koboSpan" id="kobo.216.2">In the absence of adequate context, AI tools may generate outputs that are technically correct but misaligned with the project’s goals </span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">or requirements.</span></span></p>
<p><span class="koboSpan" id="kobo.218.1">As developers integrate AI into their workflow, it is essential to recognize their role in providing clear and relevant context. </span><span class="koboSpan" id="kobo.218.2">This responsibility involves understanding that AI, while powerful, is not infallible or omniscient. </span><span class="koboSpan" id="kobo.218.3">It requires input that accurately reflects the problem at hand and the </span><span class="No-Break"><span class="koboSpan" id="kobo.219.1">desired outcomes.</span></span></p>
<p><span class="koboSpan" id="kobo.220.1">Developers</span><a id="_idIndexMarker802"/><span class="koboSpan" id="kobo.221.1"> should approach AI as a collaborative tool, guiding it through a well-defined context to ensure that its contributions are aligned with project objectives. </span><span class="koboSpan" id="kobo.221.2">This involves critically evaluating AI suggestions and adapting them to fit the specific nuances of </span><span class="No-Break"><span class="koboSpan" id="kobo.222.1">their projects.</span></span></p>
<p><span class="koboSpan" id="kobo.223.1">The following would be</span><a id="_idIndexMarker803"/><span class="koboSpan" id="kobo.224.1"> important to </span><span class="No-Break"><span class="koboSpan" id="kobo.225.1">include context:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.226.1">Provide detailed comments</span></strong><span class="koboSpan" id="kobo.227.1">: Incorporate comprehensive comments into the code that explain not just what the code does but also the purpose behind it. </span><span class="koboSpan" id="kobo.227.2">This helps AI tools understand the intent behind </span><span class="No-Break"><span class="koboSpan" id="kobo.228.1">the code.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.229.1">Use descriptive naming conventions</span></strong><span class="koboSpan" id="kobo.230.1">: Choose variable and function names that clearly indicate their purpose and usage. </span><span class="koboSpan" id="kobo.230.2">This aids AI in generating more relevant and </span><span class="No-Break"><span class="koboSpan" id="kobo.231.1">readable code.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.232.1">Document code thoroughly</span></strong><span class="koboSpan" id="kobo.233.1">: Ensure that the codebase is well-documented, outlining the broader project objectives, coding standards, and </span><span class="No-Break"><span class="koboSpan" id="kobo.234.1">specific functionalities.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.235.1">Frame problems clearly</span></strong><span class="koboSpan" id="kobo.236.1">: When seeking AI assistance, define the problem as specifically as possible. </span><span class="koboSpan" id="kobo.236.2">This includes stating the desired outcomes and any relevant constraints </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">or considerations.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.238.1">Effectively leveraging AI in programming requires a balanced approach that recognizes AI as a powerful assistant but not a complete substitute for human expertise. </span><span class="koboSpan" id="kobo.238.2">By providing clear, detailed context and maintaining critical oversight, developers can maximize the benefits of AI-powered tools. </span><span class="koboSpan" id="kobo.238.3">This approach ensures that AI serves as a catalyst for enhanced productivity and creativity in software development, complementing human capabilities rather than attempting to </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">replace them.</span></span></p>
<p><span class="koboSpan" id="kobo.240.1">The paramount importance of</span><a id="_idIndexMarker804"/><span class="koboSpan" id="kobo.241.1"> context in AI-powered programming cannot be overstated. </span><span class="koboSpan" id="kobo.241.2">As AI continues to evolve, its capacity to interpret and utilize context will determine the extent of its impact on </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">software development.</span></span></p>
<p><span class="koboSpan" id="kobo.243.1">For developers to truly harness the potential of AI in programming, a deep understanding of programming and technology is essential. </span><span class="koboSpan" id="kobo.243.2">While prompt engineering significantly amplifies productivity, it is not a standalone solution. </span><span class="koboSpan" id="kobo.243.3">The ability to provide clear and detailed context to AI is a skill that synergizes with a developer’s technical expertise. </span><span class="koboSpan" id="kobo.243.4">Ultimately, the effectiveness of AI tools in augmenting development work hinges on the developer’s foundational knowledge and experience in coding. </span><span class="koboSpan" id="kobo.243.5">This combination of technical proficiency and skillful prompt engineering is key to maximizing the benefits </span><a id="_idIndexMarker805"/><span class="koboSpan" id="kobo.244.1">of AI in </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">software development.</span></span></p>
<h1 id="_idParaDest-146"><a id="_idTextAnchor148"/><span class="koboSpan" id="kobo.246.1">Exploring the capabilities and interaction with AI in coding</span></h1>
<p><span class="koboSpan" id="kobo.247.1">This section is dedicated to providing developers with in-depth insights and strategies for effectively leveraging AI within their coding projects, focusing on its features and interaction dynamics. </span><span class="koboSpan" id="kobo.247.2">Whether it involves integrating AI for routine coding tasks or utilizing it for the more intricate and imaginative facets of programming, this section intends to offer comprehensive guidance on making AI a transformative element in your </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">coding practices.</span></span></p>
<p><span class="koboSpan" id="kobo.249.1">Let’s explore the expansive capabilities of AI in coding and learn the best practices for interacting with AI tools, enhancing not only the productivity and quality of your projects but also your overall experience as </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">a developer.</span></span></p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor149"/><span class="koboSpan" id="kobo.251.1">Code completion – The foundation of AI-powered coding</span></h2>
<p><span class="koboSpan" id="kobo.252.1">Unlike ChatGPT, which requires full </span><a id="_idIndexMarker806"/><span class="koboSpan" id="kobo.253.1">context in the prompt for each interaction, code completion in programming environments is deeply integrated with the code editor. </span><span class="koboSpan" id="kobo.253.2">AI-powered coding tools dynamically collect necessary data from the code you are writing and seamlessly communicate with the backend LLM. </span><span class="koboSpan" id="kobo.253.3">This integration offers an experience akin to pair programming or mob programming with an </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">AI collaborator.</span></span></p>
<p><span class="koboSpan" id="kobo.255.1">The typical AI tool continuously analyzes the code within the editor, understanding the immediate context to offer relevant suggestions. </span><span class="koboSpan" id="kobo.255.2">This contextual awareness is key to the effectiveness of code completion. </span><span class="koboSpan" id="kobo.255.3">In AI tools, where context is important, the most important thing is how the context was collected from the editor. </span><span class="koboSpan" id="kobo.255.4">Sometimes, humans tend to focus on the accuracy of the model behind it. </span><span class="koboSpan" id="kobo.255.5">That is never a mistake; the smarter the AI, the better. </span><span class="koboSpan" id="kobo.255.6">However, as AI develops in the future, any tool will be able to perform certain tasks. </span><span class="koboSpan" id="kobo.255.7">What will stand out in that case is its excellence as a data collection tool. </span><span class="koboSpan" id="kobo.255.8">Therefore, in code completion, it is important to know how the AI-powered coding assistant tool collects information from the editor and to determine whether code completion should take this </span><span class="No-Break"><span class="koboSpan" id="kobo.256.1">into account.</span></span></p>
<p><span class="koboSpan" id="kobo.257.1">As developers type code, an AI-powered coding tool suggests potential code snippets that complete or extend the code. </span><span class="koboSpan" id="kobo.257.2">Typically, this functionality is not just about speeding up the typing process; it is about offering intelligent, contextually relevant suggestions that can improve code quality </span><span class="No-Break"><span class="koboSpan" id="kobo.258.1">and efficiency.</span></span></p>
<p><span class="koboSpan" id="kobo.259.1">Here is an example of code completion in action. </span><span class="koboSpan" id="kobo.259.2">Let’s create a file </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">calc.js</span></strong><span class="koboSpan" id="kobo.261.1"> and write the following </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">in JavaScript:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.263.1">
function calculateSum(a, b) {
    // AI Suggestion Here}</span></pre> <p><span class="koboSpan" id="kobo.264.1">For example, AI code-completion</span><a id="_idIndexMarker807"/><span class="koboSpan" id="kobo.265.1"> would complement the contents of a function </span><span class="No-Break"><span class="koboSpan" id="kobo.266.1">as follows:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.267.1">
function calculateSum(a, b) {
    const sum = a + b;
    return sum;
}</span></pre> <p><span class="koboSpan" id="kobo.268.1">The AI model behind code completion has been exposed to a vast array of code, but it is important to clarify that this exposure means it has been “</span><em class="italic"><span class="koboSpan" id="kobo.269.1">trained on data</span></em><span class="koboSpan" id="kobo.270.1">” rather than having fundamentally “</span><em class="italic"><span class="koboSpan" id="kobo.271.1">learned</span></em><span class="koboSpan" id="kobo.272.1">” in the traditional sense. </span><span class="koboSpan" id="kobo.272.2">Essentially, it has become adept at recognizing patterns unique to coding through the analysis of these extensive code repositories. </span><span class="koboSpan" id="kobo.272.3">By utilizing LLMs, the model can discern patterns, best practices, and common coding paradigms to generate suggestions. </span><span class="koboSpan" id="kobo.272.4">As a predictive engine for the next word or sequence in code, the quality of its suggestions is directly influenced by the quality of the input code. </span><span class="koboSpan" id="kobo.272.5">In essence, the output quality reflects the quality of the code data it was trained on, highlighting that its capability to provide relevant suggestions depends on recognizing patterns within the </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">training data.</span></span></p>
<p><span class="koboSpan" id="kobo.274.1">Code generation—the ability of </span><a id="_idIndexMarker808"/><span class="koboSpan" id="kobo.275.1">AI-powered coding tools to interpret and respond to natural language—is remarkable. </span><span class="koboSpan" id="kobo.275.2">The breakthrough with AI is its capacity to understand natural language as it is presented, offering code suggestions based on that understanding rather than relying on static analysis, as with traditional non-AI code completion tools such as IntelliSense. </span><span class="koboSpan" id="kobo.275.3">Developers can detail the functionality, parameters, and expected outcomes of a code segment through comments, directing the AI to generate </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">relevant code.</span></span></p>
<p><span class="koboSpan" id="kobo.277.1">When we talk about “</span><em class="italic"><span class="koboSpan" id="kobo.278.1">code generation</span></em><span class="koboSpan" id="kobo.279.1">,” it</span><a id="_idIndexMarker809"/><span class="koboSpan" id="kobo.280.1"> includes what was referred to in the previous section as code completion, but here we are discussing it in a broader sense, focusing on generating code from natural language and various types </span><span class="No-Break"><span class="koboSpan" id="kobo.281.1">of information.</span></span></p>
<p><span class="koboSpan" id="kobo.282.1">The effectiveness of this feature depends on the precision and clarity of the instructions provided. </span><span class="koboSpan" id="kobo.282.2">Well-defined and explicit comments empower AI-powered coding tools to produce more accurate and suitable </span><span class="No-Break"><span class="koboSpan" id="kobo.283.1">code responses.</span></span></p>
<p><span class="koboSpan" id="kobo.284.1">This is where the importance of your knowledge, experience, and approach to prompt crafting becomes evident. </span><span class="koboSpan" id="kobo.284.2">It is crucial to leverage your critical thinking and logical writing skills in a manner that the AI </span><span class="No-Break"><span class="koboSpan" id="kobo.285.1">can comprehend.</span></span></p>
<p><span class="koboSpan" id="kobo.286.1">For example, let’s create a JavaScript file named </span><strong class="source-inline"><span class="koboSpan" id="kobo.287.1">calc.js</span></strong><span class="koboSpan" id="kobo.288.1">, as follows, and write the comments you want </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">to implement:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.290.1">
// Function name: calculateAverage
// Function arguments: numbers (array)
// Return type of the function: number</span></pre> <p><span class="koboSpan" id="kobo.291.1">If AI-powered tools can</span><a id="_idIndexMarker810"/><span class="koboSpan" id="kobo.292.1"> generate code, it will look like </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.294.1">
function calculateAverage(numbers: number[]): number {
    // calculate the average of the array
    const sum = numbers.reduce((a, b) =&gt; a + b);
    return sum / numbers.length;
}</span></pre> <p><span class="koboSpan" id="kobo.295.1">Providing examples within other sections of the code or in comments can be extremely helpful. </span><span class="koboSpan" id="kobo.295.2">Additionally, one of the strengths of AI-powered coding tools lies in their ability to generate code based on structured examples. </span><span class="koboSpan" id="kobo.295.3">This feature proves especially beneficial in situations such as developing models from given </span><span class="No-Break"><span class="koboSpan" id="kobo.296.1">data examples.</span></span></p>
<p><span class="koboSpan" id="kobo.297.1">For instance, consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.298.1">following comment:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.299.1">
# [{"id": "A1", "name": "Yoshi Yamashita"}]</span></pre> <p><span class="koboSpan" id="kobo.300.1">Then, AI can</span><a id="_idIndexMarker811"/><span class="koboSpan" id="kobo.301.1"> produce the following model. </span><span class="koboSpan" id="kobo.301.2">The following example will output Python if you write Python in the file </span><strong class="source-inline"><span class="koboSpan" id="kobo.302.1">user.py</span></strong><span class="koboSpan" id="kobo.303.1">, but similarly, if you write a specific language, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">user.js</span></strong><span class="koboSpan" id="kobo.305.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">user.rb</span></strong><span class="koboSpan" id="kobo.307.1">, the same implementation would be carried out for a </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">different language:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.309.1">
users = json.loads(json_data)
class User:
    def __init__(self, id, name):
        self.id = id
        self.name = name</span></pre> <p><span class="koboSpan" id="kobo.310.1">This indicates that the distance between the definition of the implementation and the implementation itself is getting </span><span class="No-Break"><span class="koboSpan" id="kobo.311.1">very close.</span></span></p>
<p><span class="koboSpan" id="kobo.312.1">When it comes to definitions, table definitions can be turned into SQL queries for database tables, cloud infrastructure definitions can be turned into YAML files for Terraform, and </span><span class="No-Break"><span class="koboSpan" id="kobo.313.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.314.1">For example, from a given JSON example, it is possible to generate commands to create a model for Ruby </span><span class="No-Break"><span class="koboSpan" id="kobo.315.1">on Rails.</span></span></p>
<p><span class="koboSpan" id="kobo.316.1">Here is the given </span><span class="No-Break"><span class="koboSpan" id="kobo.317.1">JSON example:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.318.1">
{
  "name": "Yoshi Yamashita",
  "age": 48,
  "description": "Hello from Tokyo",
  "country": "Japan",
  "title": "Software Engineer",
  "email": yoshiyamashita@example.com
}</span></pre> <p><span class="koboSpan" id="kobo.319.1">All you have to do is provide the prompt “</span><em class="italic"><span class="koboSpan" id="kobo.320.1">Generate a rails command to create a new user</span></em><span class="koboSpan" id="kobo.321.1">” for this example, and AI will create a ready-to-use command in CLI </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">as follows:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.323.1">
rails g model User name:string age:integer description:text country:string title:string email:string</span></pre> <p><span class="koboSpan" id="kobo.324.1">The code </span><a id="_idIndexMarker812"/><span class="koboSpan" id="kobo.325.1">generation capability represents a significant advancement in AI-powered coding. </span><span class="koboSpan" id="kobo.325.2">By interpreting descriptive comments and structured examples, AI can generate accurate and functional code, reducing manual coding efforts and enhancing the efficiency of the </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">development process.</span></span></p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor150"/><span class="koboSpan" id="kobo.327.1">Code explanation</span></h2>
<p><span class="koboSpan" id="kobo.328.1">AI has the </span><a id="_idIndexMarker813"/><span class="koboSpan" id="kobo.329.1">capability to analyze existing code and automatically generate explanations that clarify the code’s functionality. </span><span class="koboSpan" id="kobo.329.2">This feature proves to be invaluable for understanding code that is not adequately documented or for demystifying complex algorithms for other developers. </span><span class="koboSpan" id="kobo.329.3">These generated explanations assist in simplifying complex code into more comprehensible segments, thereby facilitating a better understanding of the logic and intent behind the code </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">for others.</span></span></p>
<p><span class="koboSpan" id="kobo.331.1">Such a capability is instrumental in reducing the onboarding time for new team members, accelerating the comprehension of code for first-time viewers, and proving useful in scenarios where there is a noticeable gap between the specification and the actual code. </span><span class="koboSpan" id="kobo.331.2">Moreover, it enhances the value of the code by providing explanations for previously unmaintained or obscure code, thereby making its </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">functionality clearer.</span></span></p>
<p><span class="koboSpan" id="kobo.333.1">Here is an example of writing an algorithm in Python by creating a file, </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">eratosthenes.py</span></strong><span class="koboSpan" id="kobo.335.1">, and specifically considering generating explanations for the Sieve of the Eratosthenes algorithm, which was originally presented </span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">without explanation:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.337.1">
def eratosthenes_sieve(n):
    primes = []
    sieve = [True] * (n + 1)
    for p in range(2, n + 1):
        if sieve[p]:
            primes.append(p)
            for i in range(p * p, n + 1, p):
                sieve[i] = False
    return primes</span></pre> <p><span class="koboSpan" id="kobo.338.1">If you write a comment at the beginning of a line, the AI will recognize that you write a comment on every new line, and the AI will automatically complete the rest by simply breaking the line. </span><span class="koboSpan" id="kobo.338.2">AI </span><a id="_idIndexMarker814"/><span class="koboSpan" id="kobo.339.1">can generate the </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">following comments:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.341.1">
# This is a function that calculates prime numbers less than n
def eratosthenes_sieve(n):
    # Primes will hold all the prime numbers found
    primes = []
    # sieve is a list used to track prime numbers
    sieve = [True] * (n + 1)
    # loop through each number in the range 2 to n
    for p in range(2, n + 1):
        # If the number is marked as True in the sieve list
        if sieve[p]:
            # It is a prime number, so add it to the primes list
            primes.append(p)
            # Mark all multiples of this prime number as False
            for i in range(p * p, n + 1, p):
                sieve[i] = False
    # return the list of prime numbers
    return primes</span></pre> <p><span class="koboSpan" id="kobo.342.1">In extreme cases, you do not need any specific prompt. </span><span class="koboSpan" id="kobo.342.2">Sometimes, all you have to do when you use GitHub Copilot</span><a id="_idIndexMarker815"/><span class="koboSpan" id="kobo.343.1"> is press </span><em class="italic"><span class="koboSpan" id="kobo.344.1">Tab</span></em><span class="koboSpan" id="kobo.345.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.346.1">Enter</span></em><span class="koboSpan" id="kobo.347.1">. </span><span class="koboSpan" id="kobo.347.2">However, if more formatting is done, it can go beyond explanation and have various possibilities, such as deriving documentation from code or reverse engineering table definitions from a database migration implementation, </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">for example.</span></span></p>
<p><span class="koboSpan" id="kobo.349.1">Code explanation </span><a id="_idIndexMarker816"/><span class="koboSpan" id="kobo.350.1">by AI significantly elevates the overall quality of code by enhancing its readability and understandability. </span><span class="koboSpan" id="kobo.350.2">This feature plays a crucial role in narrowing the gap between intricate code and comprehensive documentation, offering an automated solution to make code accessible and intelligible to a broad spectrum of developers. </span><span class="koboSpan" id="kobo.350.3">By saving time and facilitating better code maintenance and collaboration, this capability highlights the transformative influence of AI in the </span><span class="No-Break"><span class="koboSpan" id="kobo.351.1">coding process.</span></span></p>
<h1 id="_idParaDest-149"><a id="_idTextAnchor151"/><span class="koboSpan" id="kobo.352.1">Strategies for maximizing AI efficiency</span></h1>
<p><span class="koboSpan" id="kobo.353.1">In this section, we delve </span><a id="_idIndexMarker817"/><span class="koboSpan" id="kobo.354.1">into strategies aimed at boosting your mastery of AI tools within the realm of programming. </span><span class="koboSpan" id="kobo.354.2">By embracing an approach that emphasizes specificity, context awareness, and consistency, you will find significant enhancements in how you interact with AI, leading to streamlined coding processes and improved output quality. </span><span class="koboSpan" id="kobo.354.3">Specifically, offering clear, detailed instructions enhances the efficacy of AI tools, enabling them to better align with your expectations. </span><span class="koboSpan" id="kobo.354.4">A deep understanding and communication of the working context lead to more precise and applicable AI-generated suggestions. </span><span class="koboSpan" id="kobo.354.5">Furthermore, upholding a uniform coding style and adhering to established naming conventions greatly aid AI’s interpretation of your code, culminating in superior quality outcomes. </span><span class="koboSpan" id="kobo.354.6">These strategies collectively refine your engagement with AI, transforming it into a more efficient and effective partnership </span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">in programming.</span></span></p>
<p><span class="koboSpan" id="kobo.356.1">Moreover, I want to touch upon the iterative process of improving interactions with AI. </span><span class="koboSpan" id="kobo.356.2">This process involves </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">the following:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.358.1">Requesting a suggestion </span><span class="No-Break"><span class="koboSpan" id="kobo.359.1">from AI</span></span></li>
<li><span class="koboSpan" id="kobo.360.1">Reviewing the </span><span class="No-Break"><span class="koboSpan" id="kobo.361.1">results critically</span></span></li>
<li><span class="koboSpan" id="kobo.362.1">Making a decision to accept, reject, or manually adjust </span><span class="No-Break"><span class="koboSpan" id="kobo.363.1">the suggestion</span></span></li>
<li><span class="koboSpan" id="kobo.364.1">Applying the change or feedback for continuous </span><span class="No-Break"><span class="koboSpan" id="kobo.365.1">improvement (kaizen)</span></span></li>
</ol>
<p><span class="koboSpan" id="kobo.366.1">By keeping these three principles in mind at each phase of interaction with AI, you will foster a more productive and harmonious collaboration. </span><span class="koboSpan" id="kobo.366.2">These practices blend traditional software engineering principles with the innovative capabilities of AI, ensuring that your code remains both human-friendly and optimized for </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">AI assistance.</span></span></p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor152"/><span class="koboSpan" id="kobo.368.1">Be specific</span></h2>
<p><span class="koboSpan" id="kobo.369.1">The clarity and</span><a id="_idIndexMarker818"/><span class="koboSpan" id="kobo.370.1"> specificity of instructions play a crucial role in the effectiveness of </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">the tool.</span></span></p>
<p><span class="koboSpan" id="kobo.372.1">AI-powered coding tools are designed to respond to the nuances of the instructions provided by the developer. </span><span class="koboSpan" id="kobo.372.2">Their ability to generate useful and accurate code is greatly enhanced when the prompts or comments are specific and clear. </span><span class="koboSpan" id="kobo.372.3">The more detailed the instruction, the better the AI can understand the intended outcome. </span><span class="koboSpan" id="kobo.372.4">This understanding directly influences the relevance and accuracy of the code suggestions provided by the </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">AI tool.</span></span></p>
<p><span class="koboSpan" id="kobo.374.1">In the example of a vague prompt, a developer might instruct an AI with a statement such as “</span><em class="italic"><span class="koboSpan" id="kobo.375.1">Sort this list</span></em><span class="koboSpan" id="kobo.376.1">.” </span><span class="koboSpan" id="kobo.376.2">Such a prompt is unclear because it does not specify the contents of the list or how it should be sorted. </span><span class="koboSpan" id="kobo.376.3">The AI, faced with this ambiguity, might struggle to provide an accurate solution. </span><span class="koboSpan" id="kobo.376.4">However, when the instruction is more specific, such as “</span><em class="italic"><span class="koboSpan" id="kobo.377.1">Sort this list of integers in ascending order</span></em><span class="koboSpan" id="kobo.378.1">,” it becomes much clearer. </span><span class="koboSpan" id="kobo.378.2">This specific prompt gives the AI precise information about the type of data in the list, which is integers, and the desired sorting criterion, which is ascending order. </span><span class="koboSpan" id="kobo.378.3">With these details, the AI is better equipped to generate a more accurate and relevant piece of code, aligned with the </span><span class="No-Break"><span class="koboSpan" id="kobo.379.1">developer’s intent.</span></span></p>
<p><span class="koboSpan" id="kobo.380.1">The following two points can be considered to elicit </span><span class="No-Break"><span class="koboSpan" id="kobo.381.1">better results:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.382.1">Tailoring prompts to the task</span></strong><span class="koboSpan" id="kobo.383.1">: When using AI tools, it is important to tailor the prompts to the specific task at hand. </span><span class="koboSpan" id="kobo.383.2">This includes specifying data types, desired outcomes, constraints, and any other relevant details that could impact </span><span class="No-Break"><span class="koboSpan" id="kobo.384.1">code generation.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.385.1">Avoiding ambiguity</span></strong><span class="koboSpan" id="kobo.386.1">: Specific instructions help in avoiding ambiguity, ensuring that the AI tool does not misinterpret the task or provide irrelevant </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">code snippets.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.388.1">Being specific</span><a id="_idIndexMarker819"/><span class="koboSpan" id="kobo.389.1"> in instructions is a key best practice when working with AI tools in software development. </span><span class="koboSpan" id="kobo.389.2">Detailed prompts enable these tools to provide more accurate and useful code suggestions, thereby enhancing the efficiency and effectiveness of the development process. </span><span class="koboSpan" id="kobo.389.3">By focusing on clarity and precision in their interactions with AI, developers can harness the full potential of these tools, leading to more productive and successful </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">coding experiences.</span></span></p>
<h2 id="_idParaDest-151"><a id="_idTextAnchor153"/><span class="koboSpan" id="kobo.391.1">Be context-aware</span></h2>
<p><span class="koboSpan" id="kobo.392.1">Embracing context awareness is paramount. </span><span class="koboSpan" id="kobo.392.2">This approach not only enhances the efficiency with which tools are utilized but also improves the precision of information relayed to AI. </span><span class="koboSpan" id="kobo.392.3">Context awareness in software design entails being mindful of the boundaries that delineate work, systems, </span><span class="No-Break"><span class="koboSpan" id="kobo.393.1">and processes.</span></span></p>
<p><span class="koboSpan" id="kobo.394.1">The significance of recognizing these boundaries is highlighted when taking into account the inherent limitations of both humans and AI. </span><span class="koboSpan" id="kobo.394.2">Simply put, this underscores that both entities have a finite capacity for processing information and must operate within appropriate contexts to </span><span class="No-Break"><span class="koboSpan" id="kobo.395.1">function effectively.</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.396.1">Human limitations</span></strong><span class="koboSpan" id="kobo.397.1">: Humans have a cognitive threshold. </span><span class="koboSpan" id="kobo.397.2">When information overload occurs, selecting relevant information becomes challenging, leading to what is known as cognitive overload. </span><span class="koboSpan" id="kobo.397.3">By being mindful of one’s current context and processing information within limited contexts, humans can manage information more efficiently. </span><span class="koboSpan" id="kobo.397.4">Humans cannot provide AI with unlimited information, nor can they effectively sift through vast amounts of information received </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">from AI.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.399.1">AI limitations</span></strong><span class="koboSpan" id="kobo.400.1">: Similarly, AI has its own limits in recognition, primarily defined by the token limits of current models. </span><span class="koboSpan" id="kobo.400.2">Tokens, the smallest units recognized by AI, such as characters or words, have a numerical limit in AI models at the time of writing. </span><span class="koboSpan" id="kobo.400.3">While AI can continue to generate contextually appropriate information, the generation must eventually terminate to ensure the output remains accurate and as intended, necessitating an awareness of AI’s </span><span class="No-Break"><span class="koboSpan" id="kobo.401.1">performance boundaries.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.402.1">Here, I provide a </span><a id="_idIndexMarker820"/><span class="koboSpan" id="kobo.403.1">practical checklist of items for use during interactions with AI. </span><span class="koboSpan" id="kobo.403.2">This checklist is vital for ensuring effective collaboration with AI, focusing on the right context for your development efforts. </span><span class="koboSpan" id="kobo.403.3">Getting into the habit of thinking about this in every interaction with the AI will help you have </span><span class="No-Break"><span class="koboSpan" id="kobo.404.1">good interactions.</span></span></p>
<p><span class="koboSpan" id="kobo.405.1">Checklist for </span><a id="_idIndexMarker821"/><span class="koboSpan" id="kobo.406.1">every </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">AI interaction:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.408.1">Does AI know it? </span><span class="koboSpan" id="kobo.408.2">– Explicit context provision</span></strong><span class="koboSpan" id="kobo.409.1">: Check if the AI is already familiar with the context of your task. </span><span class="koboSpan" id="kobo.409.2">If your task ventures beyond AI’s pre-existing knowledge, provide additional, detailed context to bridge </span><span class="No-Break"><span class="koboSpan" id="kobo.410.1">the gap.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.411.1">Is AI Capable? </span><span class="koboSpan" id="kobo.411.2">– Assessing AI limits</span></strong><span class="koboSpan" id="kobo.412.1">: Verify that your expectations align with what AI, such as GPT-4, can realistically achieve. </span><span class="koboSpan" id="kobo.412.2">Understanding the capabilities and limitations, especially regarding token counts and context expansiveness, </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">is crucial.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.414.1">How to pass the info? </span><span class="koboSpan" id="kobo.414.2">– File and information check</span></strong><span class="koboSpan" id="kobo.415.1">: Ensure you are using the correct files and information with AI. </span><span class="koboSpan" id="kobo.415.2">For GitHub Copilot Chat, leveraging context variables such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">#file</span></strong><span class="koboSpan" id="kobo.417.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">#editor</span></strong><span class="koboSpan" id="kobo.419.1"> to specify the relevant context and using an agent feature such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.420.1">@workspace</span></strong><span class="koboSpan" id="kobo.421.1"> to expand context can enhance accuracy. </span><span class="koboSpan" id="kobo.421.2">Please verify the accuracy of your approach. </span><span class="koboSpan" id="kobo.421.3">The implementation of the specific tool is not covered here, but for GitHub Copilot, please refer to the documentation on the latest implementation in the </span><em class="italic"><span class="koboSpan" id="kobo.422.1">Further </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.423.1">reading</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.424.1"> section.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.425.1">How can I optimize It? </span><span class="koboSpan" id="kobo.425.2">– Quality management</span></strong><span class="koboSpan" id="kobo.426.1">: Evaluate and adjust the volume of text, characters, and data you are sending to AI. </span><span class="koboSpan" id="kobo.426.2">The goal is to optimize the amount of information—increasing what’s necessary and reducing what’s not—to </span><a id="_idIndexMarker822"/><span class="koboSpan" id="kobo.427.1">ensure quality </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">and efficiency.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.429.1">The importance of </span><a id="_idIndexMarker823"/><span class="koboSpan" id="kobo.430.1">being context-aware cannot be overstated—it involves providing information in just the right measure and utilizing prompts and coding techniques to convey intentions with precision. </span><span class="koboSpan" id="kobo.430.2">AI-powered development tools such as GitHub Copilot stand as aids for engineers, facilitating the provision of rich context to AI, thus enhancing the tool’s utility </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">and effectiveness.</span></span></p>
<p><span class="koboSpan" id="kobo.432.1">Reflecting on this, it becomes evident that applying these ideas to architecture and programming is not a new concept. </span><span class="koboSpan" id="kobo.432.2">This principle aligns with methodologies that have been in practice for a long time. </span><span class="koboSpan" id="kobo.432.3">By embracing a domain-driven development approach, one can engage in context-aware design. </span><span class="koboSpan" id="kobo.432.4">Additionally, the principle of loose coupling in architecture, which has been explored in various contexts, has evolved from language-specific domain separation to service-oriented architecture and further into </span><span class="No-Break"><span class="koboSpan" id="kobo.433.1">microservices architecture.</span></span></p>
<p><span class="koboSpan" id="kobo.434.1">In summary, incorporating a context-aware approach into AI-powered coding can be considered a good strategy in the era of AI software development. </span><span class="koboSpan" id="kobo.434.2">Ultimately, this approach boils down to adopting good, existing architectural practices that are loosely coupled, boundary-conscious, and user-friendly for humans. </span><span class="koboSpan" id="kobo.434.3">By focusing on the integration of comprehensive context, allowing AI tools to gain a richer understanding of the project, developers can enhance the precision and usefulness of AI-generated suggestions. </span><span class="koboSpan" id="kobo.434.4">This not only enables developers to more effectively handle AI but also makes it easier for anyone to navigate and utilize AI capabilities to their </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">fullest potential.</span></span></p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor154"/><span class="koboSpan" id="kobo.436.1">Be consistent</span></h2>
<p><span class="koboSpan" id="kobo.437.1">In an AI-enhanced </span><a id="_idIndexMarker824"/><span class="koboSpan" id="kobo.438.1">programming environment, maintaining a consistent coding style and adopting AI-readable naming conventions are pivotal. </span><span class="koboSpan" id="kobo.438.2">This section explores how these practices enhance interactions with AI-powered coding tools and contribute to better </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">code quality.</span></span></p>
<p><span class="koboSpan" id="kobo.440.1">A consistent coding style, encompassing aspects such as indentation, naming conventions, and comment writing, is essential in software development. </span><span class="koboSpan" id="kobo.440.2">It not only ensures code readability for human developers but also plays a significant role in how effectively AI-powered coding tools can interpret and </span><span class="No-Break"><span class="koboSpan" id="kobo.441.1">suggest code.</span></span></p>
<p><span class="koboSpan" id="kobo.442.1">For example, the following code in Python could be considered a </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">consistent code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.444.1">
def calculate_area(length, width):
    return length * width</span></pre> <p><span class="koboSpan" id="kobo.445.1">This example demonstrates a clear and consistent use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">snake_case</span></strong><span class="koboSpan" id="kobo.447.1"> naming and straightforward function naming, facilitating both human understanding and </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">AI interpretation.</span></span></p>
<p><span class="koboSpan" id="kobo.449.1">In contrast, the following code can be a bad example </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">for AI:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.451.1">
def calcSomething(l, w):
    # code goes here</span></pre> <p><span class="koboSpan" id="kobo.452.1">In this example, the inconsistent naming and lack of clarity might result in less effective suggestions from AI. </span><span class="koboSpan" id="kobo.452.2">If one were to try to complete this content with auto-completion, the AI might be able to give an accurate answer for a simple example such as this, but if there were countless such random, meaningless notations scattered throughout the code base, mistakes could </span><span class="No-Break"><span class="koboSpan" id="kobo.453.1">be made.</span></span></p>
<p><span class="koboSpan" id="kobo.454.1">AI’s capability to interpret both natural and programming languages suggests that it reads code not only in its technical syntax but also as a form of natural language. </span><span class="koboSpan" id="kobo.454.2">This underscores the importance of clear and meaningful naming conventions in programming. </span><span class="koboSpan" id="kobo.454.3">By naming variables and functions in a way that is easily understandable, developers not only aid human comprehension but also enhance the ability of AI models to accurately discern the purpose and context of </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">the code.</span></span></p>
<p><span class="koboSpan" id="kobo.456.1">For example, effective AI-readable naming conventions involve using specific and descriptive names for variables and functions. </span><span class="koboSpan" id="kobo.456.2">This practice extends beyond just aiding human collaborators; it allows AI tools to interpret code with higher accuracy. </span><span class="koboSpan" id="kobo.456.3">Such clarity in naming is beneficial in reducing the ambiguity that might otherwise lead to inaccurate or irrelevant code suggestions by </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">AI systems.</span></span></p>
<p><span class="koboSpan" id="kobo.458.1">Concreteness and context are crucial. </span><span class="koboSpan" id="kobo.458.2">Avoid generic names and strive to provide clear context, which can be achieved through methods such as type hinting or adding explanatory comments. </span><span class="koboSpan" id="kobo.458.3">These practices significantly enhance the precision of AI-generated suggestions, leading to more relevant and functional </span><span class="No-Break"><span class="koboSpan" id="kobo.459.1">code outputs.</span></span></p>
<p><span class="koboSpan" id="kobo.460.1">At this stage, it </span><a id="_idIndexMarker825"/><span class="koboSpan" id="kobo.461.1">is clear that code that is easily understandable by AI is also inherently more comprehensible to humans. </span><span class="koboSpan" id="kobo.461.2">In essence, the advent of AI in coding does not always necessitate a reinvention of best practices in software engineering. </span><span class="koboSpan" id="kobo.461.3">The principles outlined in respected resources like O’Reilly’s </span><em class="italic"><span class="koboSpan" id="kobo.462.1">The Art of Readable Code: Simple and Practical Techniques for Writing Better Code</span></em><span class="koboSpan" id="kobo.463.1"> remain relevant and applicable in the AI era. </span><span class="koboSpan" id="kobo.463.2">Maintaining these tried and tested practices ensures that code remains accessible and understandable, both for human collaborators and </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">AI tools.</span></span></p>
<h1 id="_idParaDest-153"><a id="_idTextAnchor155"/><span class="koboSpan" id="kobo.465.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.466.1">AI can help you code. </span><span class="koboSpan" id="kobo.466.2">However, you may have noticed that no matter how advanced AI gets, the approach to coding does not really change much. </span><span class="koboSpan" id="kobo.466.3">All you have to do is be the great engineer that you always have been. </span><span class="koboSpan" id="kobo.466.4">Additionally, using AI well will help you improve </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">your skills.</span></span></p>
<p><span class="koboSpan" id="kobo.468.1">AI will do more than you expect if you approach things with curiosity, so let’s work with AI to create a great future, and I hope this chapter will give you </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">a hint.</span></span></p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor156"/><span class="koboSpan" id="kobo.470.1">Further reading</span></h1>
<ul>
<li><em class="italic"><span class="koboSpan" id="kobo.471.1">GitHub Copilot optimization with prompt crafting and context </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.472.1">setting</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.473.1"> (</span></span><a href="https://code.visualstudio.com/docs/copilot/prompt-crafting"><span class="No-Break"><span class="koboSpan" id="kobo.474.1">https://code.visualstudio.com/docs/copilot/prompt-crafting</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.475.1">)</span></span></li>
<li><em class="italic"><span class="koboSpan" id="kobo.476.1">The Art of Readable Code: Simple and Practical Techniques for Writing Better Code</span></em><span class="koboSpan" id="kobo.477.1"> by Dustin Boswell and Trevor </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">Foucher (</span></span><a href="https://www.oreilly.com/library/view/the-art-of/9781449318482/"><span class="No-Break"><span class="koboSpan" id="kobo.479.1">https://www.oreilly.com/library/view/the-art-of/9781449318482/</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.480.1">)</span></span></li>
</ul>
</div>
</body></html>