- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Benefits of Cloud Native and Common Misunderstandings
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云原生的好处和常见误解
- en: Several thousand years ago, households had to dig and build wells, draw water
    from rivers, or set up rain barrels to collect water. They had to manage the filtration
    and purification to ensure water was safe for drinking and other uses, and they
    had to maintain that infrastructure. Water supply turned into a commodity by centralized
    municipal water systems. Users can now access clean water through a faucet and
    pay for the amount they use.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 几千年前，家庭需要挖掘并建设水井，从河流中取水，或者搭建雨水收集桶来收集水源。他们需要管理水的过滤和净化，以确保水是安全的，适合饮用及其他用途，并且需要维护这些基础设施。通过集中式市政供水系统，水供应成为了一种商品。现在，用户只需通过水龙头即可获取干净的水，并按使用量付费。
- en: Similarly, **cloud native** commoditizes information technology aspects that
    we had to manage in the past. It can enable the simplification of solution architectures
    and operational complexity. It can also make securing our applications easier
    and help us meet regulatory goals. This commoditization aspect can make it easier
    to manage and refresh our data. The word *can* was used on purpose in the previous
    sentences. All four authors have worked for professional service organizations
    focusing on cloud technology. The cloud provides significant new opportunities,
    but we must understand the risks, anti-patterns, and how to mitigate them. Despite
    the huge potential that cloud native brings, we have seen many things going mindbogglingly
    wrong. That includes accidental deletion of entire environments, and leaking secrets,
    and the core part of the book will focus on that. Quite often, we were involved
    in remediating those applications or helping customers with security breaches
    or data losses. Of course, other times, we were working on greenfield solutions
    and could help to stay away from anti-patterns.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，**云原生**使得我们过去需要管理的信息技术方面变得商品化。它可以简化解决方案架构和运营复杂性，也可以使得应用程序的安全更容易，帮助我们实现合规目标。这种商品化的特性可以让我们更轻松地管理和更新数据。在之前的句子中故意使用了*can*一词。所有四位作者都曾在专注于云技术的专业服务机构工作。云技术提供了重大的新机会，但我们必须理解其中的风险、反模式，以及如何降低这些风险。尽管云原生带来了巨大的潜力，但我们也看到了许多令人难以置信的问题。这包括整个环境的意外删除、秘密泄露等，书中的核心部分将聚焦于此。我们经常参与修复这些应用程序，或帮助客户解决安全漏洞和数据丢失问题。当然，也有时我们参与的是绿地解决方案的工作，能够帮助避免反模式。
- en: 'The goal of this book is to help steer away from these anti-patterns, remediate
    them, and move toward best practices. In this chapter, we will lay out the foundations.
    The following chapters will build on top of that gained knowledge. Therefore,
    it is important to digest the information in this chapter, which includes the
    following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的目标是帮助我们远离这些反模式，修复它们，并朝着最佳实践迈进。在本章中，我们将阐述基础内容，后续章节将在此基础上扩展。因此，理解本章中的信息至关重要，其中包括以下内容：
- en: The evolution of cloud native
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云原生的演变
- en: The benefits of cloud native
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云原生的好处
- en: DevSecOps culture, IaC, and CI/CD
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DevSecOps文化、基础设施即代码（IaC）和持续集成/持续交付（CI/CD）
- en: Observability and resilience
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可观察性和弹性
- en: Common misunderstandings
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见的误解
- en: The evolution of cloud native
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云原生的演变
- en: Cloud native did not occur overnight. Many events contributed to this paradigm
    change. Let’s examine the history and explore key concepts that will help us understand
    cloud native. Why is it considered necessary today? How did we get here? Did we
    learn from the past? Here is a fast-forward list of the critical historical events
    influencing what we now know as cloud native. We are looking at it in chronological
    order. Therefore, we will be jumping between hardware, software, and design paradigms.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生并非一夜之间发生的。许多事件促成了这一范式的变化。让我们回顾一下历史，探讨一些关键概念，这将帮助我们理解云原生。为什么它在今天被认为是必需的？我们是如何走到今天的？我们从过去中学到了什么？以下是影响我们现在所知的云原生的关键历史事件的快速回顾。我们将按时间顺序来审视这些事件，因此，我们会穿梭于硬件、软件和设计范式之间。
- en: The foundations for ML, AI, and cross-functional teams
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 机器学习、人工智能和跨职能团队的基础
- en: '**Machine learning** (**ML**) and **artificial intelligence** (**AI**) are
    nowadays often used when discussing cloud native, and various **cloud service
    providers** (**CSPs**) provide many prepackaged ML and AI services. The history
    goes a long way back.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**机器学习**（**ML**）和**人工智能**（**AI**）如今在讨论云原生时经常被提及，许多**云服务提供商**（**CSPs**）提供了许多预打包的ML和AI服务。这一历史可以追溯很久。'
- en: In 1950, an English mathematician, Alan Turing, published the paper *Computing
    Machinery and Intelligence*, proposing the Turing test as a criterion for machine
    intelligence. American scientists and researchers coined the term *AI* in their
    proposal for the Dartmouth conference in 1956.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 1950年，英国数学家艾伦·图灵发表了论文*计算机器与智能*，提出了图灵测试作为衡量机器智能的标准。美国科学家和研究人员在1956年达特茅斯会议的提案中创造了*人工智能*（AI）这一术语。
- en: Many see virtualization as a major foundational step toward cloud native development.
    It started in the 1960s when IBM released the Control Program/Cambridge Monitor
    System. It enabled the division of hardware components. For example, several **virtual
    machines** (**VMs**) running on a physical computer can use the same physical
    processors and memory. VMs allow multiple users to share hardware resources.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人将虚拟化视为迈向云原生开发的一个重要基础性步骤。虚拟化始于1960年代，当时IBM发布了控制程序/剑桥监控系统。这一系统使硬件组件的划分成为可能。例如，多个**虚拟机**（**VMs**）可以在一台物理计算机上运行，共享相同的物理处理器和内存。虚拟机允许多个用户共享硬件资源。
- en: 'In 1967, Melvin Edward Conway developed a theory named “Conway’s Law.” It describes
    how designers of software components that interact with each other also have to
    communicate with each other. Conway summarized this behavior with the following
    quote: “*Organizations which design systems (in the broad sense used here) are
    constrained to produce designs which are copies of the communication structures
    of these organizations.*” This is a significant finding that influences how we
    structure teams nowadays. We use terminology such as squads, agile teams, and
    DevOps. We know that we have to set up cross-functional teams and excel in collaboration
    to deliver cloud-friendly solutions.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 1967年，梅尔文·爱德华·康威提出了一种名为“康威定律”的理论。该理论描述了互相交互的软件组件的设计师们必须互相沟通的现象。康威用以下名言总结了这种行为：“*设计系统的组织（在此广义上所用）被约束于产生这些组织沟通结构的设计的复制品。*”这是一个重要的发现，影响了我们今天如何构建团队。我们使用诸如小组、敏捷团队和DevOps这样的术语。我们知道，必须建立跨职能团队，并在协作中表现出色，以交付适合云计算的解决方案。
- en: The age of virtualization
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟化时代
- en: IBM continued developing further enhancements in 1980\. However, the market
    was not ready yet for a wide commercial adoption of VMs. Personal computers became
    popular in the 1980s, slowing down the VM market. It was only in the late 1990s
    that VMs went mainstream. One of the market leaders was VMware.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: IBM在1980年继续开发进一步的增强功能。然而，当时市场还没有准备好广泛商用虚拟机。个人计算机在1980年代开始流行，减缓了虚拟机市场的发展。直到1990年代末，虚拟机才开始成为主流。VMware是市场的领导者之一。
- en: The beginning of distributed applications
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分布式应用的开始
- en: A new design paradigm, **service-oriented architecture** (**SOA**), emerged.
    It introduced the concept of services and promoted reusability. SOA is often seen
    as a precursor to micro-services. At the same time, a little bookshop called Amazon
    realized that they needed to change their architecture to scale it in a way that
    makes it future-proof. An intelligent group of Amazon engineers released the internally
    published *Distributed Computing Manifesto*, which explained that the architecture
    of our application needs to scale to manage a demand 10 times the current size
    of what it was back then. The paper called out that applications should not be
    tightly coupled. It explained a service-based model. It also proposed a three-tier
    architecture to separate the presentation layer (also called client or application),
    business logic, and data.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一种新的设计范式——**面向服务架构**（**SOA**）应运而生。它引入了服务的概念并推动了可重用性。SOA常被视为微服务的前身。与此同时，一家名为亚马逊的小书店意识到，他们需要改变架构，以一种具有未来保障的方式进行扩展。亚马逊的一群聪明工程师发布了内部出版的*分布式计算宣言*，解释了我们的应用架构需要能够扩展，以应对比当时规模大10倍的需求。该论文指出，应用程序不应紧密耦合。它解释了基于服务的模型，并提出了一种三层架构，分别用于表示层（也称为客户端或应用）、业务逻辑和数据。
- en: It also described that synchronization should be used when an immediate response
    is required. Asynchronous calls can be used for workflows where an immediate outcome
    is not required. The workflow only needs to move to the next stage. Asynchronous
    API calls made perfect sense for Amazon’s order processes. **Amazon Web Services**
    (**AWS**) launched years later as a new brand. The first web services were released
    for public consumption. The first public launch was a message queuing service
    called **Simple Queue** **Service** (**SQS**).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 它还描述了在需要立即响应时应使用同步操作。对于不要求立即结果的工作流，可以使用异步调用。工作流只需推进到下一阶段。异步 API 调用在亚马逊的订单处理流程中显得非常合理。**Amazon
    Web Services** (**AWS**) 在几年后以新品牌推出。第一个公共 web 服务发布，首次公开推出的是一个名为 **Simple Queue**
    **Service** (**SQS**) 的消息队列服务。
- en: The philosophy of queuing aligned perfectly with the *Distributing Computing
    Manifesto*. **Elastic Cloud Compute** (**EC2**), a virtualization service, and
    the blob storage service called **Simple Storage Service** (**S3**) were released
    next. S3 was a very significant milestone in the evolution of cloud native history.
    In 2000, Roy Fielding defined REST architectures in his PhD dissertation *Architectural
    Styles and the Design of Network-based Software Architectures*. REST is designed
    for scalable client-server applications. REST suggests that the coupling between
    the client and the origin server must be as loose as possible. Within the context
    of REST APIs, “stateless” means that each request from a client to a server must
    contain all the information needed to understand and process the request, without
    relying on any stored context on the server. This ensures that the server does
    not retain any session state between requests, allowing for scalability and reliability.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 队列哲学与 *分布式计算宣言* 完美契合。**Elastic Cloud Compute** (**EC2**) 作为虚拟化服务，以及名为 **Simple
    Storage Service** (**S3**) 的 Blob 存储服务接踵而至。S3 成为云原生历史演进中的一个重要里程碑。2000 年，Roy Fielding
    在其博士论文 *网络基础软件架构的架构风格与设计* 中定义了 REST 架构。REST 旨在支持可扩展的客户端-服务器应用程序。REST 提出，客户端与源服务器之间的耦合应尽可能松散。在
    REST API 的上下文中，“无状态”意味着从客户端到服务器的每个请求都必须包含所有必要的信息，以便理解和处理该请求，而不依赖于服务器上存储的任何上下文。这确保了服务器在请求之间不会保留任何会话状态，从而实现可扩展性和可靠性。
- en: The rise of Agile, DevOps, and the cloud
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 敏捷、DevOps 和云的崛起
- en: In 2001, 17 software engineers gathered in Utah to outline values and principles
    for agile software development. Some of those engineers became famous software
    development advocates, including Alistair Cockburn, Martin Fowler, and Kent Beck.
    As a result of this get-together, they created the *Manifesto for Agile Software
    Development*, often called the *Agile Manifesto*. It highlights the importance
    of individuals and collaboration within software development engineering teams
    and with customers to deliver better software more efficiently. The collaboration
    aspects address some of the problems described in Conway’s Law. That cross-functional
    team approach is still embedded in most agile delivery frameworks.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 2001 年，17 名软件工程师在犹他州聚集，制定了敏捷软件开发的价值观和原则。这些工程师中的一些人成为了著名的敏捷开发倡导者，包括阿里斯泰尔·科克本、马丁·福勒和肯特·贝克。通过这次聚会，他们创建了
    *敏捷软件开发宣言*，通常被称为 *敏捷宣言*。该宣言强调了在软件开发工程团队和客户之间，个人和协作的重要性，以更高效地交付更好的软件。协作方面解决了在康威定律中描述的一些问题。这种跨职能团队的方式至今仍然嵌入大多数敏捷交付框架中。
- en: '**Google Cloud Platform** (**GCP**) and Microsoft’s Azure cloud platform were
    launched in 2008\. In the same year, Google released App Engine, one of the first
    serverless computing offerings. It included HTTP functions with a 60-second timeout
    and a blob store and data store with timeouts.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**Google Cloud Platform** (**GCP**) 和微软的 Azure 云平台于 2008 年推出。就在同一年，谷歌发布了 App
    Engine，这是最早的无服务器计算服务之一。它包括带有 60 秒超时的 HTTP 函数以及带有超时设置的 Blob 存储和数据存储。'
- en: The need for collaboration emerged even more during this decade, and software
    industry experts pointed out the problems that result from separating development
    and operations.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一十年中，合作的需求变得愈加明显，软件行业的专家指出了将开发与运维分开所带来的问题。
- en: The term *DevOps* was coined. The first DevOpsDays conference took place in
    Belgium in 2009\. In its early days, DevOps focused on **continuous integration/continuous
    delivery** (**CI/CD**) and infrastructure automation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '*DevOps* 这个术语应运而生。第一届 DevOpsDays 大会于 2009 年在比利时举行。在最初的阶段，DevOps 关注的是 **持续集成/持续交付**
    (**CI/CD**) 和基础设施自动化。'
- en: Edge computing – microservices, and addressing security
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 边缘计算——微服务，以及解决安全问题
- en: In 2010, **edge computing** gained significance, especially within the **Internet
    of Things** (**IoT**). Edge computing is an extension of the cloud. It brings
    the entry points to cloud infrastructure closer to the consumer. Some of the key
    benefits are latency reduction and increased resilience and reliability. The use
    case of edge computing has evolved since then. For example, content can be cached
    closer to the end user. This caching approach is known as a **content distribution
    network** (**CDN**). Well-known CDN solutions are provided by Cloudflare, Akamai,
    and the three major cloud platforms (AWS, GCP, and Azure).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 2010年，**边缘计算**变得越来越重要，尤其是在**物联网**（**IoT**）领域。边缘计算是云计算的扩展，它将云基础设施的入口点更接近消费者。一些关键的好处包括延迟减少以及提高系统的韧性和可靠性。边缘计算的使用场景自那时以来发生了变化。例如，内容可以被缓存到离最终用户更近的地方。这种缓存方法被称为**内容分发网络**（**CDN**）。知名的CDN解决方案由Cloudflare、Akamai和三大云平台（AWS、GCP和Azure）提供。
- en: In 2011, the term *microservices* gained popularity in the software engineering
    community. Microservices enhance SOA with a strong focus on continuous incremental
    change and lightweight communication between services and endpoints. Sometimes,
    people use the term microservices interchangeably with the term *cloud native*.
    We will talk more about that when we explore common misunderstandings.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 2011年，*微服务*一词在软件工程界流行起来。微服务通过强烈关注持续增量变更以及服务和端点之间的轻量级通信，增强了面向服务架构（SOA）。有时，人们将*微服务*与*云原生*这两个术语交替使用。我们将在探讨常见误解时深入讨论这一点。
- en: Engineers at Heroku also developed the 12-Factor App methodology during that
    time. The 12-Factor App principles provide best practice guidance for building
    scalable and maintainable **software as a service** (**SaaS**) applications. They
    emphasize a declarative setup, a clean contract with the underlying operating
    system, and maximum portability between execution environments. Some key principles
    include managing configuration separately from code, treating backing services
    as attached resources, and strict separation of build, release, and run stages.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Heroku的工程师在那个时期还开发了12-Factor App方法论。12-Factor App原则为构建可扩展和可维护的**软件即服务**（**SaaS**）应用程序提供了最佳实践指导。它们强调声明式配置、与底层操作系统的清晰契约，以及在执行环境之间的最大可移植性。一些关键原则包括将配置与代码分开管理，将后端服务视为附加资源，以及严格分离构建、发布和运行阶段。
- en: Between 2012 and 2013, the term *DevSecOps* was mentioned more and more. It
    was seen as an extension of DevOps. DevSecOps advocates embedding security early
    in the software development process, automating security testing, and embracing
    a culture of shared security responsibility among teams.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在2012至2013年之间，*DevSecOps*一词被越来越多地提及。它被视为DevOps的扩展。DevSecOps提倡在软件开发过程中尽早嵌入安全性，自动化安全测试，并在团队之间倡导共享安全责任的文化。
- en: Containers and function as a service
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器和功能即服务
- en: In 2013, Docker containers were released. The main difference between VMs and
    containers is that VMs provide an abstracted version of the entire hardware of
    a physical machine, including the CPU, memory, and storage. On the other hand,
    containers are portable instances of software. Containers are unaware of other
    processes running on the host operating system.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 2013年，Docker容器发布。虚拟机（VMs）和容器之间的主要区别在于，虚拟机提供了物理机器整个硬件的抽象版本，包括CPU、内存和存储。另一方面，容器是软件的便携实例。容器无法感知主机操作系统上运行的其他进程。
- en: Google released Kubernetes about a year later, which is a container orchestration
    platform. Kubernetes is still widely used for scaling containers, container management,
    scalability, and automated deployments.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Google大约一年后发布了Kubernetes，它是一个容器编排平台。Kubernetes至今仍广泛用于容器的扩展、容器管理、可扩展性和自动化部署。
- en: The first **function as a service** (**FaaS**) capability was released in 2014\.
    AWS released Lambda functions. Later, other CSPs adopted FaaS, such as Microsoft
    with Azure Functions and GCP with Google Cloud Functions. FaaS provides a fully
    managed runtime where we only need to manage our code. This was a fundamental
    shift that allowed DevSecOps practitioners to fully focus on the work that distinguishes
    their organization from others, including application code, and architectural
    design. We only pay while the function is running, and there is zero cost when
    the function is not being invoked.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个**函数即服务**（**FaaS**）功能是在2014年发布的。AWS发布了Lambda函数。后来，其他CSP也采纳了FaaS，如Microsoft的Azure
    Functions和GCP的Google Cloud Functions。FaaS提供一个完全托管的运行时环境，我们只需要管理我们的代码。这是一个根本性的转变，使得DevSecOps从业人员能够专注于区分他们组织与其他组织的工作，包括应用程序代码和架构设计。我们只需在函数运行时付费，当函数未被调用时没有任何费用。
- en: The concept of service meshes was also introduced during that time, which are
    a dedicated infrastructure layer for monitoring, managing, and securing network
    communication between microservices in a cloud native application.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 服务网格的概念也是在那时引入的，它是一个专门的基础设施层，用于监控、管理和保护云原生应用程序中微服务之间的网络通信。
- en: Cloud native and best practices
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 云原生和最佳实践
- en: The **Cloud Native Computing Foundation** (**CNCF**) is a Linux Foundation project
    that started in 2015\. Two years later, in 2017, Google, IBM, and Lyft open-sourced
    the popular service mesh implementation Istio.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**云原生计算基金会**（**CNCF**）是一个Linux基金会项目，始于2015年。两年后，在2017年，Google、IBM和Lyft开源了流行的服务网格实现Istio。'
- en: In 2018, researchers at the **National Institute of Standards and Technology**
    (**NIST**) and the **National Cyber Security Center of Excellence** (**NCCoE**)
    published the **Zero Trust Architecture** (**ZTA**) framework. It describes a
    “never trust, always verify” approach. This requires strict identity verification
    for every device and human attempting to access resources, regardless of location
    within or outside the network. ZTA is now increasingly becoming more important
    in cloud native architectures. It is seen as a robust approach to reduce the risk
    of data breaches and enforce the least privileged access approach.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 2018年，**国家标准与技术研究院**（**NIST**）和**国家网络安全卓越中心**（**NCCoE**）的研究人员发布了**零信任架构**（**ZTA**）框架。它描述了一种“永不信任，总是验证”的方法。这要求对每个尝试访问资源的设备和人员进行严格的身份验证，无论其位于网络内部还是外部。ZTA现在在云原生架构中变得越来越重要。它被视为减少数据泄露风险并执行最小特权访问方法的可靠方式。
- en: OpenTelemetry is an open source observability framework. It was created in 2019
    when CNCF merged the two projects, OpenCensus and OpenTracing. Its purpose is
    to collect traces, metrics, and telemetry data. OpenTelemetry is commonly used
    to monitor microservices and other distributed applications.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTelemetry是一个开源的可观察性框架。它是在2019年CNCF合并了OpenCensus和OpenTracing两个项目时创建的。它的目的是收集追踪、指标和遥测数据。OpenTelemetry通常用于监控微服务和其他分布式应用程序。
- en: The FinOps Foundation was established in 2019 and became a project of the Linux
    Foundation in 2020\. It is dedicated to “*advancing people who practice the discipline
    of cloud financial management through best practices, education,* *and standards.*”
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: FinOps基金会于2019年成立，并在2020年成为Linux基金会的一个项目。它致力于“*通过最佳实践、教育和标准，推动实践云财务管理学科的人群。*”
- en: Between 2020 and 2012, GitOps evolved from DevOps. It is a practice for CD using
    Git, a distributed version control system, as a source of truth for infrastructure
    and application configuration.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在2020到2012年间，GitOps从DevOps演变而来。它是一种使用Git（分布式版本控制系统）作为基础设施和应用配置的真实来源的CD实践。
- en: In 2023, **Open Policy Agent** (**OPA**) emerged as a security framework in
    the Kubernetes community. It addresses several use cases, including authorization
    of REST API endpoint calls, integrating custom authorization logic into applications,
    and a policy-as-code framework for cloud infrastructure pipelines. It had previously
    been a CNCF incubating project.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 2023年，**Open Policy Agent**（**OPA**）作为一个安全框架出现在Kubernetes社区中。它解决了多个使用案例，包括REST
    API端点调用的授权、将自定义授权逻辑集成到应用程序中，以及为云基础设施管道提供基于代码的策略框架。它此前是一个CNCF孵化项目。
- en: Also in 2023, the trend of ML and AI integration emerged. The major CSPs released
    their managed services, including Google’s AI Platform, Amazon SageMaker, and
    Azure ML.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 同样在2023年，ML和AI集成的趋势开始出现。主要的CSP发布了他们的托管服务，包括Google的AI平台、Amazon SageMaker和Azure
    ML。
- en: Where are we now and what does the future bring?
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们现在处于什么阶段，未来将带来什么？
- en: Many of the described frameworks and best practices continued to trend through
    2024\. One of the biggest trends is embedded AI services for productivity, operations,
    and security. Let’s go through some examples before we move to the benefits of
    cloud native.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 许多描述的框架和最佳实践将在2024年继续流行。最大的趋势之一是嵌入式AI服务，涵盖生产力、运维和安全性。在讨论云原生的好处之前，让我们先来看一些例子。
- en: '**AI for operations** (**AIOps**) provides predictive insights, anomaly detection,
    and automated responses. **Cloud native application protection platform** (**CNAPP**)
    solutions are taking the world by storm. They provide holistic protection and
    compliance validation throughout the **software development life cycle** (**SDLC**),
    from development to operations. Chatbots and other generative AI services that
    assist developers and improve their productivity are also rapidly becoming popular.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**运维中的AI**（**AIOps**）提供预测性洞察、异常检测和自动化响应。**云原生应用保护平台**（**CNAPP**）解决方案正席卷全球。它们在**软件开发生命周期**（**SDLC**）的各个阶段，从开发到运维，提供全面的保护和合规性验证。帮助开发人员并提高生产力的聊天机器人和其他生成式AI服务也在迅速流行。'
- en: The AI trend includes technologies such as ChatGPT by OpenAI, Microsoft’s GitHub
    Copilot, AWS Code Whisperer, Amazon Q, and Google’s Cloud AI and Vertex AI. There
    are legal concerns regarding generative AI services. One concern is that our sensitive
    data could be used to train the AI model. The main concerns are whether the data
    could become visible to a third party and whether the data remains within our
    region, which might be required for compliance reasons. Another concern is intellectual
    property ownership. Who owns the result if the generative AI service generates
    foundational parts, and a human enhances that generated outcome? Different jurisdictions
    have different laws, and there are often gray areas because this is a fairly new
    concern. Discussions about these concerns will continue for quite some time.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: AI趋势包括OpenAI的ChatGPT、微软的GitHub Copilot、AWS Code Whisperer、Amazon Q和谷歌的Cloud
    AI与Vertex AI等技术。关于生成式AI服务存在法律方面的顾虑。其中一个问题是我们的敏感数据可能会被用来训练AI模型。主要的顾虑是数据是否会暴露给第三方，以及数据是否会保留在我们的地区，这可能是合规性要求。另一个问题是知识产权归属。如果生成式AI服务生成了基础部分，而人类对该生成结果进行了增强，结果的归属应该归谁？不同的法域有不同的法律，而且由于这是一个相对较新的问题，常常存在灰色地带。这些问题的讨论可能会持续一段时间。
- en: We now have a good understanding of significant events that contributed to what
    we now understand as cloud native. But what are the actual benefits of cloud native
    and why is it so significant for modern architectures? We will explore that in
    the next section.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对促成云原生概念的重要事件有了较为清晰的认识。但云原生的实际好处是什么？为什么它对现代架构如此重要？我们将在下一部分进行探讨。
- en: Benefits of cloud native
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 云原生的好处
- en: 'What is cloud native? There are many different definitions, and for the context
    of this book, we will go with the definition of the CNCF:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是云原生？有很多不同的定义，针对本书的上下文，我们将采用CNCF的定义：
- en: “*Cloud native technologies, also called the cloud native stack, are the technologies
    used to build cloud native applications. These technologies enable organizations
    to build and run scalable applications in modern and dynamic environments such
    as public, private, and hybrid clouds while fully leveraging cloud computing benefits.
    They are designed from the ground up to exploit the capabilities of cloud computing,
    and containers, service meshes, microservices, and immutable infrastructure exemplify*
    *this approach.*”
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: “*云原生技术，也称为云原生技术栈，是用来构建云原生应用的技术。这些技术使得组织能够在现代和动态的环境中，如公共云、私有云和混合云，构建和运行可扩展的应用，同时充分利用云计算的优势。它们从一开始就设计用来发挥云计算的能力，容器、服务网格、微服务和不可变基础设施体现了*
    *这一方法。*”
- en: According to Gartner the term “cloud native” is an approach that “refers to
    something created to optimally leverage or implement cloud characteristics.” The
    key phrase here is “*optimally leverage or implement cloud characteristics*.”
    This area is exactly where we have seen many large organizations go wrong. Quite
    often, they treat the cloud the same as their data centers. We will dive into
    that in the following chapters when we go through anti-patterns in detail.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Gartner的说法，“云原生”这一术语指的是“旨在最佳利用或实现云特性的做法”。这里的关键短语是“*最佳利用或实现云特性*”。这一领域恰恰是我们看到许多大型组织出错的地方。很多时候，他们将云当作与他们数据中心相同的东西来处理。我们将在接下来的章节中深入探讨这一点，详细介绍反模式。
- en: Faster time to market
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更快的市场时间
- en: 'Let’s start with the first key benefit: *faster time to market*. It is one
    of the key drivers and the reason why so many start-ups have commenced using cloud
    native services. Those start-ups started without legacy systems and needed to
    show outcomes quickly to get venture capital and generate income streams for growth.
    Developers can leverage self-service provisioning of resources, saving them a
    lot of time compared to traditional mechanisms where they had to request infrastructure
    to be provisioned.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个关键好处开始：*更快的市场时间*。这是许多初创公司开始使用云原生服务的关键驱动因素之一。那些初创公司没有遗留系统，需要快速展示成果，以获得风险投资并创造增长收入流。开发者可以利用自助式资源供应，相比于传统机制需要请求基础设施部署的方式，这节省了大量时间。
- en: With a cloud native approach, they can quickly create new environments or serverless
    functions. Depending on the resource type, the provisioning might take seconds
    or minutes. Database provisioning usually takes several minutes, whereas blob
    storage, such as an Amazon S3 bucket or FaaS, can be deployed within seconds.
    This helps to achieve a quicker time-to-market goal. It also helps for quicker
    innovation cycles. If we want to perform a proof of concept to compare the productivity
    using differing programming languages, using FaaS will save a lot of time because
    the runtimes are already pre-provisioned by our CSP. It is easy to try out some
    functions in Golang, and others in Rust or Java. Provisioning and decommissioning
    are a minimal effort and developers can focus on the application development without
    any waiting times.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 采用云原生方法，他们可以快速创建新的环境或无服务器功能。根据资源类型，供应可能需要几秒钟或几分钟。数据库供应通常需要几分钟，而像Amazon S3桶或FaaS这样的Blob存储可以在几秒钟内部署。这有助于实现更快的市场时间目标，也有助于更快的创新周期。如果我们想进行概念验证，比较使用不同编程语言的生产力，使用FaaS可以节省大量时间，因为运行时已经由我们的CSP预先配置。尝试在Golang中运行一些函数，或在Rust或Java中运行其他函数非常简单。供应和退役的工作量很小，开发人员可以专注于应用程序开发，而不需要等待。
- en: Scalability and elasticity
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可扩展性和弹性
- en: Scalability and elastic infrastructure are other benefits. Applications can
    easily scale up and down on demand. Cloud native architectures typically leverage
    horizontal scaling over vertical scaling. This is a big advantage for applications
    with significant peaks, such as shopping websites or payment applications. They
    need to scale up during day peak times or seasonal peaks. Once the traffic spike
    decreases, we can automatically scale back the underlying infrastructure.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 可扩展性和弹性基础设施是其他好处。应用程序可以根据需求轻松地扩展或缩减。云原生架构通常利用水平扩展而非垂直扩展。这对于流量有显著波动的应用程序，如购物网站或支付应用程序，是一个很大的优势。它们需要在白天的高峰时段或季节性高峰时段进行扩展。一旦流量激增减少，我们可以自动缩减底层基础设施。
- en: This is very different from traditional on-premises deployments, where we need
    to permanently provision for the absolute highest traffic volume to avoid outages.
    The cloud infrastructure is elastic. So is the pricing model to some degree. For
    instance, if we dispose of a compute instance after a scaling event, we are not
    being charged for it anymore. However, if we store data without deleting it, we
    continue paying storage fees.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这与传统的本地部署方式有很大的不同，在传统方式中，我们需要永久性地为最高的流量量预留资源以避免停机。而云基础设施是弹性的，定价模型在某种程度上也是如此。例如，如果我们在扩展事件后处置计算实例，我们将不再为其付费。然而，如果我们存储数据却没有删除它，我们仍然需要支付存储费用。
- en: Managed services
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理服务
- en: Managed services are managed by the CSP. They improve the operational efficiency
    for customers and reliability and availability. Therefore, they are a significant
    advantage in cloud native architectures. The CSP manages the underlying infrastructure
    of managed services. Depending on the service, that may include the application
    itself, such as a queuing or notification application. This includes the provisioning,
    configuration, maintenance, and network constructs. If we use a managed relational
    database service such as Amazon **Relational Database Service** (**RDS**), Microsoft
    Azure Database, or a Google Cloud database, the CSP manages the patching and upgrading
    of the underlying infrastructure, including the database engine. Managed database
    services also implement security and compliance with industry regulations up to
    the database layer. The customer is responsible for the security above that layer,
    such as the data encryption. The way our business drives business value is not
    impacted by how we patch our database or run a hypervisor. Managed services are
    abstracting away a lot of this operational overhead. This allows us to focus on
    the business differentiators, such as the application logic and data offering.
    Managed services typically provide monitoring and reporting capabilities, such
    as method invocation for FaaS. Managed database or data storage services usually
    come with out-of-the-box backup and recovery mechanisms. Managed services can
    scale automatically and have built-in cost management and optimization features.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 托管服务由云服务提供商（CSP）管理，它们提高了客户的操作效率、可靠性和可用性。因此，它们是云原生架构中的一个重要优势。CSP管理托管服务的基础设施。根据服务的不同，这可能包括应用程序本身，例如队列或通知应用程序。托管服务包括资源的配置、维护和网络结构。如果我们使用托管关系型数据库服务，如Amazon
    **关系型数据库服务**（**RDS**）、微软Azure数据库或Google Cloud数据库，CSP将负责底层基础设施的修补和升级，包括数据库引擎。托管数据库服务还会执行符合行业规定的安全性和合规性，直到数据库层级。客户则负责该层之上的安全性，例如数据加密。我们企业实现商业价值的方式并不会受到如何修补数据库或运行虚拟化管理程序的影响。托管服务抽象化了大量操作开销，这使得我们能够专注于业务区分点，如应用逻辑和数据提供。托管服务通常提供监控和报告功能，例如FaaS的调用方法。托管数据库或数据存储服务通常提供开箱即用的备份和恢复机制。托管服务可以自动扩展，并具备内置的成本管理和优化功能。
- en: Security and compliance
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全性与合规性
- en: Further security and compliance advantages of cloud native architectures are
    unified access controls. **Role-based access control** (**RBAC**), **attribute-based
    access control** (**ABAC**), and **identity and access management** (**IAM**)
    services ensure we can implement the least-privilege principle. Encryption by
    default for data protection in transit and at rest ensures that the customer data
    can always be encrypted, which is a best practice and also required in many regulated
    industries.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生架构的进一步安全性和合规性优势包括统一的访问控制。**基于角色的访问控制**（**RBAC**）、**基于属性的访问控制**（**ABAC**）和**身份与访问管理**（**IAM**）服务确保我们能够实施最小权限原则。默认启用的加密机制可确保数据在传输和静止状态下得到保护，从而确保客户数据始终可以加密，这是一种最佳实践，并且在许多受监管行业中也是强制要求的。
- en: There are also built-in security features, such as **DDoS** (**distributed denial-of-service**)
    protection, firewalls, **network access control lists** (**NACLs**), and **security
    information and event management** (**SIEM**) tools. Most CSPs also support **multi-factor
    authentication** (**MFA**) and **single sign-on** (**SSO**). Having these two
    controls in place is quite often an internal security requirement. MFA is also
    mandated by some regulatory requirements, such as the **Payment Card Industry
    Data Security Standard** (**PCI-DSS**). SSO integration makes it easier to manage
    human and machine access permissions centrally. This centralized approach reduces
    operational effort and also helps to meet regulatory requirements.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 还内置了安全特性，例如**DDoS**（**分布式拒绝服务**）保护、防火墙、**网络访问控制列表**（**NACLs**）和**安全信息与事件管理**（**SIEM**）工具。大多数CSP还支持**多因素认证**（**MFA**）和**单点登录**（**SSO**）。实施这两个控制通常是内部安全要求。MFA也是一些监管要求强制的，例如**支付卡行业数据安全标准**（**PCI-DSS**）。SSO集成使得集中管理人类和机器的访问权限变得更加容易。这种集中化的方式减少了运营工作量，并有助于满足合规性要求。
- en: Cloud native also provides preventive and detective guardrails, which are instrumental
    in protecting our teams from some human errors. Preventive guardrails ensure that
    specific actions, such as deleting a backup vault, can never be performed. Detective
    guardrails still allow specific actions, but they can send notifications if a
    particular event happens, and findings can be visualized on a dashboard. For example,
    we would like to see whether we have any unencrypted databases in a development
    environment. We could enforce encryption via preventive guardrails for higher
    environments such as testing or production. Detective guardrails can also trigger
    auto-remediations for existing cloud resources. If a blob storage does not have
    access logging enabled, an auto-remediation can perform that change. Automated
    vulnerability scans are another feature that many CSPs offer. They help to scan
    VMs, containers, FaaS code, and networks. The scanning tools typically provide
    a report with findings and remediation recommendations.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生还提供了预防性和侦测性护栏，这对于保护我们的团队免受某些人为错误至关重要。预防性护栏确保某些特定操作，如删除备份库，永远无法执行。侦测性护栏仍允许某些操作，但如果发生特定事件，它们可以发送通知，并且可以在仪表板上可视化发现。例如，我们希望查看开发环境中是否有任何未加密的数据库。我们可以通过预防性护栏强制对测试或生产等更高环境进行加密。侦测性护栏还可以触发现有云资源的自动修复。如果某个
    Blob 存储没有启用访问日志记录，自动修复可以执行该更改。自动化漏洞扫描是许多云服务提供商（CSP）提供的另一项功能。它们帮助扫描虚拟机、容器、FaaS
    代码和网络。这些扫描工具通常提供带有发现和修复建议的报告。
- en: Reliability and availability
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可靠性与可用性
- en: There are also other reliability and availability benefits of cloud native applications.
    Anomaly detection services help to detect suspicious user behavior or unusual
    system behavior due to a flaw. They help to identify incidents at an early stage.
    Deployment architectures can easily leverage several independent locations within
    one geographical region. AZs are physically isolated from each other and have
    separate power supply and connectivity, but highspeed interconnects within a region.
    A region could be Sydney or Singapore. Independent locations are called **availability
    zones** (**AZs**). The term *AZ* has a different meaning depending on our CSP,
    but for now, this definition is good enough for us. It is best practice to architect
    our application so that it leverages several AZs, ideally all the AZs we have
    in our region. Multi-AZ deployments help with automated failovers from one AZ
    to another. In an outage in one AZ, the other AZs can absorb the load and reply
    to incoming requests, such as API calls. This failover is a built-in feature,
    but the application needs to be architected correctly to leverage those benefits.
    We could even deploy our application to several regions. In the unlikely event
    of a total region failure, the second region can take on the entire load and respond
    to incoming requests. A total region outage is very unlikely. Therefore, this
    use case is less common than the other use cases for global deployments.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生应用程序还有其他的可靠性和可用性优势。异常检测服务帮助检测由于缺陷导致的可疑用户行为或异常系统行为。它们有助于在早期阶段识别事件。部署架构可以轻松利用一个地理区域内的多个独立位置。可用区（AZ）彼此物理隔离，具有独立的电源供应和连接性，但区域内有高速互联。一个区域可以是悉尼或新加坡。独立的位置称为**可用区**（**AZs**）。术语*AZ*在不同的云服务提供商（CSP）中有不同的含义，但目前这个定义对我们来说已经足够了。最佳实践是将我们的应用架构设计为利用多个可用区，理想情况下是我们所在区域内的所有可用区。多可用区部署有助于从一个可用区自动故障转移到另一个可用区。在一个可用区发生故障时，其他可用区可以分担负载并响应传入的请求，如
    API 调用。这个故障转移是一个内置功能，但应用程序需要正确架构，以便利用这些优势。我们甚至可以将应用程序部署到多个区域。在极不可能发生的区域完全故障的情况下，第二个区域可以承载全部负载并响应传入请求。区域完全故障的可能性非常小。因此，这种用例比全球部署的其他用例要少见。
- en: Regional outages are a segway into the next advantage we want to discuss.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 区域性故障是我们想要讨论的下一个优势的引入。
- en: Global deployments
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全球部署
- en: With global deployments, it becomes easy for organizations that operate in several
    countries or even globally to address that in their deployment architecture. With
    global deployments, we can reduce the latency between our customers’ devices and
    our applications. We can leverage a CDN; this caches data closer to our customers
    and is helpful if customers are not located in our geographical region. For example,
    suppose our application is hosted in Sydney, on the east side of Australia, and
    our customers are 4,000 kilometers away on the west coast of Australia. In that
    case, we can leverage a CDN to store cacheable information in Perth, located on
    the west coast. Those distributed locations are called **edge locations**. We
    can even run certain forms of authentication on the edge location to reduce the
    latency for a login procedure. This additional caching layer increases the availability
    of content. It can also reduce the bandwidth cost because the amount of data that
    needs to be provided by an origin server is reduced, and therefore, we are charged
    less egress data. We can potentially downsize our provisioned infrastructure.
    CDNs can handle large traffic spikes. Hence, they protect against DDoS attacks.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 通过全球部署，对于在多个国家甚至全球运营的组织来说，这使得在部署架构中处理这些问题变得更加容易。全球部署能够减少客户设备与应用程序之间的延迟。我们可以利用CDN，这样可以将数据缓存更靠近客户，并且如果客户不在我们的地理区域内，这会非常有帮助。例如，假设我们的应用程序托管在澳大利亚东部的悉尼，而我们的客户位于距离4,000公里外的澳大利亚西海岸。在这种情况下，我们可以利用CDN将可缓存的信息存储在位于西海岸的珀斯。这些分布式位置称为**边缘位置**。我们甚至可以在边缘位置上运行某些形式的身份验证，以减少登录过程的延迟。这个额外的缓存层提高了内容的可用性。它还可以减少带宽成本，因为需要由源服务器提供的数据量减少，因此，我们的出站数据费用会较低。我们还可以有可能缩减我们提供的基础设施。CDN可以处理大规模的流量峰值，因此，它们可以防止DDoS攻击。
- en: Another driver for global deployments could be regulatory requirements, such
    as data sovereignty laws. For regulated industries such as financial services
    or health services, customer data must reside in the originating region. For instance,
    data of United States citizens must be stored within the United States, and data
    of European customers must be stored within the European Union. With global deployments,
    it becomes easier to deploy applications to different regions. The application
    will then store the data within that region and stay there. With a CDN, we can
    also use cloud native geo-restrictions. We can limit the content to particular
    continents or countries; usually, we can define allow and deny lists. Those geo-restrictions
    are why some media content is unavailable in other countries. E-commerce platforms
    typically deploy their applications globally as well. That way, they can have
    different product catalogs per region and have all the reliability and availability
    benefits. The reduced latency of global deployments is also why they are ubiquitous
    for gaming or large IoT solutions. Another use case for global deployments is
    **disaster recovery** (**DR**). Data can be backed up in a different region to
    improve business resilience.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个全球部署的驱动因素可能是合规性要求，例如数据主权法。对于受监管的行业，如金融服务或健康服务，客户数据必须存储在原始地区。例如，美国公民的数据必须存储在美国境内，欧洲客户的数据必须存储在欧盟境内。通过全球部署，部署应用程序到不同地区变得更加容易。应用程序将把数据存储在该地区并保持在那里。通过CDN，我们还可以使用云原生的地理限制。我们可以将内容限制在特定的大陆或国家，通常可以定义允许和拒绝列表。这些地理限制就是为什么某些媒体内容在其他国家不可用。电子商务平台通常也会全球部署其应用程序。这样，他们可以为每个地区提供不同的产品目录，并享有所有的可靠性和可用性优势。全球部署的低延迟也是它们在游戏或大型物联网解决方案中普遍应用的原因。全球部署的另一个应用场景是**灾难恢复**（**DR**）。数据可以在不同的地区进行备份，以提高业务的弹性。
- en: CI/CD – automate all the things
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CI/CD – 自动化一切
- en: Cloud native typically offers automation capabilities for CI/CD. They enable
    automated build, test, and deployment of applications.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生通常提供CI/CD的自动化功能。它们能够实现应用程序的自动构建、测试和部署。
- en: When using CI/CD, every change goes through a controlled process that should
    include peer reviews of code changes. Since everything is code-based, creating
    new environments ad hoc is low effort. Creating environments in other regions
    or tearing down temporary environments is also easy. Automation helps to decrease
    the time to market, improve the robustness of the change management process, enable
    consistency between environments, improve security and reliability, and help reduce
    cost.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用CI/CD时，每次变更都经过一个受控的流程，其中应包括同行审查代码变更。由于一切都是基于代码的，临时创建新环境的工作量非常低。在其他地区创建环境或拆除临时环境也很容易。自动化有助于缩短上市时间、提升变更管理过程的鲁棒性、实现环境间的一致性、提高安全性和可靠性，并帮助降低成本。
- en: Cost benefits and paradigm change
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成本效益与范式转变
- en: Hosting our applications in the cloud instead of on-premises moves the cost
    model from an upfront **capital expenditure** (**CapEx**) investment to a pay-as-you-go
    model. Rather than having substantial infrastructure investments every five years,
    we will have an ongoing spend in the cloud.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的应用托管在云端而不是本地部署，意味着成本模式从前期**资本支出**（**CapEx**）投资转变为按需付费模式。我们不再每五年进行大规模的基础设施投资，而是会在云端持续产生支出。
- en: Some of the previously described features, such as auto-scaling and automation,
    help with cost optimization in the cloud. But there are more native features.
    Each cloud resource should have tags. Tags are metadata that describe a resource.
    Common tags include environment, data classification, cost center, and application
    owner. Tags can be used for a cost breakdown or security controls. Native cost
    dashboards provide cost insight and give different views based on tags, regions,
    or resource types, such as VMs or managed API gateways. The cost dashboard solutions
    are AWS Cost Explorer, Google Cloud Billing Reports, and Azure Cost Management
    & Billing.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一些前面提到的功能，如自动扩展和自动化，有助于在云中进行成本优化。但还有更多本地功能。每个云资源都应该有标签。标签是描述资源的元数据。常见的标签包括环境、数据分类、成本中心和应用所有者。标签可以用于成本拆解或安全控制。本地成本仪表板提供成本洞察，并根据标签、地区或资源类型（如虚拟机或托管API网关）提供不同的视图。成本仪表板解决方案包括AWS成本资源管理器、Google
    Cloud Billing Reports和Azure成本管理与账单。
- en: We can also set up budgets to ensure we are notified if the projected spending
    exceeds the forecasted spending. We can define budgets manually or use built-in
    AI capabilities to set budget values. The AI component usually takes a few days
    to figure out the usual peaks and lows. Most CSPs also provide rightsizing recommendation
    services. This service helps to reduce costs where the customer has overprovisioned
    resources, such as VMs or databases. CSPs also offer a committed spending plan,
    which grants discounts if we commit to a spending amount for longer than a year.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以设置预算，确保如果预计支出超过预期支出时会收到通知。我们可以手动定义预算，或者使用内建的人工智能功能来设置预算值。人工智能组件通常需要几天时间来了解常见的支出高峰和低谷。大多数云服务提供商（CSP）也提供资源优化建议服务。该服务帮助减少因客户过度配置资源（如虚拟机或数据库）而产生的费用。CSP还提供承诺支出计划，如果我们承诺在一年以上的时间内达到一定支出额，还能获得折扣。
- en: Portability
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可移植性
- en: Cloud native also delivers a couple of portability benefits. Containers and
    orchestration tools such as Kubernetes promote standardized configuration and
    deployment processes. A container-hosted application can easily migrate to a different
    CSP. Cloud native solutions are hybrid cloud-compatible and can integrate with
    our data centers. Hybrid deployments are widespread for massive application migrations
    where the migration from on-premises to the cloud happens over a long period.
    Typically, the frontend part of the application is moved to the cloud first, starting
    with components such as the CDN, APIs, and user interface. For cases where low
    latency and a reduced jitter are required, we can use cloud native connectivity
    services. These connectivity services require our data center to be in one of
    the colocations of the CSP and underlying infrastructure changes in our data center,
    such as new cable connections, are required. Examples are GCP Cloud Interconnect,
    AWS Direct Connect, and Azure ExpressRoute.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生还带来了一些可移植性好处。容器和编排工具如Kubernetes促进了标准化的配置和部署过程。一个容器托管的应用可以轻松迁移到不同的CSP。云原生解决方案是混合云兼容的，并且可以与我们的数据中心集成。混合部署在大规模应用迁移中非常普遍，特别是在从本地部署到云端的迁移过程中，这一过程通常会持续很长时间。通常，应用的前端部分首先迁移到云端，从CDN、API和用户界面等组件开始。对于需要低延迟和减少抖动的场景，我们可以使用云原生连接服务。这些连接服务要求我们的数据中心位于CSP的一个共址位置，并且数据中心的基础设施需要发生变化，例如新的电缆连接等。例子包括GCP
    Cloud Interconnect、AWS Direct Connect和Azure ExpressRoute。
- en: Cloud native architectures offer many benefits. However, we have only scratched
    the surface of cloud automation, and we have not even discussed the cultural aspect.
    Let’s get onto it now.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 云原生架构提供了许多好处。然而，我们仅仅触及了云自动化的皮毛，甚至还没有讨论文化层面的内容。现在让我们来探讨这个话题。
- en: DevSecOps culture, IaC, and CI/CD
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DevSecOps文化、基础设施即代码（IaC）和持续集成/持续交付（CI/CD）
- en: In the *The evolution of cloud native* section, we discussed Conway’s Law, the
    Agile Manifesto, the rise of Agile software development, and the first DevOps
    conference in 2009\. But what exactly is DevOps?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在*云原生的演进*一节中，我们讨论了康威定律、敏捷宣言、敏捷软件开发的崛起以及2009年的第一次DevOps大会。那么，DevOps到底是什么呢？
- en: The culturural aspect
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文化层面
- en: '**DevOps** is a cross-functional combination of development and operations.
    Key characteristics are shared ownership, workflow automation, and rapid feedback.
    DevOps uses cultural behavior, practices, and tools to automate development and
    operations to improve the end-to-end SDLC. Its goal is to improve the software
    quality and decrease the time from a committed change to production. DevOps is
    mainly about culture and, as a result, it impacts the software toolchain. The
    cultural change aspect of DevOps adoption is quite often underestimated. Let’s
    elaborate on the impacts to understand why this is the case.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**DevOps**是开发和运维的跨职能组合。其主要特点包括共享所有权、工作流自动化和快速反馈。DevOps利用文化行为、实践和工具来自动化开发和运维，从而改善端到端的SDLC。其目标是提高软件质量并缩短从提交变更到生产环境的时间。DevOps主要关乎文化，因此它会影响软件工具链。DevOps采纳中的文化变革往往被低估。让我们详细讨论这些影响，以便理解为何会出现这种情况。'
- en: DevOps adoption means that different disciplines work together, which we call
    cross-functional teams. The *two-pizza team* topology, created by Amazon’s Jeff
    Bezos in the early 2000s, is a strategy for keeping teams small and efficient
    by ensuring they are small enough to be fed with just two pizzas. This approach
    fosters better communication, agility, and productivity within the team. The *you
    build it, you run it* mentality fosters business agility. It empowers teams to
    react faster and innovate to deliver customer value. It also results in high-quality
    outcomes since people are motivated to avoid incidents they get called into. Those
    things should sound familiar by now. Let’s have a look at how this looks when
    we add security to the mix.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps的采纳意味着不同学科的人员共同协作，我们称之为跨职能团队。*两块披萨团队*结构是亚马逊的杰夫·贝索斯在2000年代初提出的一种策略，旨在通过确保团队足够小到只需要两块披萨就能满足其需求，来保持团队的小巧和高效。这种方法促进了团队内部更好的沟通、敏捷性和生产力。*你构建它，你运维它*的理念促进了业务敏捷性，使团队能够更快反应并创新交付客户价值。这也带来了高质量的成果，因为人们被激励避免发生会让他们被召集处理的事件。这些应该已经听起来很熟悉了。现在让我们来看一看在加入安全性因素之后，会是什么样子。
- en: DevSecOps
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DevSecOps
- en: A mature DevSecOps culture adopts a **shift-left** approach. Functional and
    non-functional quality controls are performed very early in the SDLC. *Shift left*
    means testing activities such as requirement definition and design start early,
    so the testers are involved early. Testing is usually automated to a high degree,
    including unit tests, integration tests, non-functional tests, regression tests,
    contract tests, and others. Tools for static code analysis help to analyze code
    quality.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 成熟的DevSecOps文化采用**Shift-Left**方法。功能性和非功能性的质量控制在软件开发生命周期（SDLC）初期就开始执行。*Shift
    Left*意味着测试活动（如需求定义和设计）开始得早，因此测试人员能够提前参与。测试通常会高度自动化，包括单元测试、集成测试、非功能性测试、回归测试、合同测试等。静态代码分析工具有助于分析代码质量。
- en: '**DevSecOps** augments DevOps and suggests embedding security in the software
    delivery process. This empowers development teams to produce high-quality changes
    that meet security and regulatory requirements. DevSecOps integrates security
    tools into the CI/CD toolchain. This integration includes **static application
    security testing** (**SAST**) tools to analyze the source code for vulnerabilities.
    **Software composition analysis** (**SCA**) is an analysis of custom-built source
    code to detect embedded open source software or libraries and validate that they
    are up to date and contain no security flaws. Other usual security scans include
    secret scanning to ensure no security keys or passwords are embedded in the code.
    Vulnerability scans inspect machine images, container images, and source code
    for common vulnerabilities and exposures. These types of scans have become increasingly
    important due to a surge in supply chain attacks. A supply chain attack uses third-party
    tools or services to infiltrate a system or network.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**DevSecOps**增强了DevOps，并建议在软件交付过程中嵌入安全性。这使得开发团队能够生产满足安全和法规要求的高质量变更。DevSecOps将安全工具集成到CI/CD工具链中。此集成包括**静态应用安全测试**（**SAST**）工具，用于分析源代码中的漏洞。**软件组成分析**（**SCA**）是对定制源代码的分析，用以检测嵌入的开源软件或库，并验证它们是否是最新的且没有安全漏洞。其他常见的安全扫描包括秘密扫描，以确保代码中没有嵌入安全密钥或密码。漏洞扫描检查机器镜像、容器镜像和源代码中的常见漏洞和暴露。这些扫描变得越来越重要，因为供应链攻击的激增。供应链攻击利用第三方工具或服务渗透系统或网络。'
- en: There are many new trends with the word *Ops* in them. One that gets a lot of
    attention is **AIOps**, which promotes leveraging AI capabilities and embedding
    those in the DevSecOps approach to identify anomalies and suspicious behavior
    early. As a result, we want to see improvements in delivery and operation, and
    we will look into that next.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多新兴趋势与*Ops*相关。其中一个备受关注的是**AIOps**，它提倡利用AI技术并将其嵌入DevSecOps方法中，以便及早识别异常和可疑行为。因此，我们希望看到交付和运营的改进，接下来我们将探讨这一点。
- en: Measuring the progress
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 衡量进展
- en: 'The **DevOps Research and Assessment** (**DORA**) team published the DORA metrics.
    Their purpose is to measure and improve the performance and efficiency of the
    software development process. Providing actionable insights helps identify bottlenecks
    and improve the process. The four key DORA metrics are as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**DevOps研究与评估**（**DORA**）团队发布了DORA指标，其目的是衡量并提高软件开发过程的性能和效率。提供可操作的见解有助于识别瓶颈并改进过程。四个关键的DORA指标如下：'
- en: '**Lead time for changes** (**LTFC**) is the time from the first code commit
    to deployment. Shorter lead times mean faster delivery of business value.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变更的交付时间**（**LTFC**）是从第一次代码提交到部署的时间。较短的交付时间意味着可以更快地交付业务价值。'
- en: For instance, we can track the time from when a developer commits a change to
    a production release. On average, this takes 24 hours, which allows the company
    to respond swiftly to market demands and user feedback.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，我们可以跟踪开发者从提交更改到发布到生产环境的时间。平均而言，这需要24小时，这使得公司能够迅速响应市场需求和用户反馈。
- en: '**Deployment frequency** (**DF**) is the number of deployments in a given duration
    of time. A high frequency indicates the ability to deliver new features and bug
    fixes and respond to customer needs.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署频率**（**DF**）是指在给定时间段内的部署次数。高频率表示能够交付新功能和修复bug，并响应客户需求。'
- en: For example, we release updates to our mobile app twice a week. This frequent
    deployment helps to quickly deliver new features and bug fixes to users, ensuring
    the app remains competitive and user-friendly.
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，我们每周发布两次移动应用更新。这种频繁的部署有助于快速将新功能和错误修复交付给用户，确保应用保持竞争力和用户友好。
- en: '**Change failure rate** (**CFR**) is the percentage of failed changes over
    all changes. A lower rate indicates higher quality and stability in releases.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更改失败率** (**CFR**) 是所有更改中失败更改的百分比。较低的比例表示发布的质量和稳定性较高。'
- en: For instance, out of 50 deployments in a month, 5 resulted in rollback or required
    hotfixes due to bugs or issues. This gives our organization a CFR of 10%, highlighting
    areas for improvement in their testing and review processes.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，在一个月的 50 次部署中，5 次由于错误或问题导致回滚或需要热修复。这为我们的组织提供了 10% 的 **更改失败率** (**CFR**)，突出了他们的测试和审查过程中的改进空间。
- en: '**Mean time to recovery** (**MTTR**) measures the average time it takes to
    recover from a system failure. A shorter MTTR demonstrates the ability to recover
    quickly from incidents.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**恢复时间中位数** (**MTTR**) 衡量从系统故障中恢复所需的平均时间。较短的 MTTR 表示能够从事件中快速恢复。'
- en: Tackling the cultural challenges
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应对文化挑战
- en: Now that we have looked into DevSecOps, we can see that adoption is not trivial.
    There is a lot to consider. Starting from a waterfall software development approach
    will be a steep learning curve. A considerable percentage of humans have some
    degree of resistance to cultural change. If an organization is separated into
    silos, it will take a while to break those down. DevSecOps requires more collaboration
    and broader skills. Therefore, it is crucial to provide sufficient training. Training
    will be required to gain cloud native knowledge including the tools used to build,
    test, and deploy the code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 DevSecOps，我们可以看到其采纳并非易事。需要考虑的因素很多。从瀑布式软件开发方法入手将会是一个陡峭的学习曲线。相当一部分人对文化变革有一定的抵触。如果一个组织被划分为孤岛，它将需要一段时间才能打破这些障碍。DevSecOps
    需要更多的协作和更广泛的技能。因此，提供足够的培训至关重要。培训将是获得云原生知识所必需的，包括用于构建、测试和部署代码的工具。
- en: As the term *Ops* in DevSecOps suggests, the team also operates the applications.
    Therefore, the team is motivated to release quality code to ensure they do not
    need to solve too many incidents. This ownership approach is a crucial differentiator
    from traditional methods, where development and operations are separated. It also
    means the team members need the skills to build observability capabilities and
    react to incidents. Learning all this will require training, which can be a combination
    of classroom training, online training courses, and pair programming. Providing
    learning environments for experimenting and creating proof of concepts is also
    very effective in upskilling our teams. These environments are usually called
    *sandpits* or *sandboxes*. We use the word *developer* here because they will
    likely produce application, test, infrastructure, or configuration code. But that
    term can be used interchangeably with engineer, software engineer, full stack
    developer, and others.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如 DevSecOps 中的术语 *Ops* 所暗示，团队还负责应用程序的运行。因此，团队有动力发布高质量的代码，以确保他们不需要解决太多的故障。这种拥有感方法是与传统方法的一个重要区别，在传统方法中，开发和运维是分开的。这也意味着团队成员需要具备构建可观察性能力并响应事件的技能。学习这些内容将需要培训，这可以是课堂培训、在线培训课程和结对编程的结合。提供用于实验和创建概念验证的学习环境对于提升团队技能也非常有效。这些环境通常被称为
    *沙坑* 或 *沙箱*。我们在这里使用 *开发者* 一词，因为他们可能会编写应用程序、测试、基础设施或配置代码。但这个术语可以与工程师、软件工程师、全栈开发者等互换使用。
- en: There are different ways organizations can drive cultural change. Top-down means
    the change initiative starts at the leadership level, and bottom-up means it begins
    with the delivery team and eventually reaches the management and leadership levels.
    For a successful DevSecOps adoption, we will need buy-in from the leadership.
    Otherwise, the required cultural changes won’t happen. The adoption process is
    mostly successful when it gets adopted first in parts of the organization that
    already have an agile delivery approach. Those teams will find it easier to experience
    DevSecOps, and they can start swarming after a while. That means the team members
    can be augmented and act as mentors in other teams. Getting external help through
    a DevSecOps consultancy can be good if we are at the beginning of our transformation
    journey. The external consultants can coach the team, contribute to the code base,
    and ensure that best practices are applied. For a successful DevSecOps journey,
    the consultants must transfer the knowledge to the internal development teams.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 组织可以通过不同的方式推动文化变革。自上而下意味着变革举措从领导层开始，而自下而上意味着它从交付团队开始，最终到达管理层和领导层。为了成功采用DevSecOps，我们需要获得领导层的支持。否则，所需的文化变革将无法实现。当DevSecOps首先在已经采用敏捷交付方式的部分组织中进行时，
    adoption过程通常会更为成功。这些团队会更容易体验到DevSecOps，过一段时间后，他们可以开始进行集体合作。这意味着团队成员可以被扩展，并且可以作为其他团队的导师。如果我们刚开始转型旅程，寻求DevSecOps咨询公司提供外部帮助是非常有益的。外部顾问可以指导团队，贡献代码库，并确保最佳实践得以应用。为了确保DevSecOps旅程的成功，顾问们必须将知识转移给内部开发团队。
- en: IaC
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IaC
- en: The source code is the source of truth for every cloud native solution. Individuals
    responsible for the infrastructure create the infrastructure or patterns via **infrastructure
    as code** (**IaC**). IaC defines components such as network constructs, servers,
    policies, storage, and FaaS in code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码是每个云原生解决方案的真相来源。负责基础设施的人通过**基础设施即代码**（**IaC**）创建基础设施或模式。IaC在代码中定义了诸如网络构件、服务器、策略、存储和FaaS等组件。
- en: Cloud native versus cloud-agnostic IaC
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 云原生IaC与云无关IaC的区别
- en: 'CSPs offer their own IaC technology and there are also third-party offerings
    that are platform-agnostic:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: CSP提供了自己的IaC技术，也有一些第三方产品是平台无关的：
- en: '**Cloud** **native IaC**:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**云原生IaC**：'
- en: CSPs have their own IaC service for their platform, including AWS CloudFormation,
    **Azure Resource Manager** (**ARM**), and Google Cloud Deployment Manager. Those
    services come with their own IaC language. Compared to higher programming languages
    such as Golang or Java, the IaC languages are less complex and can be learned
    quickly. Simplicity benefits individuals with a strong infrastructure background
    who do not necessarily have much coding experience except for Bash or PowerShell
    scripts.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: CSP（云服务提供商）为其平台提供了自己的IaC服务，包括AWS CloudFormation、**Azure Resource Manager**（**ARM**）和Google
    Cloud Deployment Manager。这些服务带有自己特定的IaC语言。与Golang或Java等高级编程语言相比，IaC语言较为简单，可以快速学习。简洁性对有着强大基础设施背景的人非常有利，即使他们并不一定有太多的编码经验，除了Bash或PowerShell脚本之外。
- en: '**Platform-agnostic IaC**:'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平台无关的IaC**：'
- en: There are also IaC tools available that use one common language to deploy to
    several cloud and on-premises platforms. Terraform is a popular IaC tool that
    can deploy to all major CSPs and thousands of other platforms, including collaboration
    platforms, firewalls, network tools, and source code management tools. Terraform
    used to be open source, but when it was shifted to a Business Source License in
    2023, the community reacted quickly. The code base was forked, and a new open
    source project called **OpenTofu** was established.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 也有一些IaC工具使用一种通用语言来部署到多个云平台和本地平台。Terraform是一个流行的IaC工具，可以部署到所有主要的CSP以及数千个其他平台，包括协作平台、防火墙、网络工具和源代码管理工具。Terraform曾是开源的，但当它在2023年转为商业源许可证时，社区迅速作出了反应。代码库被分叉，一个名为**OpenTofu**的新开源项目成立了。
- en: It sounds as if IaC has the potential to bring significant advantages, which
    we will discuss next.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来，IaC有潜力带来显著的优势，接下来我们将讨论这些优势。
- en: Advantages of IaC
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: IaC的优势
- en: What are the advantages of defining our cloud resources via IaC? Whenever we
    deploy something repeatedly, such as a temporary or new testing environment, the
    architecture and deployment approach will always be consistent, and the approach
    is easy to repeat. Typically, we use different parameters for a different environment,
    for example, a different IP range for a different network segment or a smaller
    auto-scaling group for non-production environments. The rest of the code stays
    the same. Hence, IaC is also very efficient in achieving scalability or implementing
    global deployments. Configuration and code are fully version-controlled in Git.
    Therefore, it is easy to go back to the previous version.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过IaC定义云资源有什么优势？每当我们重复部署某些东西时，例如临时或新的测试环境，架构和部署方式将始终保持一致，且这种方式易于重复。通常，我们会为不同的环境使用不同的参数，例如为不同的网络段使用不同的IP范围，或者为非生产环境使用更小的自动扩展组。其余的代码保持不变。因此，IaC在实现可扩展性或实施全球部署方面也非常高效。配置和代码都在Git中进行版本控制。因此，回滚到以前的版本非常容易。
- en: We can also easily use version pinning if we want our production environment
    to be further behind than the development environment. IaC also helps to achieve
    a good DR response time. Instead of manually or semi-manually building a new DR
    environment, we can fully automate this with IaC and CI/CD technologies, which
    we will cover in a minute. IaC also helps to meet security and compliance requirements.
    Security requirements are embedded in the code. For instance, if we only want
    to allow HTTPS traffic, our code will only open port `443`, then we articulate
    that in the source code. As best practice, the code will be peer-reviewed to ensure
    we meet our requirements. When we redeploy, we can be sure we don’t expose our
    application since the deployment will deliver a repeatable outcome. All changes
    are tracked in Git, which helps with auditing and compliance. Some regulatory
    frameworks require a repeatable approach. That is exactly what IaC establishes.
    There is also a cost benefit to IaC. Because creating and destroying resources
    is so easy, it helps avoid over-provisioning. If test environments are not needed,
    then resources can be easily shut down if they are not required. If we take a
    complete serverless approach, we will need to worry less about this. We will talk
    about this later when we get into the strategy.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望生产环境比开发环境滞后，**版本固定**（version pinning）也可以很容易地使用。基础设施即代码（IaC）还帮助实现良好的灾难恢复响应时间。我们可以通过IaC和CI/CD技术，完全自动化灾难恢复环境的构建，而不是手动或半手动地构建新的灾难恢复环境，这一点我们稍后会详细讨论。IaC还帮助满足安全性和合规性要求。安全性要求嵌入在代码中。例如，如果我们只允许HTTPS流量，我们的代码将只开放端口`443`，然后我们将在源代码中明确这一点。作为最佳实践，代码会经过同行评审，以确保我们满足要求。在重新部署时，我们可以确信不会暴露我们的应用程序，因为部署将提供一个可重复的结果。所有更改都在Git中进行跟踪，有助于审计和合规性。一些监管框架要求采取可重复的方法，这正是IaC所建立的。此外，IaC还有成本效益。由于创建和销毁资源非常简单，它有助于避免过度配置。如果测试环境不再需要，那么可以在不需要时轻松关闭资源。如果我们采用完全无服务器的方式，就不需要过多担心这个问题。我们稍后会在讨论策略时谈到这一点。
- en: How do we deploy the cloud resources that we have defined via IaC? How do we
    build and deploy our application code? How do we execute all the functional and
    non-functional tests in an automated way? The answer is CI/CD, and we will explore
    it now.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何部署通过IaC定义的云资源？我们如何构建和部署我们的应用程序代码？我们如何以自动化的方式执行所有功能和非功能测试？答案就是CI/CD，我们现在就来探讨它。
- en: CI/CD
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CI/CD
- en: CI/CD is a combination of continuous integration and continuous delivery, sometimes
    referred to as continuous deployment. The main difference is that continuous delivery
    requires a manual approval step, whereas continuous deployment deploys automatically
    after a code change. CI/CD bridges gaps between development and operations. It
    enforces automation during the build process, functional and non-functional testing,
    and deployment.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD是持续集成（Continuous Integration）和持续交付（Continuous Delivery）的结合，有时也称为持续部署（Continuous
    Deployment）。主要的区别在于，持续交付需要手动审批步骤，而持续部署在代码更改后会自动部署。CI/CD弥合了开发和运维之间的差距。在构建过程、功能和非功能测试以及部署过程中，它强制执行自动化。
- en: Defining a structure
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义结构
- en: 'There are many ways to structure the CI/CD process and even more combinations
    of tools. The fine-tuning will depend a lot on organizational and regulatory needs.
    We will go with a standard structure, where we want to adopt a shift-left approach.
    The following diagram helps us step through this process:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD过程有很多种结构方式，甚至有更多工具组合。微调将很大程度上取决于组织和监管需求。我们将采用一种标准结构，在这种结构中，我们希望采用“左移”方法。以下图表帮助我们逐步了解这一过程：
- en: '![Figure 1.1: Simplified conceptual CI/CD process](img/B22364_01_1.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图1.1：简化的概念性CI/CD过程](img/B22364_01_1.jpg)'
- en: Figure 1.1 - Simplified conceptual CI/CD process
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 - 简化的概念性CI/CD过程
- en: The process starts with the developer using the preferred **integrated development
    environment** (**IDE**). Sometimes, developers use just a command-line tool. However,
    IDEs are commonly used because they provide practical built-in features and plugin
    architecture. This architecture enables the installation of extensions or plugins.
    Visual Studio Code is a popular open source IDE developed by Microsoft. Even though
    the software is open source, the available extensions are not necessarily open
    source. IDEs usually have a built-in Git integration. However, we can install
    an additional extension that visualizes the Git repository and the Git branches.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程从开发者使用首选的**集成开发环境**（**IDE**）开始。有时候，开发者仅使用命令行工具。然而，IDE通常被广泛使用，因为它们提供了实用的内置功能和插件架构。这种架构支持安装扩展或插件。Visual
    Studio Code是由微软开发的流行开源IDE。尽管该软件是开源的，但可用的扩展未必是开源的。IDE通常具有内置的Git集成。然而，我们可以安装一个额外的扩展来可视化Git仓库和Git分支。
- en: Git branching and shift left
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Git分支与左移
- en: A Git branch is a separate version of the code repository created for a new
    change. There are different branching models, such as trunk-based development
    or feature branching. We will look into that in more detail in [*Chapter 5*](B22364_05.xhtml#_idTextAnchor136),
    and for our example, we will use the feature branching model. When the developer
    wants to commit a change to the repository, it is important to work off the latest
    version in the repo (short for repository). Therefore, a `git pull` command is
    required to ensure the latest version is in the local copy. After that, the developer
    creates a new feature branch and updates the code. There are a lot of checks that
    can now be run automatically to provide early feedback. For example, a security
    extension could scan the code and identify weaknesses. For instance, if the code
    is a Terraform template that defines a public Amazon S3 bucket, then the plugin
    can provide feedback that the bucket should be private. S3 buckets are blob storage
    constructs in AWS, and misconfigured S3 buckets have been the reason for many
    data breaches. This early feedback is an example of shift left, and the developer
    can fix the code before it is validated in the CI/CD pipeline. Code formatting,
    linting, and syntax validations typically run on the client side. Once the developer
    is happy with the changes, the code is committed to the Git repo.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Git分支是为新变更创建的代码仓库的独立版本。有不同的分支模型，比如基于主干的开发或功能分支。我们将在[*第5章*](B22364_05.xhtml#_idTextAnchor136)中详细讨论这一点，作为我们的示例，我们将使用功能分支模型。当开发者想要将变更提交到仓库时，重要的是要基于仓库中的最新版本进行操作（仓库的简称为repo）。因此，需要使用`git
    pull`命令来确保本地副本是最新版本。之后，开发者创建一个新的功能分支并更新代码。现在可以自动运行许多检查，以提供早期反馈。例如，一个安全扩展可以扫描代码并识别潜在的弱点。例如，如果代码是一个定义了公共Amazon
    S3桶的Terraform模板，那么插件可以提供反馈，提醒该桶应该是私有的。S3桶是AWS中的二进制存储构造，配置错误的S3桶已成为许多数据泄露的原因。这种早期反馈就是“左移”的例子，开发者可以在代码通过CI/CD管道验证之前修复代码。代码格式化、代码检查和语法验证通常在客户端运行。一旦开发者对更改满意，代码就会提交到Git仓库。
- en: Optionally, a commit can trigger a pre-commit hook, executing the steps we just
    described. It can also auto-generate documentation.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，一个提交可以触发预提交钩子，执行我们刚才描述的步骤。它还可以自动生成文档。
- en: Approval and deployment
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 批准与部署
- en: The developer then raises a **pull request** (**PR**). Someone performs a peer
    review. The PR gets approved if the code meets the expectations. Then, the code
    is merged into the main branch. The merge will trigger the pipeline to run. In
    the beginning, there will be some validation steps similar to the ones the developer
    had already run. Still, we want to ensure that some validations are mandatory
    and don’t rely on individuals. As a next step, the build process will kick off
    and run some static code analysis, functional and non-functional tests, and further
    security scans. Once the pipeline run is successful, an authorized individual
    can trigger the deployment. These steps are a simple example of a CI/CD pipeline.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员随后提交**拉取请求**（**PR**）。有人会进行同行评审。如果代码符合预期，PR会被批准。然后，代码会被合并到主分支。合并将触发管道运行。最初，会有一些验证步骤，类似于开发人员已经运行过的步骤。但我们希望确保某些验证是强制性的，并且不依赖于个人。接下来，构建过程将启动，并运行一些静态代码分析、功能性和非功能性测试以及进一步的安全扫描。一旦管道运行成功，授权人员可以触发部署。这些步骤是CI/CD管道的一个简单示例。
- en: We can see the many benefits of automating those steps. Building out the required
    pipelines for an organization will take a while, but once they are established,
    the development process becomes much quicker, more reliable, and more secure.
    But how can we validate that it also runs as expected? Let’s find out.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到自动化这些步骤的许多好处。为一个组织构建所需的管道需要一些时间，但一旦它们建立起来，开发过程变得更加迅速、可靠和安全。但我们如何验证它是否按预期运行呢？让我们来看看。
- en: Observability and resilience
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可观察性与弹性
- en: We have already covered many aspects of cloud native solutions, including the
    cultural impact, cross-functional teams, DevSecOps culture, and tooling complexity.
    We will now examine observability and resilience, two areas that need more consideration
    during the early design phases of cloud native solutions.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经涵盖了云原生解决方案的许多方面，包括文化影响、跨职能团队、DevSecOps文化和工具复杂性。现在我们将研究可观察性和弹性，这两个在云原生解决方案的早期设计阶段需要更多关注的领域。
- en: If we do not establish comprehensive observability, we will not know whether
    we achieve our targets, such as response times. And if we fail, we will not know
    where the bottleneck is. Therefore we need to have a holistic logging, monitoring,
    and observability strategy in place. The same applies to withstanding failures.
    We need insights to validate that our deployment architecture matches the resilience
    expectations. We will explore both aspects, starting with observability and what
    it means in a cloud native context. We cannot fix what we cannot see. Observability
    helps get actionable insight into an application’s internal state and measure
    it by evaluating outputs.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有建立全面的可观察性，我们就无法知道是否达到了目标，例如响应时间。如果我们失败了，我们也无法知道瓶颈在哪里。因此，我们需要制定全面的日志记录、监控和可观察性策略。承受故障的能力也是如此。我们需要洞察力来验证我们的部署架构是否符合弹性预期。我们将探讨这两个方面，从可观察性开始，并在云原生环境中了解其含义。我们无法修复我们看不见的东西。可观察性帮助我们深入了解应用程序的内部状态，并通过评估输出进行度量。
- en: Logging – the observability enabler
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志记录 – 可观察性的推动者
- en: '**Logs** are the key enabler for monitoring and observability. The scope of
    logs is very broad, and they can include operating system logs, access logs, application
    logs, infrastructure logs, network flow logs, **domain name service** (**DNS**)
    logs, and more. Logs enable monitoring, alerting, debugging, incident discovery,
    and performance optimization. Earlier in this chapter, we clarified that a typical
    DevSecOps team (aka product squad) writes the code and also manages their application,
    also referred to as “product.” Therefore, the team will be motivated to establish
    good observability practices and tooling.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '**日志**是监控和可观察性的关键推动者。日志的范围非常广泛，可以包括操作系统日志、访问日志、应用程序日志、基础设施日志、网络流量日志、**域名服务**（**DNS**）日志等。日志使得监控、警报、调试、事件发现和性能优化成为可能。在本章前面，我们已经阐明，典型的DevSecOps团队（即产品小组）编写代码并管理他们的应用程序，也称为“产品”。因此，该团队将有动力建立良好的可观察性实践和工具。'
- en: A good maturity level can be achieved when the team has a good mix of skills
    and experience mix across development and operations. Individuals with operational
    experience know the value of observability. People with a software engineering
    background also see the value of observability, especially on the application
    layer.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当团队在开发和运维之间具备良好的技能和经验混合时，可以实现良好的成熟度水平。拥有运维经验的人员了解可观察性的重要性。具有软件工程背景的人也会看到可观察性的重要性，尤其是在应用层。
- en: However, sometimes, the other layers, such as the network or operating system
    layer, need to be considered more. Getting a holistic picture covering all layers
    is critical to getting good insights into our systems. It is also essential to
    be able to correlate data. For instance, if we have a hybrid cloud application,
    a business transaction might start at the CDN, get to an API layer, and then write
    to a cloud-hosted queue where the on-premises business logic pulls the data from
    and writes it to an on-premises-hosted database.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时候，其他层级，如网络层或操作系统层，需要更多的关注。获取涵盖所有层级的整体视图对于深入了解我们的系统至关重要。能够关联数据也至关重要。例如，如果我们有一个混合云应用，一个业务事务可能从CDN开始，经过API层，然后写入云托管的队列，在那里本地的业务逻辑从队列中拉取数据并将其写入本地托管的数据库。
- en: Additionally, there is an on-premises firewall that inspects all incoming traffic.
    This architecture is complex but also common. If we have performance **service-level
    agreements** (**SLAs**), we will not only need to measure the end-to-end transaction
    time. We will need to identify the bottlenecks if we run the risk of failing to
    meet those SLAs. The problem could be anywhere on the entire traffic path. Good
    insights will help to pinpoint the bottleneck. Collecting all those logs leads
    us to another challenge. Because we know we need to collect all relevant logs,
    it is easy to fall into the trap of over-collecting, leading to alert fatigue.
    We will examine the typical anti-patterns in [*Chapter 10*](B22364_10.xhtml#_idTextAnchor270)
    and discuss how to address those pitfalls.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个本地防火墙，它检查所有进来的流量。这个架构很复杂，但也很常见。如果我们有**服务级别协议**（**SLAs**），我们不仅需要衡量端到端的事务时间，还需要在可能无法满足这些SLA的情况下识别瓶颈。问题可能出现在整个流量路径的任何地方。良好的洞察力将帮助我们确定瓶颈。收集所有这些日志会带来另一个挑战。因为我们知道需要收集所有相关日志，很容易陷入过度收集的陷阱，从而导致告警疲劳。我们将在[*第10章*](B22364_10.xhtml#_idTextAnchor270)中探讨典型的反模式，并讨论如何解决这些陷阱。
- en: Log quality
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志质量
- en: Consistency, standardization, and good quality of log information are foundational
    for helpful dashboards and meaningful alerts.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性、标准化和良好的日志信息质量是有用的仪表板和有意义的告警的基础。
- en: A couple of things need to be considered to achieve this. We will need an agreement
    on the severity levels we want to log. Not all severity levels require logging
    all the time. The debug level, for instance, should only be logged when we are
    debugging. If we don’t make a sensible decision about when to use what severity
    level and what levels need to be logged, we will have inconsistent log files.
    It is also very likely that we will then log too much. This means we need a bigger
    log file indexer, increasing operational expenses. An increasing size of log volume
    makes it harder to find relevant information in case of an incident. That is especially
    the case if we don’t have a standardized log structure.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一目标，需要考虑几个方面。我们需要就要记录的严重性级别达成一致。并非所有严重性级别都需要始终记录。例如，调试级别应该仅在我们调试时记录。如果我们不明智地决定在何时使用什么严重性级别，以及哪些级别需要记录，我们将会得到不一致的日志文件。而且，很可能我们会记录过多的内容。这意味着我们需要更大的日志文件索引器，从而增加运营开销。日志量的增加使得在发生事故时更难找到相关信息，尤其是在没有标准化日志结构的情况下。
- en: Therefore, we also need to define what information is captured in the log files
    and the sequence and structure. Structured data formats such as JSON help achieve
    this, and they help include key-value pairs to provide context. The log entry
    could include a key of `userID` or `sessionID` and the actual ID as a value. The
    log entry should contain other helpful contexts during troubleshooting, such as
    timestamps, transaction IDs, and correlation IDs, to trace and correlate requests
    between microservices. We should not store sensitive information such as credit
    card details, customer names, and addresses in log files. Some regulatory frameworks,
    such as the PCI-DSS, mandate data categories that must not be stored in log files.
    Centralized logging will also help to find data correlations because logs from
    APIs, the database, and infrastructure events will be saved in the same storage.
    Examples of popular open source logging tools are Logback, Graylog, and Log4j.
    The latter became famous in 2021 due to a vulnerability known as Log4 Shell, which
    allowed hackers to take control of devices running unpatched versions of Log4j.
    Therefore, we should always protect ourselves from vulnerabilities, and we will
    discuss this in more detail in Chapter 6\. Some service mesh solutions, such as
    Istio or Linkerd, provide logs, metrics, and traces out of the box.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们还需要定义日志文件中捕获的信息，以及其顺序和结构。像 JSON 这样的结构化数据格式有助于实现这一点，并且有助于包含键值对以提供上下文。日志条目可以包括一个
    `userID` 或 `sessionID` 的键，以及实际的 ID 作为值。日志条目还应包含在故障排除过程中其他有用的上下文信息，例如时间戳、事务 ID
    和关联 ID，以便跟踪和关联微服务之间的请求。我们不应在日志文件中存储敏感信息，如信用卡详细信息、客户姓名和地址。某些监管框架，如 PCI-DSS，规定了不能存储在日志文件中的数据类别。集中式日志记录还将有助于找到数据关联，因为来自
    API、数据库和基础设施事件的日志将保存在相同的存储中。流行的开源日志工具包括 Logback、Graylog 和 Log4j。后者因 2021 年的 Log4
    Shell 漏洞而广为人知，该漏洞使黑客能够控制运行未打补丁版本的 Log4j 的设备。因此，我们应该始终保护自己免受漏洞攻击，我们将在第六章中详细讨论这一点。一些服务网格解决方案，如
    Istio 或 Linkerd，开箱即用地提供日志、指标和追踪。
- en: What else do we need to consider for logs? We need to ensure that only authorized
    individuals and systems have access to log files. If they contain sensitive information,
    they need to be encrypted. However, we will check with our applicable regulatory
    frameworks and internal security policy to see whether that is allowed. If our
    source code contains recursions, we should ensure that the same exception or error
    is not logged multiple times. We must also consider data retention for log files
    to avoid a bill shock. A sound logging approach will enable a good monitoring
    and observability capability, which we will discuss next.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们还需要考虑日志的哪些方面？我们需要确保只有授权的个人和系统可以访问日志文件。如果它们包含敏感信息，则需要加密。然而，我们需要与适用的监管框架和内部安全政策进行核实，以查看是否允许这样做。如果我们的源代码包含递归，我们应确保相同的异常或错误不会被多次记录。我们还必须考虑日志文件的数据保留策略，以避免账单冲击。一个合理的日志记录方法将能够提供良好的监控和可观察性能力，接下来我们将讨论这一点。
- en: Monitoring and observability
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控与可观察性
- en: A monitoring solution is needed to make sense of the logs, and we need alerts
    to be notified about any critical events.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 需要一个监控解决方案来解析日志，并且我们需要设置警报，以便在发生任何关键事件时收到通知。
- en: OpenTelemetry is an open source observability framework. It is designed to capture
    and process telemetry data, including metrics, logs, and traces from cloud native
    applications. It provides a set of APIs, libraries, agents, and instrumentation
    to help DevSecOps teams monitor application behavior. It fosters standardized
    data collection and consistent observability across applications and environments.
    A significant benefit is the interoperability with various backend systems. Because,
    with OpenTelemetry, we can instrument a standardized code, we can easily swap
    to different backends and tools. This reduces the vendor lock-in. OpenTelemetry
    has strong community support and is backed by major CSPs and observability vendors,
    ensuring ongoing improvements, broad compatibility, and shared knowledge and best
    practices. When choosing a new observability product, it is worthwhile to make
    OpenTelemetry support an evaluation criterion.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: OpenTelemetry 是一个开源的可观察性框架。它旨在捕获和处理遥测数据，包括来自云原生应用程序的度量、日志和追踪数据。它提供了一套 API、库、代理和工具，用于帮助
    DevSecOps 团队监控应用程序的行为。它促进了跨应用程序和环境的数据收集标准化和一致的可观察性。一个显著的好处是与各种后端系统的互操作性。因为通过 OpenTelemetry，我们可以为代码提供标准化的工具，这样就可以轻松地切换到不同的后端和工具。这减少了供应商的锁定。OpenTelemetry
    拥有强大的社区支持，并得到了主要云服务提供商和可观察性供应商的支持，确保了持续的改进、广泛的兼容性以及共享的知识和最佳实践。在选择新的可观察性产品时，值得将
    OpenTelemetry 支持作为评估标准。
- en: Popular open source tools that support OpenTelemetry are Prometheus for metrics
    collection, Grafana for visualization, Fluentd for log collection, and Jaeger
    for distributed tracing.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 支持 OpenTelemetry 的流行开源工具包括用于度量收集的 Prometheus、用于可视化的 Grafana、用于日志收集的 Fluentd
    和用于分布式追踪的 Jaeger。
- en: When setting up alerts, it is also critical to consider a team roster for on-call
    times. This defines when a particular DevSecOps team member needs to be available
    to solve incidents. It should also provide some flexibility and allow temporary
    roster changes if an individual is unavailable due to personal circumstances.
    If our team operates across different time zones, the tool must address that.
    Popular commercial offerings are PagerDuty and Atlassian Opsgenie. Observability
    helps to gain application insights in real time and to be able to react swiftly
    to any unexpected behavior. We aim to architect robust, scalable, and elastic
    solutions. But we also need to address the insights that we gained from an incident
    to improve resilience, which we will elaborate on in the next section.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置警报时，考虑值班团队成员的排班时间也至关重要。这定义了某个特定的 DevSecOps 团队成员何时需要待命以解决事件。它还应提供一定的灵活性，并允许在个人因个人原因无法参与时临时调整排班。如果我们的团队跨越多个时区，工具必须能够解决这个问题。流行的商业产品有
    PagerDuty 和 Atlassian Opsgenie。可观察性有助于实时获得应用程序的洞察，并能够迅速应对任何意外行为。我们的目标是构建强大、可扩展和弹性的解决方案。但我们也需要处理从事件中获得的洞察，以提高系统的韧性，这将在下一节中详细阐述。
- en: Resilience
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 韧性
- en: Addressing resilience in a cloud native architecture is crucial to understanding
    how the application can withstand failures. Failures can occur on any layer in
    the architecture and in any of the components involved. AWS released the first
    version of the *AWS Well-Architected Framework*, Microsoft followed with an Azure
    version in 2020, and Google released the *Google Cloud Architecture Framework*
    in 2021\. All three frameworks have a *Reliability* pillar or chapter in their
    framework. Nevertheless, this area is often misunderstood, especially in the early
    days of a cloud adoption journey. It is the architect’s and engineer’s responsibility
    to design and implement the application in a way that addresses possible failures.
    If we leverage managed services, then the CSP will take a lot of considerations
    into account, and we can reduce the reliability surface that we need to manage.
    We will discuss this in detail in [*Chapter 7*](B22364_07.xhtml#_idTextAnchor198).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在云原生架构中处理韧性问题对于理解应用程序如何承受故障至关重要。故障可能发生在架构中的任何层级和任何相关组件中。AWS 发布了 *AWS Well-Architected
    Framework* 的第一个版本，微软在 2020 年发布了 Azure 版本，谷歌则在 2021 年发布了 *Google Cloud Architecture
    Framework*。这三个框架中都有一个关于 *可靠性* 的支柱或章节。然而，这一领域通常被误解，特别是在云采纳的初期阶段。设计和实施能够应对可能故障的应用程序是架构师和工程师的责任。如果我们利用托管服务，云服务提供商将考虑到许多因素，我们可以减少需要管理的可靠性表面。我们将在
    [*第七章*](B22364_07.xhtml#_idTextAnchor198) 中详细讨论这一点。
- en: Humans can fail – so can the cloud
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 人类可能会失败——云也会失败
- en: Even though the CSP is responsible for the resilience of the cloud services,
    outages can and will occur. “*Everything fails, all the time*” is a famous quote
    from Amazon’s chief technology officer, Werner Vogels.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管云服务提供商（CSP）负责云服务的弹性，停机事件仍然可能发生。亚马逊首席技术官沃纳·沃格尔（Werner Vogels）曾说过一句名言：“*一切都会失败，始终如此*”。
- en: There are a variety of infrastructure failure scenarios on the CSP side, such
    as service outages, AZ outages, region outages, or global services outages, such
    as a DNS outage. These are just some examples, and, of course, we can also have
    outages within the actual application. Examples are misconfiguration of load balancing
    or database connection pools, running out of disk or storage space, not allocating
    enough compute power such as memory or CPU size, unexpected configuration drift,
    or software vulnerabilities. We need to consider guiding principles when architecting
    resilience, and we will step through these now.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在CSP方面，有多种基础设施故障场景，例如服务中断、可用区中断、区域中断或全球服务中断，如DNS中断。这些只是一些例子，当然，我们也可能在实际应用中遇到故障。例子包括负载均衡或数据库连接池的配置错误、磁盘或存储空间用尽、未分配足够的计算能力（如内存或CPU大小）、意外的配置漂移或软件漏洞。在架构弹性时，我们需要考虑一些指导原则，接下来我们将逐一讨论这些原则。
- en: Automating recovery
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动化恢复
- en: First, an application should automatically recover from failure. This behavior
    is also known as self-healing. A failure needs to be discovered to initiate an
    automated recovery process. We put health checks in place. Those health checks
    can trigger follow-up actions. For example, we can configure health checks on
    a load balancer, and if a container instance behind the load balancer fails, it
    will be automatically replaced with a new instance. For this recovery scenario,
    it is essential to have a quick start-up time. Therefore, lean container images
    such as Docker Alpine are widely used.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，应用程序应该能自动从故障中恢复。这种行为也被称为自愈。必须发现故障才能启动自动恢复过程。我们会设置健康检查，这些健康检查可以触发后续的操作。例如，我们可以在负载均衡器上配置健康检查，如果负载均衡器后面的容器实例发生故障，它将被自动替换为新的实例。在这种恢复场景中，快速启动时间至关重要。因此，像Docker
    Alpine这样的精简容器镜像被广泛使用。
- en: Another guiding principle is that all change must be managed through code and
    automation. Automation enables a repeatable outcome and allows all changes to
    be tracked and reviewed. CI/CD becomes one of our best friends when we move into
    a cloud native world. Write access should be limited to CI/CD pipelines. Developers
    should be limited to read-only access for all environments except for sandbox
    environments. If human access is required in an incident, then there should be
    a break-glass mechanism. That means the elevated permissions are limited to the
    required timeframe and audit logs capture all manually performed changes.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个指导原则是所有变更必须通过代码和自动化进行管理。自动化能够确保可重复的结果，并允许所有变更被追踪和审查。当我们进入云原生世界时，CI/CD成为我们最好的伙伴之一。写入访问权限应仅限于CI/CD流水线。除沙箱环境外，开发人员应仅限于对所有环境的只读访问权限。如果在发生事故时需要人工干预，则应该有一个破玻机制。这意味着提升的权限仅限于所需的时间框架，并且审计日志会捕获所有手动执行的更改。
- en: Resilience and scalability
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 弹性与可扩展性
- en: Recovery procedures must be tested. A working backup routine does not guarantee
    backup integrity or that the recovery procedure will work as planned. Our business
    continuity plan needs to address recovery testing. We must validate the documentation
    during a recovery test and update the documented recovery steps if required. A
    data criticality framework will help to define the proper **recovery time objectives**
    (**RTOs**) and **recovery point objectives** (**RPOs**). The RTO defines the maximum
    time to restore a failed application after an outage. The RPO defines the maximum
    time we tolerate for a data loss. For instance, if the RPO is 1 minute, we accept
    the risk that we could lose data for 60 seconds. Therefore, we will need to configure
    automated backups for every minute. The shorter the RTO is, the more frequently
    we need to perform backups. We need to consider cost and performance trade-offs
    to make informed decisions. We must test other recovery scenarios, such as network
    recovery.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 必须测试恢复程序。一个有效的备份程序并不能保证备份的完整性或恢复程序能够按计划正常工作。我们的业务连续性计划需要涵盖恢复测试。我们必须在恢复测试期间验证文档，并在必要时更新恢复步骤文档。一个数据重要性框架将有助于定义适当的**恢复时间目标**（**RTOs**）和**恢复点目标**（**RPOs**）。RTO定义了恢复失败应用程序的最大时间。RPO定义了我们能容忍的数据丢失最大时间。例如，如果RPO是1分钟，那么我们接受可能会丢失60秒的数据风险。因此，我们需要配置每分钟一次的自动备份。RTO越短，我们需要进行备份的频率就越高。我们需要考虑成本和性能的权衡，以做出明智的决策。我们还必须测试其他恢复场景，例如网络恢复。
- en: Another resilience guiding principle is that an application should scale horizontally
    to increase availability. Horizontal scaling means we scale out in the event of
    a traffic spike. Typically, additional instances are spun up behind a load balancer
    to distribute the load. If we architect the solution for auto-scaling, capacity
    guesses become somewhat irrelevant. We still need to consider hard service limits
    published by the cloud vendors. But with dynamic provisioning and auto-scaling,
    we rely less on capacity estimates. Auto-scaling also helps reduce the CSP cost
    since we can right-size based on dynamic demand changes instead of statically
    provisioning for peak times.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个弹性指导原则是，应用程序应横向扩展以提高可用性。横向扩展意味着在流量激增时进行扩展。通常，额外的实例会在负载均衡器后面启动以分担负载。如果我们为自动扩展架构解决方案，容量预估就变得不那么重要了。我们仍然需要考虑云服务商发布的硬性服务限制。但通过动态配置和自动扩展，我们对容量估算的依赖减少了。自动扩展还有助于降低云服务提供商的成本，因为我们可以根据动态需求变化来调整资源，而不是为峰值时段静态配置。
- en: Testing the recovery
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试恢复能力
- en: Game days are an excellent way to validate resilience and uncover weaknesses
    that require remediation to improve application reliability or security posture.
    These are structured events where teams simulate different failure scenarios to
    test the auto-recovery, the efficiency of human processes, and the accuracy of
    the recovery documentation. The goals of the game day need to be defined before
    we can select failure scenarios. We will also need an environment where we can
    simulate outages. If our applications, including infrastructure, are defined as
    code and can be deployed via CI/CD pipelines, creating a temporary environment
    for that purpose will be easy. The game days usually start with a team briefing
    before the incident simulation commences. Typical scenarios include shutting down
    servers or containers, throttling network bandwidth, or simulating cloud service
    outages.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏日是验证弹性并发现需要修复的弱点，以提升应用程序可靠性或安全性的一种绝佳方式。这些是结构化的事件，团队模拟不同的故障场景，以测试自动恢复、人工流程的效率和恢复文档的准确性。游戏日的目标需要在选择故障场景之前定义清楚。我们还需要一个可以模拟停机的环境。如果我们的应用程序，包括基础设施，是以代码定义并且可以通过CI/CD管道进行部署，那么为此目的创建一个临时环境将变得很容易。游戏日通常以团队简报开始，然后才进行事故模拟。典型的场景包括关闭服务器或容器、限制网络带宽或模拟云服务停机。
- en: 'We can simulate outages with fault injection simulators. Netflix developed
    tools for this purpose and released Chaos Monkey in 2011\. It randomly terminates
    instances. Other tools followed, including Latency Monkey, to simulate network
    latencies or unreliable network conditions. Nowadays, the major cloud platforms
    offer cloud native fault simulators: AWS Fault Injection Service, Azure Chaos
    Studio, and Google Cloud Chaos Engineering.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Once the fault injection has started, the team members need to detect where
    the problem is by using the observability tools and diagnosing findings. Data
    recovery needs to be validated. The validation includes data integrity validation
    and performance testing.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: The insights gained will lead to mitigation steps, such as improving data recovery
    or fixing a misconfigured auto-scaling. The day ends with analyzing what worked
    well and what did not. These required improvements need to be implemented and
    tested again at a later stage. Game days are a good way of embedding feedback
    loops in our DevSecOps culture.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have explored a holistic picture of cloud native benefits, both
    cultural and technological aspects, we will finish this chapter by clarifying
    some common misunderstandings. This knowledge will help us to navigate through
    the anti-patterns that we will discuss afterward.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Common misunderstandings
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, we have a good understanding of cloud native. But why are there so many
    misunderstandings? The concepts are complex and require different ways of working.
    Technology is changing rapidly, and there is a lack of standardization, which
    leads to various interpretations. Moving toward cloud native requires a lot of
    training and a new mindset.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'Misunderstandings can lead to the following shortcomings:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Slow time to market
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lack of security
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lack of fault tolerance
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lack of backup and recovery
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inefficient DevOps and CI/CD best practices
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increased operational effort
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increased **total cost of** **ownership** (**TCO**)
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will now examine some common cloud native misunderstandings. Each will result
    in several of the listed shortcomings.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: The shared responsibility model
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not understanding the shared responsibility between the CSP and the customer
    is a misunderstanding with very severe consequences. The shared responsibility
    model articulates security and compliance ownership. The CSP is responsible for
    the “security *of* the cloud.” That means they protect the underlying infrastructure
    that runs the services offered to the customers. Those are the data centers and
    the infrastructure that delivers cloud services. The customer is responsible for
    “security *in* the cloud,” for example, for their data or ensuring that encryption
    is enabled.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: In an **infrastructure as a service** (**IaaS**) model, the customer has the
    highest level of responsibility. The CSP only manages foundational infrastructure,
    such as networks, data storage, and VMs that can host the guest operating system.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: The customer’s responsibility is to manage their network constructs, such as
    a **network address translation** (**NAT**) gateway. The customer must also manage
    application-level controls, identity and access management, endpoints, and data.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: In a **platform as a service** (**PaaS**) model, the CSP manages infrastructure
    and platform components such as the operating system, libraries, and runtime.
    Customers are responsible for data management and user access for their applications.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: The SaaS provider manages most security responsibilities in a SaaS model, including
    software, infrastructure, networks, and application-level security. The customer
    is responsible for data protection, account management, and user access.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows how responsibilities change when we move from on-premises
    to IaaS, PaaS, and SaaS. Whether we choose IaaS, PaaS, or SaaS, the following
    areas will always be our responsibility: data, endpoints, access management, and
    account or subscription management.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2: The shared responsibility model](img/B22364_01_2.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 - The shared responsibility model
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: When we look at serverless technologies such as FaaS (AWS Lambda, Azure Functions,
    and GCP Cloud Functions), the customer’s responsibility is between SaaS and PaaS.
    The customer user is accountable for the serverless service’s deployed code and
    user-defined security or configuration options. Many organizations have a cloud
    platform team that establishes a platform for the product teams. They will often
    use a cloud native landing zone offering that provides a preconfigured, secure,
    and scalable environment designed to streamline cloud adoption, enhance security
    and compliance, and improve operational efficiency. In large organizations, the
    cloud platform team typically manages AWS accounts, Azure subscriptions, and Google
    projects. The cloud platform team will leverage cloud native account vending services
    such as the AWS account vending service or the Azure subscription vending service
    to perform this task.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'The cloud platform team typically provides a service catalog that contains
    self-service artifacts, such as containers, network constructs for routing, guardrails,
    observability tooling, and more. Some artifacts will be provisioned as part of
    the automated account creation, including networking constructs, logging and monitoring
    capabilities, and guardrails. The product teams might publish other items to the
    service catalog or the container registry. In this case, we have a three-tiered
    shared responsibility model: the CSP, the cloud platform team, and the product
    teams. This can result in confusion around the operating model, which we will
    discuss next.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Operating model confusions
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The operating model needs to address the responsibility model, and a clearly
    defined RACI matrix will help everyone understand what to do (**RACI** stands
    for **responsible, accountable, consulted, and informed**). The RACI matrix should
    include all phases in the SDLC, from source code to operations. Some example tasks
    that should be in the RACI matrix are certificate management, DNS management,
    key management, backup, and recovery.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: When I worked for a cloud and DevOps consultancy, I started a new engagement
    with an educational institution. It was my first morning on site when an administrator
    accidentally deleted an entire data warehouse environment. Unfortunately, this
    was the only non-production environment. The data warehouse is a very business-critical
    application since it manages all the data of university applicants and students.
    We then tried to recover from backups. Unfortunately, the data recovery had never
    been tested. The backup data was corrupt and, therefore, useless.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Another administrator then asked whether we could call Amazon and ask them for
    backups. This question demonstrates that the shared responsibility model is not
    always understood. The administrator should not have had permission to delete
    an environment in the first place. Access and identity management, including the
    principle of least privilege enforcement, is the customer’s responsibility. Also,
    data management, including backups and recovery testing, is the responsibility
    of the customer. After that incident, we built a self-healing solution for the
    client and improved the permission model.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Missing out on cultural transformation
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another common misunderstanding is that cloud native is only about technology.
    We have talked about the DevSecOps culture before. The full potential will only
    be utilized if we are changing the culture. Otherwise, business innovation will
    be limited. It is easy to experiment in the cloud, create new proofs of concept,
    tear them down, or change them, but only with a DevSecOps mindset when mature
    automation practices are established. We need to put an effort into cultural transformation
    and leverage training and team augmentation. Otherwise, the resistance to change
    will continue, and the opportunity for quick change and release cycles can never
    be unleashed.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: The lack of DevSecOps maturity will result in poor governance, limited agility,
    and slow responsiveness to market needs. A siloed approach where development and
    operations are separated will be reflected in the application structure as described
    in Conway’s Law. Eventually, the end customer experience will not be as good as
    possible. Another consideration is that cost management and ownership differ from
    an on-premises CapEx model. We are shifting toward **operational expenses** (**OpEx**),
    and without cost ownership and cost tagging, we cannot achieve effective showback
    or chargeback models.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: If cloud native is solely seen as a technology enabler, we will not achieve
    efficient cost management. There will also be security challenges, which brings
    us to the following fundamental misunderstanding.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Treating cloud like on-premises
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Believing that security controls in the cloud are the same as on-premises can
    also lead to many anti-patterns. This misbelief brings significant security risks
    and challenges and can dramatically reduce efficiencies and slow down our time
    to market.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: We must manage data encryption, access controls, and backups for an on-premises
    environment. CSPs offer native security controls for encryption and access control.
    However, these controls need to be configured by the customer. It is critical
    to understand the responsibility demarcation, and it shows why understanding the
    shared responsibility model is so important. In other words, we can establish
    data security controls much easier in the cloud. Still, we must remember to look
    into our security and regulatory requirements and assess the attack vector.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Because of the global nature of the cloud, it is also easy to copy data to different
    regions. Cross-region support is a feature, but it can also be a trap with severe
    consequences. Since it is straightforward to switch between areas, it is recommended
    to have a policy-as-code framework in place that prevents that from happening
    by accident.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: To manage network security on-premises, we use firewalls, VPNs, and intrusion
    detection and prevention systems, which we must manage ourselves. Cloud native
    offers virtual network segmentation and security features such as NACLs, security
    firewalls, and managed firewall services. Those controls need to be configured
    by the customer, but this can be done much easier than on-premises. We can guarantee
    consistent security controls between environments if those controls are managed
    via source code and deployed via CI/CD pipelines. This approach has similarities
    with application security. For on-premises workloads, we need to build all the
    controls, including vulnerability management and application firewalls. If we
    utilize a fully managed service, such as a managed database service or FaaS, the
    CSP is already taking care of the majority. We still need secure coding practices
    and scan our code, but we don’t need to scan the managed runtime environment.
    The CSP manages that for us; they have comprehensive compliance coverage. The
    coverage applies at least to the level managed by the CSP and we can download
    compliance reports for external audits. The customer still needs to take care
    of the layer above, as described in the shared responsibility model. However,
    cloud native provides compliance and audit features that can be configured for
    our needs. Cloud native services include Azure Compliance Manager, AWS Config,
    and Google Cloud Compliance Resource Center.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Lift & shift will leverage the full cloud potential
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Thinking that a lift and shift approach will leverage all cloud benefits is
    another widely spread misbelief. *Lift and shift* means an application is moved
    from on-premises to the cloud without rearchitecting and refactoring. Lift and
    shift does not leverage any cloud native benefits. Instead of leveraging a managed
    database service, the database will be built using VMs, which requires installing
    the operating system and database. That means we must patch the database server,
    scan it for vulnerabilities, and develop and manage the entire security from scratch
    instead of leveraging built-in features. It would be much simpler if we could
    migrate our database to a managed database service. That way, we can significantly
    reduce the operational complexity and simplify the security approach. Cloud native
    services also have built-in scalability, resilience, and observability features.
    They simplify the application architecture and make it easier to operate the application.
    A lift and shift approach is very costly; such an application’s operational cost
    can be higher than on-premises. A driver for lift and shift could be a data center
    exit strategy. The overall effort will be higher because we need to build all
    the security controls and building blocks traditionally and then refactor the
    application toward cloud native. The effort duplication brings many challenges
    and a high likelihood of a budget blowout.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Containers solve everything
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: “Moving everything onto containers will make my application cloud native” is
    another widespread misconception. A containerized application does not necessarily
    utilize all the cloud native features we have explored. There are several variations
    of this misunderstanding. Another one is that cloud native requires containers.
    Even though containers are a fundamental technology in this space, they are not
    necessarily required. We might be able to use FaaS if that is a good architectural
    fit for our goal. In that case, we don’t need to manage containers or a cluster.
    A further variation of the container misunderstanding is that Kubernetes is required.
    Kubernetes is the most popular container orchestration platform, and the CSP offers
    managed Kubernetes services. There are some excellent use cases for it, such as
    microservice architectures. However, it comes with a steeper learning curve compared
    to Faas, and it is often underestimated. It is also worthwhile checking whether
    the required skills are available in the geographical market where the team needs
    to be.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Security can be an afterthought
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A very concerning misunderstanding is that security can be bolted on afterward.
    Security must be considered and integrated from the beginning. “*Security is job
    zero*” is a well-known quote first mentioned by AWS’s chief information security
    officer in 2017\. It means that security is everyone’s responsibility and should
    be considered the foundational priority in all cloud and IT operations, even before
    other jobs or tasks, hence *job zero*. In the DevSecOps section of this chapter,
    we discussed how security aspects need to be addressed early, ideally starting
    with security checks in the IDE, having scans embedded in the CI/CD pipeline,
    and continuing with scans in our environments. A lot of this end-to-end coverage
    will not be present if security gets retrofitted later on. That means the application
    has an increased attack surface, and data breaches become more likely because
    of a lack of guardrails. There might be operational interruptions, maybe because
    a cloud native firewall that would protect from DDoS attacks or SQL intrusions
    is not used from the beginning onward. Or certificates expire because the cloud
    native certificate manager that also renews certificates is not being used. There
    will also be a risk that compliance requirements cannot be met. These factors
    can result in reputational damage, negatively impacting our business. Therefore,
    it is best to address security right from the beginning.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Cloud native versus microservices
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another misunderstanding is that cloud native and microservices have the same
    meaning. People sometimes use the two terms interchangeably, but they differ in
    some respects. Cloud native is an overarching approach that includes a variety
    of practices and tools for developing and running applications in the cloud. It
    focuses on scalability, resilience, continuous delivery, and leveraging cloud
    infrastructure. Cloud native includes containerization, orchestration, a DevSecOps
    culture, and automation through CI/CD pipelines. It addresses the entire SDLC
    and operations in the cloud. The microservices concept provides architecture guidance
    specifically on how to break down applications into smaller, independently deployable
    components. Cloud native applications leverage features and infrastructure. They
    are designed to run in the cloud. A microservices architecture can be applied
    to any application, whether hosted on-premises or in the cloud. Microservices
    hosted in the cloud can be part of a cloud native strategy.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: Other misunderstandings
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: These are the main misunderstandings, and let’s just quickly step through a
    couple more.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'Cloud native adoption will automatically save money. This is only true if the
    solution is architected in the right way. We went through that when we talked
    about lift and shift and containers. Another one is that cloud native is not as
    secure as on-premises. This is also totally wrong: the security controls are different
    from on-premises. If we utilize managed services, then the complexity of the security
    will decrease.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: There are many drivers for adopting a cloud native stack, such as business agility,
    operational efficiency, time to market, developer productivity, and others. Our
    key drivers will depend on our business strategy. The cloud strategy needs to
    align with or be embedded in it to ensure the cloud native adoption delivers the
    best possible outcome. We will look into the strategy in the next chapter.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This introductory chapter has already covered a lot of ground. We learned about
    the evolution and benefits of cloud native. We discussed how culture is part of
    cloud native and how DevOps evolved to DevSecOps. It is critical to consider security
    throughout the complete SDLC. We also looked into foundations for CI/CD, observability,
    and resilience. We also clarified common misunderstandings, which will be helpful
    for conversations with stakeholders and the remainder of the book. Now that we
    are equipped with an excellent foundational understanding, we are ready to look
    into anti-patterns. We will start with objectives and strategy in the next chapter
    since they will be defined at the beginning of our cloud native adoption.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Setting Up Your Organization for Success'
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This second part focuses on strategic areas of our cloud adoption journey. These
    areas include strategy, governance, FinOps, DevSecOps culture, continuous integration
    and continuous delivery (CI/CD), and security. Within each area, we will explore
    common anti-patterns before discussing what good looks like and how to transition
    into good habits.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 2*](B22364_02.xhtml#_idTextAnchor055)*, The Cost of Unclear Objectives
    and Strategy*'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 3*](B22364_03.xhtml#_idTextAnchor085)*, Rethinking Governance in
    a Cloud Native Paradigm*'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B22364_04.xhtml#_idTextAnchor112)*, FinOps – How to Avoid a Bill
    Shock*'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B22364_05.xhtml#_idTextAnchor136)*, Delivering Rapidly and Continuously
    Without Compromising Security*'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B22364_06.xhtml#_idTextAnchor165)*, How to Meet Your Security
    and Compliance Goals*'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
