<html><head></head><body>
		<div id="_idContainer032">
			<h1 id="_idParaDest-133" class="chapter-number"><a id="_idTextAnchor194"/>7</h1>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor195"/>Templating, Iterating, and Conditionals</h1>
			<p>This chapter will cover advanced structures for the Puppet language, including templates that enable the insertion of variables into templated files. The two formats available in Puppet, <strong class="bold">Embedded Ruby </strong>(<strong class="bold">ERB</strong>) templates, which are based on native Ruby templating, and <strong class="bold">Embedded Puppet </strong>(<strong class="bold">EPP</strong>) templates, which are modern Puppet language-based <a id="_idIndexMarker456"/>templates, will be discussed, highlighting the <a id="_idIndexMarker457"/>differences between the two and the core advantages of using EPP <span class="No-Break">over ERB.</span></p>
			<p>Additionally, the chapter will delve into the use of iteration and loops in Puppet, showing how iterative functions are used with sections of code known as lambdas in Puppet instead of more traditional <strong class="source-inline">loop</strong> keywords of other languages. Finally, the chapter will examine the different types of conditional statements available in Puppet, including <strong class="source-inline">if</strong>, <strong class="source-inline">case</strong>, and <strong class="source-inline">unless</strong> statements, which are typical of any programming language, and the Puppet-specific selector, which allows a value on a key or variable to be chosen based on a fact or variable. The chapter will also examine the use of regular expressions within conditionals <span class="No-Break">in detail.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Templating formats in Puppet – EPP <span class="No-Break">and ERB</span></li>
				<li>Iteration <span class="No-Break">and loops</span></li>
				<li><span class="No-Break">Conditional statements</span></li>
			</ul>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor196"/>Technical requirement</h1>
			<p>All code in this section can be tested on the local <span class="No-Break">development server.</span></p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor197"/>Templating formats in Puppet – EPP and ERB</h1>
			<p>Templating in Puppet allows for the generation of content in a standard format, by substituting <a id="_idIndexMarker458"/>variables and using conditional logic to customize the <a id="_idIndexMarker459"/>content. Puppet supports two templating formats: ERB, which <a id="_idIndexMarker460"/>is a native Ruby templating format (<a href="https://github.com/ruby/erb">https://github.com/ruby/erb</a>) and has been available in all versions of Puppet; and EPP templates, which are based on the Puppet language, were introduced in Puppet 4, and are available in later versions of Puppet 3 with the future <span class="No-Break">parser enabled.</span></p>
			<p>Templates provide greater flexibility than strings but are less flexible than using resources such as <strong class="source-inline">file_line</strong>, <strong class="source-inline">augueas</strong>, or <strong class="source-inline">concat</strong> for controlling individual or groups of settings. Therefore, a balance of complexity needs to be struck when deciding whether to use templates <span class="No-Break">or resources.</span></p>
			<p>For relatively short <strong class="source-inline">heredoc</strong> files or simple strings, templates with variable interpolation may be sufficient. However, for more complex files and particular files where multiple modules may be managing different settings or where manual edits may be accepted, using resources for each setting or section would be less complex and <span class="No-Break">more manageable.</span></p>
			<p>In older code, it is possible to find that templates were overused, which can reflect the lack of availability of resource types such as <strong class="source-inline">file_line</strong> in previous versions of Puppet. It is important to review what state was being attempted to be achieved and ensure that by using templates to control all the content settings, a whole file is not being unnecessarily enforced, which may contain settings that have become redundant as the underlying application associated with the configuration file has updated and changed its <span class="No-Break">configuration settings.</span></p>
			<p>While there is no reason to use ERB for new code, many forge modules and legacy code bases may contain ERB, and thus both formats will be covered in this section to provide understanding. After showing the syntax of both formats, the advantages of using EPP and reasons to convert ERB to EPP will <span class="No-Break">be discussed.</span></p>
			<p>Templates can be <a id="_idIndexMarker461"/>generated either by using content in template files or via a string, which is known as an inline template. For template files, ERB uses the <strong class="source-inline">template</strong> function and EPP uses the <strong class="source-inline">epp </strong>function. For inline templates, EPP uses the <strong class="source-inline">inline_epp</strong> function and ERB uses the <span class="No-Break"><strong class="source-inline">inline_template</strong></span><span class="No-Break"> function.</span></p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor198"/>EPP templates</h2>
			<p>An EPP template file is a text file that contains a mixture of text and Puppet language expressions surrounded <a id="_idIndexMarker462"/>by tags. These tags indicate how the Puppet expression should be evaluated and can <a id="_idIndexMarker463"/>modify the text in the template, allowing for the creation of a file based on Puppet language features such as variable interpolation, logic statements, <span class="No-Break">and functions.</span></p>
			<p><em class="italic">Table 7.1 </em>shows the available tag types that can <span class="No-Break">be used:</span></p>
			<table id="table001-3" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Tag Name</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Starting tag (</strong><span class="No-Break"><strong class="bold">with trimming)</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Ending tag (</strong><span class="No-Break"><strong class="bold">with trimming)</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Purpose</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Parameter</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">&lt;% |  </strong>(<strong class="source-inline">&lt;%- |</strong>)</p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">|%&gt; </strong>(<strong class="source-inline">| - %&gt;</strong>)</p>
						</td>
						<td class="No-Table-Style">
							<p>Declare parameters accepted by <span class="No-Break">the template</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Non-printing expression</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">&lt;% </strong>(<strong class="source-inline">&lt;%-</strong>)</p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">%&gt; </strong>(<strong class="source-inline">&lt;%-</strong>)</p>
						</td>
						<td class="No-Table-Style">
							<p>Evaluate the Puppet code but <span class="No-Break">don’t print</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Expression printing</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">&lt;%=</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">%&gt; </strong>(<strong class="source-inline">-%&gt;</strong>)</p>
						</td>
						<td class="No-Table-Style">
							<p>Evaluate the code to a value <span class="No-Break">to print</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Comment</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">&lt;%# </strong>(<strong class="source-inline">&lt;%#-</strong>)</p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">%&gt;  </strong>(<strong class="source-inline">-%&gt;</strong>)</p>
						</td>
						<td class="No-Table-Style">
							<p>Allow the addition of comment lines just for the template <span class="No-Break">file itself</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 7.1 – EPP template tags</p>
			<p>When a template is evaluated, it switches between text mode and Puppet mode as it encounters start tags, and returns to text mode as it reaches end tags. In text mode, it outputs the text as content, and when it finds a tag, the Puppet code between the start and end tags is evaluated, depending on the kind of <span class="No-Break">start tag.</span></p>
			<p>As noted in <em class="italic">Table 7.1</em>, some of the tags can be modified with a hyphen (<strong class="source-inline">-</strong>) to trim spaces and new lines <span class="No-Break">as appropriate.</span></p>
			<p>The parameter tag is optional and, if used, must be the first content in a template file, except for a comment tag, which <a id="_idIndexMarker464"/>must use a closing hyphen. It produces behavior similar to how parameters can be declared at the start of Puppet classes, as was shown in <a href="B18492_08.xhtml#_idTextAnchor212"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>. The parameters follow the same pattern as a class, so they can optionally include a type at the <a id="_idIndexMarker465"/>beginning. They <a id="_idIndexMarker466"/>must then have a dollar (<strong class="source-inline">$</strong>) symbol followed by a variable name, optionally followed by an equal (<strong class="source-inline">=</strong>) symbol and a default value, and finally, they must end with <span class="No-Break">a comma.</span></p>
			<p>For example, to have an options parameter containing a string set to an empty string by default, an <strong class="source-inline">application_mode</strong> parameter, which can contain full, partial, or none strings and defaults to <strong class="source-inline">node</strong>, and a <strong class="source-inline">cluster_enabled</strong> parameter, which is a Boolean, the following code would start <span class="No-Break">our template:</span></p>
			<pre class="source-code">
&lt;%- |
String $options = '',
Enum[full,partial,none] $application_mode = 'none',
Boolean $cluster_enabled,
|-%&gt;</pre>
			<p>When parameters are passed to an EPP template, they become local scope and can just be called directly by name, but variables from the calling class must be called by full namespace name; this is similar to a defined type. Any parameters without a default value, such as <strong class="source-inline">cluster_enabled</strong> in the preceding example, are mandatory and must be <span class="No-Break">passed in.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">It is recommended to always use hyphens with parameters to avoid any accidental white space at the start of <span class="No-Break">a template.</span></p>
			<p>If parameters are not used, class variables can be directly accessed using the class scope, such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">$example_module::example_param</strong></span><span class="No-Break">.</span></p>
			<p>Parameters allow a template to be more flexible if it is to be used in several different places, ensuring the data is more defined and locked down to requirements and making it clear at a glance what data is consumed. It may become a better option to just use variables when you need to use a lot of variables and parameters would just not scale. Passing parameters not defined in the parameter list will result in a syntax error, although if no parameters are used, any parameters can be passed to the template. Later in this section, it will be seen how to pass a hash to the <strong class="source-inline">epp_template</strong> function when <span class="No-Break">referencing it.</span></p>
			<p>The <strong class="source-inline">comment</strong> tag in Puppet templates allows for comments to be added within the template <a id="_idIndexMarker467"/>file itself. These <a id="_idIndexMarker468"/>comments will not <a id="_idIndexMarker469"/>appear in the output when the template is evaluated and its content is generated. Here’s an example of what a comment would look like in a <span class="No-Break">Puppet template:</span></p>
			<pre class="source-code">
&lt;%#- An example comment. -%&gt;</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">&lt;%#-</strong> hyphen trimming feature is available from Puppet 6.0.0 onward. Before this, the trimming behavior <span class="No-Break">was assumed.</span></p>
			<p>An expression printing tag puts the returned value of a Puppet expression into the output. This can be a <a id="_idIndexMarker470"/>variable or fact, the output of a function, or the output for operators. The final output is a string and will be automatically converted if necessary. At its simplest level, this can be used to print a fact as a value. For example, the following line will read <strong class="source-inline">application = exampleapp</strong> if the <strong class="source-inline">application_name</strong> fact contained the <span class="No-Break"><strong class="source-inline">exampleapp</strong></span><span class="No-Break"> value:</span></p>
			<pre class="source-code">
application = &lt;%= $facts[application_name] -%&gt;</pre>
			<p>This example is also the first time variables have been shown in this context, but they are accessed in the same way as variables in regular <span class="No-Break">Puppet code.</span></p>
			<p>Non-printing tags contain iterative and conditional logic. This is different from other tags because the <a id="_idIndexMarker471"/>effect of the tag can span multiple lines until another tag closes the iterator or conditional logic. For example, the <strong class="source-inline">if</strong> statement (which will be covered in the <em class="italic">Conditional statement </em>section) opens with a curly brace, <strong class="source-inline">{</strong>, and closes with a curly brace, <strong class="source-inline">}</strong>. In the following example, we can ensure that if the application name returns <strong class="source-inline">undef</strong> from the <strong class="source-inline">getvar</strong> function, it will not output <strong class="source-inline">application = </strong>as it would have in our previous example. Instead, it will ignore the line if the variable is <span class="No-Break">not defined:</span></p>
			<pre class="source-code">
&lt;% if getvar(facts.application_name) { -%&gt;
 application = &lt;%= $facts[application_name] -%&gt;
&lt;% } -%&gt;</pre>
			<p>Multiple levels of non-printing tags can be used to create nested <strong class="source-inline">if</strong> or <strong class="source-inline">case</strong> statements <span class="No-Break">as appropriate.</span></p>
			<p>There are some syntax mistakes to be careful with. If a non-printing expression tag contains a comment, it will essentially comment to the end of the line and require the close tag on the next line, as per <span class="No-Break">this example:</span></p>
			<pre class="source-code">
&lt;%-# I don't finish commenting here  -%&gt; but on the next line
-%&gt;</pre>
			<p>This mistake could clearly happen with a mistyped <strong class="source-inline">comment</strong> tag so care must be taken and any tags, not just a comment closing tag, would be ignored till the <span class="No-Break">new line.</span></p>
			<p>To include literal <strong class="source-inline">&lt;% </strong>or <strong class="source-inline">%&gt;</strong> characters in the template output without having them evaluated as EPP tags, you can use an additional <strong class="source-inline">%</strong> character to escape them. For instance, to output <strong class="source-inline">&lt;% Puppet expression example %&gt;</strong> as text, you would write <strong class="source-inline">&lt;%% Puppet expression example %%%&gt;</strong>. Note that the escape only applies to the first <strong class="source-inline">&lt;% </strong>or <strong class="source-inline">%&gt;</strong> encountered, so if you need to escape only one of them in a line, you can use the escape once and then the other <span class="No-Break">symbol normally.</span></p>
			<p>EPP templates can <a id="_idIndexMarker472"/>be validated using the <strong class="source-inline">puppet epp validate &lt;template_name.epp&gt; </strong>command, and in <a href="B18492_08.xhtml#_idTextAnchor212"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, it will be seen <a id="_idIndexMarker473"/>that the <strong class="bold">Puppet Development Kit</strong> (<strong class="bold">PDK</strong>) will run this command as part of <span class="No-Break">its validation.</span></p>
			<p>To test the rendering of templates, the <strong class="source-inline">render </strong>command can be used with a hash of values as required: <strong class="source-inline">puppet epp render &lt;template_name.epp&gt; --values '{key1 =&gt; value1, key2 =&gt; </strong><span class="No-Break"><strong class="source-inline">value2}'</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The full specification for EPP templates can be viewed online <span class="No-Break">at </span><a href="https://github.com/puppetlabs/puppet-specifications/blob/master/language/templates.md"><span class="No-Break">https://github.com/puppetlabs/puppet-specifications/blob/master/language/templates.md</span></a><span class="No-Break">.</span></p>
			<p>After reviewing the syntax of the EPP template file, let’s see how to use the <strong class="source-inline">epp</strong> function in a Puppet resource. The <strong class="source-inline">epp</strong> function can be used with resources such as <strong class="source-inline">file</strong> by passing it to the <strong class="source-inline">content </strong>attribute. Additionally, a key-value hash can be provided to specify the parameters, as discussed in the previous section on the <span class="No-Break"><strong class="source-inline">parameter</strong></span><span class="No-Break"> tag:</span></p>
			<pre class="source-code">
file { '/etc/exampleapp.conf':
  ensure =&gt; file,
  content =&gt; epp('exampleapp/exampleapp.conf.epp', {'version' =&gt; '1', 'clustered' =&gt; false}),
}</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">If you wish to try the preceding example on your developer environment, create a suitable template file on your system and change the <strong class="source-inline">exampleapp </strong>module name to the absolute path containing the template, such as <strong class="source-inline">/var/tmp </strong>or<strong class="source-inline"> </strong><span class="No-Break"><strong class="source-inline">C:\Users\David Sandilands</strong></span><span class="No-Break">.</span></p>
			<p>The namespace <a id="_idIndexMarker474"/>used in <strong class="source-inline">epp</strong> assumes that either it will <a id="_idIndexMarker475"/>form a module path, <strong class="source-inline">&lt;modulename/templatename.epp&gt;</strong>, which translates to <strong class="source-inline">modulepath/modulename/templates/templatename.epp</strong>, or it will be an absolute path on disk. In <a href="B18492_08.xhtml#_idTextAnchor212"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, the structure of modules will be covered <span class="No-Break">in detail.</span></p>
			<p>Inline templates are similar to regular templates, but instead of using a separate template file, they require a string or variable to be passed to them. They are generally used for workarounds or where using a heredoc feels easier than using a <span class="No-Break">template file.</span></p>
			<p>One example of a workaround is when using the Vault module, which was discussed in <a href="B18492_05.xhtml#_idTextAnchor123"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, to retrieve secrets using deferred functions. The Vault module returns a key-value pair, but we may only want <a id="_idIndexMarker476"/>to access the value of the password. As the value is deferred, it can’t be manipulated as a string. Using the <strong class="source-inline">inline_epp</strong> function, as shown in the following example, allows us to unwrap the string during agent runtime and apply it to <span class="No-Break">the file:</span></p>
			<pre class="source-code">
$vault_keypair = { 'password' =&gt; Deferred('vault_lookup::lookup', ["secret/examleapp", 'https://vault:8200']), }
file { '/etc/exampleapp_secret.conf':
  ensure =&gt; file,
  content =&gt; Deferred('inline_epp', ['PASSWORD=&lt;%= $password.unwrap %&gt;', $vault_keypair]),
}</pre>
			<p>Having covered EPP templates for <a id="_idIndexMarker477"/>the management <a id="_idIndexMarker478"/>of heritage code, we will now review how ERB <span class="No-Break">is different.</span></p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor199"/>ERB templates</h2>
			<p>ERB templates are <a id="_idIndexMarker479"/>similar to EPP templates, but there are some <a id="_idIndexMarker480"/>differences worth noting. ERB templates are text files that contain a mixture of text and Ruby language expressions surrounded by tags. ERB uses the same tags as EPP, except it does not have parameter tags, and it is not possible to <span class="No-Break">pass parameters.</span></p>
			<p>In ERB, a template has a local scope and a parent scope, which is the class or defined type evaluating the template. Variables in the current scope can be accessed using the <strong class="source-inline">@</strong> symbol, which is how Ruby normally accesses variables. To access variables out of scope, you can use the <strong class="source-inline">scope</strong> object or the older <strong class="source-inline">scope.lookup</strong> function, which was used before the hash format was introduced <span class="No-Break">into Puppet.</span></p>
			<p>To give some simple Ruby examples, you can use an <strong class="source-inline">if</strong> statement to check whether the <strong class="source-inline">exampleapp_extras</strong> variable does not contain <strong class="source-inline">NONE</strong>, and to output the <strong class="source-inline">extras &lt;exampleapp_version&gt; </strong>string in the template. You can also use an <strong class="source-inline">unless</strong> statement to check whether the <strong class="source-inline">exampleapp_key </strong>variable is not <strong class="source-inline">nil</strong>, and to output the <strong class="source-inline">key &lt;exampleapp_nill&gt;</strong> string if it has a <span class="No-Break">defined value:</span></p>
			<pre class="source-code">
&lt;% if @exampleapp_extras!= "NONE" %&gt;extras&lt;%= @exampleapp_version%&gt;&lt;% end %&gt;
&lt;% unless @exampleapp_key.nil? -%&gt;
key &lt;%= @exampleapp_%&gt;
&lt;% end -%&gt;</pre>
			<p>Iteration in Ruby is similar, with the <strong class="source-inline">each</strong> function also available. The following example shows an array of settings from a variable being output one by one in the template content <span class="No-Break">using iteration:</span></p>
			<pre class="source-code">
&lt;% @array_of_settings.each do |setting| -%&gt;
&lt;%= val %&gt;
&lt;% end -%&gt;</pre>
			<p>Data from Puppet variables will be translated from their Puppet type to the equivalent Ruby type (more information can be found in the official Puppet documentation at <a href="https://www.puppet.com/docs/puppet/latest/lang_template_erb.html#erb_variables-puppet-data-types-ruby">https://www.puppet.com/docs/puppet/latest/lang_template_erb.html#erb_variables-puppet-data-types-ruby</a>). However, it <a id="_idIndexMarker481"/>is beyond the <a id="_idIndexMarker482"/>scope of this book to discuss how Ruby can transform <span class="No-Break">this data.</span></p>
			<p>It is also possible to call Puppet functions in ERB templates using the <strong class="source-inline">&lt;%scope.function_name(&lt;Name of function&gt;, &lt;Array of </strong><span class="No-Break"><strong class="source-inline">Arguments&gt;)%&gt;</strong></span><span class="No-Break"> syntax.</span></p>
			<p>For example, to use the <strong class="source-inline">downcase </strong>function on the <strong class="source-inline">example_variable</strong> variable and output the <a id="_idIndexMarker483"/>result to the template, the following code can <span class="No-Break">be used:</span></p>
			<pre class="source-code">
&lt;%= scope.call_function('downcase', [@example_variable]) %&gt;</pre>
			<p>Validating the syntax of an ERB template can be done by running the <strong class="source-inline">erb</strong> command: <strong class="source-inline">erb -P -x -T '-' example.erb | ruby -c</strong>. As with EPP, the PDK will check for both types of templates when running validation. Unfortunately, there is no way to render an <span class="No-Break">ERB template.</span></p>
			<p>Using the content of an ERB template file in a file looks very similar to EPP, but as discussed, it does not have parameters and uses the <strong class="source-inline">template()</strong>function. Converting the EPP example would look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
file { '/etc/exampleapp.conf':
  ensure =&gt; file,
  content =&gt; template('exampleapp/exampleapp.conf.erb'),
}</pre>
			<p>It is possible to pass and evaluate multiple template files, which will be concatenated together. For example, updating content as follows would combine the <span class="No-Break">two templates:</span></p>
			<pre class="source-code">
content =&gt; [ template('exampleapp/exampleapp.conf.erb'), template('exampleapp/exampleapp2.conf.erb')]</pre>
			<p>Inline ERB just uses the <strong class="source-inline">inline_template</strong> function in the same system as inline EPP, and was often <a id="_idIndexMarker484"/>written in the past to allow Ruby code to provide <a id="_idIndexMarker485"/>a workaround for the lack of iteration/loops provided by past versions of Puppet and perform <span class="No-Break">data transformation.</span></p>
			<p>Now that ERB has been discussed, it is time to highlight why EPP is preferred over ERB and reasons to consider converting <span class="No-Break">heritage code.</span></p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor200"/>EPP and ERB comparison</h2>
			<p>After reviewing both syntax templates, it is clear that EPP has several advantages over ERB. Firstly, EPP has significantly better performance than ERB. ERB creates a scope object for all facts and top-scope variables each time a template is evaluated, while EPP only uses <a id="_idIndexMarker486"/>facts and variables relevant to the template. In environments with a large number of facts, this can have a significant impact <span class="No-Break">on performance.</span></p>
			<p>Furthermore, EPP provides greater security because templates can be provided with a limited scope of data to be used and validate that all data exists before use. ERB, on the other hand, has no built-in validation, and non-existent variables will simply be dropped. For example, if a variable in a class has not been evaluated before the template is used, ERB will not <span class="No-Break">catch this.</span></p>
			<p>EPP can also be seen as easier to use since it is in the Puppet DSL style and does not require any Ruby knowledge. This makes it easier to code, especially with the ability to use the <strong class="source-inline">puppet epp render</strong> and <strong class="source-inline">validate</strong> commands. Additionally, EPP is under more active development, and recent features, such as templates being able to automatically unwrap sensitive variables in 6.20 and later, will only be available <span class="No-Break">in EPP.</span></p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor201"/>Iteration and loops</h1>
			<p>Puppet’s approach <a id="_idIndexMarker487"/>to iteration and loops is influenced by the fact that its variables are immutable, meaning that <a id="_idIndexMarker488"/>once they are set, they cannot be changed. This makes many normal approaches used with <strong class="source-inline">loop</strong> or <strong class="source-inline">do</strong> keywords to transform data impossible. In early versions of the language, this was worked around by passing an array to defined types, as discussed in <a href="B18492_03.xhtml#_idTextAnchor048"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, or using inline ERB templates with Ruby code to manipulate arrays <span class="No-Break">and hashes.</span></p>
			<p>However, the issue with the defined type approach was that the code doing the work was abstracted away and not visible. Furthermore, every time a different type of iteration was required, it would require its own defined type, bloating the code. Therefore, it is important to review heritage code and refactor these patterns to the approaches that will <span class="No-Break">be discussed.</span></p>
			<p>In modern Puppet, the approach taken is to use iterative functions that pass data from arrays and hashes to lambdas. A lambda is a function with no name, so it cannot be called anywhere <a id="_idIndexMarker489"/>else except by a function. A lambda can be attached to any function call, including custom functions. <em class="italic">Table 7.2 </em>provides a full list of functions involved with iteration and lambdas. While some functions may not be considered iterators, they have <a id="_idIndexMarker490"/>similar behaviors. It should also be noted that other functions could <a id="_idIndexMarker491"/>be combined/chained into these examples, such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">unique</strong></span><span class="No-Break">:</span></p>
			<table id="table002" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Function name</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Purpose</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Return type</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Parameters</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">all</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Runs through all elements until <strong class="source-inline">false</strong> is returned from the lambda or completes and <span class="No-Break">returns </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">true</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">false</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>1 <span class="No-Break">or 2</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">any</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Runs through all elements until <strong class="source-inline">true </strong>is returned from the lambda or completes and <span class="No-Break">returns </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="source-inline">true</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">false</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>1 <span class="No-Break">or 2</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">break</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Used within a lambda and stops <span class="No-Break">the iteration.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">n/a</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">n/a</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">each</strong>, <span class="No-Break"><strong class="source-inline">reverse_each</strong></span><span class="No-Break">, </span><span class="No-Break"><strong class="source-inline">tree_each</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Passes each element of a hash or array in turn for the lambda to process (reverse order or <span class="No-Break">recursive variations).</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">n/a</span></p>
						</td>
						<td class="No-Table-Style">
							<p>1 <span class="No-Break">or 2</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">filter</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Runs through all elements and matches with lambda code, returning matching elements in <span class="No-Break">an array.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Array</span></p>
						</td>
						<td class="No-Table-Style">
							<p>1 <span class="No-Break">or 2</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">index</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Runs through all elements and on the first match within lambda code, returns the index of the <span class="No-Break">matching element.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Integer</span></p>
						</td>
						<td class="No-Table-Style">
							<p>1 <span class="No-Break">or 2</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">lest</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>The function takes one argument; if this value is undefined it will run a lambda and return the outcome. If the argument is not undefined it will return <span class="No-Break">the argument.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Any <span class="No-Break">valid type</span></p>
						</td>
						<td class="No-Table-Style">
							<p>0</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">map</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Runs through all elements and applies lambda code to that element. Returns an array of elements <span class="No-Break">post lambda.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">array</span></p>
						</td>
						<td class="No-Table-Style">
							<p>1 <span class="No-Break">or 2</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">next</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Used within a lambda to change the value of the next element in <span class="No-Break">the iteration.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">n/a</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">n/a</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">reduce</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Runs through all elements and applies lambda code passing the outcome forward to <span class="No-Break">each iteration.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">array</span></p>
						</td>
						<td class="No-Table-Style">
							<p>2</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">return</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Used to cause a lambda to return (cannot be used at <span class="No-Break">top scope).</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">n/a</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">n/a</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">slice</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Runs through a sliced size of elements such as three elements <span class="No-Break">per iteration.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Array</span></p>
						</td>
						<td class="No-Table-Style">
							<p>1 or size <span class="No-Break">of slice</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">step</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Chained into another iterable function passing a sequence of elements incrementing at a step size from a starting element to a <span class="No-Break">finishing element.</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Iterable</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">n/a</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">then</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Takes one argument and if it is not undefined, it will call a lambda with the argument. Otherwise, it will <span class="No-Break">return </span><span class="No-Break"><strong class="source-inline">undefined</strong></span><span class="No-Break">.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Any <span class="No-Break">valid type</span></p>
						</td>
						<td class="No-Table-Style">
							<p>1</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">with</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Takes one argument and unconditionally passes it to a lambda and runs with the argument. Returns the result of <span class="No-Break">the lambda.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Any <span class="No-Break">valid type</span></p>
						</td>
						<td class="No-Table-Style">
							<p>1</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 7.2 – Functions for iteration and lambdas</p>
			<p>The basic syntax structure for iterative functions using lambdas in Puppet is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
&lt;function acting on data&gt; | &lt;parameter(s)&gt; | { lambda of Puppet code }</pre>
			<p>As an example, consider using the <strong class="source-inline">each</strong> function to loop around an array, with a single parameter (optionally typed), and printing <span class="No-Break">the output:</span></p>
			<pre class="source-code">
['first', 'second', 'third'].each | String $x | { notice $x }</pre>
			<p>This would result in the <strong class="source-inline">notice</strong> function printing for each string in the array, similar to a <strong class="source-inline">for </strong>loop with a <strong class="source-inline">print</strong>/<strong class="source-inline">echo</strong> command in <span class="No-Break">most languages.</span></p>
			<p>The <strong class="source-inline">each</strong> function <a id="_idIndexMarker492"/>can also use two parameters, which would give the index as the first parameter <a id="_idIndexMarker493"/>and the content of that index as the second parameter. The following code would print <strong class="source-inline">index 2 contains second</strong> for the second iteration of <span class="No-Break">the lambda:</span></p>
			<pre class="source-code">
['first', 'second', 'third'].each | $index $value | { notice "index $index contains $value" }</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">To test these examples on your developer desktop, simply run <strong class="source-inline">puppet apply -e '&lt;</strong><span class="No-Break"><strong class="source-inline">example code&gt;'</strong></span><span class="No-Break">.</span></p>
			<p>To clarify, when using the <strong class="source-inline">each</strong> function with a single parameter on a hash, each key-value pair will be passed as an array to the lambda. For example, running the code <strong class="source-inline">[{ key1 =&gt; 'val1', key2 =&gt; 'val2' }].each | $key_pair | { notice $key_pair }</strong> will output two arrays, one for each key-value pair: <strong class="source-inline">['key1', 'val1'] </strong>and <strong class="source-inline">['</strong><span class="No-Break"><strong class="source-inline">key2', 'val2']</strong></span><span class="No-Break">.</span></p>
			<p>If two parameters are used in the lambda, the first parameter will represent the key and the second parameter will represent the value. For example, running the code <strong class="source-inline">[{ key1 =&gt; 'val1', key2 =&gt; 'val2' }].each | $key, $value | { notice "$key contains $value" }</strong> will output two strings, one for each key-value pair: <strong class="source-inline">key1 contains val1</strong> and <strong class="source-inline">key2 </strong><span class="No-Break"><strong class="source-inline">contains val2</strong></span></p>
			<p>It is also worth noting that other data types, such as strings, can be automatically converted into arrays where each character in the string will be treated as an element. Additionally, a range of numbers can be declared using an <strong class="source-inline">Integer</strong> type; for example, running the code <strong class="source-inline">Integer[100, 150].each | Integer $number | { notice $number }</strong> will output all integers from <strong class="source-inline">100</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">150</strong></span><span class="No-Break">.</span></p>
			<p>Finally, iteration can be <a id="_idIndexMarker494"/>nested; for example, to handle a hash with array values, an iterative function <a id="_idIndexMarker495"/>can be used within the lambda. Running the following code will output each value in the array of the <strong class="source-inline">key1 </strong>key-value pair – <strong class="source-inline">'value1'</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">'value2'</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
[{ key1 =&gt; ['value1', 'value2'], key2 =&gt; 'val2' }].each | $key, $value_array | {
  $value_array.each | $value | {
    notice $value
  }
}</pre>
			<p>Overall, this section provides an overview of the most commonly used functions in Puppet, but for more in-depth descriptions, users can refer to the official documentation at <a href="https://www.puppet.com/docs/puppet/latest/function.html "><span class="No-Break">https://www.puppet.com/docs/puppet/latest/function.html </span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor202"/>Iterative loops</h2>
			<p>The main function reviewed so far is <strong class="source-inline">each</strong>, and there are several functions that perform this loop of <a id="_idIndexMarker496"/>elements or manipulate the loop. <strong class="source-inline">reverse_each</strong> simply takes the reverse order of the elements, as its name suggests. <strong class="source-inline">tree_each</strong> allows values in nested arrays/hashes to be returned with different behaviors depending on the flags provided. It is relatively complicated and niche. The <strong class="source-inline">slice</strong> function allows us to take a specific number of elements in each iteration. For example, the following code would pass arrays of three numbers at a time from the sequence to <span class="No-Break">the lambda:</span></p>
			<pre class="source-code">
Integer[100, 151].slice(3) | Array $numbers | { notice $numbers }</pre>
			<p>On the last iteration, it would provide the remaining elements; in this example, an array with just <strong class="source-inline">[151]</strong>. It is also possible to use multiple parameters, but the number of parameters must be the same as the <span class="No-Break"><strong class="source-inline">slice</strong></span><span class="No-Break"> size:</span></p>
			<pre class="source-code">
Integer[100, 151].slice(3) | Integer $first, Integer $second, Integer $third  | { notice $numbers }</pre>
			<p>The <strong class="source-inline">step</strong> function allows us to choose which elements of an iterable we wish to pass. In this code example, it would start at the first element, then the fourth, the seventh, and <span class="No-Break">so on:</span></p>
			<pre class="source-code">
Integer[100, 150].step(3) | Integer $numbers | { notice $numbers }</pre>
			<p>This can be useful when chained into another iterable function. The next type of function is for matching patterns. This is a different style of iteration function where instead of just passing the elements to the lambda to perform some action, the iterative function defines how the lambda will return. For example, <strong class="source-inline">all</strong> is looking for all elements to match the check in the lambda to return <strong class="source-inline">true</strong>. If any of the lambdas return <strong class="source-inline">false</strong>, the function will return <strong class="source-inline">false</strong>. For example, the following code would print <strong class="source-inline">true </strong>because all the elements were greater <span class="No-Break">than </span><span class="No-Break"><strong class="source-inline">99</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
Integer[100, 151].all | Integer $number | { $number &gt; 99 }.notice()</pre>
			<p>The <strong class="source-inline">any</strong> function <a id="_idIndexMarker497"/>is the opposite of <strong class="source-inline">all</strong>, returning <strong class="source-inline">false</strong> if there are no matches and <strong class="source-inline">true</strong> if the lambda returns <strong class="source-inline">true</strong> in any iteration. The <strong class="source-inline">index</strong> function is similar to <strong class="source-inline">any</strong>, but instead of returning <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong>, it returns the index number of the element that matches, or <strong class="source-inline">undef</strong> if there is no match. For example, the following code would print <strong class="source-inline">20</strong>, as <strong class="source-inline">number</strong> would match the <span class="No-Break">20th element:</span></p>
			<pre class="source-code">
Integer[100, 151].index | Integer $number | { $number == 120 }.notice()</pre>
			<p>All of the functions can work with two parameters on arrays or hashes, as shown in the examples for the <span class="No-Break"><strong class="source-inline">each</strong></span><span class="No-Break"> </span><span class="No-Break">function.</span></p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor203"/>Data transformation</h2>
			<p>Data transformation is another way iterators are used to iterate through elements and perform adjustments <a id="_idIndexMarker498"/>before returning them. This is one of the main reasons why the iterator to lambda pattern was developed, as Puppet is unable to reassign variables. For example, the <strong class="source-inline">map</strong> function iterates over each element and applies a lambda whose result is stored in an array. For example, the following code would divide each element by <strong class="source-inline">1024 </strong>and return an array of <strong class="source-inline">[2, </strong><span class="No-Break"><strong class="source-inline">3, 1]</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
[2048, 3096, 1024].map | $size | {  $size / 1024 } .notice()</pre>
			<p>The <strong class="source-inline">filter</strong> function takes each element in the iteration and applies the code in the lambda. If the lambda returns <strong class="source-inline">true</strong>, the element will be added to an array for return. Otherwise, if <strong class="source-inline">false</strong>, it will continue to the next iteration. For example, the following filter would iterate through each array, checking whether the size is greater than <strong class="source-inline">0</strong>, which would result in an output of <strong class="source-inline">[[1, 2, 3], ['a', 'b', 'c']]</strong>, with the second element’s empty array <span class="No-Break">being removed:</span></p>
			<pre class="source-code">
[[1,2,3], [], [a,b,c]].filter | $array | { $array.size &gt; 0   } .notice()</pre>
			<p>Both <strong class="source-inline">filter</strong> and <strong class="source-inline">map</strong> can handle one or two parameters, as shown with the <strong class="source-inline">each</strong> function on arrays <span class="No-Break">and hashes.</span></p>
			<p>The <strong class="source-inline">reduce</strong> function allows for cumulative work to take place in the lambdas. It is different from the <a id="_idIndexMarker499"/>other functions and requires two parameters: the first parameter keeps its value through the iterations, while the second is the element. Additionally, the starting value can be chosen for the first parameter by passing a value to the <strong class="source-inline">reduce</strong> function. In this example, the <strong class="source-inline">total</strong> parameter would start at <strong class="source-inline">1</strong> and, in each round, add the element to its total, resulting in <strong class="source-inline">15</strong> being returned <span class="No-Break">and printed:</span></p>
			<pre class="source-code">
[2, 4, 8].reduce(1) | $total, $number | {  $total + $number } .notice()</pre>
			<p>Within a lambda, it is also possible to change the flow of iteration. The <strong class="source-inline">next</strong> function can change what the next element will be: <strong class="source-inline">undef</strong> if nothing is provided to the <strong class="source-inline">next</strong> function, or the value provided to the <strong class="source-inline">next</strong> function. The <strong class="source-inline">break</strong> function stops the iterator at that point in the code and returns to the iterative function, effectively ending the iterator at that point. The <strong class="source-inline">return</strong> function, in comparison, returns from the iterative function, so it will not complete at all and returns to the containing class, function, or <span class="No-Break">defined type.</span></p>
			<p>To demonstrate this change in flow, the first example using <strong class="source-inline">map</strong> over a series of numbers will run a <strong class="source-inline">next</strong> function, and when the element matches <strong class="source-inline">101</strong>, it will replace the next element, <strong class="source-inline">102</strong>, with <strong class="source-inline">1984</strong>, and then a <strong class="source-inline">break</strong> function will be run when the element is greater than <strong class="source-inline">104</strong>. So, with the notice at the end printing, this will return an array of <strong class="source-inline">[100, </strong><span class="No-Break"><strong class="source-inline">1984, 102]</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
Integer[100, 151].map | Integer $number | { if $number == 101 { next(1984) } if $number &gt; 103 { break() } $number }.notice()</pre>
			<p>To highlight the different behavior of replacing the <strong class="source-inline">break</strong> function with a <strong class="source-inline">return</strong> function, the following example will result in nothing <span class="No-Break">being printed:</span></p>
			<pre class="source-code">
class example {
  Integer[100, 151].map | Integer $number | { if $number == 101 { next(1984) } if $number &gt; 103 { return() } $number }.notice()
} </pre>
			<p>This is the reason, in this <a id="_idIndexMarker500"/>example, that we have put the function within a class because <strong class="source-inline">return </strong>cannot be called at a top scope level only within a class, function, or <span class="No-Break">defined type.</span></p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor204"/>Nested data</h2>
			<p>The last types of functions are useful when handling nested data or generally handling undefined values. <strong class="source-inline">then</strong> is chained after a lambda and if it receives <strong class="source-inline">undef</strong> outputted from that lambda, it <a id="_idIndexMarker501"/>will return <strong class="source-inline">undef</strong>; otherwise, it will pass the value to another lambda. So the following example would use the <strong class="source-inline">dig</strong> function to attempt to access a <strong class="source-inline">c</strong> element that doesn’t exist in the second hash in the array, and as <strong class="source-inline">then</strong> would receive <strong class="source-inline">undef</strong>, it would therefore <span class="No-Break">return </span><span class="No-Break"><strong class="source-inline">undef</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
$example = {first =&gt; { second =&gt; [{a =&gt; 10, b =&gt; 20}, {d =&gt; 30, e =&gt; 40}]}}
$example.dig(first, second, 1, c ).then |$x| { $x / 10 }.notice()</pre>
			<p>To clarify the previous statement, if <strong class="source-inline">dig(first, second, 1, d)</strong> is changed to <strong class="source-inline">dig(first, second, 2, d)</strong>, it would then pass <strong class="source-inline">30</strong> to the lambda, which would divide by <strong class="source-inline">10</strong> and <span class="No-Break">print </span><span class="No-Break"><strong class="source-inline">3</strong></span><span class="No-Break">.</span></p>
			<p><strong class="source-inline">lest</strong> is the opposite of <strong class="source-inline">then</strong> and returns the value it is defined; otherwise, it passes <strong class="source-inline">undef</strong> to the lambda, which can take an action such as setting a default value instead. This can be useful; when used alongside <strong class="source-inline">then</strong>, taking the preceding example, adding <strong class="source-inline">lest</strong> would allow a value of <strong class="source-inline">undef </strong>to be returned if it <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
$example.dig(first, second, 1, c ).then |$x| { $x / 10 }.lest() || { 0 } .notice()</pre>
			<p>The <strong class="source-inline">with</strong> function is somewhat of a specialist edge, as it is used to pass values through if our lambda is able to handle <strong class="source-inline">undef</strong> or <span class="No-Break">defined values.</span></p>
			<p>So, having reviewed the various functions and seeing the data transformation and explorations of <a id="_idIndexMarker502"/>data possible, it is worth highlighting again how, instead of using a defined type, as was done in the past, when we need to create multiple resources. So, for example, to create a directory for as many instances as requested, the following code could <span class="No-Break">be used:</span></p>
			<pre class="source-code">
Integer[1,$instance_number].each |Integer $id | {
  file {"/opt/app/exampleapp/instance${id}":
    ensure =&gt; directory,
  }
}</pre>
			<p>Having covered how Puppet can perform loops and iteration, the conditional statements will be <span class="No-Break">reviewed next.</span></p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor205"/>Conditional statements</h1>
			<p>Puppet has the <a id="_idIndexMarker503"/>conditional statements you would expect of any language, with <strong class="source-inline">if</strong>, <strong class="source-inline">unless</strong>, and <strong class="source-inline">case</strong> allowing code behavior to be different depending on things such as facts or data from external sources. Puppet additionally uses selectors, which are similar to a <strong class="source-inline">case</strong> statement but return a value instead of executing code <span class="No-Break">on result.</span></p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor206"/>If and unless statements</h2>
			<p>The <strong class="source-inline">if</strong> statement follows <a id="_idIndexMarker504"/>a specific syntax that includes the <strong class="source-inline">if</strong> keyword <a id="_idIndexMarker505"/>followed by a condition, an opening curly brace (<strong class="source-inline">{</strong>), the Puppet code to execute if the condition evaluates to <strong class="source-inline">true</strong>, and a closing curly <span class="No-Break">brace (</span><span class="No-Break"><strong class="source-inline">}</strong></span><span class="No-Break">).</span></p>
			<p>The following example is a simple check on a Boolean in <strong class="source-inline">example_bool</strong> to print a notice if it <span class="No-Break">contains </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
if $example_bool {
  notice 'It was true'
}</pre>
			<p>This can be optionally extended by adding an <strong class="source-inline">else</strong> keyword after the closing curly brace (<strong class="source-inline">}</strong>) of the <strong class="source-inline">if</strong> statement and then using an opening curly brace (<strong class="source-inline">{</strong>) with Puppet code to perform if the condition is <strong class="source-inline">false</strong>. This is then closed with a closing curly brace (<strong class="source-inline">}</strong>). To also print when <strong class="source-inline">example_bool</strong> is <strong class="source-inline">false</strong>, the code would be updated <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
if $example_bool {
  notice 'It was true'
}else{
  notice 'It was false'
}</pre>
			<p>Similarly, to perform <a id="_idIndexMarker506"/>multiple <strong class="source-inline">if</strong> checks together, the <strong class="source-inline">elsif</strong> keyword can <a id="_idIndexMarker507"/>be used after the <strong class="source-inline">if </strong>statement’s closing curly brace (<strong class="source-inline">}</strong>), allowing the same <strong class="source-inline">if</strong> syntax to be followed again. This can be nested and repeated as required. To provide an example, following up on the Boolean check with <strong class="source-inline">elsif</strong>, we can add a second check to see whether the value variable is greater than <strong class="source-inline">2</strong>, print a notice if it is, and an <strong class="source-inline">else</strong> statement that prints that both conditions <span class="No-Break">were </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
if $example_bool {
  notice 'It was true'
}elsif $value &gt; 2{
  notice 'It was false and value is greater than 2'
}else {
  notice 'It was false and the value was 2 or less'
}</pre>
			<p>The <strong class="source-inline">unless</strong> statement is <a id="_idIndexMarker508"/>simply the inverse of the <strong class="source-inline">if</strong> statement. It allows <a id="_idIndexMarker509"/>you to avoid having to negate a condition, and it can also be used in combination with an <strong class="source-inline">if</strong> statement. However, it has no equivalent to <strong class="source-inline">elsif</strong> and will cause a compilation failure if used. To demonstrate this with the previous <strong class="source-inline">if</strong> example, the <strong class="source-inline">unless</strong> statement can be used instead to check whether <strong class="source-inline">example_bool </strong>is <strong class="source-inline">false</strong> and print a notice in <span class="No-Break">that case:</span></p>
			<pre class="source-code">
unless $example_bool {
  notice 'It was false'
}else{
  notice 'It was true'
}</pre>
			<p>Any non-Boolean <a id="_idIndexMarker510"/>values used in the conditions will be converted to <a id="_idIndexMarker511"/>Booleans as per the data type rules, as covered in <a href="B18492_04.xhtml#_idTextAnchor078"><span class="No-Break"><em class="italic">Chapter 4</em></span></a><span class="No-Break">.</span></p>
			<p>The Puppet style guide recommends for the lines which follow the keywords <strong class="source-inline">if</strong> and <strong class="source-inline">unless</strong> that the code should be indented by two spaces and aligned as was shown in <span class="No-Break">the examples.</span></p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor207"/>Case statement</h2>
			<p>The <strong class="source-inline">case</strong> statement works by matching the value outputted from a control expression. This is commonly the <a id="_idIndexMarker512"/>content of a fact or variable, but it could <a id="_idIndexMarker513"/>also be an expression or function. The format starts with the <strong class="source-inline">case</strong> keyword, followed by a control expression, resolving to a value and enclosed within curly braces. Each following line starts with either a matching case or a comma-separated list of cases, followed by a colon, and the Puppet code enclosed within curly braces to be applied for the matching case. The <strong class="source-inline">case</strong> statement is then closed with a <span class="No-Break">curly brace.</span></p>
			<p>For example, to test the value of the <strong class="source-inline">hardwareisa</strong> fact and include a profile based on the type of processor architecture in use, the following code can be used. It includes a Unix profile for <strong class="source-inline">sparc </strong>or <strong class="source-inline">powerpc</strong> values, the Linux 32-bit profile for <strong class="source-inline">i686</strong> and <strong class="source-inline">i386</strong> values, the 64-bit profile for any value ending in <strong class="source-inline">64</strong>, and the default profile for any value failing to match <span class="No-Break">a case:</span></p>
			<pre class="source-code">
case $facts[' hardwareisa'] {
  'sparc', 'powerpc': { include profile::unix}
  'i686', 'i386': { include profile::linux::32bit}
  /(*64)/: { include profile::linux::64bit}
  default: { include profile::default }
}</pre>
			<p>The Puppet style guide <a id="_idIndexMarker514"/>recommends always <a id="_idIndexMarker515"/>using a <strong class="source-inline">default</strong> case, which can be a failure or even just an empty <span class="No-Break">curly brace.</span></p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor208"/>Selectors</h2>
			<p>Selectors are similar to <strong class="source-inline">case</strong> statements, but instead of applying Puppet code for the matching case, they <a id="_idIndexMarker516"/>return a value. Selectors can be used wherever a value is expected, such <a id="_idIndexMarker517"/>as variable assignment, resource attributes, and function arguments. The Puppet style guide recommends only using selectors in variable assignments to improve readability, but it may be seen in legacy code in resource attributes as it was previously a <span class="No-Break">popular pattern.</span></p>
			<p>The syntax of a selector is a control expression resolving to a value, a question mark (<strong class="source-inline">?</strong>), and an opening curly brace (<strong class="source-inline">{</strong>). It then has a number of case matches, starting with a single case or the <strong class="source-inline">default </strong>keyword, a hash rocket (<strong class="source-inline">=&gt;</strong>), the value to return, and a closing comma. The selector is then closed with a closing curly <span class="No-Break">brace (</span><span class="No-Break"><strong class="source-inline">}</strong></span><span class="No-Break">).</span></p>
			<p>The following example shows the <strong class="source-inline">apache_package_name </strong>variable assigned based on the output of the <strong class="source-inline">os.family</strong> fact, using the <strong class="source-inline">httpd</strong> name for Red Hat, <strong class="source-inline">apache2</strong> for Debian or Ubuntu, <strong class="source-inline">apache-httpd</strong> for Windows, and defaulting to <strong class="source-inline">httpd</strong> if there is no match. A package resource could then use this name to install the <span class="No-Break">relevant package:</span></p>
			<pre class="source-code">
$apache_package_name = $facts['os']['family'] ? {
  'RedHat' =&gt; 'httpd',
  /(Debian|Ubuntu)/ =&gt; ' apache2 ',
  'Windows' =&gt; 'apache-httpd',
  default =&gt; 'httpd',
}
package { $apache_package_name }</pre>
			<p>As with the <strong class="source-inline">case</strong> statement, the <a id="_idIndexMarker518"/>Puppet style guide recommends that selectors always <a id="_idIndexMarker519"/>use a <strong class="source-inline">default </strong>case, which can be a failure or even just an empty <span class="No-Break">curly brace.</span></p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor209"/>Capture variables</h2>
			<p>If the <strong class="source-inline">case</strong> statement <a id="_idIndexMarker520"/>used was a regular expression, then <a id="_idIndexMarker521"/>what is known as capture variables will be available within the associated code as number variables such as <strong class="source-inline">$1</strong> and <strong class="source-inline">$2</strong>, with the entire match available <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">$0</strong></span><span class="No-Break">.</span></p>
			<p>To modify the example in the <em class="italic">Case statement </em>section, if the match was against <strong class="source-inline">amd64</strong>, this would <span class="No-Break">include </span><span class="No-Break"><strong class="source-inline">profile::linux::amd64</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
/(*64)/: { include profile::linux::${1} }</pre>
			<p>Having reviewed all aspects of templates, conditionals, iterations, and loops, we will now use a lab to recap and bring these <span class="No-Break">concepts together.</span></p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor210"/>Lab – creating and testing templates containing loops and conditions</h1>
			<p>In this lab, we will <a id="_idIndexMarker522"/>bring together everything you have <a id="_idIndexMarker523"/>seen in this chapter so far, testing and validating some example templates and creating a template using logic <span class="No-Break">and iteration:</span></p>
			<ol>
				<li>Download the template files at <a href="https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch07/templates_to_check"/><a href="https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch07/templates_to_check">https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch07/templates_to_check</a> and validate and parse each of them to ensure the templates produce the following (<strong class="source-inline">&lt;&gt;</strong> shows where interpolation needs <span class="No-Break">to happen):</span><ul><li><strong class="bold">“This template was run on a machine with &lt;# number of cpus of your </strong><span class="No-Break"><strong class="bold">machine&gt; cpus”</strong></span></li><li><strong class="bold">“The custom fact pack.lab was &lt; set to content of fact or the string ‘not set’ &gt; “</strong></li></ul></li>
			</ol>
			<p class="callout-heading">Hint</p>
			<p class="callout">You would want to use the <strong class="source-inline">getvar</strong> function to test the fact and test it by passing in a hash, setting it <a id="_idIndexMarker524"/>when parsing to <span class="No-Break">test it.</span></p>
			<ul>
				<li><strong class="bold">“The system uptime is &lt; showing only days hours mins if they are non zero &gt; “</strong></li>
				<li><strong class="bold">“This machine is &lt;not/is&gt; virtual &lt;and runs </strong><span class="No-Break"><strong class="bold">on &lt;$virtual&gt;”</strong></span></li>
			</ul>
			<ol>
				<li value="2">Create a <a id="_idIndexMarker525"/>template that prints <span class="No-Break">the </span><span class="No-Break"><a id="_idIndexMarker526"/></span><span class="No-Break">following</span></li>
			</ol>
			<p><strong class="bold">“This is a &lt; os family &gt; machine running version &lt; os release full &gt; ““The following directories are in the path</strong> <strong class="bold">&lt; list each </strong><span class="No-Break"><strong class="bold">path &gt;”</strong></span></p>
			<p class="callout-heading">Hint</p>
			<p class="callout">Use the <strong class="source-inline">split </strong>function (<a href="https://www.puppet.com/docs/puppet/latest/function.html#split">https://www.puppet.com/docs/puppet/latest/function.html#split</a>) to separate the path fact string into <a id="_idIndexMarker527"/>an array that can be iterated, and remember that Windows paths are split by ; while Unix/Linux based paths are split by :  . See the answer <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch07/2_sample.epp"><span class="No-Break">https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch07/2_sample.epp</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor211"/>Summary</h1>
			<p>In this chapter, the use of templates in Puppet was examined. It showed Puppet’s two types of templates – EPP and ERB – which worked in similar ways, using a mix of plain text and tags surrounding code to allow for Puppet/Ruby to apply logic and variables and create more complex content when evaluated. It was warned that the level of complexity should be carefully considered before using templates instead of functions such as <strong class="source-inline">file_line</strong>, and controlling resources individually. Additionally, because of the lack of functions for a single line or setting control in files, templates had been overused, and heritage code should be examined carefully to ensure that a template was the correct level <span class="No-Break">of complexity.</span></p>
			<p>EPP was shown to be the recommended way of producing templates since it was in the Puppet language and easier to learn for a Puppet developer. It was also more secure since it could limit its scope with parameters, and similarly, more performant since it only created a scope for the variables and facts required, unlike ERB, which, for every template used, would generate a scope for all facts. Furthermore, it was mentioned that all Puppet future development work would be for EPP, as was shown by the inclusion of automatic unwrapping of sensitive variables in EPP files, and the capability of rendering a template was only available <span class="No-Break">in EPP.</span></p>
			<p>EPP and ERB templates were shown to be referenced and evaluated from files via the <strong class="source-inline">epp</strong> and <strong class="source-inline">template</strong> functions, where multiple files could be combined together. It was also shown that inline templates were possible via the <strong class="source-inline">inline-template</strong> or <strong class="source-inline">inline-epp</strong> functions, where the text could be passed directly to the function instead of being stored in <span class="No-Break">a file.</span></p>
			<p>Iteration and loops were then shown, highlighting Puppet’s previous lack of capability to do this with the immutable nature of Puppet variables making more traditional <strong class="source-inline">loop</strong> keywords impractical. Puppet was shown to instead use iterative functions on arrays and hashes, which passed values as parameters to lambda functions. These unnamed lambda functions, which could only be called by other functions, allow the creation of a scope entirely local to the lambda function and, therefore, allow variable names to be reused. The iterative function chooses how values should be passed to the lambda, such as each passing one value or key pair at a time, or <strong class="source-inline">Reduce</strong>, which allows the use of a parameter that is passed through each lambda function along with each value and key pair and can be useful to do <span class="No-Break">cumulative transformations.</span></p>
			<p>Puppet’s conditional logic was then discussed, showing it to be similar to most other languages. <strong class="source-inline">if</strong> checks evaluate a check to a Boolean statement/comparison, which if <strong class="source-inline">true</strong>, is acted on with Puppet code. The <strong class="source-inline">else</strong> keyword allows an action to take place if the Boolean was <strong class="source-inline">false</strong>, and the <strong class="source-inline">elsif</strong> keyword allows the chaining of checks together. <strong class="source-inline">unless</strong> was shown to be the inverse of <strong class="source-inline">if</strong>, acting on the check if it was negative and allowing <strong class="source-inline">else</strong> to act if it was <strong class="source-inline">true</strong>, although it had no equivalent <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">elsif</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">case</strong> keyword was then discussed. We showed that it works by taking the value and matching it to run Puppet code based on the match or to a default if no value was found. The <strong class="source-inline">selector</strong> keyword was shown to be similar to the behavior of the <strong class="source-inline">case</strong> statement but is used instead of running Puppet code to assign a value. It was highlighted that, despite it being a common pattern in the past to use a selector within resources, this was no longer considered best practice. Finally, capture variables were shown as variables available to conditionals that had used regular expressions to show what the match <span class="No-Break">had been.</span></p>
			<p>Having now reviewed the core Puppet language, it is time to learn how to structure the manifest file and classes we have used so far. The next chapter will demonstrate how modules provide the necessary structure to hold the manifests, classes, and other configuration and implementation files that we have examined. The roles and profiles pattern will also be explored, providing an additional abstraction to represent the technology stacks and business needs of customers. Moreover, Puppet Forge will be demonstrated as a source of modules that can be consumed to reduce the need for development and to collaborate with the Puppet community to enhance the <span class="No-Break">available code.</span></p>
		</div>
	</body></html>