- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Implementing Traffic Management, Security, and Observability with Istio
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Istio实施流量管理、安全性和可观察性
- en: In the previous chapter, we covered **site reliability engineering** (**SRE**)
    and how it has helped manage production environments using DevOps practices. In
    this chapter, we’ll dive deep into a service mesh technology called Istio, which
    will help us implement SRE practices and manage our application better in production.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了**站点可靠性工程**（**SRE**）及其如何通过DevOps实践帮助管理生产环境。在本章中，我们将深入探讨一种名为Istio的服务网格技术，它将帮助我们实施SRE实践，并在生产中更好地管理我们的应用。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论以下主要主题：
- en: Revisiting the Blog App
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重新审视博客应用
- en: Introduction to service mesh
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务网格简介
- en: Introduction to Istio
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Istio简介
- en: Understanding the Istio architecture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解Istio架构
- en: Installing Istio
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装Istio
- en: Using Istio Ingress to allow traffic
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Istio Ingress来允许流量
- en: Securing your microservices using Istio
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Istio保护你的微服务
- en: Managing traffic with Istio
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Istio管理流量
- en: Observing traffic and alerting with Istio
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Istio观察流量并设置告警
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, we will spin up a cloud-based Kubernetes cluster, **Google
    Kubernetes Engine** (**GKE**), for the exercises. At the time of writing, **Google
    Cloud Platform** (**GCP**) provides a free $300 trial for 90 days, so you can
    go ahead and sign up for one at [https://console.cloud.google.com/](https://console.cloud.google.com/).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将启动一个基于云的Kubernetes集群——**Google Kubernetes Engine**（**GKE**），用于练习。在撰写本文时，**Google
    Cloud Platform**（**GCP**）提供了一个为期90天、价值300美元的免费试用，你可以在[https://console.cloud.google.com/](https://console.cloud.google.com/)注册一个。
- en: 'You will also need to clone the following GitHub repository for some of the
    exercises: [https://github.com/PacktPublishing/Modern-DevOps-Practices-2e](https://github.com/PacktPublishing/Modern-DevOps-Practices-2e).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要克隆以下GitHub仓库以完成一些练习：[https://github.com/PacktPublishing/Modern-DevOps-Practices-2e](https://github.com/PacktPublishing/Modern-DevOps-Practices-2e)。
- en: 'You can use the Cloud Shell offering available from GCP to follow this chapter.
    Go to Cloud Shell and start a new session. Run the following command to clone
    the repository into your home directory to access the required resources:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用GCP提供的Cloud Shell来完成本章内容。进入Cloud Shell并启动一个新的会话。运行以下命令将仓库克隆到你的主目录中，以便访问所需资源：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We also need to set the project ID and enable a few GCP APIs we will use in
    this chapter. To do so, run the following commands:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要设置项目ID，并启用一些我们将在本章中使用的GCP API。为此，运行以下命令：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you haven't followed the previous chapters and want to start quickly with
    this, you can follow the next part, *Setting up the baseline*, though I highly
    recommend that you go through the last few chapters to get a flow. If you have
    been following the hands-on exercises in the previous chapters, feel free to skip
    this part.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有按照前几章的内容进行学习，想要快速开始，可以继续阅读下一个部分，*设置基础环境*，不过我强烈建议你先阅读前几章，了解整个流程。如果你已经跟着前几章的实操练习走了，那么可以跳过这一部分。
- en: Setting up the baseline
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置基础环境
- en: 'To ensure continuity with the previous chapters, let’s start by creating a
    service account for Terraform so that we can interact with our GCP project:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保与前几章的连续性，我们首先创建一个服务账户，用于Terraform与我们的GCP项目进行交互：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You will see that a file called `key-file` has been created within your working
    directory. Now, create a new repository called `mdo-environments` with a `README.md`
    file on GitHub, rename the `main` branch to `prod`, and create a new branch called
    `dev` using GitHub. Navigate to `https://github.com/<your_github_user>/mdo-environments/settings/secrets/actions/new`
    and create a secret named `GCP_CREDENTIALS`. For the value, print the `key-file`
    file, copy its contents, and paste it into the **values** field of the GitHub
    secret.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到一个名为`key-file`的文件已经在你的工作目录中创建。现在，在GitHub上创建一个名为`mdo-environments`的新仓库，并添加一个`README.md`文件，重新命名`main`分支为`prod`，并使用GitHub创建一个名为`dev`的新分支。导航至`https://github.com/<your_github_user>/mdo-environments/settings/secrets/actions/new`，创建一个名为`GCP_CREDENTIALS`的密钥。在**values**字段中，打印`key-file`文件，复制其内容并粘贴到GitHub密钥的**values**字段中。
- en: Next, create another secret, `PROJECT_ID`, and specify your GCP project ID within
    the **values** field.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建另一个密钥`PROJECT_ID`，并在**values**字段中指定你的GCP项目ID。
- en: 'Next, we need to create a **GCS bucket** for Terraform to use as a remote backend.
    To do this, run the following commands:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为Terraform创建一个**GCS bucket**作为远程后端。为此，运行以下命令：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The next thing we need to do is set up our Secrets Manager. Let’s create a
    secret called `external-secrets`, where we will pass the MongoDB credentials in
    the JSON format. To do so, run the following command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置我们的 Secrets Manager。让我们创建一个名为 `external-secrets` 的密钥，在其中传递 MongoDB
    的凭证，格式为 JSON。为此，请运行以下命令：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We need to create the `Secret` resource, which will interact with GCP to fetch
    the stored secret. First, we need to create a GCP service account to interact
    with Secrets Manager using the following commands:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建 `Secret` 资源，它将与 GCP 交互以获取存储的密钥。首先，我们需要使用以下命令创建一个 GCP 服务账户与 Secrets Manager
    进行交互：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As we’re following the principle of least privilege, we will add the following
    role binding to provide access only to the `external-secrets` secret, as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们遵循最小权限原则，我们将添加以下角色绑定，仅提供对 `external-secrets` 密钥的访问，具体如下：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, let’s generate the service account key file using the following command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令生成服务账户密钥文件：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next, copy the contents of the `key.json` file into a new GitHub Actions secret
    called `GCP_SM_CREDENTIALS`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将 `key.json` 文件的内容复制到一个新的 GitHub Actions 密钥 `GCP_SM_CREDENTIALS` 中。
- en: 'We also need to create the following GitHub Actions secrets for binary authorization
    to work:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要创建以下 GitHub Actions 密钥，以使二进制授权生效：
- en: '[PRE8]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As the workflow automatically raises pull requests at the end, we need to define
    a GitHub token. This token allows the workflow to act on behalf of the current
    user when creating the pull request. Here are the steps:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 由于工作流在结束时会自动提交拉取请求，我们需要定义一个 GitHub token。这个 token 允许工作流在创建拉取请求时代表当前用户执行操作。以下是步骤：
- en: Go to [https://github.com/settings/personal-access-tokens/new](https://github.com/settings/personal-access-tokens/new).
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问 [https://github.com/settings/personal-access-tokens/new](https://github.com/settings/personal-access-tokens/new)。
- en: Create a new token with “Repository” access for the `mdo-environments` repository,
    granting it `read-write` pull request permissions. This approach aligns with the
    principle of least privilege, offering more granular control.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `mdo-environments` 仓库创建一个具有“仓库”访问权限的新 token，授予它 `读写` 拉取请求权限。这种方法符合最小权限原则，提供更精细的控制。
- en: Once the token is created, copy it.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 token 后，复制它。
- en: Now, create a GitHub Actions secret named `GH_TOKEN` and paste the copied token
    as the value.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为 `GH_TOKEN` 的 GitHub Actions 密钥，并将复制的 token 作为值粘贴进去。
- en: 'Now that all the prerequisites have been met, we can clone our repository and
    copy the baseline code. Run the following commands to do this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有先决条件都已满足，我们可以克隆我们的仓库并复制基础代码。运行以下命令进行此操作：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we’re now on the baseline, let’s proceed further and understand the sample
    Blog App that we will deploy and manage in this chapter.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们处于基础阶段，让我们进一步了解本章将要部署和管理的示例博客应用。
- en: Revisiting the Blog App
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重温博客应用
- en: 'Since we discussed the Blog App previously, let’s look at the services and
    their interactions again:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们之前讨论过博客应用，那么让我们再看一遍它的服务及其交互：
- en: '![Figure 15.1 – The Blog App and its services and interactions](img/B19877_15__1.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.1 – 博客应用及其服务和交互](img/B19877_15__1.jpg)'
- en: Figure 15.1 – The Blog App and its services and interactions
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.1 – 博客应用及其服务和交互
- en: So far, we’ve created CI and CD pipelines for building, testing, and pushing
    our Blog App microservices containers using GitHub Actions, deploying them using
    Argo CD in a GKE cluster.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用 GitHub Actions 为构建、测试和推送博客应用微服务容器创建了 CI 和 CD 管道，并通过 Argo CD 在 GKE
    集群中部署它们。
- en: 'As you may recall, we created the following resources for the application to
    run seamlessly:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能记得的，我们为确保应用的顺利运行创建了以下资源：
- en: '**MongoDB**: We deployed an auth-enabled MongoDB database with root credentials.
    The credentials were injected via environment variables sourced from a Kubernetes
    **Secret** resource. To persist our database data, we created a **PersistentVolume**
    mounted to the container, which we provisioned dynamically using a **PersistentVolumeClaim**.
    As the container is stateful, we used a **StatefulSet** to manage it and, therefore,
    a headless **Service** to expose the database.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MongoDB**：我们部署了一个启用了身份验证的 MongoDB 数据库，并使用 root 凭证。凭证通过来自 Kubernetes **Secret**
    资源的环境变量注入。为了持久化数据库数据，我们创建了一个挂载到容器的 **PersistentVolume**，并使用 **PersistentVolumeClaim**
    动态供应它。由于容器是有状态的，我们使用 **StatefulSet** 来管理它，并因此使用无头 **Service** 来公开数据库。'
- en: '**Posts, reviews, ratings, and users**: The *posts*, *reviews*, *ratings*,
    and *users* microservices interacted with MongoDB through the root credentials
    that were injected via environment variables sourced from the same **Secret**
    as MongoDB. We deployed them using their respective **Deployment** resources and
    exposed all of them via individual **ClusterIP Services**.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**帖子、评论、评分和用户**：*帖子*、*评论*、*评分*和*用户*微服务通过根凭证与MongoDB交互，这些凭证通过来自同一**Secret**的环境变量注入。我们使用各自的**Deployment**资源部署它们，并通过单独的**ClusterIP
    Services**暴露它们。'
- en: '**Frontend**: The *frontend* microservice does not need to interact with MongoDB,
    so there was no interaction with the Secret resource. We also deployed this service
    using a **Deployment** resource. As we wanted to expose the service on the internet,
    we created a **LoadBalancer Service** for it.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前端**：*前端*微服务不需要与MongoDB交互，因此没有与Secret资源的交互。我们也使用**Deployment**资源部署了该服务。由于我们希望将该服务暴露到互联网，我们为其创建了一个**LoadBalancer
    Service**。'
- en: 'We can summarize them with the following diagram:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下图示来总结它们：
- en: '![Figure 15.2 – Blog App – Kubernetes resources and interactions](img/B19877_15_2.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.2 – 博客应用 – Kubernetes 资源和交互](img/B19877_15_2.jpg)'
- en: Figure 15.2 – Blog App – Kubernetes resources and interactions
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.2 – 博客应用 – Kubernetes 资源和交互
- en: Now that we understand the application, let’s understand what a service mesh
    is and how it is beneficial in this use case.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了应用的结构，接下来我们了解一下服务网格是什么以及它在这个用例中的优势。
- en: Introduction to service mesh
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务网格介绍
- en: 'Imagine being in a bustling city with a complex network of roads and highways.
    You’re driving your car from one side of the city to the other. In this scenario,
    you deal with the following entities:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下你处在一个繁忙的城市中，城市里有着复杂的道路和高速公路网络。你正在驾驶汽车，从城市的一侧开到另一侧。在这种情况下，你会接触到以下实体：
- en: '**Your car**: Your car represents an individual service or application in a
    computer system. It has a specific purpose, just like a microservice or application
    in a software architecture.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你的汽车**：你的汽车代表计算机系统中的一个独立服务或应用。它有一个特定的目的，就像软件架构中的微服务或应用一样。'
- en: '**Roads and highways**: The roads and highways are like the network connections
    and communication pathways between different services in your application. Services
    need to interact and communicate with each other to perform various functions,
    just as vehicles need roads to get from one place to another.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**道路和高速公路**：道路和高速公路就像是你应用中不同服务之间的网络连接和通信路径。服务需要互相交互和通信来执行各种功能，就像车辆需要道路从一个地方开到另一个地方。'
- en: '**Traffic lights and signs**: Traffic lights, signs, and road rules help manage
    traffic flow, ensuring that vehicles (services) can safely and efficiently navigate
    the city. These are like the rules, protocols, and tools in a service mesh regulating
    communication and data exchange between services.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交通灯和标志**：交通灯、标志和交通规则帮助管理交通流量，确保车辆（服务）能够安全、高效地在城市中行驶。这些就像服务网格中的规则、协议和工具，调节服务之间的通信和数据交换。'
- en: '**Traffic control center**: Think of the traffic control center as the service
    mesh. It’s a centralized system that monitors and manages traffic flow across
    the city. Similarly, a service mesh is a centralized infrastructure that oversees
    and facilitates communication between services, ensuring they can communicate
    reliably and securely.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交通控制中心**：可以把交通控制中心看作是服务网格。它是一个集中式的系统，监控和管理城市的交通流量。类似地，服务网格是一个集中式基础设施，监督并促进服务之间的通信，确保它们能够可靠、安全地通信。'
- en: '**Traffic monitoring and optimization**: The traffic control center ensures
    safe travel and can optimize traffic flow. It can reroute vehicles to avoid congestion
    or accidents. In the context of a service mesh, it can optimize the flow of data
    and requests between services, ensuring efficient and resilient communication.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流量监控与优化**：交通控制中心确保安全通行并能够优化交通流量。它可以重新规划车辆路线，避免拥堵或事故。在服务网格的上下文中，它能够优化数据和请求在服务之间的流动，确保高效和弹性的通信。'
- en: '**Safety and reliability**: In the city, the traffic control center helps prevent
    accidents and ensures everyone reaches their destinations safely. Similarly, a
    service mesh enhances the safety and reliability of your computer system by providing
    features such as load balancing, security, and fault tolerance.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性和可靠性**：在城市中，交通控制中心有助于防止事故，确保每个人都能安全到达目的地。同样，服务网格通过提供负载均衡、安全性和容错等功能，提高计算机系统的安全性和可靠性。'
- en: So, just as the traffic control center makes your journey in a complex city
    more manageable and secure, a service mesh in a computer system simplifies and
    secures the communication between different services, ensuring that data and requests
    can flow smoothly, reliably, and safely.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 就像交通控制中心让你在复杂的城市中更容易、安全地出行一样，计算机系统中的服务网格简化并保护了不同服务之间的通信，确保数据和请求能够顺畅、可靠、安全地流动。
- en: Containers and the orchestration platforms that manage them, such as Kubernetes,
    have streamlined how we handle microservices. The introduction of container technology
    played a pivotal role in popularizing this concept by allowing for the execution
    and scalability of individual application components as self-contained entities,
    each with an isolated runtime environment.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 容器及其管理平台，如 Kubernetes，简化了我们处理微服务的方式。容器技术的引入在推广这一概念方面起到了关键作用，它使得各个应用组件能够作为独立的实体执行和扩展，每个组件都有一个隔离的运行环境。
- en: While adopting a microservices architecture offers advantages such as accelerated
    development, enhanced system robustness, simplified testing, and the ability to
    scale different aspects of an application independently, it isn’t without its
    challenges. Managing microservices can be a complex endeavor. Instead of dealing
    with a single, monolithic application, you now have multiple dynamic components,
    each catering to specific functionalities.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管采用微服务架构提供了加速开发、增强系统稳定性、简化测试和能够独立扩展应用各个部分等优势，但它也有其挑战。管理微服务可能是一项复杂的工作。你不再处理单一的单体应用，而是拥有多个动态组件，每个组件都承担特定的功能。
- en: 'In the context of extensive applications, it’s not uncommon to see hundreds
    of microservices interacting with each other, which can quickly become overwhelming.
    The primary concerns that may be raised by your security and operations teams
    are as follows:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在大规模应用的背景下，看到数百个微服务相互交互并不罕见，这可能会迅速变得令人不知所措。你的安全和运维团队可能会提出以下主要问题：
- en: Ensuring secure communication between microservices. You need to secure numerous
    smaller services rather than securing a single monolithic application.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保微服务之间的安全通信。你需要保护许多小服务，而不是保护一个单体应用。
- en: Isolating a problematic microservice in case of an issue.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在出现问题时，如何隔离一个有问题的微服务。
- en: Testing deployments with a limited percentage of traffic before a full release
    to establish trust.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在全面发布前，以有限比例的流量进行部署测试，以建立信任。
- en: Consolidating application logs that are now distributed across multiple sources.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整合现在分布在多个来源的应用日志。
- en: Monitoring the health of the services becomes more intricate, with many components
    constituting the application.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控服务的健康状况变得更加复杂，因为应用由许多组件组成。
- en: While Kubernetes effectively addresses some management issues, it primarily
    serves as a container orchestration platform and excels in that role. However,
    it doesn’t inherently solve all the complexities of a microservices architecture
    as they require specific solutions. Kubernetes does not inherently provide robust
    service management capabilities.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Kubernetes 有效地解决了一些管理问题，但它主要作为容器编排平台，并且在这一角色中表现出色。然而，它并没有固有地解决微服务架构的所有复杂性，因为这些架构需要特定的解决方案。Kubernetes
    本身并不提供强大的服务管理功能。
- en: By default, communication between Kubernetes containers lacks security measures,
    and enforcing TLS between pods involves managing an extensive number of TLS certificates.
    Identity and access management between pods is also not applied out of the box.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Kubernetes 容器之间的通信缺乏安全措施，强制在 Pod 之间使用 TLS 需要管理大量的 TLS 证书。Pod 之间的身份和访问管理也不是开箱即用的。
- en: While tools such as Kubernetes Network Policy can be employed to implement a
    firewall between pods, they function at a Layer 3 level rather than Layer 7, which
    is what modern firewalls operate at. This means you can identify the source of
    traffic but cannot inspect the data packets to make metadata-driven decisions,
    such as routing based on an HTTP header.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然像 Kubernetes 网络策略这样的工具可以用于在 Pod 之间实施防火墙，但它们在第 3 层而非第 7 层运作，而现代防火墙正是基于第 7 层操作。这意味着你可以识别流量的来源，但无法检查数据包，从而做出基于元数据的决策，例如基于
    HTTP 头进行路由。
- en: 'Although Kubernetes offers methods for deploying pods and conducting A/B testing
    and canary deployments, these processes often involve scaling container replicas.
    For example, deploying a new microservice version with just 10% of traffic directed
    to it requires at least 10 containers: 9 for the old version and 1 for the new
    version. Kubernetes distributes traffic evenly among pods without intelligent
    traffic splitting.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Kubernetes 提供了部署 Pod、进行 A/B 测试和金丝雀发布的方法，但这些过程通常涉及容器副本的扩展。例如，部署一个新版本的微服务并将
    10% 的流量导向它，至少需要 10 个容器：9 个用于旧版本，1 个用于新版本。Kubernetes 在 Pod 之间平均分配流量，而没有智能流量拆分。
- en: Each Kubernetes container within a pod maintains separate logging, necessitating
    a custom solution for capturing and consolidating logs.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Kubernetes 容器在 Pod 内保持独立的日志记录，因此需要一个定制的解决方案来捕获和汇总日志。
- en: While the Kubernetes dashboard provides features such as monitoring pods and
    checking their health, it does not offer insights into how components interact,
    the traffic distribution among pods, or the container chains that constitute the
    application. The inability to trace traffic flow through Kubernetes pods means
    you cannot pinpoint where in the chain a request encountered a failure.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Kubernetes 仪表盘提供了监控 Pod 和检查其健康状况等功能，但它无法提供关于组件如何交互、Pod 之间流量分配情况或构成应用程序的容器链的信息。无法追踪流量在
    Kubernetes Pod 中的流动意味着你无法确定请求在链中遇到故障的位置。
- en: To address these challenges comprehensively, a service mesh technology such
    as Istio can be of extreme help. This can effectively tackle the intricacies of
    managing microservices in Kubernetes and offer solutions for secure communication,
    intelligent traffic management, monitoring, and more. Let’s understand what the
    Istio service mesh is through a brief introduction.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了全面应对这些挑战，像 Istio 这样的服务网格技术可以提供极大的帮助。它可以有效应对 Kubernetes 中微服务管理的复杂性，并为安全通信、智能流量管理、监控等提供解决方案。让我们通过简要介绍来了解
    Istio 服务网格是什么。
- en: Introduction to Istio
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Istio 简介
- en: Istio is a service mesh technology designed to streamline service connectivity,
    security, governance, and monitoring.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 是一种服务网格技术，旨在简化服务连接、安全性、治理和监控。
- en: In the context of a microservices application, each microservice operates independently
    using containers, resulting in a complex web of interactions. This is where a
    service mesh comes into play, simplifying the discovery, management, and control
    of these interactions, often accomplished through a sidecar proxy. Allow me to
    break it down for you step by step.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务应用的背景下，每个微服务独立运行，使用容器，从而产生了一个复杂的交互网络。这就是服务网格发挥作用的地方，它简化了这些交互的发现、管理和控制，通常通过旁车代理来实现。让我一步一步为你解析。
- en: Imagine a standard Kubernetes application comprising a frontend and a backend
    pod. Kubernetes offers built-in service discovery between pods using Kubernetes
    services and CoreDNS. Consequently, you can direct traffic using the service name
    from one pod to another. However, you won’t have significant control over these
    interactions and runtime traffic management.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个标准的 Kubernetes 应用，由前端和后端 Pod 组成。Kubernetes 提供了使用 Kubernetes 服务和 CoreDNS
    进行 Pod 之间的内建服务发现。因此，你可以使用服务名称将流量从一个 Pod 引导到另一个 Pod。然而，你对这些交互和运行时流量管理的控制将有限。
- en: Istio steps in by injecting a sidecar container into your pod, which acts as
    a proxy. Your containers communicate with other containers via this proxy. This
    architecture allows all requests to flow through the proxy, enabling you to exert
    control over the traffic and collect data for further analysis. Moreover, Istio
    provides the means to encrypt communication between pods and enforce identity
    and access management through a unified control plane.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 通过将旁车容器注入到 Pod 中，充当代理。你的容器通过这个代理与其他容器进行通信。这种架构使得所有请求都通过代理流动，从而使你能够控制流量并收集数据以供进一步分析。此外，Istio
    提供了加密 Pod 之间通信的手段，并通过统一的控制平面实施身份和访问管理。
- en: Due to this architecture, Istio boasts a range of core functionalities that
    enhance the traffic management, security, and observability of your microservices
    environment.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种架构，Istio 拥有一系列核心功能，能够提升微服务环境中的流量管理、安全性和可观测性。
- en: Traffic management
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流量管理
- en: Istio effectively manages traffic by harnessing the power of the sidecar proxy,
    often referred to as the envoy proxy, alongside **ingress** and **egress gateways**.
    With these components, Istio empowers you to shape traffic and define service
    interaction rules. This includes implementing features such as **timeouts**, **retries**,
    **circuit breakers**, and much more, all through configurations within the control
    plane.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 通过利用 sidecar 代理（通常称为 envoy 代理）以及**入口**和**出口网关**，有效地管理流量。借助这些组件，Istio 使你能够塑造流量并定义服务交互规则。这包括实现诸如**超时**、**重试**、**熔断器**等功能，所有这些都可以通过控制面中的配置进行设置。
- en: These capabilities open the door to intelligent practices such as **A/B testing**,
    **canary deployments**, and **staged rollouts** with **traffic division based
    on percentages**. You can seamlessly execute gradual releases, transitioning from
    an existing version (**Blue**) to a new one (**Green**), all with user-friendly
    controls.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能为智能实践提供了可能，比如**A/B 测试**、**金丝雀部署**和**分阶段发布**，以及**基于百分比的流量划分**。你可以无缝执行渐进式发布，从现有版本（**Blue**）过渡到新版本（**Green**），所有操作都可以通过用户友好的控制界面完成。
- en: Moreover, Istio allows you to conduct operational tests in a live production
    environment, offering **live traffic mirroring** to test instances. This enables
    you to gather real-time insights and identify potential production issues before
    they impact your application. Additionally, you can route requests to different
    language-specific microservices versions based on **geolocation or user profiles**,
    among other possibilities.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Istio 允许你在生产环境中进行操作测试，通过**实时流量镜像**来测试实例。这使你能够收集实时数据并在问题影响应用程序之前识别潜在的生产问题。此外，你还可以基于**地理位置或用户档案**等因素，将请求路由到不同语言版本的微服务。
- en: Security
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全性
- en: Istio takes security seriously by securing your microservices through the envoy
    proxy and establishing identity access management between pods via mutual TLS.
    It is a robust defense against man-in-the-middle attacks through out-of-the-box
    **traffic encryption** between pods. This mutual authentication ensures that only
    trusted frontends can connect to backends, creating a strong trust relationship.
    Consequently, even if one of the pods is compromised, it cannot compromise the
    rest of your application. Istio further enhances security with **fine-grained
    access control policies** and introduces auditing tools currently lacking in Kubernetes,
    enhancing your cluster’s overall security posture.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 重视安全性，通过 envoy 代理保护你的微服务，并通过互信 TLS 在 pods 之间建立身份访问管理。这是一种强大的防御机制，能够防止中间人攻击，且在
    pods 之间提供开箱即用的**流量加密**。这种互认证确保只有受信任的前端可以连接到后台，从而建立强大的信任关系。因此，即使其中一个 pod 被攻破，它也无法威胁到应用程序的其他部分。Istio
    进一步增强了安全性，提供了**细粒度的访问控制策略**，并引入了目前 Kubernetes 中缺乏的审计工具，从而提升了集群的整体安全性。
- en: Observability
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可观察性
- en: Thanks to the envoy sidecar, Istio maintains a keen awareness of the traffic
    flowing through the pods, enabling you to gather crucial telemetry data from the
    services. This wealth of data aids in gaining insights into service behavior and
    offers a window into future optimization possibilities for your applications.
    Additionally, Istio consolidates application logs and facilitates **traffic tracing**
    through multiple microservices. These features empower you to identify and resolve
    issues more swiftly, helping you isolate problematic services and expedite debugging.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 envoy sidecar 的存在，Istio 能够敏锐地感知流经 pod 的流量，从而使你能够从服务中收集至关重要的遥测数据。这些丰富的数据有助于深入了解服务行为，并为应用程序未来的优化提供了一个窗口。此外，Istio
    还整合了应用程序日志，并通过多个微服务实现**流量追踪**。这些功能使你能够更迅速地识别和解决问题，帮助你隔离有问题的服务并加快调试过程。
- en: Developer-friendly
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面向开发者的友好性
- en: Istio’s most remarkable feature is its ability to relieve developers from the
    burdens of managing security and operational intricacies within their implementations.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 最显著的特点是，它能够减轻开发者在实现过程中管理安全性和操作复杂性的负担。
- en: Istio’s Kubernetes-aware nature permits developers to continue building their
    applications as standard Kubernetes deployments. Istio seamlessly and automatically
    injects sidecar containers into the pods, sparing developers the need to worry
    about these technical intricacies.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 对 Kubernetes 的深刻理解使得开发者可以继续像标准 Kubernetes 部署那样构建应用程序。Istio 会无缝且自动地将 sidecar
    容器注入到 pods 中，免去开发者对这些技术细节的担忧。
- en: Once these sidecar containers have been integrated, operations and security
    teams can then step in to enforce policies related to traffic management, security,
    and the overall operation of the application. This results in a mutually beneficial
    scenario for all involved parties.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦这些边车容器被集成，运维和安全团队就可以介入，执行与流量管理、安全性及应用程序整体运营相关的政策。这为所有相关方创造了互利的局面。
- en: Istio empowers security and operations teams to efficiently oversee microservices
    applications without hampering the development team’s productivity. This collaborative
    approach ensures that each team within the organization can maintain its specialized
    focus and effectively contribute to the app’s success. Now that we understand
    Istio, let’s look at its architecture.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 使安全和运维团队能够高效地监管微服务应用程序，而不妨碍开发团队的生产力。这种协作方法确保组织内的每个团队都能保持其专业焦点，并有效地为应用程序的成功做出贡献。现在我们已经了解了
    Istio，接下来我们将看看它的架构。
- en: Understanding the Istio architecture
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Istio 架构
- en: 'Istio simplifies microservices management through two fundamental components:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 通过两个基本组件简化了微服务的管理：
- en: '**Data plane**: This comprises the sidecar envoy proxies that Istio injects
    into your microservices. These proxies take on the essential role of routing traffic
    between various services, and they also collect crucial telemetry data to facilitate
    monitoring and insights.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据平面**：数据平面由 Istio 注入到微服务中的边车 envoy 代理组成。这些代理承担着在不同服务之间路由流量的关键角色，并收集重要的遥测数据，以便于监控和分析。'
- en: '**Control plane**: The control plane serves as the command center, instructing
    the data plane on how to route traffic effectively. It also handles the storage
    and management of configuration details, making it easier for administrators to
    interact with the sidecar proxy and take control of the Istio service mesh. In
    essence, the control plane functions as the intelligence and decision-making hub
    of Istio.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制平面**：控制平面充当指挥中心，指示数据平面如何有效地路由流量。它还负责配置细节的存储和管理，便于管理员与边车代理交互并控制 Istio 服务网格。本质上，控制平面是
    Istio 的智能和决策中心。'
- en: 'Similarly, Istio manages two types of traffic:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，Istio 管理两种类型的流量：
- en: '**Data plane traffic**: This type of traffic consists of the core business-related
    data exchanged between your microservices. It encompasses the actual interactions
    and transactions that your application handles.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据平面流量**：这种流量由微服务之间交换的核心业务相关数据组成。它涵盖了应用程序处理的实际交互和事务。'
- en: '**Control plane traffic**: In contrast, the control plane traffic consists
    of messages and communications between Istio components, and it is chiefly responsible
    for governing the behavior of the service mesh. It acts as the control mechanism
    that orchestrates the routing, security, and overall functioning of the microservices
    architecture.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制平面流量**：相反，控制平面流量由 Istio 组件之间的消息和通信组成，主要负责管理服务网格的行为。它充当着控制机制，协调微服务架构中的路由、安全性和整体功能。'
- en: 'The following diagram describes the Istio architecture in detail:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 下图详细描述了 Istio 架构：
- en: '![Figure 15.3 – Istio architecture](img/B19877_15_3.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.3 – Istio 架构](img/B19877_15_3.jpg)'
- en: Figure 15.3 – Istio architecture
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.3 – Istio 架构
- en: As we can see two distinct parts in the preceding diagram, the control plane
    and the data plane, let’s go ahead and understand them.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面的图示中看到的，控制平面和数据平面是两个不同的部分，接下来我们将深入了解它们。
- en: The control plane architecture
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制平面架构
- en: Istio ships the control plane as a single **istiod** component. The Istio control
    plane, or istiod, comprises several critical components, each playing a distinct
    role in managing your service mesh.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 将控制平面作为一个单独的 **istiod** 组件进行部署。Istio 控制平面，或称 istiod，包含多个关键组件，每个组件在管理服务网格中扮演着独特的角色。
- en: Pilot
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pilot
- en: '**Pilot** serves as the central control hub of the service mesh. It communicates
    with the envoy sidecars using the Envoy API and translates the high-level rules
    specified in Istio manifests into envoy configurations. Pilot enables service
    discovery, intelligent traffic management, and routing capabilities. It empowers
    you to implement practices such as A/B testing, Blue/Green deployments, canary
    rollouts, and more. Additionally, Pilot enhances the resiliency of your service
    mesh by configuring sidecars to handle tasks such as timeouts, retries, and circuit
    breaking. One of its notable features is providing a bridge between Istio configuration
    and the underlying infrastructure, allowing Istio to run on diverse platforms
    such as Kubernetes, **Nomad**, and **Consul**. Regardless of the platform, Pilot
    ensures consistent traffic management.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**Pilot** 作为服务网格的中央控制中心，使用 Envoy API 与 envoy sidecar 通信，并将 Istio 清单中指定的高级规则转换为
    envoy 配置。Pilot 支持服务发现、智能流量管理和路由功能。它使您能够实施 A/B 测试、蓝绿部署、金丝雀发布等实践。此外，Pilot 通过配置 sidecar
    处理超时、重试和断路等任务，增强了服务网格的弹性。它的一个显著特点是提供 Istio 配置与底层基础设施之间的桥梁，使 Istio 能够在多种平台上运行，如
    Kubernetes、**Nomad** 和 **Consul**。无论平台如何，Pilot 都能确保一致的流量管理。'
- en: Citadel
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Citadel
- en: '**Citadel** focuses on identity and access management within your service mesh,
    fostering secure communication between Kubernetes pods. It safeguards your pods
    by ensuring encrypted communication, even if your developers have designed components
    with insecure TCP connections. Citadel simplifies the implementation of mutual
    TLS by managing the complexities of certificates. It offers user authentication,
    credential management, certificate handling, and traffic encryption, ensuring
    pods can securely validate one another when necessary.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**Citadel** 专注于在您的服务网格内进行身份和访问管理，促进 Kubernetes pod 之间的安全通信。它通过确保加密通信来保护您的 pod，即使您的开发人员设计的组件使用了不安全的
    TCP 连接。Citadel 通过管理证书的复杂性简化了相互 TLS 的实现。它提供用户身份验证、凭证管理、证书处理和流量加密，确保 pod 在必要时能够安全地相互验证。'
- en: Galley
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Galley
- en: '**Galley** is responsible for essential configuration tasks within your service
    mesh. It validates, processes, and distributes configuration changes throughout
    the Istio control plane. For example, when you apply a new policy, Galley ingests
    the configuration, validates its accuracy, processes it for the intended components,
    and seamlessly disseminates it within the service mesh. In essence, Galley serves
    as the interface through which the Istio control plane interacts with the underlying
    APIs, facilitating the smooth management of your service mesh.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**Galley** 负责服务网格中的基本配置任务。它验证、处理并分发配置更改到 Istio 控制平面。例如，当您应用新的策略时，Galley 会摄取该配置，验证其准确性，处理并为目标组件准备，最后无缝地在服务网格中分发。简而言之，Galley
    作为 Istio 控制平面与底层 API 之间的接口，促进了服务网格的顺利管理。'
- en: Now, let’s dive deep into understanding the data plane architecture.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入了解数据平面架构。
- en: The data plane architecture
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据平面架构
- en: The data plane component of Istio is composed of **envoy proxies**, **ingress
    gateways**, and **egress gateways**.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 的数据平面组件由 **envoy 代理**、**入口网关** 和 **出口网关** 组成。
- en: Envoy proxies
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Envoy 代理
- en: 'Envoy proxies play a pivotal role in enabling various aspects of your service
    mesh. These **Layer 7** proxies are uniquely capable of making crucial decisions
    based on the content of the messages they handle, and they are the sole components
    that directly interact with your business traffic. Here’s how these envoy proxies
    contribute to the functionality of Istio:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Envoy 代理在启用服务网格的各个方面中发挥着至关重要的作用。这些 **第 7 层** 代理能够根据它们处理的消息内容做出重要决策，并且它们是唯一直接与您的业务流量交互的组件。以下是这些
    envoy 代理如何贡献于 Istio 的功能：
- en: '**Traffic control**: They provide fine-grained control over how traffic flows
    within your service mesh, allowing you to define routing rules for various types
    of traffic, including **HTTP**, **TCP**, **WebSockets**, and **gRPC**.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流量控制**：它们提供对服务网格内流量流动的细粒度控制，允许您为各种类型的流量定义路由规则，包括 **HTTP**、**TCP**、**WebSockets**
    和 **gRPC**。'
- en: '**Security and authentication**: Envoy proxies enforce **identity and access
    management**, ensuring that only authorized pods can interact with one another.
    They implement **mutual TLS** and **traffic encryption** to prevent **man-in-the-middle
    attacks** and offer features such as rate limiting to safeguard against runaway
    costs and **denial-of-service attacks**.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性和认证**：Envoy 代理执行**身份和访问管理**，确保只有经过授权的 pod 可以相互交互。它们实现**相互 TLS**和**流量加密**，以防止**中间人攻击**，并提供如速率限制等特性，以防止超出预算的成本和**拒绝服务攻击**。'
- en: '**Network resiliency**: They enhance network resiliency by supporting features
    such as **retries**, **failover**, **circuit breaking**, and **fault injection**
    to maintain the reliability and robustness of your services.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络弹性**：它们通过支持**重试**、**故障转移**、**断路器**和**故障注入**等特性来增强网络弹性，保持服务的可靠性和健壮性。'
- en: Next, let’s look at Ingress and egress gateways.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们来看看入站和出站网关。
- en: Ingress and egress gateways
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 入站和出站网关
- en: In Istio, ingress is a collection of one or more envoy proxies, which Pilot
    dynamically configures upon their deployment. These envoy proxies are crucial
    in controlling and routing incoming external traffic into your service mesh, ensuring
    that it is appropriately directed to the relevant services based on defined routing
    rules and policies. This dynamic configuration allows Istio to effectively manage
    and secure external traffic flows without requiring extensive manual intervention,
    ensuring that your applications can operate efficiently and securely within the
    service mesh.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Istio 中，入站网关是一组一个或多个 envoy 代理，Pilot 在其部署时动态配置这些代理。这些 envoy 代理在控制和路由外部流量进入您的服务网格中至关重要，确保流量根据定义的路由规则和策略正确地指向相关服务。这种动态配置使得
    Istio 能够有效地管理和保护外部流量流动，而无需大量的人工干预，确保您的应用程序可以在服务网格内高效、安全地运行。
- en: Egress gateways are similar to ingress gateways but they work on outgoing traffic
    instead. To understand this better, let’s use *Figure 15**.3* as a reference and
    understand the traffic flow through **Service A** and **Service B**.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 出站网关与入站网关相似，但它们处理的是出站流量。为了更好地理解这一点，我们可以参考*图 15.3*，了解**服务 A**和**服务 B**之间的流量流向。
- en: In this architecture, traffic within the service mesh follows a structured path
    through **Ingress**, microservices (**Service A** and **Service B**), and **Egress**,
    ensuring efficient routing and security measures. Let’s break down the flow of
    a traffic packet through your service mesh.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个架构中，服务网格中的流量遵循一个结构化的路径，通过**入站**、微服务（**服务 A**和**服务 B**）以及**出站**，确保高效的路由和安全措施。让我们分解一下流量包在服务网格中的流动过程。
- en: Ingress
  id: totrans-135
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 入站
- en: Traffic enters the service mesh through an ingress resource, which is essentially
    a cluster of envoy proxies. Pilot configures these envoy proxies upon deployment.
    Ingress proxies are aware of their backends due to configurations based on Kubernetes
    service endpoints. Ingress proxies conduct health checks, perform load balancing,
    and make intelligent routing decisions based on metrics such as load, packets,
    quotas, and traffic balancing.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 流量通过入站资源进入服务网格，入站资源本质上是一个 envoy 代理集群。Pilot 在部署时配置这些 envoy 代理。由于基于 Kubernetes
    服务端点的配置，入站代理了解其后端服务。入站代理执行健康检查、负载均衡，并基于负载、数据包、配额和流量平衡等指标做出智能路由决策。
- en: Service A
  id: totrans-137
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 服务 A
- en: Once Ingress routes the traffic to a pod, it encounters the sidecar proxy container
    of the Service A pod, not the actual microservice container. The envoy proxy and
    the microservice container share the same network namespace within the pod and
    have identical IP addresses and IP Table rules. The envoy proxy takes control
    of the pod, handling all traffic passing through it. The proxy interacts with
    Citadel to enforce policies, checks whether traffic needs encryption, and establishes
    TLS connections with the backend pod.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦入站网关将流量路由到一个 pod，它会遇到服务 A pod 的边车代理容器，而不是实际的微服务容器。envoy 代理和微服务容器共享 pod 内的同一网络命名空间，并且具有相同的
    IP 地址和 IP 表规则。envoy 代理控制 pod，处理通过它的所有流量。该代理与 Citadel 进行交互，执行策略，检查流量是否需要加密，并与后端
    pod 建立 TLS 连接。
- en: Service B
  id: totrans-139
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 服务 B
- en: Service A’s encrypted packet is sent to Service B, where similar steps are followed.
    Service B’s proxy verifies the sender’s identity through a TLS handshake with
    the source proxy. Upon establishing trust, the packet is forwarded to the Service
    B container, continuing the flow toward the egress layer.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 服务A的加密数据包被发送到服务B，服务B会遵循类似的步骤。服务B的代理通过与源代理进行TLS握手来验证发送者的身份。在建立信任后，数据包被转发到服务B的容器，继续流向出口层。
- en: Egress
  id: totrans-141
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 出口
- en: The egress resource manages outbound traffic from the mesh. Egress defines which
    traffic can exit the mesh and employs Pilot for configuration, similar to the
    ingress layer. Egress resources enable the implementation of policies restricting
    outbound traffic to only necessary services.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 出口资源管理着来自网格的出站流量。出口定义了哪些流量可以离开网格，并使用Pilot进行配置，类似于入口层。出口资源使得可以实施限制出站流量只流向必要服务的策略。
- en: Telemetry data collection
  id: totrans-143
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 遥测数据收集
- en: Throughout these steps, proxies collect telemetry data from the traffic. This
    telemetry data is sent to **Prometheus** for storage and analysis. This data can
    be visualized in **Grafana**, offering insights into the service mesh’s behavior.
    The telemetry data can also be sent to external tools such as **ELK** for more
    in-depth analysis and machine learning applications on metrics collected.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些步骤中，代理收集来自流量的遥测数据。这些遥测数据会发送到**Prometheus**进行存储和分析。这些数据可以在**Grafana**中可视化，提供对服务网格行为的洞察。遥测数据也可以发送到外部工具，如**ELK**，以便对收集的指标进行更深入的分析和机器学习应用。
- en: This structured flow ensures traffic moves securely and efficiently through
    the service mesh while providing valuable insights for monitoring, analysis, and
    decision-making processes.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这一结构化流程确保流量在服务网格中安全高效地流动，同时为监控、分析和决策过程提供宝贵的洞察。
- en: Now that we’ve understood the Istio architecture and its features, let’s go
    ahead and see how we can install it.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了Istio的架构和特点，接下来让我们看看如何安装它。
- en: Installing Istio
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装Istio
- en: The general way of installing Istio is to download Istio using the provided
    link and run a shell, which will install Istio on our system, including the **istioctl**
    component. Then, we need to use **istioctl** to install Istio within a Kubernetes
    cluster. However, since we’re using GitOps, we will use the GitOps principles
    to install it. Istio offers another method to install Istio – that is, using Helm.
    Since we know that Argo CD supports Helm, we will use that instead.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 安装Istio的一般方式是通过提供的链接下载Istio并运行一个shell，这将把Istio安装到我们的系统中，包括**istioctl**组件。然后，我们需要使用**istioctl**在Kubernetes集群中安装Istio。然而，由于我们使用的是GitOps，我们将使用GitOps原则来安装它。Istio还提供了另一种安装方式——使用Helm。由于我们知道Argo
    CD支持Helm，因此我们将使用它。
- en: 'Therefore, we will create new Argo CD applications to deploy it. We will create
    an Argo CD application for `istio-base`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将创建新的Argo CD应用程序来部署它。我们将为`istio-base`创建一个Argo CD应用程序：
- en: '[PRE10]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As we can see, it will deploy `v1.19.1` of the `istio-base` helm chart from
    [https://istio-release.storage.googleapis.com/charts](https://istio-release.storage.googleapis.com/charts)
    to the `istio-system` namespace of the Kubernetes cluster. Similarly, we will
    deploy `istiod` to the `istio-system` namespace using the following config:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，它将从[https://istio-release.storage.googleapis.com/charts](https://istio-release.storage.googleapis.com/charts)部署`istio-base`的`v1.19.1`
    helm图表到Kubernetes集群的`istio-system`命名空间。类似地，我们将使用以下配置将`istiod`部署到`istio-system`命名空间：
- en: '[PRE11]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, we will install the `istio-ingress` component on the `istio-ingress`
    namespace using the following config:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将使用以下配置在`istio-ingress`命名空间中安装`istio-ingress`组件：
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will also define the configuration on Terraform so that we can use push-based
    GitOps to create our application automatically. So, we will append the following
    to the `app.tf` file:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在Terraform中定义配置，以便我们可以使用基于推送的GitOps自动创建我们的应用。因此，我们将以下内容附加到`app.tf`文件中：
- en: '[PRE13]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we can commit and push these files to our remote repository and wait for
    Argo CD to reconcile the changes using the following commands:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以提交并推送这些文件到我们的远程仓库，并等待Argo CD使用以下命令进行变更协调：
- en: '[PRE14]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As soon as we push the code, we’ll see that the GitHub Actions workflow has
    been triggered. To access the workflow, go to `https://github.com/<your_github_user>/mdo-environments/actions`.
    Soon, the workflow will apply the configuration and create the Kubernetes cluster,
    deploy Argo CD, external secrets, our Blog App, and Istio.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们推送代码，我们将看到GitHub Actions工作流已触发。要访问该工作流，请前往`https://github.com/<your_github_user>/mdo-environments/actions`。不久后，工作流将应用配置并创建Kubernetes集群，部署Argo
    CD、外部机密、我们的Blog应用和Istio。
- en: 'Once the workflow succeeds, we must access the Argo Web UI. To do that, we
    need to authenticate with the GKE cluster. To do so, run the following command:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦工作流成功执行，我们必须访问Argo Web UI。为此，我们需要使用GKE集群进行身份验证。执行以下命令来完成身份验证：
- en: '[PRE15]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To utilize the Argo CD Web UI, you will require the external IP address of
    the `argo-server` service. To get that, run the following command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Argo CD Web UI，您需要`argo-server`服务的外部IP地址。要获取该地址，请运行以下命令：
- en: '[PRE16]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Now, we know that Argo CD can be accessed at `https://34.122.51.25/`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道可以通过`https://34.122.51.25/`访问Argo CD。
- en: 'Next, we will run the following commands to reset the admin password:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将运行以下命令来重置管理员密码：
- en: '[PRE17]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, allow 2 minutes for the new credentials to be generated. After that, execute
    the following command to retrieve the password:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，等待2分钟让新凭证生成。之后，执行以下命令以获取密码：
- en: '[PRE18]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that we have the credentials, we can log in. We will see the following
    page:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了凭证，可以登录了。我们将看到以下页面：
- en: '![Figure 15.4 – Argo CD Web UI – home page](img/B19877_15_4.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.4 – Argo CD Web UI – 主页](img/B19877_15_4.jpg)'
- en: Figure 15.4 – Argo CD Web UI – home page
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.4 – Argo CD Web UI – 主页
- en: As we can see, the Istio applications are up and running. Though Istio is installed
    and running, the sidecars won’t be injected unless we ask Istio to do so. We’ll
    look at this next.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Istio应用程序已启动并运行。尽管Istio已经安装并运行，但除非我们要求Istio注入侧车，否则侧车不会被注入。接下来我们会讲解这个部分。
- en: Enabling automatic sidecar injection
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启用自动侧车注入
- en: 'Since envoy sidecars are the key technology behind Istio’s capabilities, they
    must be added to your existing pods to enable Istio to manage them. Updating each
    pod’s configuration to include these sidecars can be challenging. To address this
    challenge, Istio offers a solution by enabling the automatic injection of these
    sidecars. To allow automatic sidecar injection on a namespace, we must add a label
    – that is, `istio-injection: enabled`. To do so, we will modify the `blog-app.yaml`
    file and add the label to the namespace resource:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '由于envoy侧车是Istio功能背后的关键技术，它们必须添加到现有的Pod中，以便Istio能够管理它们。更新每个Pod的配置以包含这些侧车可能具有挑战性。为了解决这个问题，Istio提供了解决方案，通过启用这些侧车的自动注入功能。要在命名空间上启用自动侧车注入，我们必须添加一个标签——即`istio-injection:
    enabled`。为此，我们将修改`blog-app.yaml`文件，并将标签添加到命名空间资源中：'
- en: '[PRE19]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, we can commit this resource to Git and push the changes remotely using
    the following commands:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将此资源提交到Git并使用以下命令将更改推送到远程：
- en: '[PRE20]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the next Argo CD sync, we will soon find the label attached to the namespace.
    As soon as the label is applied, we need to restart our deployments and stateful
    sets, at which point new pods will come up with the injected sidecars. Use the
    following commands to do so:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一次Argo CD同步中，我们将很快找到附加到命名空间的标签。标签应用后，我们需要重新启动部署和有状态集，此时新Pod将启动并带有注入的侧车。使用以下命令进行操作：
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, let’s list the pods in the `blog-app` namespace using the following command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令列出`blog-app`命名空间中的Pod：
- en: '[PRE22]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As we can see, the pods now show two containers instead of one. The extra container
    is the envoy sidecar. Istio’s installation and setup are complete.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Pod现在显示两个容器，而不是一个。额外的容器是envoy侧车。Istio的安装和设置已完成。
- en: Now that our application has the Istio sidecar injected, we can use Istio ingress
    to allow traffic to our application, which is currently exposed via a load balancer
    service.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用已经注入了Istio侧车，我们可以使用Istio入口控制器来允许流量访问我们的应用，当前该应用通过负载均衡服务暴露。
- en: Using Istio ingress to allow traffic
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Istio入口控制器来允许流量
- en: We need to create a Blog App ingress gateway to associate our application with
    the Istio ingress gateway. It is necessary for configuring our application to
    route traffic through the Istio ingress gateway as we want to leverage Istio’s
    traffic management and security features.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个Blog应用的入口网关，将我们的应用与Istio入口网关关联起来。这是配置我们的应用通过Istio入口网关路由流量所必需的，因为我们希望利用Istio的流量管理和安全功能。
- en: 'Istio deploys the Istio ingress gateway as a part of the installation process,
    and it’s exposed on a load balancer by default. To determine the load balancer’s
    IP address and ports, you can run the following commands:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 在安装过程中会部署 Istio 入口网关，并且默认将其暴露在负载均衡器上。要确定负载均衡器的 IP 地址和端口，你可以运行以下命令：
- en: '[PRE23]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As we can see, Istio exposes various ports on your load balancer, and as our
    application needs to run on port 80, we can access it using `http://<IngressLoadBalancerExternalIP>:80`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Istio 在负载均衡器上暴露了多个端口，而我们的应用程序需要运行在端口 80，因此我们可以使用`http://<IngressLoadBalancerExternalIP>:80`来访问它。
- en: The next step would be to use this ingress gateway and expose our application.
    For that, we need to create **Gateway** and **VirtualService** resources.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是使用这个入口网关并暴露我们的应用程序。为此，我们需要创建**网关（Gateway）**和**虚拟服务（VirtualService）**资源。
- en: Istio gateway is a **custom resource definition** (**CRD**) that helps you define
    how incoming external traffic can access services in your mesh. It acts as an
    entry point to your service and a load balancer for incoming traffic. When external
    traffic arrives at a gateway, it determines how to route it to the appropriate
    services based on the specified routing rules.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 网关是一个**自定义资源定义**（**CRD**），它帮助你定义外部流量如何访问你的服务网格中的服务。它充当服务的入口点，并作为传入流量的负载均衡器。当外部流量到达网关时，它会根据指定的路由规则来决定如何将流量路由到相应的服务。
- en: When we define an Istio gateway, we also need to define a `VirtualService` resource
    that uses the gateway and describes the routing rules for the traffic. Without
    a `VirtualService` resource, the Istio gateway will not know where and how to
    route the traffic it receives. A `VirtualService` resource is not only used for
    routing traffic from gateways but also for routing traffic within different services
    of the mesh. It allows you to define sophisticated routing rules, including traffic
    splitting, retries, timeouts, and more. Virtual services are often associated
    with specific services or workloads and determine how traffic should be routed
    to them. You can use virtual services to control how traffic is distributed among
    different versions of a service, enabling practices such as A/B testing, canary
    deployments, and Blue/Green deployments. Virtual services can also route traffic
    based on HTTP headers, paths, or other request attributes. In the current context,
    we will use the `VirtualService` resource to filter traffic based on paths and
    route them all to the **frontend** microservice.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义一个 Istio 网关时，我们还需要定义一个使用该网关并描述流量路由规则的`VirtualService`资源。如果没有`VirtualService`资源，Istio
    网关将不知道如何以及将流量路由到哪里。`VirtualService`资源不仅用于从网关路由流量，还用于在网格中的不同服务之间路由流量。它允许你定义复杂的路由规则，包括流量分配、重试、超时等。虚拟服务通常与特定的服务或工作负载关联，并决定如何将流量路由到这些服务。你可以使用虚拟服务来控制流量如何在服务的不同版本之间分配，从而支持
    A/B 测试、金丝雀发布和蓝绿部署等实践。虚拟服务还可以根据 HTTP 头、路径或其他请求属性来路由流量。在当前的上下文中，我们将使用`VirtualService`资源根据路径过滤流量，并将它们全部路由到**前端**微服务。
- en: 'Let’s look at the definition of the `Gateway` resource first:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先查看`Gateway`资源的定义：
- en: '[PRE24]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'As we can see, we define a `Gateway` resource that uses the Istio ingress gateway
    (defined by the `istio: ingress` selector) and listens on HTTP port `80`. It allows
    connection to all hosts as we’ve set that to `"*"`. For gateways to work correctly,
    we need to define a `VirtualService` resource. Let’s look at that next:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '如我们所见，我们定义了一个使用 Istio 入口网关（由`istio: ingress`选择器定义）的`Gateway`资源，并监听 HTTP 端口`80`。它允许连接到所有主机，因为我们将其设置为`"*"”。为了使网关正常工作，我们需要定义一个`VirtualService`资源。接下来我们来看看这个资源：'
- en: '[PRE25]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `VirtualService` resource listens on all hosts and applies to `blog-app-gateway`
    as specified. It allows `/static`, and `/posts` as a `prefix` match. This means
    all requests with a URI that begins with them would be routed. The `/login`, `/logout`,
    `/register`, `/updateprofile`, and `/` paths have an `exact` match, which means
    that the exact URI is matched and allowed. These are routed to the `frontend`
    service on port `80`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`VirtualService`资源监听所有主机，并如指定的那样应用于`blog-app-gateway`。它允许`/static`和`/posts`作为`前缀（prefix）`匹配。这意味着所有以这些路径开头的
    URI 请求都会被路由。`/login`、`/logout`、`/register`、`/updateprofile`和`/`路径具有`精确（exact）`匹配，这意味着只有完全匹配的
    URI 才会被允许。这些请求将被路由到`frontend`服务的端口`80`。'
- en: We must also modify the `frontend` service within the `blog-app.yaml` file to
    change the service type to `ClusterIP`. This will remove the attached load balancer
    from the service, and all requests will be routed via the ingress gateway.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须修改`blog-app.yaml`文件中的`frontend`服务，将服务类型更改为`ClusterIP`。这样会将附加的负载均衡器从服务中移除，所有请求将通过入口网关路由。
- en: 'Now, let’s go ahead and apply these changes using the following commands:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过以下命令来应用这些更改：
- en: '[PRE26]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We will wait 5 minutes for the sync to work, after which we can go to `http://<Ingress`
    **LoadBalancerExternalIP>** to access our Blog App. You should see the following
    page. This shows that the application is working correctly:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将等待 5 分钟以便同步生效，之后可以访问`http://<Ingress` **LoadBalancerExternalIP>** 来访问我们的博客应用。你应该能看到以下页面。这表明应用程序运行正常：
- en: '![Figure 15.5 – Blog App – home page](img/B19877_15_5.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图 15.5 – 博客应用 – 主页](img/B19877_15_5.jpg)'
- en: Figure 15.5 – Blog App – home page
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图 15.5 – 博客应用 – 主页
- en: You can play around with the application by registering, logging in, creating
    a post, and writing a review. Try updating the post and reviews to see whether
    all aspects of the application are working. Now, let’s look at the security aspects
    of our microservices.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过注册、登录、创建帖子和写评论来玩一下这个应用程序。尝试更新帖子和评论，看看应用的各个方面是否正常工作。现在，让我们看看我们微服务的安全性方面。
- en: Securing your microservices using Istio
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Istio 保护你的微服务
- en: Running microservices in production offers numerous advantages, such as independent
    scalability, enhanced agility, reduced scope of change, frequent deployments,
    and reusability. However, they also introduce unique challenges, particularly
    in terms of security.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中运行微服务具有众多优势，如独立的可扩展性、增强的敏捷性、减少的变更范围、频繁的部署和可重用性。然而，它们也带来了独特的挑战，尤其是在安全方面。
- en: 'In a monolithic architecture, the security focus revolves around safeguarding
    a single application. However, in a typical enterprise-grade microservices application,
    hundreds of microservices may need to interact securely with each other. Kubernetes
    serves as an excellent platform for hosting and orchestrating microservices. Nevertheless,
    the default communication between microservices is insecure, as they typically
    use plaintext HTTP. This may not meet your security requirements. To apply the
    same security principles to microservices as you would to a traditional enterprise
    monolith, you must ensure the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体架构中，安全性关注的是保护单一应用程序。然而，在典型的企业级微服务应用中，可能需要数百个微服务相互安全地互动。Kubernetes 是托管和编排微服务的绝佳平台。然而，微服务之间的默认通信是不安全的，因为它们通常使用明文
    HTTP。这可能无法满足你的安全需求。为了将与传统企业单体应用相同的安全原则应用到微服务中，必须确保以下几点：
- en: '**Encrypted communications**: All interactions between microservices must be
    encrypted to prevent potential man-in-the-middle attacks'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加密通信**：微服务之间的所有交互必须加密，以防止潜在的中间人攻击。'
- en: '**Access control**: Access control mechanisms need to be in place to ensure
    that only authorized microservices can interface with each other'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问控制**：需要实施访问控制机制，以确保只有经过授权的微服务才能相互通信。'
- en: '**Telemetry and audit logging**: Capturing, logging, and auditing telemetry
    data is crucial to understanding traffic behavior and proactively detecting intrusions'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遥测和审计日志**：捕获、记录和审计遥测数据对于了解流量行为并主动检测入侵至关重要。'
- en: Istio simplifies addressing these security concerns and provides these essential
    security features out of the box. With Istio, you can enforce strong **identity
    and access management**, mutual **TLS** and **encryption**, **authentication**
    and **authorization**, and comprehensive **audit logging** – all within a unified
    control plane. This means you can establish robust security practices for your
    microservices, promoting the safety and reliability of your applications in a
    dynamic and distributed environment.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Istio 简化了处理这些安全问题，并提供了开箱即用的核心安全功能。通过 Istio，你可以强制执行强大的**身份和访问管理**、相互**TLS**和**加密**、**认证**和**授权**以及全面的**审计日志**—所有这些都在统一的控制平面内。这意味着你可以为你的微服务建立强大的安全实践，在动态分布的环境中提升应用程序的安全性和可靠性。
- en: In the context of Istio, you should be aware that it automatically injects sidecar
    proxies into your pods and modifies the IP tables of your Kubernetes cluster to
    ensure that all connections occur through these proxies. This setup is designed
    to enforce TLS encryption by default, enhancing the security of your microservices
    without requiring specific configurations. The communication between these envoy
    proxies within the service mesh is automatically secured through TLS.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在Istio的背景下，你应该了解它会自动将边车代理注入到你的Pod中，并修改Kubernetes集群的IP表，以确保所有连接都通过这些代理进行。这种设置旨在默认强制启用TLS加密，增强你的微服务安全性，而无需特定配置。这些Envoy代理之间的通信会通过TLS自动加密。
- en: While the default setup offers a foundational level of security and effectively
    prevents man-in-the-middle attacks, it’s advisable to further bolster the security
    of your microservices by applying specific policies. Before delving into the detailed
    features, having a high-level understanding of how security functions in Istio
    is beneficial.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管默认配置提供了基础的安全性，并有效防止了中间人攻击，但建议通过应用特定策略来进一步增强微服务的安全性。在深入了解详细功能之前，理解Istio中安全性如何运作是有益的。
- en: 'Istio incorporates the following key components for enforcing security:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Istio包含以下关键组件来执行安全策略：
- en: '**Certificate authority** (**CA**): This component manages keys and certificates,
    ensuring secure and authenticated communication within the service mesh.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**证书颁发机构**（**CA**）：此组件管理密钥和证书，确保在服务网格中进行安全和认证的通信。'
- en: '**Configuration API Server**: The Configuration API Server distributes authentication
    policies, authorization policies, and secure naming information to the envoy proxies.
    These policies define how services can authenticate and authorize each other and
    manage secure communication.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置API服务器**：配置API服务器将身份验证策略、授权策略和安全命名信息分发给Envoy代理。这些策略定义了服务如何进行身份验证和授权，并管理安全通信。'
- en: '**Sidecar proxies**: Sidecar proxies, deployed alongside your microservices,
    are crucial in enforcing security policies. They act as policy enforcement points,
    implementing the policies supplied to them.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边车代理**：边车代理作为微服务的配套部署，对于强制执行安全策略至关重要。它们充当策略执行点，实施提供给它们的策略。'
- en: '**Envoy proxy extensions**: These extensions enable the collection of telemetry
    data and auditing, providing insights into traffic behavior and helping to identify
    and mitigate security issues.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Envoy代理扩展**：这些扩展使得可以收集遥测数据和审计信息，提供流量行为的洞察，并帮助识别和缓解安全问题。'
- en: With these components working in concert, Istio ensures a robust security framework
    for your microservices, which can be further fine-tuned by defining and enforcing
    specific security policies tailored to your application’s needs.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些组件协同工作下，Istio为你的微服务提供了一个强大的安全框架，可以通过定义和执行特定的安全策略进一步优化，以满足你应用的需求。
- en: As our application currently runs on HTTP, it would be a great idea to implement
    TLS in our Blog App and expose it over HTTPS. Let’s start by creating a secure
    ingress gateway for this.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序目前运行在HTTP上，因此在博客应用中实现TLS并通过HTTPS暴露是一个很好的主意。让我们从创建一个安全的入口网关开始。
- en: Creating secure ingress gateways
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建安全的入口网关
- en: Secure ingress gateways are nothing but **TLS-enabled ingress gateways**. To
    enable TLS on an ingress gateway, we must provide it with a **private key** and
    a **certificate** chain. We will use a self-signed certificate chain for this
    exercise, but you must use a proper CA certificate chain in production. A CA certificate
    is a digital certificate that’s granted by a reputable CA, such as Verisign or
    Entrust, within a **public key infrastructure** (**PKI**). It plays a pivotal
    role in guaranteeing the security and reliability of digital interactions and
    transactions.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 安全的入口网关就是**启用了TLS的入口网关**。要在入口网关上启用TLS，我们必须为其提供**私钥**和**证书链**。我们将在这个练习中使用自签名证书链，但在生产环境中你必须使用正确的CA证书链。CA证书是由可信的CA（如Verisign或Entrust）授予的数字证书，属于**公钥基础设施**（**PKI**）的一部分。它在保障数字交互和交易的安全性与可靠性方面发挥着关键作用。
- en: 'Let’s start by creating a **root certificate** and **private key** to sign
    certificates for our application by using the following command:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建**根证书**和**私钥**开始，通过以下命令签署应用程序的证书：
- en: '[PRE27]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Using the generated root certificate, we can now generate the **server certificate**
    and the key using the following commands:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用生成的根证书，我们现在可以使用以下命令生成 **服务器证书** 和密钥：
- en: '[PRE28]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The next step is to generate a Kubernetes TLS secret within the `istio-ingress`
    namespace for our ingress gateway to read it. However, as we don’t want to store
    the TLS key and certificate in our Git repository, we will use **Google Secrets
    Manager** instead. Therefore, let’s run the following command to do so:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是在 `istio-ingress` 命名空间中生成一个 Kubernetes TLS 秘密供我们的入口网关读取。然而，考虑到我们不希望将 TLS
    密钥和证书存储在 Git 仓库中，我们将改用 **Google Secrets Manager**。因此，我们将运行以下命令来实现：
- en: '[PRE29]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we must create an external secret manifest to fetch the keys and certificates
    from Secrets Manager and generate a TLS secret. The following manifest will help
    us achieve that:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须创建一个外部秘密清单，从 Secrets Manager 获取密钥和证书，并生成 TLS 秘密。以下清单将帮助我们实现这一目标：
- en: '[PRE30]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, let’s create a directory within our Environment Repository and copy the
    external secret manifest there. Use the following commands for that:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在环境仓库中创建一个目录，并将外部秘密清单复制到其中。使用以下命令进行操作：
- en: '[PRE31]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Next, we need to modify the ingress gateway resource to configure TLS. To do
    so, we must modify the `Gateway` resource to the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要修改入口网关资源以配置 TLS。为此，我们必须将 `Gateway` 资源修改为以下内容：
- en: '[PRE32]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The gateway configuration is similar to the previous one, but instead of `port
    80`, we’re using `port 443` for `HTTPS`. We also have a `tls` section with a `SIMPLE`
    mode, which means it is a standard TLS connection. We’ve specified `credentialName`,
    pointing to the secret we created using the TLS key and certificate. Since all
    the setup is now ready, let’s commit and push the code using the following commands:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 网关配置与之前类似，但我们使用 `port 443` 来替代 `port 80`，用于 `HTTPS`。我们还有一个 `tls` 部分，并设置为 `SIMPLE`
    模式，这意味着它是一个标准的 TLS 连接。我们已经指定了 `credentialName`，指向我们使用 TLS 密钥和证书创建的秘密。由于所有设置已就绪，让我们使用以下命令提交并推送代码：
- en: '[PRE33]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Wait for `blog-app` to sync. Once we’ve done this, we can access our application
    at `https:` **//<IngressLoadBalancerExternalIP>**. With that, the connection coming
    into our application has been encrypted.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 等待 `blog-app` 同步。一旦完成，我们可以通过 `https:` **//<IngressLoadBalancerExternalIP>**
    访问我们的应用程序。这样，进入应用程序的连接就已经加密。
- en: Though we’ve secured connection coming into our mesh, securing all internal
    service interactions with services using TLS within your service mesh would be
    good as an additional security layer. We’ll implement that next.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经保护了进入服务网格的连接，但作为额外的安全层，保护所有内部服务之间的 TLS 通信也是非常重要的。接下来，我们将实施这一措施。
- en: Enforcing TLS within your service mesh
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在服务网格中强制启用 TLS
- en: As we know by now, by default, Istio provides TLS encryption for communication
    between workloads that have sidecar proxies injected. However, it’s important
    to note that this default setting operates in compatibility mode. In this mode,
    traffic between two services with sidecar proxies injected is encrypted. However,
    workloads without sidecar proxies can still communicate with backend microservices
    over plaintext HTTP. This design choice is made to simplify the adoption of Istio,
    as teams newly introducing Istio don’t need to immediately address the issue of
    making all source traffic TLS-enabled.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，默认情况下，Istio 为注入了 sidecar 代理的工作负载之间的通信提供 TLS 加密。然而，需要注意的是，这个默认设置处于兼容模式。在这种模式下，两个具有
    sidecar 代理的服务之间的流量是加密的。但是，没有 sidecar 代理的工作负载仍然可以通过明文 HTTP 与后端微服务通信。这个设计选择是为了简化
    Istio 的采用，因为新引入 Istio 的团队不需要立即解决将所有源流量启用 TLS 的问题。
- en: 'Let’s create and get a shell to a pod in the `default` namespace. The backend
    traffic will be plaintext because the namespace does not have automatic sidecar
    injection. We will then `curl` the `frontend` microservice from there and see
    whether we get a response. Run the following command to do so:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建并进入 `default` 命名空间中的一个 Pod 的 shell。由于该命名空间没有自动的 sidecar 注入，后端流量将是明文的。然后，我们将在那里
    `curl` `frontend` 微服务，看看是否能收到响应。运行以下命令进行操作：
- en: '[PRE34]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As we can see, we get an `HTTP 200` response back.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们得到了 `HTTP 200` 响应。
- en: This approach balances security and compatibility, allowing a gradual transition
    to a fully encrypted communication model. Over time, as more services have sidecar
    proxies injected, the overall security posture of the microservices application
    improves. However, as we are starting fresh, enforcing strict TLS for our Blog
    App would make sense. So, let’s do that.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable strict TLS on a workload, namespace, or the entire cluster, Istio
    provides peer authentication policies using the `PeerAuthentication` resource.
    As we only need to implement strict TLS on the Blog App, enabling it at the namespace
    level would make sense. To do that, we will use the following `PeerAuthentication`
    resource:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, let’s apply this using the following commands:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Argo CD should pick up the new configuration and apply the strict TLS policy
    as soon as we push the changes. Wait for the Argo CD sync to be in a clean state,
    and run the following commands to check whether strict TLS is working:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As we can see, the request has now been rejected as it is a plaintext request,
    and the backend will only allow TLS. This shows that strict TLS is working fine.
    Now, let’s move on and secure our services even better.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'From our design, we know how services interact with each other:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: The `frontend` microservice can only connect to the `posts`, `reviews`, and
    `users` microservices
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only the `reviews` microservice can connect to the `ratings` microservice.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only the `posts`, `reviews`, `users`, and `ratings` microservices can connect
    to the `mongodb` database
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Therefore, we can define these interactions and only allow these connections
    explicitly. Therefore, the `frontend` microservice will not be able to connect
    with the `mongodb` database directly, even if it tries to.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Istio provides the `AuthorizationPolicy` resource to manage this. Let’s implement
    the preceding scenario using that.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with the `posts` microservice:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The `AuthorizationPolicy` has multiple sections. It starts with `name` and
    `namespace`, which are `posts` and `blog-app`, respectively. The `spec` section
    contains `selector`, where we specify that we need to apply this policy to all
    pods with the `app: posts` label. We use an `ALLOW` action for this. Note that
    Istio has an implicit `deny-all` policy for all pods that match the selector,
    and any `ALLOW` rules will be applied on top of that. Any traffic that does not
    match the `ALLOW` rules will be denied by default. We have rules to define what
    traffic to allow; here, we’re using the `from` > `source` > `principals` and setting
    the `frontend` service account on this. So, in summary, this rule will apply to
    the `posts` microservice and only allow traffic from the `frontend` microservice.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we will apply the same policy to the `reviews` microservice, as
    follows:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `users` microservice also only needs to accept traffic from the `frontend`
    microservice:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `ratings` microservice should accept traffic only from the `reviews` microservice,
    so we will make a slight change to the principals, as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Finally, the `mongodb` service needs a connection from all microservices apart
    from `frontend`, so we must specify multiple entries in the principal section:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Since we’ve used service accounts to understand where the requests are coming
    from, we must also create and assign service accounts to respective services.
    So, we will modify the `blog-app.yaml` file and add service accounts for each
    service, something like the following:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'I’ve already replicated the same in the new `blog-app.yaml` file. Let’s commit
    the changes and push them to GitHub so that we can apply them to our cluster:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now, we must wait for the sync to complete and then verify the setup. First,
    we’ll get a shell to the `frontend` pod and try to use `wget` to connect with
    the backend microservices. We will try to connect with each microservice and see
    what we get. If we get `HTTP 200` or `404`, this means the backend is allowing
    connections, while if we get `HTTP 403` or `Error`, this signifies the backend
    is blocking connections. Run the following commands to do so:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: As we can see, we get an `HTTP 404` response from the `posts`, `reviews`, and
    `users` microservices. The `ratings` microservice returns a `403 Forbidden` response,
    and the `mongodb` service reports that the resource is unavailable. This means
    that our setup is working correctly.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try the same with the `posts` microservice:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'As we can see, the `posts` microservice can communicate successfully with `mongodb`,
    but the rest of the microservices return `403 Forbidden`. This is what we were
    expecting. Now, let’s do the same with the `reviews` microservice:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As we can see, the `reviews` microservice can successfully connect with the
    `ratings` microservice and `mongodb`, while getting a `403` response from other
    microservices. This is what we expected. Now, let’s check the `ratings` microservice:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: As we can see, the `ratings` microservice can only connect successfully with
    the `mongdb` database and gets a `403` response for other services.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve tested all the services, the setup is working fine. We’ve secured
    our microservices to a great extent! Now, let’s look at another aspect of managing
    microservices with Istio – traffic management.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Managing traffic with Istio
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Istio offers robust traffic management capabilities that form a core part of
    its functionality. When leveraging Istio for microservice management within your
    Kubernetes environment, you gain precise control over how these services communicate
    with each other. This empowers you to define the traffic path within your service
    mesh meticulously.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the traffic management features at your disposal are as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Request routing
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fault injection
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traffic shifting
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TCP traffic shifting
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request timeouts
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circuit breaking
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mirroring
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The previous section employed an ingress gateway to enable traffic entry into
    our mesh and used a virtual service to distribute traffic to the services. With
    virtual services, the traffic distribution happens in a round-robin fashion by
    default. However, we can change that using destination rules. These rules provide
    us with an intricate level of control over the behavior of our mesh, allowing
    for a more granular management of traffic within the Istio ecosystem.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we delve into that, we need to update our Blog App so that it includes
    a new version of the `ratings` service deployed as `ratings-v2`, which will return
    black stars instead of orange stars. I’ve already updated the manifest for that
    in the repository. Therefore, we just need to copy that to the `mdo-environments`
    repository, commit it, and push it remotely using the following commands:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Wait for the application to sync. After this, we need to do a few things:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Go to the Blog App home page > **Sign In** > **Not a User? Create an account**
    and create a new account.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the **Actions** tab > **Add a Post**, add a new post with a title and
    content of your choice, and click **Submit**.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the **Add a Review** text field to add a review, provide a rating, and click
    **Submit**.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Posts** again and access the post that we had created.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, keep refreshing the page. We will see that we get orange stars half the
    time and black stars for the rest. Traffic is splitting equally across `v1` and
    `v2` (that is, the orange and black stars):'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.6 – Round robin routing](img/B19877_15_6.jpg)'
  id: totrans-302
  prefs: []
  type: TYPE_IMG
- en: Figure 15.6 – Round robin routing
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: This occurs due to the absence of destination rules, which leaves Istio unaware
    of the distinctions between `v1` and `v2`. Let’s define destination rules for
    our microservices to rectify this, clearly informing Istio of these versions.
    In our case, we have one version for each microservice, except for the `ratings`
    microservice, so we’ll define the following destination rules accordingly.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by defining the destination rule of the `frontend` microservice:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The provided YAML manifest introduces a `DestinationRule` resource named `frontend`
    within the `blog-app` namespace. This resource is associated with the host named
    `frontend`. Subsequently, we define subsets labeled as `v1`, targeting pods with
    the `version: v1` label. Consequently, configuring our virtual service to direct
    traffic to the `v1` destination will route requests to pods bearing the `version:`
    `v1` label.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: 'This same configuration approach can be replicated for the `posts`, `users`,
    and `reviews` microservices. However, the `ratings` microservice requires a slightly
    different configuration due to the deployment of two versions, as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The YAML manifest for the `ratings` microservice closely resembles that of
    the other microservices, with one notable distinction: it features a second subset
    labeled as `v2`, corresponding to pods bearing the `version:` `v2` label.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: 'Consequently, requests routed to the `v1` destination target all pods with
    the `version: v1` label, while requests routed to the `v2` destination are directed
    to pods labeled `version: v2`.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this in a practical context, we will proceed to define virtual
    services for each microservice. Our starting point will be defining the virtual
    service for the `frontend` microservice, as illustrated in the following manifest:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The provided YAML manifest outlines a `VirtualService` resource named `frontend`
    within the `blog-app` namespace. This resource configures the host `frontend`
    with an HTTP route destination, directing all traffic to the `frontend` host and
    specifying the `v1` subset. Consequently, all requests targeting the `frontend`
    host will be routed to the `v1` destination that we previously defined.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: We will replicate this configuration approach for the `posts`, `reviews`, and
    `users` microservices, creating corresponding `VirtualService` resources. In the
    case of the `ratings` microservice, the decision is made to route all traffic
    to the `v1` (orange stars) version. Therefore, we apply a similar `VirtualService`
    resource for the `ratings` microservice as well.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s copy the manifests to the `mdo-environments` repository and commit
    and push the code to the remote repository using the following commands:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Wait for Argo CD to sync the changes. Now, all requests will route to `v1`.
    Therefore, you will only see orange stars in the reviews, as shown in the following
    screenshot:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.7 – Route to v1](img/B19877_15_7.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
- en: Figure 15.7 – Route to v1
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s try to roll out `v2` using a canary rollout approach.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Traffic shifting and canary rollouts
  id: totrans-322
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Consider a scenario where you’ve developed a new version of your microservice
    and are eager to introduce it to your user base. However, you’re understandably
    cautious about the potential impact on the entire service. In such cases, you
    may opt for a deployment strategy known as **canary rollouts**, also known as
    a **Blue/Green deployment**.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'The essence of a canary rollout lies in its incremental approach. Instead of
    an abrupt transition, you methodically shift traffic from the previous version
    (referred to as **Blue**) to the new version (**Green**). This gradual migration
    allows you to thoroughly test the functionality and reliability of the new release
    with a limited subset of users before implementing it across the entire user base.
    This approach minimizes the risks associated with deploying new features or updates
    and ensures a more controlled and secure release process. The following figure
    illustrates this process beautifully:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.8 – Canary rollouts](img/B19877_15_8.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
- en: Figure 15.8 – Canary rollouts
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how a *canary rollout* strategy works:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '**Initial release**: The existing version (referred to as the *baseline* or
    *current version*) continues to serve the majority of users.'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Early access**: A small group of users or systems, typically selected as
    a representative sample, is identified as the *canary group*. They receive the
    new version.'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Monitoring and evaluation**: The software’s performance and behavior in the
    canary group are closely monitored. Metrics, logs, and user feedback are collected
    to identify issues or anomalies.'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Gradual expansion**: If the new version proves stable and performs as expected
    in the canary group, its exposure is incrementally expanded to a broader user
    base. This expansion can occur in stages, with a small percentage of users being
    “promoted” to the new version at each stage.'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Continuous monitoring**: Throughout the rollout, continuous monitoring and
    analysis are critical to identify and address any emerging issues promptly. If
    problems are detected, the rollout can be halted or reversed to protect the majority
    of users.'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Full deployment**: Once the new version has been successfully validated through
    the canary rollout stages, it is eventually made available to the entire user
    base.'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, let’s roll out the `ratings-v2` service to `20%` of our users. For that,
    we’ll use the following `VirtualService` resource:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: As we can see, we’ve modified the `ratings` virtual service to introduce a second
    destination pointing to the `v2` subset. A noteworthy addition in this configuration
    is the introduction of the `weight` attribute. For the `v1` destination, we have
    assigned a weight of `80`, while the `v2` destination carries a weight of `20`.
    This means that `20%` of the traffic will be directed to the `v2` version of the
    `ratings` microservice, providing a controlled and adjustable distribution of
    traffic between the two versions.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s copy the manifest and then commit and push the changes to the remote
    repository using the following commands:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Following the completion of the Argo CD sync, if you refresh the page 10 times,
    you’ll observe that black stars appear twice out of those 10 times. This is a
    prime example of a canary rollout in action. You can continue monitoring the application
    and gradually adjust the weights to shift traffic toward `v2`. Canary rollouts
    effectively mitigate risks during production rollouts, providing a method to address
    the fear of the unknown, especially when implementing significant changes.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: However, another approach exists to test your code in a production environment
    that involves using live traffic without exposing your application to end users.
    This method is known as traffic mirroring. We’ll delve into it in the following
    discussion.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: Traffic mirroring
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Traffic mirroring**, also called shadowing, is a concept that has recently
    gained traction. It is a powerful approach that allows you to assess your releases
    in a production environment without posing any risk to your end users.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, many enterprises maintained a staging environment that closely
    mimicked the production setup. The Ops team deployed new releases to the staging
    environment in this setup while testers generated synthetic traffic to simulate
    real-world usage. This approach provided a means for teams to evaluate how the
    code would perform in the production environment, assessing its functional and
    non-functional aspects before promoting it to production. The staging environment
    served as the ground for performance, volumetric, and operational acceptance testing.
    While this approach had its merits, it was not without its challenges. Maintaining
    static test environments, which involved substantial costs and resources, was
    one of them. Creating and sustaining a replica of the production environment required
    a team of engineers, leading to high overhead.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, synthetic traffic often deviated from real live traffic since the
    former relied on historical data, while the latter reflected current user interactions.
    This discrepancy occasionally led to overlooked scenarios.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, traffic mirroring offers a solution that similarly enables
    operational acceptance testing while going a step further. It allows you to conduct
    this testing using live, real-time traffic without any impact on end users.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how traffic mirroring operates:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Deploy a new version of the application and activate traffic mirroring.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The old version continues to respond to requests as usual but concurrently sends
    an asynchronous copy of the traffic to the new version.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The new version processes the mirrored traffic but refrains from responding
    to end users.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ops team monitors the behavior of the new version and reports any issues
    to the development team.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This process is depicted in the following figure:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.9 – Traffic mirroring](img/B19877_15_9.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_IMG
- en: Figure 15.9 – Traffic mirroring
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: Traffic mirroring revolutionizes the testing process by enabling teams to uncover
    issues that might remain hidden in a traditional staging environment. Additionally,
    you can utilize monitoring tools such as Prometheus and Grafana to record and
    monitor the outcomes of your testing efforts, enhancing the overall quality and
    reliability of your releases.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, without further ado, let’s configure traffic mirroring for our `ratings`
    service. Traffic mirroring is managed through the `VirtualService` resource, so
    let’s modify the `ratings` virtual service to the following:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In this configuration, we set up a single `destination` targeting `v1` with
    a `weight` value of `100`. Additionally, we defined a `mirror` section that directs
    traffic to `ratings:v2` with a `mirror_percent` value of 100\. This signifies
    that all traffic initially routed to `ratings:v1` is mirrored and simultaneously
    sent to `v2`.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s commit the changes and push them to the remote repository using the following
    commands:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Following the completion of the Argo CD synchronization process, we’ll proceed
    to refresh the page five times. Subsequently, we can inspect the logs of the `ratings:v1`
    service using the following command:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'With traffic mirroring active, it’s expected that the same set of logs observed
    in the `ratings:v1` service will also be mirrored in the `ratings:v2` service.
    To confirm this, we can list the logs for the `ratings:v2` service using the following
    command:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Indeed, the logs and timestamps match precisely, providing clear evidence of
    concurrent log entries in `ratings:v1` and `ratings:v2`. This observation effectively
    demonstrates the mirroring functionality in operation, showcasing how traffic
    is duplicated for real-time monitoring and analysis in both versions.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: Traffic mirroring is a highly effective method for identifying issues that often
    elude detection within traditional infrastructure setups. It is a potent approach
    for conducting operational acceptance testing of your software releases. This
    practice simplifies testing and safeguards against potential customer incidents
    and operational challenges.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other aspects of traffic management that Istio provides, but covering
    all of them is beyond the scope of this chapter. Please feel free to explore other
    aspects of it by visiting the Istio documentation: [https://istio.io/latest/docs/tasks/traffic-management/](https://istio.io/latest/docs/tasks/traffic-management/).'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: As we already know, Istio leverages envoy proxies as sidecar components alongside
    your microservice containers. Given that these proxies play a central role in
    directing and managing the traffic within your service mesh, they also collect
    valuable telemetry data.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: This telemetry data is subsequently transmitted to Prometheus, a monitoring
    and alerting tool, where it can be stored and effectively visualized. Tools such
    as Grafana are often employed in conjunction with Prometheus to provide insightful
    and accessible visualizations of this telemetry data, empowering you to monitor
    and manage your service mesh effectively. Therefore, we’ll go ahead and explore
    the observability portion of Istio in the next section.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Observing traffic and alerting with Istio
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Istio provides several tools to visualize traffic through our mesh through Istio
    add-ons. While **Prometheus** is the central telemetry data collection, storage,
    and query layer, **Grafana** and **Kiali** provide us with interactive graphical
    tools to interact with that data.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start this section by installing the observability add-ons using the
    following commands:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: As soon as we push the code, Argo CD should create a new `istio-system` namespace
    and install the add-ons. Once they have been installed, we can start by accessing
    the Kiali dashboard.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the Kiali dashboard
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Kiali** is a powerful observability and visualization tool for microservices
    and service mesh management. It offers real-time insights into the behavior of
    your service mesh, helping you monitor and troubleshoot issues efficiently.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: 'As the Kiali service is deployed on a cluster IP and hence not exposed externally,
    let’s do a port forward to access the Kiali dashboard using the following command:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Once the port forward session has started, click on the web preview icon of
    Google Cloud Shell, choose **Change port to 20001**, and click **preview**. You
    will see the following dashboard. This dashboard provides valuable insights into
    the applications running across the mesh:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.10 – Kiali dashboard](img/B19877_15_10.jpg)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
- en: Figure 15.10 – Kiali dashboard
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: 'To visualize service interactions, we can switch to the graph view by clicking
    on the `blog-app` namespace. We will see the following dashboard, which provides
    an accurate view of how traffic flows, the percentage of successful traffic, and
    other metrics:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.11 – Kiali service interaction graph](img/B19877_15_11.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
- en: Figure 15.11 – Kiali service interaction graph
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: While Kiali dashboards provide valuable insights regarding our mesh and help
    us observe service interactions in real time, they lack the capability of providing
    us with advanced monitoring and alerting capabilities. For that, we can use Grafana.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring and alerting with Grafana
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Grafana** is a leading open source platform for observability and monitoring,
    offering dynamic dashboards and robust alerting capabilities. It enables users
    to visualize data from diverse sources while setting up alerts for proactive issue
    detection.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'As we’ve already installed Grafana with the necessary add-ons, let’s access
    it by opening a port forward session. Ensure you terminate the existing Kiali
    port-forwarding session or use a different port. Run the following command to
    do so:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Once the port forwarding session has started, access the Grafana page like
    we did for Kiali, and go to **Home** > **Dashboards** > **Istio** > **Istio Service
    Dashboard**. We should see a dashboard similar to the following:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.12 – Istio service dashboard ](img/B19877_15_12.jpg)'
  id: totrans-390
  prefs: []
  type: TYPE_IMG
- en: Figure 15.12 – Istio service dashboard
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: This dashboard provides rich visualizations regarding some standard SLIs we
    may want to monitor, such as the request’s *success rate*, *duration*, *size*,
    *volume*, and *latency*. It helps you observe your mesh meticulously, and you
    can also build additional visualizations based on your requirements by using the
    **Prometheus Query Language** (**PromQL**), which is simple to learn and apply.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: However, monitoring and visualization must be complemented by alerting for complete
    reliability. So, let’s delve into that.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: Alerting with Grafana
  id: totrans-394
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To initiate the alerting process, it’s crucial to establish clear criteria.
    Given the limited volume at hand, simulating an accurate SLO breach can be challenging.
    For simplicity, our alerting criteria will trigger when traffic volume surpasses
    one transaction per second.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: 'The initial phase of this process involves crafting the query to retrieve the
    necessary metrics. We will employ the following query to achieve this objective:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The provided query determines the traffic rate for all transactions passing
    through the Istio ingress gateway to the `frontend` microservice.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step involves creating the alert rules with the query in place. To
    do this, navigate to **Home** > **Alerting** > **Alert rules**. Then, fill in
    the form, as illustrated in the following screenshot:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.13 – Defining alert rules](img/B19877_15_13.jpg)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
- en: Figure 15.13 – Defining alert rules
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: The alert rule is configured to monitor for violations at a 1-minute interval
    for 2 consecutive minutes. Once the alert rule has been established, triggering
    the alert is as simple as refreshing the Blog App home page about 15–20 times
    rapidly every 1 to 2 minutes. This action should activate the alert. To observe
    this process, navigate to **Home** > **Alerting** > **Alert rules**. You will
    notice the alert in a **Pending** state in the first minute. This means it has
    detected a violation in one of its checks and will wait for another violation
    within the 2-minute duration before triggering the alert.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: 'In a production environment, setting longer check intervals, typically around
    5 minutes, with alerting intervals of 15 minutes is typical. This approach helps
    avoid excessive alerting for self-resolving transient issues, ensuring the SRE
    team is not inundated with false alerts. The goal is to maintain a balance and
    prevent the team from treating every alert as a potential false alarm. The following
    screenshot shows a pending alert:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.14 – Alert pending](img/B19877_15_15.jpg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
- en: Figure 15.14 – Alert pending
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: 'After the 2-minute monitoring period, you should observe the alert being triggered,
    as depicted in the following screenshot. This indicates that the alert rule has
    successfully identified a sustained violation of the defined criteria and is now
    actively notifying relevant parties or systems:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.15 – Alert firing](img/B19877_15_16.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
- en: Figure 15.15 – Alert firing
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Since no specific alert channels have been configured in this context, the fired
    alerts will be visible within the Grafana dashboard only. It is highly advisable
    to set up a designated alert destination for sending alerts to your designated
    channels, using a tool such as **PagerDuty** to page on-call engineers or **Slack**
    notifications to alert your on-call team. Proper alert channels ensure that the
    right individuals or teams are promptly notified of critical issues, enabling
    rapid response and issue resolution.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-410
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we conclude this chapter and wrap up this book, our journey has taken us
    through an array of diverse concepts and functionalities. While we’ve covered
    substantial ground in this chapter, it’s essential to recognize that Istio is
    a rich and multifaceted technology, making it a challenge to encompass all its
    intricacies within a single chapter.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: This chapter marked our initiation into the world of service mesh, shedding
    light on its particular advantages in the context of microservices. Our exploration
    extended to various dimensions of Istio, beginning with installing Istio and extending
    our sample Blog App to utilize it using automatic sidecar injection. We then moved
    on to security, delving into the intricacies of securing ingress gateways with
    mTLS, enforcing strict mTLS among microservices, and harnessing authorization
    policies to manage traffic flows.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: Our journey then led us to traffic management, where we introduced essential
    concepts such as destination rules and virtual services. These enabled us to carry
    out canary rollouts and traffic mirroring, demonstrating the power of controlled
    deployments and real-time traffic analysis. Our voyage culminated in observability,
    where we harnessed the Kiali dashboard to visualize service interactions and ventured
    deep into advanced monitoring and alerting capabilities using Grafana.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: As we end this remarkable journey, I want to extend my heartfelt gratitude to
    you for choosing this book and accompanying me through its pages. I trust you’ve
    found every part of this book enjoyable and enlightening. I hope this book has
    equipped you with the skills necessary to excel in the ever-evolving realm of
    modern DevOps. I wish you the utmost success in all your present and future endeavors.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-415
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: Which approach would you use to install Istio among the available options using
    GitOps methodology?
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. Istioctl
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: B. Helm charts
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: C. Kustomize
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: D. Manifest bundle
  id: totrans-421
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What configuration is necessary for Istio to inject sidecars into your workloads
    automatically?
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A. Apply the `istio-injection-enabled: true` label to the namespace'
  id: totrans-423
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: B. No configuration is needed – Istio automatically injects sidecars into all
    pods
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: C. Modify the manifests so that they include the Istio sidecars and redeploy
    them
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Istio sidecars automatically communicate with each other using mTLS. (True/False)
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which resource enforces policies that dictate which services are permitted to
    communicate with each other?
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `AuthenticationPolicy`
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: B. `AuthorizationPolicy`
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: C. `PeerAuthentication`
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Which of the following resources would you use for canary rollouts? (Choose
    two)
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `VirtualService`
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: B. `IngressGateway`
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: C. `DestinationRule`
  id: totrans-434
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: D. `Egress Gateway`
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Why would you use traffic mirroring in production? (Choose three)
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. Real-time monitoring for production performance and behavior analysis
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: B. To route traffic to a new version to duplicate traffic to test the performance
    of your backend service
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: C. Safe testing of changes or updates without risking production disruptions
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: D. Streamlined troubleshooting and debugging for issue identification and resolution
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Which observability tool would you use to visualize real-time service interactions?
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. Prometheus
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: B. Grafana
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: C. Kiali
  id: totrans-444
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: D. Loki
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Answers
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the answers to this chapter’s questions:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
- en: B
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A and C
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A, C, and D
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: C
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Appendix: The Role of AI in DevOps'
  id: totrans-455
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The recent developments in **artificial intelligence** (**AI**) with the launch
    of generative AI using ChatGPT have taken the tech industry by storm. It has made
    many existing AI players pivot, and most companies are now looking at the best
    ways to use it in their products. Naturally, DevOps and the tooling surrounding
    it are no exceptions, and slowly, AI is gaining firm ground in this discipline,
    which historically relied upon more traditional automation methods. Before we
    delve into how AI changes DevOps, let’s first understand what AI is.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
- en: 'This appendix will cover the following topics:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
- en: What is AI?
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The role of AI in the DevOps infinity loop
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is AI?
  id: totrans-460
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AI emulates human intelligence in computing. You know how our computers do fantastic
    things, but they need to be told everything to do? Well, AI doesn’t work like
    that. It learns a ton from looking at lots of information, like how we learn from
    our experiences. That way, it can figure out patterns independently and make decisions
    without needing someone to tell it what to do every time. This makes AI intelligent
    because it can keep learning new things and get better at what it does.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
- en: Imagine if your computer could learn from everything it sees, just like you
    remember from everything around you. That’s how AI works—it’s a computer’s way
    of getting more intelligent. Instead of needing step-by-step instructions, AI
    learns from vast amounts of information. This makes it great at spotting patterns
    in data and deciding things on its own. And when it comes to DevOps, AI can be
    of great help! Let’s look at that next.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
- en: The role of AI in the DevOps infinity loop
  id: totrans-463
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we are already aware, instead of following a linear path of software delivery,
    DevOps practices generally follow an infinity loop, as shown in the following
    figure:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19877_Appendix_1.jpg)'
  id: totrans-465
  prefs: []
  type: TYPE_IMG
- en: Figure A.1 – DevOps infinity loop
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: DevOps practices heavily emphasize automation to ensure that this infinity loop
    operates smoothly, and we need tools. Most of these tools help build, deploy,
    and operate your software. You will typically start writing code in an **integrated
    development environment** (**IDE**) and then check code into a central source
    code repository such as Git. There will be a continuous integration pipeline that
    will build code from your Git repository and push it to an artifact repository.
    Your QA team might write automated tests to ensure the artifact is tested before
    it is deployed to higher environments using a continuous deployment pipeline.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
- en: Before the advent of AI, setting up all of the toolchains and operating them
    relied on traditional coding methods; that is, you would still write code to automate
    the processes, and the automation would behave more predictably and do what it
    was told to. However, with AI, things are changing.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: AI is transforming DevOps by automating tasks, predicting failures, and optimizing
    performance. In other words, by leveraging AI’s capabilities, DevOps teams can
    achieve greater efficiency, reduce errors, and deliver software faster and more
    reliably.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some key roles of AI in DevOps:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '**Automating Repetitive Tasks**: AI can automate repetitive and tedious tasks,
    such as code testing, deployment, and infrastructure provisioning. This frees
    up DevOps engineers to focus on more strategic and creative work, such as developing
    new features and improving application performance.'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Predicting and Preventing Failures**: AI can analyze vast amounts of data,
    including logs, performance metrics, and user feedback, to identify patterns and
    predict potential failures. This proactive approach allows DevOps teams to address
    issues before they impact users or cause major disruptions.'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimizing Resource Utilization**: AI can analyze resource usage data to
    optimize infrastructure allocation and prevent resource bottlenecks. This ensures
    that applications have the resources they need to perform optimally, minimizing
    downtime and improving overall system efficiency.'
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhancing Security**: AI can be used to detect and prevent security threats
    by analyzing network traffic, identifying anomalous behavior, and flagging suspicious
    activity. This helps DevOps teams maintain a robust security posture and protect
    sensitive data.'
  id: totrans-474
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improving Collaboration and Communication**: AI can facilitate collaboration
    and communication among DevOps teams by providing real-time insights, automating
    workflows, and enabling seamless communication channels. This breaks down silos
    and promotes a more cohesive DevOps culture.'
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at the areas of the DevOps infinity loop and see how AI impacts them.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: Code development
  id: totrans-477
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This area is where we see the most significant impact of generative AI and other
    AI technologies. AI revolutionizes code development by automating tasks such as
    code generation, bug detection, optimization, and testing. Through autocomplete
    suggestions, bug detection algorithms, and predictive analytics, AI accelerates
    coding, enhances code quality, and ensures better performance while aiding in
    documentation and code security analysis. Its role spans from assisting in writing
    code to predicting issues, ultimately streamlining the software development life
    cycle, and empowering developers to create more efficient, reliable, and secure
    applications.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
- en: Many tools employ AI in code development, and one of the most popular tools
    in this area is **GitHub Copilot**.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Copilot is a collaborative effort between **GitHub** and **OpenAI**,
    introducing a code completion feature that utilizes OpenAI’s **Codex**. Codex,
    trained on vast code repositories from GitHub, quickly generates code based on
    the current file’s content and cursor location. Compatible with popular code editors
    such as **Visual Studio Code**, **Visual Studio**, **Neovim**, and **JetBrains
    IDEs**, Copilot supports languages such as **Python**, **JavaScript**, **TypeScript**,
    **Ruby**, and **Go**.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
- en: Praised by GitHub and users alike, Copilot generates entire code lines, functions,
    tests, and documentation. Its functionality relied on the context provided and
    the extensive code contributions by developers on GitHub, regardless of their
    software license. Dubbed the world’s first AI pair programmer by **Microsoft**,
    it is a paid tool and charges a subscription fee of $10 per month or $100 per
    year per user after a 60-day trial period.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
- en: With Copilot, you can start by writing comments on what you intend to do, and
    it will generate the required code for you. This speeds up development many times,
    and most of the time, you just need to review and test your code to see whether
    it does what you intend it to do. A great power indeed! It can optimize existing
    code and provide feedback by generating code snippets. It can also scan your code
    for security vulnerabilities and suggest alternative approaches.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t want to pay that $10, you can also look at free alternatives such
    as **Tabnine**, **Captain Stack**, **GPT-Code Clippy**, **Second Mate**, and **Intellicode**.
    Paid alternatives include Amazon’s **Code Whisperer** and Google’s **ML-enhanced**
    **code completion**.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
- en: AI tools not only help enhance the development workflow but also help in software
    testing and quality assurance. Let’s look at that next.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: Software testing and quality assurance
  id: totrans-485
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Traditionally, software testing has taken more of a manual approach because
    most developers don’t want software testing as a full-time profession. Though
    automation testing has gained ground recently, the knowledge gap has hindered
    this process in most organizations. Therefore, AI would most impact the testing
    function as it bridges the human-machine gap.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: 'AI-integrated testing techniques revolutionize every stage of the **software
    testing life cycle** (**STLC**); some of them are as follows:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
- en: '**Test script generation**: Traditionally, creating test scripts was time-consuming,
    involving deep system understanding. AI and **machine learning** (**ML**) now
    expedite this process by analyzing requirements, existing test cases, and application
    behavior to craft more optimized test scripts, offering ready-to-use templates
    with preconfigured code snippets and comprehensive comments, and translating plain
    language instructions into complete test scripts using **natural language processing**
    (**NLP**) techniques.'
  id: totrans-488
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test data generation**: AI-equipped testing tools provide detailed and ample
    test data for comprehensive coverage. They achieve this by generating synthetic
    data from existing sets for specific test objectives, transforming data to create
    diverse testing scenarios, refining existing data for higher precision and relevance,
    and scanning large code bases for context comprehension.'
  id: totrans-489
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intelligent test execution**: AI alleviates test execution challenges by
    automatically categorizing and organizing test cases, efficiently selecting tests
    for various devices, operating systems, and configurations, and smartly executing
    regression tests for critical functionalities.'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Intelligent test maintenance**: AI/ML minimizes test maintenance challenges
    by implementing self-healing mechanisms to handle broken selectors and analyzing
    UI and code change relationships to identify affected areas.'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Root cause analysis**: AI aids in understanding and rectifying issues by
    analyzing logs, performance metrics, and anomalies to pinpoint impact areas, tracing
    issues back to affected user stories and feature requirements, and utilizing knowledge
    repositories for comprehensive root cause analysis.'
  id: totrans-492
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Multiple tools in the market help you achieve all of it; some of the most popular
    ones are the following:'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: '**Katalon platform**: A comprehensive quality management tool that simplifies
    test creation, execution, and maintenance across various applications and environments.
    It boasts AI features such as **TrueTest**, **StudioAssist**, **self-healing**,
    **visual testing**, and **AI-powered test** **failure analysis**.'
  id: totrans-494
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TestCraft**: Built on **Selenium**, TestCraft offers both manual and automated
    testing capabilities with a user-friendly interface and AI-driven element identification,
    allowing tests to run across multiple browsers in parallel.'
  id: totrans-495
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Applitools**: Known for its AI-based visual testing, Applitools efficiently
    identifies visual bugs, monitors app visual aspects, and provides accurate visual
    test analytics using AI and ML.'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Function**: Utilizes AI/ML for functional, performance, and load testing
    with simplicity, allowing test creation through plain English input, self-healing,
    test analytics, and multi-browser support.'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mabl**: An AI-powered tool offering low-code testing, intuitive intelligence,
    data-driven capabilities, end-to-end testing, and valuable insights generation,
    promoting team collaboration.'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AccelQ**: Automates test designs, plans, and execution across the UI, mobile,
    API, and PC software, featuring **automated test generation**, **predictive analysis**,
    and comprehensive test management.'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testim**: Uses ML to expedite test creation and maintenance, allowing for
    quick end-to-end test creation, smart locators for resilient tests, and a blend
    of recording functions and coding for robust test creation.'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we’ve already seen the benefits of AI in development and testing, let’s move
    on to software delivery.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration and delivery
  id: totrans-502
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In **continuous integration** (**CI**) and **continuous delivery** (**CD**),
    AI brings a transformative edge by optimizing and automating various stages of
    the software development pipeline. AI augments CI by automating code analysis,
    identifying patterns, and predicting potential integration issues. It streamlines
    the process by analyzing code changes, suggesting appropriate test cases, and
    facilitating faster integration cycles. Through ML, AI can understand historical
    data from past builds, recognizing patterns that lead to failures, thereby aiding
    in more efficient debugging and code quality improvement.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
- en: In CD, AI optimizes deployment pipelines by automating release strategies, predicting
    performance bottlenecks, and suggesting optimizations for smoother delivery. It
    analyzes deployment patterns, user feedback, and system performance data to recommend
    the most efficient delivery routes. Additionally, AI-driven CD tools enhance risk
    prediction, allowing teams to foresee potential deployment failures and make informed
    decisions to mitigate risks before they impact production environments. Ultimately,
    AI’s role in CI/CD accelerates the development cycle, improves software quality,
    and enhances the reliability of software releases.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some AI-powered tools used in software release and delivery:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
- en: '**Harness**: Harness utilizes AI to automate software delivery processes, including
    continuous integration, deployment, and verification. It employs ML to analyze
    patterns from deployment pipelines, predict potential issues, and optimize release
    strategies for better efficiency and reliability.'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitClear**: GitClear employs AI algorithms to analyze code repositories and
    provides insights into developer productivity, code contributions, and team performance.
    It helps understand code base changes, identify bottlenecks, and optimize development
    workflows.'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jenkins**: Thanks to its plugin-based architecture, Jenkins, a widely used
    automation server, employs a lot of AI plugins and extensions to enhance its capabilities
    in CI/CD. AI-powered plugins help automate tasks, optimize build times, and predict
    build failures by analyzing historical data.'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CircleCI**: CircleCI integrates AI and ML to optimize CI/CD workflows. It
    analyzes build logs, identifies patterns leading to failures, and provides recommendations
    to improve build performance and reliability.'
  id: totrans-509
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These AI-powered tools improve software release and delivery processes’ speed,
    quality, and reliability by automating tasks, optimizing workflows, predicting
    issues, and providing valuable insights for better decision-making.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at the next stage in the process—software operations.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: Software operations
  id: totrans-512
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AI is pivotal in modern software operations, revolutionizing how systems are
    monitored, managed, and optimized. By leveraging ML algorithms, AI helps automate
    routine tasks such as monitoring system performance, analyzing logs, and identifying
    anomalies in real time. It enables predictive maintenance by detecting patterns
    that precede system failures, allowing for proactive intervention and preventing
    potential downtime. Additionally, AI-powered tools streamline incident management
    by correlating alerts, prioritizing critical issues, and providing actionable
    insights, enhancing the overall resilience and reliability of software operations.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, AI augments decision-making processes by analyzing vast amounts of
    data to identify trends, forecast resource requirements, and optimize infrastructure
    utilization. AI adapts to changing environments through its continuous learning
    capabilities, enabling software operations teams to stay ahead of evolving challenges
    and complexities. Overall, AI’s role in software operations ensures greater efficiency,
    improved system performance, and proactive problem resolution, contributing significantly
    to the seamless functioning of IT infrastructures.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some AI-powered tools used in software operations:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynatrace**: Dynatrace utilizes AI for application performance monitoring
    and management. It employs AI algorithms to analyze vast amounts of data, providing
    real-time insights into application performance, identifying bottlenecks, and
    predicting potential issues before they impact end users.'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PagerDuty**: PagerDuty integrates AI-driven incident management, alerting,
    and on-call scheduling. It uses ML to correlate events and alerts, reducing noise
    and providing intelligent notifications for critical incidents.'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Opsani**: Opsani leverages AI for autonomous optimization of cloud applications.
    It analyzes application performance, dynamically adjusts configurations, and optimizes
    resources to maximize performance and cost-efficiency.'
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Moogsoft**: Moogsoft offers AI-driven IT operations and AIOps platforms.
    It uses ML to detect anomalies, correlate events, and automate incident resolution,
    helping teams proactively manage and resolve issues in complex IT environments.'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sumo Logic**: Sumo Logic employs AI for log management, monitoring, and analytics.
    It uses ML to identify patterns, anomalies, and security threats within logs and
    operational data, enabling proactive troubleshooting and security incident detection.'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**New Relic**: New Relic utilizes AI for application and infrastructure monitoring.
    Its AI-powered platform helps identify performance issues, predict system behavior,
    and optimize resource utilization for better application performance.'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LogicMonitor**: LogicMonitor uses AI for infrastructure monitoring and observability.
    It analyzes metrics and performance data to provide insights into system health,
    predict potential issues, and optimize resource allocation in complex environments.'
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpsRamp**: OpsRamp employs AI for IT operations management, offering capabilities
    for monitoring, incident management, and automation. It uses ML to detect anomalies,
    automate routine tasks, and optimize workflows for better operational efficiency.'
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These AI-powered tools assist in automating tasks, predicting and preventing
    issues, optimizing resource allocation, and enhancing overall system reliability
    in software operations.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
- en: The integration of AI into DevOps practices is still in its early stages, but
    its potential impact is significant. By automating tasks, optimizing processes,
    and enhancing collaboration, AI can revolutionize the way software is developed,
    deployed, and managed. As AI technology continues to develop, we can expect to
    see even more ways in which AI is used to improve the DevOps process.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-526
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AI revolutionizes DevOps practices by infusing intelligence into every development
    and operations cycle stage. It streamlines processes, enhances efficiency, and
    ensures smoother collaboration between development and operations teams. AI automates
    routine tasks, predicts potential bottlenecks, and optimizes workflows, transforming
    how software is built, tested, deployed, and monitored. From automating code analysis
    to predicting system failures, AI empowers DevOps by enabling quicker decision-making,
    reducing errors, and fostering a more agile and responsive software development
    environment.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
- en: In essence, AI acts as a silent partner, continuously learning from data, suggesting
    improvements, and helping DevOps teams foresee and address issues before they
    impact the software’s performance. It’s the catalyst that drives agility and innovation,
    allowing DevOps to evolve from a mere collaboration between teams to a symbiotic
    relationship where AI enhances the capabilities of both development and operations,
    paving the way for more efficient and reliable software delivery.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
