<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer018">
<h1 class="chapter-number" id="_idParaDest-84"><a id="_idTextAnchor083"/>5</h1>
<h1 id="_idParaDest-85"><a id="_idTextAnchor084"/>Managing Services in Linux</h1>
<p>In this chapter, we’re going to explain services (programs running in the background as daemons) in more depth. We’re going to explain <strong class="source-inline">init</strong> scripts and <strong class="source-inline">systemd</strong> units. We are also going to cover Alpine Linux <strong class="source-inline">rc</strong> commands that <span class="No-Break">manage services.</span></p>
<p>The chapter covers the <span class="No-Break">following topics:</span></p>
<ul>
<li>Understanding Linux services <span class="No-Break">in detail</span></li>
<li>A few words about Upstart, <span class="No-Break">an alternative</span></li>
</ul>
<h1 id="_idParaDest-86"><a id="_idTextAnchor085"/>Technical requirements</h1>
<p>For this chapter, you will need a Linux system at hand where you can execute privileged commands, either using <strong class="source-inline">sudo</strong> or jumping straight to the root account (although we particularly recommend the first one). You’ll also need a Linux text editor of your choice that will produce pure text files. If you are going to edit on a Windows system, use a text editor that enables you to save Unix files. We recommend editing in the command line with one of your favorite command-line text editors: <strong class="source-inline">vim</strong>, <strong class="source-inline">emacs</strong>, <strong class="source-inline">joe</strong>, <strong class="source-inline">nano</strong>, or whatever <span class="No-Break">suits you.</span></p>
<h1 id="_idParaDest-87"><a id="_idTextAnchor086"/>Understanding Linux services in detail</h1>
<p><a id="_idTextAnchor087"/>Unless you <a id="_idIndexMarker312"/>are running some kind of low-level embedded device on your desktop—and we strongly doubt it—your operating system manages a multitude of tasks to create a comfortable and productive environment for you. Be it Mac OS X, Linux, Windows, or FreeBSD, they all run a multitude of background programs that together provide a useful system. The same goes for server flavors of those operating systems. A background program or background process (in Unix and Linux called, fluffily, a daemon) means a program that is not attached to any input (keyboard, mouse, etc.) or output (monitor, terminal, etc.). This way, they can start working even when no one is logged in to the system and keep working when the user logs out. They can also run under the privileges of a user who can never log in to the system, making their execution <span class="No-Break">much safer.</span></p>
<p>The number of services running on your Linux system will, in large part, depend on the distribution and, in even larger part, on the <span class="No-Break">system’s purpose.</span><a id="_idTextAnchor088"/></p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor089"/>The history of Linux service management</h2>
<p>As you can<a id="_idIndexMarker313"/> probably imagine, the task of managing the system services—the programs required to run so that your computer is usable to you—is not a trivial one. The software that runs them must be stable and robust. This, and the fact that the system is expected to start rarely, especially on servers, made the Linux-adopted solution survive for decades. The increasing need to start services in parallel (through the emergence and widespread use of many threaded CPUs) and more intelligently gave way to several implementations of the new <strong class="source-inline">init</strong> system, which we will <span class="No-Break">cover next<a id="_idTextAnchor090"/>.</span></p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor091"/>systemd</h2>
<p><strong class="source-inline">systemd</strong> is a <a id="_idIndexMarker314"/>service manager for Linux that is able to manage services<a id="_idIndexMarker315"/> that start with the operating system. It replaces traditional <strong class="source-inline">init</strong> scripts. It is responsible for starting and stopping system services, managing system state, and logging system events. It has become the default <strong class="source-inline">init</strong> system for many popular Linux distributions, including CentOS, Fedora Linux, <strong class="bold">Red Hat Enterprise Linux</strong> (<strong class="bold">RHEL</strong>), and<a id="_idIndexMarker316"/> <span class="No-Break">Ubuntu Linux.</span></p>
<p>This service manager is responsible for controlling the initialization of the system itself (services required for the Linux OS), starting and stopping system services, and managing system resources. It provides another way of managing services and other system components, and it allows system administrators to configure and customize the behavior of their <a id="_idIndexMarker317"/>systems in a more standardized way than with <strong class="bold">System V</strong> (<span class="No-Break"><strong class="bold">SysV</strong></span><span class="No-Break">) </span><span class="No-Break"><strong class="source-inline">init</strong></span><span class="No-Break">.</span></p>
<p>One of the key features of <strong class="source-inline">systemd</strong> is its ability to start services in parallel, which can significantly reduce the boot time of a system. It also includes a number of tools for managing and monitoring <span class="No-Break">system services.</span></p>
<p>Another thing <strong class="source-inline">systemd</strong> is praised for is the uniformity of service configurations it has finally brought to the Linux world. In every Linux distribution, the <strong class="source-inline">systemd</strong> configuration files are delivered to the same path; they look the same. There are, however, still some differences depending on the path binaries are being installed to. <strong class="source-inline">systemd</strong> is also better at knowing whether a process is running, making it more difficult to end up in a situation where we can’t start a process because of <span class="No-Break">stale files.</span></p>
<p>One of the major <a id="_idIndexMarker318"/>advantages of <strong class="source-inline">systemd</strong> is its awareness of dependencies. The service (running program under <strong class="source-inline">systemd</strong> control) configuration contains information about all the other services it depends on and can also point to services that depend on it. What’s more, the service can inform <strong class="source-inline">systemd</strong> about which targets it requires to run: if your service needs the network to be up and running, you can put this information into the configuration, and <strong class="source-inline">systemd</strong> will ensure your daemon will be brought up only after the network is <span class="No-Break">properly configured.</span></p>
<p>The following is a list of some of the tools and utilities that are provided as part <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">systemd</strong></span><span class="No-Break">:</span></p>
<ul>
<li><strong class="source-inline">systemd</strong>: This is<a id="_idIndexMarker319"/> the main system and service manager. It is the main program that controls the initialization and management of services and other <span class="No-Break">system components.</span></li>
<li><strong class="source-inline">systemctl</strong>: This is <a id="_idIndexMarker320"/>the command-line utility for managing system services and other system components. It can be used to start, stop, restart, enable, and disable services, as well as to view the status of services and other <span class="No-Break">system components.</span></li>
<li><strong class="source-inline">journalctl</strong>: This is<a id="_idIndexMarker321"/> used for viewing and manipulating the system log, which is managed by <strong class="source-inline">systemd</strong>. It can be used to view log messages, filter log messages based on various criteria, and export log data to <span class="No-Break">a file.</span></li>
<li><strong class="source-inline">coredumpctl</strong>: This is a<a id="_idIndexMarker322"/> utility, as the name suggests, that helps retrieve core dumps from <span class="No-Break"><strong class="source-inline">systemd</strong></span><span class="No-Break">’s journal.</span></li>
<li><strong class="source-inline">systemd-analyze</strong>: This<a id="_idIndexMarker323"/> can be used for analyzing the boot performance of a system. It measures the time it takes for a system to boot, as well as the time it takes to identify potential bottlenecks and <span class="No-Break">performance issues.</span></li>
<li><strong class="source-inline">systemd-cgls</strong>: This is a command-line utility for viewing the control group hierarchy<a id="_idIndexMarker324"/> on a system. <strong class="bold">Control groups</strong>, or <strong class="bold">cgroups</strong>, are <a id="_idIndexMarker325"/>used by <strong class="source-inline">systemd</strong> to manage system resources and to isolate processes from <span class="No-Break">one another.</span></li>
<li><strong class="source-inline">systemd-delta</strong>: This<a id="_idIndexMarker326"/> is a command-line utility for analyzing the<a id="_idIndexMarker327"/> differences between the default configuration files provided by <strong class="source-inline">systemd</strong> and any local modifications made to <span class="No-Break">these files.</span></li>
<li><strong class="source-inline">systemd-detect-virt</strong>: This<a id="_idIndexMarker328"/> is a command-line utility for detecting the virtualization environment in which a system is running. It can be used to determine whether a system is running in a <strong class="bold">virtual machine</strong> (<strong class="bold">VM</strong>), a container, or on <span class="No-Break">bare metal.</span></li>
<li><strong class="source-inline">systemd-inhibit</strong>: This is a<a id="_idIndexMarker329"/> command-line utility for preventing certain system actions, such as suspending or shutting down the system, from <span class="No-Break">being performed.</span></li>
<li><strong class="source-inline">systemd-nspawn</strong>: This is<a id="_idIndexMarker330"/> a command-line utility for running processes in lightweight containers. It can be used to create and manage containers, as well as to execute processes <span class="No-Break">within containers.</span></li>
</ul>
<p>This is just a list of more common tools and utilities that are provided as part of <strong class="source-inline">systemd</strong>. There are many more, but we will not cover <span class="No-Break">them here.</span></p>
<h3>Targets</h3>
<p>In <strong class="source-inline">systemd</strong>, a <strong class="bold">target</strong> is a <a id="_idIndexMarker331"/>specific state that the system can be in, and it is represented by a symbolic name. Targets are used to define the high-level behavior of the system, and they are typically used to group together a set of related services and other <span class="No-Break">system components.</span></p>
<p>For example, <strong class="source-inline">multi-user.target</strong> is a target that represents a system that is ready to provide multi-user access, with networking and other services enabled; <strong class="source-inline">graphical.target</strong> is a target that represents a system that is ready to display a graphical login screen, with a graphical desktop environment and related <span class="No-Break">services enabled.</span></p>
<p>Targets are <a id="_idIndexMarker332"/>typically defined in unit files, which are configuration files that describe the properties and behavior of system components. When a target is activated, <strong class="source-inline">systemd</strong> will start all of the services and other system components that are associated with <span class="No-Break">that target.</span></p>
<p><strong class="source-inline">systemd</strong> includes a number of predefined targets that cover a wide range of common system states, and administrators can also define custom targets to suit the specific needs of their systems. Targets can be activated using the <strong class="source-inline">systemctl</strong> command, or by modifying the default target that is set when the <span class="No-Break">system boots.</span></p>
<p>Here are some<a id="_idIndexMarker333"/> examples of predefined <span class="No-Break"><strong class="source-inline">systemd</strong></span><span class="No-Break"> targets:</span></p>
<ul>
<li><strong class="source-inline">poweroff.target</strong>: Represents a system that is shutting down or <span class="No-Break">powered off</span></li>
<li><strong class="source-inline">rescue.target</strong>: Represents a system that is running in rescue mode, with minimal <span class="No-Break">services enabled</span></li>
<li><strong class="source-inline">multi-user.target</strong>: Represents a system that is ready to provide multi-user access, with networking and other <span class="No-Break">services enabled</span></li>
<li><strong class="source-inline">graphical.target</strong>: Represents a system that is ready to display a graphical login screen, with a graphical desktop environment and related <span class="No-Break">services enabled</span></li>
<li><strong class="source-inline">reboot.target</strong>: Represents a system that <span class="No-Break">is rebooting</span></li>
<li><strong class="source-inline">emergency.target</strong>: Represents a system that is running in emergency mode, with only the most essential <span class="No-Break">services enabled</span></li>
</ul>
<p>Here is an example of a <strong class="source-inline">systemd</strong> unit file that defines a <span class="No-Break">custom target:</span></p>
<pre class="source-code">
[Unit]
Description=Unit File With Custom Target
[Install]
WantedBy=multi-user.target</pre>
<p>This <a id="_idIndexMarker334"/>unit file defines a target named <strong class="source-inline">Custom Target</strong> that is meant to be activated as part of <strong class="source-inline">multi-user.target</strong>. The <strong class="source-inline">WantedBy</strong> directive specifies that the target should be activated when <strong class="source-inline">multi-user.target</strong> <span class="No-Break">is activated.</span></p>
<p>Here is another example of a <strong class="source-inline">systemd</strong> unit file named <strong class="source-inline">custom.target</strong> that defines a <span class="No-Break">custom target:</span></p>
<pre class="source-code">
[Unit]
Description=My simple service
[Install]
WantedBy=multi-user.target</pre>
<p>The following is a unit file that is using our <span class="No-Break"><strong class="source-inline">custom.target</strong></span><span class="No-Break"> target:</span></p>
<pre class="source-code">
[Service]
ExecStart=/usr/local/bin/my-simple-service
Type=simple
[Install]
WantedBy=custom.target</pre>
<p>This unit file defines a target named <strong class="source-inline">Unit File With Custom Target</strong> and a service named <strong class="source-inline">My simple service</strong>. The <strong class="source-inline">ExecStart</strong> directive specifies the command that should be used to start the service, and the <strong class="source-inline">Type</strong> directive specifies the type of service. The <strong class="source-inline">WantedBy</strong> directive in the <strong class="source-inline">[Install]</strong> section of the service unit specifies that the service should be activated when <strong class="source-inline">custom.target</strong> <span class="No-Break">is activated.</span></p>
<p>Now, as we have touched upon unit files a bit, let’s dig into them deeper and see what <a id="_idTextAnchor092"/>is possible <span class="No-Break">with them.</span></p>
<h3>Unit files</h3>
<p>Unit files<a id="_idIndexMarker335"/> are usually stored in the <strong class="source-inline">/lib/systemd/</strong> system directory of Linux OS filesystems. No files in this directory should be altered in any way since they will be replaced by files contained in packages when a service is upgraded using a <span class="No-Break">packet manager.</span></p>
<p>Instead, to<a id="_idIndexMarker336"/> modify a unit file of a specific service, create your customized unit file inside the <strong class="source-inline">/etc/systemd/system</strong> directory. Files in this <strong class="source-inline">etc</strong> directory will take precedence over the <span class="No-Break">default location.</span></p>
<p><strong class="source-inline">systemd</strong> is able to provide unit activation using <span class="No-Break">the following:</span></p>
<ul>
<li><strong class="bold">Dependency</strong>: It will <a id="_idIndexMarker337"/>start a unit simply by using a pre-built dependency tree handled by <strong class="source-inline">systemd</strong>. At its simplest, you will need to add a dependency with <strong class="source-inline">multi-user.target</strong> or with <strong class="source-inline">network.target</strong> if your service is <span class="No-Break">using networking.</span></li>
<li><strong class="bold">Drop-in unit files</strong>: You<a id="_idIndexMarker338"/> can easily extend the default unit file by providing a snippet that will override a part of the default unit file (for example, change daemon execution options). Those are the files you’d place inside the <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">etc/systemd/system</strong></span><span class="No-Break"> directory.</span></li>
<li><strong class="bold">Templates</strong>: You <a id="_idIndexMarker339"/>can also define template unit files. Those special units can be used to create multiple instances of the same <span class="No-Break">general unit.</span></li>
<li><strong class="bold">Security features</strong>: You<a id="_idIndexMarker340"/> can specify read-only access or deny access to a part of the filesystem, assign <strong class="source-inline">private/tmp</strong> or network access, and limit <span class="No-Break">kernel capabilities.</span></li>
<li><strong class="bold">Path</strong>: You<a id="_idIndexMarker341"/> can start a unit based on activity on or the availability of a file or directory in <span class="No-Break">the filesystem.</span></li>
<li><strong class="bold">Socket</strong>: This a <a id="_idIndexMarker342"/>special type of file in the Linux operating system that enables communication between two processes. Using this feature, you can delay starting a service until the associated socket is accessed. You can also create a unit file that simply creates a socket early in a boot process and a separate unit file that uses <span class="No-Break">this socket.</span></li>
<li><strong class="bold">Bus</strong>: You<a id="_idIndexMarker343"/> can activate a unit by using the bus interface provided by D-Bus. D-Bus<a id="_idIndexMarker344"/> is simply a message bus used for <strong class="bold">inter-process communication</strong> (<strong class="bold">IPC</strong>), most commonly used in GUIs such as GNOME <span class="No-Break">or KDE.</span></li>
<li><strong class="bold">Device</strong>: You can<a id="_idIndexMarker345"/> also start a unit at the availability of hardware (the <strong class="source-inline">dev</strong> file, located in the <strong class="source-inline">/dev</strong> directory). This will leverage a mechanism known as <strong class="source-inline">udev</strong>, which is a Linux subsystem that supplies <span class="No-Break">device events.</span></li>
</ul>
<p>Once you’ve<a id="_idIndexMarker346"/> started a service, you will probably want to check whether it’s up and healthy by taking a look at the log files. This<a id="_idTextAnchor093"/> job is taken care of <span class="No-Break">by </span><span class="No-Break"><strong class="source-inline">journald</strong></span><span class="No-Break">.</span></p>
<h3>Logging</h3>
<p>Every service <a id="_idIndexMarker347"/>managed by <strong class="source-inline">systemd</strong> sends its logs to <strong class="source-inline">journald</strong>—a special part of <strong class="source-inline">systemd</strong>. There is a special command-line tool for managing those logs: <strong class="source-inline">journalctl</strong>. In its simplest form, running a <strong class="source-inline">journalctl</strong> command will simply output all system logs, with the newest ones being at the top. While the format of the logs is similar to <strong class="source-inline">syslog</strong>—the traditional tool for gathering logs on Linux—<strong class="source-inline">journald</strong> captures more data. It collects data from the boot process, kernel logs, <span class="No-Break">and more.</span></p>
<p>The boot logs are transient by default. This means they are not saved between system reboots. There is, however, a possibility to record them permanently. There are two ways to do it, <span class="No-Break">as follows:</span></p>
<ul>
<li>Create a special directory. When <strong class="source-inline">journald</strong> detects it during system boot, it will save logs there: <strong class="source-inline">sudo mkdir -</strong><span class="No-Break"><strong class="source-inline">p /var/log/journal</strong></span><span class="No-Break">.</span></li>
<li>Edit the <strong class="source-inline">journald</strong> configuration file and enable persistent boot logs. Open the <strong class="source-inline">/etc/systemd/journald.conf</strong> file with your favorite editor and, in the <strong class="source-inline">[Journal]</strong> section, edit the <strong class="source-inline">Storage</strong> option to look <span class="No-Break">like this:</span><pre class="source-code">
[Journal]</pre><pre class="source-code">
Storage=persistent</pre></li>
</ul>
<p><strong class="source-inline">journald</strong> is capable of filtering logs by service by the use of the <strong class="source-inline">-u service.name</strong> option—that is, <strong class="source-inline">journalctl -u httpd.service</strong> will only print logs from the <strong class="source-inline">httpd</strong> daemon. There’s a possibility of printing logs from a given timeframe, printing from more than one service, searching logs by <strong class="bold">process ID</strong> (<strong class="bold">PID</strong>), and more. As usual, we <a id="_idIndexMarker348"/>recommend referring to the man page—use the <strong class="source-inline">man journalctl</strong> command <span class="No-Break">for this.</span></p>
<p>In this section, we have covered the most often used services software in the Linux world—<strong class="source-inline">systemd</strong>. In the next section, we are going to look at OpenRC—a system used in Alpine Linux, the Linux distribution of<a id="_idTextAnchor094"/> choice for containers in <span class="No-Break">the cloud.</span></p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor095"/>OpenRC</h2>
<p>Alpine Linux<a id="_idIndexMarker349"/> uses another system for managing system services called <strong class="bold">OpenRC</strong>. OpenRC <a id="_idIndexMarker350"/>is a dependency-based <strong class="source-inline">init</strong> system originally developed for the use of Gentoo Linux. It is designed to be lightweight, simple, and easy to maintain. OpenRC uses plain text configuration files, which makes it easy to customize and configure. It is also easy to extend with custom scripts and programs. OpenRC is flexible and can be used on a wide variety of systems, from embedded devices <span class="No-Break">to servers.</span></p>
<p>The following<a id="_idIndexMarker351"/> are examples of how OpenRC is used in <span class="No-Break">Alpine Linux:</span></p>
<ul>
<li><strong class="bold">Starting and stopping system services</strong>: OpenRC is used to manage system services such as networking, <strong class="source-inline">ssh</strong>, and <strong class="source-inline">cron</strong>. You can use the <strong class="source-inline">rc-service</strong> command to start, stop, or check the status of a service. For example, to start the <strong class="source-inline">ssh</strong> service, you can run <strong class="source-inline">rc-service </strong><span class="No-Break"><strong class="source-inline">ssh start</strong></span><span class="No-Break">.</span></li>
<li><strong class="bold">Customizing system initialization and shutdown</strong>: OpenRC allows you to write custom scripts to customize the behavior of your system during startup or shutdown. These scripts are executed at specific points in the boot process and can be used to set up custom configurations or perform <span class="No-Break">other tasks.</span></li>
<li><strong class="bold">Managing system runlevels</strong>: OpenRC uses <strong class="bold">runlevels</strong> to define the system’s behavior. You can use the <strong class="source-inline">rc-update</strong> command to add or remove services from different runlevels. For example, to make a service start at boot, you can run <strong class="source-inline">rc-update add &lt;</strong><span class="No-Break"><strong class="source-inline">service&gt; boot</strong></span><span class="No-Break">.</span></li>
</ul>
<p>To start a service, use <a id="_idIndexMarker352"/>the following  <span class="No-Break"><strong class="source-inline">rc-service</strong></span><span class="No-Break"> command:</span></p>
<pre class="console">
admin@myhome:~$ rc-service &lt;service&gt; start</pre>
<p>To stop a service, use the following <span class="No-Break"><strong class="source-inline">rc-service</strong></span><span class="No-Break"> command:</span></p>
<pre class="console">
admin@myhome:~$ rc-service &lt;service&gt; stop</pre>
<p>To check the status of a service, use the following <span class="No-Break"><strong class="source-inline">rc-service</strong></span><span class="No-Break"> command:</span></p>
<pre class="console">
admin@myhome:~$ rc-service &lt;service&gt; status</pre>
<p>To enable a service to start at boot, use the following <span class="No-Break"><strong class="source-inline">rc-update</strong></span><span class="No-Break"> command:</span></p>
<pre class="console">
admin@myhome:~$ rc-update add &lt;service&gt; default</pre>
<p>To disable a service from starting at boot, use the following <span class="No-Break"><strong class="source-inline">rc-update</strong></span><span class="No-Break"> command:</span></p>
<pre class="console">
admin@myhome:~$ rc-update del &lt;service&gt; default</pre>
<p>Default in<a id="_idIndexMarker353"/> this context means a default runlevel of the Alpine Linux system. Runlevels in general are used to define the system’s behavior. There are several predefined runlevels common to most Linux distributions, each of which corresponds to a specific set of services that are started <span class="No-Break">or stopped.</span></p>
<p>In Alpine Linux, these are the<a id="_idIndexMarker354"/> <span class="No-Break">default runlevels:</span></p>
<ul>
<li><strong class="source-inline">default</strong>: This is the default runlevel and is used when the system is booted normally. Services that are started in this runlevel include networking, SSH, and <span class="No-Break">system logging.</span></li>
<li><strong class="source-inline">boot</strong>: This runlevel is used when the system is booting. Services that are started in this runlevel include the system console, the system clock, and <span class="No-Break">the kernel.</span></li>
<li><strong class="source-inline">single</strong>: This runlevel is used when the system is booted into single-user mode. Only a minimal set of services is started in this runlevel, including the system console and the <span class="No-Break">system clock.</span></li>
<li><strong class="source-inline">shutdown</strong>: This runlevel is used when the system is shutting down. Services that are stopped in this runlevel include networking, SSH, and <span class="No-Break">system logging.</span></li>
</ul>
<p>OpenRC uses a very similar way of defining service actions to SysV <strong class="source-inline">init</strong> we mentioned earlier in this <a id="_idIndexMarker355"/>chapter. Commands such as <strong class="source-inline">start</strong>, <strong class="source-inline">stop</strong>, <strong class="source-inline">restart</strong>, and <strong class="source-inline">status</strong> are defined in a Bash script. Here is a basic example of <span class="No-Break">a service:</span></p>
<pre class="source-code">
# Name of the service
name="exampleservice"
# Description of the service
description="This is my example service"
# Start command
start() {
  # Add your start commands
}
# Stop command
stop() {
  # Add your stop command here
}
# Restart command
restart() {
  stop
  start
}</pre>
<p>To create a <a id="_idIndexMarker356"/>new service, you can copy this file to a new file and modify the <strong class="source-inline">name</strong>, <strong class="source-inline">description</strong>, <strong class="source-inline">start</strong>, <strong class="source-inline">stop</strong>, and <strong class="source-inline">restart</strong> functions as needed. The <strong class="source-inline">start</strong> function should contain the command to start the service, the <strong class="source-inline">stop</strong> function should contain the command to stop the service, and the <strong class="source-inline">restart</strong> function should stop and start the service. Those can be the same as for <span class="No-Break">SysV </span><span class="No-Break"><strong class="source-inline">init</strong></span><span class="No-Break">.</span></p>
<p>In OpenRC, <strong class="source-inline">init</strong> scripts are typically stored in the <strong class="source-inline">/etc/init.d</strong> directory. These are scripts that are used to start and stop services and manage the <span class="No-Break">system’s runlevels.</span></p>
<p>To create<a id="_idIndexMarker357"/> a new <strong class="source-inline">init</strong> script for OpenRC, you can create a new file in the <strong class="source-inline">/etc/init.d</strong> directory and make <span class="No-Break">it executable.</span></p>
<p>Once you <a id="_idIndexMarker358"/>have created your <strong class="source-inline">init</strong> script, you can use the <strong class="source-inline">rc-update</strong> command to add it to the default runlevel, which will cause the service to start at boot. For example, to add the <strong class="source-inline">exampleservice</strong> service to the default runlevel, you can run the <span class="No-Break">following command:</span></p>
<pre class="console">
admin@myhome:~$ rc-update add exampleservice default</pre>
<p>In most cases, we’ll be using Alpine Linux in a Docker environment where there’s little use for OpenRC, but it’s still useful to know for some edge-case usage. We will look at Docker in more detail in <a href="B18197_08.xhtml#_idTextAnchor166"><span class="No-Break"><em class="italic">Chapter 8</em></span></a> and <a href="B18197_09.xhtml#_idTextAnchor245"><span class="No-Break"><em class="italic">Chapter 9</em></span></a><span class="No-Break">.</span></p>
<p>In this section, we have looked at OpenRC, software that controls system services in Alpine Linux. In the next section, we are going to introduce, very shortly, an outdated form of SysV <strong class="source-inline">init</strong>, which may come up with older or minimal <span class="No-Break">Linux distributions.</span></p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor096"/>SysV init</h2>
<p>As previously <a id="_idIndexMarker359"/>mentioned, the <strong class="source-inline">init</strong> process is the most important <a id="_idIndexMarker360"/>continuously running process in the system. It’s responsible for starting system services when the system boots up or when an administrator requests it, and stopping system services when the system is shutting down or when requested, all in the proper order. It’s also responsible for restarting services on request. Since <strong class="source-inline">init</strong> will execute code on behalf of the root user, it is imperative that it’s well tested for stability and <span class="No-Break">security risks.</span></p>
<p>One of the charming properties of the old <strong class="source-inline">init</strong> system was its simplicity. The starting, stopping, and restarting of a service was managed by a script—one that had to be written by either the application author, the distribution package owner for this application, or the system administrator—if the service was not installed from packages. The scripts were simple and easy to understand, write, <span class="No-Break">and debug.</span></p>
<p>The more the complexity of software grew, however, the more the old <strong class="source-inline">init</strong> system showed its age. Starting up a simple service was okay. Starting up an application consisting of several programs grew more difficult, especially as the dependencies between them became more important. <strong class="source-inline">init</strong> lacks observation of dependencies of startup of the services it takes <span class="No-Break">care of.</span></p>
<p>Another place where the old <strong class="source-inline">init</strong> system became more and more unfit for modern systems was serial startup: it was unable to start services in parallel, thus negating modern multicore CPU gains. The time was nigh to look for a system more fit to the <span class="No-Break">new times.</span></p>
<p>A typical <strong class="source-inline">init</strong> system consists<a id="_idIndexMarker361"/> of several components, <span class="No-Break">as follows:</span></p>
<ul>
<li>A <strong class="source-inline">/etc/init.d</strong> or <strong class="source-inline">/etc/rc.d/init.d</strong>  directory that contains <span class="No-Break">start/stop scripts.</span></li>
<li>A <strong class="source-inline">/etc/inittab</strong> file that defines runlevels and sets up a <span class="No-Break">default one.</span></li>
<li>A <strong class="source-inline">/etc/rcX.d</strong> directory that contains all the scripts for services that should be started or stopped in the runlevel <strong class="source-inline">X</strong>, where <strong class="source-inline">X</strong> is a number from <strong class="source-inline">0</strong> (zero) to <strong class="source-inline">6</strong>. We will get to the details in the <span class="No-Break">next paragraph.</span></li>
</ul>
<p>The <strong class="source-inline">/etc/init.d/</strong> directory contains shell scripts responsible for starting, stopping, and restarting services. The script accepts a single argument of either <strong class="source-inline">start</strong>, <strong class="source-inline">stop</strong>, or <strong class="source-inline">restart</strong>. Each argument passed to the script executes a proper function (usually named the same as the argument: <strong class="source-inline">start</strong>, <strong class="source-inline">stop</strong>, or <strong class="source-inline">restart</strong>), and the function runs a set of <a id="_idIndexMarker362"/>steps to properly start, stop, or restart the given service. The kind of final state of the start process that the system ends up in is called a <strong class="bold">runlevel</strong>. The <a id="_idIndexMarker363"/>runlevel determines whether services are being started or stopped and which of them are being started if this is the course <span class="No-Break">of action.</span></p>
<p>To determine the type of action to call, a link to the script would be created in the directory related to the runlevel <span class="No-Break">in question.</span></p>
<p>Let’s assume we <a id="_idIndexMarker364"/>want the system to end up in runlevel <strong class="source-inline">3</strong>. If we want our service to be started in this runlevel, we would create a link to the <strong class="source-inline">/etc/rc.d/my_service</strong> script pointing to the <strong class="source-inline">/etc/rc3.d/</strong> directory. The name of the link determines the type of action and the order. So, if we wanted the service to be started after numbers <strong class="source-inline">01</strong>-<strong class="source-inline">49</strong>, we would call it <strong class="source-inline">/etc/rc.3/S50my_service</strong>. The letter <strong class="source-inline">S</strong> tells the <strong class="source-inline">init</strong> system to start the service, and the number <strong class="source-inline">50</strong> tells it to start it after all services with lower numbers have been started. Please note that the numbering is more of a framework. It is not guaranteed that there are scripts with all other numbers prior to <strong class="source-inline">50</strong>. The same goes for stopping services. After determining which runlevel is the default for stopping the system (usually <strong class="source-inline">0</strong>), a proper <strong class="source-inline">symlink</strong> is created for the <span class="No-Break">service script.</span></p>
<p>The major problem with the preceding framework is that it’s totally unaware of dependencies. The only way to ensure that the services on which your daemon depends are running is to script it around in your <strong class="source-inline">start</strong> function. In the case of more complex applications comprising many services, this may lead to bigger <span class="No-Break">start/stop scripts.</span></p>
<p>Another issue <a id="_idIndexMarker365"/>with <strong class="source-inline">init</strong> scripts being raised by admins and developers was that there are multiple standards on how to write them and multiple different tools around <strong class="source-inline">init</strong> scripts. Basically, every major Linux distribution had its own way of writing those scripts and its own library of helper functions. Let’s consider an <strong class="source-inline">init</strong> script starting the same <strong class="source-inline">My Service</strong> service on Slackware Linux and Debian/GNU Linux. This is also where the introductory chapter on writing shell scripts comes <span class="No-Break">in handy.</span></p>
<p>In both cases, Slackware and Debian, we are going to cut some original content out for brevity, leaving only the most important parts. Do not worry as both distributions deliver wholly commented <span class="No-Break">example scripts.</span></p>
<p>The <a id="_idIndexMarker366"/>following <strong class="source-inline">init</strong> script will work in a Slackware Linux environment. The script starts with a header where we declare the name of the service and some <span class="No-Break">important paths:</span></p>
<pre class="source-code">
#!/bin/bash
#
# my_service       Startup script for the My Service daemon
#
# chkconfig: 2345 99 01
# description: My Service is a custom daemon that performs some important functions.
# Source function library.
. /etc/rc.d/init.d/functions
# Set the service name.
SERVICE_NAME=my_service
# Set the path to the service binary.
SERVICE_BINARY=/usr/local/bin/my_service
# Set the path to the service configuration file.
CONFIG_FILE=/etc/my_service/my_service.conf
# Set the user that the service should run as.
SERVICE_USER=my_service
# Set the process ID file.
PIDFILE=/var/run/my_service.pid
# Set the log file.
LOGFILE=/var/log/my_service.log</pre>
<p>The<a id="_idIndexMarker367"/> good thing is that an example script delivered with Slackware is very well commented. We have to declare a path to the binary for the daemon. We also have to declare the user and group that the service will run as, effectively deciding filesystem permissions <span class="No-Break">for it.</span></p>
<p>The next section<a id="_idIndexMarker368"/> defines all important actions for the service: <strong class="source-inline">start</strong>, <strong class="source-inline">stop</strong>,<strong class="source-inline"> and restart</strong>. There are usually a few others, but we have cut them out <span class="No-Break">for brevity:</span></p>
<pre class="source-code">
start() {
  echo -n "Starting $SERVICE_NAME: "
  # Check if the service is already running.
  if [ -f $PIDFILE ]; then
    echo "already running"
    return 1
  fi
  # Start the service as the specified user and group.
  daemon --user $SERVICE_USER --group $SERVICE_GROUP $SERVICE_BINARY -c $CONFIG_FILE -l $LOGFILE -p $PIDFILE
  # Write a lock file to indicate that the service is running.
  touch $LOCKFILE
  echo "done"
}</pre>
<p>The <strong class="source-inline">start</strong> function<a id="_idIndexMarker369"/> checks whether the service is running utilizing the <strong class="source-inline">pid</strong> file. The <strong class="source-inline">pid</strong> file is a text file that contains the PID of the service. It gives information about both the main process of the service and its status. There is a caveat, however. It is possible that the service isn’t running anymore and the <strong class="source-inline">pid</strong> file still exists. That would prevent the <strong class="source-inline">start</strong> function from actually starting <span class="No-Break">the service.</span></p>
<p>After the <a id="_idIndexMarker370"/>check determines that the <strong class="source-inline">pid</strong> file doesn’t exist, which means that the service is not running, a special tool called <strong class="source-inline">daemon</strong> is used to start the process with user and group permissions, pointing to a configuration file, log file, and <strong class="source-inline">pid</strong> <span class="No-Break">file locations.</span></p>
<p>The function communicates its actions using the <strong class="source-inline">bash echo</strong> command, which prints the given text. In case of automatic execution, the output of the <strong class="source-inline">echo</strong> command will be logged to system logs depending on the logging <span class="No-Break"><strong class="source-inline">daemon</strong></span><span class="No-Break"> configuration:</span></p>
<pre class="source-code">
stop() {
  echo -n "Stopping $SERVICE_NAME: "
  # Check if the service is running.
  if [ ! -f $PIDFILE ]; then
    echo "not running"
    return 1
  fi
  # Stop the service.
  killproc -p $PIDFILE $SERVICE_BINARY
  # Remove the lock file.
  rm -f $LOCKFILE
  # Remove the PID file.
  rm -f $PIDFILE
  echo "done"
}</pre>
<p>Again, the <strong class="source-inline">stop</strong> function <a id="_idIndexMarker371"/>checks whether the service is running using the <strong class="source-inline">pid</strong> file. The probability of the service running without a proper <strong class="source-inline">pid</strong> file is almost nonexistent. After the check is done, a special command called <strong class="source-inline">killproc</strong> is used to terminate the process. In the final part of the function, the script does some housekeeping tasks, cleaning the <strong class="source-inline">pid</strong> file and the <span class="No-Break"><strong class="source-inline">lock</strong></span><span class="No-Break"> file:</span></p>
<pre class="source-code">
restart() {
  stop
  start
}</pre>
<p>The <strong class="source-inline">restart</strong> function <a id="_idIndexMarker372"/>is very simple. It reuses the already defined <strong class="source-inline">start</strong> and <strong class="source-inline">stop</strong> functions to do exactly what it says: restart the service. This is often useful if the service configuration requires the binary to be <span class="No-Break">loaded again:</span></p>
<pre class="source-code">
case "$1" in
  start)
    start
    ;;
  stop)
    stop
    ;;
  restart)
    restart
    ;;
  *)
    echo "Usage: $0 {start|stop|restart|uninstall}"
esac</pre>
<p>The final part of<a id="_idIndexMarker373"/> the script evaluates the action we want to take—start, stop, or restart the service—and calls the proper function. If we ask it to do something it doesn’t recognize, the <a id="_idIndexMarker374"/>script will print out <span class="No-Break">usage instructions.</span></p>
<p>The following script, however, is intended for a Debian <span class="No-Break">Linux environment:</span></p>
<pre class="source-code">
#!/bin/bash
#
# my_service       Startup script for the My Service daemon
#
# chkconfig: 2345 99 01
# description: My Service is a custom daemon that performs some important functions.
# Source function library.
. /lib/lsb/init-functions
# Set the service name.
SERVICE_NAME=my_service
# Set the path to the service binary.
SERVICE_BINARY=/usr/local/bin/my_service
# Set the path to the service configuration file.
CONFIG_FILE=/etc/my_service/my_service.conf
# Set the user that the service should run as.
SERVICE_USER=my_service
# Set the group that the service should run as.
SERVICE_GROUP=my_service</pre>
<p>Again, the <a id="_idIndexMarker375"/>script starts with a header section that defines paths to be later<a id="_idIndexMarker376"/> used in the <strong class="source-inline">start</strong> and <strong class="source-inline">stop</strong> sections. Normally there are more lines, but we’ve cut them out for <span class="No-Break">brevity, again:</span></p>
<pre class="source-code">
start() {
  log_daemon_msg "Starting $SERVICE_NAME"
  # Check if the service is already running.
  if [ -f $PIDFILE ]; then
    log_failure_msg "$SERVICE_NAME is already running"
    log_end_msg 1
    return 1
  fi
  # Start the service as the specified user and group.
  start-stop-daemon --start --background --user $SERVICE_USER --group $SERVICE_GROUP --make-pidfile --pidfile $PIDFILE --startas $SERVICE_BINARY -- -c $CONFIG_FILE -l $LOGFILE
  # Write a lock file to indicate that the service is running.
  touch $LOCKFILE
  log_end_msg 0
}</pre>
<p>The <strong class="source-inline">start</strong> function<a id="_idIndexMarker377"/> looks similar to the one from the Slackware version. You’ll notice some subtle differences, however, <span class="No-Break">as follows:</span></p>
<ul>
<li>The <strong class="source-inline">start-stop-daemon</strong> helper function is being used here to manage the running service instead of <strong class="source-inline">daemon</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">killproc</strong></span></li>
<li>There are specialized functions for logging instead of simple echo: <strong class="source-inline">log_daemon_msg</strong>, <strong class="source-inline">log_failure_msg</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">log_end_msg</strong></span></li>
<li>The <strong class="source-inline">start-stop-daemon</strong> function accepts special flags to determine the action (<strong class="source-inline">start</strong> and <strong class="source-inline">stop</strong>) as well as detaching the program from the terminal, making it<a id="_idIndexMarker378"/> effectively a system service (<strong class="source-inline">--background</strong>), as <span class="No-Break">seen here:</span></li>
</ul>
<pre class="source-code">
stop() {
  log_daemon_msg "Stopping $SERVICE_NAME"
  # Check if the service is running.
  if [ ! -f $PIDFILE ]; then
    log_failure_msg "$SERVICE_NAME is not running"
    log_end_msg 1
    return 1
  fi
  # Stop the service.
  start-stop-daemon --stop --pidfile $PIDFILE
  # Remove the lock file.
  rm -f $LOCKFILE
  # Remove the PID file.
  rm -f $PIDFILE
  log_end_msg 0
}</pre>
<p>The <strong class="source-inline">stop</strong> function<a id="_idIndexMarker379"/> is pretty similar to the <strong class="source-inline">stop</strong> function from Slackware, with similar differences to those the <strong class="source-inline">start</strong> <span class="No-Break">function had.</span></p>
<p>The rest of the script containing the <strong class="source-inline">restart</strong> function and the task evaluation is not that interesting, and we’ve cut <span class="No-Break">it out.</span></p>
<p>As you probably still remember from the section about <strong class="source-inline">systemd</strong>, it solves some of those problems. SysV is not seen too often in modern systems, so you will most commonly need to deal with <span class="No-Break"><strong class="source-inline">systemd</strong></span><span class="No-Break"> instead.</span></p>
<p>T<a id="_idTextAnchor097"/>here is, however, another replacement for SysV <strong class="source-inline">init</strong> <span class="No-Break">called Upstart.</span></p>
<h1 id="_idParaDest-92">A few words about Upstart, an alternative</h1>
<p>Upstart is <a id="_idIndexMarker380"/>an event-based replacement for the traditional SysV <strong class="source-inline">init</strong> system used to manage and control services and daemons on a system. Upstart was introduced in Ubuntu <strong class="source-inline">6.10</strong> and later versions and is designed to improve boot time, simplify system configuration, and provide more flexibility in managing system services. It has now been largely replaced by <strong class="source-inline">systemd</strong> in most <span class="No-Break">Linux distributions.</span></p>
<p>Upstart is used to manage the initialization process of the system and to start, stop, and supervise tasks and services. It is designed to be more flexible and efficient than the traditional <strong class="source-inline">init</strong> daemon and to provide more information about the status of tasks <span class="No-Break">and services.</span></p>
<p>All that can be managed by <strong class="source-inline">systemd</strong> and/or <strong class="source-inline">cron</strong> has become an industry standard, so if you don’t have a good reason for using those or already have a system using Upstart, we discourage you from using it as <span class="No-Break">a default.</span></p>
<h1 id="_idParaDest-93">Summary</h1>
<p>In this chapter, we covered system services—or daemons in the Unix and Linux world—and the software most often used to manage them. We explained what those are, how to inspect their state, and how to control them. In the next chapter, we are going to dive into <span class="No-Break">Linux networking.</span></p>
</div>
</div></body></html>