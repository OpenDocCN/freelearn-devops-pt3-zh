- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Brief History of Deploying Salesforce Changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With Salesforce’s own delivery model coming in the form of three major releases
    per year, the platform has evolved substantially since it was first made available
    back in 2000\. From its early days as a predominantly sales tool, Salesforce has
    evolved to become a development platform in its own right. With this change came
    the need to bring true development best practices to your customizations and the
    need to deliver them effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll be looking at the history of making and delivering changes
    on the Salesforce platform, to understand the current shortcomings of the built-in
    tools. This will help set the context for the necessity of a DevOps process and
    where the current state of the art sits today. We’ll be covering the following
    main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The beginnings of customizing Salesforce
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apex and Visualforce
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sandboxes and change sets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SFDX and scratch orgs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DevOps Center
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike the rest of this book, this chapter does not necessarily provide actionable
    steps or best practice guidance that you can apply to your Salesforce implementations.
    However, one of the fundamental principles of being a good Salesforce architect
    is to understand the *why* of our decisions. By looking at the history of Salesforce
    as a development platform, and how it has continued to steer toward contemporary
    software development approaches and tooling, we can better understand the need
    for DevOps in the Salesforce ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to the history of Salesforce as a development platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For any sufficiently complex IT system, it is important to consider the full
    range of architectural considerations in both the implementation phase and the
    day-to-day running of the system. These considerations are not just technical
    aspects but those that sit at the business level as well – strong governance,
    accurate and up-to-date documentation, definable metrics, and a demonstrable return
    on investment to the business.
  prefs: []
  type: TYPE_NORMAL
- en: As Salesforce has grown, so has the need to apply these architectural factors
    to the work we do on the platform. Salesforce has become a *first-class citizen*
    in many organizations, acting as the digital hub to run a business. A proper change
    management process is therefore critical to avoid interruptions of service, and
    DevOps is the perfect approach to that requirement. DevOps promises faster, more
    accurate software releases, fewer errors, less downtime, and a faster path to
    recovery when problems occur.
  prefs: []
  type: TYPE_NORMAL
- en: We can reasonably pinpoint Salesforce first becoming a development platform
    in 2003\. At the company’s inaugural edition of Dreamforce, their flagship conference
    that continues annually to the present day, they announced a fundamental shift
    in how customers can customize the platform. Dubbed **sforce 2.0**, it was initially
    positioned as an *on-demand application server* and included some key capabilities,
    which we’ll explore next.
  prefs: []
  type: TYPE_NORMAL
- en: Custom objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first major innovation introduced at this time was the ability to create
    additional custom objects, much like database tables, to complement the built-in
    objects provided by Salesforce for their core CRM capabilities. These custom objects
    could themselves contain custom fields and together provided the early framework
    for developing custom business applications on the platform.
  prefs: []
  type: TYPE_NORMAL
- en: Suddenly, Salesforce had moved from being just a sales CRM system and started
    moving toward becoming a platform to develop custom business applications. Salesforce
    teams were now able to start tailoring processes and applications to the core
    needs of their business, regardless of which industry they worked in. For example,
    some Salesforce customers would leverage this capability to start building out
    the ability to handle support cases for their business – something that didn’t
    become a core platform capability until the announcement of Service Cloud in 2009.
  prefs: []
  type: TYPE_NORMAL
- en: S-Controls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: S-Controls (initially called *sforce controls*) were one of the two programmatic
    elements of the new customization capabilities. Combining both functionality and
    user interface elements in one container, S-Controls could contain any items that
    could be displayed in a browser, such as Java applets, ActiveX controls, and web
    forms.
  prefs: []
  type: TYPE_NORMAL
- en: While they’ve been long since deprecated, S-Controls were the first method made
    available for developers to customize the platform in a programmatic way, and
    they allowed them to bring skillsets and programming languages from other non-Salesforce
    development into the platform. They enabled Salesforce developers to harness HTML
    and JavaScript for the creation of custom pages and user interface components.
    In this sense, they could be potentially viewed as an early forerunner of Lightning
    Web Components but without much of the best practice we use today.
  prefs: []
  type: TYPE_NORMAL
- en: SOQL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sforce 2.0 also introduced **Sforce Object Query Language** (**SOQL**), which
    provided a means of querying data from both standard and custom objects, with
    a syntax like the industry standard, SQL. This provided developers with a powerful
    mechanism with which to query the data in their Salesforce organization programmatically
    and act upon the results of these queries.
  prefs: []
  type: TYPE_NORMAL
- en: If we were to look at SOQL from an architect’s perspective, we can see how this
    aligns with the need to ensure that your data quality is of as high a standard
    as your metadata. Clean, actionable data to drive business decisions should always
    be one of the key deliverables for an architect. SOQL provided an additional means
    of working with this data, whether operationally for the day-to-day business or
    as the beginning of a means to extract data from the platform for archival purposes.
    This latter use case is something that we’ll explore later as we look at the importance
    of backups in a well-architected Salesforce DevOps strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Sforce web services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the other fundamental new capabilities of sforce 2.0 was the ability
    to integrate Salesforce with other platforms, thanks to the exposing of the object
    model and business logic via web service APIs. Using the standards at the time,
    SOAP and WSDL, it was now possible to interact with your Salesforce organization
    from more traditional development environments and systems, over a network.
  prefs: []
  type: TYPE_NORMAL
- en: Workflows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last major element introduced with sforce 2.0 was a business process automation
    engine called workflows. By defining workflow rules that responded to changes
    in your data, business logic could be triggered for things such as escalations,
    notifications, and automatic updates to data in response to events. Workflows
    were still very much a config, not code, means of delivering functionality, but
    as we’ll see later, being a low-code solution does not mean that it should be
    ignored when it comes to DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: Apex and Visualforce
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the 2006 edition of Dreamforce, Salesforce’s flagship conference, co-founder
    Parker Harris revealed the most significant change to the Salesforce platform
    to date. Customers were now able to develop custom solutions using Salesforce’s
    own programming language, called **Apex**, right within Salesforce itself.
  prefs: []
  type: TYPE_NORMAL
- en: A variant of the popular Java programming language, Apex enabled automation
    through code for the first time. Originally limited to triggers only, developers
    could now take a programmatic approach to responding to data changes.
  prefs: []
  type: TYPE_NORMAL
- en: Later in the evolution of the platform, Apex would adopt more of the object-oriented
    paradigm with the arrival of Apex classes, allowing developers to build a more
    structured, decoupled implementation than triggers alone could deliver.
  prefs: []
  type: TYPE_NORMAL
- en: Alongside Apex, the other major innovation to the Salesforce platform was Visualforce,
    introduced in 2008\. Taking cues from other contemporary UI languages such as
    ASP or PHP, Visualforce blended HTML with programmatic elements and markup that
    connected back to your logic written in Apex. Visualforce went on to quickly supersede
    the S-Controls that were previously introduced, becoming the standard way to write
    custom user interfaces and pages in your Salesforce implementation.
  prefs: []
  type: TYPE_NORMAL
- en: With all these advances in the platform for development and customization, Salesforce
    then turned its attention to how to deliver them. Let’s look at how this was initially
    introduced in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Sandboxes and change sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As Salesforce continued to mature, the need to be able to safely make changes
    outside of production and move them across when ready became obvious. However,
    the pace of DevOps innovation did not seem to keep up with the rise of Salesforce
    as a development platform.
  prefs: []
  type: TYPE_NORMAL
- en: Sandboxes were introduced in the winter 2006 release, allowing customers to
    try out changes and enhancements in a safe environment away from production –
    but with a catch. The original implementation of sandboxes did not allow you to
    move those changes *back* to production, meaning that you had to recreate those
    changes again in your production environment manually. This would be both time-consuming
    and error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: In recognition of this shortcoming, change sets were initially introduced in
    beta for the winter 2010 release, some four years after sandboxes, and finally,
    they became generally available in the Spring 2011 release. Change sets finally
    allowed the code and configuration work done in sandbox environments to be packaged
    up and moved between environments, whether from sandbox to sandbox, sandbox to
    production, or even production to sandbox. This opened up new possibilities to
    plan Salesforce environments as part of a mature application development life
    cycle – you could now have dev, QA, UAT, and staging environments ahead of production
    go-live. This was the first significant step toward achieving a DevOps process
    that matched those on other development platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Metadata and Tooling APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To open the platform to better tooling for development and deployment, Salesforce
    introduced two important APIs – Metadata API in the Spring 2008 release and Tooling
    API in the Spring 2013 release. While they both fulfilled similar functions, there
    were some important differences in their aims and functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Metadata API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the simplest level, metadata is data that describes the *structure* of your
    data, but for the Salesforce platform, that is a bit of an oversimplification.
    The term *metadata* covers many of the configuration and customization elements
    of Salesforce as well – at the time of writing, Salesforce’s own Metadata Coverage
    Report, available at [https://developer.salesforce.com/docs/metadata-coverage](https://developer.salesforce.com/docs/metadata-coverage),
    indicates 601 metadata types in the platform, the vast majority of which are covered
    in Metadata API.
  prefs: []
  type: TYPE_NORMAL
- en: Metadata API can be used to move this metadata between environments. You can
    retrieve the metadata as XML files from one Salesforce organization and deploy
    it into another. Much like change sets, the source and target for these operations
    can be sandboxes, production, or, as we’ll learn about shortly, scratch orgs.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, Metadata API allows you to create, update, and delete metadata
    within a Salesforce org, and this unlocks a fundamental capability for both Salesforce
    development and to adopt a DevOps approach on the platform.
  prefs: []
  type: TYPE_NORMAL
- en: The Metadata API underpins most DevOps tools on the platform, whether that’s
    Salesforce’s own SFDX, the new DevOps Center, or the various third-party Salesforce
    DevOps solutions available. They all leverage Metadata API to coordinate the movement
    of your code and config between environments.
  prefs: []
  type: TYPE_NORMAL
- en: Tooling API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While Metadata API did much of the heavy work of managing metadata, Salesforce
    introduced Tooling API to provide further capabilities that better aligned to
    DevOps practices, such as smaller and more focused metadata retrieval and deployment,
    the ability to run unit tests and view both the test results and the associated
    code coverage, and support for some additional code debugging capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to manage unit test cycles makes Tooling API another strong candidate
    for use in DevOps processes and tools. As architects, we need to ensure that we
    not only deliver code *quickly* but also that it is of the right quality – it
    doesn’t break in isolation, it doesn’t break existing code, it fulfills the requirements
    for which it was created, and it deploys between Salesforce organizations seamlessly.
    These are all factors of the Change Failure Rate, one of the fundamental DevOps
    metrics that we’ll explore in the next chapter as we look at what the key considerations
    to develop a DevOps culture as architects are.
  prefs: []
  type: TYPE_NORMAL
- en: Tooling API is primarily targeted at those wishing to create additional development
    tools or apps for the platform, and its arrival heralded Salesforce development
    support in some of the popular IDEs of the day, which we will look at next.
  prefs: []
  type: TYPE_NORMAL
- en: The Force.com IDE and Mavensmate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With new tools that leveraged Metadata and Tooling APIs, it was no longer necessary
    to develop for the Salesforce platform from within the platform. To assist developers
    with this approach, Salesforce started looking at how best to deliver a standardized
    developer experience that matched the standards of the time. Let’s run through
    the tools available at that time.
  prefs: []
  type: TYPE_NORMAL
- en: The Force.com IDE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the early IDEs that took advantage of this was Salesforce’s own Force.com
    IDE.
  prefs: []
  type: TYPE_NORMAL
- en: Built on top of the modular plugin architecture of the popular Eclipse development
    environment that was predominantly used for Java, the Force.com IDE took advantage
    of the new APIs to allow developers to not only code with a proper editor but
    also to save their changes back in their development organizations, directly from
    the IDE, without having to switch back to the Salesforce user interface.
  prefs: []
  type: TYPE_NORMAL
- en: The Force.com IDE became very popular very quickly, as it was the first attempt
    to provide a modern environment for Salesforce developers, with some of the niceties
    that developers on other platforms such as Java or .NET had come to expect. However,
    it developed a reputation for being slow and unstable equally as quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Mavensmate
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As an antidote to the heavyweight installation of Eclipse and the plugin, and
    as a potential means to improve speed and stability, 2013 saw the arrival of another
    development tool for Salesforce – Mavensmate.
  prefs: []
  type: TYPE_NORMAL
- en: Mavensmate took the same plugin approach as the Force.com IDE, in that it effectively
    extended another editor called **Sublime Text** (and later, support was added
    for the rival Atom editor), but both the underlying editor and the Mavensmate
    plugin on the top were considerably more lightweight. This made working with Salesforce
    development easier, faster, and more stable than ever before, and Mavensmate became
    the choice of Salesforce developers everywhere on the basis of its speed and ease
    of use – not just for development but also to deploy changes, thanks to the use
    of the Metadata and Tooling APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing SFDX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The state of Salesforce change management had largely remained stable for several
    years. For the majority of Salesforce developers and admins, change sets remained
    the definitive means of delivering change from sandbox to production.
  prefs: []
  type: TYPE_NORMAL
- en: All this changed again when Salesforce released its SFDX toolchain in 2018\.
    SFDX offered the promise of modern development and deployment practices, seen
    on other platforms, delivered through a command-line tool. Suddenly, the potential
    existed for advanced, scriptable deployments, more robust IDE integration, and
    a new way to manage changes. Most importantly, it represented the move toward
    a source-driven development model for Salesforce, rather than the traditional
    organization-based model.
  prefs: []
  type: TYPE_NORMAL
- en: The SFDX **command-line interface** (**CLI**) was coupled with the introduction
    of scratch orgs. These are ephemeral development environments that can be spun
    up and torn down easily from SFDX, created using different configurations (or
    *org shapes*), and populated with test data. The ability to create them from a
    command lent itself to a new era of automated testing, as we shall see later,
    but it also reinforced the principle that organizations are now secondary to source
    code. If a scratch org expires, it’s not a major issue because another one can
    be easily recreated from the source code.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, Salesforce had recognized the need for tight integration with development
    tools and provided extensions for the popular **Visual Studio** (**VS**) Code
    environment, easing both development and deployment on the Salesforce platform,
    right from the IDE. Additionally, by building on open standards such as the **Open
    Command Line Interface Framework** (**OCLIF**), it opened the tool up to extension
    via plugins, which were contributed from both inside and outside Salesforce, extending
    the capabilities of the SFDX CLI and filling some of the gaps that the tool didn’t
    cover natively.
  prefs: []
  type: TYPE_NORMAL
- en: SFDX continues to be the Salesforce-recommended approach for developers working
    with the platform, especially around integrating it into CI/CD pipelines and other
    automation. As of December 2022, Salesforce is continuing a drive toward a unified
    CLI that combines the SFDX command line and the newer SF command line, which introduced
    a newer structure and a cleaner approach. This consolidation will hopefully result
    in an even more efficient command-line toolset that will increase the ease of
    building a robust DevOps pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: DevOps Center
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Salesforce has long acknowledged that the platform has outgrown change sets,
    but SFDX was (and still is) perceived by its customers as a tool solely for developers
    and those comfortable with the command line, despite the VS Code extensions that
    made it easier to work with. A considerable ecosystem of third-party providers
    such as Gearset, Copado, AutoRABIT, and Flosum had sprung up to provide platforms
    for robust DevOps that better matched the wider IT industry’s best practices.
    These tools gave Salesforce developers and admins capabilities such as organization-to-organization
    comparisons, version control capabilities, static code analysis, and deployment
    pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Salesforce entered this space with the release of DevOps Center, which became
    generally available in December 2022\. While not as feature-rich as the incumbent
    solutions from the third-party ecosystem, it represented a change of messaging
    from Salesforce to all users – a move away from change set deployments to something
    that was easy enough to work with, whether you were a low-code or pro-code admin
    or developer.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll be exploring the specifics of DevOps Center (and indeed, the leading solutions
    in the third-party Salesforce DevOps space) in a later chapter, but it’s important
    to see how much of a fundamental shift in thinking this new product is, particularly
    when viewed in the context of the history of creating and delivering changes to
    the platform described earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'DevOps Center introduces much of the best practice in Salesforce DevOps that’s
    slowly been established, incrementally, over the years and packages it up in an
    easy-to-understand native interface, right within the platform:'
  prefs: []
  type: TYPE_NORMAL
- en: It guides Salesforce practitioners toward a model in which source control is
    the version of truth for changes, rather than sandbox organizations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It encourages the concept of isolated, incremental change through work items,
    or user stories – a concept popularized by the agile movement and popular in the
    DevOps strategy of many other platforms and organizations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most importantly, it gives better visibility and accountability for change delivery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are factors of the overall architecture of a DevOps process, which we
    shall delve into later in this book. It doesn’t cover every aspect thoroughly
    in the initial release, and it should very much be considered a DevOps *tool*
    rather than a DevOps *solution*, but as a means of educating Salesforce users
    on the basics of DevOps and weaning them off change sets, it’s a very solid start.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the history of Salesforce as a development platform
    and saw how features were added over the years. We also explored the approach
    to delivering those changes on Salesforce, from change sets, through the various
    APIs and tools that utilized them, to the arrival of DevOps Center.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with this knowledge, we can not only better appreciate how far the platform
    has come but also understand the reasoning behind some of the design choices we
    have today, gaining a little knowledge of older implementations, which can often
    prove useful when faced with having to work on older Salesforce organizations.
  prefs: []
  type: TYPE_NORMAL
- en: As architects, it’s important to not take DevOps tooling for granted, and having
    the ability to work with a variety of different approaches and solutions, no matter
    how old, will help us to work with and improve the state of Salesforce DevOps
    for the implementations we deliver. In subsequent chapters, we’ll look at some
    of the most recent tooling and, more importantly, the techniques and processes
    that shape modern Salesforce DevOps.
  prefs: []
  type: TYPE_NORMAL
