- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding GitLab Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GitLab is a huge, complicated web app that aims to be a “one-stop shop” for
    making every step of the software development life cycle easier: it helps you
    to plan, create, test, secure, and deploy software. And those are just the big
    tasks it covers! It also helps you track progress using a variety of workflows,
    document projects, create release notes, store Docker images or other types of
    software packages, host static web pages, monitor the performance of deployed
    applications, and watch for suspicious network traffic within Kubernetes clusters.
    This list could be much longer, but you get the picture: *GitLab helps with most
    of the tasks involved in the standard software development* *life cycle.*'
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B18073_01.xhtml#_idTextAnchor013), we articulated key problems
    in the software development life cycle that GitLab was designed to solve. Now,
    we’ll introduce you to the key GitLab concepts and components that you’ll need
    to be familiar with in order to use it effectively. Once you understand these
    building blocks, you’ll be ready to start the work of setting up CI/CD pipelines,
    which we will begin to address in [*Chapter 4*](B18073_04.xhtml#_idTextAnchor084).
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll discuss projects, groups, issues, branches, and merge
    requests. We’ll then bring those GitLab components to life by showing you how
    to create, manage, and use some of those concepts in the application’s GUI. When
    you’re comfortable with these fundamentals, you’ll learn how to use **GitLab flow**,
    which is a best practice workflow recommended by GitLab’s developers for effectively
    combining the tool’s various building blocks as you write, test, secure, and deploy
    software.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how the main topics appear in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Emphasizing the “why” over the “how”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the GitLab platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing work into projects and groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking work with issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing files safely with commits, branches, and merge requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling DevOps practices with GitLab flow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ll benefit most from this chapter if you’re able to follow along by logging
    into an account on a GitLab instance. This account can be an account on the instance
    hosted at gitlab.com (also known as a **Software-as-a-Service** (**SaaS**) instance),
    or an account on an instance hosted by your company (known as a self-managed,
    a self-hosted, or an on-premises instance). You could even host GitLab on your
    own hardware at home or on a virtual machine in the cloud, using a service such
    as AWS EC2, Google Cloud Platform, or Microsoft Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Hosting your own instance is not as far-fetched as it sounds, thanks to surprisingly
    low hardware requirements—you can even host GitLab on a Raspberry Pi!—and a variety
    of “Omnibus” Linux packages that contain everything you need for an entire GitLab
    instance. We’ll refer you to the GitLab installation documentation at [https://about.gitlab.com/install](https://about.gitlab.com/install)
    for more information if you want to go down this path.
  prefs: []
  type: TYPE_NORMAL
- en: If you’d prefer to let someone else take care of installation, administration,
    and upgrade tasks for you, head over to [https://gitlab.com](https://gitlab.com)
    and sign up for a free account on their SaaS platform. Although there are minor
    feature differences between the SaaS and self-managed varieties of GitLab, they
    are so small that we won’t discuss them in this book. For all intents and purposes,
    the feature sets of SaaS GitLab and self-managed GitLab are identical.
  prefs: []
  type: TYPE_NORMAL
- en: 'As of early 2023, GitLab has three **product tiers**: Free, Premium, and Ultimate.
    The first of these tiers is open source and free for everyone to use. It also
    has the most limited feature set. The Premium tier requires a paid license but
    adds some extra features. The Ultimate tier costs more than Premium but unlocks
    the entire GitLab feature set. These tiers apply to both SaaS and self-managed
    installations.'
  prefs: []
  type: TYPE_NORMAL
- en: This book will discuss some features that are available in the Free tier, some
    that are available only in the Premium and Ultimate tiers, and some that are only
    unlocked with an Ultimate license. If you are on a budget, don’t worry. GitLab
    has plenty of functionality to improve your life as a software developer, even
    with the lower tiers. Many people find the Free tier to be all they ever need,
    especially if they mainly use GitLab for personal hobby projects.
  prefs: []
  type: TYPE_NORMAL
- en: Emphasizing the “why” over the “how”
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get started, a word of warning. For the most part, this book will
    not lead you through step-by-step instructions on what to click in the GitLab
    GUI in order to perform various operations.
  prefs: []
  type: TYPE_NORMAL
- en: First, instructions for most operations are already well covered in GitLab’s
    official documentation, which is remarkably clear and thorough.
  prefs: []
  type: TYPE_NORMAL
- en: Second, because GitLab is in rapid development, its GUI often changes. These
    changes are rarely radical, workflow-breaking changes, but they are significant
    enough that screenshots, or even bullet-pointed instructions for how to perform
    operations, can quickly get stale. This means that any concrete instructions in
    this book could become confusing or impossible to follow, or potentially even
    lead to data loss, as the GitLab GUI drifts over time. To avoid that problem,
    we’ll mostly focus on *why* you might want to use different GitLab features. Although
    we’ll give you a general picture of *how* to use those features, we usually won’t
    provide detailed instructions for every configuration option or workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the GitLab platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is GitLab?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The company called GitLab makes a single product: a web application that is
    also called GitLab.Behind the scenes, the GitLab web application is a complicated
    collection of tools, databases, queues, and glue code holding it all together,
    but as far as the user is concerned, it’s just a single, web-based tool for building
    software.'
  prefs: []
  type: TYPE_NORMAL
- en: Different Meanings of “GitLab”
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, the term “GitLab” refers to the tool rather than the company,
    unless we explicitly say otherwise.
  prefs: []
  type: TYPE_NORMAL
- en: As we discussed in the first chapter, GitLab’s single-tool model is much easier
    to install, administer, and upgrade than any collection of separate, more focused
    tools. It requires only a single set of credentials per user. It offers a consistent
    GUI for all of its features. It integrates all the software development life cycle
    tools, allowing data to flow smoothly and without loss or distortion from one
    feature to the next. It provides a single location to learn about the status of
    your software as you plan, build, test, secure, and deploy it. To top it all off,
    it’s a lot cheaper than buying separate licenses for a collection of separate
    tools. And if you find that any of GitLab’s individual features don’t give you
    the flexibility or power that you need, you can almost always integrate other
    tools with GitLab to make it suit your technical needs and preferred workflow.
  prefs: []
  type: TYPE_NORMAL
- en: What problem does GitLab solve?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The purpose of GitLab—the problem it aims to solve—has shifted and broadened
    over the years. It was created in 2011 with a narrow focus: it wanted to make
    Git both easier to use and more powerful. In those days, it was not much more
    than a web-based GUI wrapper around Git and a centralized place to store projects’
    golden Git repositories.'
  prefs: []
  type: TYPE_NORMAL
- en: Since then, GitLab has widened its scope. It now aims not just at Git but at
    the entire software development life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a sense of how its mission has grown, you first need to understand Gitlab’s
    concept of “stages” in the software development life cycle. GitLab recognizes
    10 stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Manage**: Create audit and compliance reports, and restrict access to resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plan**: Divide work into workable chunks that you can prioritize, weight,
    and assign to team members.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Create**: Commit, review, and approve file edits, whether they contain code,
    configuration information, or other assets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Verify**: Run automated tests to make sure your software does what it’s supposed
    to.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Package**: Bundle your software into a deployable format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secure**: Find any security vulnerabilities in your software or its dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Release**: Deploy your software, optionally using sophisticated techniques
    such as feature flags and canary deployments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configure**: Set up the environments where your code will be deployed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitor**: Report on performance metrics, incidents, or errors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Protect**: Detect potential security problems in deployment environments
    such as Kubernetes clusters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that there’s nothing magical about this division of the software development
    life cycle into stages. Another company might have divided it into 9 or 13 stages
    and might have drawn the boundaries between stages slightly differently. But GitLab’s
    division probably seems reasonable to anyone who has been involved in software
    development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s return to the question of what problem GitLab aims to solve. Since its
    humble beginnings as a solution to the difficulties of using Git (that is, early
    GitLab focused exclusively on the Create stage described previously), it now addresses
    problems faced by practitioners of all 10 of these software development life cycle
    stages. Because different stages present different problems, it’s hard to give
    a succinct description of the single problem GitLab is targeting. In fact, it’s
    probably impossible considering that GitLab now targets a myriad of problems from
    all 10 stages. The shortest, best answer we can give to the question of why GitLab
    exists is this: *it helps people write better software, more efficiently, and
    with* *less risk*.'
  prefs: []
  type: TYPE_NORMAL
- en: We’re the first to admit that GitLab is not yet equally effective at addressing
    the problems of all 10 stages. That is to say, some of the features that GitLab
    offers as solutions to various problems are more mature or more robust than others.
    As you might expect, the GitLab features that have been around the longest (such
    as the Git-related functionality) are generally the most mature, and more recently
    developed features (such as protecting your application from suspicious traffic
    within a Kubernetes cluster) are significantly more minimal. But GitLab is very
    transparent about its own assessment of the relative maturity of its solutions
    to the problems of the various stages, and which features it intends to focus
    on developing and improving in the near future. So, if you’re particularly curious
    about how full-featured GitLab’s solution to a particular software development
    life cycle problem is, a quick Google search for “GitLab maturity” will probably
    give you all the information you need to make an informed decision about whether
    GitLab offers enough power and flexibility to address the problems that trouble
    you the most.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you might be wondering how GitLab can compete with specialized
    tools that focus on just one of the software development life cycle stages. After
    all, can a single tool really replace a suite of 10 separate tools, each of which
    is considered “best in breed” for their problem domain?
  prefs: []
  type: TYPE_NORMAL
- en: First, you might find that you don’t need as many features or as much power
    as you initially think you do. One of the authors of this book once took a full-day
    training course on a Java performance profiling tool. He left the training with
    his head spinning from all the fantastic features the product offered and the
    detailed performance bottleneck reports that he would soon be able to present
    to his manager. But, it turned out his company only needed 2% of the power of
    that tool and could have gotten away with using a much simpler and cheaper alternative
    instead. The moral of this story? *GitLab might give you all the power you need,
    no matter which software development life cycle stage you’re* *concerned with*.
  prefs: []
  type: TYPE_NORMAL
- en: Second, some of GitLab’s features are the result of integrating independently
    developed open source tools that truly are the best tools available for the problems
    they address. For example, many of GitLab’s security vulnerability scanners are
    highly regarded open source tools. It’s true that you could download and use these
    tools outside of GitLab, but GitLab makes it trivial to enable them in your workflow,
    and it integrates their output into existing GitLab dashboards in a familiar,
    easy-to-read format that’s consistent with all of GitLab’s other reports.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, if you really do find that you need more than GitLab offers to solve
    a particular software development life cycle problem, you can almost always find
    a way to integrate outside tools into your GitLab workflow. Some of these integrations
    are explicitly supported by GitLab, and as a result, have virtually seamless results.
    Other integrations require more work on your part. But, virtually any tool that
    you can run from an operating system’s command line can be integrated into GitLab.
    Results may vary, but the number of tools that can’t talk to GitLab at all is
    vanishingly small.
  prefs: []
  type: TYPE_NORMAL
- en: The verify, secure, and release stages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we’ve established that GitLab has ambitious goals for helping with
    all 10 stages of the software development life cycle, let’s scale things back
    a bit. This chapter focuses on the middle of the SDLC: the **verify**, **secure**,
    and **release** stages. These are among the most commonly used stages when writing
    software, and among the most problematic for all the reasons described in [*Chapter
    1*](B18073_01.xhtml#_idTextAnchor013). Fortunately, they are also the stages at
    which GitLab is most effective, and the feature it uses to solve the problems
    posed by those stages is, as you might guess, CI/CD pipelines. Now you know why
    so much of this book focuses on exactly that topic!'
  prefs: []
  type: TYPE_NORMAL
- en: To understand how GitLab can help with the problems found in those three stages,
    you’ll need to know about a few concepts, terms, and GitLab components. Fortunately,
    everything you’re about to learn in the rest of this chapter will be relevant
    and useful to many of the other Gitlab stages as well. So, once you understand
    how to use these concepts, you’ll not only be able to move on to understanding
    GitLab CI/CD pipelines but you’ll also be better equipped to understand how GitLab
    tackles other SDLC stages that are not discussed in this book.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this chapter will focus on introducing those concepts, terms, and
    components. Let’s dive in, starting with a GitLab component called a **project**.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing work into projects and groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Projects** are the fundamental building blocks of GitLab. A GitLab project
    represents a single software product that you are working on or a single non-software
    project that you are working on. Projects are where you store your files, and
    they are the starting point for navigating GitLab’s different features. In short,
    projects are where you spend most of your time as a GitLab user.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of typical projects, and who might use them:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A mobile phone app for finding a nearby car wash, used by development team
    #1'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A desktop version of the same car wash app, used by development team #2'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The documentation used by the technical writing team
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An upcoming conference, used by the event planning team
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Onboarding tasks for new employees, used by the entire company
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, some of these examples are software-related, but others have
    nothing to do with software. You can use projects to plan, manage, and track the
    progress of any kind of work. Although it’s true that most GitLab projects are
    focused on developing software, your company might find many non-technical uses
    for projects as well.
  prefs: []
  type: TYPE_NORMAL
- en: There’s no hard-and-fast rule for how to chop up your work into projects. For
    example, one company might decide to put all its documentation in a separate,
    documentation-specific project as described in the previous example. Another company
    might include the documentation files for each software product within the projects
    created for those products. Use whatever structure works best for you. Often,
    this requires some trial-and-error experimentation, so don’t be afraid to rejigger
    your use of projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s easiest to understand what a project is by seeing a picture of one. It
    won’t surprise you to know that GitLab is developed using GitLab tools. Here’s
    the project for the open source portion of GitLab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – The project for GitLab’s open source code ](img/Figure_3.01_B18073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – The project for GitLab’s open source code
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the list of files takes up the largest part of a project’s screen.
    What might not be obvious from the screenshot is that those files are actually
    a Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of a GitLab project as being a “wrapper” around a Git repository.
    Furthermore, you can consider the repository that lives in GitLab to be the “golden”
    copy of the repository, as discussed in [*Chapter 2*](B18073_02.xhtml#_idTextAnchor035).
    Because a project contains a Git repository, the project also gives you access
    to all the other things that a Git repository normally contains, including Git
    commits, Git tags, and Git branches. We’ll talk about how to view these components
    later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, you’ll find that you have a collection of projects that all hang
    together in some way. Here are some typical examples:'
  prefs: []
  type: TYPE_NORMAL
- en: Projects that all belong to the same team
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Projects for macOS and Windows versions of the same software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Projects that are all related to database management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When this happens, you can use a **GitLab group** to gather those related projects
    so they all exist in a single place within GitLab. You can think of GitLab groups
    as being similar to directories or folders that hold collections of projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'GitLab groups aren’t limited to holding GitLab projects: they can also hold
    other GitLab groups. You can have up to 20 levels of these subgroups within a
    GitLab group. You’re encouraged to use these subgroups in any way you want to
    organize your projects into related collections.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a sample structure of groups, subgroups, and projects that might help
    you understand the relationship between the three concepts. Imagine that there’s
    a company called Acme Anvils, whose IT team oversees developing software for selling
    its anvils. It also makes separate software that’s used for internal purposes
    such as inventory management. Their group hierarchy might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – A sample group and project hierarchy](img/Figure_3.02_B18073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – A sample group and project hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: 'Groups are more than just a way to collect related projects. You can also use
    them to establish roles and permissions. Using groups, you can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Invite other GitLab users to be members of a group.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Assign them a role within that group.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grant a user, group, or role permission to view or edit any projects within
    that group.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thus, groups provide a simple way to regulate access control to several users
    at once.
  prefs: []
  type: TYPE_NORMAL
- en: A group will also roll up components from all the projects within that group.
    For example, you can go to a single screen to see all the issues in all of the
    projects within a group.
  prefs: []
  type: TYPE_NORMAL
- en: But, groups don’t have to be complicated, and you don’t have to use all of their
    features. They’re a great way to simply collect related projects into a single
    place.
  prefs: []
  type: TYPE_NORMAL
- en: Enough theory about projects, groups, and subgroups. Now, it’s time to see those
    concepts in action.
  prefs: []
  type: TYPE_NORMAL
- en: Example – organizing your Hats for Cats work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cast your mind all the way back to [*Chapter 1*](B18073_01.xhtml#_idTextAnchor013),
    where we introduced your idea for a Hats for Cats web store. It’s time to get
    serious about setting up GitLab to help you develop that software.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say that you decide that Hats for Cats needs to exist in three different
    forms: a web app, an iOS app, and an Android app. You decide that although some
    of the logic will be similar between these three products, there are enough implementation
    differences so that each deserves its own project.'
  prefs: []
  type: TYPE_NORMAL
- en: '(Reminder: this chapter won’t tell you how to create, edit, or view projects
    or groups. As discussed at the start of this chapter, the official GitLab documentation
    is your best source of information for step-by-step instructions for working with
    any GitLab components or using the GUI. This chapter—and in fact the entire book—focuses
    on the *why* rather than the *how*.)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Because iOS and Android are both mobile platforms, you decide that it makes
    sense to collect those under a single group dedicated to mobile development. Then,
    you decide to collect that group, together with the web app project, under an
    umbrella group that comprises your entire Hats for Cats concept. Finally, you
    decide it makes sense to provide online documentation that is entirely platform-agnostic:
    it should apply equally to the iOS, Android, and web versions of the app. Because
    it isn’t tied to any of the existing projects, you want to create a new project
    just to hold the documentation.'
  prefs: []
  type: TYPE_NORMAL
- en: To realize this structure in GitLab, it’s often easiest to work from the top
    down, starting with groups and finishing with projects. You start by logging in
    to GitLab and creating the top-level **Hats for Cats** group, using all the default
    settings. (If you’d like to follow along, please take a look at the official GitLab
    documentation for explicit instructions on how to do this.) When that’s done,
    GitLab takes you to the home page for that group. Now you decide to create a subgroup
    called **Mobile** within the **Hats for** **Cats** group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it’s time to create the projects. (Again, GitLab documentation can explain
    the exact process for doing this, but fortunately, it’s very simple.) Imagine
    that you do the following in order to begin working on Hats for Cats:'
  prefs: []
  type: TYPE_NORMAL
- en: Make a project called **Documentation** inside the **Hats for Cats** group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a project called **Web** inside the **Hats for** **Cats** group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a project called **iOS** inside the **Mobile** subgroup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a project called **Android** inside the **Mobile** subgroup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you’re done, you end up with a group and project structure that looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Hats for Cats group and project hierarchy](img/Figure_3.03_B18073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Hats for Cats group and project hierarchy
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do a quick review before moving on:'
  prefs: []
  type: TYPE_NORMAL
- en: A project gives you a Git repository in which you can store your code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A project is also the central place from which you’ll do most of your work in
    GitLab.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several related projects can be collected within a group.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Groups can hold projects, other groups, or both.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By organizing your projects within groups and possibly subgroups, you can keep
    them well organized and easy to find, but you also gain the ability to assign
    permissions to other team members at the group level and have those permissions
    apply to all projects within the group.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Time to move on to the next fundamental building block of GitLab: **issues**.'
  prefs: []
  type: TYPE_NORMAL
- en: Tracking work with issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If a GitLab project is where a single product or initiative lives, a GitLab
    **issue** is where a single chunk of work lives. If you’ve used tools other than
    GitLab for planning and tracking work, you might have run across terms such as
    “story” or “ticket” to describe components that are similar to GitLab issues.
  prefs: []
  type: TYPE_NORMAL
- en: Issues live within GitLab projects, with each issue only belonging to one project
    (although they can be moved between projects). In addition to being linked to
    projects, issues are also linked to a huge number of other GitLab components,
    as you’ll see when we introduce you to those components. In fact, these linkages
    are a big part of what gives GitLab its power to reach across all 10 stages of
    the SDLC.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of a GitLab issue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'GitLab issues consist of several parts, of which these four are the most important:'
  prefs: []
  type: TYPE_NORMAL
- en: A **title**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **description**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Several optional **metadata** fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A threaded **discussion**, where team members can comment on the issue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at each of these issue components in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'The title is a short description of what the issue is about. For example, `Add
    a FAQ page`, `Fix bug #12`, or `Improve page load performance by 20%` are all
    reasonable issue titles. You don’t need to provide all the details about a feature
    in its title; that’s what the **description** field is for.'
  prefs: []
  type: TYPE_NORMAL
- en: The **Description** field can contain as little or as much text as you want.
    It can contain screenshots or links, and it makes full use of Markdown’s formatting
    features. It can also be edited later as more information comes to light or the
    exact direction of the issue changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Issues have several metadata fields. We won’t go over all of them, but here
    are some of the most important ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Assignee**: This field identifies the person or persons who own the issue,
    in the sense that they’re responsible for pushing it forward and serving as a
    point of contact if people have questions or comments about the issue that they
    don’t want to add to the issue’s discussion section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Due date**: There are several ways to use due dates in GitLab, but the most
    straightforward is to assign a due date directly to an issue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Labels**: We’ll discuss these in more detail later, but they serve to prioritize,
    route, or report on the progress of an issue, among other uses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Weight**: This field describes how much work you expect the issue to require.
    If you’re familiar with the Scrum method of project management, you’ve used the
    similar concept of “story points.” When assigning a weight to an issue, you can
    either use a concrete metric ( for example, person-hours) or a more abstract metric
    (for example, tiny tasks get one point, medium tasks get two points, and large
    tasks get three points). Every team has their own philosophy about this, which
    they develop with time and experience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to these explicit metadata fields, there’s another important piece
    of metadata about the issue: whether it is open or closed. Every issue starts
    with a status of **Open**. When someone completes the work required by an issue,
    they will normally change its status to **Closed**.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, every issue has a discussion section that lets people participate in
    threaded discussions, as you’d find on Facebook or Instagram. Because it’s threaded,
    people can reply to individual messages, or they can add entirely new messages.
    Discussions can include emojis, links, or images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since a picture is worth a thousand words, here’s a sample issue from your
    Hats for Cats project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Sample issue](img/Figure_3.04_B18073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Sample issue
  prefs: []
  type: TYPE_NORMAL
- en: Most projects contain many issues, with both **Open** and **Closed** statuses.
    GitLab makes it easy to see a list of all the issues in a project and to zoom
    in on any issues in the list to see the full details of that issue. You can also
    look at a list of issues from a group level instead of a project level. This view
    shows a list of all the issues that belong to any of the projects within that
    group. So, if you want to know how many issues are left to work on for both the
    iOS and Android versions of the Hats for Cats app, you can go up a level from
    the individual projects and look at a list of all the issues that have the **Open**
    status within the **Mobile** group.
  prefs: []
  type: TYPE_NORMAL
- en: The kinds of tasks that issues can represent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You might think that issues are only used to capture work related to software
    development, but that’s just the tip of the issue iceberg. Let’s look at the broad
    range of tasks that you can describe and track with a GitLab issue:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a feature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fix a bug.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write automated tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up a database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure a tool for the whole team to use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Research technical options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Brainstorm solutions to a problem.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plan an event.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Poll the team about preferences for coding standards.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Report and manage a security incident.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Propose an idea for a new product or a new feature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ask a question that anyone can provide an opinion on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Request T-shirt designs for an upcoming corporate outing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, there are many more possible uses for issues than are included in
    this short list. As you can see, they can be used for technical or non-technical
    work, and they can be used by a single person or an entire company.
  prefs: []
  type: TYPE_NORMAL
- en: To give one more possibly unexpected example, every new hire at GitLab is assigned
    an issue that includes *Welcome to the company* text and a long list of onboarding
    tasks for them to complete and check off. The employee’s manager and the company’s
    human resources department monitor this issue during the employee’s first few
    weeks to see how they are progressing through the onboarding process. Later, after
    onboarding is complete and the issue has been closed, the employee can use the
    issue as a reference source for company policies and procedures.
  prefs: []
  type: TYPE_NORMAL
- en: Labels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before explaining how you might realistically use issues, we need to introduce
    you to **labels**. These are colored tags containing a short bit of text. You
    can apply labels to issues or other GitLab components, such as merge requests
    (which we’ll discuss later), and remove them when they are no longer useful. You
    can define whatever labels you need for your project or group, and you can always
    add more labels or delete existing labels. Then, you can apply one or more labels
    to an issue to “mark” that issue with the contents of the label.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of commonly created labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '**High Priority**: Indicates an issue that needs to be worked on immediately'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**QA**: Indicates an issue that is the responsibility of the quality assurance
    team'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Status::Healthy**: Indicates an issue that is progressing according to the
    schedule'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Status::At Risk**: Indicates an issue that has fallen behind and needs extra
    resources to be assigned to it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Notice that the last two labels have double colons inside their descriptive
    text. The double colons have a special meaning: they turn these labels into **scoped
    labels**, which means they are mutually exclusive. That is, an issue can have
    the **Status::Healthy** label or the **Status::At Risk** label applied to it,
    but not both. Non-scoped labels—labels that don’t contain a double colon—can be
    applied in any combination to any issue. For example, you could apply both the
    **Front-end** and **DB** labels to an issue that needs work from both your frontend
    developer and your database administrator.'
  prefs: []
  type: TYPE_NORMAL
- en: GitLab uses hundreds of issues to prioritize, route, assign responsibility,
    and track work as it develops the GitLab product itself, so don’t be afraid to
    make and apply whatever issues you need; they’re free to create and easy to manage.
  prefs: []
  type: TYPE_NORMAL
- en: Issue workflows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with many GitLab components, there’s no single workflow for using issues
    that works well for every team in every situation. You’re encouraged to experiment
    and discover the best way to use issues for yourself considering your needs and
    team culture. But, we can present a *typical* workflow for issues, which you can
    use as a starting point when exploring possibilities for working with GitLab issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a sample workflow for one of your Hats for Cats projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Think up some work that needs to be done and figure out which project that
    work belongs to*. For example, as part of the Hats for Cats iOS project, you need
    to research the Objective-C and Swift programming languages to figure out which
    you should use for writing the iOS app.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Create an issue in that project and describe the work inside that issue*.
    You create an issue titled `Research languages for iOS` and add a description
    of the possible languages and your initial feelings about which might be the best
    to choose.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Add a weight to the issue*. You decide to use a metric of the total person-days
    expected and assign this issue a weight of two.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Set a due date for the issue*. You set the issue to be due in 3 days.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Assign labels to prioritize and route the issue*. You assign the **iOS** and
    **High Priority** labels to the issue. The former ensures that the right people
    monitor it, and the latter indicates that work on the issue needs to begin immediately.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Discuss the issue*. People who are working on the Hats for Cats iOS app chime
    in with their past experiences with the different iOS languages. Other people
    ask clarifying questions. Someone adds links to outside blog posts that discuss
    Swift and Objective-C. You add a screenshot of a language comparison table from
    a developer-focused website.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Assign the issue*. In the discussion, you ask your most experienced developer
    whether they’re willing to tackle this task. When they agree, you assign the issue
    to them so that everyone knows that they’re responsible for working on this issue
    and updating its progress.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Update labels*. As work progresses, the person to whom you assigned the issue
    updates its labels. For example, they might remove the **High Priority** label
    once it’s underway, and add a **Status::At Risk** scoped label when they realize
    that they’re unlikely to complete the research by the issue’s due date.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Close the issue when it is complete*. The developer to whom the issue was
    assigned completes their research and posts their findings in the issue’s discussion
    section. Then they close it, signifying that no more work remains to be done on
    the issue.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This wraps up your introduction to GitLab issues. You’ve seen what kinds of
    work you can describe in an issue, what data goes into an issue, and what workflow
    you might use when working on an issue. It’s hard to be an effective GitLab user
    without creating and using lots of issues, so it’s a great idea to practice creating,
    viewing, and editing issues as you get comfortable with GitLab.
  prefs: []
  type: TYPE_NORMAL
- en: Editing files safely with commits, branches, and merge requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the last chapter, you learned about using branches and commits in Git, where
    a branch is a series of commits, and a commit is a snapshot that consists of edits
    to one or more files. Because GitLab is in some senses a wrapper around a Git
    repository (although of course, it’s much more than that), branches and commits
    are also an important part of using GitLab. There’s a third, related concept that
    you’ll use frequently in GitLab: the **merge request** (often referred to as an
    **MR**). In this section, we’ll explain what an MR is and show you how to work
    with all three components in GitLab.'
  prefs: []
  type: TYPE_NORMAL
- en: GitLab often gives you more than one way to do something, and that’s true of
    working with commits and branches. You can either type commands into a terminal
    or use the GitLab GUI to perform most of the operations you’re likely to need
    for these two components. Because MRs are a concept that’s specific to GitLab
    and not Git, you’ll see that MRs require you to use the GitLab GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Before you can commit edits to a branch, you need to create the branch. Thinking
    back to the last chapter, you’ll remember that you can make a branch with the
    `git branch <BRANCH-NAME>` command followed by some form of the `git push` command
    to copy your branch up to the golden copy of your project’s repository. Alternatively,
    you can work primarily in the GUI by creating a new branch right inside GitLab
    and then copying that branch to your local copy of the repository (assuming you
    have a local copy) with a combination of `git fetch` and some form of `git pull`.
    Because the exact command depends on your situation, you should consult your favorite
    dedicated Git reference material for full information.
  prefs: []
  type: TYPE_NORMAL
- en: Although normally we won’t lead you through explicit instructions for using
    the GitLab GUI, creating branches, commits, and MRs is so fundamental to working
    effectively with GitLab that we’ll give you an overview of exactly how to work
    with these through the GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by creating a branch. Because a branch is a part of a Git repository,
    and a GitLab project is nothing more than a GitLab repository with a ton of extra
    features, it makes sense to create a branch within a GitLab project. For example,
    imagine that you want to add an `allow-password-change` branch to the Hats for
    Cats Android app so your developers can add a feature that lets users manage their
    passwords.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how to add that branch:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate through your group structure and open the **Android** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the navigation pane on the left-hand side of the page, click **Repository**
    > **Branches**. This takes you to a list of branches that exist in the project’s
    repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the **New branch** button, fill in the branch’s name, hit the **Create
    branch** button, and you’re done:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.5 – List of branches within a project](img/Figure_3.05_B18073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – List of branches within a project
  prefs: []
  type: TYPE_NORMAL
- en: 'After you’ve created a branch, you can commit edits to it. Once again, there
    are two ways to do this. You’ve already learned about the three-command sequence
    that you can use in a terminal: `git add <FILE-NAME>` followed by `git commit
    --message "<MESSAGE>"` followed by `git push`. But, if you’d rather work within
    GitLab, here’s what you need to do:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the project’s repository by clicking **Repository** > **Files**
    in the left-hand navigation pane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure you’re working in the right branch by clicking the branch name dropdown
    near the top left of the page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Selecting a branch in a project](img/Figure_3.06_B18073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Selecting a branch in a project
  prefs: []
  type: TYPE_NORMAL
- en: Within the repository’s list of files, click the name of the file you want to
    edit. This will display its contents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Edit in Web IDE** to open an in-browser editor, and make any changes
    needed to the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you’d like to edit more files within this commit, click on the next file’s
    name in the file browser toward the left of the page and make any edits you want
    to its contents.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you’re done making changes, click **Commit…** and enter a commit message.
    If you haven’t created a merge request for this branch yet, it’s usually a good
    idea to check the **Start a new merge request** checkbox. Click **Commit** and
    you’re done.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you’ve cloned the repository to your local machine, you might want to use
    `git checkout <BRANCH-NAME>` followed by `git pull` to copy the commit you just
    made to your local repository, but you can often get away with doing this occasionally
    instead of after every commit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Commit your edits](img/Figure_3.07_B18073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Commit your edits
  prefs: []
  type: TYPE_NORMAL
- en: Editing files and committing changes directly to your project’s repository without
    ever touching a terminal is one of the great joys of using GitLab, so it’s well
    worth practicing this feature until it becomes a part of your normal workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Making branches doesn’t do you any good unless you can switch between them,
    so you can view or edit the contents of whichever branch you want. You’ve seen
    how to do this from the command line using `git checkout <BRANCH-NAME>` or `git
    switch <BRANCH-NAME>`. It’s just as easy to switch branches within the GUI: just
    find the branch dropdown that exists at the top left of many pages and switch
    to your preferred branch. It can be easy to forget which branch you’re on, so
    it’s good to get in the habit of quickly checking this dropdown from time to time
    to keep yourself oriented.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'It probably goes without saying, but we’ll say it anyway: switching the branch
    using a terminal command only changes the branch that you’re on in your local
    repository and not the branch that you’re on in the golden copy of the repository
    hosted on GitLab. Similarly, changing the branch in the GitLab GUI only changes
    the branch that you’re on in the GitLab-hosted repository, not the branch that
    you’re on in your local repository. So, don’t switch in one location and assume
    that you’ve also switched on the other; the local and remote copies of your repository
    are completely independent when it comes to keeping track of which branch you’re
    on.'
  prefs: []
  type: TYPE_NORMAL
- en: Commit history
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most common operations with a Git repository is to look at the history
    of the commits on a particular branch, as seen in *Figure 3**.8*. As you learned
    in [*Chapter 2*](B18073_02.xhtml#_idTextAnchor035), running `git log` in a terminal
    will show you a reverse-chronological history of all commits made to whatever
    branch you’re on in the local repository, along with the author, timestamp, **Secure
    Hash Algorithm** (**SHA**), and commit message of each commit. You can do the
    same thing in the GitLab GUI by navigating to the main page of a project, selecting
    the branch you’re interested in from the branch dropdown, and clicking the **History**
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – List of commits on a branch](img/Figure_3.08_B18073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – List of commits on a branch
  prefs: []
  type: TYPE_NORMAL
- en: The history is a list of commits on this branch, with the most recent at the
    top of the list. This list includes the same information about each commit as
    you would get from the `git log` command. A nice bonus of using a GUI such as
    this is that you can click on any commit within the list to see every edit made
    to every file in the commit, displayed in an easy-to-read side-by-side format
    (switchable to an inline format, if you find that easier to parse visually). Of
    course, you can get this same information within a terminal with the `git diff`
    command, but that output is not nearly as easy to read as the output shown in
    the GitLab GUI.
  prefs: []
  type: TYPE_NORMAL
- en: Merging one Git branch into another
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Merging a branch into another branch is the first action that’s performed significantly
    differently in the GUI versus in a terminal. As you will remember, you can merge
    `branch-a` into `main` (to pick two sample branch names) from the command line
    using `git checkout main` followed by `git merge branch-a`. But, doing this same
    operation in the GitLab GUI requires an MR. This is one of the most important
    and often used parts of GitLab, so it’s a critical thing to understand and get
    practice with. It’s important to understand that a merge request is the *only*
    way to merge one branch into another from within the GitLab GUI. Here’s a sample
    merge request from one of your Hats for Cats projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Sample merge request](img/Figure_3.09_B18073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Sample merge request
  prefs: []
  type: TYPE_NORMAL
- en: Merge requests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A merge request is exactly what it sounds like: a GitLab component that represents
    a request that somebody (maybe you, maybe somebody else) merge one branch into
    another in the golden copy of the repository on a GitLab instance. A merge request
    looks a lot like an issue. It contains many of the same fields, including a title,
    a description, an assignee, and a threaded discussion.'
  prefs: []
  type: TYPE_NORMAL
- en: But, merge requests add a few extra fields that don’t exist in issues. These
    include the `branch-a` into `main`, the source branch would be `branch-a` and
    the target branch would be `main`.
  prefs: []
  type: TYPE_NORMAL
- en: Merge requests also display the Git commits that are on the source branch, and
    collect all the edits from each commit into a single screen within the MR. This
    lets you see exactly how merging the source into the target would affect the files
    of the target branch.
  prefs: []
  type: TYPE_NORMAL
- en: Another aspect of merge requests that separates them from issues is that they
    contain a special pane that displays the results of the automated tests and scans
    that the CI/CD pipeline has performed on the code in the branch. We’ll talk about
    this pane in more detail later, but you can think of it as a one-stop shop for
    showing the overall status of the code that you’re developing. Is it doing what
    it’s supposed to do? Does it have security vulnerabilities? Is it introducing
    dependencies that use unacceptable software licenses? In short, by looking at
    this pane, you can quickly see whether the work you’re doing on the branch is
    making the overall software product better or worse. This is a very handy feature,
    for sure!
  prefs: []
  type: TYPE_NORMAL
- en: Finally, merge requests contain a big, impossible-to-miss **Merge** button.
    The mission of a merge request is to merge one branch’s commits into another branch,
    so it would be useless if it didn’t give users a way to perform the merge. There
    are many reasons this button might be grayed-out and unclickable, thereby blocking
    the merge from happening.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list is some examples of why a merge might be blocked. Note that
    most of these blocking behaviors are configurable, so you can decide which works
    best for your team:'
  prefs: []
  type: TYPE_NORMAL
- en: The merge request title starts with `Draft`. This indicates that the branch
    associated with the merge request is still a work in progress, and the developer
    does not intend for it to be merged yet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitLab’s license scanner (more about this in a later chapter) detects that the
    merge request is introducing a dependency with a license that’s incompatible with
    the overall project’s license.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated tests fail for the most recent commit to the branch associated with
    the merge request.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One or more discussion threads in the merge request are unresolved.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The merge request hasn’t received enough approvals, or approvals from the right
    people, to satisfy the approval rules. We’ll describe this in more detail next.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing and approving code in merge requests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Because merge requests have the power to alter the files in the target branch,
    and the target branch is almost always `main`, `master`, or whatever branch holds
    your stable, production-ready code, it’s critical that every MR is scrutinized
    by members of the development team. Fortunately, merge requests have several features
    to enable code reviews:'
  prefs: []
  type: TYPE_NORMAL
- en: You can **link comments directly to one or more lines in a file**, so it’s obvious
    which lines of code you’re referring to when you make suggestions for improving
    them (or when you praise them).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can **propose alternative code** right in the discussion section. These
    proposals even include a button that allows the original author to accept your
    suggestions with a single click on the GUI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can **assign reviewers** from your team. They will receive notifications
    via email saying that you’d like them to review the edits in your merge request.
    These reviewers are listed in a metadata field in the MR, so everyone on your
    team knows who has been asked to review the files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Team members can **approve your code**. This is a separate concept from reviewing
    your code. Reviewing is usually a repeated process that consists of a review,
    followed by the original author making fixes in response to your review, followed
    by another review, followed by more fixes, and so on. An approval is a single,
    one-time “thumbs up” that means that the approver considers your edits to be ready
    to merge.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can create **rules for who must approve your MR** before it can be merged.
    These rules can become quite complicated and can involve several groups of people.
    Here are three sample rules for who must approve a merge request in order for
    it to be unblocked:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 1**: Either the tech lead or the architect for your team'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 2**: Your development team manager'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 3**: Any one of the three members of the quality assurance team, plus
    any one of two members from the security team, plus two of the three architects'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, MRs are critical to getting your edits reviewed, approved, and
    merged into the right branch.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a merge request before you commit code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several ways to create merge requests, including a few shortcuts that
    GitLab provides in possibly unexpected (but helpful) places. As we’ve done previously
    when describing other GitLab components, we’ll ask you to look at the official
    GitLab documentation for up-to-date instructions on how to use the GUI to create,
    view, and manage merge requests.
  prefs: []
  type: TYPE_NORMAL
- en: However, we should definitely give you some guidance on *when* to create merge
    requests. This might sound odd or counterintuitive, but *we recommend that you
    create a merge request for a branch immediately after creating the branch, before
    you’ve committed any code to* *the branch*.
  prefs: []
  type: TYPE_NORMAL
- en: This advice probably sounds especially strange if you’ve used tools like GitHub
    before. GitHub’s merge requests (known as **pull requests**) are usually created
    *after* you’ve committed all the code you intend to put on a branch. After all,
    if the purpose of a merge request is to merge the source branch’s edits into the
    target branch, what’s the point of opening a merge request when there isn’t any
    code on the source branch to merge?
  prefs: []
  type: TYPE_NORMAL
- en: Using a merge request as a dashboard for your code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two reasons why making MRs early in the workflow is such a widely
    accepted best practice among GitLab users. First, an MR serves as a “dashboard”
    that lets you know about the overall quality of the code you’re adding to the
    branch. The dashboard answers questions like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Are automated tests passing?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does your code meet performance requirements?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has your code introduced any security vulnerabilities?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it adds any new third-party dependencies, do they use licenses that are compatible
    with your overall project license?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does your code satisfy style and quality requirements?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you distribute your app as a Docker image, are there any known security vulnerabilities
    in the base Docker image that your code is packaged with?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These results are all available for viewing in other parts of the GitLab GUI,
    but it’s convenient to see them all neatly presented within an MR.
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, when you view the results within the MR, you see a “delta”
    view of these results. In other words, the results in the MR will tell you how
    the test and scan results for the MR’s associated branch *differ* from the results
    of the same test and scans as run against your default branch. This is incredibly
    valuable because it lets you know whether the code that you are contributing to
    the branch is headed in the right direction. To put it simply, *are your commits
    to the branch making your software better or worse?*
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if you wait to create a merge request until you’re all done coding,
    you won’t benefit from this constant guidance on whether you’re on the right track
    with your commits. This is, all by itself, a great reason to create an MR before
    you’ve committed any code to your branch.
  prefs: []
  type: TYPE_NORMAL
- en: Merge requests improve collaboration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'But, there’s another compelling reason to create your MR early in the development
    workflow: *merge requests encourage collaboration among team members*. By providing
    an area for threaded discussions, they let your coworkers review and comment on
    every commit you make. Are you introducing subtle bugs? Your coworkers can spot
    them and alert you when they’re still easy to fix. Are you starting to code an
    algorithm that’s not as fast as an alternative? Someone can let you know before
    you commit many hours and lines of code to build the wrong thing. Are you misusing
    certain idioms in your programming language? If a senior developer can point that
    out early in the process, you can adjust your style before committing any more
    code to the branch.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These scenarios all share a common theme: by collaborating early and often,
    by reviewing small pieces of code that arrive in a single commit, problems become
    easier to spot and cheaper to fix. MRs are exactly the place where this kind of
    collaboration can occur.'
  prefs: []
  type: TYPE_NORMAL
- en: Anyone who has been asked to review a completed feature that consists of 3,000
    lines of code knows the sinking feeling of being unsure where even to begin. Or
    the despair you feel when you realize that the developer has misunderstood the
    specifications and not built the feature that the product owner intended. Or the
    awkwardness that comes from pointing out a programming or style error that the
    developer has made hundreds of times throughout the feature’s code. All these
    situations can be avoided by frequent reviews of small pieces of code. And, that’s
    only possible when you have a merge request ready to go before the first commit
    lands.
  prefs: []
  type: TYPE_NORMAL
- en: The frequent collaboration enabled by merge requests not only helps the folks
    who are reviewing the code but also helps the author of that code. In the same
    way that automated test failures are easier to troubleshoot and fix when the commit
    that caused the failures consists of small pieces of code, it’s also easier to
    fix style problems, suboptimal algorithms, or bugs when a code reviewer spots
    those problems in a 12-line piece of code than it is when they call out those
    problems in 3,000 lines of code that make up the completed feature or bug fix.
    It’s far better and easier to adjust your coding practices early in the development
    process than it is to have to go back and make potentially complicated or even
    destabilizing fixes after you thought you were done coding.
  prefs: []
  type: TYPE_NORMAL
- en: These principles apply to security vulnerabilities as well. A truism in software
    is that you must take security into account throughout the entire development
    workflow; you can’t just tack it on at the end. The frequent security scan results
    that show up in merge requests help make it possible to honor this principle by
    “baking in” security from the very beginning of the development workflow. Code
    reviews by experienced developers or members of your security team also help achieve
    this goal, and the MR discussion pane is exactly where that sort of code review
    takes place. This principle of “shifting left”—which we’ve discussed earlier in
    this book—is especially important when it comes to security. This is because security
    problems sometimes require extensive rethinking and reworking of basic architectural
    decisions in your software. This kind of repair is much easier, cheaper, and less
    disruptive when the code base is smaller and simpler, as it tends to be when work
    has just begun on a new feature.
  prefs: []
  type: TYPE_NORMAL
- en: The three amigos – issues, branches, and merge requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You now know quite a bit about issues, branches, and merge requests. It’s important
    to understand that these three GitLab components are closely related when they’re
    used to plan and accomplish a programming task.
  prefs: []
  type: TYPE_NORMAL
- en: 'GitLab recommends a particular workflow for these three components. They suggest
    that you first create an issue as soon as you’ve identified work to be done. As
    soon as that issue is assigned to a developer, the developer should immediately
    make a branch to work on, and then create a merge request for that branch. The
    issue, branch, and merge request should all have similar (or sometimes even identical)
    titles to show that they are related to each other. For example, if you saw these
    components, you’d know from their titles that they all address the same task:'
  prefs: []
  type: TYPE_NORMAL
- en: '`simplify the` `login process`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`simplify-login-process`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`simplify the` `login process`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because issues, branches, and merge requests are so closely related, and because
    all three are usually required when completing any coding work with GitLab, you’ll
    sometimes see them referred to as the **three amigos**. If you’re not sure how
    to start work on a programming task, a good rule of thumb is to make sure you
    have the three amigos all lined up before you write any code.
  prefs: []
  type: TYPE_NORMAL
- en: When two amigos are enough
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: However, it’s also worth mentioning that you don’t *have* to have all three
    components for every task. If a task doesn’t require you to edit any files in
    your repository, there’s no need for a branch, which means there’s also no need
    for a merge request. You might remember that, earlier, we said that a possible
    use case for an issue would be to solicit T-shirt designs for an upcoming corporate
    event. Those T-shirt designs could all be added directly to the issue’s discussion
    section. You don’t need to edit any files to satisfy the requirements of that
    task, so you could get away with not making a branch, and not making an associated
    merge request. In fact, making a branch and merge request issue would probably
    be confusing to your coworkers because it suggests that you *do* expect files
    to be edited while completing this work.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, there are cases where you need a branch and merge request, but don’t
    need an issue. For example, imagine that you need to fix a tiny, trivial typo
    in your code. You *could* make an issue describing the problem, but that’s probably
    overkill for such a small edit. It seems more appropriate in this case to simply
    make a branch and merge request, then make a single commit that fixes the typo,
    and then ask for review and approval of the MR. Most GitLab users would probably
    agree that no issue is needed (although no harm would come from making one). Having
    said that, some organizations might decide that every MR requires a related issue,
    which is also a perfectly acceptable policy, even if it occasionally leads to
    some extra work.
  prefs: []
  type: TYPE_NORMAL
- en: How are issues and merge requests different?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might find yourself wondering how issues and merge requests differ. We’ve
    already discussed the extra kinds of information that merge requests contain,
    but there’s a philosophical difference between the two components that’s helpful
    to keep in mind. Think of issues as being the place to present and discuss **ideas**.
    A merge request, on the other hand, is where you present and discuss **code**.
    If you use this concept to distinguish the two, that will help you understand
    when just one of them is needed versus when both are needed. It also helps you
    understand whether any comments you might have are better suited to the discussion
    section in the issue (if you’re talking about the general idea of the work) or
    the discussion section in the merge request (if you’re talking about the specific
    code delivered by a developer).
  prefs: []
  type: TYPE_NORMAL
- en: Another difference between issues and merge requests is the different status
    values they can have. Issues can be **open** or **closed**, whereas merge requests
    can be **open**, **closed**, or **merged**. In fact, closed merge requests are
    somewhat rare, as that status is only used when you abort a merge request instead
    of following through with the merge. That does happen sometimes, but the far more
    common outcome for a merge request is for it to transition to the **merged** status
    once its associated branch is merged.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you’ve seen how to use the GitLab GUI to deal with fundamental concepts
    such as commits, branches, and merge requests. You’ve also been shown how issues
    and merge requests may look similar at first glance, but serve importantly different
    roles within GitLab. You understand why it’s important to create a merge request
    before you’ve committed any edits to merge, and how merge requests support close,
    frequent collaboration among team members. Finally, you know about the three amigos
    of issues, branches, and merge requests, and you understand how they work together
    to help you plan work, complete work, and merge any code changes that result from
    that work. In other words, you’ve been exposed to all of the fundamental building
    blocks of using GitLab to write software, even if you’re still in the dark about
    how GitLab verifies, secures, packages, and deploys the software once you’ve written
    it. But, we’ll get there soon, we promise!
  prefs: []
  type: TYPE_NORMAL
- en: Enabling DevOps practices with GitLab flow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s end this chapter by seeing how issues, branches, and merge requests fit
    together in a realistic example. This shows GitLab’s recommended best practice
    for how to use all the components you’ve been introduced to in a smooth workflow
    that works for most situations. In fact, this workflow is so strongly recommended
    and so well proven over time that GitLab even has a name for this workflow: **GitLab
    flow**. As always, you’re encouraged to treat this workflow as a starting point
    when developing your own processes and procedures; feel free to tinker with it
    as needed for your team, product, and organizational culture.'
  prefs: []
  type: TYPE_NORMAL
- en: 'While working on the Hats for Cats web app, you decide to add a feature that
    lets you filter the hats by cat breed. After all, a cowboy hat for a large-headed
    Maine Coon might swamp the dainty head of a Devon Rex. Here are all the steps
    prescribed by GitLab flow to bring that feature into existence:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Filter hats by breed`, leaving all metadata fields empty.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the issue’s discussion section, you mention two people who you think might
    have opinions on whether this feature is a good idea.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both those people add replies to the discussion section. One just leaves a thumbs-up
    emoji. The other expresses support for the idea but asks whether the app should
    filter by other criteria as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You decide that filtering by other criteria is a good idea, but you’re not
    sure what those criteria should be. You make another issue titled `Question: what
    criteria should we use when filtering hats?` You set this issue aside to deal
    with later and return your focus to the `Filter hats by breed` issue because you’re
    confident that breed should be one of the criteria.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At a team-wide planning meeting, the group decides to assign the issue a weight
    of 8, which for your team means it’s expected to be a 1-week task. You assign
    the issue to a backend developer named Elizabeth, and you set its due date field
    to 2 weeks from today.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Elizabeth applies a *scoped* **Status::In Progress** label and an *unscoped*
    **Back-end** label to the issue. This will help the team keep track of whether
    the issue is on track and understand who is responsible for it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Elizabeth makes a temporary branch called `filter-hats-by-breed` to hold her
    commits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Elizabeth creates a merge request titled `Draft: Filter hats by breed`. She
    assigns teammates Alice and Bob to review the merge request. They have nothing
    to do yet since Elizabeth hasn’t added any code to the MR’s branch.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that Elizabeth has the three amigos of issue, branch, and merge request
    set up, she starts coding.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After she finishes a small, testable chunk of code, she commits it to her branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Elizabeth looks at the MR to see the results of the automated tests, code quality
    scans, license scans, and security scans that ran against her first commit. They
    don’t report any problems, so she celebrates with a mug of Assam tea with extra
    sugar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alice and Bob get email notifications that Elizabeth has committed code to the
    MR’s branch. They look at the MR and review her changes. Both add some comments
    about what parts of her code they like, and what parts can be improved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some of the suggestions seem wrong to Elizabeth, so she adds comments in the
    MR’s discussion section explaining her point of view. She continues to talk it
    out until they all reach an agreement about how she should proceed. Elizabeth
    adds a new commit with the agreed-upon fixes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once again, Elizabeth looks in the MR to see the results of automated tests
    and scans against her last commit. One of the security scans points out a vulnerability
    that she unwittingly introduced. She quickly adds a new commit that fixes the
    vulnerability. The scans run again on this fixed code, and this time it’s smooth
    sailing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Elizabeth gets a thumbs-up review from both Alice and Bob on all the code she’s
    committed so far, so her work is done. She removes the **Back-end** label, adds
    a **Front-end** label, and re-assigns the issue to a frontend engineer named George.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: George writes some frontend code and adds a few commits to the same `filter-by-breed`
    branch that Elizabeth was using. Each commit triggers a new run of automated tests
    and scans, and each is reviewed by Alice and Bob.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: George realizes that the work is falling behind schedule, so he adds an **At
    Risk** label to the original issue. The development manager responds to this by
    assigning another frontend developer named Helen to help George.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The cycle of commit-then-review-then-inspect-automated-test-and-scan-results
    continues for a few more rounds until George and Helen complete the feature. They
    remove the **At Risk** label. Alice and Bob are satisfied with the code, and both
    add thumbs-up emojis to the discussion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: George removes `Draft:` from the title of the issue, indicating that he considers
    the code ready to be merged.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: George mentions the security and QA teams in the MR’s discussion so they can
    approve it. Until they do, the **Web** project’s approval rules block the MR from
    being merged.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One member of the security team and two members of the QA team mark the MR as
    “approved.” This re-activates the MR’s merge button. With great glee and a feeling
    of accomplishment, George removes the **Front-end** and **Status::In Progress**
    labels and clicks the MR’s merge button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The whole team goes out to a pub to celebrate and eats an uncomfortable quantity
    of pizza.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s a diagram showing this flow, but with some steps removed for clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Major steps in GitLab flow](img/Figure_3.10_B18073.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – Major steps in GitLab flow
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve been exposed to an awful lot of concepts and terminology in this chapter,
    so let’s do a quick review.
  prefs: []
  type: TYPE_NORMAL
- en: GitLab is a web application whose mission is to solve many of the problems faced
    by people involved with any of the 10 stages of the SDLC. So, GitLab doesn’t solve
    just one problem; it solves many problems that exist in many different facets
    of software development.
  prefs: []
  type: TYPE_NORMAL
- en: Working with GitLab happens mostly within a GitLab project, which represents
    one software product, one portion of your org chart, or one initiative. Projects
    that share a similar theme can be collected within GitLab groups, and groups can
    also contain subgroups.
  prefs: []
  type: TYPE_NORMAL
- en: Each individual task or chunk of work is recorded in a GitLab issue. Issues
    describe the work to be done, allow team members to participate in a discussion
    about the issue, and include many fields to store metadata about the issue. Issues
    usually represent software-related tasks, but can (and should) be used to describe,
    plan, and track non-technical work as well.
  prefs: []
  type: TYPE_NORMAL
- en: You can create *scoped* or *unscoped* labels to highlight issue statuses or
    health, or to indicate which person or team is responsible for doing work on the
    issue. You can assign labels to merge requests as well as issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'A GitLab merge request is the component you use for merging one branch into
    another within the GitLab GUI. Each merge request lists a source branch and a
    target branch, and merging the merge request will cause any commits that were
    only on the source branch to be added to the target branch. Merge requests look
    similar to issues, but they serve different purposes: the former is used for describing,
    discussing, and merging code. The latter is used for describing and discussing
    ideas and tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the GitLab GUI for performing many common Git-related tasks
    besides managing merge requests. For example, you can use the GUI to create a
    branch, add a commit, show a list of commits on a branch, or assign a tag to a
    commit.
  prefs: []
  type: TYPE_NORMAL
- en: GitLab flow is the best practice workflow for using all of the GitLab components
    in a proven, reliable way to build software. You’re not required to use GitLab
    flow, but it’s a great starting point for figuring out what workflow and policies
    work best for your organization or team.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we’ve been dancing around a central part of GitLab flow: the **CI/CD
    pipelines** that run countless different checks on your code once you’ve committed
    it to a repository. In the next chapter, we’ll tackle it head-on, and get to the
    heart of what is possibly GitLab’s most powerful and most helpful feature.'
  prefs: []
  type: TYPE_NORMAL
