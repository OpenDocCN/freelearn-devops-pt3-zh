- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Understanding GitLab Components
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 GitLab 组件
- en: 'GitLab is a huge, complicated web app that aims to be a “one-stop shop” for
    making every step of the software development life cycle easier: it helps you
    to plan, create, test, secure, and deploy software. And those are just the big
    tasks it covers! It also helps you track progress using a variety of workflows,
    document projects, create release notes, store Docker images or other types of
    software packages, host static web pages, monitor the performance of deployed
    applications, and watch for suspicious network traffic within Kubernetes clusters.
    This list could be much longer, but you get the picture: *GitLab helps with most
    of the tasks involved in the standard software development* *life cycle.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab 是一个庞大而复杂的 Web 应用程序，旨在成为软件开发生命周期中每个步骤的“一站式商店”：它帮助你规划、创建、测试、保障和部署软件。这些仅仅是它涵盖的大任务！它还帮助你通过多种工作流跟踪进展、记录项目、创建发布说明、存储
    Docker 镜像或其他类型的软件包、托管静态网页、监控已部署应用的性能，以及监控 Kubernetes 集群中的可疑网络流量。这个列表可以更长，但你明白了：*GitLab
    有助于完成标准软件开发生命周期中的大部分任务* *。*
- en: In [*Chapter 1*](B18073_01.xhtml#_idTextAnchor013), we articulated key problems
    in the software development life cycle that GitLab was designed to solve. Now,
    we’ll introduce you to the key GitLab concepts and components that you’ll need
    to be familiar with in order to use it effectively. Once you understand these
    building blocks, you’ll be ready to start the work of setting up CI/CD pipelines,
    which we will begin to address in [*Chapter 4*](B18073_04.xhtml#_idTextAnchor084).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 1 章*](B18073_01.xhtml#_idTextAnchor013)中，我们阐明了 GitLab 旨在解决的关键软件开发生命周期问题。现在，我们将向你介绍一些关键的
    GitLab 概念和组件，这些是你有效使用 GitLab 时需要熟悉的内容。一旦你理解了这些基础，你将准备好开始设置 CI/CD 流水线，我们将在[*第 4
    章*](B18073_04.xhtml#_idTextAnchor084)中开始讨论这个话题。
- en: In this chapter, we’ll discuss projects, groups, issues, branches, and merge
    requests. We’ll then bring those GitLab components to life by showing you how
    to create, manage, and use some of those concepts in the application’s GUI. When
    you’re comfortable with these fundamentals, you’ll learn how to use **GitLab flow**,
    which is a best practice workflow recommended by GitLab’s developers for effectively
    combining the tool’s various building blocks as you write, test, secure, and deploy
    software.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论项目、小组、问题、分支和合并请求。接着，我们将通过向你展示如何在应用程序的 GUI 中创建、管理和使用这些概念，使这些 GitLab
    组件栩栩如生。当你熟悉了这些基础后，你将学习如何使用 **GitLab flow**，这是 GitLab 开发人员推荐的一种最佳实践工作流，用于在编写、测试、保障和部署软件时有效地结合工具的各个组成部分。
- en: 'This is how the main topics appear in the chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要主题如下：
- en: Emphasizing the “why” over the “how”
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强调“为什么”而非“如何”
- en: Introducing the GitLab platform
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 GitLab 平台
- en: Organizing work into projects and groups
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将工作组织成项目和小组
- en: Tracking work with issues
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用问题跟踪工作
- en: Editing files safely with commits, branches, and merge requests
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用提交、分支和合并请求安全地编辑文件
- en: Enabling DevOps practices with GitLab flow
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 GitLab flow 启用 DevOps 实践
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You’ll benefit most from this chapter if you’re able to follow along by logging
    into an account on a GitLab instance. This account can be an account on the instance
    hosted at gitlab.com (also known as a **Software-as-a-Service** (**SaaS**) instance),
    or an account on an instance hosted by your company (known as a self-managed,
    a self-hosted, or an on-premises instance). You could even host GitLab on your
    own hardware at home or on a virtual machine in the cloud, using a service such
    as AWS EC2, Google Cloud Platform, or Microsoft Azure.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能通过登录到 GitLab 实例上的账户来跟随本章内容，你将从中受益最大。这个账户可以是托管在 gitlab.com 上的实例账户（也称为 **软件即服务**
    (**SaaS**) 实例），或者是托管在你公司上的实例账户（称为自管理实例、自托管实例或本地实例）。你甚至可以将 GitLab 托管在你自己的硬件上，或者通过
    AWS EC2、Google Cloud Platform 或 Microsoft Azure 等服务在云中的虚拟机上托管。
- en: Hosting your own instance is not as far-fetched as it sounds, thanks to surprisingly
    low hardware requirements—you can even host GitLab on a Raspberry Pi!—and a variety
    of “Omnibus” Linux packages that contain everything you need for an entire GitLab
    instance. We’ll refer you to the GitLab installation documentation at [https://about.gitlab.com/install](https://about.gitlab.com/install)
    for more information if you want to go down this path.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 由于GitLab的硬件要求非常低——你甚至可以在树莓派上托管GitLab——并且有多种包含所有GitLab实例所需内容的“Omnibus”Linux安装包，因此托管自己的实例并不像听起来那么不可思议。如果你想走这条路，我们将引导你查看[https://about.gitlab.com/install](https://about.gitlab.com/install)上的GitLab安装文档，获取更多信息。
- en: If you’d prefer to let someone else take care of installation, administration,
    and upgrade tasks for you, head over to [https://gitlab.com](https://gitlab.com)
    and sign up for a free account on their SaaS platform. Although there are minor
    feature differences between the SaaS and self-managed varieties of GitLab, they
    are so small that we won’t discuss them in this book. For all intents and purposes,
    the feature sets of SaaS GitLab and self-managed GitLab are identical.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更愿意让别人来为你处理安装、管理和升级任务，可以访问[https://gitlab.com](https://gitlab.com)并在他们的SaaS平台上注册一个免费账户。虽然SaaS版和自托管版GitLab之间有一些小的功能差异，但这些差异非常微小，因此我们在本书中不会讨论它们。从实际用途来看，SaaS版GitLab和自托管版GitLab的功能集是相同的。
- en: 'As of early 2023, GitLab has three **product tiers**: Free, Premium, and Ultimate.
    The first of these tiers is open source and free for everyone to use. It also
    has the most limited feature set. The Premium tier requires a paid license but
    adds some extra features. The Ultimate tier costs more than Premium but unlocks
    the entire GitLab feature set. These tiers apply to both SaaS and self-managed
    installations.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 截至2023年初，GitLab有三个**产品套餐**：免费版、Premium版和Ultimate版。第一个套餐是开源的，任何人都可以免费使用，但它的功能最为有限。Premium版需要付费许可证，但增加了一些额外功能。Ultimate版的价格高于Premium版，但解锁了完整的GitLab功能集。这些套餐适用于SaaS版和自托管版的GitLab。
- en: This book will discuss some features that are available in the Free tier, some
    that are available only in the Premium and Ultimate tiers, and some that are only
    unlocked with an Ultimate license. If you are on a budget, don’t worry. GitLab
    has plenty of functionality to improve your life as a software developer, even
    with the lower tiers. Many people find the Free tier to be all they ever need,
    especially if they mainly use GitLab for personal hobby projects.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将讨论一些在免费套餐中提供的功能，也会介绍一些仅在Premium和Ultimate套餐中可用的功能，还有一些功能只有在Ultimate许可证下才能解锁。如果你的预算有限，不用担心。即使在较低的套餐中，GitLab也有足够的功能来提升你作为软件开发者的工作效率。许多人发现免费套餐已足够满足他们的需求，尤其是如果他们主要使用GitLab来做个人爱好项目的话。
- en: Emphasizing the “why” over the “how”
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强调“为什么”而非“如何”
- en: Before we get started, a word of warning. For the most part, this book will
    not lead you through step-by-step instructions on what to click in the GitLab
    GUI in order to perform various operations.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，有一句警告。大多数情况下，本书不会逐步引导你点击GitLab GUI中的每个操作步骤。
- en: First, instructions for most operations are already well covered in GitLab’s
    official documentation, which is remarkably clear and thorough.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，大多数操作的指令已经在 GitLab 官方文档中得到了很好的覆盖，文档内容清晰且详尽。
- en: Second, because GitLab is in rapid development, its GUI often changes. These
    changes are rarely radical, workflow-breaking changes, but they are significant
    enough that screenshots, or even bullet-pointed instructions for how to perform
    operations, can quickly get stale. This means that any concrete instructions in
    this book could become confusing or impossible to follow, or potentially even
    lead to data loss, as the GitLab GUI drifts over time. To avoid that problem,
    we’ll mostly focus on *why* you might want to use different GitLab features. Although
    we’ll give you a general picture of *how* to use those features, we usually won’t
    provide detailed instructions for every configuration option or workflow.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，由于GitLab正处于快速开发中，其图形用户界面（GUI）经常发生变化。这些变化通常不是激烈的、破坏工作流的变化，但它们足够显著，以至于截图或如何执行操作的逐条指令很容易变得过时。这意味着本书中的具体指令可能会变得让人困惑或无法执行，甚至可能导致数据丢失，因为随着时间推移GitLab的GUI会发生变化。为了避免这个问题，我们将主要关注*为什么*你可能想要使用不同的GitLab功能。虽然我们会给你一个*如何*使用这些功能的整体框架，但通常不会提供每个配置选项或工作流的详细操作指引。
- en: Introducing the GitLab platform
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍GitLab平台
- en: What is GitLab?
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是GitLab？
- en: 'The company called GitLab makes a single product: a web application that is
    also called GitLab.Behind the scenes, the GitLab web application is a complicated
    collection of tools, databases, queues, and glue code holding it all together,
    but as far as the user is concerned, it’s just a single, web-based tool for building
    software.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 叫做GitLab的公司生产一个单一的产品：一个也叫GitLab的Web应用程序。幕后，GitLab Web应用程序是一个复杂的工具、数据库、队列和粘合代码的集合，将一切串联在一起，但就用户而言，它只是一个用于构建软件的单一Web工具。
- en: Different Meanings of “GitLab”
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: “GitLab”的不同含义
- en: Throughout this book, the term “GitLab” refers to the tool rather than the company,
    unless we explicitly say otherwise.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的“GitLab”一词指的是工具本身，而非公司，除非我们明确说明。
- en: As we discussed in the first chapter, GitLab’s single-tool model is much easier
    to install, administer, and upgrade than any collection of separate, more focused
    tools. It requires only a single set of credentials per user. It offers a consistent
    GUI for all of its features. It integrates all the software development life cycle
    tools, allowing data to flow smoothly and without loss or distortion from one
    feature to the next. It provides a single location to learn about the status of
    your software as you plan, build, test, secure, and deploy it. To top it all off,
    it’s a lot cheaper than buying separate licenses for a collection of separate
    tools. And if you find that any of GitLab’s individual features don’t give you
    the flexibility or power that you need, you can almost always integrate other
    tools with GitLab to make it suit your technical needs and preferred workflow.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第一章中所讨论的，GitLab的单一工具模型比任何由多个、更专注的工具组成的集合更容易安装、管理和升级。它只需要每个用户一套凭据。它为所有功能提供一致的GUI。它集成了所有软件开发生命周期工具，允许数据在一个功能到另一个功能之间流动顺畅且无丢失或失真。它提供了一个单一的位置，让你在规划、构建、测试、安全和部署软件时，了解软件的状态。更棒的是，它比购买多个单独工具的许可证便宜得多。如果你发现GitLab的任何单独功能不能提供你所需要的灵活性或功能，你几乎总是可以将其他工具与GitLab集成，以使其符合你的技术需求和偏好工作流。
- en: What problem does GitLab solve?
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitLab解决了什么问题？
- en: 'The purpose of GitLab—the problem it aims to solve—has shifted and broadened
    over the years. It was created in 2011 with a narrow focus: it wanted to make
    Git both easier to use and more powerful. In those days, it was not much more
    than a web-based GUI wrapper around Git and a centralized place to store projects’
    golden Git repositories.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab的目标——它旨在解决的问题——随着时间的推移发生了变化并且更加广泛。GitLab于2011年创建时，关注点比较狭窄：它希望使Git更加易用且更强大。那时候，它不过是一个基于Web的GUI封装工具，作为一个集中的地方来存储项目的主Git仓库。
- en: Since then, GitLab has widened its scope. It now aims not just at Git but at
    the entire software development life cycle.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，GitLab的范围得到了扩展。它现在不仅仅针对Git，而是针对整个软件开发生命周期。
- en: 'To get a sense of how its mission has grown, you first need to understand Gitlab’s
    concept of “stages” in the software development life cycle. GitLab recognizes
    10 stages:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解其使命如何发展，首先需要理解GitLab在软件开发生命周期中的“阶段”概念。GitLab识别出10个阶段：
- en: '**Manage**: Create audit and compliance reports, and restrict access to resources.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理**：创建审计和合规报告，并限制对资源的访问。'
- en: '**Plan**: Divide work into workable chunks that you can prioritize, weight,
    and assign to team members.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计划**：将工作分解为可操作的任务，便于优先级排序、加权和分配给团队成员。'
- en: '**Create**: Commit, review, and approve file edits, whether they contain code,
    configuration information, or other assets.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建**：提交、审核和批准文件编辑，无论它们包含的是代码、配置信息还是其他资产。'
- en: '**Verify**: Run automated tests to make sure your software does what it’s supposed
    to.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证**：运行自动化测试，确保软件按预期执行。'
- en: '**Package**: Bundle your software into a deployable format.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**打包**：将软件打包成可部署格式。'
- en: '**Secure**: Find any security vulnerabilities in your software or its dependencies.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全**：查找软件或其依赖项中的任何安全漏洞。'
- en: '**Release**: Deploy your software, optionally using sophisticated techniques
    such as feature flags and canary deployments.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布**：部署软件，选择性地使用功能标志和金丝雀发布等复杂技术。'
- en: '**Configure**: Set up the environments where your code will be deployed.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**：设置代码将要部署的环境。'
- en: '**Monitor**: Report on performance metrics, incidents, or errors.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控**：报告性能指标、事件或错误。'
- en: '**Protect**: Detect potential security problems in deployment environments
    such as Kubernetes clusters.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保护**：检测部署环境中潜在的安全问题，如Kubernetes集群。'
- en: Note that there’s nothing magical about this division of the software development
    life cycle into stages. Another company might have divided it into 9 or 13 stages
    and might have drawn the boundaries between stages slightly differently. But GitLab’s
    division probably seems reasonable to anyone who has been involved in software
    development.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，软件开发生命周期分为各个阶段并没有什么神奇之处。另一家公司可能将其分为 9 或 13 个阶段，并可能在阶段之间的边界上有所不同。但 GitLab
    的分阶段方法对于任何参与过软件开发的人来说， probably seems reasonable。
- en: 'Let’s return to the question of what problem GitLab aims to solve. Since its
    humble beginnings as a solution to the difficulties of using Git (that is, early
    GitLab focused exclusively on the Create stage described previously), it now addresses
    problems faced by practitioners of all 10 of these software development life cycle
    stages. Because different stages present different problems, it’s hard to give
    a succinct description of the single problem GitLab is targeting. In fact, it’s
    probably impossible considering that GitLab now targets a myriad of problems from
    all 10 stages. The shortest, best answer we can give to the question of why GitLab
    exists is this: *it helps people write better software, more efficiently, and
    with* *less risk*.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到 GitLab 旨在解决的具体问题上。自从作为解决使用 Git 的难题的方案起步（也就是说，早期的 GitLab 只专注于之前提到的“创建”阶段），现在它已经能够解决软件开发生命周期所有
    10 个阶段中的问题。由于不同的阶段呈现出不同的问题，难以用简洁的语言描述 GitLab 旨在解决的单一问题。事实上，考虑到 GitLab 现在解决的是来自
    10 个阶段的各种问题，这个问题可能根本无法简明扼要地回答。我们能给出的最简洁、最好的回答就是：*它帮助人们更高效、更少风险地编写更好的软件*。
- en: We’re the first to admit that GitLab is not yet equally effective at addressing
    the problems of all 10 stages. That is to say, some of the features that GitLab
    offers as solutions to various problems are more mature or more robust than others.
    As you might expect, the GitLab features that have been around the longest (such
    as the Git-related functionality) are generally the most mature, and more recently
    developed features (such as protecting your application from suspicious traffic
    within a Kubernetes cluster) are significantly more minimal. But GitLab is very
    transparent about its own assessment of the relative maturity of its solutions
    to the problems of the various stages, and which features it intends to focus
    on developing and improving in the near future. So, if you’re particularly curious
    about how full-featured GitLab’s solution to a particular software development
    life cycle problem is, a quick Google search for “GitLab maturity” will probably
    give you all the information you need to make an informed decision about whether
    GitLab offers enough power and flexibility to address the problems that trouble
    you the most.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要承认，GitLab 目前在解决所有 10 个阶段的问题上还没有达到同等的效果。换句话说，GitLab 提供的解决方案中，有些功能比其他功能更成熟、更强大。正如你可能预期的那样，GitLab
    存在时间最长的功能（如与 Git 相关的功能）通常是最成熟的，而较新开发的功能（如在 Kubernetes 集群中保护你的应用免受可疑流量攻击）则显得相对简陋。但
    GitLab 对自己对各个阶段问题的解决方案的相对成熟度评估非常透明，并且明确表示其将在近期专注于哪些功能的开发和改进。因此，如果你特别关心 GitLab
    对某一特定软件开发生命周期问题的解决方案是否足够完善，快速搜索“GitLab maturity”可能会为你提供所有必要的信息，让你可以做出是否 GitLab
    提供足够的功能和灵活性来解决你最关心的问题的明智决定。
- en: At this point, you might be wondering how GitLab can compete with specialized
    tools that focus on just one of the software development life cycle stages. After
    all, can a single tool really replace a suite of 10 separate tools, each of which
    is considered “best in breed” for their problem domain?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能会想，GitLab 如何与专注于软件开发生命周期某一阶段的专业工具竞争。毕竟，单一工具真的能替代 10 个独立工具的组合吗？每个工具都被认为是在各自领域中“最佳”的解决方案。
- en: First, you might find that you don’t need as many features or as much power
    as you initially think you do. One of the authors of this book once took a full-day
    training course on a Java performance profiling tool. He left the training with
    his head spinning from all the fantastic features the product offered and the
    detailed performance bottleneck reports that he would soon be able to present
    to his manager. But, it turned out his company only needed 2% of the power of
    that tool and could have gotten away with using a much simpler and cheaper alternative
    instead. The moral of this story? *GitLab might give you all the power you need,
    no matter which software development life cycle stage you’re* *concerned with*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你可能会发现，你并不像最初认为的那样需要那么多功能或那么强大的性能。本书的其中一位作者曾参加过一整天的 Java 性能分析工具培训课程。培训结束时，他脑袋一片混乱，因为这款产品提供了许多惊人的功能，并且他很快就能向经理展示详细的性能瓶颈报告。但最终事实证明，他的公司只需要该工具
    2% 的功能，完全可以使用一个更简单且更便宜的替代工具。这个故事的寓意是什么？*无论你关心的是哪个软件开发生命周期阶段，GitLab 可能会提供你所需的所有功能*。
- en: Second, some of GitLab’s features are the result of integrating independently
    developed open source tools that truly are the best tools available for the problems
    they address. For example, many of GitLab’s security vulnerability scanners are
    highly regarded open source tools. It’s true that you could download and use these
    tools outside of GitLab, but GitLab makes it trivial to enable them in your workflow,
    and it integrates their output into existing GitLab dashboards in a familiar,
    easy-to-read format that’s consistent with all of GitLab’s other reports.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，GitLab 的一些功能是通过集成独立开发的开源工具实现的，这些工具在解决其所面临的问题时，确实是最优秀的工具。例如，许多 GitLab 的安全漏洞扫描工具都是备受推崇的开源工具。确实，你可以在
    GitLab 之外下载并使用这些工具，但 GitLab 使得在工作流中启用这些工具变得非常简单，并且将它们的输出集成到现有的 GitLab 仪表板中，呈现出一种熟悉的、易于阅读的格式，且与
    GitLab 其他报告一致。
- en: Finally, if you really do find that you need more than GitLab offers to solve
    a particular software development life cycle problem, you can almost always find
    a way to integrate outside tools into your GitLab workflow. Some of these integrations
    are explicitly supported by GitLab, and as a result, have virtually seamless results.
    Other integrations require more work on your part. But, virtually any tool that
    you can run from an operating system’s command line can be integrated into GitLab.
    Results may vary, but the number of tools that can’t talk to GitLab at all is
    vanishingly small.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你确实发现 GitLab 提供的功能不足以解决某个特定的软件开发生命周期问题，你几乎总能找到将外部工具集成到 GitLab 工作流中的方法。其中一些集成是
    GitLab 明确支持的，因此能够实现几乎无缝的效果。其他集成可能需要你更多的操作。但几乎任何可以从操作系统命令行运行的工具，都可以与 GitLab 集成。结果可能有所不同，但无法与
    GitLab 对接的工具几乎可以忽略不计。
- en: The verify, secure, and release stages
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证、安全和发布阶段
- en: 'Now that we’ve established that GitLab has ambitious goals for helping with
    all 10 stages of the software development life cycle, let’s scale things back
    a bit. This chapter focuses on the middle of the SDLC: the **verify**, **secure**,
    and **release** stages. These are among the most commonly used stages when writing
    software, and among the most problematic for all the reasons described in [*Chapter
    1*](B18073_01.xhtml#_idTextAnchor013). Fortunately, they are also the stages at
    which GitLab is most effective, and the feature it uses to solve the problems
    posed by those stages is, as you might guess, CI/CD pipelines. Now you know why
    so much of this book focuses on exactly that topic!'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经确认 GitLab 在帮助解决软件开发生命周期的所有 10 个阶段方面有雄心勃勃的目标，我们就稍微缩小一下视野。本章重点介绍 SDLC 的中间阶段：**验证**、**安全**和**发布**阶段。这些是编写软件时最常用的阶段，也是最具挑战性的阶段，正如[
    *第 1 章*](B18073_01.xhtml#_idTextAnchor013)中所描述的那样，存在许多问题。幸运的是，这也是 GitLab 最为有效的阶段，而
    GitLab 用来解决这些阶段问题的功能，正如你可能猜到的，是 CI/CD 流水线。现在你应该明白为什么本书有这么多内容专注于这一主题了！
- en: To understand how GitLab can help with the problems found in those three stages,
    you’ll need to know about a few concepts, terms, and GitLab components. Fortunately,
    everything you’re about to learn in the rest of this chapter will be relevant
    and useful to many of the other Gitlab stages as well. So, once you understand
    how to use these concepts, you’ll not only be able to move on to understanding
    GitLab CI/CD pipelines but you’ll also be better equipped to understand how GitLab
    tackles other SDLC stages that are not discussed in this book.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 GitLab 如何帮助解决这三个阶段中发现的问题，你需要了解一些概念、术语和 GitLab 组件。幸运的是，本章接下来要学习的内容将对许多其他
    GitLab 阶段也具有相关性和实用性。因此，一旦你理解了如何使用这些概念，你不仅能够继续理解 GitLab CI/CD 管道，还能更好地理解 GitLab
    如何解决本书未讨论的其他 SDLC 阶段。
- en: The rest of this chapter will focus on introducing those concepts, terms, and
    components. Let’s dive in, starting with a GitLab component called a **project**.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分将重点介绍这些概念、术语和组件。让我们开始吧，首先介绍一个 GitLab 组件——**项目**。
- en: Organizing work into projects and groups
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将工作组织为项目和组
- en: '**Projects** are the fundamental building blocks of GitLab. A GitLab project
    represents a single software product that you are working on or a single non-software
    project that you are working on. Projects are where you store your files, and
    they are the starting point for navigating GitLab’s different features. In short,
    projects are where you spend most of your time as a GitLab user.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**项目**是 GitLab 的基本构建块。一个 GitLab 项目代表你正在处理的单个软件产品或单个非软件项目。项目是你存储文件的地方，也是你导航
    GitLab 不同功能的起点。简而言之，项目是你作为 GitLab 用户大部分时间所在的地方。'
- en: 'Here are some examples of typical projects, and who might use them:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些典型项目的示例，以及可能使用它们的人员：
- en: 'A mobile phone app for finding a nearby car wash, used by development team
    #1'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '用于寻找附近洗车店的手机应用，开发团队 #1 使用'
- en: 'A desktop version of the same car wash app, used by development team #2'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '同一个洗车应用的桌面版，开发团队 #2 使用'
- en: The documentation used by the technical writing team
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 技术写作团队使用的文档
- en: An upcoming conference, used by the event planning team
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即将举行的会议，用于事件规划团队
- en: Onboarding tasks for new employees, used by the entire company
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新员工的入职任务，整个公司使用
- en: As you can see, some of these examples are software-related, but others have
    nothing to do with software. You can use projects to plan, manage, and track the
    progress of any kind of work. Although it’s true that most GitLab projects are
    focused on developing software, your company might find many non-technical uses
    for projects as well.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这些示例中有一些与软件相关，但其他的则与软件无关。你可以使用项目来规划、管理和跟踪任何类型工作的进展。虽然大多数 GitLab 项目确实专注于软件开发，但你的公司可能会发现许多与技术无关的项目用途。
- en: There’s no hard-and-fast rule for how to chop up your work into projects. For
    example, one company might decide to put all its documentation in a separate,
    documentation-specific project as described in the previous example. Another company
    might include the documentation files for each software product within the projects
    created for those products. Use whatever structure works best for you. Often,
    this requires some trial-and-error experimentation, so don’t be afraid to rejigger
    your use of projects.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 没有硬性规定如何将工作划分为项目。例如，一家公司可能决定将所有文档放入一个独立的、专门用于文档的项目中，正如前面的示例所描述的那样。另一家公司可能会将每个软件产品的文档文件包含在为这些产品创建的项目中。使用最适合你的结构。通常，这需要一些反复试验，因此不要害怕重新调整你的项目使用方式。
- en: 'It’s easiest to understand what a project is by seeing a picture of one. It
    won’t surprise you to know that GitLab is developed using GitLab tools. Here’s
    the project for the open source portion of GitLab:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 了解项目是什么，最简单的方式是看一张项目的图片。你不会感到惊讶，GitLab 本身就是使用 GitLab 工具开发的。这里是 GitLab 开源部分的项目：
- en: '![Figure 3.1 – The project for GitLab’s open source code ](img/Figure_3.01_B18073.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.1 – GitLab 开源代码的项目](img/Figure_3.01_B18073.jpg)'
- en: Figure 3.1 – The project for GitLab’s open source code
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.1 – GitLab 开源代码的项目
- en: As you can see, the list of files takes up the largest part of a project’s screen.
    What might not be obvious from the screenshot is that those files are actually
    a Git repository.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，文件列表占据了项目屏幕的最大部分。从截图中可能不明显的是，这些文件实际上是一个 Git 仓库。
- en: You can think of a GitLab project as being a “wrapper” around a Git repository.
    Furthermore, you can consider the repository that lives in GitLab to be the “golden”
    copy of the repository, as discussed in [*Chapter 2*](B18073_02.xhtml#_idTextAnchor035).
    Because a project contains a Git repository, the project also gives you access
    to all the other things that a Git repository normally contains, including Git
    commits, Git tags, and Git branches. We’ll talk about how to view these components
    later in this chapter.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将一个GitLab项目视为一个“包装器”，它围绕着一个Git仓库。此外，您还可以将存储在GitLab中的仓库视为“黄金”副本，就像在[*第2章*](B18073_02.xhtml#_idTextAnchor035)中讨论的那样。由于项目包含Git仓库，项目还让您访问Git仓库通常包含的所有其他内容，包括Git提交、Git标签和Git分支。我们将在本章后面讲解如何查看这些组件。
- en: 'Sometimes, you’ll find that you have a collection of projects that all hang
    together in some way. Here are some typical examples:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您会发现自己拥有一系列以某种方式关联的项目。以下是一些典型示例：
- en: Projects that all belong to the same team
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 都属于同一团队的项目
- en: Projects for macOS and Windows versions of the same software
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: macOS和Windows版本的同一软件的项目
- en: Projects that are all related to database management
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有与数据库管理相关的项目
- en: When this happens, you can use a **GitLab group** to gather those related projects
    so they all exist in a single place within GitLab. You can think of GitLab groups
    as being similar to directories or folders that hold collections of projects.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当这种情况发生时，您可以使用**GitLab组**来聚集这些相关的项目，以便它们都集中存在于GitLab的一个地方。您可以将GitLab组视为类似于目录或文件夹，用于存储一组项目。
- en: 'GitLab groups aren’t limited to holding GitLab projects: they can also hold
    other GitLab groups. You can have up to 20 levels of these subgroups within a
    GitLab group. You’re encouraged to use these subgroups in any way you want to
    organize your projects into related collections.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab组不仅限于保存GitLab项目：它们还可以包含其他GitLab组。您可以在GitLab组内最多拥有20级子组。我们鼓励您根据需要使用这些子组，将项目组织成相关的集合。
- en: 'Here’s a sample structure of groups, subgroups, and projects that might help
    you understand the relationship between the three concepts. Imagine that there’s
    a company called Acme Anvils, whose IT team oversees developing software for selling
    its anvils. It also makes separate software that’s used for internal purposes
    such as inventory management. Their group hierarchy might look like this:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个组、子组和项目的示例结构，可能有助于您理解这三者之间的关系。假设有一个名为Acme Anvils的公司，其IT团队负责开发销售铁砧的软件。它还开发用于内部目的的软件，例如库存管理。它们的组层级结构可能如下所示：
- en: '![Figure 3.2 – A sample group and project hierarchy](img/Figure_3.02_B18073.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – 一个示例的组和项目层级结构](img/Figure_3.02_B18073.jpg)'
- en: Figure 3.2 – A sample group and project hierarchy
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 一个示例的组和项目层级结构
- en: 'Groups are more than just a way to collect related projects. You can also use
    them to establish roles and permissions. Using groups, you can do the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 组不仅仅是收集相关项目的方式。您还可以用它们来建立角色和权限。使用组，您可以执行以下操作：
- en: Invite other GitLab users to be members of a group.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邀请其他GitLab用户成为组的成员。
- en: Assign them a role within that group.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为他们分配组内的角色。
- en: Grant a user, group, or role permission to view or edit any projects within
    that group.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授予用户、用户组或角色查看或编辑该组内任何项目的权限。
- en: Thus, groups provide a simple way to regulate access control to several users
    at once.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，组提供了一种简单的方式，可以一次性管理多个用户的访问控制。
- en: A group will also roll up components from all the projects within that group.
    For example, you can go to a single screen to see all the issues in all of the
    projects within a group.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一个组还会汇总该组内所有项目的组件。例如，您可以进入单一界面查看该组内所有项目的所有问题。
- en: But, groups don’t have to be complicated, and you don’t have to use all of their
    features. They’re a great way to simply collect related projects into a single
    place.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，组不一定要复杂，您也不必使用它们的所有功能。它们是一个很好的方式，可以简单地将相关项目收集到一个地方。
- en: Enough theory about projects, groups, and subgroups. Now, it’s time to see those
    concepts in action.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 关于项目、组和子组的理论讲解到此为止，现在是时候看看这些概念如何在实践中应用了。
- en: Example – organizing your Hats for Cats work
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 示例 – 组织您的“猫咪帽子”工作
- en: Cast your mind all the way back to [*Chapter 1*](B18073_01.xhtml#_idTextAnchor013),
    where we introduced your idea for a Hats for Cats web store. It’s time to get
    serious about setting up GitLab to help you develop that software.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下[*第1章*](B18073_01.xhtml#_idTextAnchor013)，我们介绍了您构思的“猫咪帽子”网店。现在是时候认真设置GitLab，帮助您开发软件了。
- en: 'Let’s say that you decide that Hats for Cats needs to exist in three different
    forms: a web app, an iOS app, and an Android app. You decide that although some
    of the logic will be similar between these three products, there are enough implementation
    differences so that each deserves its own project.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你决定“猫帽子”需要以三种不同的形式存在：Web应用、iOS应用和Android应用。你决定，尽管这三种产品之间的某些逻辑会相似，但它们之间有足够的实现差异，因此每个产品都应该有自己的项目。
- en: '(Reminder: this chapter won’t tell you how to create, edit, or view projects
    or groups. As discussed at the start of this chapter, the official GitLab documentation
    is your best source of information for step-by-step instructions for working with
    any GitLab components or using the GUI. This chapter—and in fact the entire book—focuses
    on the *why* rather than the *how*.)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: （提醒：本章不会告诉你如何创建、编辑或查看项目或组。正如本章开头所提到的，官方GitLab文档是你获取逐步操作指导的最佳资源，适用于GitLab的任何组件或使用GUI。本章——实际上整个书籍——专注于*为什么*，而非*如何*。）
- en: 'Because iOS and Android are both mobile platforms, you decide that it makes
    sense to collect those under a single group dedicated to mobile development. Then,
    you decide to collect that group, together with the web app project, under an
    umbrella group that comprises your entire Hats for Cats concept. Finally, you
    decide it makes sense to provide online documentation that is entirely platform-agnostic:
    it should apply equally to the iOS, Android, and web versions of the app. Because
    it isn’t tied to any of the existing projects, you want to create a new project
    just to hold the documentation.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于iOS和Android都是移动平台，你决定将它们收集到一个专门用于移动开发的单一组中。然后，你决定将这个组与Web应用项目一起，收集到一个包含整个“猫帽子”概念的总组下。最后，你决定提供一个完全与平台无关的在线文档：它应该适用于iOS、Android和Web版本的应用。因为它不与任何现有项目相关联，所以你希望创建一个新的项目来专门保存文档。
- en: To realize this structure in GitLab, it’s often easiest to work from the top
    down, starting with groups and finishing with projects. You start by logging in
    to GitLab and creating the top-level **Hats for Cats** group, using all the default
    settings. (If you’d like to follow along, please take a look at the official GitLab
    documentation for explicit instructions on how to do this.) When that’s done,
    GitLab takes you to the home page for that group. Now you decide to create a subgroup
    called **Mobile** within the **Hats for** **Cats** group.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitLab中实现这种结构时，通常从上往下工作最为简便，先从组开始，最后创建项目。你从登录GitLab并创建顶级**Hats for Cats**组开始，使用所有默认设置。（如果你想跟着做，请查看官方GitLab文档，了解如何操作的详细步骤。）完成后，GitLab会将你带到该组的主页。现在，你决定在**Hats
    for Cats**组内创建一个名为**Mobile**的子组。
- en: 'Now, it’s time to create the projects. (Again, GitLab documentation can explain
    the exact process for doing this, but fortunately, it’s very simple.) Imagine
    that you do the following in order to begin working on Hats for Cats:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建项目了。（再次说明，GitLab文档可以详细解释此过程，但幸运的是，这非常简单。）假设你进行以下操作以开始进行“猫帽子”项目的工作：
- en: Make a project called **Documentation** inside the **Hats for Cats** group.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Hats for Cats**组内创建一个名为**Documentation**的项目。
- en: Make a project called **Web** inside the **Hats for** **Cats** group.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Hats for Cats**组内创建一个名为**Web**的项目。
- en: Make a project called **iOS** inside the **Mobile** subgroup.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Mobile**子组内创建一个名为**iOS**的项目。
- en: Make a project called **Android** inside the **Mobile** subgroup.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Mobile**子组内创建一个名为**Android**的项目。
- en: 'When you’re done, you end up with a group and project structure that looks
    like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，你将得到一个看起来像这样的组和项目结构：
- en: '![Figure 3.3 – Hats for Cats group and project hierarchy](img/Figure_3.03_B18073.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – “猫帽子”组和项目层级](img/Figure_3.03_B18073.jpg)'
- en: Figure 3.3 – Hats for Cats group and project hierarchy
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – “猫帽子”组和项目层级
- en: 'Let’s do a quick review before moving on:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，先快速复习一下：
- en: A project gives you a Git repository in which you can store your code.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个项目会为你提供一个Git仓库，你可以在其中存储代码。
- en: A project is also the central place from which you’ll do most of your work in
    GitLab.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个项目也是你在GitLab中进行大多数工作的核心位置。
- en: Several related projects can be collected within a group.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以将多个相关项目收集到一个组中。
- en: Groups can hold projects, other groups, or both.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组可以包含项目、其他组或两者。
- en: By organizing your projects within groups and possibly subgroups, you can keep
    them well organized and easy to find, but you also gain the ability to assign
    permissions to other team members at the group level and have those permissions
    apply to all projects within the group.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在组内组织项目，甚至可能是子组，你可以保持项目的良好组织，方便查找，并且你还能在组级别分配权限给其他团队成员，并使这些权限应用到该组内的所有项目。
- en: 'Time to move on to the next fundamental building block of GitLab: **issues**.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在该进入GitLab的下一个基本构建块：**问题**。
- en: Tracking work with issues
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用问题跟踪工作
- en: If a GitLab project is where a single product or initiative lives, a GitLab
    **issue** is where a single chunk of work lives. If you’ve used tools other than
    GitLab for planning and tracking work, you might have run across terms such as
    “story” or “ticket” to describe components that are similar to GitLab issues.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个GitLab项目是单一产品或计划所在的地方，那么GitLab的**问题**就是单一工作项所在的地方。如果你曾使用过其他工具进行工作规划和跟踪，可能会遇到像“故事”或“工单”这样的术语，它们用于描述与GitLab问题类似的组件。
- en: Issues live within GitLab projects, with each issue only belonging to one project
    (although they can be moved between projects). In addition to being linked to
    projects, issues are also linked to a huge number of other GitLab components,
    as you’ll see when we introduce you to those components. In fact, these linkages
    are a big part of what gives GitLab its power to reach across all 10 stages of
    the SDLC.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 问题存在于GitLab项目中，每个问题仅属于一个项目（尽管它们可以在项目之间移动）。除了与项目相关联外，问题还与大量其他GitLab组件相关联，正如我们在介绍这些组件时所看到的那样。事实上，这些关联是GitLab在SDLC的所有10个阶段中发挥作用的关键因素之一。
- en: The structure of a GitLab issue
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitLab问题的结构
- en: 'GitLab issues consist of several parts, of which these four are the most important:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab问题由多个部分组成，其中这四个部分是最重要的：
- en: A **title**
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标题**'
- en: A **description**
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个**描述**
- en: Several optional **metadata** fields
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 几个可选的**元数据**字段
- en: A threaded **discussion**, where team members can comment on the issue
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个有线程的**讨论**，团队成员可以在其中对问题进行评论。
- en: Let’s look at each of these issue components in more detail.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看一下这些问题组件。
- en: 'The title is a short description of what the issue is about. For example, `Add
    a FAQ page`, `Fix bug #12`, or `Improve page load performance by 20%` are all
    reasonable issue titles. You don’t need to provide all the details about a feature
    in its title; that’s what the **description** field is for.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '标题是对问题内容的简短描述。例如，`添加FAQ页面`、`修复bug #12`或`提高页面加载性能20%`都是合理的问题标题。你不需要在标题中提供所有关于某个功能的细节；那是**描述**字段的作用。'
- en: The **Description** field can contain as little or as much text as you want.
    It can contain screenshots or links, and it makes full use of Markdown’s formatting
    features. It can also be edited later as more information comes to light or the
    exact direction of the issue changes.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**描述**字段可以包含你想要的任意多或少的文本。它可以包含截图或链接，并充分利用Markdown的格式化功能。随着更多信息的揭示或问题方向的变化，它也可以在后续编辑。'
- en: 'Issues have several metadata fields. We won’t go over all of them, but here
    are some of the most important ones:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 问题有几个元数据字段。我们不会逐一介绍所有字段，但这里是一些最重要的：
- en: '**Assignee**: This field identifies the person or persons who own the issue,
    in the sense that they’re responsible for pushing it forward and serving as a
    point of contact if people have questions or comments about the issue that they
    don’t want to add to the issue’s discussion section.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**指派人**：此字段标识一个或多个负责此问题的人，意味着他们负责推动问题的进展，并作为联系人，解答那些不想添加到问题讨论区的提问或评论。'
- en: '**Due date**: There are several ways to use due dates in GitLab, but the most
    straightforward is to assign a due date directly to an issue.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**截止日期**：GitLab中有几种方式可以使用截止日期，但最直接的方式是将截止日期直接分配给问题。'
- en: '**Labels**: We’ll discuss these in more detail later, but they serve to prioritize,
    route, or report on the progress of an issue, among other uses.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标签**：我们稍后会更详细地讨论这些标签，但它们的作用是优先级排序、路线指定或报告问题进度等。'
- en: '**Weight**: This field describes how much work you expect the issue to require.
    If you’re familiar with the Scrum method of project management, you’ve used the
    similar concept of “story points.” When assigning a weight to an issue, you can
    either use a concrete metric ( for example, person-hours) or a more abstract metric
    (for example, tiny tasks get one point, medium tasks get two points, and large
    tasks get three points). Every team has their own philosophy about this, which
    they develop with time and experience.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作量**：该字段描述你预期问题所需的工作量。如果你熟悉 Scrum 项目管理方法，那么你也使用过类似的“故事点”概念。为一个问题分配工作量时，你可以使用具体的度量单位（例如人时），也可以使用更抽象的度量单位（例如，小任务为一分，中等任务为两分，大任务为三分）。每个团队都有自己关于这方面的哲学，通常是通过时间和经验积累出来的。'
- en: 'In addition to these explicit metadata fields, there’s another important piece
    of metadata about the issue: whether it is open or closed. Every issue starts
    with a status of **Open**. When someone completes the work required by an issue,
    they will normally change its status to **Closed**.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些明确的元数据字段，还有一个关于问题的重要元数据：它是开放还是关闭的。每个问题开始时的状态是**开放**。当某人完成了问题所需的工作后，通常会将其状态更改为**已关闭**。
- en: Finally, every issue has a discussion section that lets people participate in
    threaded discussions, as you’d find on Facebook or Instagram. Because it’s threaded,
    people can reply to individual messages, or they can add entirely new messages.
    Discussions can include emojis, links, or images.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，每个问题都有一个讨论区，允许人们参与线程式讨论，就像你在 Facebook 或 Instagram 上看到的那样。由于是线程式的，参与者可以回复个别消息，也可以添加全新的消息。讨论可以包括表情符号、链接或图片。
- en: 'Since a picture is worth a thousand words, here’s a sample issue from your
    Hats for Cats project:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 既然一张图片胜过千言万语，这里有一个来自你们“猫咪帽子”项目的示例问题：
- en: '![Figure 3.4 – Sample issue](img/Figure_3.04_B18073.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – 示例问题](img/Figure_3.04_B18073.jpg)'
- en: Figure 3.4 – Sample issue
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 示例问题
- en: Most projects contain many issues, with both **Open** and **Closed** statuses.
    GitLab makes it easy to see a list of all the issues in a project and to zoom
    in on any issues in the list to see the full details of that issue. You can also
    look at a list of issues from a group level instead of a project level. This view
    shows a list of all the issues that belong to any of the projects within that
    group. So, if you want to know how many issues are left to work on for both the
    iOS and Android versions of the Hats for Cats app, you can go up a level from
    the individual projects and look at a list of all the issues that have the **Open**
    status within the **Mobile** group.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数项目包含许多问题，这些问题的状态有**开放**和**已关闭**。GitLab 使得查看项目中所有问题的列表变得容易，并且可以聚焦到列表中的任何问题，查看该问题的完整详情。你也可以从组级别而不是项目级别查看问题列表。这种视图会显示属于该组内任何项目的所有问题列表。所以，如果你想了解“猫咪帽子”应用的
    iOS 和 Android 版本还有多少问题需要处理，你可以从各个独立项目中升到上一级，查看**移动端**组中所有**开放**状态的问题列表。
- en: The kinds of tasks that issues can represent
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题能代表的任务类型
- en: 'You might think that issues are only used to capture work related to software
    development, but that’s just the tip of the issue iceberg. Let’s look at the broad
    range of tasks that you can describe and track with a GitLab issue:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为问题仅用于捕捉与软件开发相关的工作，但那只是问题冰山的一角。让我们来看看可以用 GitLab 问题描述和追踪的广泛任务范围：
- en: Add a feature.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加一个功能。
- en: Fix a bug.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修复一个 bug。
- en: Write automated tests.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写自动化测试。
- en: Set up a database.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置一个数据库。
- en: Configure a tool for the whole team to use.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置一个全团队使用的工具。
- en: Research technical options.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 研究技术选项。
- en: Brainstorm solutions to a problem.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头脑风暴，解决一个问题。
- en: Plan an event.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计划一个活动。
- en: Poll the team about preferences for coding standards.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对团队进行调查，了解编码标准的偏好。
- en: Report and manage a security incident.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 报告并管理安全事件。
- en: Propose an idea for a new product or a new feature.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提出一个新产品或新功能的想法。
- en: Ask a question that anyone can provide an opinion on.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提出任何人都可以发表意见的问题。
- en: Request T-shirt designs for an upcoming corporate outing.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求为即将到来的公司聚会设计 T 恤。
- en: Of course, there are many more possible uses for issues than are included in
    this short list. As you can see, they can be used for technical or non-technical
    work, and they can be used by a single person or an entire company.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，问题的用途远不止于此，远比这个简短的列表要多。如你所见，问题可以用于技术性或非技术性的工作，既可以由个人使用，也可以由整个公司使用。
- en: To give one more possibly unexpected example, every new hire at GitLab is assigned
    an issue that includes *Welcome to the company* text and a long list of onboarding
    tasks for them to complete and check off. The employee’s manager and the company’s
    human resources department monitor this issue during the employee’s first few
    weeks to see how they are progressing through the onboarding process. Later, after
    onboarding is complete and the issue has been closed, the employee can use the
    issue as a reference source for company policies and procedures.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 再举一个可能意外的例子，GitLab的每位新员工都会被分配一个问题，其中包含*欢迎加入公司*文本以及一长串要完成和检查的入职任务。在员工的前几周，员工的经理和公司的人力资源部门将监控此问题，以查看他们在入职流程中的进展情况。稍后，当入职流程完成并关闭该问题后，员工可以将该问题用作公司政策和流程的参考来源。
- en: Labels
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 标签
- en: Before explaining how you might realistically use issues, we need to introduce
    you to **labels**. These are colored tags containing a short bit of text. You
    can apply labels to issues or other GitLab components, such as merge requests
    (which we’ll discuss later), and remove them when they are no longer useful. You
    can define whatever labels you need for your project or group, and you can always
    add more labels or delete existing labels. Then, you can apply one or more labels
    to an issue to “mark” that issue with the contents of the label.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在解释如何实际使用问题之前，我们需要向您介绍**标签**。这些是带有短文本的彩色标签。您可以将标签应用于问题或其他GitLab组件，例如合并请求（稍后我们会讨论），并在它们不再有用时删除它们。您可以为您的项目或组定义任何需要的标签，并始终可以添加更多标签或删除现有标签。然后，您可以将一个或多个标签应用于问题，以“标记”该问题的标签内容。
- en: 'Here are some examples of commonly created labels:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些通常创建的标签示例：
- en: '**High Priority**: Indicates an issue that needs to be worked on immediately'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**High Priority**：指示需要立即处理的问题'
- en: '**QA**: Indicates an issue that is the responsibility of the quality assurance
    team'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**QA**：指示由质量保证团队负责的问题'
- en: '**Status::Healthy**: Indicates an issue that is progressing according to the
    schedule'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Status::Healthy**：指示按计划进行的问题'
- en: '**Status::At Risk**: Indicates an issue that has fallen behind and needs extra
    resources to be assigned to it'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Status::At Risk**：指示已落后并需要额外资源分配的问题'
- en: 'Notice that the last two labels have double colons inside their descriptive
    text. The double colons have a special meaning: they turn these labels into **scoped
    labels**, which means they are mutually exclusive. That is, an issue can have
    the **Status::Healthy** label or the **Status::At Risk** label applied to it,
    but not both. Non-scoped labels—labels that don’t contain a double colon—can be
    applied in any combination to any issue. For example, you could apply both the
    **Front-end** and **DB** labels to an issue that needs work from both your frontend
    developer and your database administrator.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，最后两个标签在其描述文本中有双冒号。双冒号具有特殊含义：它们将这些标签转换为**作用域标签**，这意味着它们是互斥的。也就是说，一个问题可以被应用为**Status::Healthy**标签或**Status::At
    Risk**标签，但不能同时存在。不带双冒号的非作用域标签可以以任何组合应用于任何问题。例如，您可以将**Front-end**和**DB**标签同时应用于需要前端开发人员和数据库管理员工作的问题。
- en: GitLab uses hundreds of issues to prioritize, route, assign responsibility,
    and track work as it develops the GitLab product itself, so don’t be afraid to
    make and apply whatever issues you need; they’re free to create and easy to manage.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab使用数百个问题来优先考虑、路由、分配责任并跟踪工作，以开发GitLab产品本身，因此请勇于制作和应用您所需的任何问题；它们可以免费创建并易于管理。
- en: Issue workflows
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题工作流程
- en: As with many GitLab components, there’s no single workflow for using issues
    that works well for every team in every situation. You’re encouraged to experiment
    and discover the best way to use issues for yourself considering your needs and
    team culture. But, we can present a *typical* workflow for issues, which you can
    use as a starting point when exploring possibilities for working with GitLab issues.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多GitLab组件一样，对于每个团队在每种情况下都有效的问题使用工作流并不存在单一的解决方案。鼓励您进行实验，并发现根据您的需求和团队文化最佳使用问题的方法。但是，我们可以提供一个问题的*典型*工作流示例，您可以将其用作探索与GitLab问题合作的可能性的起点。
- en: 'Here’s a sample workflow for one of your Hats for Cats projects:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您的一项名为"Hats for Cats"项目的样本工作流程：
- en: '*Think up some work that needs to be done and figure out which project that
    work belongs to*. For example, as part of the Hats for Cats iOS project, you need
    to research the Objective-C and Swift programming languages to figure out which
    you should use for writing the iOS app.'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*构思需要完成的工作，并弄清楚这项工作属于哪个项目*。例如，作为《Hats for Cats》iOS项目的一部分，你需要研究Objective-C和Swift编程语言，以决定使用哪种语言来编写iOS应用。'
- en: '*Create an issue in that project and describe the work inside that issue*.
    You create an issue titled `Research languages for iOS` and add a description
    of the possible languages and your initial feelings about which might be the best
    to choose.'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*在该项目中创建问题并描述问题中的工作内容*。你创建了一个标题为`Research languages for iOS`的问题，并添加了关于可能的编程语言及你初步选择哪个语言的看法的描述。'
- en: '*Add a weight to the issue*. You decide to use a metric of the total person-days
    expected and assign this issue a weight of two.'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*为问题添加权重*。你决定使用预期的总人天数作为度量标准，并为该问题分配一个权重值为二。'
- en: '*Set a due date for the issue*. You set the issue to be due in 3 days.'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*为问题设置截止日期*。你将问题的截止日期设置为3天后。'
- en: '*Assign labels to prioritize and route the issue*. You assign the **iOS** and
    **High Priority** labels to the issue. The former ensures that the right people
    monitor it, and the latter indicates that work on the issue needs to begin immediately.'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*分配标签以优先处理并指引问题*。你将**iOS**和**高优先级**标签分配给该问题。前者确保合适的人员进行监控，后者则表明该问题需要立即开始处理。'
- en: '*Discuss the issue*. People who are working on the Hats for Cats iOS app chime
    in with their past experiences with the different iOS languages. Other people
    ask clarifying questions. Someone adds links to outside blog posts that discuss
    Swift and Objective-C. You add a screenshot of a language comparison table from
    a developer-focused website.'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*讨论问题*。参与开发《Hats for Cats》iOS应用的人员分享他们在不同iOS语言方面的经验。其他人提出澄清性问题。有些人提供了讨论Swift和Objective-C的外部博客链接。你还从一个面向开发者的网站上添加了一个语言对比表的截图。'
- en: '*Assign the issue*. In the discussion, you ask your most experienced developer
    whether they’re willing to tackle this task. When they agree, you assign the issue
    to them so that everyone knows that they’re responsible for working on this issue
    and updating its progress.'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*分配问题*。在讨论中，你询问最有经验的开发者是否愿意处理这个任务。当他们同意后，你将问题分配给他们，这样每个人都知道他们负责处理这个问题并更新进展。'
- en: '*Update labels*. As work progresses, the person to whom you assigned the issue
    updates its labels. For example, they might remove the **High Priority** label
    once it’s underway, and add a **Status::At Risk** scoped label when they realize
    that they’re unlikely to complete the research by the issue’s due date.'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*更新标签*。随着工作的进展，你分配问题的人员更新问题的标签。例如，当工作开始时，他们可能会移除**高优先级**标签，并在意识到自己可能无法在问题的截止日期前完成研究时，添加**状态::风险中**的标签。'
- en: '*Close the issue when it is complete*. The developer to whom the issue was
    assigned completes their research and posts their findings in the issue’s discussion
    section. Then they close it, signifying that no more work remains to be done on
    the issue.'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*完成后关闭问题*。被分配该问题的开发者完成了他们的研究，并将结果发布到问题的讨论区。然后他们关闭了该问题，表示该问题已无进一步工作需要完成。'
- en: This wraps up your introduction to GitLab issues. You’ve seen what kinds of
    work you can describe in an issue, what data goes into an issue, and what workflow
    you might use when working on an issue. It’s hard to be an effective GitLab user
    without creating and using lots of issues, so it’s a great idea to practice creating,
    viewing, and editing issues as you get comfortable with GitLab.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你对GitLab问题的介绍。你已经了解了在问题中可以描述的工作内容、问题中包含的数据以及在处理问题时可能采用的工作流程。没有创建和使用大量问题，很难成为一个高效的GitLab用户，因此在熟悉GitLab的过程中，练习创建、查看和编辑问题是一个很好的方法。
- en: Editing files safely with commits, branches, and merge requests
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全地编辑文件，包括提交、分支和合并请求
- en: 'In the last chapter, you learned about using branches and commits in Git, where
    a branch is a series of commits, and a commit is a snapshot that consists of edits
    to one or more files. Because GitLab is in some senses a wrapper around a Git
    repository (although of course, it’s much more than that), branches and commits
    are also an important part of using GitLab. There’s a third, related concept that
    you’ll use frequently in GitLab: the **merge request** (often referred to as an
    **MR**). In this section, we’ll explain what an MR is and show you how to work
    with all three components in GitLab.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章节中，你了解了如何使用 Git 中的分支和提交，其中分支是一系列提交，而提交是由一个或多个文件的编辑所组成的快照。因为从某些角度看，GitLab
    是 Git 仓库的一个封装（尽管它远不止如此），所以分支和提交也是使用 GitLab 的重要组成部分。在 GitLab 中，还有一个你会频繁使用的相关概念：**合并请求**（通常简称为**MR**）。在本节中，我们将解释什么是
    MR，并向你展示如何在 GitLab 中操作这三者。
- en: GitLab often gives you more than one way to do something, and that’s true of
    working with commits and branches. You can either type commands into a terminal
    or use the GitLab GUI to perform most of the operations you’re likely to need
    for these two components. Because MRs are a concept that’s specific to GitLab
    and not Git, you’ll see that MRs require you to use the GitLab GUI.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab 通常提供多种方法来完成同一件事，在操作提交和分支时也不例外。你可以通过在终端中输入命令，或者使用 GitLab 图形界面（GUI）来执行你需要的大多数操作。由于
    MR（合并请求）是 GitLab 特有的概念，而不是 Git 的一部分，你会发现 MR 需要使用 GitLab GUI。
- en: Before you can commit edits to a branch, you need to create the branch. Thinking
    back to the last chapter, you’ll remember that you can make a branch with the
    `git branch <BRANCH-NAME>` command followed by some form of the `git push` command
    to copy your branch up to the golden copy of your project’s repository. Alternatively,
    you can work primarily in the GUI by creating a new branch right inside GitLab
    and then copying that branch to your local copy of the repository (assuming you
    have a local copy) with a combination of `git fetch` and some form of `git pull`.
    Because the exact command depends on your situation, you should consult your favorite
    dedicated Git reference material for full information.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在你能将编辑提交到分支之前，你需要先创建该分支。回顾上一章节，你会记得你可以使用 `git branch <BRANCH-NAME>` 命令创建分支，随后使用某种形式的
    `git push` 命令将分支复制到项目仓库的“金本副本”中。或者，你也可以通过 GitLab 的 GUI 在 GitLab 中创建一个新分支，然后使用
    `git fetch` 和某种形式的 `git pull` 将该分支复制到你本地的仓库副本中（前提是你有本地副本）。由于确切的命令依赖于你的情况，你应该参考你最喜爱的
    Git 专门书籍来获得完整的信息。
- en: Although normally we won’t lead you through explicit instructions for using
    the GitLab GUI, creating branches, commits, and MRs is so fundamental to working
    effectively with GitLab that we’ll give you an overview of exactly how to work
    with these through the GUI.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通常我们不会详细指导你如何使用 GitLab GUI，但创建分支、提交和 MR 是有效使用 GitLab 的基础，因此我们将概述如何通过 GUI 操作这些内容。
- en: Let’s start by creating a branch. Because a branch is a part of a Git repository,
    and a GitLab project is nothing more than a GitLab repository with a ton of extra
    features, it makes sense to create a branch within a GitLab project. For example,
    imagine that you want to add an `allow-password-change` branch to the Hats for
    Cats Android app so your developers can add a feature that lets users manage their
    passwords.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个分支开始。因为分支是 Git 仓库的一部分，而 GitLab 项目不过是一个附加了大量额外功能的 Git 仓库，所以在 GitLab 项目中创建分支是合乎逻辑的。例如，假设你想为《Hats
    for Cats》安卓应用添加一个`allow-password-change`分支，以便你的开发人员能够添加一个让用户管理密码的功能。
- en: 'Here’s how to add that branch:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何添加分支的方法：
- en: Navigate through your group structure and open the **Android** project.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的组结构中导航并打开**Android**项目。
- en: In the navigation pane on the left-hand side of the page, click **Repository**
    > **Branches**. This takes you to a list of branches that exist in the project’s
    repository.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在页面左侧的导航面板中，点击**仓库** > **分支**。这将带你进入项目仓库中存在的分支列表。
- en: 'Click the **New branch** button, fill in the branch’s name, hit the **Create
    branch** button, and you’re done:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**新建分支**按钮，填写分支名称，点击**创建分支**按钮，完成：
- en: '![Figure 3.5 – List of branches within a project](img/Figure_3.05_B18073.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 项目中的分支列表](img/Figure_3.05_B18073.jpg)'
- en: Figure 3.5 – List of branches within a project
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 项目中的分支列表
- en: 'After you’ve created a branch, you can commit edits to it. Once again, there
    are two ways to do this. You’ve already learned about the three-command sequence
    that you can use in a terminal: `git add <FILE-NAME>` followed by `git commit
    --message "<MESSAGE>"` followed by `git push`. But, if you’d rather work within
    GitLab, here’s what you need to do:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 创建分支后，你可以提交编辑。再次提醒，这有两种方式可以做到。你已经了解了在终端中使用的三条命令：`git add <FILE-NAME>`，然后是`git
    commit --message "<MESSAGE>"`，再接着是`git push`。不过，如果你更愿意在 GitLab 内操作，下面是你需要做的：
- en: Navigate to the project’s repository by clicking **Repository** > **Files**
    in the left-hand navigation pane.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击左侧导航栏中的**Repository** > **Files**，导航到项目的代码库。
- en: 'Make sure you’re working in the right branch by clicking the branch name dropdown
    near the top left of the page:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你正在正确的分支上工作，方法是点击页面左上方的分支名称下拉菜单：
- en: '![Figure 3.6 – Selecting a branch in a project](img/Figure_3.06_B18073.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 在项目中选择分支](img/Figure_3.06_B18073.jpg)'
- en: Figure 3.6 – Selecting a branch in a project
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 在项目中选择分支
- en: Within the repository’s list of files, click the name of the file you want to
    edit. This will display its contents.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码库的文件列表中，点击你想编辑的文件名，这样就会显示该文件的内容。
- en: Click **Edit in Web IDE** to open an in-browser editor, and make any changes
    needed to the file.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**Edit in Web IDE**以打开浏览器中的编辑器，并对文件进行必要的更改。
- en: If you’d like to edit more files within this commit, click on the next file’s
    name in the file browser toward the left of the page and make any edits you want
    to its contents.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想编辑此提交中的更多文件，点击页面左侧文件浏览器中的下一个文件名，并对其内容进行任何你想要的编辑。
- en: When you’re done making changes, click **Commit…** and enter a commit message.
    If you haven’t created a merge request for this branch yet, it’s usually a good
    idea to check the **Start a new merge request** checkbox. Click **Commit** and
    you’re done.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你完成更改后，点击**Commit…**并输入提交信息。如果你还没有为该分支创建合并请求，通常建议勾选**Start a new merge request**复选框。点击**Commit**，你就完成了。
- en: If you’ve cloned the repository to your local machine, you might want to use
    `git checkout <BRANCH-NAME>` followed by `git pull` to copy the commit you just
    made to your local repository, but you can often get away with doing this occasionally
    instead of after every commit.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你已经将代码库克隆到本地机器上，你可能想使用`git checkout <BRANCH-NAME>`，然后执行`git pull`，将你刚才做的提交复制到本地代码库，但你通常可以选择偶尔这样做，而不是每次提交后都这么做。
- en: '![Figure 3.7 – Commit your edits](img/Figure_3.07_B18073.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – 提交你的编辑](img/Figure_3.07_B18073.jpg)'
- en: Figure 3.7 – Commit your edits
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 提交你的编辑
- en: Editing files and committing changes directly to your project’s repository without
    ever touching a terminal is one of the great joys of using GitLab, so it’s well
    worth practicing this feature until it becomes a part of your normal workflow.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 直接在 GitLab 中编辑文件并将更改提交到你项目的代码库，而不需要触碰终端，这是使用 GitLab 的一大乐趣，因此值得多加练习，直到它成为你正常工作流程的一部分。
- en: 'Making branches doesn’t do you any good unless you can switch between them,
    so you can view or edit the contents of whichever branch you want. You’ve seen
    how to do this from the command line using `git checkout <BRANCH-NAME>` or `git
    switch <BRANCH-NAME>`. It’s just as easy to switch branches within the GUI: just
    find the branch dropdown that exists at the top left of many pages and switch
    to your preferred branch. It can be easy to forget which branch you’re on, so
    it’s good to get in the habit of quickly checking this dropdown from time to time
    to keep yourself oriented.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 创建分支对你没什么帮助，除非你能在它们之间切换，这样你可以查看或编辑任何你想要的分支内容。你已经学会了如何使用命令行通过`git checkout <BRANCH-NAME>`或`git
    switch <BRANCH-NAME>`来完成这件事。在图形用户界面中切换分支同样简单：只需找到许多页面左上角存在的分支下拉菜单，切换到你喜欢的分支即可。有时容易忘记你当前所在的分支，因此养成时常检查此下拉菜单的习惯是个好主意，帮助自己保持方向感。
- en: Tip
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'It probably goes without saying, but we’ll say it anyway: switching the branch
    using a terminal command only changes the branch that you’re on in your local
    repository and not the branch that you’re on in the golden copy of the repository
    hosted on GitLab. Similarly, changing the branch in the GitLab GUI only changes
    the branch that you’re on in the GitLab-hosted repository, not the branch that
    you’re on in your local repository. So, don’t switch in one location and assume
    that you’ve also switched on the other; the local and remote copies of your repository
    are completely independent when it comes to keeping track of which branch you’re
    on.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能不言而喻，但我们还是要说一下：使用终端命令切换分支只会改变你本地仓库中所在的分支，而不会改变你在 GitLab 上托管的仓库中的分支。同样，在 GitLab
    图形界面中切换分支只会改变你在 GitLab 托管的仓库中所在的分支，而不会改变你在本地仓库中的分支。因此，不要在一个位置切换分支后就认为你在另一个位置也切换了；本地和远程仓库中的分支是完全独立的。
- en: Commit history
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提交历史记录
- en: 'One of the most common operations with a Git repository is to look at the history
    of the commits on a particular branch, as seen in *Figure 3**.8*. As you learned
    in [*Chapter 2*](B18073_02.xhtml#_idTextAnchor035), running `git log` in a terminal
    will show you a reverse-chronological history of all commits made to whatever
    branch you’re on in the local repository, along with the author, timestamp, **Secure
    Hash Algorithm** (**SHA**), and commit message of each commit. You can do the
    same thing in the GitLab GUI by navigating to the main page of a project, selecting
    the branch you’re interested in from the branch dropdown, and clicking the **History**
    button:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Git 仓库中最常见的操作之一是查看特定分支上提交的历史记录，如*图 3.8*所示。正如你在 [*第 2 章*](B18073_02.xhtml#_idTextAnchor035)中学到的那样，在终端中运行`git
    log`会显示你所在分支的所有提交的反向时间顺序历史记录，包括每次提交的作者、时间戳、**安全哈希算法**（**SHA**）和提交信息。你也可以在 GitLab
    图形界面中做同样的事情，只需导航到项目的主页，选择你感兴趣的分支（从分支下拉菜单中），然后点击**历史记录**按钮：
- en: '![Figure 3.8 – List of commits on a branch](img/Figure_3.08_B18073.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8 – 分支上的提交列表](img/Figure_3.08_B18073.jpg)'
- en: Figure 3.8 – List of commits on a branch
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 分支上的提交列表
- en: The history is a list of commits on this branch, with the most recent at the
    top of the list. This list includes the same information about each commit as
    you would get from the `git log` command. A nice bonus of using a GUI such as
    this is that you can click on any commit within the list to see every edit made
    to every file in the commit, displayed in an easy-to-read side-by-side format
    (switchable to an inline format, if you find that easier to parse visually). Of
    course, you can get this same information within a terminal with the `git diff`
    command, but that output is not nearly as easy to read as the output shown in
    the GitLab GUI.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 历史记录是该分支上提交的列表，最新的提交在列表的顶部。这个列表包含与`git log`命令相同的每个提交信息。使用这样的图形界面一个很好的附加功能是，你可以点击列表中的任何提交，查看每个文件中所做的所有编辑，以易于阅读的并排格式显示（如果你觉得这种格式更容易查看，也可以切换为内联格式）。当然，你也可以在终端中使用`git
    diff`命令获得相同的信息，但终端输出远没有 GitLab 图形界面中的输出那么容易阅读。
- en: Merging one Git branch into another
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合并一个 Git 分支到另一个分支
- en: 'Merging a branch into another branch is the first action that’s performed significantly
    differently in the GUI versus in a terminal. As you will remember, you can merge
    `branch-a` into `main` (to pick two sample branch names) from the command line
    using `git checkout main` followed by `git merge branch-a`. But, doing this same
    operation in the GitLab GUI requires an MR. This is one of the most important
    and often used parts of GitLab, so it’s a critical thing to understand and get
    practice with. It’s important to understand that a merge request is the *only*
    way to merge one branch into another from within the GitLab GUI. Here’s a sample
    merge request from one of your Hats for Cats projects:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitLab 图形界面中，将一个分支合并到另一个分支是与终端中的操作显著不同的第一个操作。如你所记得，你可以通过命令行使用`git checkout
    main`，然后执行`git merge branch-a`，将`branch-a`合并到`main`（以两个示例分支名称为例）。但是，在 GitLab 图形界面中执行相同的操作需要一个合并请求（MR）。这是
    GitLab 中最重要且最常用的部分之一，因此理解并练习这一操作非常关键。需要理解的是，合并请求是从 GitLab 图形界面中将一个分支合并到另一个分支的*唯一*方法。以下是你某个
    Hats for Cats 项目中的示例合并请求：
- en: '![Figure 3.9 – Sample merge request](img/Figure_3.09_B18073.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9 – 示例合并请求](img/Figure_3.09_B18073.jpg)'
- en: Figure 3.9 – Sample merge request
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – 示例合并请求
- en: Merge requests
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合并请求
- en: 'A merge request is exactly what it sounds like: a GitLab component that represents
    a request that somebody (maybe you, maybe somebody else) merge one branch into
    another in the golden copy of the repository on a GitLab instance. A merge request
    looks a lot like an issue. It contains many of the same fields, including a title,
    a description, an assignee, and a threaded discussion.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 合并请求就是字面意思：GitLab 中的一个组件，表示某人（可能是你，也可能是别人）请求将一个分支合并到 GitLab 实例的仓库金本副本中的另一个分支。合并请求看起来很像一个问题，它包含了许多相同的字段，包括标题、描述、受指派人以及线程式讨论。
- en: But, merge requests add a few extra fields that don’t exist in issues. These
    include the `branch-a` into `main`, the source branch would be `branch-a` and
    the target branch would be `main`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，合并请求会添加一些在问题中不存在的额外字段。这些字段包括 `branch-a` 到 `main`，其中源分支为 `branch-a`，目标分支为
    `main`。
- en: Merge requests also display the Git commits that are on the source branch, and
    collect all the edits from each commit into a single screen within the MR. This
    lets you see exactly how merging the source into the target would affect the files
    of the target branch.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 合并请求还会显示源分支上的 Git 提交，并将每个提交的所有修改收集到合并请求中的单个页面内。这让你能够精确看到将源分支合并到目标分支时会如何影响目标分支中的文件。
- en: Another aspect of merge requests that separates them from issues is that they
    contain a special pane that displays the results of the automated tests and scans
    that the CI/CD pipeline has performed on the code in the branch. We’ll talk about
    this pane in more detail later, but you can think of it as a one-stop shop for
    showing the overall status of the code that you’re developing. Is it doing what
    it’s supposed to do? Does it have security vulnerabilities? Is it introducing
    dependencies that use unacceptable software licenses? In short, by looking at
    this pane, you can quickly see whether the work you’re doing on the branch is
    making the overall software product better or worse. This is a very handy feature,
    for sure!
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 合并请求的另一个特点是，它们包含一个特殊面板，显示 CI/CD 管道对分支中的代码进行的自动化测试和扫描结果。我们稍后会更详细地讨论这个面板，但你可以将其视为显示你正在开发的代码总体状态的“一站式商店”。它是否按预期工作？是否存在安全漏洞？是否引入了使用不被接受的软件许可证的依赖？简而言之，通过查看这个面板，你可以快速判断你在该分支上进行的工作是让整体软件产品变得更好还是更差。这无疑是一个非常实用的功能！
- en: Finally, merge requests contain a big, impossible-to-miss **Merge** button.
    The mission of a merge request is to merge one branch’s commits into another branch,
    so it would be useless if it didn’t give users a way to perform the merge. There
    are many reasons this button might be grayed-out and unclickable, thereby blocking
    the merge from happening.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，合并请求中包含一个大而显眼的 **Merge** 按钮。合并请求的任务是将一个分支的提交合并到另一个分支，所以如果没有提供执行合并的方式，这个按钮就没有意义。这个按钮可能因为许多原因变成灰色并无法点击，从而阻止合并的进行。
- en: 'The following list is some examples of why a merge might be blocked. Note that
    most of these blocking behaviors are configurable, so you can decide which works
    best for your team:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些合并请求被阻止的原因示例。请注意，许多这些阻止行为是可以配置的，因此你可以决定最适合你团队的配置：
- en: The merge request title starts with `Draft`. This indicates that the branch
    associated with the merge request is still a work in progress, and the developer
    does not intend for it to be merged yet.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并请求标题以 `Draft` 开头。这表明与合并请求关联的分支仍在进行中，开发者不打算立即合并。
- en: GitLab’s license scanner (more about this in a later chapter) detects that the
    merge request is introducing a dependency with a license that’s incompatible with
    the overall project’s license.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitLab 的许可证扫描器（稍后章节会详细介绍）会检测到合并请求引入了一个与整体项目许可证不兼容的依赖。
- en: Automated tests fail for the most recent commit to the branch associated with
    the merge request.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化测试未通过与合并请求关联的分支最近一次提交的测试。
- en: One or more discussion threads in the merge request are unresolved.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并请求中的一个或多个讨论线程未解决。
- en: The merge request hasn’t received enough approvals, or approvals from the right
    people, to satisfy the approval rules. We’ll describe this in more detail next.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并请求没有获得足够的批准，或者没有得到合适人员的批准，无法满足审批规则。我们将在接下来的内容中更详细地描述这一点。
- en: Reviewing and approving code in merge requests
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 审查和批准合并请求中的代码
- en: 'Because merge requests have the power to alter the files in the target branch,
    and the target branch is almost always `main`, `master`, or whatever branch holds
    your stable, production-ready code, it’s critical that every MR is scrutinized
    by members of the development team. Fortunately, merge requests have several features
    to enable code reviews:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: You can **link comments directly to one or more lines in a file**, so it’s obvious
    which lines of code you’re referring to when you make suggestions for improving
    them (or when you praise them).
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can **propose alternative code** right in the discussion section. These
    proposals even include a button that allows the original author to accept your
    suggestions with a single click on the GUI.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can **assign reviewers** from your team. They will receive notifications
    via email saying that you’d like them to review the edits in your merge request.
    These reviewers are listed in a metadata field in the MR, so everyone on your
    team knows who has been asked to review the files.
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Team members can **approve your code**. This is a separate concept from reviewing
    your code. Reviewing is usually a repeated process that consists of a review,
    followed by the original author making fixes in response to your review, followed
    by another review, followed by more fixes, and so on. An approval is a single,
    one-time “thumbs up” that means that the approver considers your edits to be ready
    to merge.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can create **rules for who must approve your MR** before it can be merged.
    These rules can become quite complicated and can involve several groups of people.
    Here are three sample rules for who must approve a merge request in order for
    it to be unblocked:'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 1**: Either the tech lead or the architect for your team'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 2**: Your development team manager'
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rule 3**: Any one of the three members of the quality assurance team, plus
    any one of two members from the security team, plus two of the three architects'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, MRs are critical to getting your edits reviewed, approved, and
    merged into the right branch.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: Creating a merge request before you commit code
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are several ways to create merge requests, including a few shortcuts that
    GitLab provides in possibly unexpected (but helpful) places. As we’ve done previously
    when describing other GitLab components, we’ll ask you to look at the official
    GitLab documentation for up-to-date instructions on how to use the GUI to create,
    view, and manage merge requests.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: However, we should definitely give you some guidance on *when* to create merge
    requests. This might sound odd or counterintuitive, but *we recommend that you
    create a merge request for a branch immediately after creating the branch, before
    you’ve committed any code to* *the branch*.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: This advice probably sounds especially strange if you’ve used tools like GitHub
    before. GitHub’s merge requests (known as **pull requests**) are usually created
    *after* you’ve committed all the code you intend to put on a branch. After all,
    if the purpose of a merge request is to merge the source branch’s edits into the
    target branch, what’s the point of opening a merge request when there isn’t any
    code on the source branch to merge?
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: Using a merge request as a dashboard for your code
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are two reasons why making MRs early in the workflow is such a widely
    accepted best practice among GitLab users. First, an MR serves as a “dashboard”
    that lets you know about the overall quality of the code you’re adding to the
    branch. The dashboard answers questions like the following:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Are automated tests passing?
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does your code meet performance requirements?
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has your code introduced any security vulnerabilities?
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it adds any new third-party dependencies, do they use licenses that are compatible
    with your overall project license?
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does your code satisfy style and quality requirements?
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you distribute your app as a Docker image, are there any known security vulnerabilities
    in the base Docker image that your code is packaged with?
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These results are all available for viewing in other parts of the GitLab GUI,
    but it’s convenient to see them all neatly presented within an MR.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: More importantly, when you view the results within the MR, you see a “delta”
    view of these results. In other words, the results in the MR will tell you how
    the test and scan results for the MR’s associated branch *differ* from the results
    of the same test and scans as run against your default branch. This is incredibly
    valuable because it lets you know whether the code that you are contributing to
    the branch is headed in the right direction. To put it simply, *are your commits
    to the branch making your software better or worse?*
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Of course, if you wait to create a merge request until you’re all done coding,
    you won’t benefit from this constant guidance on whether you’re on the right track
    with your commits. This is, all by itself, a great reason to create an MR before
    you’ve committed any code to your branch.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Merge requests improve collaboration
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'But, there’s another compelling reason to create your MR early in the development
    workflow: *merge requests encourage collaboration among team members*. By providing
    an area for threaded discussions, they let your coworkers review and comment on
    every commit you make. Are you introducing subtle bugs? Your coworkers can spot
    them and alert you when they’re still easy to fix. Are you starting to code an
    algorithm that’s not as fast as an alternative? Someone can let you know before
    you commit many hours and lines of code to build the wrong thing. Are you misusing
    certain idioms in your programming language? If a senior developer can point that
    out early in the process, you can adjust your style before committing any more
    code to the branch.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'These scenarios all share a common theme: by collaborating early and often,
    by reviewing small pieces of code that arrive in a single commit, problems become
    easier to spot and cheaper to fix. MRs are exactly the place where this kind of
    collaboration can occur.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Anyone who has been asked to review a completed feature that consists of 3,000
    lines of code knows the sinking feeling of being unsure where even to begin. Or
    the despair you feel when you realize that the developer has misunderstood the
    specifications and not built the feature that the product owner intended. Or the
    awkwardness that comes from pointing out a programming or style error that the
    developer has made hundreds of times throughout the feature’s code. All these
    situations can be avoided by frequent reviews of small pieces of code. And, that’s
    only possible when you have a merge request ready to go before the first commit
    lands.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: The frequent collaboration enabled by merge requests not only helps the folks
    who are reviewing the code but also helps the author of that code. In the same
    way that automated test failures are easier to troubleshoot and fix when the commit
    that caused the failures consists of small pieces of code, it’s also easier to
    fix style problems, suboptimal algorithms, or bugs when a code reviewer spots
    those problems in a 12-line piece of code than it is when they call out those
    problems in 3,000 lines of code that make up the completed feature or bug fix.
    It’s far better and easier to adjust your coding practices early in the development
    process than it is to have to go back and make potentially complicated or even
    destabilizing fixes after you thought you were done coding.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: These principles apply to security vulnerabilities as well. A truism in software
    is that you must take security into account throughout the entire development
    workflow; you can’t just tack it on at the end. The frequent security scan results
    that show up in merge requests help make it possible to honor this principle by
    “baking in” security from the very beginning of the development workflow. Code
    reviews by experienced developers or members of your security team also help achieve
    this goal, and the MR discussion pane is exactly where that sort of code review
    takes place. This principle of “shifting left”—which we’ve discussed earlier in
    this book—is especially important when it comes to security. This is because security
    problems sometimes require extensive rethinking and reworking of basic architectural
    decisions in your software. This kind of repair is much easier, cheaper, and less
    disruptive when the code base is smaller and simpler, as it tends to be when work
    has just begun on a new feature.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: The three amigos – issues, branches, and merge requests
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You now know quite a bit about issues, branches, and merge requests. It’s important
    to understand that these three GitLab components are closely related when they’re
    used to plan and accomplish a programming task.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'GitLab recommends a particular workflow for these three components. They suggest
    that you first create an issue as soon as you’ve identified work to be done. As
    soon as that issue is assigned to a developer, the developer should immediately
    make a branch to work on, and then create a merge request for that branch. The
    issue, branch, and merge request should all have similar (or sometimes even identical)
    titles to show that they are related to each other. For example, if you saw these
    components, you’d know from their titles that they all address the same task:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '`simplify the` `login process`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`simplify-login-process`'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`simplify the` `login process`'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because issues, branches, and merge requests are so closely related, and because
    all three are usually required when completing any coding work with GitLab, you’ll
    sometimes see them referred to as the **three amigos**. If you’re not sure how
    to start work on a programming task, a good rule of thumb is to make sure you
    have the three amigos all lined up before you write any code.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: When two amigos are enough
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: However, it’s also worth mentioning that you don’t *have* to have all three
    components for every task. If a task doesn’t require you to edit any files in
    your repository, there’s no need for a branch, which means there’s also no need
    for a merge request. You might remember that, earlier, we said that a possible
    use case for an issue would be to solicit T-shirt designs for an upcoming corporate
    event. Those T-shirt designs could all be added directly to the issue’s discussion
    section. You don’t need to edit any files to satisfy the requirements of that
    task, so you could get away with not making a branch, and not making an associated
    merge request. In fact, making a branch and merge request issue would probably
    be confusing to your coworkers because it suggests that you *do* expect files
    to be edited while completing this work.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, there are cases where you need a branch and merge request, but don’t
    need an issue. For example, imagine that you need to fix a tiny, trivial typo
    in your code. You *could* make an issue describing the problem, but that’s probably
    overkill for such a small edit. It seems more appropriate in this case to simply
    make a branch and merge request, then make a single commit that fixes the typo,
    and then ask for review and approval of the MR. Most GitLab users would probably
    agree that no issue is needed (although no harm would come from making one). Having
    said that, some organizations might decide that every MR requires a related issue,
    which is also a perfectly acceptable policy, even if it occasionally leads to
    some extra work.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: How are issues and merge requests different?
  id: totrans-259
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might find yourself wondering how issues and merge requests differ. We’ve
    already discussed the extra kinds of information that merge requests contain,
    but there’s a philosophical difference between the two components that’s helpful
    to keep in mind. Think of issues as being the place to present and discuss **ideas**.
    A merge request, on the other hand, is where you present and discuss **code**.
    If you use this concept to distinguish the two, that will help you understand
    when just one of them is needed versus when both are needed. It also helps you
    understand whether any comments you might have are better suited to the discussion
    section in the issue (if you’re talking about the general idea of the work) or
    the discussion section in the merge request (if you’re talking about the specific
    code delivered by a developer).
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Another difference between issues and merge requests is the different status
    values they can have. Issues can be **open** or **closed**, whereas merge requests
    can be **open**, **closed**, or **merged**. In fact, closed merge requests are
    somewhat rare, as that status is only used when you abort a merge request instead
    of following through with the merge. That does happen sometimes, but the far more
    common outcome for a merge request is for it to transition to the **merged** status
    once its associated branch is merged.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Now, you’ve seen how to use the GitLab GUI to deal with fundamental concepts
    such as commits, branches, and merge requests. You’ve also been shown how issues
    and merge requests may look similar at first glance, but serve importantly different
    roles within GitLab. You understand why it’s important to create a merge request
    before you’ve committed any edits to merge, and how merge requests support close,
    frequent collaboration among team members. Finally, you know about the three amigos
    of issues, branches, and merge requests, and you understand how they work together
    to help you plan work, complete work, and merge any code changes that result from
    that work. In other words, you’ve been exposed to all of the fundamental building
    blocks of using GitLab to write software, even if you’re still in the dark about
    how GitLab verifies, secures, packages, and deploys the software once you’ve written
    it. But, we’ll get there soon, we promise!
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Enabling DevOps practices with GitLab flow
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s end this chapter by seeing how issues, branches, and merge requests fit
    together in a realistic example. This shows GitLab’s recommended best practice
    for how to use all the components you’ve been introduced to in a smooth workflow
    that works for most situations. In fact, this workflow is so strongly recommended
    and so well proven over time that GitLab even has a name for this workflow: **GitLab
    flow**. As always, you’re encouraged to treat this workflow as a starting point
    when developing your own processes and procedures; feel free to tinker with it
    as needed for your team, product, and organizational culture.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'While working on the Hats for Cats web app, you decide to add a feature that
    lets you filter the hats by cat breed. After all, a cowboy hat for a large-headed
    Maine Coon might swamp the dainty head of a Devon Rex. Here are all the steps
    prescribed by GitLab flow to bring that feature into existence:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: In the `Filter hats by breed`, leaving all metadata fields empty.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the issue’s discussion section, you mention two people who you think might
    have opinions on whether this feature is a good idea.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both those people add replies to the discussion section. One just leaves a thumbs-up
    emoji. The other expresses support for the idea but asks whether the app should
    filter by other criteria as well.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You decide that filtering by other criteria is a good idea, but you’re not
    sure what those criteria should be. You make another issue titled `Question: what
    criteria should we use when filtering hats?` You set this issue aside to deal
    with later and return your focus to the `Filter hats by breed` issue because you’re
    confident that breed should be one of the criteria.'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At a team-wide planning meeting, the group decides to assign the issue a weight
    of 8, which for your team means it’s expected to be a 1-week task. You assign
    the issue to a backend developer named Elizabeth, and you set its due date field
    to 2 weeks from today.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Elizabeth applies a *scoped* **Status::In Progress** label and an *unscoped*
    **Back-end** label to the issue. This will help the team keep track of whether
    the issue is on track and understand who is responsible for it.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Elizabeth makes a temporary branch called `filter-hats-by-breed` to hold her
    commits.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Elizabeth creates a merge request titled `Draft: Filter hats by breed`. She
    assigns teammates Alice and Bob to review the merge request. They have nothing
    to do yet since Elizabeth hasn’t added any code to the MR’s branch.'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that Elizabeth has the three amigos of issue, branch, and merge request
    set up, she starts coding.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After she finishes a small, testable chunk of code, she commits it to her branch.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Elizabeth looks at the MR to see the results of the automated tests, code quality
    scans, license scans, and security scans that ran against her first commit. They
    don’t report any problems, so she celebrates with a mug of Assam tea with extra
    sugar.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Alice and Bob get email notifications that Elizabeth has committed code to the
    MR’s branch. They look at the MR and review her changes. Both add some comments
    about what parts of her code they like, and what parts can be improved.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Some of the suggestions seem wrong to Elizabeth, so she adds comments in the
    MR’s discussion section explaining her point of view. She continues to talk it
    out until they all reach an agreement about how she should proceed. Elizabeth
    adds a new commit with the agreed-upon fixes.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once again, Elizabeth looks in the MR to see the results of automated tests
    and scans against her last commit. One of the security scans points out a vulnerability
    that she unwittingly introduced. She quickly adds a new commit that fixes the
    vulnerability. The scans run again on this fixed code, and this time it’s smooth
    sailing.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Elizabeth gets a thumbs-up review from both Alice and Bob on all the code she’s
    committed so far, so her work is done. She removes the **Back-end** label, adds
    a **Front-end** label, and re-assigns the issue to a frontend engineer named George.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: George writes some frontend code and adds a few commits to the same `filter-by-breed`
    branch that Elizabeth was using. Each commit triggers a new run of automated tests
    and scans, and each is reviewed by Alice and Bob.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: George realizes that the work is falling behind schedule, so he adds an **At
    Risk** label to the original issue. The development manager responds to this by
    assigning another frontend developer named Helen to help George.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The cycle of commit-then-review-then-inspect-automated-test-and-scan-results
    continues for a few more rounds until George and Helen complete the feature. They
    remove the **At Risk** label. Alice and Bob are satisfied with the code, and both
    add thumbs-up emojis to the discussion.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: George removes `Draft:` from the title of the issue, indicating that he considers
    the code ready to be merged.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: George mentions the security and QA teams in the MR’s discussion so they can
    approve it. Until they do, the **Web** project’s approval rules block the MR from
    being merged.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One member of the security team and two members of the QA team mark the MR as
    “approved.” This re-activates the MR’s merge button. With great glee and a feeling
    of accomplishment, George removes the **Front-end** and **Status::In Progress**
    labels and clicks the MR’s merge button.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The whole team goes out to a pub to celebrate and eats an uncomfortable quantity
    of pizza.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s a diagram showing this flow, but with some steps removed for clarity:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Major steps in GitLab flow](img/Figure_3.10_B18073.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – Major steps in GitLab flow
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-291
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You’ve been exposed to an awful lot of concepts and terminology in this chapter,
    so let’s do a quick review.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: GitLab is a web application whose mission is to solve many of the problems faced
    by people involved with any of the 10 stages of the SDLC. So, GitLab doesn’t solve
    just one problem; it solves many problems that exist in many different facets
    of software development.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Working with GitLab happens mostly within a GitLab project, which represents
    one software product, one portion of your org chart, or one initiative. Projects
    that share a similar theme can be collected within GitLab groups, and groups can
    also contain subgroups.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Each individual task or chunk of work is recorded in a GitLab issue. Issues
    describe the work to be done, allow team members to participate in a discussion
    about the issue, and include many fields to store metadata about the issue. Issues
    usually represent software-related tasks, but can (and should) be used to describe,
    plan, and track non-technical work as well.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: You can create *scoped* or *unscoped* labels to highlight issue statuses or
    health, or to indicate which person or team is responsible for doing work on the
    issue. You can assign labels to merge requests as well as issues.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'A GitLab merge request is the component you use for merging one branch into
    another within the GitLab GUI. Each merge request lists a source branch and a
    target branch, and merging the merge request will cause any commits that were
    only on the source branch to be added to the target branch. Merge requests look
    similar to issues, but they serve different purposes: the former is used for describing,
    discussing, and merging code. The latter is used for describing and discussing
    ideas and tasks.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the GitLab GUI for performing many common Git-related tasks
    besides managing merge requests. For example, you can use the GUI to create a
    branch, add a commit, show a list of commits on a branch, or assign a tag to a
    commit.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: GitLab flow is the best practice workflow for using all of the GitLab components
    in a proven, reliable way to build software. You’re not required to use GitLab
    flow, but it’s a great starting point for figuring out what workflow and policies
    work best for your organization or team.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we’ve been dancing around a central part of GitLab flow: the **CI/CD
    pipelines** that run countless different checks on your code once you’ve committed
    it to a repository. In the next chapter, we’ll tackle it head-on, and get to the
    heart of what is possibly GitLab’s most powerful and most helpful feature.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
