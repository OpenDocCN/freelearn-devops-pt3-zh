<html><head></head><body>
		<div id="_idContainer037">
			<h1 id="_idParaDest-151" class="chapter-number"><a id="_idTextAnchor212"/>8</h1>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor213"/>Developing and Managing Modules</h1>
			<p>Having reviewed many aspects of the Puppet language, it is clear that using manifest files and classes alone would not scale or provide the structure needed as a code base grows for a diverse range of servers and customer requirements. In this chapter, we will review the components required to create Puppet code at scale. We will be looking at Puppet <strong class="bold">modules</strong>, which <a id="_idIndexMarker528"/>allow us to bundle code and data focused on a single technology implementation, thus making it easy to share and combine with other implementations. Then, we’ll explore the <strong class="bold">roles and profiles method </strong>to show you how profiles can group modules to create technology stacks and roles, then combine profiles to match business requirements. After, we’ll cover the <strong class="bold">Puppet Development Kit </strong>(<strong class="bold">PDK</strong>), showing how it can automate the process of creating and managing modules. The directories and files templated by the PDK will be shown, highlighting its built-in validation and linting checks, as well as unit compilation checks. Next, we’ll look at <strong class="bold">Rspec</strong>, as a method that expands on this to provide more thorough unit testing, as well as <strong class="bold">ServerSpec</strong>, which is used for server testing, at a high level. Then, we’ll discuss the <strong class="bold">Puppet Forge </strong>catalog, which acts as the source of modules developed by Puppet itself, as well as vendors and members of the community. We will show you how to filter various aspects of modules to understand how they are supported, their compatibility with OS and Puppet versions, and scoring/scanning ratings so that you can choose the best module for your <span class="No-Break">organization’s needs.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>What is a module and what is <span class="No-Break">in it?</span></li>
				<li>Roles and <span class="No-Break">profiles method</span></li>
				<li>The PDK and how to write and test <span class="No-Break">a module</span></li>
				<li>Testing using RSpec <span class="No-Break">with PDK</span></li>
				<li>Understanding <span class="No-Break">Puppet Forge</span></li>
			</ul>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor214"/>Technical requirements</h1>
			<p>This chapter does not require any infrastructure to be deployed. All actions can be performed from your <span class="No-Break">developer desktop.</span></p>
			<h1 id="_idParaDest-154"><a id="_idTextAnchor215"/>What is a module and what is in it?</h1>
			<p>Modules<a id="_idIndexMarker529"/> provide us with a way to group code and data, making it easier to share and reuse code that is part of a specific technology implementation. Almost all of your Puppet code will be stored in modules of one kind or another. You should work out the scope of your module to create focused modules with a single clear responsibility. If you were deploying a LAMP or WAMP stack, you would not make a single module that configured all components; instead, you would break it into individual modules, including OS settings, MySQL, and Apache. This allows greater code reuse and reduces the complexity of any <span class="No-Break">individual module.</span></p>
			<p>A module is a directory named with similar criteria to a class, so it must begin with a lowercase letter and can only contain lowercase letters, numbers, and underscores. Unlike classes, modules cannot be nested and do not us<a id="_idTextAnchor216"/>e the <strong class="source-inline">::</strong> symbol. Reserved words and class names should not be used as <span class="No-Break">module names.</span></p>
			<p>Modules have a directory structure that allows Puppet to know where various types of code and data will be stored and autoloaded as requested. As discussed in <a href="B18492_06.xhtml#_idTextAnchor185"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, a scope namespace and file service namespace for that module will be created. The core code and data <a id="_idIndexMarker530"/>are stored in the <span class="No-Break">following directories:</span></p>
			<ul>
				<li><strong class="source-inline">data</strong>: Contains module-based data for parameter defaults, which will be covered in <a href="B18492_09.xhtml#_idTextAnchor233"><span class="No-Break"><em class="italic">Chapter 9</em></span></a><span class="No-Break"><em class="italic">.</em></span></li>
				<li><strong class="source-inline">examples</strong>: Contains examples of how to declare the modules’ classes and <span class="No-Break">defined types.</span></li>
				<li><strong class="source-inline">files</strong>: Contains static file content that can be placed <span class="No-Break">by Puppet.</span></li>
				<li><strong class="source-inline">manifests</strong>: Contains all the manifests of the module and directories that <span class="No-Break">provide structure.</span></li>
				<li><strong class="source-inline">template</strong>: Contains the EPP and ERB template files to be used by <span class="No-Break">Puppet code.</span></li>
				<li><strong class="source-inline">tasks</strong>: Contains tasks for procedural work. This will be covered in <a href="B18492_12.xhtml#_idTextAnchor293"><span class="No-Break"><em class="italic">Chapter 12</em></span></a></li>
			</ul>
			<p>Modules also<a id="_idIndexMarker531"/> have what is <a id="_idIndexMarker532"/>known as <strong class="bold">plugins</strong>, allowing them to distribute various custom Puppet components to the Puppet server or agent, as relevant. Some of these plugins are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">lib/facter</strong>: Custom facts written<a id="_idIndexMarker533"/> in <strong class="bold">Ruby </strong>that are used on <span class="No-Break">the agent</span></li>
				<li><strong class="source-inline">lib/puppet/functions</strong>: Custom functions written in Ruby that are used by <span class="No-Break">the server</span></li>
				<li><strong class="source-inline">lib/puppet/type</strong>: Custom resource types that are used on both the server <span class="No-Break">and agent</span></li>
				<li><strong class="source-inline">lib/puppet/provider</strong>: Custom resource providers written in Puppet that are used on both the server <span class="No-Break">and agent</span></li>
				<li><strong class="source-inline">lib/augeaus/lenses</strong>: Custom Augeas lenses that are used on the <span class="No-Break">agent side</span></li>
				<li><strong class="source-inline">facts.d</strong>: External facts or static scripts that are used on <span class="No-Break">the agent</span></li>
				<li><strong class="source-inline">functions</strong>: Customs functions written in Puppet that are used on <span class="No-Break">the server</span></li>
			</ul>
			<p>It is important <a id="_idIndexMarker534"/>to note that certain plugin types, such as resource types, are not isolated fully in environments. Environments will be discussed in detail in <a href="B18492_11.xhtml#_idTextAnchor272"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, where we will focus on classification and release management, but for now, note that environments allow isolated code bases to be used by nodes so that they can use different versions of code. This is due to the way Ruby loads the first resource type and makes it global, ignoring any duplicates found. Therefore, it is important to consult the Puppet documentation: <a href="https://puppet.com/docs/puppet/latest/environment_isolation.html#environment_isolation">https://puppet.com/docs/puppet/latest/environment_isolation.html#environment_isolation</a>. You can configure environment isolation as necessary if you use modules containing plugins that cannot be isolated. Puppet Enterprise provides isolation in environments <span class="No-Break">by default.</span></p>
			<p>Modules can be used in different ways. While most of this chapter will focus on modules that use Puppet code for configuration, modules can be used to distribute an item or items. An example of this is the PowerShell module in Puppet Forge (<a href="https://forge.puppet.com/modules/puppetlabs/powershell">https://forge.puppet.com/modules/puppetlabs/powershell</a>), which is used only to distribute a new exec provider using the provider <span class="No-Break">plugin directory.</span></p>
			<p>Focusing on the <strong class="source-inline">manifests</strong> directory, the manifest files will have the same name as the class name they contain. The major exception to this is the main manifest, which is named <strong class="source-inline">init.pp</strong>, but has the class name of the module. This main manifest is often used as the entry point to the module. As discussed in <a href="B18492_06.xhtml#_idTextAnchor185"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, a module namespace is created for the module, allowing us to include the module in code by running <strong class="source-inline">include &lt;</strong><span class="No-Break"><strong class="source-inline">module name&gt;</strong></span><span class="No-Break">.</span></p>
			<p>The classes <a id="_idIndexMarker535"/>should be self-contained and small, focusing on one aspect. A common piece of advice on how to identify a class that is too big is when it is too large to view in a single editor screen. With this in mind, one of the most common patterns when starting with modules is to use the main manifest, <strong class="source-inline">init.pp</strong>, as an entry point that takes parameters to be used across the module. After, it calls other classes that are used and sets their ordering. An example of this is using an <strong class="source-inline">install</strong> class to install resources such as packages, a <strong class="source-inline">config</strong> class to add any configuration files or users, and a <strong class="source-inline">service </strong>class to manage the service. The following code shows an example of a main manifest for <span class="No-Break">this pattern:</span></p>
			<pre class="source-code">
class exampleapp (
  Boolean $package_managed = true,
  Integer $package_version = 3,
  Boolean $user_managed = true,
  Integer $user_id= 10,
  Boolean $service_enable = true,
  Integer $jmx_heap_size = 1024,
  Integer $thread_number = 10,
)
{
  contain exampleapp::install
  contain exampleapp::config
  contain exampleapp::service
  Class['exampleapp::install']
  -&gt; Class['exampleapp::config']
  ~&gt; Class['exampleapp::service']
}</pre>
			<p>Considering the available parameters, such as the public API of the module, would allow the module to be flexible; in addition, consistency should be maintained when naming these parameters. Here, we use an approach where parameters are named based on their effect. So, for <strong class="source-inline">exampleapp</strong>, it can be seen that both the package and user take a Boolean to declare if the module is managing them as a resource. A Boolean is used on <strong class="source-inline">service_enable</strong> to decide if the service is enabled on boot, while integers are provided for <strong class="source-inline">user_id </strong>and <strong class="source-inline">package_version</strong>. Two additional integers are then used for configuring the application, setting the Java memory size, and the thread number. These parameters can be accessed using the module namespace and performing a data lookup for the variable at <strong class="source-inline">modulename::variablename</strong>. This is known as automatic parameter lookup and will be covered in detail when we review how Puppet handles data in <a href="B18492_09.xhtml#_idTextAnchor233"><span class="No-Break"><em class="italic">Chapter 9</em></span></a><span class="No-Break">.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Parameters and other aspects of a module can be documented via comments in the header of the code, which can then be generated in different formats using the Puppet Strings gem. Details can be found in the Puppet Strings style guide and on the following web <span class="No-Break">page: </span><a href="https://puppet.com/docs/puppet/latest/puppet_strings_style.html"><span class="No-Break">https://puppet.com/docs/puppet/latest/puppet_strings_style.html</span></a><span class="No-Break">.</span></p>
			<p>We adopt the<a id="_idIndexMarker536"/> approach of using containment and ordering on the classes within the module. This ensures, if requested, that the package is installed, the configuration is added, and the service is then managed or refreshed since each stage depends on the next. The <strong class="source-inline">contain</strong> keyword should not be considered a default to be used instead of <strong class="source-inline">include</strong>; it should only be used when it is this component module style and when the classes will only ever only be used within the main class. In the <em class="italic">Roles and profiles method </em>section, you will see where containment and ordering like this would <span class="No-Break">be inappropriate.</span></p>
			<p>From this, we can see how these subclasses use the parameters from the main manifest. For example, the <strong class="source-inline">install</strong> manifest uses an <strong class="source-inline">if</strong> statement on the <strong class="source-inline">package_managed</strong> variable; if it’s <strong class="source-inline">True</strong>, it installs the version of the <strong class="source-inline">exampleapp</strong> package set by the <span class="No-Break"><strong class="source-inline">package_version</strong></span><span class="No-Break"> </span><span class="No-Break">variable:</span></p>
			<pre class="source-code">
class exampleapp::install {
if $exampleapp::package_managed {
  package { 'exampleapp':
    ensure =&gt; $exampleapp::package_version
  }
 }
}</pre>
			<p>For the <strong class="source-inline">config</strong> manifest, we can see how the <strong class="source-inline">jmx_heap_size</strong> and <strong class="source-inline">thread_number</strong> variables <a id="_idIndexMarker537"/>can be substituted into a template by using the module namespace to access the template stored in the templates folder in the <span class="No-Break"><strong class="source-inline">exampleapp</strong></span><span class="No-Break"> module:</span></p>
			<pre class="source-code">
class exampleapp::config {
  file { '/etc/exampleapp/app.conf':
    ensure  =&gt; file,
    content =&gt; epp('exampleapp/app.conf.epp', {' jmx_heap_size ' =&gt; $exampleapp::jmx_heap_size , ' thread_number' =&gt; $exampleapp::thread_number }),
  }
}</pre>
			<p>The <strong class="source-inline">service</strong> class is very similar in style to the <strong class="source-inline">install</strong> class. It uses an <strong class="source-inline">if</strong> statement; if this is <strong class="source-inline">True</strong>, it adds a service of <strong class="source-inline">exampleapp</strong> and sets the <strong class="source-inline">enable</strong> parameter based on the <span class="No-Break"><strong class="source-inline">service_enable</strong></span><span class="No-Break"> variable:</span></p>
			<pre class="source-code">
class exampleapp::service
  if $exampleapp::service_managed {
    service{'exampleapp': 
    ensure =&gt; 'running', 
    enable =&gt; $exampleapp::service_enable ,
    }
  } 
}</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">A common module pattern was to use a <strong class="source-inline">params.pp</strong> file to manage default module data. Hiera 5 can now manage module-level data in a more structured way than a manifest file, as will be shown in <a href="B18492_09.xhtml#_idTextAnchor233"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>. The <strong class="source-inline">params.pp</strong> file is still commonly seen in code, particularly where the structure of the data is simple and there is little value in changing it <span class="No-Break">to Hiera.</span></p>
			<p>The <strong class="source-inline">examples</strong> directory <a id="_idIndexMarker538"/>could contain a file called <strong class="source-inline">init.pp</strong>, specifying how the class could <span class="No-Break">be called:</span></p>
			<pre class="source-code">
class { 'exampleapp':
  package_managed =&gt; true,
  package_version =&gt; 3,
  user_managed =&gt; true,
  user_id =&gt; 10,
  service_enable =&gt; true,
  jmx_heap_size =&gt; 1024,
  thread_number =&gt; 10,
}</pre>
			<p>The naming of files is not important in the <strong class="source-inline">examples</strong> directory; there could be several different examples to show common selections of module attributes for different setups. For example, a module might show how it can be included with the minimum default values, but also the required attributes for a specific architecture, such as deploying in a <span class="No-Break">cluster setup.</span></p>
			<p>As the configuration use case becomes more complex, the other most common approach to the module structure can be<a id="_idIndexMarker539"/> seen in the Apache module in the Puppet Forge catalog: <a href="https://forge.puppet.com/modules/puppetlabs/apache">https://forge.puppet.com/modules/puppetlabs/apache</a>. Instead of grouping resources based on simple <strong class="source-inline">package</strong> and <strong class="source-inline">config</strong> classes, the <strong class="source-inline">apache</strong> module breaks down the different components of the application. In this example, the main manifest for Apache performs a default installation of Apache, with a default virtual host and a document root directory, and starts the Apache service. This can be configured by using the relevant module parameters. Here, the Apache service is managed in a separate class, but the resources that would normally have been in the <strong class="source-inline">package</strong> and <strong class="source-inline">config </strong>classes are managed within the Apache main class. There are also various implementation classes, such as <strong class="source-inline">vhosts</strong>, <strong class="source-inline">mod</strong>, and <strong class="source-inline">mpm</strong>, for different <strong class="source-inline">apache</strong> configuration items. This gives the main class a clear purpose of performing the basic installation and configuring the <strong class="source-inline">apache</strong> server so that the implementation classes can focus on specific customizations. For example, the <strong class="source-inline">vhosts</strong> classes are defined types that can be defined for each virtual host the <strong class="source-inline">apache</strong> <span class="No-Break">server requires.</span></p>
			<p>These examples <a id="_idIndexMarker540"/>provide a structure that you can follow for your modules and can be adapted as needed. However, the key lessons to take away are that modules should focus on a single task, only manage their resources (no cross-module dependencies), and be granular <span class="No-Break">and portable.</span></p>
			<p>In this section, we looked at the directory and file structure of a Puppet module and two common patterns for creating modules. These modules, by themselves, configure focused individual technical implementations. In the next section, we will see how a module’s structure can be used to combine modules to produce technical stacks and, by combining technical stacks and configuration, meet the business requirements customers have <span class="No-Break">for servers.</span></p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor217"/>Lab – reviewing the apache module</h1>
			<p>It would be <a id="_idIndexMarker541"/>impractical to print all the key parts of the <strong class="source-inline">apache</strong> module’s code in this book. However, reviewing the code at <a href="https://forge.puppet.com/modules/puppetlabs/apache">https://forge.puppet.com/modules/puppetlabs/apache</a> and reading the <strong class="source-inline">examples</strong> directory to see how the main class, <strong class="source-inline">apache</strong>, is combined with various classes within the module to configure different components will help you understand how this module pattern can <span class="No-Break">be structured.</span></p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor218"/>Roles and profiles method</h1>
			<p>In the previous<a id="_idIndexMarker542"/> section, the modules we discussed are what are known as component modules since they cover single implementations. These modules are mostly of interest to users directly involved with the technology implementation, such as Unix or Windows administrators, where understanding that specific resources have been applied is the most important aspect of the configuration. But different users are not interested in how a node is configured; instead, they are interested in what it does. An application specialist, for example, would care that, for their application, Tomcat and MySQL were installed, not how it was configured. A project manager would care that they got a server that met a business need but not what technical stacks were used. The project manager may also see each implementation as unique, but there will often be a lot of similarities, such as various technology stacks being used across multiple applications using Apache or Java with variations of settings based on location <span class="No-Break">or environment.</span></p>
			<p>Without providing some sort of structure for these levels of logic, trying to apply these modules to nodes would require a lot of duplication and complexity of <span class="No-Break"><strong class="source-inline">if</strong></span><span class="No-Break"> statements.</span></p>
			<p>A pattern called roles and profiles uses a modular structure to achieve this. Role and profile are not keywords but just patterns to use within modules and classes. A simple approach can be to have a module called <strong class="source-inline">role</strong> and a module called <strong class="source-inline">profile</strong>, with each class in these modules representing a role <span class="No-Break">or profile.</span></p>
			<p>These roles represent the business need that a customer, such as a project manager, would require, while a profile would reflect a technical stack for <span class="No-Break">an application.</span></p>
			<p>When looking at how to apply the role and profiles method to the configuration of pre-existing applications, it’s important to look from the role down to the module to avoid the natural temptation of trying to find the technical solution first without the business logic. This involves breaking things down into components and granularly thinking about what it is and not what it looks like. One trick to identifying roles is often to take hostnames, which generally contain information about the location, environment use, and application. For example, a hostname may look like <strong class="source-inline">fk1ora005prd</strong>, where <strong class="source-inline">fk1</strong> is a data center location, <strong class="source-inline">005</strong> is a numerator, and <strong class="source-inline">prd</strong> is the production environment, leaving <strong class="source-inline">ora</strong> as the Oracle application, which would match the role’s name. So, roles should be business names such as <strong class="source-inline">buildserver</strong>, <strong class="source-inline">proxyserver</strong>, or <strong class="source-inline">ecomwebserver</strong>, while the profile should be the technology stack name, such as Apache, Jenkins, <span class="No-Break">or nginx.</span></p>
			<p>This naming isn’t always perfect and sometimes, some of the terms may simply be the same ones that project managers use for ordering Oracle servers. They may be unaware of the underlying profiles of the Oracle role, which would include an Oracle profile and other <span class="No-Break">relevant profiles.</span></p>
			<p>In this case, a <strong class="source-inline">role</strong> class should simply call the required profiles with no variables, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
class role::exampleapp {
  include profile::core
  include profile::java
  include profile::apache
}</pre>
			<p>In<a id="_idIndexMarker543"/> contrast, a <strong class="source-inline">profile</strong> class should contain parameters to customize the module and class declarations to add the <span class="No-Break">required modules:</span></p>
			<pre class="source-code">
class profile::java(
  Pattern[/present|installed|latest|^[.+_0-9a-zA-Z:~-]+$/] $java_version
  String $java_distribution
) {
class { 'java':
  version      =&gt; $java_version,
  distribution =&gt;  $java_distribution,
  }
}</pre>
			<p>In <a href="B18492_09.xhtml#_idTextAnchor233"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, which deals with Puppet and data, you’ll see how Hiera can model the data that overrides the profile defaults. A server should only have one role; if it needs two roles, then it is in itself a new role, but a role will have multiple profiles. <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.1 </em>shows a simple example of using roles, profiles, and modules and how the classes would include one another. With this setup, as we’ll see later in <a href="B18492_11.xhtml#_idTextAnchor272"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, classifying a box is as simple as <a id="_idIndexMarker544"/>ensuring the right role is assigned to <span class="No-Break">the node:</span></p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/B18492_08_01.jpg" alt="Figure 8.1 – An example of roles, profiles, and modules"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – An example of roles, profiles, and modules</p>
			<p>The framework shown in the preceding figure is all about abstraction, so we decouple the business logic, implementation, and resource management and reduce the <span class="No-Break">node-level complexity.</span></p>
			<p>This <a id="_idIndexMarker545"/>pattern is not a requirement but provides suggestions on how you can structure code to avoid duplication and provide a model. In this scenario, several adaptations could <span class="No-Break">be considered.</span></p>
			<p>Using complexity escalation allows us to not create too much structure when we have little code initially. If there are only a couple of resources in a profile, then it may be easier to keep it that way and expand to a module when it becomes <span class="No-Break">more complicated.</span></p>
			<p>Depending on your organization’s change management and delivery requirements, it may make sense to have multiple profile or role modules to allow for more granular control and access – for example, <strong class="source-inline">teama_profiles</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">teamb_profiles</strong></span><span class="No-Break">.</span></p>
			<p>As discussed in <a href="B18492_03.xhtml#_idTextAnchor048"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, it is generally advised against using inheritance in Puppet code, but it may be worthwhile expanding the namespaces of a <strong class="source-inline">profile</strong> module by grouping manifests in a directory, such as creating an <strong class="source-inline">exampleapp</strong> directory within <strong class="source-inline">profile</strong> and creating <strong class="source-inline">client.pp</strong> and<strong class="source-inline"> server.pp</strong> to represent the server and client versions (<strong class="source-inline">profile::exampleapp::server </strong>and <strong class="source-inline">profile::exampleapp::client</strong>, respectively). This could also be done for specific OSs. Before considering this approach, note that this structure is an edge case and carries a lot of risks when <span class="No-Break">using inheritance.</span></p>
			<p>If profiles are found to be too rigid to plan for in a changing stack or if adopting heritage servers means that it becomes necessary to drop certain parts of profiles or roles, then using parameters to make the profile more dynamic can allow classes to be defined through the parameter of the profile class, either by Hiera or <span class="No-Break">default values.</span></p>
			<p>As a simple example, the following code uses <strong class="source-inline">include_classes</strong> with the default values listed in the <span class="No-Break"><strong class="source-inline">exampleapp</strong></span><span class="No-Break"> module:</span></p>
			<pre class="source-code">
class profile::exampleapp(
  Array[String] $include_classes = ['exampleapp'],
) {
  include $include_classes
}</pre>
			<p>This would allow us to override the <strong class="source-inline">include_classes</strong> array from Hiera or the module data in the profile. This could be made tighter for inclusions by us only allowing classes from a <span class="No-Break">set module:</span></p>
			<pre class="source-code">
class profile::exampleapp(
  Array[String] $include_classes = ['server'],
 ) {
$modules = $include_classes.map | String $module | {
  "exampleteam_exampleapp::${profile}"
}
include $modules
}</pre>
			<p>To<a id="_idIndexMarker546"/> add more structure to the parameters and make it clear in approval and code review processes, the class parameters could be broken out further. Here, we can add default, mandatory, additional, and knockout arrays, thus providing <span class="No-Break">full flexibility:</span></p>
			<pre class="source-code">
class profile::exampleapp(
  Array[String] $include_default          = ['my_default'],
  Array[String] $include_mandatory        = ['my_base_profile'],
  Array[String] $include_additional       = ['my_test_default_profile'],
  Array[String] $include_removal          = ['my_default'],
){
$profiles = $include_default + $include_mandatory + $include_additional + $include_removal
include $profiles
}</pre>
			<p>It is possible to mix this pattern even further by, say, limiting multiple namespaces and having lists of class arrays for each namespace. This will be dictated by what approach will give your organization enough flexibility while making it clear what will be affected by the code and who should <span class="No-Break">review it.</span></p>
			<p>With this method, it may also be useful to define a <strong class="source-inline">noop</strong> flag using a parameter and then noop on resources. You could also do this via the <strong class="source-inline">noop</strong> function from <a href="https://forge.puppet.com/modules/trlinkin/noop">https://forge.puppet.com/modules/trlinkin/noop</a> to allow modules to be added and put into noop mode until they <span class="No-Break">are accepted.</span></p>
			<p>These<a id="_idIndexMarker547"/> adjustments to the patterns are more complex and involve reading the Hiera data to understand what a role and profile represent, but it will be up to your organization to decide which approach will work best. While a reduction in variation with rigid roles and profiles is ideal, this can lead to adoption resistance or issues with heritage if there are no appropriate ways to <span class="No-Break">manage it.</span></p>
			<p>Having reviewed the structure of modules that the roles and profiles pattern can create and the contents of such modules, we can see that this is a lot of content to manage manually by creating files and managing various testing tools. The next section looks at how to automate the life cycle of module creation and testing using <span class="No-Break">the PDK.</span></p>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor219"/>Writing and testing a module using the PDK</h1>
			<p>The PDK was<a id="_idIndexMarker548"/> introduced to ease the effort required to consistently create the directories and files for modules and to also group some commonly used testing and validation tooling. We will be reviewing PDK version 2.7.1, the latest available at the time of writing. PDK installs its own Ruby gems and environment to provide the <span class="No-Break">following tools:</span></p>
			<table id="table001-4" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Ruby </strong><span class="No-Break"><strong class="bold">Gem Name</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Ruby </strong><span class="No-Break"><strong class="bold">Gem Purpose</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Project Page</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">metadata-json-lint</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Validates the syntax and lints <strong class="source-inline">metadata.json</strong> to <span class="No-Break">style guidelines</span></p>
						</td>
						<td class="No-Table-Style">
							<p><a href="https://github.com/voxpupuli/metadata-json-lint"><span class="No-Break">https://github.com/voxpupuli/metadata-json-lint</span></a></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">pdk</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Generates modules and module content with automated <span class="No-Break">testing commands</span></p>
						</td>
						<td class="No-Table-Style">
							<p><a href="https://github.com/puppetlabs/pdk"><span class="No-Break">https://github.com/puppetlabs/pdk</span></a></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">puppet-lint</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Lints Puppet manifest code against the Puppet language <span class="No-Break">style guide</span></p>
						</td>
						<td class="No-Table-Style">
							<p><a href="https://github.com/puppetlabs/puppet-lint"><span class="No-Break">https://github.com/puppetlabs/puppet-lint</span></a></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">puppet-syntax</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Checks Puppet manifests, templates, and Hiera YAML for <span class="No-Break">correct syntax</span></p>
						</td>
						<td class="No-Table-Style">
							<p><a href="https://github.com/voxpupuli/puppet-syntax"><span class="No-Break">https://github.com/voxpupuli/puppet-syntax</span></a></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">puppetlabs_spec_helper</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Provides the tooling necessary to test against different versions <span class="No-Break">of Puppet</span></p>
						</td>
						<td class="No-Table-Style">
							<p><a href="https://github.com/puppetlabs/puppetlabs_spec_helper"><span class="No-Break">https://github.com/puppetlabs/puppetlabs_spec_helper</span></a></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">rspec-puppet</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Compiles Puppet code and tests the expected behavior using a Puppet-specific implementation of <span class="No-Break">Ruby RSpec</span></p>
						</td>
						<td class="No-Table-Style">
							<p><a href="https://github.com/puppetlabs/rspec-puppet"><span class="No-Break">https://github.com/puppetlabs/rspec-puppet</span></a></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Rspec-puppet-facts</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Gives a method that provides facts for supported OSs using the output <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">facterdb</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><a href="https://github.com/voxpupuli/rspec-puppet-facts"><span class="No-Break">https://github.com/voxpupuli/rspec-puppet-facts</span></a></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">facterdb</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Provides example output of facts for various OSs on different <span class="No-Break">Facter versions</span></p>
						</td>
						<td class="No-Table-Style">
							<p><a href="https://github.com/voxpupuli/facterdb"><span class="No-Break">https://github.com/voxpupuli/facterdb</span></a></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 8.1 – PDK gem list</p>
			<p>The common<a id="_idIndexMarker549"/> misconception about the PDK is that it is packaging and installing these tools. What it is actually doing is running a <strong class="source-inline">bundle install</strong> in each module that’s created. After, the PDK cache is saved, making it appear like PDK is packaging <span class="No-Break">the tools.</span></p>
			<p>Using the gems discussed in <em class="italic">Table 8.1</em>, the PDK can generate <span class="No-Break">the following:</span></p>
			<ul>
				<li>Modules with complete module skeletons, metadata, and <span class="No-Break">README templates</span></li>
				<li>Classes, defined types, tasks, custom facts and functions, and <span class="No-Break">Ruby providers</span></li>
				<li>Unit test templates for classes and <span class="No-Break">defined types</span></li>
			</ul>
			<p>The PDK performs linting to<a id="_idIndexMarker550"/> check styles and best practices and to run syntax validation against <span class="No-Break">the following:</span></p>
			<ul>
				<li>The <strong class="source-inline">metadata.json</strong> file; see <em class="italic">Table 8.2 </em><span class="No-Break">for details</span></li>
				<li>Puppet manifest files (<strong class="source-inline">.pp</strong>) against specific <span class="No-Break">Puppet versions</span></li>
				<li>Ruby files (<strong class="source-inline">.rb</strong>) against specific Puppet versions <span class="No-Break">of Ruby</span></li>
				<li>EPP and ERB <span class="No-Break">template files</span></li>
				<li><strong class="source-inline">Puppetfile</strong> and <strong class="source-inline">environment.conf</strong>, which provides the module list for an environment and its environment settings, as will be discussed in <a href="B18492_11.xhtml#_idTextAnchor272"><span class="No-Break"><em class="italic">Chapter 11</em></span></a></li>
				<li><span class="No-Break">YAML files</span></li>
			</ul>
			<p>The PDK runs RSpec unit tests on modules and classes. This will be discussed in detail in the <em class="italic">Testing with RSpec using the </em><span class="No-Break"><em class="italic">PDK </em></span><span class="No-Break">section.</span></p>
			<p>The PDK has build and release commands to make a .<strong class="source-inline">tar</strong> file for uploading to Puppet Forge and the Puppet <span class="No-Break">debugging console.</span></p>
			<p>To <a id="_idIndexMarker551"/>create a module, the <strong class="source-inline">pdk new module</strong> command (optionally with the module’s name at the end) is run. Answer the questions regarding the module’s name (if it wasn’t provided, specify your Puppet<a id="_idIndexMarker552"/> Forge username, if you have one), who wrote the module, the license the code should fall under, and the OSs that will be supported. This process can be seen in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/B18492_08_02.jpg" alt="Figure 8.2 – pdk new module questions"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – pdk new module questions</p>
			<p>The answers provided for user details and licenses will be offered as defaults in future runs and can be checked by running <strong class="source-inline">pdk get config</strong> and reviewing the <span class="No-Break"><strong class="source-inline">user.module_defaults</strong></span><span class="No-Break"> settings.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="source-inline">puppet module generate</strong> command, which was used before the introduction of the PDK, was deprecated in Puppet 5 and removed in <span class="No-Break">Puppet 6.</span></p>
			<p>Once the answers have been entered and confirmed, a directory containing the module names will <a id="_idIndexMarker553"/>be created. It will contain the<a id="_idIndexMarker554"/> following content directories, which were previously discussed in the <em class="italic">What is a module and what is in </em><span class="No-Break"><em class="italic">it? </em></span><span class="No-Break">section:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">data</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">examples</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">files</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">Manifests</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">spec</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">tasks</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">templates</strong></span></li>
			</ul>
			<p>Using the default built-in template, it then creates the following additional configuration files <span class="No-Break">and directories:</span></p>
			<table id="table002-1" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">File/Directory Name</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">File/Directory Use</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">appveyor.yml</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Appveyor CI integration <span class="No-Break">configuration file</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">CHANGELOG.md</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>A change log that can <span class="No-Break">be maintained</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">devcontainer</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>How a container should be configured to test <span class="No-Break">this module</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">fixtures.yml</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Test module <span class="No-Break">dependencies configuration</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Gemfile</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Ruby <span class="No-Break">gem dependencies</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Gemfile.lock</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Ruby <span class="No-Break">gem dependencies</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">gitattributes</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Associates attributes and behaviors with <span class="No-Break">file types</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">gitignore</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Files Git <span class="No-Break">should ignore</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">gitlab-ci.yml</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Example configuration for using with <span class="No-Break">GitLab CI</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">metadata.json</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<ul>
								<li>Metadata, including questions filled out <span class="No-Break">during creation</span></li>
							</ul>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">pdkignore</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<ul>
								<li>Files to ignore when building a package for <span class="No-Break">Puppet Forge</span></li>
							</ul>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">puppet-lint.rc</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Configuration for the <span class="No-Break"><strong class="source-inline">puppet-lint</strong></span><span class="No-Break"> gem</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">Rakefile</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Ruby <span class="No-Break">task configuration</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">README.md</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>A template for a README page for <span class="No-Break">the module</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">rspec</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Configuration defaults for <strong class="source-inline">rspec</strong> for <span class="No-Break">unit testing</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">rubocop.yml</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Settings for Ruby <span class="No-Break">style checking</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">spec</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>A directory containing files for <strong class="source-inline">rspec </strong><span class="No-Break">unit testing</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">spec/default_facts.yaml</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Default facts available for <span class="No-Break">all tests</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">spec/spec_helper.rb</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Entry point script for <strong class="source-inline">rspec</strong> that sets <span class="No-Break">various configurations</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">sync.yml</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>A file to customize the PDK template <span class="No-Break">in use</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">vscode</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Configuration for VSCode, such as <span class="No-Break">recommended extensions</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">yardopts</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Configuration file for <span class="No-Break">Puppet Strings</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 8.2 – PDK default template files and directories</p>
			<p>For a <a id="_idIndexMarker555"/>pre-existing module, it is also possible to run <strong class="source-inline">pdk convert</strong> to adapt the module to the template. It will confirm the<a id="_idIndexMarker556"/> changes it would make before <span class="No-Break">applying them.</span></p>
			<p>The size of the contents of PDK has grown over time and the default template can contain a lot of unused files. It is possible to create a custom template simply by forking from <a href="https://github.com/puppetlabs/pdk-templates">https://github.com/puppetlabs/pdk-templates</a> and following the README file to adjust the template as required. It can then be used in a module by using <strong class="source-inline">--template-url</strong> on the new module or convert commands. Alternatively, the <strong class="source-inline">.sync.yml</strong> files can be set to be deleted, unmanaged, or have settings changed. The following <strong class="source-inline">.sync.yml</strong> file example would set the <strong class="source-inline">.gitlab-ci.yml </strong>file so that it’s not in the module. It would ensure the <strong class="source-inline">.vscode</strong> directory is not managed by PDK templates, avoiding any future updates. It would also disable legacy facts (global variables of facts, which were covered in <a href="B18492_05.xhtml#_idTextAnchor123"><span class="No-Break"><em class="italic">Chapter 5</em></span></a><span class="No-Break">):</span></p>
			<pre class="source-code">
common
  disable_legacy_facts: true
.gitlab-ci.yml
  delete: true
.vscode
  Unmanaged: true</pre>
			<p>The full settings that can be adjusted are documented in the PDK template README <span class="No-Break">file: </span><a href="https://github.com/puppetlabs/pdk-templates/blob/main/README.md"><span class="No-Break">https://github.com/puppetlabs/pdk-templates/blob/main/README.md</span></a><span class="No-Break">.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">If a configuration change is required across several existing modules, the <strong class="source-inline">modulesync </strong>module can be useful for managing this. It is available on the following web <span class="No-Break">page: </span><a href="https://github.com/voxpupuli/modulesync"><span class="No-Break">https://github.com/voxpupuli/modulesync</span></a><span class="No-Break">.</span></p>
			<p>Now that the contents of a PDK module and its tooling have been described in detail, we will describe the<a id="_idIndexMarker557"/> workflow of developing a module, as shown in <span class="No-Break"><em class="italic">Figure 8</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">.</span></p>
			<p class="IMG---Figure">¶¶¶</p>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/B18492_08_03.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.3 – The PDK workflow</p>
			<p>As was discussed, by running <strong class="source-inline">pdk new</strong> to create a new module or <strong class="source-inline">pdk convert</strong> on an uncontrolled module, an initial module of PDK content and its settings is established. Using <strong class="source-inline">pdk update</strong>, the<a id="_idIndexMarker558"/> configuration of a module can be updated since we can change its settings, provide a new template, or change the <span class="No-Break">PDK version.</span></p>
			<p>The next step is to add any new content files that are required. This may include a <strong class="source-inline">class</strong>, <strong class="source-inline">defined_type</strong>, fact, function provider, task, or transport and can be done by using the <strong class="source-inline">pdk new</strong> command and the relevant content. This will create a file by using the template for the chosen content and a <strong class="source-inline">rspec</strong> test file. For content that’s not available through PDK, such as external facts or plans, the files and tests must be <span class="No-Break">created manually.</span></p>
			<p>Once the file and test for the content are in place, your code should be added. At regular intervals, the code can be validated and tested via the <strong class="source-inline">pdk validate</strong> command, which checks the linting and syntax parsing. This command can also be used with the <strong class="source-inline">-a</strong> flag, which will attempt to auto-correct any errors. For linting errors, specific checks can be ignored in a section of a file by using inline comments or by surrounding areas of code with comments via <strong class="source-inline">lint:ignore:&lt;rule name&gt;</strong>. The following example shows how a line could be set to ignore the 140-character lint rule. In this case, the section of code would ignore the check for double quotes, which should only be used where both strings and variables are used in <span class="No-Break">variable assignment:</span></p>
			<pre class="source-code">
$long_variable_text = "Pretend this is more than 140 characters" # lint:ignore:140chars
  # lint:ignore:double_quoted_strings
  $variable1 = "don't do this"
  $variable2 = "this is just a simple example"
  # lint:endignore</pre>
			<p>If the check must be ignored in all code, the <strong class="source-inline">.puppet-lint.rc</strong> file could be updated by adding a flag such as <strong class="source-inline">--no-selector_inside_resource-check</strong> to ensure <strong class="source-inline">puppet-lint</strong> does not run the check to ensure selector code is inside a resource. The full list of <strong class="source-inline">puppet-lint</strong> checks can be viewed at <a href="https://github.com/puppetlabs/puppet-lint/tree/gh-pages/checks">https://github.com/puppetlabs/puppet-lint/tree/gh-pages/checks</a>. Note that disabling checks should be avoided as much as possible as this may affect your module scoring or ability to get a module endorsed in Puppet Forge. This drives your code further away from recommended <span class="No-Break">Puppet practices.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout"><a href="http://puppet-lint.com/checks/">http://puppet-lint.com/checks/</a> is not owned by Puppet and is out of date. Puppet forked the module to <a href="https://github.com/puppetlabs/puppet-lint">https://github.com/puppetlabs/puppet-lint</a>, which is why it is recommended that <a href="https://puppetlabs.github.io/puppet-lint">https://puppetlabs.github.io/puppet-lint</a> is <span class="No-Break">used instead.</span></p>
			<p>Once <strong class="source-inline">pdk validate</strong> is running cleanly, the <strong class="source-inline">pdk test unit</strong> command can be run to perform<a id="_idIndexMarker559"/> unit testing. The<a id="_idIndexMarker560"/> checks provided by the templates are basic and are meant to check if the code works at all; in the case of Puppet code, it ensures the code will compile. A powerful feature is that checks can be run against specific Puppet or Puppet Enterprise versions by using the <strong class="source-inline">--puppet-version </strong>flag or <strong class="source-inline">--pe-version</strong> – for example, <strong class="source-inline">pdk test unit –pe-version=2019.11</strong> – so that code testing can take place before upgrades. In the next section, you will learn how to expand the <strong class="source-inline">rspec</strong> <span class="No-Break">checks further.</span></p>
			<p>Puppet Forge will be discussed in detail at the end of this chapter. Releasing to Puppet Forge is beyond the scope of this book but if the code is to be released for use in Puppet Forge, you can run the <strong class="source-inline">pdk build</strong> command to create a <strong class="source-inline">.tar</strong> file to be uploaded or the <strong class="source-inline">pdk release</strong> command to automate the process of uploading modules to <span class="No-Break">Puppet Forge.</span></p>
			<p>It is important to keep <strong class="source-inline">metadata.json</strong> up to date as it will restrict what testing takes place based on Puppet’s supported version and is a key part of the documentation. The format and its options can be viewed <span class="No-Break">at </span><a href="https://docs.puppet.com/puppet/latest/modules_metadata.html"><span class="No-Break">https://docs.puppet.com/puppet/latest/modules_metadata.html</span></a><span class="No-Break">.</span></p>
			<p>To view all the options available, you can review the full PDK command reference <span class="No-Break">at </span><a href="https://puppet.com/docs/pdk/2.x/pdk_reference.html"><span class="No-Break">https://puppet.com/docs/pdk/2.x/pdk_reference.html</span></a><span class="No-Break">.</span></p>
			<p>Having reviewed how to use the PDK to create and manage modules, as well as its validation and testing capabilities, let’s learn how to perform full unit testing <span class="No-Break">using RSpec.</span></p>
			<h1 id="_idParaDest-158"><a id="_idTextAnchor220"/>Testing with RSpec using the PDK</h1>
			<p>To<a id="_idIndexMarker561"/> take this initial validation<a id="_idIndexMarker562"/> and compilation testing further at the unit test level, RSpec can be used to test the behavior and logic of modules, while ServerSpec can be used to test at the system <span class="No-Break">integration level.</span></p>
			<p>RSpec is a <a id="_idIndexMarker563"/>Ruby framework for testing Ruby code and is written in a <strong class="bold">domain-specific language </strong>(<strong class="bold">DSL</strong>) to<a id="_idIndexMarker564"/> make it easier to read. The <strong class="source-inline">rspec-puppet</strong> test is an implementation of RSpec, specifically designed for testing <span class="No-Break">Puppet modules.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">It is important to note that the current project code is available at <a href="https://github.com/puppetlabs/rspec-puppet">https://github.com/puppetlabs/rspec-puppet</a>, forked from <a href="https://github.com/rodjek/rspec-puppet">https://github.com/rodjek/rspec-puppet</a>, with core guides and documentation available <span class="No-Break">at </span><a href="http://rspec-puppet.com/"><span class="No-Break">http://rspec-puppet.com/</span></a><span class="No-Break">.</span></p>
			<p>When users start using RSpec, some may feel that it is just mimicking the Puppet code but in a different language. RSpec runs through the different logic and behavior of your Puppet code and ensures that the correct catalogs and output will be produced in various environments and cases. This protects against regressions when refactoring or upgrading to new Puppet releases. If the RSpec code is becoming a simple mimic of the code in the manifest, then the test scenarios are not being <span class="No-Break">reviewed properly.</span></p>
			<p>The advantage of this style of unit testing is that it allows you to test code without having to spin up any specific infrastructure or make <span class="No-Break">any changes.</span></p>
			<p>RSpec tests are contained in Ruby files in a module inside the <strong class="source-inline">spec</strong> directory, with directories containing the tests for different types of code, such as classes in the <strong class="source-inline">spec/classes</strong> directory, and defined types in the <span class="No-Break"><strong class="source-inline">spec/defines</strong></span><span class="No-Break"> directory.</span></p>
			<p>We are ignoring the other possible test directories (the <strong class="source-inline">types</strong>, <strong class="source-inline">type_alias</strong>, and <strong class="source-inline">functions </strong>test directories) as creating them is beyond the scope of this book. However, most of what will be discussed here can apply to <span class="No-Break">these types.</span></p>
			<p>RSpec configuration is covered within the PDK and the files are created automatically with the <strong class="source-inline">pdk new</strong> commands. However, they can be added either when converting a module or using the PDK by adding the <strong class="source-inline">--add-tests</strong> flag to the <strong class="source-inline">convert</strong> command, <strong class="source-inline">pdk convert --add-tests</strong>, and with the <strong class="source-inline">pdk new test --unit &lt;name&gt; </strong><span class="No-Break">command, respectively.</span></p>
			<p>Before<a id="_idIndexMarker565"/> we look at what a defined type and class will get by default from the PDK, we must run the <strong class="source-inline">pdk new class exampleapp</strong> and <strong class="source-inline">pdk new define example_define</strong> commands on the <strong class="source-inline">exampleapp</strong> module to create the main manifest and a defined type called <strong class="source-inline">example_define</strong>. This will result in a file called <strong class="source-inline">spec/classes/exampleapp.rb</strong> with the <span class="No-Break">following contents:</span></p>
			<pre class="source-code">
require 'spec_helper'
describe 'exampleapp' do
  on_supported_os.each do |os, os_facts|
    context "on #{os}" do
      let(:facts) { os_facts }
      it { is_expected.to compile }
    end
  end
end</pre>
			<p>Further, <strong class="source-inline">spec/defined/example_define.rb</strong> can be created <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
require 'spec_helper'
describe 'exampleapp::example_define' do
  let(:title) { 'namevar' }
  let(:params) do
    {}
  end
  on_supported_os.each do |os, os_facts|
    context "on #{os}" do
      let(:facts) { os_facts }
      it { is_expected.to compile }
    end
  end
end</pre>
			<p>Breaking <a id="_idIndexMarker566"/>this down, the first step is to <strong class="source-inline">require spec_helper</strong>, which results in the <strong class="source-inline">spec/spec_helper.rb</strong> file being loaded. Because the <strong class="source-inline">spec</strong> directory is loaded into the path automatically, it only needs to state the title; this configures RSpec, which will be discussed in more detail later in this section. The next part, <strong class="source-inline">describe</strong>, is an RSpec keyword that’s used to describe a group of tests. For both the <strong class="source-inline">exampleapp</strong> and <strong class="source-inline">example_define</strong> tests, the name of the class and defined class are described since there is only one basic group of tests <span class="No-Break">for each.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you have used <strong class="source-inline">puppet-rspec</strong> previously, you may have set an additional type definition in the <strong class="source-inline">describe</strong> statement, such as <strong class="source-inline">describe 'exampleapp'</strong>, <strong class="source-inline">:type =&gt; :class do</strong>. This is unnecessary due to the folders acting as auto identifiers of <span class="No-Break">the type.</span></p>
			<p>A defined type always needs a title and any parameters. Upon using the <strong class="source-inline">let</strong> keyword, a title is set, as well as parameters, which in this case <span class="No-Break">are blank.</span></p>
			<p>Both the <strong class="source-inline">exampleapp</strong> and <strong class="source-inline">example_define</strong> classes then perform a loop using the <strong class="source-inline">on_supported_os</strong> function, which is provided by the <strong class="source-inline">rspec-puppet-facts</strong> gem, taking the input from the <strong class="source-inline">metadata.json</strong> file, which contains details regarding the OSs that are supported and producing an array of facts in the <strong class="source-inline">os_facts</strong> variable. This is then passed to another <strong class="source-inline">let</strong>, which assigns these facts to the contents of the <span class="No-Break"><strong class="source-inline">os_facts</strong></span><span class="No-Break"> </span><span class="No-Break">array.</span></p>
			<p>The <strong class="source-inline">it</strong> keyword<a id="_idIndexMarker567"/> is known as an <strong class="bold">example </strong>in <strong class="source-inline">rspec</strong> terms and can be either a single line or encased within a <strong class="source-inline">do</strong> end block. This is a test case and contains an expect statement called <strong class="source-inline">is_expected.to</strong>, which is a verification step of a condition. This condition is expressed via a matcher. In this case, this will compile the Puppet code of the class and defined type and confirm that a catalog will be <span class="No-Break">generated successfully.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">We recommend the styling guide available at <a href="https://www.betterspecs.org/">https://www.betterspecs.org/</a>, which is for the general Ruby RSpec style. We will be quoting recommendations from it throughout <span class="No-Break">this chapter.</span></p>
			<p>Having briefly examined the default compile test, let’s look at each component and how to expand <span class="No-Break">them further.</span></p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor221"/>The describe and context keywords</h2>
			<p>One of<a id="_idIndexMarker568"/> the big confusions for many Puppet developers who have previously tried to use RSpec is understanding where to use the <strong class="source-inline">describe</strong> keyword and where to use <strong class="source-inline">context</strong>. They seem to be interchangeable, and this is for a very good<a id="_idIndexMarker569"/> reason. The <strong class="source-inline">context</strong> keyword is an alias of <strong class="source-inline">describe</strong>, so they are interchangeable, and your use only affects how your <span class="No-Break">code reads.</span></p>
			<p><em class="italic">Betterspecs </em>recommends using <strong class="source-inline">describe</strong> to describe the method being tested. In terms of Puppet RSpec, this was why we saw <strong class="source-inline">describe</strong> with a class name of <strong class="source-inline">exampleapp</strong> and <strong class="source-inline">exampleapp::example_define</strong> as its defined class in the <em class="italic">Testing with RSpec using the </em><span class="No-Break"><em class="italic">PDK </em></span><span class="No-Break">section.</span></p>
			<p>It is recommended that <strong class="source-inline">context</strong> be written in a style of <em class="italic">when</em>, <em class="italic">with</em>, or <em class="italic">without </em>situations, which should make it clear what scenario is <span class="No-Break">being tested.</span></p>
			<p>The style recommendation of this book is to write a single <strong class="source-inline">describe</strong> to match the Puppet type, such as <strong class="source-inline">class</strong>, and then <strong class="source-inline">context</strong> to match the scenarios to <span class="No-Break">be tested.</span></p>
			<p>The blocks of <strong class="source-inline">describe</strong> and <strong class="source-inline">context</strong> allow the situation being tested to be described and for us to set facts, variables, and parameters. Since they can be nested, it allows<a id="_idIndexMarker570"/> inheritance to take<a id="_idIndexMarker571"/> place, which will build up more detailed scenarios, or different logical routes to be tried, though care should be taken not to make the cases too hard <span class="No-Break">to read.</span></p>
			<p>The aim should be to test all cases. So, a plan should be made to test valid, edge, and invalid cases, allowing both positive and negative cases to be tested. As a simple example without any code tests or parameters set, the following code for the <strong class="source-inline">exampleapp</strong> class would look at the contexts for each supported OS, based on whether the <strong class="source-inline">install</strong> version is a middle value, a low edge version, or an <span class="No-Break">invalid version:</span></p>
			<pre class="source-code">
describe 'exampleapp' do
  on_supported_os.each do |os, _os_facts|
    context "on #{os}" do
      context 'When install_version is 6' do
        it { is_expected.to compile }
      end
      context 'When install_version is 1' do
        it { is_expected.to compile.and_raise_error('unsupported version') }
      end
      context 'When install_version is invalid string' do
        it { is_expected.to compile.and_raise_error('Invalid version string') }
      end
    end
  end
end</pre>
			<p>Now that we have the basic structure of the scenarios to test, the next step is to use matchers to test what is produced in the catalog based <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">context</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor222"/>Examples, expectations, and matchers</h2>
			<p>The sample <strong class="source-inline">it</strong> statements <a id="_idIndexMarker572"/>can be either a single line, as demonstrated in the <em class="italic">Testing with RSpec using the PDK </em>section, or can be broken up over multiple lines when the matcher that’s used is too long to be on a single line. Using <strong class="source-inline">do</strong> and <strong class="source-inline">end</strong>, the same compile example could be expressed <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
it do
is_expected.to compile
end</pre>
			<p>In the general Ruby RSpec implementation, expectations <a id="_idIndexMarker573"/>have a broader choice, but in <strong class="source-inline">puppet-rspec</strong>, our expectations will be limited to just using the <strong class="source-inline">is_expected</strong> keyword. However, this can be negated by using <strong class="source-inline">not_to</strong> – for example, <strong class="source-inline">It { </strong><span class="No-Break"><strong class="source-inline">is_expected.not_to</strong></span><span class="No-Break">.</span></p>
			<p>The matchers provide a variety of tests for testing various resource types. The matcher syntax <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">contain_&lt;resource_type&gt;('&lt;title&gt;').&lt;options&gt;</strong></span><span class="No-Break">.</span></p>
			<p>For the <a id="_idIndexMarker574"/>compile matcher, we could be more explicit by adding the <strong class="source-inline">with_all_deps</strong> option to the compile – for example, <strong class="source-inline">it { is_expected.to compile.with_all_deps }</strong>. This would test that all the relationships in the catalog contain resources. Alternatively, we could look for a compile error with the <strong class="source-inline">and_raise_error('error_message')</strong> option, which will contain the message we expect to be thrown as a string – for example, <strong class="source-inline">it { is_expected.to compile.raise_error('lets cause </strong><span class="No-Break"><strong class="source-inline">failure' }</strong></span><span class="No-Break">.</span></p>
			<p>The main set of matches is based on resource types using a pattern of <strong class="source-inline">contain_&lt;resource_type&gt;('&lt;resource_title&gt;')</strong> – <span class="No-Break">for example,</span></p>
			<p><strong class="source-inline">it { is_expected.to contain_class('exampleclass::install') }</strong> and <strong class="source-inline">it { is_expected.to </strong><span class="No-Break"><strong class="source-inline">contain_service('httpd') }</strong></span><span class="No-Break">.</span></p>
			<p><strong class="source-inline">Rspec-puppet</strong> does not do class name parsing or lookup, so the matcher will only accept qualified classes without leading colons. So, <strong class="source-inline">install</strong> won’t be found in <strong class="source-inline">exampleclass</strong>, but <strong class="source-inline">exampleclass::install</strong> will. If a resource type contains a <strong class="source-inline">::</strong> symbol, this needs to be converted into a <strong class="source-inline">__ </strong>symbol, which will make <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">contain_exampleapp__exampletype</strong></span><span class="No-Break">.</span></p>
			<p>Resource matchers <a id="_idIndexMarker575"/>can be further expanded by chaining them using the <strong class="source-inline">with</strong>, <strong class="source-inline">only_with</strong>, and <strong class="source-inline">without</strong> methods. This allows us to check the parameters of resources; <strong class="source-inline">with</strong> ensures the resource in the catalog has the parameters as specified, <strong class="source-inline">only_with</strong> ensures that only the parameters provided have been set and no others, and <strong class="source-inline">without</strong> accepts an array of parameters and ensures those parameters are not set. When using these methods, it is more readable to use an <strong class="source-inline">it do...end</strong> format, as shown in the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
it do
  is_expected.to contain_package('httpd').with(
  'ensure' =&gt; 'latest',
  'provider' =&gt; 'solaris',
  )
end</pre>
			<p>This can be shortened to only one parameter by following the method syntax for <strong class="source-inline">with</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">only_with</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&lt;with_method&gt;_&lt;parameter name&gt;
it {is_expected.to contain_server('exampleserver').only_with_enable(true)  }</pre>
			<p>For <strong class="source-inline">without</strong>, the method accepts an array of parameters that should not be set on <span class="No-Break">the resource:</span></p>
			<pre class="source-code">
it {is_expected.to contain_user('exampleuser'). .without(['managehome', 'home']) }</pre>
			<p>These methods can be chained together either as the same methods or as <span class="No-Break">a mix:</span></p>
			<pre class="source-code">
it {is_expected.to contain_server('exampleserver').with_enable(true).without_ensure  }</pre>
			<p>A different kind of <a id="_idIndexMarker576"/>matcher for resources is using a <strong class="source-inline">count</strong>, which allows the <strong class="source-inline">have_&lt;resource_type&gt;_count</strong> syntax. For example, to verify if the total number of resources is <strong class="source-inline">5</strong> and the total number of classes is <strong class="source-inline">4</strong>, the following code can <span class="No-Break">be run:</span></p>
			<pre class="source-code">
it { is_expected.to have_resource_count(5) }
it { is_expected.to have_class_count(4) }</pre>
			<p>Having reviewed how to set examples, it is clear that for the <strong class="source-inline">describe</strong> and <strong class="source-inline">context</strong> keywords, parameters and pre-conditions will need to be set for there to be a testing scenario. For example, if the context is that the install version is 1, then the parameter install version will need to be set <span class="No-Break">to 1.</span></p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor223"/>Parameters and preconditions</h2>
			<p>In the default example for defined types, we explained how the <strong class="source-inline">let</strong> keyword can be used to set specify the title and empty parameters of a test instantiation of a defined type. However, these can also be used for other types, such as <span class="No-Break">parameterized classes.</span></p>
			<p>To populate <a id="_idIndexMarker577"/>parameters, an array of keys and values separated by a <strong class="source-inline">=&gt;</strong> symbol can be supplied in strings with an undefined value declared as <strong class="source-inline">:undef</strong>, which is translated to <strong class="source-inline">undef</strong> when it compiles the test. For example, to set <strong class="source-inline">param1</strong> to the <strong class="source-inline">yup</strong> string and <strong class="source-inline">param2</strong> to <strong class="source-inline">undef</strong>, the following <strong class="source-inline">let</strong> could <span class="No-Break">be used:</span></p>
			<pre class="source-code">
let(:params) { {'param1' =&gt; 'yup', 'param2' =&gt; :undef } }</pre>
			<p>In addition to parameters, preconditions <a id="_idIndexMarker578"/>can also be set. So, if the manifest being tested is dependent on another class or variable being in the catalog, this could be added so it will be evaluated before the test class. For example, in the module pattern, we showed that the <strong class="source-inline">config</strong> class needed to be evaluated after the <strong class="source-inline">install</strong> class in the catalog but before the <strong class="source-inline">service</strong> class. This could be done using the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
let(:pre_condition) { 'include exampleapp::install' }
let(:post_condition){ 'include exampleapp::service' }</pre>
			<p>An array of strings <a id="_idIndexMarker579"/>can also be used if there are multiple conditions. If the test is for a specific node or environment, this can be set <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
let(:node) { puppet.packtpub.com' }
let(:environment) { 'production' }</pre>
			<p>The node should<a id="_idIndexMarker580"/> be a <strong class="bold">fully qualified domain </strong><span class="No-Break"><strong class="bold">name </strong></span><span class="No-Break">(</span><span class="No-Break"><strong class="bold">FQDN</strong></span><span class="No-Break">).</span></p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor224"/>Relationships</h2>
			<p>The <a id="_idIndexMarker581"/>relationships of resources can be tested with the <strong class="source-inline">that_requires</strong>, <strong class="source-inline">that_comes_before</strong>, <strong class="source-inline">that_notifies</strong>, and <strong class="source-inline">that_subscribes_to</strong> methods. It is not important if the Puppet code is using a <strong class="source-inline">require</strong> and RSpec is using <strong class="source-inline">that_comes_before</strong> or if the Puppet code is using directional arrows, so long as the variants are logically equivalent to each other since the test is on <span class="No-Break">the catalog.</span></p>
			<p>These methods are chained into the example with the requirement, but there are some differences between how relationships are declared in a Puppet manifest and how they are declared in a <strong class="source-inline">rspec </strong>test: the name should not be quoted, it cannot have multiple resource names under a single type, and if a class is referenced, there should be no leading <strong class="source-inline">::</strong> to mark it as the top scope. As a simple example, a file called <strong class="source-inline">exampleconfig</strong> that requires the <strong class="source-inline">exampleapp</strong> package can be checked <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
it { is_expected.to contain_file('exampleconfig').that_requires('Package[exampleapp]') }</pre>
			<p>To check that the <strong class="source-inline">exampleapp</strong> package was before the <strong class="source-inline">exampleapp::service</strong> and <strong class="source-inline">exampleapp::config</strong> classes, an array can be passed. However, note that they cannot be under <span class="No-Break">one class:</span></p>
			<pre class="source-code">
it { is_expected.to contain_package('exampleapp').that_comes_before('Class[exampleapp::service]','Class[exampleapp::config]') }</pre>
			<p>An example of a resource with parameters using <strong class="source-inline">it do...end</strong> that notified two files is <span class="No-Break">as follows</span></p>
			<pre class="source-code">
it do
  is_expected.to contain_service('anotherapp').with(
    'ensure' =&gt; 'running',
    'enable' =&gt; 'true',
  ).that_notifies('File[config_a]', 'File[config_b]')
end</pre>
			<p>If the test is on <a id="_idIndexMarker582"/>something like a defined class that has <strong class="source-inline">require</strong> or <strong class="source-inline">before</strong> as part of its definition, this relationship can be set in parameters. However, the <strong class="source-inline">ref</strong> helper must be used to name the resource it is dependent on, using the <strong class="source-inline">ref('&lt;type&gt;','&lt;title'&gt;)</strong> syntax. For a defined type that requires the <strong class="source-inline">exampleapp</strong> package, the following code would add the relationship <span class="No-Break">via parameters:</span></p>
			<pre class="source-code">
let(:params) { 'require' =&gt; ref('Package', 'exampleapp') }</pre>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor225"/>Data from Hiera and facts</h2>
			<p>Data from Hiera and facts <a id="_idIndexMarker583"/>have a huge influence on the logic in our code, so it must be able to be supplied and customized to cover the different scenarios to be tested. As was shown in the default examples in the <em class="italic">Testing with RSpec using the PDK </em>section, the <strong class="source-inline">rspec-puppet-facts</strong> gem checks the <strong class="source-inline">metadata.json</strong> file to find the list of supported OSs. However, <strong class="source-inline">metadata.json</strong> does not have a way to provide architectures, and by default, <strong class="source-inline">rspec-puppet-facts</strong> chooses a default architecture depending on the OS, such as i86PC for Solaris or x86_64 for Fedora. If you want to be able to check additional architectures, you can pass hardware models in a comma-separated array. This will be combined with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
  additional_archs = {
    :hardwaremodels =&gt; ['i386'],
  }
on_supported_os(additional_archs).each do |os, os_facts|</pre>
			<p>If it only <a id="_idIndexMarker584"/>makes sense to test a subsection such as a class that has been specifically made for an OS, then you can pass the relevant details using the <strong class="source-inline">operatingsystem</strong> and <strong class="source-inline">operatingsystemreleases </strong>parameters; this will <span class="No-Break">override </span><span class="No-Break"><strong class="source-inline">metadata.json</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
    ubuntu = {
      supported_os: [
        {
          'operatingsystem'        =&gt; 'Ubuntu',
          'operatingsystemrelease' =&gt; ['18.04', '16.04'],
        },
      ],
    }
on_supported_os(ubuntu).each do |os, os_facts|</pre>
			<p>Using the <strong class="source-inline">on_supported_os</strong> method, this can only be set on all choices. If nothing is found, such as i386 on Windows 11, it fails to find it silently. View the <strong class="source-inline">facterdb</strong> module at <a href="https://github.com/voxpupuli/facterdb">https://github.com/voxpupuli/facterdb</a> to see what <span class="No-Break">is available.</span></p>
			<p>It is not mandatory to use <strong class="source-inline">on_supported_os</strong> but without it, by default, there will be no facts. When you need to test data that doesn’t exist in <strong class="source-inline">facterdb</strong>, it is possible to declare the facts using <strong class="source-inline">let(:facts)</strong> and the values you wish. For example, if you were testing what would happen with a theoretical RedHat 10 fact set, you would use the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
Context "when OS is redhat-10-x86_64" do
    let(:facts) do
      {
        :osfamily                  =&gt; 'RedHat',
        :operatingsystem           =&gt; '<strong class="source-inline">RedHat'</strong>,
        :operatingsystemmajrelease =&gt; '10',
        …
      }
    end</pre>
			<p>Similarly, if <a id="_idIndexMarker585"/>additional facts were to be added to the <strong class="source-inline">os_facts</strong> variable in a nested <strong class="source-inline">context</strong>, the <strong class="source-inline">merge</strong> method could be used with the <span class="No-Break"><strong class="source-inline">super</strong></span><span class="No-Break"> method:</span></p>
			<pre class="source-code">
     let(:facts) do
        super().merge({
          :student =&gt; 'david',
        })
      end</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">For structured facts, these merges can become more difficult. Voxpupli has an <strong class="source-inline">override_facts</strong> helper in <a href="https://github.com/voxpupuli/voxpupuli-test">https://github.com/voxpupuli/voxpupuli-test</a> that can assist <span class="No-Break">with this.</span></p>
			<p>To add facts that can be consumed by the PDK for validation and testing the code, add a <strong class="source-inline">spec/default_module_facts.yml</strong>. This will contain YAML similar to <span class="No-Break">the following:</span></p>
			<pre class="source-code">
---,
choco_install_path: C:\ProgramData\chocolatey
chocolateyversion: 0.9.9</pre>
			<p>The <strong class="source-inline">default_facts.yml</strong> file should not be edited as it is managed by the PDK and provides minimal facts for the PDK <span class="No-Break">to run.</span></p>
			<p>It is possible to add default facts via <strong class="source-inline">.sync.yaml</strong> either by adding a standard code block or by adding <strong class="source-inline">default_facts.yml</strong>, but this is needlessly complicated compared <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">default_module_facts.yml</strong></span><span class="No-Break">.</span></p>
			<p>Any facts you provided with <strong class="source-inline">let(:facts)</strong> in a spec will merge on top of <span class="No-Break">default facts.</span></p>
			<p>In addition<a id="_idIndexMarker586"/> to these facts, three additional variables come from classification and external data sources: node parameters, which are global variables assigned from the classification to a node, trusted facts, which are variables assigned from within a Puppet client certificate, and trusted external facts, which are variables sourced from an external data source by a script. The full implementation of these will be described in detail in <a href="B18492_11.xhtml#_idTextAnchor272"><span class="No-Break"><em class="italic">Chapter 11</em></span></a><em class="italic"> </em>and <a href="B18492_14.xhtml#_idTextAnchor340"><span class="No-Break"><em class="italic">Chapter 14</em></span></a><span class="No-Break">.</span></p>
			<p>All three types of variables can be added by using a <strong class="source-inline">let</strong> statement in the spec file or by setting them as defaults <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">spec_helper</strong></span><span class="No-Break">.</span></p>
			<p>Trusted facts from Puppet 4.3 onwards will contain trusted fact keys (<strong class="source-inline">certname</strong>, <strong class="source-inline">domain</strong>, and <strong class="source-inline">hostname</strong>) that are populated based on the node name, as set with <strong class="source-inline">:node</strong>. However, trusted external facts and node parameters will <span class="No-Break">be empty.</span></p>
			<p>Trusted facts use <strong class="source-inline">trusted_facts</strong>, trusted external data uses <strong class="source-inline">trusted_external_data</strong>, and node parameters use <strong class="source-inline">node_params</strong>. For example, to declare trusted facts and trusted external data, the following <strong class="source-inline">let</strong> statements can <span class="No-Break">be used:</span></p>
			<pre class="source-code">
let(:trusted_facts) { {'pp_role' =&gt; 'puppet/server', 'pp_cluster' =&gt;
'A'} }
let(:trusted_external_data) do,
{ 
  pds: {
     puppet_classes: some_class,
     example: hiera_data,
   },
}
end</pre>
			<p>To set defaults, <strong class="source-inline">.sync.yaml</strong> can add additional lines by passing an array via <strong class="source-inline">spec_overrides</strong>; however, adding a <strong class="source-inline">spec_helper_local.rb</strong> file that contains the necessary lines will be easier than following the YAML syntax. Within a <strong class="source-inline">Rspec.config</strong> block, it is about following the <strong class="source-inline">c.&lt;fact_type&gt; = {&lt;fact/parameters_keys&gt;}</strong> format and using the fact/parameter name with <strong class="source-inline">default_ </strong>at the beginning. So, to assign node parameters as defaults, <strong class="source-inline">spec_helper_local.rb</strong> can be updated <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
RSpec.configure do |c|
  c.default_node_params = {
    'owner'  =&gt; 'oracle',
    'site'   =&gt; 'Falkirk1',
    'state' =&gt; 'live',
  }
end</pre>
			<p>Similarly, trusted <a id="_idIndexMarker587"/>external data can be set <span class="No-Break">like this:</span></p>
			<pre class="source-code">
Rspec.configure do |c|
  c.default_trusted_external_data = {
    pds: {
      puppet_classes: some_class,
      example: hiera_data,
    },
  }
end</pre>
			<p>Hiera will be covered in full in <a href="B18492_09.xhtml#_idTextAnchor233"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, but for now, it is adequate to know that Hiera provides a <strong class="source-inline">hiera.yaml</strong> file to help you learn how to look up the data and a configuration file. We have created a <strong class="source-inline">hiera.yaml</strong> definition at <strong class="source-inline">spec/fixtures/hiera/hiera.yaml</strong>, which would typically have a <strong class="source-inline">datadir</strong> defined <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">spec/fixtures/hieradata</strong></span><span class="No-Break">.</span></p>
			<p>This <a id="_idIndexMarker588"/>configuration for Hiera can be set in two ways, as documented at <a href="https://github.com/puppetlabs/rspec-puppet">https://github.com/puppetlabs/rspec-puppet</a>. The first option is to use <strong class="source-inline">let </strong>and set the necessary variables, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
let(:hiera_config) { 'spec/fixtures/hiera/hiera.yaml' }
hiera = Hiera.new(:config =&gt; 'spec/fixtures/hiera/hiera.yaml')</pre>
			<p>Lookups can then be performed <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
 primary_dns = hiera.lookup('primary_dns', nil, nil)
  let(:params) { 'primary_dns' =&gt; primary_dns}</pre>
			<p>Alternatively, the following could be added to <strong class="source-inline">spec_helper_local.rb</strong>. Here, automatic lookup of parameters would <span class="No-Break">take place:</span></p>
			<pre class="source-code">
RSpec.configure do |c|
  c.hiera_config = 'spec/fixtures/hiera/hiera.yaml'
end</pre>
			<p>Having reviewed how to create tests for individual modules, one of the issues that you’ll quickly find is that various resources, such as functions, are used within modules. These are dependent on the content of other modules. In this next section, you will learn how to use fixtures to make this content available <span class="No-Break">for testing.</span></p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor226"/>Managing dependencies with fixtures</h2>
			<p><strong class="source-inline">puppetlabs_spec_helper</strong> can<a id="_idIndexMarker589"/> put dependent modules in <strong class="source-inline">spec/fixtures/modules </strong>for when an RSpec test unit is run. The <strong class="source-inline">.fixtures.yml</strong> file can specify <strong class="source-inline">repositories:</strong> for GitHub repository sources and <strong class="source-inline">forge_modules:</strong> for modules from <span class="No-Break">Puppet Forge.</span></p>
			<p>The main arguments that are taken are <strong class="source-inline">repo</strong>, which is either the Git repository link or the Puppet Forge module name, <strong class="source-inline">ref</strong> for a Git commit ID, or Forge module version number and <strong class="source-inline">branch</strong>, which is for a Git branch. The <strong class="source-inline">ref</strong> and <strong class="source-inline">branch</strong> arguments can be used together to revise <span class="No-Break">a branch.</span></p>
			<p>So, an <a id="_idIndexMarker590"/>example <strong class="source-inline">.fixtures.yml</strong> containing two Git repositories and two Forge modules would look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
fixtures:
  forge_modules:
    peadm: "puppetlabs/peadm"
    stdlib:
      repo: "puppetlabs/stdlib"
      ref: "2.6.0"
  repository:
     pecdm:  "git://github.com/puppetlabs/pecdm"
   Puppet-data-service:
      repo: "git://github.com/puppetlabs/puppetlabs-puppet_data_service"
      Ref:  "feature_branch_1"</pre>
			<p>If there are no arguments other than <strong class="source-inline">repo</strong>, it can be shortened to one line, as shown here. If the fixtures file has changed, it is possible to run the <strong class="source-inline">--clean-fixtures</strong> flag with a <strong class="source-inline">pdk test unit</strong> command to ensure all contents <span class="No-Break">are deleted.</span></p>
			<p>More flags and options can be used with fixtures, as documented <span class="No-Break">at </span><a href="https://github.com/puppetlabs/puppetlabs_spec_helper#fixtures-examples"><span class="No-Break">https://github.com/puppetlabs/puppetlabs_spec_helper#fixtures-examples</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor227"/>Coverage reports</h2>
			<p>It is <a id="_idIndexMarker591"/>possible to produce coverage reports by adding the following piece of code <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">spec_helper_local.rb</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
RSpec.configure do |c|
  c.after(:suite) do
    RSpec::Puppet::Coverage.report!
  end
end</pre>
			<p>This <a id="_idIndexMarker592"/>checks whether Puppet resources have been covered and produces a percentage of resources covered and a list of untouched resources. The resource that’s checked must be within the module being tested and not contain any dependencies brought in by fixtures. The resource coverage percentage can also be made into a pass or failure point by adding a percentage pass rate in brackets. For example, by updating the line to <strong class="source-inline">RSpec::Puppet::Coverage.report! (100</strong>), this would ensure every resource (100%) is covered. This can sometimes be a motivator to push for RSpec use and coverage and only allow the resource percentage coverage to be reduced due to any particular issue <span class="No-Break">or exception.</span></p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor228"/>Further research and tools for RSpec</h2>
			<p>This section has tried to provide you<a id="_idIndexMarker593"/> with enough information that you can build meaningful <strong class="source-inline">rspec-puppet</strong> tests with facts data and dependencies. Also, note that normal Ruby code can be used, such as <strong class="source-inline">case</strong> or <strong class="source-inline">if</strong> statements and variables, and that there are many more options for advanced configurations in <strong class="source-inline">spec_helper_local</strong>, as documented <span class="No-Break">at </span><a href="https://rspec-puppet.com/documentation/configuration/"><span class="No-Break">https://rspec-puppet.com/documentation/configuration/</span></a><span class="No-Break">.</span></p>
			<p>This book advises against Augeas use, but it is possible to test Augeas in RSpec. Details can be found <span class="No-Break">here: </span><a href="https://github.com/domcleal/rspec-puppet-augeas"><span class="No-Break">https://github.com/domcleal/rspec-puppet-augeas</span></a><span class="No-Break">.</span></p>
			<p>Although it’s <a id="_idIndexMarker594"/>beyond the scope of this book, when using custom functions and types, it is necessary to perform stubs and mocks, which can be done via <strong class="source-inline">rspec-mocks</strong>, as documented <span class="No-Break">at </span><a href="https://github.com/puppetlabs/puppetlabs_spec_helper#mock_with"><span class="No-Break">https://github.com/puppetlabs/puppetlabs_spec_helper#mock_with</span></a><span class="No-Break">.</span></p>
			<p>It was mentioned at the start of the <em class="italic">Testing with RSpec using the PDK </em>section that for large manifests, having to type out all the RSpec for resources can be painful. However, several tools can do this for you. These include <a href="https://github.com/logicminds/puppet-retrospec">https://github.com/logicminds/puppet-retrospec</a>, <a href="https://github.com/enterprisemodules/puppet-catalog_rspec">https://github.com/enterprisemodules/puppet-catalog_rspec</a>, and <a href="https://github.com/alexharv074/create_specs.git">https://github.com/alexharv074/create_specs.git</a>; all of these can be used to generate RSpec from code <span class="No-Break">or catalogs.</span></p>
			<p>As with <a id="_idIndexMarker595"/>almost everything, it is possible to do all these tasks in YAML instead by using the <strong class="source-inline">rspec-puppet-yaml</strong> gem at <a href="https://rubydoc.info/gems/rspec-puppet-yaml">https://rubydoc.info/gems/rspec-puppet-yaml</a>. However, we would strongly advise <span class="No-Break">against this.</span></p>
			<p>For further research on RSpec, it can be useful to review the core RSpec documentation <span class="No-Break">at </span><a href="https://rspec.info/documentation/"><span class="No-Break">https://rspec.info/documentation/</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-167"><a id="_idTextAnchor229"/>Serverspec</h2>
			<p>Serverspec is<a id="_idIndexMarker596"/> an RSpec implementation that’s designed to test at the<a id="_idIndexMarker597"/> server level once configuration management has been deployed. It is a tool that’s independent of Puppet and doesn’t integrate with PDK; it is typically added to a pipelining tool to run and requires you to remotely connect from a server to a test target. Many of the same principles and ideas that we saw in the RSpec apply. The documentation and a tutorial for this can be found <span class="No-Break">at </span><a href="https://serverspec.org/"><span class="No-Break">https://serverspec.org/</span></a><span class="No-Break">.</span></p>
			<p>Having learned all about how to create and test modules in this chapter, we can now look at how to use Puppet Forge to source <span class="No-Break">pre-written modules.</span></p>
			<h1 id="_idParaDest-168"><a id="_idTextAnchor230"/>Understanding Puppet Forge</h1>
			<p>Puppet Forge<a id="_idIndexMarker598"/> provides a rich resource of modules from Puppet, the Puppet community, and third-party vendors to reduce the amount of code your organization must write and maintain. It also allows you to contribute to projects or publish modules, allowing others to contribute to <span class="No-Break">your projects.</span></p>
			<p>It is important to understand the different types of authors, endorsements, and quality scores available in Puppet Forge to understand who is developing the modules, what you can expect from them, and how to make choices regarding the <span class="No-Break">7,000+ modules.</span></p>
			<p>Anyone can register and publish modules. However, the Puppet company itself publishes under the <strong class="source-inline">puppetlabs</strong> username, while the <strong class="bold">Vox Pupuli </strong>community organization <a id="_idIndexMarker599"/>publishes under the <strong class="source-inline">puppet</strong> username. This confusion originates from Puppet originally being called Puppet Labs. This should not detract from the fact the Vox Pupli community develops to very high standards and works closely with Puppet, with both organizations contributing to one another. Full details about the <a id="_idIndexMarker600"/>Vox Pupuli community can be viewed at <a href="https://voxpupuli.org/">https://voxpupuli.org/</a>, including how to contribute and <span class="No-Break">be involved.</span></p>
			<p>There are several other key consultancy contributors, such as <strong class="source-inline">example42</strong>, <strong class="source-inline">enterprisemodules</strong>, <strong class="source-inline">camptocamp</strong>, and <strong class="source-inline">betadots</strong>, who contribute modules and offer services. There are vendor organizations, such as <strong class="source-inline">foreman</strong>, <strong class="source-inline">datadog</strong>, <strong class="source-inline">SIMP</strong>, <strong class="source-inline">cyberark</strong>, and <strong class="source-inline">Elastic</strong>, that provide modules related to their products. Finally, individual contributors such as <strong class="source-inline">saz</strong> and <strong class="source-inline">ghoneycut </strong>have contributed several quality modules. Puppet <a id="_idIndexMarker601"/>has a Champions program, highlighting known contributors to Puppet, which can assist in understanding the reliability of module <span class="No-Break">authors: </span><a href="https://puppet-champions.github.io/profiles.html"><span class="No-Break">https://puppet-champions.github.io/profiles.html</span></a><span class="No-Break">.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The process of releasing modules to Puppet Forge is beyond the scope of this book, but it can be reviewed at <a href="https://puppet.com/docs/puppet/latest/modules_publishing.html">https://puppet.com/docs/puppet/latest/modules_publishing.html</a> and used along with the <strong class="source-inline">pdk build</strong> and <strong class="source-inline">pdk release</strong> commands, as discussed in the <em class="italic">Writing and testing a module using the </em><span class="No-Break"><em class="italic">PDK </em></span><span class="No-Break">section.</span></p>
			<p>In terms of understanding how to filter for modules to use while looking at the screen shown in <span class="No-Break"><em class="italic">Figure 8</em></span><em class="italic">.4</em>, which allows us to search for all the modules that are available in Puppet Forge, we have <span class="No-Break">various options:</span></p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/B18492_08_04.jpg" alt="Figure 8.4 – Puppet Forge search screen"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.4 – Puppet Forge search screen</p>
			<p>The <a id="_idIndexMarker602"/>most immediate valuable filter is <strong class="bold">COMPATIBILITY</strong>, which reflects the content of the <strong class="source-inline">metadata.json</strong> file for OS and Puppet version compatibility. The release date, latest release, and number of downloads can be key measures to show if this is a commonly used module and if it is being kept up <span class="No-Break">to date.</span></p>
			<p>Puppet implements an endorsement scheme that’s managed by the <strong class="bold">Content and Tooling Team </strong>(<strong class="bold">CAT</strong>) with<a id="_idIndexMarker603"/> three different types: Partner, Approved, <span class="No-Break">and Supported.</span></p>
			<p>Approved modules pass specific criteria documented at <a href="https://forge.puppet.com/about/approved/criteria">https://forge.puppet.com/about/approved/criteria</a>, which ensure the modules meet usability and quality standards. This can help you when you’re trying to choose a reliable module or allow your team to aim for a standard and submit your modules <span class="No-Break">via </span><a href="https://github.com/puppetlabs/puppet-approved-modules"><span class="No-Break">https://github.com/puppetlabs/puppet-approved-modules</span></a><span class="No-Break">.</span></p>
			<p>Supported modules follow the same standards as approved modules but are fully supported by Puppet or a Puppet-approved third-party vendor, allowing Puppet Enterprise customers to raise support cases if issues are experienced. Note that only the latest version of the module is supported, and Puppet Enterprise OS versions have limited windows of support beyond end-of-life dates. The full details can be viewed <span class="No-Break">at </span><a href="https://forge.puppet.com/about/supported"><span class="No-Break">https://forge.puppet.com/about/supported</span></a><span class="No-Break">.</span></p>
			<p>The third <a id="_idIndexMarker604"/>type of partner is when support and testing are provided but not by Puppet. For this support to be valid, a separate partner licensing scheme might <span class="No-Break">be required.</span></p>
			<p>As well as this endorsement approach, a score is put on each Puppet module. Since the mechanism for scoring was last updated, the details haven’t been published in full and a breakdown of the scoring is not visible, but the module quality score is based on code style checks, compatibility tests, and metadata validation. This score gives you an idea of the module’s overall adherence to Puppet code standards upon running <strong class="source-inline">anubis-docker</strong> to <span class="No-Break">evaluate </span><a href="https://github.com/puppetlabs/anubis-docker"><span class="No-Break">https://github.com/puppetlabs/anubis-docker</span></a><span class="No-Break">.</span></p>
			<p>Malware scanning was introduced in 2021 using VirtusTotal. A visible pass or failure of the module is visible on the <strong class="bold">description </strong>page; details are available via the <strong class="bold">quality checks </strong>tab. This is not intended as a replacement for internal malware-scanning processes but provides an extra level of protection. At the time of writing, this can only be on <strong class="source-inline">puppetlabs</strong> user modules, but this will be extended to Approved, Partner, and all future module releases at a <span class="No-Break">later date.</span></p>
			<p>Modules can be deprecated as new implementations come out or simply because the use case is no longer valid and won’t be supported. These modules will be hidden by default but can be made visible by selecting the <strong class="bold">show </strong><span class="No-Break"><strong class="bold">deprecated </strong></span><span class="No-Break">option.</span></p>
			<p>Premium modules were recently added with the release of the Puppet Comply product but they currently only apply to <strong class="source-inline">cem_windows</strong> and <strong class="source-inline">cem_linux</strong> modules, which can only be used upon purchasing <span class="No-Break">Puppet Comply.</span></p>
			<p>One area that had previously been neglected in Puppet due to its historic development focus on Linux is the Windows platform. Puppet Forge has a collection page (<a href="https://forge.puppet.com/collections/windows">https://forge.puppet.com/collections/windows</a>) that highlights modules designed for Windows, such as the Chocolatey package provider: <a href="https://forge.puppet.com/modules/puppetlabs/chocolatey">https://forge.puppet.com/modules/puppetlabs/chocolatey</a>. Another major development <a id="_idIndexMarker605"/>has been the auto-generation of PowerShell <strong class="bold">Desired State Configuration </strong>(<strong class="bold">DSC</strong>) Puppet modules. This automation looks at all the DSC content on PowerShell Gallery at <a href="https://www.powershellgallery.com/">https://www.powershellgallery.com/</a> and wraps up the PowerShell code so that by including the Puppet module version of the DSC, you can download and install the code and then configure it using Puppet. These modules can be found under the DSC user at <a href="https://forge.puppet.com/modules/dsc">https://forge.puppet.com/modules/dsc</a>; each module provides a <a id="_idIndexMarker606"/>reference to the available resource types that can be called. The modules include simple single actions such as <strong class="source-inline">xInternetExplorerHomePage</strong> for setting the home page for Internet Explorer and modules such as <strong class="source-inline">xActiveDirectory</strong>, which is used to deploy and configure Active Directory. <strong class="source-inline">xInternetExplorerHomePage</strong> is simple and has a single resource type called <strong class="source-inline">dsc_xinternetexplorerhomepage</strong> that can be used to set the default home page, <span class="No-Break">like so:</span></p>
			<pre class="source-code">
dsc_xinternetexplorerhomepage { 'set home page':
  dsc_startpage =&gt; 'https://www.packtpub.com'
}</pre>
			<p><strong class="source-inline">xActiveDirectory</strong> has various resource types to configure and deploy different aspects of <span class="No-Break">Active Directory.</span></p>
			<p>This has limitations since it is a fully automatic conversion and Puppet has no ownership of the DSC code. This makes testing limited and dependent on the quality of the code and documentation provided by the DSC code owner. You may also find some modules are deprecated in the PowerShell Gallery, so it is worth checking this. Also, note that due to a bug in <strong class="source-inline">minitar</strong>, only the Puppet Enterprise code manager can correctly unpack these modules from Puppet Forge directly. For open source users, refer to the module documentation instructions, which explain how to download the module from a web link to Puppet Forge and unpack the archive manually, ensuring that the module is installed and the DSC code is <span class="No-Break">unpacked fully.</span></p>
			<p>There are some further blogs and tools to be aware of, which are beyond the scope of this book but would be worth investigating for further information. To keep up to date with Puppet Forge and Puppet-managed modules, the CAT team runs a blog <a href="https://puppetlabs.github.io/content-and-tooling-team/">https://puppetlabs.github.io/content-and-tooling-team/</a>. Puppet Forge also has an API, available at <a href="https://forgeapi.puppet.com/">https://forgeapi.puppet.com/</a>, that allows more programmatic queries to be run, and the <strong class="source-inline">denmark </strong>module, developed by Ben Ford, provides additional scans and checks to assist with reviewing <span class="No-Break">modules: </span><a href="https://github.com/binford2k/denmark"><span class="No-Break">https://github.com/binford2k/denmark</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-169"><a id="_idTextAnchor231"/>Lab – creating a module and testing it</h1>
			<p>In this lab, you <a id="_idIndexMarker607"/>will use the knowledge you’ve gained about module structure, the PDK, and testing to create and test a Grafana module. Then, using what you learned about Puppet Forge, you will explore the Forge site to <span class="No-Break">choose modules:</span></p>
			<ul>
				<li>Using either the code you wrote for <a href="B18492_04.xhtml#_idTextAnchor078"><span class="No-Break"><em class="italic">Chapter 4</em></span></a><em class="italic"> </em>for the combined Grafana, Windows, and Linux class or the example answer at <a href="https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/all_grafana_data_types.pp">https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch04/all_grafana_data_types.pp</a>, create a new module called <strong class="source-inline">packt_grafana</strong>, with this Puppet code broken up into appropriate classes following the <strong class="source-inline">init</strong>, <strong class="source-inline">service</strong>, <strong class="source-inline">config</strong>, and <strong class="source-inline">install</strong> pattern (for this number of resources, a single class in the real world would be more appropriate, but this is just for practice). I recommend creating classes with <strong class="source-inline">pdk new class</strong>. Follow <a href="https://puppet.com/docs/puppet/latest/puppet_strings_style.html">https://puppet.com/docs/puppet/latest/puppet_strings_style.html</a> to ensure classes are fully documented and <span class="No-Break">pass tests.</span></li>
				<li>Expand the default tests provided by the PDK and design the contexts to be covered while considering the parameters that could be passed and the OS choices available. Use the <a href="https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch08/.sync.yml">https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch08/.sync.yml</a> file in the module, which will include the gem file for <strong class="source-inline">puppet-catalog_rspec</strong>, and run <strong class="source-inline">pdk update</strong>. To generate some of the RSpec resources automatically, you can add <strong class="source-inline">it</strong> <strong class="source-inline">{</strong> <strong class="source-inline">dump_catalog</strong> <strong class="source-inline">}</strong> to each class spec file (you will need to define some parameters for this to work) and remove the line once you have got the output. Add a coverage test at 100% and ensure your tests <span class="No-Break">achieve this.</span></li>
				<li>Using <strong class="source-inline">pdk validate</strong> and <strong class="source-inline">pdk test unit</strong>, correct the errors that can be found in the module, as shown <span class="No-Break">here: </span><a href="https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch08/mistakemodule"><span class="No-Break">https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch08/mistakemodule</span></a><span class="No-Break">.</span></li>
				<li>Go to Puppet Forge<a id="_idIndexMarker608"/> and decide which module you wish to use for the <span class="No-Break">following tasks:</span><ul><li>Configuring SSH <span class="No-Break">on Ubuntu</span></li><li>Installing and <span class="No-Break">configuring IIS</span></li><li>Configuring the time zone using DSC on a Windows machine (hint: It’s not <strong class="source-inline">xtimezone</strong>; refer <span class="No-Break">to </span><a href="https://www.powershellgallery.com/"><span class="No-Break">https://www.powershellgallery.com/</span></a><span class="No-Break">)</span></li><li>Install and <span class="No-Break">configure Logstash</span></li></ul></li>
			</ul>
			<p>See suggested answers <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch08/module_choice.txt"><span class="No-Break">https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch08/module_choice.txt</span></a></p>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor232"/>Summary</h1>
			<p>In this chapter, you learned how modules allow you to group code and data, making it easier to share and reuse code. We discussed that modules should focus on a clear single-use responsibility. We examined the directory structure of a module and highlighted where specific Puppet code and data were stored. A good starter manifest structure was shown, highlighting the main manifest (<strong class="source-inline">init.pp</strong>) that’s used as an entry point, with parameters acting like public APIs to allow the module to be flexible and include the other classes required. We also saw that the <strong class="source-inline">install.pp</strong>, <strong class="source-inline">config.pp</strong>, and <strong class="source-inline">service.pp</strong> classes focused on installation, configuration, and services, respectively. In the case that the application becomes more complex than this, we discussed how a module can use classes and directories for <span class="No-Break">different components.</span></p>
			<p>Next, we looked at the PDK as a way to automate how modules are created and group common tooling to help us manage and test Puppet modules. We created a Ruby environment and installed the communities’ most used development tools with configuration files in the module directory. The default template for producing modules was examined, as well as how to customize this by forking <span class="No-Break">on </span><span class="No-Break"><strong class="source-inline">sync.yaml</strong></span><span class="No-Break">.</span></p>
			<p>After, we looked at the life cycle of development when using various PDK commands to create or convert a module, as well as adding different Puppet types such as classes or defined types, which create unit tests. We looked at the <strong class="source-inline">pdk validate</strong> command as a way to perform linting and syntax validation, as well as to autocorrect where possible with the <strong class="source-inline">-a</strong> flag. The templates created basic RSpec tests to check the compilation of catalogs. The PDK <strong class="source-inline">build</strong> and <strong class="source-inline">release</strong> commands were also mentioned as ways to bundle the PDK for Puppet Forge or to bundle and upload it as one command – <span class="No-Break"><strong class="source-inline">release</strong></span><span class="No-Break">.</span></p>
			<p>Next, you learned how to expand RSpec using <strong class="source-inline">describe</strong> and <strong class="source-inline">context</strong> to structure the test cases and expectations and matchers for defining individual tests. You learned that preconditions can be set via <strong class="source-inline">let</strong> statements, allowing dependencies for the class to be created in the test. You also learned how relationships can be defined by chaining the relevant function. You saw how <strong class="source-inline">let</strong> statements can be used to define facts, node data, trusted facts, and trusted external facts in data and that by using the <strong class="source-inline">default_module_facts.yaml</strong> and <strong class="source-inline">spec_helper_local</strong> files, defaults can be set for the module. After this, we covered Hiera, detailing how the configuration file can be set in a spec or via <strong class="source-inline">spec_helper</strong> and how lookups can be performed. For external dependencies, the <strong class="source-inline">fixtures.yml</strong> file was shown to be able to bring in module dependencies from Puppet Forge or local repositories to allow for catalog compilation. Coverage reporting was then added to the local spec helper, allowing unit tests to show what resources were not covered by tests and to put a pass percentage on the test. Then, we looked at some further RSpec tooling and sources, which allow you to generate RSpec code and some checks that are beyond the scope of this book. ServerSpec was then highlighted as a server-level testing framework that uses RSpec. It’s independent of Puppet and beyond the scope of this book, but it’s worth investing in and, ideally, adding to <span class="No-Break">a pipeline.</span></p>
			<p>Having shown you how to develop and structure your modules, you learned how to source modules from Puppet Forge, understand the different types of module support and endorsement available from Puppet, how scoring and scanning took place on modules, and ways to understand who contributors were and their place in the Puppet community. The Windows collection of modules was mentioned, as well as the PowerShell DSC collection, which provides automated wraparounds for modules in the PowerShell Gallery, allowing the content to be downloaded and used within Puppet code. The CAT team was mentioned as maintainers of Puppet Forge that support content with their blog publishing updates. The Denmark module was then highlighted as an additional way to <span class="No-Break">score modules.</span></p>
			<p>In the next chapter, you will learn how Puppet handles data and be introduced to Hiera and explore how it layers data into different scopes. We will discuss when best to use Puppet code, variables, and Hiera to store data and how to structure and feed this data to module parameters. We will also cover the correct ways to store data security at rest and in transport, as well as some common issues with using data in Puppet and how to <span class="No-Break">approach them.</span></p>
		</div>
	</body></html>