- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Templating, Iterating, and Conditionals
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板化、迭代和条件语句
- en: This chapter will cover advanced structures for the Puppet language, including
    templates that enable the insertion of variables into templated files. The two
    formats available in Puppet, **Embedded Ruby** (**ERB**) templates, which are
    based on native Ruby templating, and **Embedded Puppet** (**EPP**) templates,
    which are modern Puppet language-based templates, will be discussed, highlighting
    the differences between the two and the core advantages of using EPP over ERB.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍Puppet语言中的高级结构，包括允许在模板文件中插入变量的模板。Puppet中有两种格式可用：**嵌入式Ruby**（**ERB**）模板，它基于原生Ruby模板化，和**嵌入式Puppet**（**EPP**）模板，它是基于现代Puppet语言的模板。本章将讨论这两种格式，重点介绍它们之间的区别，以及使用EPP而非ERB的核心优势。
- en: Additionally, the chapter will delve into the use of iteration and loops in
    Puppet, showing how iterative functions are used with sections of code known as
    lambdas in Puppet instead of more traditional `loop` keywords of other languages.
    Finally, the chapter will examine the different types of conditional statements
    available in Puppet, including `if`, `case`, and `unless` statements, which are
    typical of any programming language, and the Puppet-specific selector, which allows
    a value on a key or variable to be chosen based on a fact or variable. The chapter
    will also examine the use of regular expressions within conditionals in detail.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，本章还将深入探讨Puppet中的迭代和循环，展示如何使用Puppet中的迭代函数和代码块（lambdas），而不是其他语言中常见的`loop`关键词。最后，本章将讨论Puppet中可用的不同类型的条件语句，包括`if`、`case`和`unless`语句，这些语句是任何编程语言中常见的，以及Puppet特有的选择器，它允许根据事实或变量选择键或变量上的值。本章还将详细探讨在条件语句中使用正则表达式的情况。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: Templating formats in Puppet – EPP and ERB
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet中的模板格式 – EPP和ERB
- en: Iteration and loops
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迭代和循环
- en: Conditional statements
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件语句
- en: Technical requirement
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All code in this section can be tested on the local development server.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中的所有代码都可以在本地开发服务器上进行测试。
- en: Templating formats in Puppet – EPP and ERB
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Puppet中的模板格式 – EPP和ERB
- en: 'Templating in Puppet allows for the generation of content in a standard format,
    by substituting variables and using conditional logic to customize the content.
    Puppet supports two templating formats: ERB, which is a native Ruby templating
    format ([https://github.com/ruby/erb](https://github.com/ruby/erb)) and has been
    available in all versions of Puppet; and EPP templates, which are based on the
    Puppet language, were introduced in Puppet 4, and are available in later versions
    of Puppet 3 with the future parser enabled.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet中的模板化允许通过替换变量并使用条件逻辑来定制内容，从而生成标准格式的内容。Puppet支持两种模板格式：ERB，它是一个原生Ruby模板格式（[https://github.com/ruby/erb](https://github.com/ruby/erb)），并且在所有版本的Puppet中都可用；EPP模板，它基于Puppet语言，在Puppet
    4中引入，并且在启用未来解析器的Puppet 3版本中也可以使用。
- en: Templates provide greater flexibility than strings but are less flexible than
    using resources such as `file_line`, `augueas`, or `concat` for controlling individual
    or groups of settings. Therefore, a balance of complexity needs to be struck when
    deciding whether to use templates or resources.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 模板提供的灵活性超过了字符串，但比使用`file_line`、`augeas`或`concat`等资源控制单个或一组设置的灵活性要低。因此，在决定使用模板还是资源时，需要在复杂性之间找到平衡。
- en: For relatively short `heredoc` files or simple strings, templates with variable
    interpolation may be sufficient. However, for more complex files and particular
    files where multiple modules may be managing different settings or where manual
    edits may be accepted, using resources for each setting or section would be less
    complex and more manageable.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于相对较短的`heredoc`文件或简单字符串，使用带变量插值的模板可能已足够。然而，对于更复杂的文件，尤其是多个模块可能管理不同设置或接受手动编辑的文件，使用资源来处理每个设置或部分会更加简单且易于管理。
- en: In older code, it is possible to find that templates were overused, which can
    reflect the lack of availability of resource types such as `file_line` in previous
    versions of Puppet. It is important to review what state was being attempted to
    be achieved and ensure that by using templates to control all the content settings,
    a whole file is not being unnecessarily enforced, which may contain settings that
    have become redundant as the underlying application associated with the configuration
    file has updated and changed its configuration settings.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在旧代码中，可能会发现模板使用过度，这反映了在 Puppet 早期版本中缺乏资源类型（如 `file_line`）。因此，审查尝试实现的目标状态非常重要，并确保通过使用模板控制所有内容设置时，整个文件不会被不必要地强制执行，避免其中包含已变得冗余的设置，因为与配置文件相关的底层应用程序已经更新并更改了其配置设置。
- en: While there is no reason to use ERB for new code, many forge modules and legacy
    code bases may contain ERB, and thus both formats will be covered in this section
    to provide understanding. After showing the syntax of both formats, the advantages
    of using EPP and reasons to convert ERB to EPP will be discussed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然新代码中没有必要使用 ERB，但许多 forge 模块和遗留代码库可能包含 ERB，因此本节将涵盖这两种格式，以帮助理解。在展示两种格式的语法后，将讨论使用
    EPP 的优点以及将 ERB 转换为 EPP 的理由。
- en: Templates can be generated either by using content in template files or via
    a string, which is known as an inline template. For template files, ERB uses the
    `template` function and EPP uses the `epp` function. For inline templates, EPP
    uses the `inline_epp` function and ERB uses the `inline_template` function.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 模板可以通过使用模板文件中的内容或通过字符串（称为内联模板）生成。对于模板文件，ERB 使用 `template` 函数，EPP 使用 `epp` 函数。对于内联模板，EPP
    使用 `inline_epp` 函数，ERB 使用 `inline_template` 函数。
- en: EPP templates
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EPP 模板
- en: An EPP template file is a text file that contains a mixture of text and Puppet
    language expressions surrounded by tags. These tags indicate how the Puppet expression
    should be evaluated and can modify the text in the template, allowing for the
    creation of a file based on Puppet language features such as variable interpolation,
    logic statements, and functions.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: EPP 模板文件是一个文本文件，包含文本和 Puppet 语言表达式的混合，表达式被标签包围。这些标签指示 Puppet 表达式应如何评估，并可以修改模板中的文本，从而基于
    Puppet 语言特性（如变量插值、逻辑语句和函数）创建文件。
- en: '*Table 7.1* shows the available tag types that can be used:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 7.1* 显示了可以使用的标签类型：'
- en: '| **Tag Name** | **Starting tag (****with trimming)** | **Ending tag (****with
    trimming)** | **Purpose** |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **标签名称** | **起始标签（****带修剪）** | **结束标签（****带修剪）** | **目的** |'
- en: '| Parameter | `<% &#124;` (`<%- &#124;`) | `&#124;%>` (`&#124; - %>`) | Declare
    parameters accepted by the template |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | `<% &#124;` (`<%- &#124;`) | `&#124;%>` (`&#124; - %>`) | 声明模板接受的参数
    |'
- en: '| Non-printing expression | `<%` (`<%-`) | `%>` (`<%-`) | Evaluate the Puppet
    code but don’t print |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 非打印表达式 | `<%` (`<%-`) | `%>` (`<%-`) | 评估 Puppet 代码但不打印 |'
- en: '| Expression printing | `<%=` | `%>` (`-%>`) | Evaluate the code to a value
    to print |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 表达式打印 | `<%=` | `%>` (`-%>`) | 评估代码并打印其值 |'
- en: '| Comment | `<%#` (`<%#-`) | `%>` (`-%>`) | Allow the addition of comment lines
    just for the template file itself |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 注释 | `<%#` (`<%#-`) | `%>` (`-%>`) | 允许仅为模板文件本身添加注释行 |'
- en: Table 7.1 – EPP template tags
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.1 – EPP 模板标签
- en: When a template is evaluated, it switches between text mode and Puppet mode
    as it encounters start tags, and returns to text mode as it reaches end tags.
    In text mode, it outputs the text as content, and when it finds a tag, the Puppet
    code between the start and end tags is evaluated, depending on the kind of start
    tag.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当模板被评估时，它在遇到起始标签时会切换到 Puppet 模式，遇到结束标签时返回到文本模式。在文本模式下，它将文本输出为内容，当找到标签时，起始标签和结束标签之间的
    Puppet 代码会被评估，具体取决于起始标签的类型。
- en: As noted in *Table 7.1*, some of the tags can be modified with a hyphen (`-`)
    to trim spaces and new lines as appropriate.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如*表 7.1*所示，一些标签可以通过使用短横线（`-`）来修剪适当的空格和换行。
- en: The parameter tag is optional and, if used, must be the first content in a template
    file, except for a comment tag, which must use a closing hyphen. It produces behavior
    similar to how parameters can be declared at the start of Puppet classes, as was
    shown in [*Chapter 8*](B18492_08.xhtml#_idTextAnchor212). The parameters follow
    the same pattern as a class, so they can optionally include a type at the beginning.
    They must then have a dollar (`$`) symbol followed by a variable name, optionally
    followed by an equal (`=`) symbol and a default value, and finally, they must
    end with a comma.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 参数标签是可选的，如果使用，必须是模板文件中的第一个内容，注释标签除外，且注释标签必须使用闭合连字符。其行为类似于 Puppet 类的参数声明方式，如在
    [*第 8 章*](B18492_08.xhtml#_idTextAnchor212) 中所示。参数遵循与类相同的模式，因此它们可以选择性地在开头包含类型。接着必须有一个美元符号（`$`），后跟变量名，后可选择一个等号（`=`）和默认值，最后必须以逗号结束。
- en: 'For example, to have an options parameter containing a string set to an empty
    string by default, an `application_mode` parameter, which can contain full, partial,
    or none strings and defaults to `node`, and a `cluster_enabled` parameter, which
    is a Boolean, the following code would start our template:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，若要使一个选项参数包含一个默认值为空字符串的字符串，一个 `application_mode` 参数（可以包含 full、partial 或 none
    字符串，并且默认值为 `node`），以及一个 `cluster_enabled` 参数（布尔值），以下代码将开始我们的模板：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: When parameters are passed to an EPP template, they become local scope and can
    just be called directly by name, but variables from the calling class must be
    called by full namespace name; this is similar to a defined type. Any parameters
    without a default value, such as `cluster_enabled` in the preceding example, are
    mandatory and must be passed in.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当参数传递给 EPP 模板时，它们变为局部作用域，并且可以直接按名称调用，但来自调用类的变量必须使用完整的命名空间名称；这类似于定义类型。任何没有默认值的参数，例如前述示例中的
    `cluster_enabled`，都是必填的，必须传入。
- en: Note
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It is recommended to always use hyphens with parameters to avoid any accidental
    white space at the start of a template.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐始终在参数前使用连字符，以避免模板开头的任何意外空格。
- en: If parameters are not used, class variables can be directly accessed using the
    class scope, such as `$example_module::example_param`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有使用参数，可以直接使用类作用域访问类变量，例如 `$example_module::example_param`。
- en: Parameters allow a template to be more flexible if it is to be used in several
    different places, ensuring the data is more defined and locked down to requirements
    and making it clear at a glance what data is consumed. It may become a better
    option to just use variables when you need to use a lot of variables and parameters
    would just not scale. Passing parameters not defined in the parameter list will
    result in a syntax error, although if no parameters are used, any parameters can
    be passed to the template. Later in this section, it will be seen how to pass
    a hash to the `epp_template` function when referencing it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 参数使得模板在多个不同位置使用时更加灵活，确保数据更为明确且与需求紧密绑定，并且一目了然地展示了消耗的是什么数据。当需要使用大量变量时，使用变量可能比使用参数更合适，因为参数无法扩展。当未在参数列表中定义的参数被传递时，将导致语法错误，尽管如果不使用参数，可以向模板传递任何参数。本节后面将展示如何在引用
    `epp_template` 函数时传递哈希值。
- en: 'The `comment` tag in Puppet templates allows for comments to be added within
    the template file itself. These comments will not appear in the output when the
    template is evaluated and its content is generated. Here’s an example of what
    a comment would look like in a Puppet template:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 模板中的 `comment` 标签允许在模板文件内添加注释。这些注释在模板被评估并生成内容时不会出现在输出中。以下是 Puppet 模板中注释的示例：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `<%#-` hyphen trimming feature is available from Puppet 6.0.0 onward. Before
    this, the trimming behavior was assumed.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`<%#-` 连字符修剪功能自 Puppet 6.0.0 版本起提供。在此之前，修剪行为是默认假定的。'
- en: 'An expression printing tag puts the returned value of a Puppet expression into
    the output. This can be a variable or fact, the output of a function, or the output
    for operators. The final output is a string and will be automatically converted
    if necessary. At its simplest level, this can be used to print a fact as a value.
    For example, the following line will read `application = exampleapp` if the `application_name`
    fact contained the `exampleapp` value:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 打印表达式标签将 Puppet 表达式的返回值输出到结果中。这可以是一个变量或事实，函数的输出，或者运算符的输出。最终的输出是一个字符串，并会在必要时自动转换。在最简单的情况下，这可以用来打印事实作为值。例如，以下行将读取
    `application = exampleapp`，如果 `application_name` 事实包含 `exampleapp` 值：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This example is also the first time variables have been shown in this context,
    but they are accessed in the same way as variables in regular Puppet code.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例也是变量在这个上下文中首次展示，但它们的访问方式与常规 Puppet 代码中的变量相同。
- en: 'Non-printing tags contain iterative and conditional logic. This is different
    from other tags because the effect of the tag can span multiple lines until another
    tag closes the iterator or conditional logic. For example, the `if` statement
    (which will be covered in the *Conditional statement* section) opens with a curly
    brace, `{`, and closes with a curly brace, `}`. In the following example, we can
    ensure that if the application name returns `undef` from the `getvar` function,
    it will not output `application =` as it would have in our previous example. Instead,
    it will ignore the line if the variable is not defined:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 非打印标签包含迭代和条件逻辑。这与其他标签不同，因为标签的效果可以跨越多行，直到另一个标签关闭迭代器或条件逻辑。例如，`if` 语句（将在*条件语句*部分中讨论）以花括号
    `{` 开始，以花括号 `}` 结束。在下面的示例中，我们可以确保如果应用程序名称从 `getvar` 函数返回 `undef`，则不会输出 `application
    =`，就像我们之前的例子中所做的那样。相反，如果变量未定义，则会忽略该行：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Multiple levels of non-printing tags can be used to create nested `if` or `case`
    statements as appropriate.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用多级非打印标签来创建适当的嵌套 `if` 或 `case` 语句。
- en: 'There are some syntax mistakes to be careful with. If a non-printing expression
    tag contains a comment, it will essentially comment to the end of the line and
    require the close tag on the next line, as per this example:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些语法错误需要小心处理。如果非打印表达式标签包含注释，则基本上会注释到行尾，并且需要在下一行上关闭标签，如本例所示：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This mistake could clearly happen with a mistyped `comment` tag so care must
    be taken and any tags, not just a comment closing tag, would be ignored till the
    new line.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这种错误显然可能会发生在误键入的 `comment` 标签中，因此必须小心，并且任何标签，而不仅仅是注释关闭标签，都会被忽略直到新行。
- en: To include literal `<%` or `%>` characters in the template output without having
    them evaluated as EPP tags, you can use an additional `%` character to escape
    them. For instance, to output `<% Puppet expression example %>` as text, you would
    write `<%% Puppet expression example %%%>`. Note that the escape only applies
    to the first `<%` or `%>` encountered, so if you need to escape only one of them
    in a line, you can use the escape once and then the other symbol normally.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 要在模板输出中包含文字 `<%` 或 `%>` 字符而不让它们作为 EPP 标签进行评估，您可以使用额外的 `%` 字符来进行转义。例如，要将 `<%
    Puppet expression example %>` 输出为文本，您应该写成 `<%% Puppet expression example %%%>`。请注意，转义仅适用于遇到的第一个
    `<%` 或 `%>`，因此如果您需要在一行中仅转义其中一个，您可以使用一次转义，然后正常使用另一个符号。
- en: EPP templates can be validated using the `puppet epp validate <template_name.epp>`
    command, and in [*Chapter 8*](B18492_08.xhtml#_idTextAnchor212), it will be seen
    that the **Puppet Development Kit** (**PDK**) will run this command as part of
    its validation.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `puppet epp validate <template_name.epp>` 命令验证 EPP 模板，并且在[*第8章*](B18492_08.xhtml#_idTextAnchor212)中，将看到
    **Puppet 开发工具包** (**PDK**) 将在其验证过程中运行此命令。
- en: 'To test the rendering of templates, the `render` command can be used with a
    hash of values as required: `puppet epp render <template_name.epp> --values ''{key1
    => value1, key2 =>` `value2}''`.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试模板的渲染，可以使用 `render` 命令，并根据需要使用值哈希：`puppet epp render <template_name.epp>
    --values '{key1 => value1, key2 =>` `value2}'。
- en: Note
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The full specification for EPP templates can be viewed online at [https://github.com/puppetlabs/puppet-specifications/blob/master/language/templates.md](https://github.com/puppetlabs/puppet-specifications/blob/master/language/templates.md).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: EPP 模板的完整规范可以在线查看 [https://github.com/puppetlabs/puppet-specifications/blob/master/language/templates.md](https://github.com/puppetlabs/puppet-specifications/blob/master/language/templates.md)。
- en: 'After reviewing the syntax of the EPP template file, let’s see how to use the
    `epp` function in a Puppet resource. The `epp` function can be used with resources
    such as `file` by passing it to the `content` attribute. Additionally, a key-value
    hash can be provided to specify the parameters, as discussed in the previous section
    on the `parameter` tag:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查 EPP 模板文件的语法之后，让我们看看如何在 Puppet 资源中使用 `epp` 函数。可以通过将其传递给 `content` 属性，将 `epp`
    函数用于诸如 `file` 等资源。此外，可以提供键值哈希以指定参数，正如在关于 `parameter` 标签的前一节中讨论的那样：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you wish to try the preceding example on your developer environment, create
    a suitable template file on your system and change the `exampleapp` module name
    to the absolute path containing the template, such as `/var/tmp` or`C:\Users\David
    Sandilands`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在开发环境中尝试前面的示例，请在系统上创建一个合适的模板文件，并将`exampleapp`模块名更改为包含模板的绝对路径，例如`/var/tmp`或`C:\Users\David
    Sandilands`。
- en: The namespace used in `epp` assumes that either it will form a module path,
    `<modulename/templatename.epp>`, which translates to `modulepath/modulename/templates/templatename.epp`,
    or it will be an absolute path on disk. In [*Chapter 8*](B18492_08.xhtml#_idTextAnchor212),
    the structure of modules will be covered in detail.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`epp`中使用的命名空间假设它要么形成一个模块路径`<modulename/templatename.epp>`，该路径转换为`modulepath/modulename/templates/templatename.epp`，要么是磁盘上的绝对路径。在[*第8章*](B18492_08.xhtml#_idTextAnchor212)中，将详细介绍模块的结构。'
- en: Inline templates are similar to regular templates, but instead of using a separate
    template file, they require a string or variable to be passed to them. They are
    generally used for workarounds or where using a heredoc feels easier than using
    a template file.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 内联模板类似于常规模板，但它们不使用单独的模板文件，而是需要传递一个字符串或变量给它们。它们通常用于解决方法或在使用 heredoc 比使用模板文件更简单的情况下。
- en: 'One example of a workaround is when using the Vault module, which was discussed
    in [*Chapter 5*](B18492_05.xhtml#_idTextAnchor123), to retrieve secrets using
    deferred functions. The Vault module returns a key-value pair, but we may only
    want to access the value of the password. As the value is deferred, it can’t be
    manipulated as a string. Using the `inline_epp` function, as shown in the following
    example, allows us to unwrap the string during agent runtime and apply it to the
    file:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个解决方法的例子是在使用[*第5章*](B18492_05.xhtml#_idTextAnchor123)中讨论的Vault模块时，通过延迟函数来检索密钥。Vault模块返回一个键值对，但我们可能只想访问密码的值。由于该值是延迟的，因此不能像字符串一样操作。使用`inline_epp`函数，如以下示例所示，可以在代理运行时解包字符串并将其应用到文件中：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Having covered EPP templates for the management of heritage code, we will now
    review how ERB is different.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍了用于管理遗留代码的 EPP 模板后，我们将回顾 ERB 的不同之处。
- en: ERB templates
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ERB 模板
- en: ERB templates are similar to EPP templates, but there are some differences worth
    noting. ERB templates are text files that contain a mixture of text and Ruby language
    expressions surrounded by tags. ERB uses the same tags as EPP, except it does
    not have parameter tags, and it is not possible to pass parameters.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ERB 模板与 EPP 模板类似，但有一些值得注意的区别。ERB 模板是包含文本和 Ruby 语言表达式的混合文本文件，表达式被标签包围。ERB 使用与
    EPP 相同的标签，但它没有参数标签，并且无法传递参数。
- en: In ERB, a template has a local scope and a parent scope, which is the class
    or defined type evaluating the template. Variables in the current scope can be
    accessed using the `@` symbol, which is how Ruby normally accesses variables.
    To access variables out of scope, you can use the `scope` object or the older
    `scope.lookup` function, which was used before the hash format was introduced
    into Puppet.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ERB 中，模板具有局部作用域和父作用域，后者是评估模板的类或定义的类型。当前作用域中的变量可以使用`@`符号访问，这是 Ruby 通常访问变量的方式。要访问作用域外的变量，可以使用`scope`对象或较旧的`scope.lookup`函数，后者是在引入哈希格式之前在
    Puppet 中使用的。
- en: 'To give some simple Ruby examples, you can use an `if` statement to check whether
    the `exampleapp_extras` variable does not contain `NONE`, and to output the `extras
    <exampleapp_version>` string in the template. You can also use an `unless` statement
    to check whether the `exampleapp_key` variable is not `nil`, and to output the
    `key <exampleapp_nill>` string if it has a defined value:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给出一些简单的 Ruby 示例，可以使用`if`语句检查`exampleapp_extras`变量是否不包含`NONE`，并在模板中输出`extras
    <exampleapp_version>`字符串。还可以使用`unless`语句检查`exampleapp_key`变量是否为`nil`，如果它有定义值，则输出`key
    <exampleapp_nill>`字符串：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Iteration in Ruby is similar, with the `each` function also available. The
    following example shows an array of settings from a variable being output one
    by one in the template content using iteration:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Ruby 中的迭代类似，`each`函数也可用。以下示例显示了通过迭代将一个变量中的设置数组逐个输出到模板内容中：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Data from Puppet variables will be translated from their Puppet type to the
    equivalent Ruby type (more information can be found in the official Puppet documentation
    at [https://www.puppet.com/docs/puppet/latest/lang_template_erb.html#erb_variables-puppet-data-types-ruby](https://www.puppet.com/docs/puppet/latest/lang_template_erb.html#erb_variables-puppet-data-types-ruby)).
    However, it is beyond the scope of this book to discuss how Ruby can transform
    this data.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 变量的数据将从 Puppet 类型转换为等效的 Ruby 类型（更多信息请参见官方 Puppet 文档：[https://www.puppet.com/docs/puppet/latest/lang_template_erb.html#erb_variables-puppet-data-types-ruby](https://www.puppet.com/docs/puppet/latest/lang_template_erb.html#erb_variables-puppet-data-types-ruby)）。然而，如何将这些数据转换为
    Ruby 类型已经超出了本书的讨论范围。
- en: It is also possible to call Puppet functions in ERB templates using the `<%scope.function_name(<Name
    of function>, <Array of` `Arguments>)%>` syntax.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用 `<%scope.function_name(<函数名称>, <参数数组>)%>` 语法在 ERB 模板中调用 Puppet 函数。
- en: 'For example, to use the `downcase` function on the `example_variable` variable
    and output the result to the template, the following code can be used:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要对 `example_variable` 变量使用 `downcase` 函数并将结果输出到模板，可以使用以下代码：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Validating the syntax of an ERB template can be done by running the `erb` command:
    `erb -P -x -T ''-'' example.erb | ruby -c`. As with EPP, the PDK will check for
    both types of templates when running validation. Unfortunately, there is no way
    to render an ERB template.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 验证 ERB 模板的语法可以通过运行 `erb` 命令来完成：`erb -P -x -T '-' example.erb | ruby -c`。与 EPP
    一样，PDK 在运行验证时会检查两种模板。遗憾的是，无法呈现 ERB 模板。
- en: 'Using the content of an ERB template file in a file looks very similar to EPP,
    but as discussed, it does not have parameters and uses the `template()`function.
    Converting the EPP example would look like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件中使用 ERB 模板文件的内容看起来与 EPP 非常相似，但如前所述，它没有参数，并且使用 `template()` 函数。转换 EPP 示例的方式如下：
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'It is possible to pass and evaluate multiple template files, which will be
    concatenated together. For example, updating content as follows would combine
    the two templates:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 可以传递并评估多个模板文件，这些文件将会合并在一起。例如，更新如下内容将合并两个模板：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Inline ERB just uses the `inline_template` function in the same system as inline
    EPP, and was often written in the past to allow Ruby code to provide a workaround
    for the lack of iteration/loops provided by past versions of Puppet and perform
    data transformation.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 内联 ERB 仅使用与内联 EPP 相同系统中的`inline_template`函数，并且过去经常用来通过 Ruby 代码提供一种解决方案，弥补早期版本的
    Puppet 缺乏迭代/循环功能，并执行数据转换。
- en: Now that ERB has been discussed, it is time to highlight why EPP is preferred
    over ERB and reasons to consider converting heritage code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在既然已经讨论了 ERB，是时候突出 EPP 相较于 ERB 更受青睐的原因以及考虑转换遗留代码的理由了。
- en: EPP and ERB comparison
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EPP 与 ERB 比较
- en: After reviewing both syntax templates, it is clear that EPP has several advantages
    over ERB. Firstly, EPP has significantly better performance than ERB. ERB creates
    a scope object for all facts and top-scope variables each time a template is evaluated,
    while EPP only uses facts and variables relevant to the template. In environments
    with a large number of facts, this can have a significant impact on performance.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在审查了两种语法模板后，很明显 EPP 相较于 ERB 具有多个优势。首先，EPP 的性能明显优于 ERB。每次评估模板时，ERB 会为所有事实和顶层变量创建一个作用域对象，而
    EPP 仅使用与模板相关的事实和变量。在拥有大量事实的环境中，这可能会对性能产生显著影响。
- en: Furthermore, EPP provides greater security because templates can be provided
    with a limited scope of data to be used and validate that all data exists before
    use. ERB, on the other hand, has no built-in validation, and non-existent variables
    will simply be dropped. For example, if a variable in a class has not been evaluated
    before the template is used, ERB will not catch this.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，EPP 提供了更高的安全性，因为模板可以提供一个有限的数据范围供使用，并在使用前验证所有数据是否存在。而 ERB 则没有内建的验证，且不存在的变量会被简单地忽略。例如，如果类中的某个变量在模板使用前未被评估，ERB
    将无法捕捉到这一点。
- en: EPP can also be seen as easier to use since it is in the Puppet DSL style and
    does not require any Ruby knowledge. This makes it easier to code, especially
    with the ability to use the `puppet epp render` and `validate` commands. Additionally,
    EPP is under more active development, and recent features, such as templates being
    able to automatically unwrap sensitive variables in 6.20 and later, will only
    be available in EPP.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: EPP也被认为更易于使用，因为它采用Puppet DSL风格，并且不需要任何Ruby知识。这使得编码更加容易，特别是能够使用`puppet epp render`和`validate`命令。此外，EPP正在积极开发中，最近的功能（例如，6.20及以后版本中能够自动解开敏感变量的模板）仅在EPP中可用。
- en: Iteration and loops
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迭代和循环
- en: Puppet’s approach to iteration and loops is influenced by the fact that its
    variables are immutable, meaning that once they are set, they cannot be changed.
    This makes many normal approaches used with `loop` or `do` keywords to transform
    data impossible. In early versions of the language, this was worked around by
    passing an array to defined types, as discussed in [*Chapter 3*](B18492_03.xhtml#_idTextAnchor048),
    or using inline ERB templates with Ruby code to manipulate arrays and hashes.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet的迭代和循环方法受其变量不可变性的影响，这意味着一旦设置，变量就不能更改。这使得许多正常使用`loop`或`do`关键字来转换数据的方法变得不可能。在语言的早期版本中，通过传递数组给定义类型来解决这个问题，如[*第3章*](B18492_03.xhtml#_idTextAnchor048)所述，或者使用带有Ruby代码的内联ERB模板来操作数组和哈希。
- en: However, the issue with the defined type approach was that the code doing the
    work was abstracted away and not visible. Furthermore, every time a different
    type of iteration was required, it would require its own defined type, bloating
    the code. Therefore, it is important to review heritage code and refactor these
    patterns to the approaches that will be discussed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用定义类型方法的问题在于，执行工作的代码被抽象化了，不可见。而且，每次需要不同类型的迭代时，都需要其自定义的定义类型，这使得代码膨胀。因此，回顾旧代码并重构这些模式为接下来将讨论的方法非常重要。
- en: 'In modern Puppet, the approach taken is to use iterative functions that pass
    data from arrays and hashes to lambdas. A lambda is a function with no name, so
    it cannot be called anywhere else except by a function. A lambda can be attached
    to any function call, including custom functions. *Table 7.2* provides a full
    list of functions involved with iteration and lambdas. While some functions may
    not be considered iterators, they have similar behaviors. It should also be noted
    that other functions could be combined/chained into these examples, such as `unique`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代Puppet中，采取的方法是使用迭代函数将数据从数组和哈希传递给lambda。lambda是一个没有名字的函数，因此除非通过某个函数调用，否则无法在其他地方调用。lambda可以附加到任何函数调用中，包括自定义函数。*表7.2*提供了涉及迭代和lambda的完整函数列表。虽然一些函数可能不被认为是迭代器，但它们有类似的行为。还应注意，其他函数可以与这些示例组合/链接，例如`unique`：
- en: '| **Function name** | **Purpose** | **Return type** | **Parameters** |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| **函数名称** | **目的** | **返回类型** | **参数** |'
- en: '| `all` | Runs through all elements until `false` is returned from the lambda
    or completes and returns `true`. | `true` or `false` | 1 or 2 |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `all` | 遍历所有元素，直到lambda返回`false`或完成并返回`true`。 | `true`或`false` | 1或2 |'
- en: '| `any` | Runs through all elements until `true` is returned from the lambda
    or completes and returns `false`. | `true` or `false` | 1 or 2 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `any` | 遍历所有元素，直到lambda返回`true`或完成并返回`false`。 | `true`或`false` | 1或2 |'
- en: '| `break` | Used within a lambda and stops the iteration. | n/a | n/a |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `break` | 用于lambda内部，停止迭代。 | 无 | 无 |'
- en: '| `each`, `reverse_each`, `tree_each` | Passes each element of a hash or array
    in turn for the lambda to process (reverse order or recursive variations). | n/a
    | 1 or 2 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `each`, `reverse_each`, `tree_each` | 依次传递哈希或数组的每个元素供lambda处理（逆序或递归变体）。 |
    无 | 1或2 |'
- en: '| `filter` | Runs through all elements and matches with lambda code, returning
    matching elements in an array. | Array | 1 or 2 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `filter` | 遍历所有元素并与lambda代码匹配，返回匹配的元素数组。 | 数组 | 1或2 |'
- en: '| `index` | Runs through all elements and on the first match within lambda
    code, returns the index of the matching element. | Integer | 1 or 2 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `index` | 遍历所有元素，并在lambda代码中首次匹配时，返回匹配元素的索引。 | 整数 | 1或2 |'
- en: '| `lest` | The function takes one argument; if this value is undefined it will
    run a lambda and return the outcome. If the argument is not undefined it will
    return the argument. | Any valid type | 0 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `lest` | 该函数接受一个参数；如果该值未定义，它将运行一个lambda并返回结果。如果参数未定义，它将返回该参数。 | 任意有效类型 |
    0 |'
- en: '| `map` | Runs through all elements and applies lambda code to that element.
    Returns an array of elements post lambda. | array | 1 or 2 |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `map` | 遍历所有元素并对该元素应用 lambda 代码。返回应用 lambda 后的元素数组。 | 数组 | 1 或 2 |'
- en: '| `next` | Used within a lambda to change the value of the next element in
    the iteration. | n/a | n/a |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `next` | 在 lambda 中使用，用于改变迭代中下一个元素的值。 | n/a | n/a |'
- en: '| `reduce` | Runs through all elements and applies lambda code passing the
    outcome forward to each iteration. | array | 2 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `reduce` | 遍历所有元素并应用 lambda 代码，将结果传递给每次迭代。 | 数组 | 2 |'
- en: '| `return` | Used to cause a lambda to return (cannot be used at top scope).
    | n/a | n/a |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `return` | 用于使 lambda 返回（不能在顶层作用域中使用）。 | n/a | n/a |'
- en: '| `slice` | Runs through a sliced size of elements such as three elements per
    iteration. | Array | 1 or size of slice |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `slice` | 按切片大小遍历元素，例如每次迭代三个元素。 | 数组 | 1 或切片大小 |'
- en: '| `step` | Chained into another iterable function passing a sequence of elements
    incrementing at a step size from a starting element to a finishing element. |
    Iterable | n/a |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `step` | 链接到另一个可迭代函数，传递一个从起始元素到结束元素按步长递增的元素序列。 | 可迭代 | n/a |'
- en: '| `then` | Takes one argument and if it is not undefined, it will call a lambda
    with the argument. Otherwise, it will return `undefined`. | Any valid type | 1
    |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| `then` | 接受一个参数，如果该参数不是 `undefined`，则调用一个 lambda 并传递该参数。否则，返回 `undefined`。
    | 任何有效类型 | 1 |'
- en: '| `with` | Takes one argument and unconditionally passes it to a lambda and
    runs with the argument. Returns the result of the lambda. | Any valid type | 1
    |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `with` | 接受一个参数，并无条件将其传递给 lambda 并使用该参数运行。返回 lambda 的结果。 | 任何有效类型 | 1 |'
- en: Table 7.2 – Functions for iteration and lambdas
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 表 7.2 – 迭代和 lambda 函数
- en: 'The basic syntax structure for iterative functions using lambdas in Puppet
    is as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Puppet 中使用 lambda 的迭代函数的基本语法结构如下：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'As an example, consider using the `each` function to loop around an array,
    with a single parameter (optionally typed), and printing the output:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑使用 `each` 函数对一个数组进行迭代，使用一个参数（可选类型），并打印输出：
- en: '[PRE13]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This would result in the `notice` function printing for each string in the array,
    similar to a `for` loop with a `print`/`echo` command in most languages.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致 `notice` 函数为数组中的每个字符串打印输出，类似于大多数语言中的 `for` 循环和 `print`/`echo` 命令。
- en: 'The `each` function can also use two parameters, which would give the index
    as the first parameter and the content of that index as the second parameter.
    The following code would print `index 2 contains second` for the second iteration
    of the lambda:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`each` 函数也可以使用两个参数，第一个参数为索引，第二个参数为该索引对应的内容。以下代码将在第二次迭代时打印 `index 2 contains
    second`：'
- en: '[PRE14]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To test these examples on your developer desktop, simply run `puppet apply -e
    '<``example code>'`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要在开发者桌面上测试这些示例，只需运行 `puppet apply -e '<``example code>'`。
- en: 'To clarify, when using the `each` function with a single parameter on a hash,
    each key-value pair will be passed as an array to the lambda. For example, running
    the code `[{ key1 => ''val1'', key2 => ''val2'' }].each | $key_pair | { notice
    $key_pair }` will output two arrays, one for each key-value pair: `[''key1'',
    ''val1'']` and `[''``key2'', ''val2'']`.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确，当在哈希上使用 `each` 函数并且仅使用一个参数时，每个键值对将作为一个数组传递给 lambda。例如，运行代码 `[{ key1 =>
    'val1', key2 => 'val2' }].each | $key_pair | { notice $key_pair }` 将输出两个数组，每个键值对对应一个数组：`['key1',
    'val1']` 和 `['``key2', 'val2']`。
- en: 'If two parameters are used in the lambda, the first parameter will represent
    the key and the second parameter will represent the value. For example, running
    the code `[{ key1 => ''val1'', key2 => ''val2'' }].each | $key, $value | { notice
    "$key contains $value" }` will output two strings, one for each key-value pair:
    `key1 contains val1` and `key2` `contains val2`'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 lambda 使用两个参数，第一个参数代表键，第二个参数代表值。例如，运行代码 `[{ key1 => 'val1', key2 => 'val2'
    }].each | $key, $value | { notice "$key contains $value" }` 将输出两个字符串，每个键值对对应一个字符串：`key1
    contains val1` 和 `key2 contains val2`。
- en: It is also worth noting that other data types, such as strings, can be automatically
    converted into arrays where each character in the string will be treated as an
    element. Additionally, a range of numbers can be declared using an `Integer` type;
    for example, running the code `Integer[100, 150].each | Integer $number | { notice
    $number }` will output all integers from `100` to `150`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 还值得注意的是，其他数据类型（例如字符串）可以自动转换为数组，其中字符串中的每个字符都被视为一个元素。此外，还可以使用 `Integer` 类型声明数字范围；例如，运行代码
    `Integer[100, 150].each | Integer $number | { notice $number }` 将输出从 `100` 到 `150`
    的所有整数。
- en: 'Finally, iteration can be nested; for example, to handle a hash with array
    values, an iterative function can be used within the lambda. Running the following
    code will output each value in the array of the `key1` key-value pair – `''value1''`
    and `''value2''`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，迭代可以嵌套；例如，为了处理具有数组值的哈希，可以在 lambda 内使用迭代函数。运行以下代码将输出 `key1` 键值对数组中的每个值——`'value1'`
    和 `'value2'`：
- en: '[PRE15]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Overall, this section provides an overview of the most commonly used functions
    in Puppet, but for more in-depth descriptions, users can refer to the official
    documentation at [https://www.puppet.com/docs/puppet/latest/function.html](https://www.puppet.com/docs/puppet/latest/function.html
    ) .
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，本节概述了 Puppet 中最常用的函数，但若想了解更深入的描述，用户可以参考官方文档：[https://www.puppet.com/docs/puppet/latest/function.html](https://www.puppet.com/docs/puppet/latest/function.html)。
- en: Iterative loops
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代循环
- en: 'The main function reviewed so far is `each`, and there are several functions
    that perform this loop of elements or manipulate the loop. `reverse_each` simply
    takes the reverse order of the elements, as its name suggests. `tree_each` allows
    values in nested arrays/hashes to be returned with different behaviors depending
    on the flags provided. It is relatively complicated and niche. The `slice` function
    allows us to take a specific number of elements in each iteration. For example,
    the following code would pass arrays of three numbers at a time from the sequence
    to the lambda:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止审查的主要函数是 `each`，还有几个函数执行元素的循环或操作循环。`reverse_each` 函数简单地按名称所示取元素的反向顺序。`tree_each`
    允许返回嵌套数组/哈希中的值，并根据提供的标志采用不同的行为。它相对复杂且较为冷门。`slice` 函数允许我们在每次迭代中获取特定数量的元素。例如，以下代码会每次传递三个数字的数组给
    lambda：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'On the last iteration, it would provide the remaining elements; in this example,
    an array with just `[151]`. It is also possible to use multiple parameters, but
    the number of parameters must be the same as the `slice` size:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一次迭代时，它将提供剩余的元素；在此示例中，即一个仅包含 `[151]` 的数组。也可以使用多个参数，但参数的数量必须与 `slice` 的大小相同：
- en: '[PRE17]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `step` function allows us to choose which elements of an iterable we wish
    to pass. In this code example, it would start at the first element, then the fourth,
    the seventh, and so on:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`step` 函数允许我们选择要传递的可迭代元素。在这个代码示例中，它将从第一个元素开始，然后是第四个、第七个，以此类推：'
- en: '[PRE18]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This can be useful when chained into another iterable function. The next type
    of function is for matching patterns. This is a different style of iteration function
    where instead of just passing the elements to the lambda to perform some action,
    the iterative function defines how the lambda will return. For example, `all`
    is looking for all elements to match the check in the lambda to return `true`.
    If any of the lambdas return `false`, the function will return `false`. For example,
    the following code would print `true` because all the elements were greater than
    `99`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这在链式调用到另一个可迭代函数时非常有用。下一个函数类型是用于匹配模式。这是一种不同风格的迭代函数，在这种方式下，迭代函数定义了 lambda 如何返回，而不是仅将元素传递给
    lambda 执行某些操作。例如，`all` 寻找所有元素是否都满足 lambda 中的检查条件以返回 `true`。如果任何一个 lambda 返回 `false`，该函数将返回
    `false`。例如，以下代码将输出 `true`，因为所有元素都大于 `99`：
- en: '[PRE19]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `any` function is the opposite of `all`, returning `false` if there are
    no matches and `true` if the lambda returns `true` in any iteration. The `index`
    function is similar to `any`, but instead of returning `true` or `false`, it returns
    the index number of the element that matches, or `undef` if there is no match.
    For example, the following code would print `20`, as `number` would match the
    20th element:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`any` 函数与 `all` 相反，如果没有匹配项，则返回 `false`，如果在任何迭代中 lambda 返回 `true`，则返回 `true`。`index`
    函数类似于 `any`，但它不是返回 `true` 或 `false`，而是返回匹配元素的索引号，若没有匹配项则返回 `undef`。例如，以下代码会输出
    `20`，因为 `number` 会匹配到第 20 个元素：'
- en: '[PRE20]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: All of the functions can work with two parameters on arrays or hashes, as shown
    in the examples for the `each` function.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数都可以在数组或哈希上使用两个参数，如 `each` 函数的示例所示。
- en: Data transformation
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据转换
- en: 'Data transformation is another way iterators are used to iterate through elements
    and perform adjustments before returning them. This is one of the main reasons
    why the iterator to lambda pattern was developed, as Puppet is unable to reassign
    variables. For example, the `map` function iterates over each element and applies
    a lambda whose result is stored in an array. For example, the following code would
    divide each element by `1024` and return an array of `[2,` `3, 1]`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 数据转换是迭代器用于遍历元素并在返回之前进行调整的另一种方式。这也是迭代器与lambda模式开发的主要原因之一，因为Puppet无法重新赋值变量。例如，`map`函数会遍历每个元素，并应用一个lambda，其结果会存储在一个数组中。例如，下面的代码会将每个元素除以`1024`，并返回一个数组`[2,
    3, 1]`：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `filter` function takes each element in the iteration and applies the code
    in the lambda. If the lambda returns `true`, the element will be added to an array
    for return. Otherwise, if `false`, it will continue to the next iteration. For
    example, the following filter would iterate through each array, checking whether
    the size is greater than `0`, which would result in an output of `[[1, 2, 3],
    [''a'', ''b'', ''c'']]`, with the second element’s empty array being removed:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter`函数在每次迭代中处理每个元素，并应用lambda中的代码。如果lambda返回`true`，则该元素将被添加到数组中并返回。否则，如果返回`false`，则会继续到下一次迭代。例如，下面的filter会遍历每个数组，检查其大小是否大于`0`，结果会输出`[[1,
    2, 3], [''a'', ''b'', ''c'']]`，并移除第二个元素中的空数组：'
- en: '[PRE22]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Both `filter` and `map` can handle one or two parameters, as shown with the
    `each` function on arrays and hashes.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`filter`和`map`都可以处理一个或两个参数，如在数组和哈希上的`each`函数所示。'
- en: 'The `reduce` function allows for cumulative work to take place in the lambdas.
    It is different from the other functions and requires two parameters: the first
    parameter keeps its value through the iterations, while the second is the element.
    Additionally, the starting value can be chosen for the first parameter by passing
    a value to the `reduce` function. In this example, the `total` parameter would
    start at `1` and, in each round, add the element to its total, resulting in `15`
    being returned and printed:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce`函数允许在lambda中进行累积操作。它与其他函数不同，需要两个参数：第一个参数在迭代过程中保持其值，而第二个参数是元素。此外，可以通过传递一个值给`reduce`函数来选择第一个参数的初始值。在这个例子中，`total`参数的初始值为`1`，并且在每一轮中将元素加到它的总和上，最终返回并打印`15`：'
- en: '[PRE23]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Within a lambda, it is also possible to change the flow of iteration. The `next`
    function can change what the next element will be: `undef` if nothing is provided
    to the `next` function, or the value provided to the `next` function. The `break`
    function stops the iterator at that point in the code and returns to the iterative
    function, effectively ending the iterator at that point. The `return` function,
    in comparison, returns from the iterative function, so it will not complete at
    all and returns to the containing class, function, or defined type.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在lambda中，也可以改变迭代的流程。`next`函数可以改变下一个元素是什么：如果没有传递任何值给`next`函数，则为`undef`，否则为提供给`next`函数的值。`break`函数会在代码的这一点停止迭代器，并返回到迭代函数，从而有效地结束迭代器的执行。相比之下，`return`函数会从迭代函数中返回，因此不会继续执行，并返回到包含类、函数或定义的类型。
- en: 'To demonstrate this change in flow, the first example using `map` over a series
    of numbers will run a `next` function, and when the element matches `101`, it
    will replace the next element, `102`, with `1984`, and then a `break` function
    will be run when the element is greater than `104`. So, with the notice at the
    end printing, this will return an array of `[100,` `1984, 102]`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一流程的变化，第一个使用`map`的例子会遍历一系列数字，运行`next`函数，当元素等于`101`时，会将下一个元素`102`替换为`1984`，然后当元素大于`104`时会运行`break`函数。因此，最终会打印的输出将是一个数组`[100,
    1984, 102]`：
- en: '[PRE24]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To highlight the different behavior of replacing the `break` function with
    a `return` function, the following example will result in nothing being printed:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了突出用`return`函数替换`break`函数后的不同行为，下面的例子将不会打印任何内容：
- en: '[PRE25]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is the reason, in this example, that we have put the function within a
    class because `return` cannot be called at a top scope level only within a class,
    function, or defined type.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是在这个例子中我们将函数放入类中的原因，因为`return`只能在类、函数或定义类型中调用，不能在顶层作用域调用。
- en: Nested data
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套数据
- en: 'The last types of functions are useful when handling nested data or generally
    handling undefined values. `then` is chained after a lambda and if it receives
    `undef` outputted from that lambda, it will return `undef`; otherwise, it will
    pass the value to another lambda. So the following example would use the `dig`
    function to attempt to access a `c` element that doesn’t exist in the second hash
    in the array, and as `then` would receive `undef`, it would therefore return `undef`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一类函数在处理嵌套数据或处理未定义值时非常有用。`then` 会在 lambda 后链接，如果它从该 lambda 输出 `undef`，则返回 `undef`；否则，它会将该值传递给另一个
    lambda。所以，以下示例将使用 `dig` 函数来尝试访问数组中第二个哈希表中不存在的 `c` 元素，由于 `then` 将接收到 `undef`，它因此会返回
    `undef`：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To clarify the previous statement, if `dig(first, second, 1, d)` is changed
    to `dig(first, second, 2, d)`, it would then pass `30` to the lambda, which would
    divide by `10` and print `3`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 为了澄清前面的语句，如果将 `dig(first, second, 1, d)` 改为 `dig(first, second, 2, d)`，它将把 `30`
    传递给 lambda，该 lambda 将除以 `10` 并打印出 `3`。
- en: '`lest` is the opposite of `then` and returns the value it is defined; otherwise,
    it passes `undef` to the lambda, which can take an action such as setting a default
    value instead. This can be useful; when used alongside `then`, taking the preceding
    example, adding `lest` would allow a value of `undef` to be returned if it is
    `0`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`lest` 是 `then` 的反义词，并返回其定义的值；否则，它会将 `undef` 传递给 lambda，这样就可以采取诸如设置默认值等操作。这在与
    `then` 一起使用时非常有用。以先前的示例为例，添加 `lest` 将允许在值为 `0` 时返回 `undef`：'
- en: '[PRE27]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `with` function is somewhat of a specialist edge, as it is used to pass
    values through if our lambda is able to handle `undef` or defined values.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`with` 函数有些特殊，因为它用于通过 lambda 传递值，如果我们的 lambda 能处理 `undef` 或已定义的值。'
- en: 'So, having reviewed the various functions and seeing the data transformation
    and explorations of data possible, it is worth highlighting again how, instead
    of using a defined type, as was done in the past, when we need to create multiple
    resources. So, for example, to create a directory for as many instances as requested,
    the following code could be used:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，经过对各种函数的审查，以及数据转换和数据探索的可能性，值得再次强调，与过去使用定义类型的方式不同，当我们需要创建多个资源时，应该使用另一种方法。所以，例如，要为请求的多个实例创建目录，可以使用以下代码：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Having covered how Puppet can perform loops and iteration, the conditional statements
    will be reviewed next.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在讲解了 Puppet 如何执行循环和迭代后，接下来将回顾条件语句。
- en: Conditional statements
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件语句
- en: Puppet has the conditional statements you would expect of any language, with
    `if`, `unless`, and `case` allowing code behavior to be different depending on
    things such as facts or data from external sources. Puppet additionally uses selectors,
    which are similar to a `case` statement but return a value instead of executing
    code on result.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 具有你在任何语言中都能预期的条件语句，`if`、`unless` 和 `case` 允许根据事实或来自外部源的数据等不同因素使代码行为有所不同。此外，Puppet
    还使用选择器，这类似于 `case` 语句，但返回一个值，而不是在结果上执行代码。
- en: If and unless statements
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`if` 和 `unless` 语句'
- en: The `if` statement follows a specific syntax that includes the `if` keyword
    followed by a condition, an opening curly brace (`{`), the Puppet code to execute
    if the condition evaluates to `true`, and a closing curly brace (`}`).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 语句遵循特定的语法，其中包括 `if` 关键字，后跟条件，一个左花括号（`{`），当条件为 `true` 时要执行的 Puppet 代码，最后是一个右花括号（`}`）。'
- en: 'The following example is a simple check on a Boolean in `example_bool` to print
    a notice if it contains `true`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例是对 `example_bool` 中布尔值的简单检查，如果它包含 `true`，则打印一条通知：
- en: '[PRE29]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This can be optionally extended by adding an `else` keyword after the closing
    curly brace (`}`) of the `if` statement and then using an opening curly brace
    (`{`) with Puppet code to perform if the condition is `false`. This is then closed
    with a closing curly brace (`}`). To also print when `example_bool` is `false`,
    the code would be updated as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过在`if`语句的闭括号（`}`）后可选地添加 `else` 关键字，并使用左花括号（`{`）结合 Puppet 代码来执行，当条件为 `false`
    时。然后再用右花括号（`}`）结束。如果要在 `example_bool` 为 `false` 时也打印，则代码更新如下：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Similarly, to perform multiple `if` checks together, the `elsif` keyword can
    be used after the `if` statement’s closing curly brace (`}`), allowing the same
    `if` syntax to be followed again. This can be nested and repeated as required.
    To provide an example, following up on the Boolean check with `elsif`, we can
    add a second check to see whether the value variable is greater than `2`, print
    a notice if it is, and an `else` statement that prints that both conditions were
    `false`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，要一起执行多个`if`检查，可以在`if`语句的闭括号（`}`）之后使用`elsif`关键字，允许再次使用相同的`if`语法。可以根据需要进行嵌套和重复。举个例子，在布尔值检查后，使用`elsif`，我们可以添加第二个检查，查看值变量是否大于`2`，如果是，则打印一条通知，并使用`else`语句打印两个条件都是`false`的情况：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The `unless` statement is simply the inverse of the `if` statement. It allows
    you to avoid having to negate a condition, and it can also be used in combination
    with an `if` statement. However, it has no equivalent to `elsif` and will cause
    a compilation failure if used. To demonstrate this with the previous `if` example,
    the `unless` statement can be used instead to check whether `example_bool` is
    `false` and print a notice in that case:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`unless`语句只是`if`语句的反义语句。它允许你避免对条件进行取反，并且它也可以与`if`语句结合使用。然而，它没有与`elsif`相对应的部分，如果使用将导致编译失败。以之前的`if`示例为例，可以改用`unless`语句来检查`example_bool`是否为`false`，如果是，则打印一条通知：'
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Any non-Boolean values used in the conditions will be converted to Booleans
    as per the data type rules, as covered in [*Chapter 4*](B18492_04.xhtml#_idTextAnchor078).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 条件中使用的任何非布尔值将根据数据类型规则转换为布尔值，如在[*第4章*](B18492_04.xhtml#_idTextAnchor078)中所述。
- en: The Puppet style guide recommends for the lines which follow the keywords `if`
    and `unless` that the code should be indented by two spaces and aligned as was
    shown in the examples.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet风格指南建议，在`if`和`unless`关键字之后的代码行应该缩进两个空格，并与示例中显示的对齐。
- en: Case statement
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`case`语句'
- en: The `case` statement works by matching the value outputted from a control expression.
    This is commonly the content of a fact or variable, but it could also be an expression
    or function. The format starts with the `case` keyword, followed by a control
    expression, resolving to a value and enclosed within curly braces. Each following
    line starts with either a matching case or a comma-separated list of cases, followed
    by a colon, and the Puppet code enclosed within curly braces to be applied for
    the matching case. The `case` statement is then closed with a curly brace.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`case`语句通过匹配控制表达式输出的值来工作。通常这是事实或变量的内容，但它也可以是一个表达式或函数。该格式以`case`关键字开始，后跟一个控制表达式，解析为一个值，并用大括号括起来。每一行以匹配的case或逗号分隔的case列表开始，后跟冒号，然后是要应用于匹配case的Puppet代码，代码用大括号括起来。`case`语句最后以大括号结束。'
- en: 'For example, to test the value of the `hardwareisa` fact and include a profile
    based on the type of processor architecture in use, the following code can be
    used. It includes a Unix profile for `sparc` or `powerpc` values, the Linux 32-bit
    profile for `i686` and `i386` values, the 64-bit profile for any value ending
    in `64`, and the default profile for any value failing to match a case:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要测试`hardwareisa`事实的值并根据使用的处理器架构类型包含一个配置文件，可以使用以下代码。它包括`sparc`或`powerpc`值的Unix配置文件，`i686`和`i386`值的Linux
    32位配置文件，任何以`64`结尾的值的64位配置文件，以及任何无法匹配到某个情况的值的默认配置文件：
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The Puppet style guide recommends always using a `default` case, which can be
    a failure or even just an empty curly brace.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet风格指南建议始终使用`default` case，它可以是一个失败的情况，甚至只是一个空的大括号。
- en: Selectors
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择器
- en: Selectors are similar to `case` statements, but instead of applying Puppet code
    for the matching case, they return a value. Selectors can be used wherever a value
    is expected, such as variable assignment, resource attributes, and function arguments.
    The Puppet style guide recommends only using selectors in variable assignments
    to improve readability, but it may be seen in legacy code in resource attributes
    as it was previously a popular pattern.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器类似于`case`语句，但它们不会应用Puppet代码，而是返回一个值。选择器可以在期望值的任何地方使用，如变量赋值、资源属性和函数参数。Puppet风格指南建议仅在变量赋值中使用选择器以提高可读性，但在遗留代码中，它也可以在资源属性中看到，因为它曾是一个流行的模式。
- en: The syntax of a selector is a control expression resolving to a value, a question
    mark (`?`), and an opening curly brace (`{`). It then has a number of case matches,
    starting with a single case or the `default` keyword, a hash rocket (`=>`), the
    value to return, and a closing comma. The selector is then closed with a closing
    curly brace (`}`).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 选择器的语法是一个控制表达式，解析为一个值，一个问号（`?`）和一个左花括号（`{`）。然后它有多个匹配案例，从一个单独的案例或`default`关键字开始，后跟一个哈希火箭符号（`=>`），返回的值，最后是一个闭合的逗号。选择器以一个右花括号（`}`）闭合。
- en: 'The following example shows the `apache_package_name` variable assigned based
    on the output of the `os.family` fact, using the `httpd` name for Red Hat, `apache2`
    for Debian or Ubuntu, `apache-httpd` for Windows, and defaulting to `httpd` if
    there is no match. A package resource could then use this name to install the
    relevant package:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如何根据`os.family`事实的输出分配`apache_package_name`变量，使用`httpd`作为Red Hat的名称，`apache2`用于Debian或Ubuntu，`apache-httpd`用于Windows，如果没有匹配，则默认为`httpd`。然后，包资源可以使用这个名称来安装相关包：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As with the `case` statement, the Puppet style guide recommends that selectors
    always use a `default` case, which can be a failure or even just an empty curly
    brace.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 和`case`语句一样，Puppet风格指南建议选择器始终使用`default`案例，这可以是一个失败，甚至只是一个空的花括号。
- en: Capture variables
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捕获变量
- en: If the `case` statement used was a regular expression, then what is known as
    capture variables will be available within the associated code as number variables
    such as `$1` and `$2`, with the entire match available at `$0`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 如果使用的`case`语句是正则表达式，则所称的捕获变量将在相关代码中作为数字变量（如`$1`和`$2`）可用，整个匹配项则可通过`$0`访问。
- en: 'To modify the example in the *Case statement* section, if the match was against
    `amd64`, this would include `profile::linux::amd64`:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要修改*Case语句*部分中的示例，如果匹配的是`amd64`，这将包括`profile::linux::amd64`：
- en: '[PRE35]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Having reviewed all aspects of templates, conditionals, iterations, and loops,
    we will now use a lab to recap and bring these concepts together.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在回顾了模板、条件语句、迭代和循环的各个方面后，我们将通过一个实验来总结并结合这些概念。
- en: Lab – creating and testing templates containing loops and conditions
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实验 – 创建并测试包含循环和条件的模板
- en: 'In this lab, we will bring together everything you have seen in this chapter
    so far, testing and validating some example templates and creating a template
    using logic and iteration:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实验中，我们将把你在本章中看到的所有内容结合起来，测试和验证一些示例模板，并创建一个包含逻辑和迭代的模板：
- en: 'Download the template files at [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch07/templates_to_check](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch07/templates_to_check)
    and validate and parse each of them to ensure the templates produce the following
    (`<>` shows where interpolation needs to happen):'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在[https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch07/templates_to_check](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch07/templates_to_check)下载模板文件，并验证和解析它们以确保模板生成以下内容（`<>`显示需要插值的部分）：
- en: '**“This template was run on a machine with <# number of cpus of your** **machine>
    cpus”**'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**“此模板在具有<#你机器的cpu数量>个cpu的机器上运行”**'
- en: '**“The custom fact pack.lab was < set to content of fact or the string ‘not
    set’ > “**'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**“自定义事实包.lab已被<设置为事实的内容或字符串‘未设置’>”**'
- en: Hint
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: You would want to use the `getvar` function to test the fact and test it by
    passing in a hash, setting it when parsing to test it.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 你会想使用`getvar`函数来测试事实，并通过传入哈希来测试它，在解析时设置它以进行测试。
- en: '**“The system uptime is < showing only days hours mins if they are non zero
    > “**'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**“系统运行时间是<仅显示天、小时和分钟，如果它们非零>”**'
- en: '**“This machine is <not/is> virtual <and runs** **on <$virtual>”**'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**“此机器是<不是/是>虚拟的<并且运行在<$virtual>上”**'
- en: Create a template that prints the following
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个模板，打印以下内容
- en: '**“This is a < os family > machine running version < os release full > ““The
    following directories are in the path** **< list each** **path >”**'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**“这是一个<os family>机器，运行版本<os release full>”** **“以下目录在路径中<列出每个路径>”**'
- en: Hint
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'Use the `split` function ([https://www.puppet.com/docs/puppet/latest/function.html#split](https://www.puppet.com/docs/puppet/latest/function.html#split))
    to separate the path fact string into an array that can be iterated, and remember
    that Windows paths are split by ; while Unix/Linux based paths are split by :
    . See the answer at [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch07/2_sample.epp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch07/2_sample.epp).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `split` 函数 ([https://www.puppet.com/docs/puppet/latest/function.html#split](https://www.puppet.com/docs/puppet/latest/function.html#split))
    将路径事实字符串分割成可以迭代的数组，并记住，Windows 路径是通过 `;` 分隔，而基于 Unix/Linux 的路径则通过 `:` 分隔。参见 [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch07/2_sample.epp](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch07/2_sample.epp)
    中的答案。
- en: Summary
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, the use of templates in Puppet was examined. It showed Puppet’s
    two types of templates – EPP and ERB – which worked in similar ways, using a mix
    of plain text and tags surrounding code to allow for Puppet/Ruby to apply logic
    and variables and create more complex content when evaluated. It was warned that
    the level of complexity should be carefully considered before using templates
    instead of functions such as `file_line`, and controlling resources individually.
    Additionally, because of the lack of functions for a single line or setting control
    in files, templates had been overused, and heritage code should be examined carefully
    to ensure that a template was the correct level of complexity.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 本章审视了在 Puppet 中使用模板。展示了 Puppet 的两种模板类型——EPP 和 ERB——它们以类似的方式工作，通过将纯文本和代码周围的标签混合，允许
    Puppet/Ruby 应用逻辑和变量，并在评估时创建更复杂的内容。文中警告，在使用模板代替诸如 `file_line` 等函数或单独控制资源之前，应仔细考虑复杂性的层级。此外，由于缺乏用于单行或文件设置控制的函数，模板已被过度使用，遗留代码应仔细审查，以确保模板是正确的复杂性级别。
- en: EPP was shown to be the recommended way of producing templates since it was
    in the Puppet language and easier to learn for a Puppet developer. It was also
    more secure since it could limit its scope with parameters, and similarly, more
    performant since it only created a scope for the variables and facts required,
    unlike ERB, which, for every template used, would generate a scope for all facts.
    Furthermore, it was mentioned that all Puppet future development work would be
    for EPP, as was shown by the inclusion of automatic unwrapping of sensitive variables
    in EPP files, and the capability of rendering a template was only available in
    EPP.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 显示了 EPP 是推荐的模板生成方式，因为它是用 Puppet 语言编写的，且对 Puppet 开发者来说更容易学习。它也更安全，因为可以通过参数限制其作用域，并且由于它仅为所需的变量和事实创建作用域，因此性能也更好；而
    ERB 每次使用模板时，都会为所有事实生成一个作用域。此外，还提到所有 Puppet 的未来开发工作都将集中在 EPP 上，例如 EPP 文件中自动解包敏感变量的功能，且渲染模板的能力仅在
    EPP 中可用。
- en: EPP and ERB templates were shown to be referenced and evaluated from files via
    the `epp` and `template` functions, where multiple files could be combined together.
    It was also shown that inline templates were possible via the `inline-template`
    or `inline-epp` functions, where the text could be passed directly to the function
    instead of being stored in a file.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`epp` 和 `template` 函数显示可以通过文件引用和评估模板，其中多个文件可以组合在一起。同时也展示了通过 `inline-template`
    或 `inline-epp` 函数可以实现内联模板，这样文本可以直接传递给函数，而不需要存储在文件中。'
- en: Iteration and loops were then shown, highlighting Puppet’s previous lack of
    capability to do this with the immutable nature of Puppet variables making more
    traditional `loop` keywords impractical. Puppet was shown to instead use iterative
    functions on arrays and hashes, which passed values as parameters to lambda functions.
    These unnamed lambda functions, which could only be called by other functions,
    allow the creation of a scope entirely local to the lambda function and, therefore,
    allow variable names to be reused. The iterative function chooses how values should
    be passed to the lambda, such as each passing one value or key pair at a time,
    or `Reduce`, which allows the use of a parameter that is passed through each lambda
    function along with each value and key pair and can be useful to do cumulative
    transformations.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 然后展示了迭代和循环，强调了 Puppet 之前由于 Puppet 变量的不可变性，使得更传统的`loop`关键字变得不切实际。相反，Puppet 被展示为使用对数组和哈希的迭代函数，将值作为参数传递给
    lambda 函数。这些没有命名的 lambda 函数只能通过其他函数调用，允许创建完全局部于 lambda 函数的作用域，因此允许变量名被重用。迭代函数选择如何将值传递给
    lambda，例如每次传递一个值或键值对，或者使用`Reduce`，它允许在每个 lambda 函数中传递一个参数，连同每个值和键值对一起传递，并且可以用于执行累积转换。
- en: Puppet’s conditional logic was then discussed, showing it to be similar to most
    other languages. `if` checks evaluate a check to a Boolean statement/comparison,
    which if `true`, is acted on with Puppet code. The `else` keyword allows an action
    to take place if the Boolean was `false`, and the `elsif` keyword allows the chaining
    of checks together. `unless` was shown to be the inverse of `if`, acting on the
    check if it was negative and allowing `else` to act if it was `true`, although
    it had no equivalent of `elsif`.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后讨论了 Puppet 的条件逻辑，显示其与大多数其他语言相似。`if` 检查会将检查评估为布尔值语句/比较，如果为`true`，则使用 Puppet
    代码进行操作。`else` 关键字允许在布尔值为`false`时执行某个操作，`elsif` 关键字允许将多个检查链式连接在一起。`unless` 被显示为
    `if` 的反义操作，当检查为负时进行操作，并允许 `else` 在检查为 `true` 时执行，尽管它没有 `elsif` 的等价项。
- en: The `case` keyword was then discussed. We showed that it works by taking the
    value and matching it to run Puppet code based on the match or to a default if
    no value was found. The `selector` keyword was shown to be similar to the behavior
    of the `case` statement but is used instead of running Puppet code to assign a
    value. It was highlighted that, despite it being a common pattern in the past
    to use a selector within resources, this was no longer considered best practice.
    Finally, capture variables were shown as variables available to conditionals that
    had used regular expressions to show what the match had been.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然后讨论了 `case` 关键字。我们展示了它是通过获取值并将其与某个匹配项进行匹配，基于匹配结果运行 Puppet 代码，或者如果没有找到匹配值，则执行默认操作。`selector`
    关键字的行为类似于 `case` 语句，但它用于分配一个值，而不是运行 Puppet 代码。需要强调的是，尽管过去在资源中使用选择器是一个常见模式，但这已不再被认为是最佳实践。最后，捕获变量作为可用于条件语句的变量被展示，它们通过正则表达式显示匹配结果。
- en: Having now reviewed the core Puppet language, it is time to learn how to structure
    the manifest file and classes we have used so far. The next chapter will demonstrate
    how modules provide the necessary structure to hold the manifests, classes, and
    other configuration and implementation files that we have examined. The roles
    and profiles pattern will also be explored, providing an additional abstraction
    to represent the technology stacks and business needs of customers. Moreover,
    Puppet Forge will be demonstrated as a source of modules that can be consumed
    to reduce the need for development and to collaborate with the Puppet community
    to enhance the available code.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经回顾了 Puppet 核心语言，是时候学习如何构建我们迄今为止使用的 manifest 文件和类了。下一章将展示模块如何提供必要的结构来容纳我们所研究的
    manifest、类以及其他配置和实现文件。还将探讨角色和配置文件模式，它提供了一种额外的抽象，用于表示客户的技术堆栈和业务需求。此外，将演示 Puppet
    Forge 作为一个模块来源，可以通过它减少开发需求，并与 Puppet 社区协作以增强现有代码。
