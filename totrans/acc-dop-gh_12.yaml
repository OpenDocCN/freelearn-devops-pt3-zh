- en: '*Chapter 10*: Feature Flags and the Feature Lifecycle'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第10章*：功能标志与功能生命周期'
- en: '**Feature Flags** are one of the most game-changing capabilities I''ve seen
    over the years when working with teams. They have many different use cases. They
    can help you to reduce complexity in your development workflow by merging code
    early, or they can help you to perform zero-downtime deployments. Feature Flags
    help you to get more value out of your features by managing the entire feature
    lifecycle.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**功能标志（Feature Flags）**是我在多年与团队合作过程中见过的最具变革性的功能之一。它们有许多不同的用例。功能标志可以帮助你通过提前合并代码来减少开发工作流中的复杂性，或者帮助你执行零停机时间部署。功能标志帮助你通过管理整个功能生命周期来从功能中获得更多的价值。'
- en: In this chapter, I will explain what Feature Flags – also known as **Feature
    Toggles** – are and what you can do with them. Unfortunately, there is no native
    solution in GitHub to help with Feature Flags. There are too many frameworks and
    services available that you could use to introduce them all. But I will give you
    some guidance on how to pick the best tools for your use case.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将解释什么是功能标志——也称为**功能切换（Feature Toggles）**——以及你可以用它们做什么。不幸的是，GitHub本身没有原生的解决方案来支持功能标志。市面上有许多框架和服务可以用来实现功能标志，但我会为你提供一些选择最佳工具的建议，帮助你根据用例来选择。
- en: 'The main topics of this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要内容如下：
- en: What are Feature Flags?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是功能标志（Feature Flags）？
- en: The lifecycle of features
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能的生命周期
- en: The benefits of Feature Flags
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能标志的优势
- en: Getting started with Feature Flags
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 入门功能标志
- en: Feature Flags and technical debt
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能标志与技术债务
- en: Experimentation with Feature Flags
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用功能标志进行实验
- en: What are Feature Flags?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是功能标志（Feature Flags）？
- en: '**Feature Flags** are a technique in software development that allows modifying
    runtime behavior without changing code. It decouples the release of functionality
    to the end users from the rollout of the binaries.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**功能标志（Feature Flags）**是一种软件开发技术，允许在不更改代码的情况下修改运行时行为。它将功能发布与二进制文件的部署解耦，使得功能可以独立于代码更新进行发布。'
- en: Feature Flags work like a switch or toggle and are, therefore, often called
    **Feature Toggles** or **Feature Switches** because of their Boolean nature. But
    Feature Flags can have many different use cases and can be more complex than a
    toggle. That's why the term *Feature Flag* is more suitable.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 功能标志像开关或切换一样工作，因此通常被称为**功能切换（Feature Toggles）**或**功能开关（Feature Switches）**，因为它们具有布尔性质。但功能标志有许多不同的用例，可能比简单的切换要复杂。因此，*功能标志（Feature
    Flag）*这一术语更为合适。
- en: 'Feature Flags allow you to encapsulate new code behind a Feature Flag and roll
    it out to the production system. The feature can then be enabled based on the
    context for a given target audience only (see *Figure 10.1*):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 功能标志允许你将新代码封装在一个功能标志后面，并将其推广到生产系统。然后，可以根据特定目标受众的上下文来启用该功能（见*图 10.1*）：
- en: '![Figure 10.1 – How Feature Flags work'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.1 – 功能标志的工作原理'
- en: '](img/B17827_10_001.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_10_001.jpg)'
- en: Figure 10.1 – How Feature Flags work
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 功能标志的工作原理
- en: 'Feature Flags are a very natural technique for developers if you have continuous
    delivery available and a separate team that is responsible for the infrastructure.
    It''s easier for developers to add a flag to the code than to change infrastructure,
    so you often end up with flags that allow testers to do different things than
    normal users or with some that allow some beta users to test some stuff. The problem
    is that if you are not explicit about Feature Flags, the configuration will normally
    end up in different places: config files, group memberships, and the application
    database. Being explicit about flags helps to improve the transparency in the
    team and ensures a uniform approach, and it enables more advanced use cases and
    ensures security and scalability.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 功能标志对于开发者来说是一种非常自然的技术，特别是如果你有持续交付功能，并且有一个独立的团队负责基础设施的话。对于开发者而言，向代码中添加标志比更改基础设施要容易得多，因此你通常会看到功能标志被用来让测试人员执行不同于普通用户的操作，或者让一些beta用户测试某些功能。问题在于，如果你没有明确规定功能标志，配置通常会分散在不同的地方：配置文件、组成员资格和应用程序数据库中。明确功能标志有助于提高团队透明度，确保统一的处理方式，同时支持更复杂的用例，确保安全性和可扩展性。
- en: The lifecycle of features
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能的生命周期
- en: Until a few years ago, most software was released every 1 or 2 years in major
    versions that had to be purchased separately or at least were coupled tightly
    to licensing through subscriptions. All the new features were squeezed into these
    new release versions. The new releases normally came with pieces of training,
    books, and online courses to teach the users the new features.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 直到几年前，大多数软件每1到2年发布一次重大版本，这些版本通常需要单独购买，或者至少与订阅的许可证紧密捆绑。所有的新功能都会被挤进这些新版本中。新版本通常伴随着培训材料、书籍和在线课程，以教授用户使用新功能。
- en: These sales models basically do not exist anymore today. Customers want their
    software as a service. No matter if we talk about mobile apps such as Facebook
    or WhatsApp, or desktop software such as Office or Windows, software is updated
    and optimized continuously, and new features are added constantly. This brings
    the challenge of educating your end users on how to use the new features properly.
    An intuitive user experience and easy discoverability of new features are more
    important than they were with the old sales model. Features must be self-explanatory,
    and a simple on-screen dialog must be sufficient to educate users on how to use
    the new feature.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这些销售模式今天几乎已经不存在了。客户希望将软件作为服务使用。无论是像 Facebook 或 WhatsApp 这样的移动应用，还是像 Office 或
    Windows 这样的桌面软件，软件都在持续更新和优化，并不断增加新功能。这带来了一个挑战：如何教育最终用户正确使用新功能。直观的用户体验和易于发现的新功能比旧的销售模式下更为重要。功能必须是自我解释的，屏幕上的简单对话框应该足以教导用户如何使用新功能。
- en: Also, value creation is completely different. Customers do not make their buy
    decision every few years. They decide every day if they use the software for a
    task at hand or not. So, instead of putting a ton of new features into a new version
    to influence buy decisions, the focus is on delivering fewer features with a high
    value by removing features that are not used or optimizing them until they are
    of high value.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，价值创造完全不同。客户不再每几年才做一次购买决定。他们每天都在决定是否使用软件来完成手头的任务。因此，重点不再是通过将大量新功能挤进新版本来影响购买决策，而是通过去除不使用的功能或优化它们直到具有高价值，从而提供少而精的高价值功能。
- en: 'This means every feature is subject to a lifecycle. The lifecycle of a feature
    could look like the one in *Figure 10.2*:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每个功能都需要经历一个生命周期。功能的生命周期可能类似于*图 10.2*所示：
- en: '![Figure 10.2 – The lifecycle of features'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.2 – 特性生命周期'
- en: '](img/B17827_10_002.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_10_002.jpg)'
- en: Figure 10.2 – The lifecycle of features
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.2 – 特性生命周期
- en: 'The lifecycle is subject to the following phases:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 生命周期包括以下几个阶段：
- en: '**Ideation and development**: After the idea for a new feature, the implementation
    starts with a few internal users. The feedback of these users is used to improve
    the feature.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构思与开发**：新功能的构思之后，实施会从少数内部用户开始。利用这些用户的反馈来改进功能。'
- en: '**Alpha or beta**: In the alpha and/or beta phase, the feature is provisioned
    to a broader, but still very limited, audience. The audience can be internal or
    selected external customers. The alpha or beta phase can be closed (private) or
    open (public), but the feature in this phase is still very dynamic and can change
    dramatically.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Alpha 或 beta**：在 Alpha 和/或 Beta 阶段，该功能提供给更广泛但仍然非常有限的用户群体。这个用户群体可以是内部用户或选定的外部客户。Alpha
    或 Beta 阶段可以是封闭（私密的）或开放（公开的），但该阶段的功能仍然非常动态，可能会发生显著变化。'
- en: '**Adoption**: If the feature is mature enough for the market, it is gradually
    exposed to a broader audience. The adoption phase can be divided into the following
    sub-phases:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**采纳**：如果该功能足够成熟以进入市场，它将逐渐暴露给更广泛的用户群体。采纳阶段可以分为以下几个子阶段：'
- en: '**Preview**: The users can **opt in** and enable the preview feature.'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**预览版**：用户可以**选择加入**并启用预览功能。'
- en: '**Default for new users**: The feature is the default for new users – but users
    could still **opt out** if they don''t want to use it.'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**新用户默认设置**：该功能是新用户的默认设置，但用户仍然可以**选择退出**，如果他们不想使用该功能。'
- en: '**Default for all users**: The feature is enabled for all users, but users
    can still opt out.'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**所有用户默认设置**：该功能对所有用户启用，但用户仍然可以选择退出。'
- en: '**Normal operation**: The feature is used by all users and an opt-out is not
    possible anymore. Previous versions of the feature get removed from the system.
    The normal operation can go on for many years.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正常运行**：该功能被所有用户使用，且不再允许选择退出。功能的旧版本会从系统中移除。正常运行阶段可能会持续多年。'
- en: '**Sundown**: The feature is replaced by a newer and hopefully better feature.
    The number of users that use this feature declines and the cost of maintaining
    the feature exceeds its value. The feature is removed from the system when all
    users can be redirected to a new feature.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日落**：该特性被一个更新的、更有可能更好的特性所取代。使用该特性的用户数量逐渐下降，维护该特性的成本超过其价值。当所有用户都能转向新特性时，该特性会从系统中移除。'
- en: Note that the value of the feature is the biggest in the early adoption phase
    as it attracts new users to your application. In the normal operations phase,
    the hype has probably flattened, and the competition has also learned from your
    feature and reacted by adjusting their software.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，特性的价值在早期采用阶段最大，因为它吸引了新的用户到你的应用程序中。在正常操作阶段，热度可能已经平稳，竞争对手也从你的特性中学到了东西，并通过调整他们的软件做出了回应。
- en: The benefits of Feature Flags
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特性标志的好处
- en: 'Managing the lifecycle of a feature without using Feature Flags is impossible,
    but there are many other use cases where Feature Flags can bring value to your
    DevOps teams:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在没有使用特性标志的情况下，无法管理特性的生命周期，但还有许多其他的用例，特性标志可以为你的 DevOps 团队带来价值：
- en: '**Release flags**: These are used to roll out code behind a flag. Release flags
    normally stay in the code until the feature is rolled out completely. This can
    be weeks or months. Release flags change with each deployment or with the system''s
    configuration. This means they can be implemented very easily by just reading
    a configuration value. But if you want to use release flags for **canary releases**
    (gradually exposing the feature to more and more users) or **blue-green deployments**
    (swapping staging and production environments), they are much more dynamic.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布标志**：这些标志用于在标志后推出代码。发布标志通常会一直存在于代码中，直到特性完全推出。这可能是几周或几个月。发布标志会随着每次部署或系统配置的变化而变化。这意味着它们可以通过读取配置值轻松实现。但是，如果你想使用发布标志进行**金丝雀发布**（逐渐向更多用户曝光特性）或**蓝绿部署**（交换暂存和生产环境），它们会更具动态性。'
- en: '**Experimentation flags**: If you roll out multiple versions of the same feature
    and expose it to different audiences, it is called **A/B testing** or **experimentation**.
    It is normally used to confirm or diminish a hypothesis by measuring certain metrics
    of how users interact with the version of the feature. Experimentation flags are
    highly dynamic and rely on a lot of contexts to use them to address different
    target audiences.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实验标志**：如果你推出多个版本的相同特性，并将其暴露给不同的受众，这就叫做**A/B 测试**或**实验**。通常用于通过测量用户与特性版本的交互情况来确认或减弱一个假设。实验标志是高度动态的，并依赖于大量的上下文来使用它们以应对不同的目标受众。'
- en: '**Permission flags**: A common use case of Feature Flags is to control what
    users can access. This can be *administration features* or *testing features*
    that are only exposed to certain audiences, or *premium features* that are only
    exposed to paying customers. Permission flags are highly dynamic and normally
    stay in the code for a long time – sometimes until the end of the application
    lifecycle. They also expose a high risk of fraud and must, therefore, be used
    carefully.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**权限标志**：特性标志的一个常见用例是控制用户可以访问的内容。这可以是*管理功能*或*测试功能*，仅暴露给特定受众，或*高级功能*，仅暴露给付费客户。权限标志是高度动态的，通常会在代码中存在很长时间——有时直到应用程序生命周期的结束。它们还存在较高的欺诈风险，因此必须谨慎使用。'
- en: '**Operation flags**: Some flags are used for operational aspects of the application
    – for example, *kill switches* used to disable certain functionality that can
    be a bottleneck for other features (also known as a *circuit breaker*). A flag
    to control different versions of a backend system is also considered an operation
    flag. Multi-variant flags are often used to control logging verbosity or other
    operational aspects.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作标志**：有些标志用于应用程序的操作方面——例如，*杀死开关*用于禁用某些可能成为其他特性瓶颈的功能（也叫做*断路器*）。用于控制后端系统不同版本的标志也被认为是操作标志。多变体标志通常用于控制日志详细信息或其他操作方面。'
- en: '*Figure 10.3* shows an overview of the different types of Feature Flags categorized
    by dynamic and the time they stay in the system:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 10.3* 展示了按动态性和在系统中存在的时间对不同类型的特性标志的概览：'
- en: '![Figure 10.3 – Types of Feature Flags'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.3 – 特性标志类型'
- en: '](img/B17827_10_003.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_10_003.jpg)'
- en: Figure 10.3 – Types of Feature Flags
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – 特性标志类型
- en: Now that we have learned what Feature Flags are and what you can do with them,
    I will show you how you can implement them in code.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了什么是功能标志以及您可以如何使用它们，我将向您展示如何在代码中实现它们。
- en: Getting started with Feature Flags
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用功能标志
- en: 'In code, a Feature Flag is nothing more than an `if` statement. Let''s assume
    you have a current implementation of the dialog to register new users:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，功能标志只是一个`if`语句。假设您已经有了一个用于注册新用户对话框的当前实现：
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, you want to create a new dialog using a Feature Flag and be able to switch
    on the new dialog at runtime:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您希望使用功能标志创建一个新的对话框，并能够在运行时打开新的对话框：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To enable or disable the feature dynamically, you have to extract the validation
    of the Feature Flag into its own function:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要动态启用或禁用功能，您必须将功能标志的验证提取到其自己的函数中：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There are many options where you can store the configuration of the Feature
    Flag:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多选项可以存储功能标志的配置：
- en: The system configuration
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统配置
- en: The user configuration
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户配置
- en: The application database
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序数据库
- en: A separate database
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单独的数据库
- en: A separate system (accessed through an API)
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单独的系统（通过API访问）
- en: It highly depends on your use case what locations work or don't work.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这高度依赖于您的用例，哪些位置适用或不适用。
- en: Feature Flags and technical debt
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能标志和技术债务
- en: If you start using Feature Flags, you normally end up with a highly configurable
    system that can change its behavior at runtime – normally by many flags that are
    scattered across multiple configuration sources. The flags tend to have dependencies
    between each other, so enabling or disabling flags exposes a great risk to the
    stability of the system. You managed to escape *merge hell* by avoiding parallel
    branches, but ended up in *feature flag hell*, with hundreds of flags that nobody
    knows what they are for.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您开始使用功能标志，通常会得到一个高度可配置的系统，可以在运行时更改其行为 - 通常是通过分散在多个配置源中的许多标志。这些标志往往彼此之间存在依赖关系，因此启用或禁用标志会对系统的稳定性造成很大风险。您设法通过避免并行分支来避免*合并地狱*，但最终却陷入了*功能标志地狱*，数百个标志，没有人知道它们的用途。
- en: 'To avoid this, you should follow these best practices:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要避免这种情况，您应该遵循以下最佳实践：
- en: '**Metrics**: Even with all the value they provide, Feature Flags in your code
    are some kind of technical debt. You should measure them as you do code coverage
    or other code-related metrics. Measure the *number* of Feature Flags, how long
    they exist (*duration*), how they evaluate in each environment (*value*, 100%
    true in production probably means the flag can be removed), and how often the
    flags are used (*calls*).'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**度量**：即使它们提供了所有的价值，功能标志在您的代码中也是某种技术债务。您应该像测量代码覆盖率或其他与代码相关的指标一样测量它们。测量功能标志的*数量*，它们存在的*时长*，它们在每个环境中的评估情况（*值*，在生产中为100%可能意味着可以移除该标志），以及标志被使用的频率（*调用*）。'
- en: '**Central management**: Manage your flags in one central place, especially
    if you use different methods to manage the flags. Each flag should have an *owner*
    and a *description*. Document the *dependencies* between Feature Flags.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集中管理**：在一个中心位置管理您的标志，特别是如果您使用不同的方法来管理这些标志。每个标志应该有一个*所有者*和一个*描述*。记录功能标志之间的*依赖关系*。'
- en: '**Integration into your process**: Integrate the management of Feature Flags
    into your process. For example, if you use Scrum, you can integrate the review
    of the Feature Flags in the *review* meeting. Make sure that all the people who
    work with the flags regularly go through all the flags and check which ones can
    be removed from the system.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成到您的流程中**：将功能标志的管理集成到您的流程中。例如，如果您使用Scrum，可以在*评审*会议中审查功能标志。确保所有定期使用标志的人都仔细查看所有标志，并检查哪些标志可以从系统中移除。'
- en: '`tmp-` as a prefix for temporary flags and `perm-` for permanent ones. Don''t
    make it too complicated, but the name of the flag should immediately indicate
    what kind of flag it is and how long it is supposed to stick around in the code
    base.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为临时标志的前缀`tmp-`和作为永久标志的前缀`perm-`。不要把它弄得太复杂，但标志的名称应立即表明它是何种类型的标志，以及它在代码库中应该存在多长时间。
- en: A technique that some teams like and others do not is **cleaning up branches**.
    You can see if this technique works for you. The idea is that the moment you create
    the flag and write the code, you know best how the code should look if the flag
    is removed one day. So, you create a cleanup branch and pull request alongside
    the code and leave the pull request open until the flag is removed. The technique
    works best with good naming conventions.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一些团队喜欢，而另一些团队不喜欢的技术是**清理分支**。你可以看看这种技术是否适合你。其思路是，在你创建标志并编写代码的那一刻，你最清楚如果标志有一天被移除，代码应该是什么样子。因此，你可以创建一个清理分支并同时创建拉取请求，直到标志被移除为止。这个技术在有良好命名规范的情况下效果最好。
- en: 'Take the preceding example; you have a flag for a new feature dialog. The code
    with the flag looks like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以之前的示例为例，你有一个用于新特性对话框的标志。带有标志的代码如下所示：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The code is developed in a `features/new-register-dialog` branch and you create
    the pull request to merge the code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 代码是在`features/new-register-dialog`分支中开发的，你创建了一个拉取请求来合并代码。
- en: 'You already know that the final state of the code, when the flag is removed,
    will only use the new dialog, so you create a new branch (for example, `cleanup/new-register-dialog`)
    and add the final version of the code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道，当标志被移除后，代码的最终状态将只使用新对话框，因此你创建了一个新的分支（例如，`cleanup/new-register-dialog`）并添加了代码的最终版本：
- en: '[PRE31]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You can then create a pull request and leave it open until the feature is rolled
    out completely and you want to clean up the code.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以创建一个拉取请求，并保持其打开，直到特性完全推出，你希望清理代码。
- en: As I said, this technique is not well suited for all teams. Maintaining the
    cleanup branches can be a lot of work in a complex environment, but you can give
    it a try.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我所说，这种技术并不适合所有团队。在复杂环境中，维护清理分支可能是一项繁重的工作，但你可以尝试一下。
- en: Feature Flags that do not get cleaned up and are not actively maintained are
    technical debt, but the advantages outweigh the disadvantages. If you are careful
    from the beginning, you can avoid the feature flag hell and only benefit from
    the flexible power they provide you when releasing and operating your application.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如果特性标志没有被清理，并且没有得到积极维护，那它就是技术债务，但其优点大于缺点。如果你从一开始就小心谨慎，你可以避免进入特性标志的地狱，并且在发布和操作你的应用程序时，只会受益于它们提供的灵活性。
- en: Frameworks and products
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 框架和产品
- en: 'There are many frameworks available that you can leverage when implementing
    Feature Flags. The framework that is the best for you depends a lot on your programming
    languages and use cases. Some focus more on UI integration, some more on rollout
    and operations. When picking your framework, you should consider the following
    aspects:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现特性标志时，有许多可供利用的框架。最适合你的框架在很大程度上取决于你的编程语言和使用案例。有些框架更专注于UI集成，有些则更专注于发布和操作。在选择框架时，你应该考虑以下方面：
- en: '**Performance**: Feature Flags must be fast and must not reduce the performance
    of your application. Proper caching should be used and also default values that
    are used if the data store cannot be reached on time.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：特性标志必须快速，不能降低应用程序的性能。应该使用适当的缓存，并且如果数据存储无法及时访问，也应使用默认值。'
- en: '**Supported programming languages**: Your solution should work with all your
    languages, especially when you use client-side flags; you must also evaluate them
    on the server for security reasons. You don''t want to configure the flags in
    different locations.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持的编程语言**：你的解决方案应该适用于所有的编程语言，特别是当你使用客户端标志时；你还必须在服务器端评估它们以确保安全。你不想在不同的地方配置标志。'
- en: '**UI integration**: If you want to provide the users with the ability to opt
    in or out of features, you want a good integration into your UI. Normally, you
    need two flags for that: one to control the visibility, and one to enable or disable
    the feature.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UI集成**：如果你想让用户能够选择是否启用某个功能，那么你需要一个良好的UI集成。通常，你需要两个标志：一个控制可见性，另一个启用或禁用功能。'
- en: '**Context**: When you want to use Feature Flags for A/B testing and experimentation,
    you need a lot of context information to evaluate the flags: the user, group memberships,
    the region, and the server, for example. This is where many frameworks fail.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上下文**：当你想使用特性标志进行A/B测试和实验时，你需要大量的上下文信息来评估标志：例如用户、组成员资格、地区和服务器。这是许多框架的弱点所在。'
- en: '**Central management**: Flags that you configure for each environment separately,
    for example, are impossible to maintain. You need one central management platform
    where you can control all the flags in one place.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中央管理**：例如，为每个环境分别配置的标志是无法维护的。你需要一个中央管理平台，在一个地方控制所有的标志。'
- en: '**Data store**: Some frameworks store the configuration in your application
    database. This is problematic for many scenarios. Normally, you have a different
    database in all your environments, so managing the settings across the environments
    is difficult.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据存储**：一些框架将配置存储在你的应用数据库中。这在许多场景下是有问题的。通常，你在所有环境中都有不同的数据库，因此在各个环境中管理设置是困难的。'
- en: 'Building a scalable, performant, and mature solution takes a lot of time and
    effort, even when using frameworks, but there are also products available that
    you can install or consume as a service. A product that has been around for many
    years and is established mature is **LaunchDarkly** ([https://launchdarkly.com/](https://launchdarkly.com/)).
    There is a lot of competition now, including the following:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个可扩展、高性能且成熟的解决方案需要大量的时间和精力，即使是使用框架时也是如此，但也有一些现成的产品可以安装或作为服务使用。一个存在多年的、成熟的产品是**LaunchDarkly**
    ([https://launchdarkly.com/](https://launchdarkly.com/))。现在有很多竞争者，包括以下几种：
- en: '**Switchover** ([https://switchover.io/](https://switchover.io/))'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Switchover** ([https://switchover.io/](https://switchover.io/))'
- en: '**VWO** ([https://vwo.com/](https://vwo.com/))'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VWO** ([https://vwo.com/](https://vwo.com/))'
- en: '**Split** ([https://www.split.io/](https://www.split.io/))'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Split** ([https://www.split.io/](https://www.split.io/))'
- en: '**Flagship** ([https://www.flagship.io/](https://www.flagship.io/))'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Flagship** ([https://www.flagship.io/](https://www.flagship.io/))'
- en: '**Azure App configuration** ([https://docs.microsoft.com/en-us/azure/azure-app-configuration/overview](https://docs.microsoft.com/en-us/azure/azure-app-configuration/overview))'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Azure 应用配置** ([https://docs.microsoft.com/en-us/azure/azure-app-configuration/overview](https://docs.microsoft.com/en-us/azure/azure-app-configuration/overview))'
- en: '**Unleash** (https://www.getunleash.io/) is also worth mentioning. It has an
    **open core** (https://github.com/Unleash/unleash) and can be self-hosted free
    of charge as a Docker container. Unleash is also the solution that is used by
    GitLab.'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '**Unleash** ([https://www.getunleash.io/](https://www.getunleash.io/)) 也值得一提。它有一个**开放核心**
    ([https://github.com/Unleash/unleash](https://github.com/Unleash/unleash))，可以作为
    Docker 容器免费自托管。Unleash 也是 GitLab 使用的解决方案。'
- en: I could not find a good resource that compares the solutions, so I added a page
    on GitHub ([https://wulfland.github.io/FeatureFlags/](https://wulfland.github.io/FeatureFlags/))
    that provides an independent comparison of the solutions.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我找不到一个好的资源来比较这些解决方案，所以我在 GitHub 上添加了一个页面 ([https://wulfland.github.io/FeatureFlags/](https://wulfland.github.io/FeatureFlags/))，提供了解决方案的独立比较。
- en: When it comes to the make-or-buy decision, most companies are better off using
    an existing service or product. Building and running a good solution for Feature
    Flags is difficult and time-consuming, especially if you are new to Feature Flags.
    Start with a good product. If, after some time, you still find it necessary to
    build your own solution, at least you have experience knowing what a solution
    should be able to do.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在做决策时，关于自建与购买的选择，大多数公司更适合使用现有的服务或产品。构建和运行一个优秀的功能标志解决方案是困难且耗时的，特别是如果你对功能标志还不熟悉的话。从一个好的产品开始。如果经过一段时间后，你仍然觉得有必要自己构建解决方案，至少你已经有了了解一个解决方案应具备功能的经验。
- en: Experimentation with Feature Flags
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用功能标志进行实验
- en: Experimentation and A/B testing cannot only be done using Feature Flags. You
    can also develop containers in different branches and use Kubernetes to run different
    versions in production; however, this will increase your complexity in Git and
    does not scale well. You don't have the context for the users either, so gathering
    the data to prove or diminish your hypothesis is much harder. Most of the solutions
    for Feature Flags have built-in support for experiments, so this is the fastest
    way to get started.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 实验和 A/B 测试不仅可以通过功能标志进行。你也可以在不同的分支中开发容器，并使用 Kubernetes 在生产环境中运行不同版本；然而，这会增加你在
    Git 中的复杂性，并且不易扩展。你也无法获得用户的上下文，因此收集数据来验证或削弱你的假设会更加困难。大多数功能标志的解决方案都内置了实验支持，所以这是最快的入门方式。
- en: 'To experiment, you define a hypothesis, conduct an experiment, and then learn
    from the results. An experiment can be defined as follows (see *Figure 10.4*):'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行实验，你需要定义一个假设，进行实验，然后从结果中学习。一个实验可以这样定义（见*图 10.4*）：
- en: '**Hypothesis**: We believe *{customer segment}*, wants *{product/feature}*
    because *{value prop}*.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**假设**：我们相信*{客户群体}*，想要*{产品/功能}*，因为*{价值主张}*。'
- en: '**Experiment**: To prove or disprove the preceding, the team will conduct an
    experiment.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实验**：为了验证或反驳前述假设，团队将进行一次实验。'
- en: '**Learning**: The experiment will prove the hypothesis by impacting the following
    metrics.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**学习**：实验将通过影响以下指标来证明假设。'
- en: '![Figure 10.4 – Conducting experiments with Feature Flags'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.4 – 使用功能标志进行实验'
- en: '](img/B17827_10_004.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_10_004.jpg)'
- en: Figure 10.4 – Conducting experiments with Feature Flags
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – 使用功能标志进行实验
- en: Let's have a look at an example. By looking into the usage data of your application,
    you realize that the page views for the first page of the registration dialog
    for new users are much higher than the number of people that finish the registration
    process. Only about 20% of them finish the registration. The hypothesis is that
    the register dialog is too complex and that the number of people finishing the
    registration will increase dramatically when the dialog is simplified.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。通过查看你的应用程序的使用数据，你发现新用户注册对话框的第一页浏览量远高于完成注册流程的人数。只有大约 20% 的人完成注册。假设是注册对话框过于复杂，当对话框简化时，完成注册的人数将大幅增加。
- en: 'To conduct the experiment, you add two new metrics to your application: `started-registration`,
    which increases every time a user clicks on the `finished-registrations`, which
    increase after the user successfully registers for your application. The two metrics
    make it easy to calculate `aborted-registrations`. You gather the data during
    the next few weeks and confirm that the aborted registration rate has an average
    of 80% over these weeks. Your team creates a new, simple dialog using a `new-register-dialog`
    Feature Flag. It removes all required fields that are not necessary for the registration
    itself, such as address and payment information, and ships the code to production.
    The data is validated before checkout anyway, so the simplified registration works,
    even if this might be a usability problem for the checkout.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行实验，你在应用程序中添加了两个新指标：`started-registration`，每当用户点击时增加；`finished-registrations`，每当用户成功注册应用程序时增加。这两个指标使得计算`aborted-registrations`（注册中止）变得容易。你收集了接下来几周的数据，并确认在这些周里，中止注册的平均率为
    80%。你的团队使用`new-register-dialog`功能标志创建了一个新的、简化的对话框。它移除了所有不必要的字段，例如地址和支付信息，这些信息并不是注册本身所必需的，然后将代码部署到生产环境中。数据在结账前
    anyway 进行验证，因此即使这可能会成为结账过程中的一个可用性问题，简化后的注册仍然有效。
- en: In production, you turn on the flag for 50% of the new users and compare the
    `aborted-registrations` rate for the two groups. The users that see the old dialog
    stay as expected at around 70% to 80% aborted, whereas the users with the new
    dialog only have an aborted rate of 55%.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，你为 50% 的新用户启用功能标志，并比较两组的`aborted-registrations`（注册中止）率。看到旧对话框的用户的中止率保持在大约
    70% 到 80% 之间，而看到新对话框的用户的中止率仅为 55%。
- en: 'The result is still not perfect so you start adding new metrics to find out
    where in the dialog the people are struggling. This leads to the next hypothesis
    (see *Figure 10.5*):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 结果仍然不完美，所以你开始添加新的指标，以找出用户在对话框中的困难点。这引出了下一个假设（见*图 10.5*）：
- en: '![Figure 10.5 – Conducting experiments with Feature Flags'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.5 – 使用功能标志进行实验'
- en: '](img/B17827_10_005.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_10_005.jpg)'
- en: Figure 10.5 – Conducting experiments with Feature Flags
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – 使用功能标志进行实验
- en: To experiment with Feature Flags, you need data. Only with the right metrics
    and the ability to map the metrics to audiences that have certain flags on or
    off are you able to really perform evidence-based development.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用功能标志进行实验，你需要数据。只有具备正确的指标并能够将这些指标与开启或关闭特定标志的受众进行映射，你才能真正进行基于证据的开发。
- en: In *Chapter 19*, *Experimentation and A/B Testing with GitHub*, we will, unsurprisingly,
    have a closer look into experimentation and A/B testing with GitHub.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第 19 章*，*使用 GitHub 进行实验和 A/B 测试*中，我们将不出所料地深入探讨使用 GitHub 进行实验和 A/B 测试的内容。
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Feature Flags are one of the most important capabilities for the acceleration
    of DevOps teams. Unfortunately, GitHub does not have a built-in solution so far.
    But there are many products that can help you to get up to speed.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 功能标志是加速 DevOps 团队工作的重要功能之一。不幸的是，GitHub 目前还没有内建的解决方案。但有许多产品可以帮助你快速上手。
- en: In this chapter, you learned about the feature lifecycle and how you can manage
    it using Feature Flags. You also learned how you can leverage Feature Flags to
    reduce complexity by checking code early.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了功能生命周期以及如何使用功能标志（Feature Flags）来管理它。你还学会了如何利用功能标志通过提前检查代码来减少复杂性。
- en: In the next chapter, you'll learn about trunk-based development and the best
    Git workflow to support fast DevOps teams.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将了解基于主干的开发（trunk-based development）以及支持快速 DevOps 团队的最佳 Git 工作流。
- en: Further reading
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can get more information on the topics here:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里获取更多相关信息：
- en: 'Martin Fowler, *Feature-Toggles (aka Feature Flags)*, 2017: [https://martinfowler.com/articles/feature-toggles.html](https://martinfowler.com/articles/feature-toggles.html)'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Martin Fowler, *Feature-Toggles（即功能标志）*, 2017: [https://martinfowler.com/articles/feature-toggles.html](https://martinfowler.com/articles/feature-toggles.html)'
- en: 'Comparison of Feature Flag solutions: [https://wulfland.github.io/FeatureFlags/](https://wulfland.github.io/FeatureFlags/)'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '功能标志解决方案比较: [https://wulfland.github.io/FeatureFlags/](https://wulfland.github.io/FeatureFlags/)'
- en: 'LaunchDarkly: [https://launchdarkly.com/](https://launchdarkly.com/)'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'LaunchDarkly: [https://launchdarkly.com/](https://launchdarkly.com/)'
- en: 'Switchover: [https://switchover.io/](https://switchover.io/)'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Switchover: [https://switchover.io/](https://switchover.io/)'
- en: 'VWO: [https://vwo.com/](https://vwo.com/)'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'VWO: [https://vwo.com/](https://vwo.com/)'
- en: 'Split: [https://www.split.io/](https://www.split.io/)'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Split: [https://www.split.io/](https://www.split.io/)'
- en: 'Flagship: [https://www.flagship.io/](https://www.flagship.io/)'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Flagship: [https://www.flagship.io/](https://www.flagship.io/)'
- en: 'Unleash: [https://www.getunleash.io/](https://www.getunleash.io/) and [https://github.com/Unleash/unleash](https://github.com/Unleash/unleash)'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Unleash: [https://www.getunleash.io/](https://www.getunleash.io/) 和 [https://github.com/Unleash/unleash](https://github.com/Unleash/unleash)'
