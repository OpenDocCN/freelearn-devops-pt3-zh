- en: '*Chapter 10*: Feature Flags and the Feature Lifecycle'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Feature Flags** are one of the most game-changing capabilities I''ve seen
    over the years when working with teams. They have many different use cases. They
    can help you to reduce complexity in your development workflow by merging code
    early, or they can help you to perform zero-downtime deployments. Feature Flags
    help you to get more value out of your features by managing the entire feature
    lifecycle.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I will explain what Feature Flags – also known as **Feature
    Toggles** – are and what you can do with them. Unfortunately, there is no native
    solution in GitHub to help with Feature Flags. There are too many frameworks and
    services available that you could use to introduce them all. But I will give you
    some guidance on how to pick the best tools for your use case.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main topics of this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: What are Feature Flags?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The lifecycle of features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The benefits of Feature Flags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with Feature Flags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feature Flags and technical debt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experimentation with Feature Flags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are Feature Flags?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Feature Flags** are a technique in software development that allows modifying
    runtime behavior without changing code. It decouples the release of functionality
    to the end users from the rollout of the binaries.'
  prefs: []
  type: TYPE_NORMAL
- en: Feature Flags work like a switch or toggle and are, therefore, often called
    **Feature Toggles** or **Feature Switches** because of their Boolean nature. But
    Feature Flags can have many different use cases and can be more complex than a
    toggle. That's why the term *Feature Flag* is more suitable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Feature Flags allow you to encapsulate new code behind a Feature Flag and roll
    it out to the production system. The feature can then be enabled based on the
    context for a given target audience only (see *Figure 10.1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – How Feature Flags work'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_10_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.1 – How Feature Flags work
  prefs: []
  type: TYPE_NORMAL
- en: 'Feature Flags are a very natural technique for developers if you have continuous
    delivery available and a separate team that is responsible for the infrastructure.
    It''s easier for developers to add a flag to the code than to change infrastructure,
    so you often end up with flags that allow testers to do different things than
    normal users or with some that allow some beta users to test some stuff. The problem
    is that if you are not explicit about Feature Flags, the configuration will normally
    end up in different places: config files, group memberships, and the application
    database. Being explicit about flags helps to improve the transparency in the
    team and ensures a uniform approach, and it enables more advanced use cases and
    ensures security and scalability.'
  prefs: []
  type: TYPE_NORMAL
- en: The lifecycle of features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until a few years ago, most software was released every 1 or 2 years in major
    versions that had to be purchased separately or at least were coupled tightly
    to licensing through subscriptions. All the new features were squeezed into these
    new release versions. The new releases normally came with pieces of training,
    books, and online courses to teach the users the new features.
  prefs: []
  type: TYPE_NORMAL
- en: These sales models basically do not exist anymore today. Customers want their
    software as a service. No matter if we talk about mobile apps such as Facebook
    or WhatsApp, or desktop software such as Office or Windows, software is updated
    and optimized continuously, and new features are added constantly. This brings
    the challenge of educating your end users on how to use the new features properly.
    An intuitive user experience and easy discoverability of new features are more
    important than they were with the old sales model. Features must be self-explanatory,
    and a simple on-screen dialog must be sufficient to educate users on how to use
    the new feature.
  prefs: []
  type: TYPE_NORMAL
- en: Also, value creation is completely different. Customers do not make their buy
    decision every few years. They decide every day if they use the software for a
    task at hand or not. So, instead of putting a ton of new features into a new version
    to influence buy decisions, the focus is on delivering fewer features with a high
    value by removing features that are not used or optimizing them until they are
    of high value.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means every feature is subject to a lifecycle. The lifecycle of a feature
    could look like the one in *Figure 10.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – The lifecycle of features'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_10_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.2 – The lifecycle of features
  prefs: []
  type: TYPE_NORMAL
- en: 'The lifecycle is subject to the following phases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ideation and development**: After the idea for a new feature, the implementation
    starts with a few internal users. The feedback of these users is used to improve
    the feature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alpha or beta**: In the alpha and/or beta phase, the feature is provisioned
    to a broader, but still very limited, audience. The audience can be internal or
    selected external customers. The alpha or beta phase can be closed (private) or
    open (public), but the feature in this phase is still very dynamic and can change
    dramatically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adoption**: If the feature is mature enough for the market, it is gradually
    exposed to a broader audience. The adoption phase can be divided into the following
    sub-phases:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Preview**: The users can **opt in** and enable the preview feature.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Default for new users**: The feature is the default for new users – but users
    could still **opt out** if they don''t want to use it.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Default for all users**: The feature is enabled for all users, but users
    can still opt out.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Normal operation**: The feature is used by all users and an opt-out is not
    possible anymore. Previous versions of the feature get removed from the system.
    The normal operation can go on for many years.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sundown**: The feature is replaced by a newer and hopefully better feature.
    The number of users that use this feature declines and the cost of maintaining
    the feature exceeds its value. The feature is removed from the system when all
    users can be redirected to a new feature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the value of the feature is the biggest in the early adoption phase
    as it attracts new users to your application. In the normal operations phase,
    the hype has probably flattened, and the competition has also learned from your
    feature and reacted by adjusting their software.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of Feature Flags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Managing the lifecycle of a feature without using Feature Flags is impossible,
    but there are many other use cases where Feature Flags can bring value to your
    DevOps teams:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Release flags**: These are used to roll out code behind a flag. Release flags
    normally stay in the code until the feature is rolled out completely. This can
    be weeks or months. Release flags change with each deployment or with the system''s
    configuration. This means they can be implemented very easily by just reading
    a configuration value. But if you want to use release flags for **canary releases**
    (gradually exposing the feature to more and more users) or **blue-green deployments**
    (swapping staging and production environments), they are much more dynamic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Experimentation flags**: If you roll out multiple versions of the same feature
    and expose it to different audiences, it is called **A/B testing** or **experimentation**.
    It is normally used to confirm or diminish a hypothesis by measuring certain metrics
    of how users interact with the version of the feature. Experimentation flags are
    highly dynamic and rely on a lot of contexts to use them to address different
    target audiences.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Permission flags**: A common use case of Feature Flags is to control what
    users can access. This can be *administration features* or *testing features*
    that are only exposed to certain audiences, or *premium features* that are only
    exposed to paying customers. Permission flags are highly dynamic and normally
    stay in the code for a long time – sometimes until the end of the application
    lifecycle. They also expose a high risk of fraud and must, therefore, be used
    carefully.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operation flags**: Some flags are used for operational aspects of the application
    – for example, *kill switches* used to disable certain functionality that can
    be a bottleneck for other features (also known as a *circuit breaker*). A flag
    to control different versions of a backend system is also considered an operation
    flag. Multi-variant flags are often used to control logging verbosity or other
    operational aspects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 10.3* shows an overview of the different types of Feature Flags categorized
    by dynamic and the time they stay in the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Types of Feature Flags'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_10_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.3 – Types of Feature Flags
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned what Feature Flags are and what you can do with them,
    I will show you how you can implement them in code.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Feature Flags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In code, a Feature Flag is nothing more than an `if` statement. Let''s assume
    you have a current implementation of the dialog to register new users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you want to create a new dialog using a Feature Flag and be able to switch
    on the new dialog at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To enable or disable the feature dynamically, you have to extract the validation
    of the Feature Flag into its own function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many options where you can store the configuration of the Feature
    Flag:'
  prefs: []
  type: TYPE_NORMAL
- en: The system configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The application database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A separate database
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A separate system (accessed through an API)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It highly depends on your use case what locations work or don't work.
  prefs: []
  type: TYPE_NORMAL
- en: Feature Flags and technical debt
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you start using Feature Flags, you normally end up with a highly configurable
    system that can change its behavior at runtime – normally by many flags that are
    scattered across multiple configuration sources. The flags tend to have dependencies
    between each other, so enabling or disabling flags exposes a great risk to the
    stability of the system. You managed to escape *merge hell* by avoiding parallel
    branches, but ended up in *feature flag hell*, with hundreds of flags that nobody
    knows what they are for.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid this, you should follow these best practices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Metrics**: Even with all the value they provide, Feature Flags in your code
    are some kind of technical debt. You should measure them as you do code coverage
    or other code-related metrics. Measure the *number* of Feature Flags, how long
    they exist (*duration*), how they evaluate in each environment (*value*, 100%
    true in production probably means the flag can be removed), and how often the
    flags are used (*calls*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Central management**: Manage your flags in one central place, especially
    if you use different methods to manage the flags. Each flag should have an *owner*
    and a *description*. Document the *dependencies* between Feature Flags.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration into your process**: Integrate the management of Feature Flags
    into your process. For example, if you use Scrum, you can integrate the review
    of the Feature Flags in the *review* meeting. Make sure that all the people who
    work with the flags regularly go through all the flags and check which ones can
    be removed from the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tmp-` as a prefix for temporary flags and `perm-` for permanent ones. Don''t
    make it too complicated, but the name of the flag should immediately indicate
    what kind of flag it is and how long it is supposed to stick around in the code
    base.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A technique that some teams like and others do not is **cleaning up branches**.
    You can see if this technique works for you. The idea is that the moment you create
    the flag and write the code, you know best how the code should look if the flag
    is removed one day. So, you create a cleanup branch and pull request alongside
    the code and leave the pull request open until the flag is removed. The technique
    works best with good naming conventions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take the preceding example; you have a flag for a new feature dialog. The code
    with the flag looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The code is developed in a `features/new-register-dialog` branch and you create
    the pull request to merge the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'You already know that the final state of the code, when the flag is removed,
    will only use the new dialog, so you create a new branch (for example, `cleanup/new-register-dialog`)
    and add the final version of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You can then create a pull request and leave it open until the feature is rolled
    out completely and you want to clean up the code.
  prefs: []
  type: TYPE_NORMAL
- en: As I said, this technique is not well suited for all teams. Maintaining the
    cleanup branches can be a lot of work in a complex environment, but you can give
    it a try.
  prefs: []
  type: TYPE_NORMAL
- en: Feature Flags that do not get cleaned up and are not actively maintained are
    technical debt, but the advantages outweigh the disadvantages. If you are careful
    from the beginning, you can avoid the feature flag hell and only benefit from
    the flexible power they provide you when releasing and operating your application.
  prefs: []
  type: TYPE_NORMAL
- en: Frameworks and products
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many frameworks available that you can leverage when implementing
    Feature Flags. The framework that is the best for you depends a lot on your programming
    languages and use cases. Some focus more on UI integration, some more on rollout
    and operations. When picking your framework, you should consider the following
    aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance**: Feature Flags must be fast and must not reduce the performance
    of your application. Proper caching should be used and also default values that
    are used if the data store cannot be reached on time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Supported programming languages**: Your solution should work with all your
    languages, especially when you use client-side flags; you must also evaluate them
    on the server for security reasons. You don''t want to configure the flags in
    different locations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UI integration**: If you want to provide the users with the ability to opt
    in or out of features, you want a good integration into your UI. Normally, you
    need two flags for that: one to control the visibility, and one to enable or disable
    the feature.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Context**: When you want to use Feature Flags for A/B testing and experimentation,
    you need a lot of context information to evaluate the flags: the user, group memberships,
    the region, and the server, for example. This is where many frameworks fail.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Central management**: Flags that you configure for each environment separately,
    for example, are impossible to maintain. You need one central management platform
    where you can control all the flags in one place.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data store**: Some frameworks store the configuration in your application
    database. This is problematic for many scenarios. Normally, you have a different
    database in all your environments, so managing the settings across the environments
    is difficult.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Building a scalable, performant, and mature solution takes a lot of time and
    effort, even when using frameworks, but there are also products available that
    you can install or consume as a service. A product that has been around for many
    years and is established mature is **LaunchDarkly** ([https://launchdarkly.com/](https://launchdarkly.com/)).
    There is a lot of competition now, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Switchover** ([https://switchover.io/](https://switchover.io/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**VWO** ([https://vwo.com/](https://vwo.com/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Split** ([https://www.split.io/](https://www.split.io/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flagship** ([https://www.flagship.io/](https://www.flagship.io/))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure App configuration** ([https://docs.microsoft.com/en-us/azure/azure-app-configuration/overview](https://docs.microsoft.com/en-us/azure/azure-app-configuration/overview))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unleash** (https://www.getunleash.io/) is also worth mentioning. It has an
    **open core** (https://github.com/Unleash/unleash) and can be self-hosted free
    of charge as a Docker container. Unleash is also the solution that is used by
    GitLab.'
  prefs: []
  type: TYPE_NORMAL
- en: I could not find a good resource that compares the solutions, so I added a page
    on GitHub ([https://wulfland.github.io/FeatureFlags/](https://wulfland.github.io/FeatureFlags/))
    that provides an independent comparison of the solutions.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to the make-or-buy decision, most companies are better off using
    an existing service or product. Building and running a good solution for Feature
    Flags is difficult and time-consuming, especially if you are new to Feature Flags.
    Start with a good product. If, after some time, you still find it necessary to
    build your own solution, at least you have experience knowing what a solution
    should be able to do.
  prefs: []
  type: TYPE_NORMAL
- en: Experimentation with Feature Flags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Experimentation and A/B testing cannot only be done using Feature Flags. You
    can also develop containers in different branches and use Kubernetes to run different
    versions in production; however, this will increase your complexity in Git and
    does not scale well. You don't have the context for the users either, so gathering
    the data to prove or diminish your hypothesis is much harder. Most of the solutions
    for Feature Flags have built-in support for experiments, so this is the fastest
    way to get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'To experiment, you define a hypothesis, conduct an experiment, and then learn
    from the results. An experiment can be defined as follows (see *Figure 10.4*):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hypothesis**: We believe *{customer segment}*, wants *{product/feature}*
    because *{value prop}*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Experiment**: To prove or disprove the preceding, the team will conduct an
    experiment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Learning**: The experiment will prove the hypothesis by impacting the following
    metrics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Conducting experiments with Feature Flags'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_10_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.4 – Conducting experiments with Feature Flags
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at an example. By looking into the usage data of your application,
    you realize that the page views for the first page of the registration dialog
    for new users are much higher than the number of people that finish the registration
    process. Only about 20% of them finish the registration. The hypothesis is that
    the register dialog is too complex and that the number of people finishing the
    registration will increase dramatically when the dialog is simplified.
  prefs: []
  type: TYPE_NORMAL
- en: 'To conduct the experiment, you add two new metrics to your application: `started-registration`,
    which increases every time a user clicks on the `finished-registrations`, which
    increase after the user successfully registers for your application. The two metrics
    make it easy to calculate `aborted-registrations`. You gather the data during
    the next few weeks and confirm that the aborted registration rate has an average
    of 80% over these weeks. Your team creates a new, simple dialog using a `new-register-dialog`
    Feature Flag. It removes all required fields that are not necessary for the registration
    itself, such as address and payment information, and ships the code to production.
    The data is validated before checkout anyway, so the simplified registration works,
    even if this might be a usability problem for the checkout.'
  prefs: []
  type: TYPE_NORMAL
- en: In production, you turn on the flag for 50% of the new users and compare the
    `aborted-registrations` rate for the two groups. The users that see the old dialog
    stay as expected at around 70% to 80% aborted, whereas the users with the new
    dialog only have an aborted rate of 55%.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result is still not perfect so you start adding new metrics to find out
    where in the dialog the people are struggling. This leads to the next hypothesis
    (see *Figure 10.5*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Conducting experiments with Feature Flags'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_10_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.5 – Conducting experiments with Feature Flags
  prefs: []
  type: TYPE_NORMAL
- en: To experiment with Feature Flags, you need data. Only with the right metrics
    and the ability to map the metrics to audiences that have certain flags on or
    off are you able to really perform evidence-based development.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 19*, *Experimentation and A/B Testing with GitHub*, we will, unsurprisingly,
    have a closer look into experimentation and A/B testing with GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Feature Flags are one of the most important capabilities for the acceleration
    of DevOps teams. Unfortunately, GitHub does not have a built-in solution so far.
    But there are many products that can help you to get up to speed.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned about the feature lifecycle and how you can manage
    it using Feature Flags. You also learned how you can leverage Feature Flags to
    reduce complexity by checking code early.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you'll learn about trunk-based development and the best
    Git workflow to support fast DevOps teams.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can get more information on the topics here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Martin Fowler, *Feature-Toggles (aka Feature Flags)*, 2017: [https://martinfowler.com/articles/feature-toggles.html](https://martinfowler.com/articles/feature-toggles.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Comparison of Feature Flag solutions: [https://wulfland.github.io/FeatureFlags/](https://wulfland.github.io/FeatureFlags/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'LaunchDarkly: [https://launchdarkly.com/](https://launchdarkly.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Switchover: [https://switchover.io/](https://switchover.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'VWO: [https://vwo.com/](https://vwo.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Split: [https://www.split.io/](https://www.split.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Flagship: [https://www.flagship.io/](https://www.flagship.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unleash: [https://www.getunleash.io/](https://www.getunleash.io/) and [https://github.com/Unleash/unleash](https://github.com/Unleash/unleash)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
