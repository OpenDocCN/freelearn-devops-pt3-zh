- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Dealing with Databases in DevOps Scenarios
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 DevOps 场景中处理数据库
- en: 'In the previous chapters, you learned about the continuous integration and
    continuous deployment of your software. You also learned how the same principles
    can be applied to the delivery of configuration in infrastructure. Once you have
    adopted these principles and started increasing the flow of value delivery, you
    might run into another challenge: managing your database schema changes.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，您了解了软件的持续集成和持续部署。您还学习了如何将相同的原则应用于基础设施配置的交付。一旦您采纳了这些原则并开始提高价值交付的流量，您可能会遇到另一个挑战：管理数据库模式的变化。
- en: Applying DevOps to databases can feel like trying to change the tires on a running
    car. You must find some way of coordinating changes between the database schema
    and application code without taking the system down for maintenance.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 将 DevOps 应用于数据库可能感觉就像是在一辆行驶的汽车上更换轮胎。您必须找到一种方法，在数据库模式和应用程序代码之间协调变化，而不需要停机维护。
- en: 'In this chapter, you will learn about different approaches for doing just that:
    managing these schema changes while avoiding downtime. With proper planning and
    a disciplined approach, this can be achieved in a way that manages risks well.
    You will see how you can treat your database schema as code, and you will learn
    about the different approaches that are available to do so. You will also see
    another approach that avoids database schemas altogether, namely, going schema-less.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，您将学习如何做到这一点：在避免停机的情况下管理数据库模式的变化。通过适当的规划和严格的管理，这可以以一种良好管理风险的方式实现。您将看到如何将数据库模式视为代码，并了解实现这一目标的不同方法。您还将看到一种完全避免数据库模式的方法，即采用无模式（schema-less）方式。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Managing a database schema as code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据库模式作为代码进行管理
- en: Applying database schema changes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用数据库模式变化
- en: Going schema-less
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 采用无模式方式
- en: Other approaches and concerns
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他方法和关注点
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In order to practice the ideas that are laid out in this chapter, you will
    need to have the following tools installed:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实践本章中提出的思想，您需要安装以下工具：
- en: An application with the Entity Framework Core NuGet package installed
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装了 Entity Framework Core NuGet 包的应用程序
- en: Visual Studio with SQL Server Data Tools
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配备 SQL Server 数据工具的 Visual Studio
- en: Access to Azure Pipelines
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问 Azure Pipelines
- en: An Azure subscription, for accessing Cosmos DB
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Azure 订阅，用于访问 Cosmos DB
- en: Managing a database schema as code
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据库模式作为代码进行管理
- en: For those of you who are familiar with working with relational databases from
    application code, it is very likely you have been working with an **object-relational
    mapper** (**ORM**).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您熟悉从应用程序代码操作关系型数据库，那么很可能您已经在使用 **对象关系映射器**（**ORM**）。
- en: ORMs were introduced to fill the impedance mismatch between object-oriented
    programming languages and the relational database schema, which works with tables.
    Well-known examples are Entity Framework and NHibernate.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 的引入是为了解决面向对象编程语言与关系型数据库模式（与表格一起工作）之间的阻抗不匹配。著名的例子有 Entity Framework 和 NHibernate。
- en: ORMs provide a layer of abstraction that allows for the storage and retrieval
    of objects from a database, without worrying about the underlying table structure
    when doing so. To perform automated mapping of objects to tables, or the other
    way around, ORMs often have built-in capabilities for describing a database schema,
    the corresponding object model, and the mappings between them in a markup language.
    Most of the time, neither of these have to be written by hand. Often, they can
    be generated from an object model or an existing database, and the mappings between
    them are often, by convention, generated or drawn in a visual editor.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ORM 提供了一层抽象，使得在存储和检索数据库中的对象时，无需关心底层的表结构。为了自动映射对象到表，或者反向操作，ORM 通常内建有用于描述数据库模式、对应对象模型及它们之间映射的标记语言功能。大多数情况下，这些内容无需手动编写。它们通常可以从对象模型或现有数据库生成，且它们之间的映射通常是通过约定生成或在可视化编辑器中绘制的。
- en: While all this allows for the current database schema to be defined as code,
    this alone does not help with coping with schema changes, yet. For handling schema
    changes as code, two common approaches are available. The first one describes
    every change in code; the other one describes only the latest version of the schema
    in code. These approaches are known as migration-based and state-based approaches,
    respectively. Both can rely on third-party tooling for applying the changes to
    the database.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些措施使当前的数据库架构可以作为代码进行定义，但仅此并不能帮助应对架构变化。要以代码处理架构变化，有两种常见的方式。第一种方法描述了每一次变化的代码；第二种方法则仅在代码中描述架构的最新版本。这两种方法分别被称为基于迁移和基于状态的方法。两者都可以依赖第三方工具将变更应用到数据库中。
- en: Migrations
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迁移
- en: The first approach is based on keeping an ordered set of changes that have to
    be applied to the database. These changes are often called **migrations**, and
    they can be generated by tools such as Microsoft Entity Framework or Redgate SQL
    Change Automation, or they can be written by hand.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法基于保持一组必须应用到数据库的有序变更。这些变更通常被称为**迁移**，它们可以通过如 Microsoft Entity Framework
    或 Redgate SQL Change Automation 等工具生成，也可以手动编写。
- en: 'Tools can automatically generate the migration scripts based on a comparison
    of the current schema of the database and the new schema definition in source
    control. This is called **scaffolding**. The scripts generated by tools are not
    always perfect, and they can be improved by applying the domain knowledge that
    the programmer has. Once one or more new migrations are scaffolded or written,
    they can be applied to a database using the chosen tool. The following is a diagram
    showing how that works:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 工具可以根据当前数据库架构和源代码控制中新的架构定义的比较，自动生成迁移脚本。这被称为**脚手架搭建**。工具生成的脚本并不总是完美的，可以通过应用程序员的领域知识进行改进。一旦生成或编写了一个或多个新的迁移，它们可以通过选定的工具应用到数据库中。以下是一个展示该过程如何工作的图示：
- en: '![Figure 9.1 – Migration approach ](img/B18655_09_01.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 迁移方法 ](img/B18655_09_01.jpg)'
- en: Figure 9.1 – Migration approach
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 迁移方法
- en: Here, we see how an ever-growing series of migrations, labeled **m1** to **m4**,
    are generated to describe incremental changes to the database. To update the database
    to the latest version, the latest applied migration is determined and all migrations
    after that are added one after the other.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到一系列不断增长的迁移，从**m1**到**m4**，它们用于描述数据库的增量变化。为了将数据库更新到最新版本，首先确定最新应用的迁移，然后依次添加其后的所有迁移。
- en: 'When editing migration scripts by hand, the following have to be kept in mind:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当手动编辑迁移脚本时，以下几点需要注意：
- en: The migration scripts should be ordered. Migrations describe the SQL statements
    that need to be executed in order to move the database from version *x* to version
    *x+1*. The next migration can be started only when this step is completed.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迁移脚本应该是有序的。迁移描述了需要执行的 SQL 语句，以便将数据库从版本*x*迁移到版本*x+1*。只有在完成当前步骤后，才能开始下一个迁移。
- en: A migration script should migrate not only the schema but also the data. This
    can mean that a few steps are needed in between migrations. For example, moving
    two columns to another table often implies that the new columns are first created,
    then filled with the data from the old columns, and only then are the old columns
    removed.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迁移脚本不仅应迁移架构，还应迁移数据。这可能意味着在迁移之间需要进行一些步骤。例如，将两个列移动到另一个表通常意味着首先创建新列，然后将旧列的数据填充到新列中，最后再移除旧列。
- en: It is advisable to include all database objects in the migration scripts. Extra
    indexes and constraints should be applied not only to the production database
    but also to test environments. With migrations, there is already a mechanism for
    delivering those from source control. Having these in the same migration scripts
    also ensures that indexes and constraints are applied in the same order and cannot
    unexpectedly block migrations by existing only in production.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建议在迁移脚本中包含所有数据库对象。额外的索引和约束不仅要应用于生产数据库，还应应用于测试环境。通过迁移，已经有了从源代码控制传递这些变更的机制。将这些内容包含在相同的迁移脚本中，还能确保索引和约束按照相同的顺序应用，并且不会因仅存在于生产环境中而意外阻塞迁移。
- en: If possible, migration scripts should be made idempotent. If there is ever an
    issue or the suspicion of an issue, being able to just rerun the last migration
    is a great way to ensure that it is fully applied.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可能，迁移脚本应该具有幂等性。如果出现问题或怀疑有问题，能够重新运行最后一次迁移是确保迁移已完全应用的好方法。
- en: One disadvantage of this approach is the strict ordering requirement that is
    imposed on generating and applying the generated migrations. This makes it hard
    to integrate this approach into a development workflow that relies heavily on
    the use of branches.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个缺点是生成和应用迁移时强制要求的严格顺序。这使得将这种方法集成到依赖于分支使用的开发工作流中变得困难。
- en: 'Migrations created in different branches that are merged together only later
    might break the ordering of migrations or, even worse, merge a split in the migration
    path. For example, imagine the case where two migrations, *b* and *c*, in two
    different branches have been created after an existing migration, *a*. How are
    these going to be merged? Neither order—*a*, *b*, *c* or *a*, *c*, *b*—is correct,
    since both *b* and *c* are created to be executed directly after *a*. The only
    way such an error can be fixed is by performing the following steps:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同分支中创建的迁移，在稍后合并时可能会打乱迁移的顺序，或者更糟糕的是，合并了迁移路径的分裂。例如，假设在现有迁移*a*之后，在两个不同分支中分别创建了迁移*b*和*c*。这些迁移将如何合并？无论是顺序*a*,
    *b*, *c*，还是*a*, *c*, *b*，都不正确，因为*b*和*c*都是在*a*之后直接执行的。修复此错误的唯一方法是执行以下步骤：
- en: Remove all migrations apart from the first new one, which is *c* in this case.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 移除所有迁移，除了第一个新的迁移，在这种情况下是*c*。
- en: Apply all other migrations to a database that has none of the new migrations
    applied, in this case, only *b* if *a* was already applied, or both *a* and *b*.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有其他迁移应用到尚未应用任何新迁移的数据库上，在这种情况下，如果*a*已经应用，则仅应用*b*，或者同时应用*a*和*b*。
- en: Generate a new migration for the other migrations, in this case, a replacement
    for *c*.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为其他迁移生成新的迁移，在这种情况下，*c*的替代迁移。
- en: An advantage of this approach is that every individual schema change will be
    deployed against the database in the same fashion. Irrespective of whether one—or
    more than one—migration is applied to the production database at the same time,
    they will still run one by one in a predictable order and in the same way in which
    they ran against the test environment, even if they were applied there one by
    one.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个优点是，每个单独的架构变更都会以相同的方式部署到数据库中。无论是否同时将一个或多个迁移应用到生产数据库，它们仍然会按可预测的顺序逐个执行，并以与它们在测试环境中执行时相同的方式运行，即使它们是在测试环境中逐个应用的。
- en: End state
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最终状态
- en: A different approach to managing schema changes is to not keep track of the
    individual changes (or migrations), but only store the latest version of the schema
    in source control. External tools such as Microsoft Visual Studio and Redgate’s
    SQL Data Compare tool are then used to compare the current schema in source control
    with the actual schema of the database, generate migration scripts, and apply
    these when running. The migration scripts are not stored and are single-use only.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 管理架构变更的另一种方法是，不跟踪单独的变更（或迁移），而仅存储架构的最新版本在源代码控制中。然后使用外部工具，如 Microsoft Visual Studio
    和 Redgate 的 SQL Data Compare 工具，来比较源代码控制中的当前架构与数据库的实际架构，生成迁移脚本，并在运行时应用这些迁移脚本。迁移脚本不被存储，只能使用一次。
- en: 'Unlike writing migrations, it is not feasible to execute a task like this by
    hand. While tracking the newest version of the schema by hand in source control
    can be managed, the same is not feasible for an end-state approach. Generating
    a migration script while comparing the existing schema and the new schema and
    applying this migration script can only be done using a tool. Examples of suitable
    tools are Redgate SQL Source Control and SQL Server Data Tools. How these tools
    work is shown in the following diagram:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与编写迁移不同，手动执行此类任务是不可行的。虽然手动在源代码控制中跟踪架构的最新版本是可以管理的，但对于最终状态方法来说，这是不可行的。生成迁移脚本时，需要比较现有架构与新架构，并应用此迁移脚本，这只能通过工具来完成。适用的工具示例有
    Redgate SQL Source Control 和 SQL Server Data Tools。以下图表展示了这些工具的工作原理：
- en: '![Figure 9.2 – Managing schema changes  ](img/B18655_09_02.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 管理架构变更](img/B18655_09_02.jpg)'
- en: Figure 9.2 – Managing schema changes
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 管理架构变更
- en: Here, we see how the current, actual database schema and the description of
    the desired database schema are compared to generate an upgrade and directly apply
    a script for making the changes needed to make the actual schema the same as the
    desired schema.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到如何比较当前的实际数据库模式和期望的数据库模式的描述，以生成升级并直接应用一个脚本，从而进行必要的更改，使实际模式与期望的模式一致。
- en: One advantage of this approach is that there is no series of scripts generated
    that have to be executed in a specific order. Therefore, this approach combines
    easily with extensive branching schemas, where changes are integrated more slowly
    over time. It also removes the need to write migrations by hand for simple scenarios,
    such as adding or deleting a column, table, or index.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个优势是，生成的脚本不需要按特定顺序执行。因此，这种方法可以轻松地与广泛的分支模式结合使用，在这种模式中，更改随着时间的推移慢慢集成。此外，它还消除了在简单场景中手动编写迁移脚本的需求，例如添加或删除列、表或索引。
- en: The disadvantage of this approach is that it makes it harder to handle changes
    that need data operations as well. Again, imagine a scenario of moving two columns
    to another table. Since the tooling only enforces the new schema, this will lead
    to data loss if there is no further intervention.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点是，它使得处理需要数据操作的更改变得更加困难。再举个例子，假设需要将两列移到另一个表中。由于工具只执行新的模式，这样会导致数据丢失，如果没有进一步的干预。
- en: One possible form of intervention to circumvent this is the addition of pre-
    and post-deployment scripts to the schema package. In the pre-deployment script,
    the current data is staged in a temporary table. Then, after applying the new
    schema, the data is copied from the temporary table to the new location in the
    post-deployment script.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了规避这个问题，一个可能的干预方式是向模式包中添加部署前后脚本。在部署前脚本中，将当前数据暂存到临时表中。然后，在应用新模式后，数据将从临时表复制到部署后脚本中的新位置。
- en: This section was about managing database schema changes in a format that can
    be stored in source control. The next section discusses how these changes can
    be picked up at deploy time and then applied to a database.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 本节内容讲述了如何以一种可以存储在源代码管理中的格式管理数据库模式更改。下一节将讨论如何在部署时捕捉这些更改并应用到数据库。
- en: Applying database schema changes
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用数据库模式更改
- en: With the database schema and, optionally, a series of migrations defined in
    source control, it is time to start thinking about when to apply changes to the
    database schema. There are two methods to do so. Database schema changes can be
    applied prior to deployment of the new application version, or by the application
    code itself.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库模式和（可选的）在源代码管理中定义的一系列迁移准备好后，就可以开始考虑何时应用这些更改到数据库模式中。可以通过两种方法来实现。数据库模式更改可以在新应用版本部署之前应用，或者由应用程序代码本身进行。
- en: Upgrading as part of the release
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为发布的一部分进行升级
- en: The first approach to applying database changes is as part of the release pipeline.
    When this is the case, the tool that is responsible for reading and executing
    the migration scripts is invoked using a step in the pipeline.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 应用数据库更改的第一种方法是作为发布流水线的一部分。在这种情况下，负责读取和执行迁移脚本的工具是通过流水线中的一个步骤调用的。
- en: This invocation can be done using a custom script in PowerShell or another scripting
    language. However, this is error-prone, and with every change of tool, there is
    a risk that the scripts need to be updated. Luckily, for most migration-based
    tools, there are Azure Pipelines tasks that are readily available for starting
    the migration from the release.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这个调用可以通过 PowerShell 或其他脚本语言中的自定义脚本来完成。然而，这种方法容易出错，而且每次工具发生变化时，脚本可能需要更新。幸运的是，对于大多数基于迁移的工具，Azure
    Pipelines 任务已经准备好，可以直接从发布启动迁移。
- en: For example, there is an Azure Pipelines extension available for applying Entity
    Framework Core migrations to a database directly from the `dll` file where they
    are defined. This task can be added to the release pipeline for updating the database
    before the new application code is deployed. A link to the **Build & Release Tools**
    extension is provided in the *Further reading* section at the end of this chapter.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，有一个 Azure Pipelines 扩展可用于直接从定义迁移的 `dll` 文件将 Entity Framework Core 迁移应用到数据库。可以将此任务添加到发布流水线中，以便在新应用代码部署之前更新数据库。在本章最后的*进一步阅读*部分提供了**构建与发布工具**扩展的链接。
- en: Another variation is a split between the build and release phases of an application.
    In this case, the migration scripts are exported as a separate build artifact,
    either directly from the source code—if written in SQL—or after executing a tool
    that generates the necessary SQL scripts as output. This artifact is then downloaded
    again in the release phase, where it is applied to the database using an Azure
    Pipelines task for executing SQL.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种变体是将应用程序的构建阶段和发布阶段分开。在这种情况下，迁移脚本作为单独的构建产物导出，可以直接从源代码导出（如果是用SQL编写的），或者在执行生成必要SQL脚本的工具之后导出作为输出。然后，这个产物会在发布阶段再次下载，在该阶段，它通过Azure
    Pipelines任务来执行SQL并应用到数据库中。
- en: Upgrading with the application code
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与应用程序代码一起升级
- en: Instead of applying schema changes from the release pipeline, they can also
    be applied by the application itself. Some of the ORMs, with migration support
    built in, have the capability to automatically detect whether the database schema
    matches the latest migration. If not, they can automatically migrate the schema
    to that latest version on the spot.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 不必从发布管道中应用模式更改，它们也可以由应用程序本身来应用。一些内建迁移支持的ORM具有自动检测数据库模式是否与最新迁移匹配的功能。如果不匹配，它们可以自动将数据库模式迁移到最新版本。
- en: 'An example of an ORM that supports this is Entity Framework. The core version
    of Entity Framework does not have support for automatic migrations built in. In
    Entity Framework Core, a single line of application code can be used to initiate
    an upgrade at a time that is convenient from the perspective of the application.
    The code for doing so is shown in the following code snippet:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 支持此功能的一个ORM示例是Entity Framework。Entity Framework的核心版本没有内建的自动迁移支持。在Entity Framework
    Core中，可以通过一行应用程序代码来启动一个适合应用程序的升级时机。执行该操作的代码如下所示：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The advantage of this approach is that it is very simple to enable. Just a Boolean
    switch in the configuration of, for example, Entity Framework can enable this
    workflow. However, the disadvantage is that most ORMs that support this will enforce
    a global lock on the database—stopping all database transactions while the migrations
    are running. For any migration or set of migrations that take more than a few
    seconds, this approach might be impractical.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是启用非常简单。例如，在Entity Framework的配置中只需一个布尔开关就可以启用此工作流。然而，缺点是大多数支持此功能的ORM会对数据库施加全局锁——在迁移运行时会停止所有数据库事务。对于任何需要几秒钟以上时间的迁移或迁移集合，这种方法可能不切实际。
- en: This approach is normally only used for migration-based approaches. Approaches
    that use an end-state approach require an external third-party tool that is used
    to generate the necessary migration scripts and apply them. This is normally done
    from the release pipeline and is not wrapped in the application itself.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法通常仅用于基于迁移的方法。使用最终状态方法的方式需要一个外部第三方工具，用来生成必要的迁移脚本并应用它们。这通常是在发布管道中完成的，而不是应用程序内部进行的。
- en: Adding a process
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加一个过程
- en: 'As the previous section illustrated, it is important to think about how and
    when changes to the database schema or the application (or applications!) that
    use that schema are applied. But, no matter how the deployment of schema changes
    and code deployments are scheduled, there will always be a period where one of
    the following is true:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 正如前一部分所说明的那样，考虑何时以及如何应用数据库模式的更改或使用该模式的应用程序（或多个应用程序）的更改非常重要。但是，无论模式更改和代码部署的部署计划如何，总会有一段时间，其中以下一种情况是成立的：
- en: The new application code is already running while the schema changes are not
    applied yet or are in the process of being applied.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的应用程序代码已经在运行，而模式更改尚未应用或正在应用过程中。
- en: The old application code is still running while the schema changes are already
    applied or are in the process of being applied.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旧的应用程序代码仍然在运行，而模式更改已经应用或正在应用过程中。
- en: The application code is not running while the schema changes are being applied.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用模式更改时，应用程序代码不会运行。
- en: The third situation is highly undesirable. This is true in general, but especially
    when practicing DevOps. If changes are shipped often and during working hours,
    it is unacceptable to take the application down for every schema change.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种情况是极其不理想的。这通常适用于所有情况，但在进行DevOps实践时尤为重要。如果更改频繁且在工作时间内发布，每次进行模式更改时都停机是不可接受的。
- en: 'To prevent having to take the application down while schema changes are being
    applied, one of the following conditions has to be met:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止在应用架构变更时需要停机，必须满足以下条件之一：
- en: The schema changes are backward-compatible in such a way that the old version
    of the application code can run without errors against a database where the schema
    changes have already been applied or are being applied.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 架构变更向后兼容，使得旧版本的应用程序代码可以在架构变更已经应用或正在应用的数据库上无错误地运行。
- en: The new application code is backward-compatible in such a way that it can run
    against both the old and new versions of the schema.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的应用程序代码向后兼容，可以同时在旧版本和新版本的架构下运行。
- en: Meeting the first of these conditions ensures that the old application code
    can continue to run while the schema changes are being applied. Meeting the second
    of these conditions ensures that the new version of the application code can be
    deployed first, and once that is completed, the database can be upgraded while
    this code is running. While either will work, it is often desirable to aim for
    the first condition. The reason is that schema changes often support application
    code changes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 满足第一个条件确保在应用架构变更时，旧版应用程序代码可以继续运行。满足第二个条件确保新版本的应用程序代码可以首先部署，并且一旦完成部署，数据库可以在代码运行时进行升级。虽然这两种方法都可行，但通常希望优先实现第一个条件。原因在于，架构变更通常会支持应用程序代码的更改。
- en: 'This means that the following is a safe process for deploying schema changes
    without downtime:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着以下是一个安全的架构变更部署过程，无需停机：
- en: Create a new database.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的数据库。
- en: Apply the database changes.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用数据库更改。
- en: Verify that the changes have been applied properly or abort the deployment pipeline.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证更改是否已正确应用，或者中止部署流程。
- en: Deploy the new application code.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署新的应用程序代码。
- en: It is important to realize that this process assumes failing forward. This means
    that if there ever is an issue with the deployment of schema changes, they should
    be resolved before going forward with the code changes.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要意识到，这一过程假设是“向前失败”。这意味着，如果架构变更的部署出现问题，应在继续进行代码更改之前解决这些问题。
- en: 'Finally, meeting the condition of backward compatibility for schema changes
    can sometimes be impossible to fulfill for a schema change. If this is the case,
    the change can often be split into two partial changes that together have the
    same end result, while they both meet the condition of backward compatibility.
    For example, renaming a property, or changing the unit in which it stores a distance
    from feet to meters, can be executed as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，满足架构变更的向后兼容性条件有时可能无法完成。如果是这种情况，通常可以将更改拆分成两个部分更改，这两个部分合起来实现相同的最终结果，同时都符合向后兼容性条件。例如，重命名一个属性，或者将存储距离的单位从英尺改为米，可以按以下方式执行：
- en: Generate a migration that adds a new column to a database table, storing the
    distance in meters.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成一个迁移，将一个新列添加到数据库表中，存储以米为单位的距离。
- en: Add application code that reads from the old column but writes to both columns.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加应用程序代码，该代码从旧列读取数据，但同时写入两个列。
- en: Deploy these changes to production.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些更改部署到生产环境。
- en: Add a new migration that migrates data from the old column to the new column
    for all cases where the new column is not yet filled, but the old column is.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的迁移，将数据从旧列迁移到新列，适用于所有新列尚未填充但旧列已填充的情况。
- en: Update the application code to read and write only the new column.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新应用程序代码，仅读取和写入新列。
- en: Deploy these changes to production.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这些更改部署到生产环境。
- en: Add a new migration that removes the old column.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的迁移，删除旧列。
- en: Using the correct tools and a proper process, it is possible to execute effective
    and safe deployments of schema changes. In the next section, another approach,
    using schema-less databases, is introduced.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 使用正确的工具和适当的流程，可以有效且安全地执行架构变更的部署。在接下来的部分中，将介绍另一种使用无架构数据库的方法。
- en: Going schema-less
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用无架构方法
- en: In the previous sections, the focus was on relational databases, where strict
    schemas are applied to every table. A completely different approach to database
    schema management is to let go of having a database schema altogether. This can
    be done by using schema-less or document databases. A well-known example of a
    schema-less database is **Azure Cosmos DB**. These databases can store documents
    of different forms in the same “table.” Table is in quote marks here since these
    types of databases often do not use the term “table,” but call this a database,
    a container, or a collection.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的部分中，重点是关系数据库，其中对每个表都应用严格的模式。另一种完全不同的数据库模式管理方法是不使用数据库模式。这可以通过使用无模式或文档数据库来实现。一个著名的无模式数据库例子是
    **Azure Cosmos DB**。这些数据库可以将不同形式的文档存储在同一个“表”中。这里的“表”是指这些数据库通常不使用“表”这个术语，而称其为数据库、容器或集合。
- en: Since these databases can store documents with a different schema in the same
    collection, schema changes no longer exist from a database’s point of view. But
    of course, there will be changes to the structure of the corresponding objects
    in the application code over time. To see how to handle this, it is best to differentiate
    between storing objects in the database and reading them back.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些数据库可以在同一个集合中存储具有不同模式的文档，从数据库的角度来看，模式变化不再存在。但当然，随着时间的推移，应用程序代码中相应对象的结构会发生变化。要了解如何处理这一点，最好区分将对象存储到数据库和从数据库读取的操作。
- en: Writing objects to the database
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写入对象到数据库
- en: The documents that are stored in a schema-less database are often serializations
    of objects in application code. When working with a relational database, these
    objects are often stored using an ORM, such as Entity Framework, Dapper, or NHibernate.
    When working with a document database, these objects are often serialized and
    stored in the database. Serialization is the process of converting an object into
    a stream of bytes so that it can be saved or transmitted easily across process
    boundaries. Deserialization is the reverse process of constructing a data structure
    or object from a stream of bytes. This means that a change in the definition of
    that code object will also result in a different document structure when saving
    the object. Due to the nature of document databases, this will work fine.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在无模式数据库中的文档通常是应用程序代码中对象的序列化。当使用关系数据库时，这些对象通常通过 ORM 存储，例如 Entity Framework、Dapper
    或 NHibernate。当使用文档数据库时，这些对象通常会被序列化并存储到数据库中。序列化是将对象转换为字节流的过程，以便能够轻松保存或跨进程边界传输。反序列化是从字节流构建数据结构或对象的逆过程。这意味着代码对象定义的变化也会导致保存该对象时文档结构的变化。由于文档数据库的特性，这种方式完全适用。
- en: As an example, take the following C# class and its JSON representation.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 作为示例，考虑以下 C# 类及其 JSON 表示。
- en: 'This code is using the `JsonConstructor` attribute to indicate that the constructor
    of the class should be used to create an instance of the class during deserialization:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使用了 `JsonConstructor` 特性来指示在反序列化过程中应该使用类的构造函数来创建类的实例：
- en: '[PRE1]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following code shows a JSON representation of the instance of a `Person`
    class after serializing it to a document database:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了将 `Person` 类实例序列化为文档数据库后的 JSON 表示：
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'After this code has been running in a production environment for a while, and
    thousands of people have been saved, a new requirement comes in. Next to the name
    of the person, the city where they live must also be recorded. For this reason,
    the `Person` class is extended to include another property. After performing this
    change and deploying the new code, whenever a person is saved, the following code
    is used:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在该代码在生产环境中运行一段时间后，成千上万的人得到了救助，出现了一个新需求。除了记录人的姓名外，还必须记录他们居住的城市。为此，`Person` 类扩展了一个新的属性。完成此更改并部署新代码后，每当保存一个人时，以下代码将被使用：
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The definition of the `Person` class has changed; the corresponding JSON representation
    of a new instance is shown in the following snippet. Both document variations
    can be saved into the same collection:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person` 类的定义已发生变化；新实例的相应 JSON 表示如以下代码所示。两种文档变体可以保存在同一个集合中：'
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This shows that from the viewpoint of writing information to the database, the
    schema-less approach is very convenient since developers do not have to think
    about schema change management at all.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明，从写入信息到数据库的角度来看，无模式的方式非常方便，因为开发人员根本不需要考虑模式变更管理。
- en: Reading objects from the database
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从数据库中读取对象
- en: While schema-less databases make it extremely easy to write documents of different
    forms to the same collection, this can pose problems when reading documents back
    from that same collection and deserializing them. In reality, the problem of schema
    management is not removed but deferred to a later point in time.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然无模式数据库使得将不同形式的文档轻松写入同一集合变得非常容易，但这在从该集合中读取文档并将其反序列化时可能会带来问题。实际上，模式管理的问题并没有被消除，而是推迟到了稍后的时间点。
- en: Continuing the example from the previous section, deserializing the first person
    that was saved on the new C# `Person` class definition will result in a null value
    for the city property. This can be unexpected since the C# code guarantees that
    a person without a city can never be constructed. This is a clear example of the
    challenges that schema-less databases pose.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 继续上一节的示例，在新C# `Person`类定义中反序列化第一个保存的人员时，城市属性将得到一个空值。这可能是意料之外的，因为C#代码保证没有城市的人永远无法构造。这是无模式数据库所带来的挑战的一个明确示例。
- en: 'In this example, the issue can be circumvented by updating the `Person` class
    to the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，可以通过将`Person`类更新为以下形式来避免这个问题：
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Aside from this scenario, where a property was added, there are many other
    scenarios that require the C# class to be adapted in order to handle deserialization
    scenarios. Some examples are as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这种添加属性的场景外，还有许多其他场景需要调整C#类以处理反序列化场景。以下是一些示例：
- en: Adding a property of a primitive type
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加原始类型的属性
- en: Adding a complex property, another object, or an array
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个复杂属性、另一个对象或数组
- en: Renaming a property
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重命名一个属性
- en: Replacing a property of a primitive type with a complex property
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用复杂属性替换原始类型的属性
- en: Making nullable properties non-nullable
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将可为空属性转换为非空属性
- en: 'Adding code to objects to handle these situations increases the size and complexity
    of the code base and pollutes the primary code base with the capabilities for
    coping with past situations. Especially when this happens often, this can lead
    to unwanted complications in a code base. To prevent this, a possible solution
    is to go through the following process whenever the schema of an object changes:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象中添加处理这些情况的代码会增加代码库的大小和复杂性，并使主代码库充斥着应对过去情形的能力。特别是当这种情况频繁发生时，可能会导致代码库中出现不必要的复杂性。为了防止这种情况，可以在每次对象模式更改时，按照以下流程进行处理：
- en: Change the schema of the object, ensuring that there are only properties added.
    Even when the goal is to remove a property, at this stage, only a property with
    the new name is added.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更改对象的模式，确保仅添加了属性。即使目标是删除属性，在这个阶段，也只是添加了具有新名称的属性。
- en: Implement logic on the object to cope with the deserialization of old versions
    of the object.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对象中实现逻辑，以应对旧版本对象的反序列化。
- en: Deploy the new version of the object.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署对象的新版本。
- en: Start a background process that loads all objects of the type from the database
    one by one and saves them back to the database.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个后台进程，从数据库中逐一加载该类型的所有对象，并将它们保存回数据库。
- en: Once the background process has processed all existing entities, remove the
    code that is responsible for coping with the schema change during deserialization
    from the code base, along with any properties that are no longer used.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦后台进程处理完所有现有实体，就从代码库中删除负责应对反序列化期间模式变化的代码，以及任何不再使用的属性。
- en: Using this approach, all changes are propagated to all stored versions of the
    object over a period of time. The downside to this approach is that the change
    to the object’s structure is spread over two changes that must be deployed separately.
    Also, deployment of the second change must wait until all objects in the database
    have been converted.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，所有更改将在一段时间内传播到对象的所有存储版本。此方法的缺点是对象结构的更改分布在两个必须分别部署的更改中。此外，第二次更改的部署必须等到数据库中的所有对象都已转换完成。
- en: Other approaches and concerns
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他方法和注意事项
- en: Besides the more common approaches that were discussed previously, the following
    tips and approaches might help with reducing the amount of work in dealing with
    databases or help reduce the risk associated with making database changes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 除了之前讨论的更常见的方法，以下提示和方法可能有助于减少处理数据库时的工作量，或帮助减少与数据库变更相关的风险。
- en: Minimizing the influence of databases
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小化数据库的影响
- en: A first step in dealing with databases can be to reduce the chance that a database
    change has to be made. In many databases, it is possible to write stored procedures—or
    some other code or script—that executes within the database engine. While stored
    procedures come with some benefits, changing them can also count as a database
    schema change, or at the least, result in changes that can be difficult to test.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 处理数据库的第一步可以是减少需要进行数据库变更的可能性。在许多数据库中，可以编写存储过程——或者其他一些在数据库引擎中执行的代码或脚本。虽然存储过程带来了一些好处，但更改它们也可能算作数据库模式变更，或者至少会导致一些难以测试的变更。
- en: One simple approach for this is to just replace stored procedures with application
    code that allows for easier side-by-side changes using feature toggles.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的方法是将存储过程替换为应用程序代码，使用功能切换可以更轻松地进行并行变更。
- en: Full side-by-side deployment
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 完全并行部署
- en: 'When working in a high-risk environment, or with a fragile database, there
    is also another approach to database schema changes that can be taken. This approach
    is based on applying feature toggles and the blue-green deployment pattern and
    goes as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在高风险环境中，或与脆弱数据库一起工作时，还可以采取另一种数据库模式变更方法。此方法基于应用功能切换和蓝绿部署模式，步骤如下：
- en: Change the application code in such a way that it writes any update to not just
    one but two databases.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改应用程序代码，使其不仅将更新写入一个数据库，而是写入两个数据库。
- en: In the production environment, create a complete, full copy of the existing
    database and configure the application code to write all changes to both databases.
    These databases will be called *old* and *new*, from now on.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生产环境中，创建现有数据库的完整副本，并配置应用程序代码将所有更改写入两个数据库。从现在开始，这两个数据库将分别称为*旧*数据库和*新*数据库。
- en: Introduce the required changes to the new database schema and the application
    code *only* in the path that writes to the new database.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅在写入新数据库的路径中引入所需的数据库模式和应用程序代码变更。
- en: Introduce the necessary changes in all code paths that read data in such a way
    that all queries run against both databases.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有读取数据的代码路径中引入必要的变更，确保所有查询都同时在两个数据库中运行。
- en: Update the application code to detect differences in the query results between
    the new and old databases and log an error when it finds any discrepancy.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新应用程序代码，以检测新旧数据库之间查询结果的差异，并在发现任何不一致时记录错误。
- en: If the changes run without any issues, remove the old database, and the old
    read and write access paths, from the application code.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果变更没有问题，删除旧数据库和应用程序代码中的旧读写访问路径。
- en: If the changes run with errors, fix the issues. Then, restart by restoring the
    backup of the intended new database, and resume at *step 5*.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果变更运行时出现错误，修复问题。然后，通过恢复预定新数据库的备份来重新启动，并从*第5步*继续。
- en: The advantage of this approach is that it is very lightweight. The downside
    is that it is very involved, takes a lot of work, and is more expensive. Also,
    the extra database costs and duration of backup and restore operations should
    be taken into account.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是非常轻量级。缺点是它涉及的工作量很大，需要很多努力，而且成本更高。此外，还应考虑额外的数据库费用以及备份和恢复操作的持续时间。
- en: Testing database changes
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试数据库变更
- en: Just as with application code, insights into the quality of database schema
    changes can be gathered through testing. Links to performing tests on database
    schemas can be found at the end of this chapter.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与应用程序代码一样，数据库模式变更的质量可以通过测试获得洞察。关于如何对数据库模式进行测试的链接可以在本章末尾找到。
- en: In most cases, in order to fully cover the risks introduced by database changes,
    system tests are needed that execute against a fully deployed stack of the application.
    This type of test can cover most of the risks that come from faulty schemas, invalid
    stored procedures, and database and application code mismatches.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，为了充分覆盖数据库变更带来的风险，需要执行针对完整应用程序堆栈的系统测试。这种测试可以覆盖由错误模式、无效存储过程以及数据库和应用程序代码不匹配引起的大多数风险。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have learned how to manage your database schema and schema
    changes using source control. You know about both the migration-based approach
    and state-based approach for storing changes, and how to apply them to your production
    database in a safe manner.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经学习了如何使用源代码控制来管理数据库模式及其变更。你了解了基于迁移的方法和基于状态的方法来存储变更，以及如何以安全的方式将它们应用到生产数据库中。
- en: Additionally, you have learned how schema-less databases can remove the burden
    of traditional schema management. However, this comes at the price of having to
    cope with schema differences when reading older versions of an object back from
    the database.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您已经了解了无模式数据库如何减轻传统模式管理的负担。然而，这也意味着在从数据库中读取旧版本的对象时，必须应对模式差异的问题。
- en: In the next chapter, you will learn about continuous testing. You will not only
    learn about testing techniques, but also about which to apply at what point, and
    how testing is a crucial part of DevOps and a critical enabler of a continuous
    flow of value to end users.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，您将学习关于持续测试的内容。您不仅会了解测试技术，还会了解在何时应用哪些技术，以及测试如何成为 DevOps 中至关重要的一部分，并且是持续向最终用户交付价值的关键推动力。
- en: Questions
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter’s material. You will find the answers in the *Assessments*
    section of the Appendix:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们结束时，下面是一些问题供您测试自己对本章内容的理解。您可以在附录中的*评估*部分找到答案：
- en: 'True or false: When working with Entity Framework, schema management is built
    in using migrations-based support.'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断题：使用 Entity Framework 时，模式管理是通过基于迁移的支持内置的。
- en: 'True or false: When working with a migrations-based approach for schema management,
    you do not need extra tracking tables in your database schema.'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断题：使用基于迁移的方法进行模式管理时，您不需要在数据库模式中添加额外的跟踪表。
- en: 'True or false: When working with an end-state-based approach for schema management,
    you do not need extra tracking tables in your database schema.'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断题：使用基于最终状态的方法进行模式管理时，您不需要在数据库模式中添加额外的跟踪表。
- en: 'What are the benefits of a full side-by-side approach to database schema changes?
    (Choose multiple answers):'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完整并行的数据库模式变更方法有哪些好处？（选择多个答案）：
- en: The risks are reduced to almost zero.
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 风险几乎降到零。
- en: You can measure the actual performance impact of changes in a production-like
    environment.
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以在类似生产环境中衡量变更的实际性能影响。
- en: Side-by-side migrations reduce cycle time.
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并行迁移可以减少周期时间。
- en: 'True or false: Schema-less databases remove the need for thinking about schema
    changes completely.'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断题：无模式数据库完全消除了考虑模式变更的需要。
- en: What is a possible technology choice that you can make to limit the impact of
    changes on your database schema?
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以选择什么技术来限制变更对数据库模式的影响？
- en: Further reading
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: More information about Entity Framework and Entity Framework migrations can
    be found at [https://docs.microsoft.com/nl-nl/ef/](https://docs.microsoft.com/nl-nl/ef/)and
    [https://docs.microsoft.com/en-us/ef/ef6/modeling/code-first/migrations/](https://docs.microsoft.com/en-us/ef/ef6/modeling/code-first/migrations/).
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关 Entity Framework 和 Entity Framework 迁移的更多信息，请访问 [https://docs.microsoft.com/nl-nl/ef/](https://docs.microsoft.com/nl-nl/ef/)
    和 [https://docs.microsoft.com/en-us/ef/ef6/modeling/code-first/migrations/](https://docs.microsoft.com/en-us/ef/ef6/modeling/code-first/migrations/)。
- en: More information about Redgate and its database tooling can be found at [https://www.red-gate.com/](https://www.red-gate.com/).
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关 Redgate 及其数据库工具的更多信息，请访问 [https://www.red-gate.com/](https://www.red-gate.com/)。
- en: More information on SQL Server Data Tools can be found at [https://docs.microsoft.com/en-us/sql/ssdt/download-sql-server-data-tools-ssdt?view=sql-server-ver15](https://docs.microsoft.com/en-us/sql/ssdt/download-sql-server-data-tools-ssdt?view=sql-server-ver15).
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关 SQL Server 数据工具的更多信息，请访问 [https://docs.microsoft.com/en-us/sql/ssdt/download-sql-server-data-tools-ssdt?view=sql-server-ver15](https://docs.microsoft.com/en-us/sql/ssdt/download-sql-server-data-tools-ssdt?view=sql-server-ver15)。
- en: 'Build & Release Tools Azure DevOps extension: [https://marketplace.visualstudio.com/items?itemName=bendayconsulting.build-task&ssr=false#overview](https://marketplace.visualstudio.com/items?itemName=bendayconsulting.build-task&ssr=false#overview).'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建与发布工具 Azure DevOps 扩展：[https://marketplace.visualstudio.com/items?itemName=bendayconsulting.build-task&ssr=false#overview](https://marketplace.visualstudio.com/items?itemName=bendayconsulting.build-task&ssr=false#overview)。
- en: 'Database changes deployment with Redgate SQL Change Automation and Azure DevOps:
    [https://azuredevopslabs.com/labs/vstsextend/redgate/](https://azuredevopslabs.com/labs/vstsextend/redgate/).'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Redgate SQL Change Automation 和 Azure DevOps 部署数据库变更：[https://azuredevopslabs.com/labs/vstsextend/redgate/](https://azuredevopslabs.com/labs/vstsextend/redgate/)。
