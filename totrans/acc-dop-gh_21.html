<html><head></head><body>
		<div id="_idContainer230">
			<h1 id="_idParaDest-340"><em class="italic"><a id="_idTextAnchor342"/>Chapter 17</em>: Empower Your Teams</h1>
			<p>If my customers are not content with their architecture, I let them explain the organizational structure of their product and draw a diagram of it. If you compare this organizational chart with their architecture diagram, you always can find a lot of similarities. This <a id="_idIndexMarker1120"/>correlation between the organizational structure and software architecture is called <strong class="bold">Conway's law</strong>.</p>
			<p>In this chapter, you'll learn how you can leverage this correlation to improve your architecture, organization structure, and software delivery performance.</p>
			<p>The following are the core topics in this chapter:</p>
			<ul>
				<li>Conway's law</li>
				<li>The two-pizza team</li>
				<li>Inverse Conway Maneuver</li>
				<li>Delivery cadence</li>
				<li>A mono- or multi-repo strategy</li>
			</ul>
			<h1 id="_idParaDest-341"><a id="_idTextAnchor343"/>Conway's law</h1>
			<p>Conway's law<a id="_idIndexMarker1121"/> goes back to an essay from 1968 (<em class="italic">Conway, Melvin, 1968</em>, p31):</p>
			<p class="author-quote">"Organizations which design systems (…) are constrained to produce designs which are copies of the communication structure of the organizations." </p>
			<p class="author-quote">– Melvin E. Conway</p>
			<p>The <a id="_idIndexMarker1122"/>law is not specific to software or system architecture but to the design of any system. Note that it is not referring to an organization's management structure but its communication structure. These might be the same thing – but in some cases, it's not. Normally, if the organizational chart does not match the software design, you can look for the communication flow, and it is different from the organizational chart.</p>
			<p>If, for example, you have many small teams or individual developers that receive requirements from different customers or consultants, they will probably talk to each other without any organizational boundaries. The system they are working on will reflect that and consist of many modules with a high cohesion that reference each other – a so-called <em class="italic">spaghetti architecture</em>. Whereas <a id="_idIndexMarker1123"/>teams that work together and receive their input through one communication channel – for example, a product owner – will build a system with a high cohesion in the modules that the team works on. But the parts of the system the other teams work on will have fewer references. To put it in the words of <em class="italic">Eric S. Raymond</em>, "<em class="italic">if three teams are working on a compiler, you'll get a three-pass compiler</em>" (see <em class="italic">Raymond, Eric S. 1996</em>, p124). <em class="italic">Figure 17.1</em> visualizes these two examples:</p>
			<div>
				<div id="_idContainer219" class="IMG---Figure">
					<img src="image/B17827_17_001.jpg" alt="Figure 17.1 – Examples of the different software designs based on a communication structure&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.1 – Examples of the different software designs based on a communication structure</p>
			<p>But what is the<a id="_idIndexMarker1124"/> desired communication structure that will lead to a system design that helps teams to accelerate their engineering velocity?</p>
			<h1 id="_idParaDest-342"><a id="_idTextAnchor344"/>The two-pizza team</h1>
			<p>One of the <a id="_idIndexMarker1125"/>most discussed microservice-based architectures that allows thousands of deployments per day at a large scale is the architecture of <strong class="bold">Amazon</strong>. They use the <strong class="bold">two-pizza rule</strong> for their team setup (<em class="italic">Amazon, 2020</em>):</p>
			<p class="author-quote">"We try to create teams that are no larger than can be fed by two pizzas." </p>
			<p class="author-quote">– Jeff Bezos</p>
			<p>But how many people exactly can you feed with two pizzas? In our user groups, we always calculate one party pizza for three to four people. That would make a team size of six to eight people. At Giordano's in the US, they use the 3/8 rule – the number of pizzas you order should be three times the number of people to feed divided by eight:</p>
			<p>This would result in a maximum of 5 to 6 people in each team. So, the size of a two-pizza team is not very well defined – and I think it has nothing to do with the hunger of the team members. The rule just means that the team should be small.</p>
			<p>The problem with big teams is that the number of links in the team grows rapidly with every team member added. You can calculate the number of links using the following formula:</p>
			<p>Here, <em class="italic">n</em> is the <a id="_idIndexMarker1126"/>number of people in the team. This means that a team with 6 members has 15 links between the members – whereas a team of 12 already has 66 links (see <em class="italic">Figure 17.2</em>):</p>
			<div>
				<div id="_idContainer220" class="IMG---Figure">
					<img src="image/B17827_17_002.jpg" alt="Figure 17.2 – The number of links between the members of a team&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.2 – The number of links between the members of a team</p>
			<p>If people <a id="_idIndexMarker1127"/>work in teams, they experience a positive synergy. The diversity and communication help to increase quality as well as the outcome. But if you add more people to the team, communication overhead and slower decision-making lead to a negative synergy (see <em class="italic">Figure 17.3</em>):</p>
			<div>
				<div id="_idContainer221" class="IMG---Figure">
					<img src="image/B17827_17_003.jpg" alt="Figure 17.3 – Effectiveness of collaboration and team size&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.3 – Effectiveness of collaboration and team size</p>
			<p>But what is the magic number – the optimum number of people for a team?</p>
			<p>The US Navy Seals state that four is the optimal size for a combat team (<em class="italic">Willink, J. and Leif Babin, L., 2017</em>). They also rely on high-frequency communication in a complex environment. But the skills of a combat team are probably more linear than those of a cross-functional development team. So, there is no evidence that the number is also optimum for development teams.</p>
			<p>In Scrum, <strong class="bold">Miller's law</strong> states <a id="_idIndexMarker1128"/>that the magical number seven, plus or minus two (<em class="italic">Miller, G.A., 1956</em>), is used to define the recommended team size. Miller's law is an essay from 1956 on the limitations of our short memory that was associated with communication capabilities. But Miller's law was scientifically refuted, and the reason that Scrum<a id="_idIndexMarker1129"/> still uses the numbers is that five to nine is simply a good team size in many circumstances – but without any scientific substantiation. There are also high-performance scrum teams with only 3 members – and others with 14 members.</p>
			<p>There is a<a id="_idIndexMarker1130"/> study from QSM analyzing 491 development projects. The study concludes that smaller teams have higher productivity, less development effort, and a better development schedule (<em class="italic">QSM, 2011</em>). The clusters of a team with 1.5 to 3 people, 3 to 5 people, and 5 to 7 people were close together. More than seven people led to a dramatic increase in development effort (see <em class="italic">Figure 17.4</em>):</p>
			<div>
				<div id="_idContainer222" class="IMG---Figure">
					<img src="image/B17827_17_004.jpg" alt="Figure 17.4 – A summary of the results of the QSM study&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.4 – A summary of the results of the QSM study</p>
			<p>There are several reasons why smaller teams perform better than larger teams (see <em class="italic">Cohn M., 2009</em>, pp177–180):</p>
			<ul>
				<li><strong class="bold">Social loafing</strong>: Social loafing is a<a id="_idIndexMarker1131"/> phenomenon where persons tend to exert less effort to achieve a goal when they work in a group where individual performance cannot be measured (<em class="italic">Karau, S.J., and Williams, K.D., 1993</em>). Smaller groups tend to be less affected by social loafing.</li>
				<li><strong class="bold">Cohesion and ownership</strong>: Smaller teams have more constructive interactions, and it is easier for the members to build feelings of trust, mutual ownership, and cohesiveness (<em class="italic">Robbins S., 2005</em>).</li>
				<li><strong class="bold">Coordination effort</strong>: In a smaller team, there is less time spent on coordination. Simple things – such as coordinating a meeting – tend to be much more complex in larger teams.</li>
				<li><strong class="bold">More rewarding</strong>: The contributions of an individual are more visible in smaller teams. This, and the better social cohesiveness, lead to a more rewarding environment if the team<a id="_idIndexMarker1132"/> size is smaller (<em class="italic">Steiner, I.D., 1972</em>).</li>
			</ul>
			<p>Of course, smaller teams have also some disadvantages. The biggest is the risk of <strong class="bold">losing one or more team members</strong>, which is much harder to be compensated for in smaller teams. Another disadvantage is <strong class="bold">the lack of certain expert skills</strong>. If you need deep expertise in five areas, it is nearly impossible to deliver it with a three-member team.</p>
			<p>Looking at this data, the optimal size for a two-pizza team is somewhere between three and seven – balancing the advantages and disadvantages, depending on your environment.</p>
			<h1 id="_idParaDest-343"><a id="_idTextAnchor345"/>Inverse Conway Maneuver</h1>
			<p>Now that we know <a id="_idIndexMarker1133"/>the optimal size for our teams, we can perform something that is called the <strong class="bold">Inverse Conway Maneuver</strong> (<em class="italic">Forsgren N., Humble, J., and Kim, G., 2018</em>, page 102). If you evolve your organization structure to autonomous two-pizza teams, your architecture evolves into a more loosely coupled one.</p>
			<p>But it's not just the team size! If you create your teams around functionalities, it will result in a layered or multi-tier architecture. If you put frontend developers and database specialists in teams, your architecture will decouple at these communication points (see <em class="italic">Figure 17.5</em>):</p>
			<div>
				<div id="_idContainer223" class="IMG---Figure">
					<img src="image/B17827_17_005.jpg" alt="Figure 17.5 – Functional teams lead to a layered architecture&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.5 – Functional teams lead to a layered architecture</p>
			<p>To achieve a<a id="_idIndexMarker1134"/> deployable and testable architecture that empowers the teams, you must create cross-functional teams responsible for business outcomes. This will lead to the desired architecture that helps you to move fast (see <em class="italic">Figure 17.6</em>):</p>
			<div>
				<div id="_idContainer224" class="IMG---Figure">
					<img src="image/B17827_17_006.jpg" alt="Figure 17.6 – Cross-functional teams aligned around business capabilities for fast value delivery&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.6 – Cross-functional teams aligned around business capabilities for fast value delivery</p>
			<p>There are four types of team topologies that have a positive impact on system architecture and, therefore, software delivery performance (<em class="italic">Skelton M., and Pais M., 2019</em>):</p>
			<ul>
				<li><strong class="bold">Value stream-aligned</strong>: This is<a id="_idIndexMarker1135"/> the most important team topology – cross-functional teams that can deliver significant value to their customers without relying on other teams to do so. These teams need all required skills to deliver value – for example, UX, QA, DBA, and operational skills.</li>
				<li><strong class="bold">Platform teams</strong>: Teams that<a id="_idIndexMarker1136"/> build the platform that enables the value stream-aligned teams to deliver value by reducing complexity and simplifying the software delivery process.</li>
				<li><strong class="bold">Enabling teams</strong>: Teams <a id="_idIndexMarker1137"/>that enable other teams to take responsibility as part of an onboarding, transitional, or training phase.</li>
				<li><strong class="bold">Subsystem team</strong>: This<a id="_idIndexMarker1138"/> team type should only be created if absolutely necessary! If a subsystem is too complicated to be handled by stream-aligned teams or platform teams, it might be preferable to have a functional team that handles this subsystem.</li>
			</ul>
			<p>It is important that each team has a clear responsibility and can deliver value without relying on other teams to finish certain tasks.</p>
			<p>But to achieve the desired effect on performance, you have to limit how the teams interact to one of the following three <strong class="bold">modes of interaction</strong>:</p>
			<ul>
				<li><strong class="bold">Collaboration</strong>: Two or<a id="_idIndexMarker1139"/> more teams work closely together for a certain time and share the responsibility.</li>
				<li><strong class="bold">Self-service</strong>: A team <a id="_idIndexMarker1140"/>provides its value to another team as a service. The responsibilities are clearly separated, and the service can be consumed as easily and automated as possible.</li>
				<li><strong class="bold">Facilitating</strong>: One team<a id="_idIndexMarker1141"/> enables another team and helps them for a certain time to learn new things or develop new habits.</li>
			</ul>
			<p>Building an effective team topology with good, well-defined communication and interaction has a huge influence – not only on the system architecture but also on the engineering velocity.</p>
			<h1 id="_idParaDest-344"><a id="_idTextAnchor346"/>Delivery cadence</h1>
			<p>Even with <a id="_idIndexMarker1142"/>cross-functional, autonomous teams, you'll still have some interdependencies and communication flow occurring between the teams. In the first chapters of this book, when I explained the flow of work and metrics, I focused on efficiency, flow, batch size, and a continuous delivery value. But you still need some cadence to control your flow. In <a id="_idIndexMarker1143"/>Scrum, this is <a id="_idIndexMarker1144"/>called <strong class="bold">empirical process control</strong>. After a certain time, you pause to <strong class="bold">inspect</strong> and <strong class="bold">adopt</strong> – not only what you deliver but also your process and team dynamics. This time span is called<a id="_idIndexMarker1145"/> a <strong class="bold">sprint</strong> in Scrum. I don't like that term because it implies a fast pace, and development should have a constant, steady pace. You don't sprint if you want to run a marathon – and product development is a marathon and not a series of sprints (but a marathon does not match with the analogy of rugby, of course). But no matter what you call these intervals, they are important for continuous learning and adoption and team building. These intervals are also important to communicate – to stakeholders and other teams.</p>
			<p>That's why these intervals should be aligned across all teams. They should determine the steady cadence and act as the heartbeat of the engineering organization.</p>
			<p>The intervals<a id="_idIndexMarker1146"/> should not be too long and not too short. A month would be the maximum and a minimum of 2 weeks for most companies. That does not mean that teams can't do smaller iterations or sprints. They can still do 1-week sprints; they just would align them with the global cadence. You can have a faster pace and align it to a slower cadence – but not vice versa (see <em class="italic">Figure 17.7</em>):</p>
			<div>
				<div id="_idContainer225" class="IMG---Figure">
					<img src="image/B17827_17_007.jpg" alt="Figure 17.7 – Aligning faster iterations with the delivery cadence&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.7 – Aligning faster iterations with the delivery cadence</p>
			<p>In this case, <em class="italic">x</em> does not necessarily have to be measured in weeks. When defining the cadence, think about the <strong class="bold">pulse of the entire organization</strong>. If everything in your organization runs on a monthly basis, then a 3-week cadence would not be in sync with the rest of your company. In this case, defining a monthly cadence – or a fraction of it – is the better choice and causes less friction. If your company is publicly traded and uses the 4-4-5 calendar, a fiscal quarter might be your pulse. Have a look at the organization pulse and sync your sprint cadence with it so that the intervals are in harmony with the organization pulse (see <em class="italic">Figure 17.8</em>):</p>
			<div>
				<div id="_idContainer226" class="IMG---Figure">
					<img src="image/B17827_17_008.jpg" alt="Figure 17.8 – Align your cadence to be in sync with the organization pulse&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.8 – Align your cadence to be in sync with the organization pulse</p>
			<p>If your <a id="_idIndexMarker1147"/>cadence is not in sync with your organization, it will generate friction. Meetings will conflict, and feedback and numbers might not be available when you need them. A consistent cadence in sync with your organizational pulse will help to smooth out flow and improve communication (<em class="italic">Reinertsen D., 2009</em>, pp176–78).</p>
			<h1 id="_idParaDest-345"><a id="_idTextAnchor347"/>A mono- or multi-repo strategy</h1>
			<p>Besides team size and cadence, the way you structure your code has also an impact on your architecture if you want to perform the Inverse Conway Maneuver. There are two strategies:</p>
			<ul>
				<li><strong class="bold">A mono-repo strategy</strong>: There is <a id="_idIndexMarker1148"/>only one repository that contains all modules (or microservices) that are needed by an application.</li>
				<li><strong class="bold">A multi-repo strategy</strong>: Each <a id="_idIndexMarker1149"/>module or microservice lives in its own repository, and you must deploy multiple repositories to get a complete working application.</li>
			</ul>
			<p>Both strategies have advantages and disadvantages. The biggest advantage of the mono-repo strategy is that it is easy to deploy and debug the entire application. But mono repos tend to get very large very fast, and that reduces the performance of Git. Also, deploying and testing different parts of the application independently becomes difficult with a growing repository. This leads to a tighter coupling of the architecture.</p>
			<h2 id="_idParaDest-346"><a id="_idTextAnchor348"/>Working with large mono repositories</h2>
			<p>What does big repo mean<a id="_idIndexMarker1150"/> in the context of Git? The repo of the Linux kernel is about 3 GB. It takes quite some time to clone, and the individual Git commands are slow – but still in an acceptable range. The Windows repository has about 300 GB – 100 times the Linux kernel. Performing certain Git actions on the Windows repository takes some time:</p>
			<ul>
				<li><strong class="source-inline">git clone</strong>: About 12 hours</li>
				<li><strong class="source-inline">git checkout</strong>: About 3 hours</li>
				<li><strong class="source-inline">git status</strong>: About 8 minutes</li>
				<li><strong class="source-inline">git add and git commit</strong>: About 3 minutes</li>
			</ul>
			<p>That's why Microsoft maintains its own fork of the Git client (<a href="https://github.com/microsoft/git">https://github.com/microsoft/git</a>). This fork contains a lot of optimizations for large repositories. It includes <a id="_idIndexMarker1151"/>the <strong class="bold">scalar CLI</strong> (<a href="https://github.com/microsoft/git/blob/HEAD/contrib/scalar/docs/index.md">https://github.com/microsoft/git/blob/HEAD/contrib/scalar/docs/index.md</a>) that can be used to set advanced Git config settings, maintain the repository in the background, and help to reduce data sent across the network. These improvements reduce the time for the Git actions in the Windows repository enormously:</p>
			<ul>
				<li><strong class="source-inline">git clone</strong>: 12 hours to 90 seconds</li>
				<li><strong class="source-inline">git checkout</strong>: 3 hours to 30 seconds</li>
				<li><strong class="source-inline">git status</strong>: 8 minutes to 3 seconds</li>
			</ul>
			<p>Many of these optimizations are already part of the Git client now. You can use, for example, <strong class="source-inline">git sparse-checkout</strong> (<a href="https://git-scm.com/docs/git-sparse-checkout">https://git-scm.com/docs/git-sparse-checkout</a>), which allows you to only download the parts of your repository that you need.</p>
			<p>You only need the<a id="_idIndexMarker1152"/> Microsoft fork if your repository is really huge; otherwise, you can probably optimize using the normal Git features.</p>
			<h2 id="_idParaDest-347"><a id="_idTextAnchor349"/>Organizing your repos with topics and star lists</h2>
			<p>The<a id="_idIndexMarker1153"/> biggest advantage of the multi-repo strategy is that you reduce the complexity of the individual repositories. Each repository can be maintained and deployed autonomously. The biggest disadvantage is that it is hard to build and test the entire application. But to get feedback from real users or to debug complex bugs, it is normally not enough to deploy an individual service or module – you need to update the entire application. This means coordinating multiple deployments across your repo boundaries.</p>
			<p>If you choose the<a id="_idIndexMarker1154"/> multi-repo strategy, you'll end up with many small<a id="_idIndexMarker1155"/> repositories. A good naming convention can help to structure them. You can also use <strong class="bold">topics</strong> to organize your repos. Topics can be set at the top-right corner of your repo (see <em class="italic">Figure 17.9</em>).</p>
			<div>
				<div id="_idContainer227" class="IMG---Figure">
					<img src="image/B17827_17_009.jpg" alt="Figure 17.9 – You can set topics for your repositories for better discoverability&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.9 – You can set topics for your repositories for better discoverability</p>
			<p>You can filter your repositories using the <strong class="source-inline">topic</strong>: keyword (see <em class="italic">Figure 17.10</em>):</p>
			<div>
				<div id="_idContainer228" class="IMG---Figure">
					<img src="image/B17827_17_010.jpg" alt="Figure 17.10 – Filter repositories based on topics&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.10 – Filter repositories based on topics</p>
			<p>Another feature<a id="_idIndexMarker1156"/> that you can use to organize large numbers of <a id="_idIndexMarker1157"/>repositories is <strong class="bold">star lists</strong>. This is a personal feature and cannot be shared. In your GitHub profile, you can create lists and organize your starred repositories (see <em class="italic">Figure 17.11</em>):</p>
			<div>
				<div id="_idContainer229" class="IMG---Figure">
					<img src="image/B17827_17_011.jpg" alt="Figure 17.11 – Organize your starred repositories in lists&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 17.11 – Organize your starred repositories in lists</p>
			<p>You can use these features like favorites in your browser, but they do not solve the problem of deploying, debugging, or testing your entire application.</p>
			<p>If you are using Kubernetes for your<a id="_idIndexMarker1158"/> microservices, you can use the <strong class="bold">Bridge to Kubernetes</strong> plugin (<a href="https://marketplace.visualstudio.com/items?itemName=mindaro.mindaro">https://marketplace.visualstudio.com/items?itemName=mindaro.mindaro</a>) in Visual Studio Code to debug a local service in the context of a production or test cluster (see <em class="italic">Medina A. M., 2021</em>). But if you rely on building and deploying all services at once, the best solution is to have a meta-repository that references all services as a submodule.</p>
			<h2 id="_idParaDest-348"><a id="_idTextAnchor350"/>Using Git submodules to structure your code</h2>
			<p>You <a id="_idIndexMarker1159"/>can use a meta-repository that contains all<a id="_idIndexMarker1160"/> other repositories as submodules. This allows you to clone all repositories with one command:</p>
			<p class="source-code">$ git clone --recurse-submodules</p>
			<p>Alternatively, to update the meta-repository if you already have it cloned, use this command:</p>
			<p class="source-code">$ git submodule update --init --recursive</p>
			<p>The repository can contain the scripts or workflows to deploy the application as a whole.</p>
			<p>You can use this meta-repository to do the release management and bundle the stable versions together. If you use branches for releases, then you can set your submodule to a certain branch and update it before you release the latest version:</p>
			<p class="source-code">$ git config -f .gitmodules submodule.&lt;SUB&gt;.branch main</p>
			<p class="source-code">$ git submodule update --remote</p>
			<p>If you use tags for releases, then you can set each submodule to a specific version and commit this to your meta-repository:</p>
			<p class="source-code">$ cd &lt;SUB&gt;</p>
			<p class="source-code">$ git checkout &lt;TAG&gt;</p>
			<p class="source-code">$ cd ..</p>
			<p class="source-code">$ git add &lt;SUB&gt;</p>
			<p class="source-code">$ git commit -m "Update &lt;SUB&gt; to &lt;TAG&gt;"</p>
			<p class="source-code">$ git push</p>
			<p>Other people can then pull the changes and update the submodules to the version corresponding to the tag:</p>
			<p class="source-code">$ git pull</p>
			<p class="source-code">$ git submodule update --init --recursive</p>
			<p>Git submodules are a nice way to work in multi-repos and deploy independently while still being able to<a id="_idIndexMarker1161"/> manage an application as a whole. But be <a id="_idIndexMarker1162"/>aware that the more interdependencies you have, the more complex the maintenance of the meta-repos and keeping them in a deployable state will be.</p>
			<h2 id="_idParaDest-349"><a id="_idTextAnchor351"/>What's the right strategy?</h2>
			<p>If the mono-repo strategy<a id="_idIndexMarker1163"/> or the <a id="_idIndexMarker1164"/>multi-repo strategy are better suited for your teams it tightly couples to <a href="B17827_16_Epub.xhtml#_idTextAnchor335"><em class="italic">Chapter 16</em></a>, <em class="italic">Loosely C</em><em class="italic">oupled Architecture and Microservices</em>, when we talked about <strong class="bold">evolutionary design</strong>. Mono-repos<a id="_idIndexMarker1165"/> are good for small products and greenfield projects. With growing size and complexity, it's best to split microservices or modules up and move them to their own repos. But always have testability and deployability in mind – for the individual service/module and for the application as a whole.</p>
			<h1 id="_idParaDest-350"><a id="_idTextAnchor352"/>Case study</h1>
			<p>After the first three successful sprints, more teams<a id="_idIndexMarker1166"/> at <strong class="bold">Tailwind Gears</strong> are moved to a new platform. The first teams have been selected to own a product that is already independently testable and deployable. With the scrum master, product owner, and QA member, they are a little big for the two-pizza rule, but this will be addressed later. The teams to follow are way too big, and they work on big monolith applications with a lot of interdependencies. To perform the Inverse Conway Maneuver, all the teams come together and self-organize the next teams to be moved to the new platform. The constraints are as follows:</p>
			<ul>
				<li>No bigger than a two-pizza team</li>
				<li>Responsible for a business capability (a <strong class="bold">bounded context</strong>) that can be extracted using the <strong class="source-inline">StranglerFigApplication</strong> pattern and be tested and deployed autonomously</li>
			</ul>
			<p>This helps to evolve the design of the applications. The new microservices are cloud-native and have their own cloud-native data store. They get integrated into the existing applications using an API and event-driven architecture. The microservices are moved to their own repositories on the new platform because they get deployed independently most of the time. Synchronization with the other teams is done using feature flags.</p>
			<p>For embedded software, this does not work. The teams need a way to build and deploy the application as a whole. But they also want to deploy and test individual modules. That's why the teams decide to split the application into different repositories and have one meta-repository that includes the other repos as submodules. This allows the individual teams to deploy their module to test hardware at any time to test new features in real-world scenarios – but it keeps the product in state, where it can be released at any time.</p>
			<p>When the first teams were moved to the new platform, they kept their existing <strong class="bold">sprint cadence</strong> of 3 weeks. Since the teams could work more or less autonomously, this was not a problem. With more teams coming to the new platform, the cadence gets aligned with the other teams. Tailwind Gears is a public traded company and used to do all its business reporting on a quarterly basis. They also report on a weekly basis and have a normalized 4-4-5 calendar. There are a lot of meetings at the end and beginning of each quarter that often collide with<a id="_idIndexMarker1167"/> sprint meetings. The teams decide to adjust their cadence to this rhythm. The quarter consists of 13 weeks – but one week has the quarterly meeting, so this week is stripped from the sprint calendar. This week is also used for the quarterly big-room planning. The remaining 12 weeks are divided into 6 two-week sprints.</p>
			<h1 id="_idParaDest-351"><a id="_idTextAnchor353"/>Summary</h1>
			<p>In this chapter, you've learned how to use the influence of your team structure and communication flow on your software and system architecture to perform the Inverse Conway Maneuver. This helps you to achieve a loosely coupled architecture of autonomously testable and deployable units that have a positive impact on your software delivery performance.</p>
			<p>In the next chapters, we'll focus more on what to build and less on how to build it. You'll learn about lean product development and how to incorporate customer feedback in your work.</p>
			<h1 id="_idParaDest-352"><a id="_idTextAnchor354"/>Further reading</h1>
			<p>These are the references from this chapter that you can also use to get more information on the topics:</p>
			<ul>
				<li>Conway, Melvin (1968). <em class="italic">How do committees invent</em>: <a href="http://www.melconway.com/Home/pdf/committees.pdf">http://www.melconway.com/Home/pdf/committees.pdf</a></li>
				<li>Raymond, Eric S. (1996). <em class="italic">The New Hacker's Dictionary</em> [3rd ed.]. MIT Press</li>
				<li>Amazon (2020): <em class="italic">Introduction to DevOps on AWS</em> - <em class="italic">Two-Pizza Teams</em>: <a href="https://docs.aws.amazon.com/whitepapers/latest/introduction-devops-aws/two-pizza-teams.html">https://docs.aws.amazon.com/whitepapers/latest/introduction-devops-aws/two-pizza-teams.html</a></li>
				<li>Willink, J. and Leif Babin, L. (2017). <em class="italic">Extreme Ownership: How U.S. Navy SEALs Lead and Win</em>. Macmillan</li>
				<li>Miller, G.A. (1956). <em class="italic">The magical number seven, plus or minus two: Some limits on our capacity for processing information</em>: <a href="http://psychclassics.yorku.ca/Miller/">http://psychclassics.yorku.ca/Miller/</a></li>
				<li>Cohn M. (2009). <em class="italic">Succeeding with Agile: Software Development Using Scrum</em>. Addison-Wesley</li>
				<li>QSM (2011). <em class="italic">Team Size Can Be the Key to a Successful Software Project</em>: <a href="https://www.qsm.com/process_improvement_01.html">https://www.qsm.com/process_improvement_01.html</a></li>
				<li>Karau, S. J. and Williams, K. D. (1993). <em class="italic">Social loafing: A meta-analytic review and theoretical integration</em>. <em class="italic">Journal of Personality and Social Psychology</em>, 65(4), 681–706. <a href="https://doi.org/10.1037/0022-3514.65.4.681">https://doi.org/10.1037/0022-3514.65.4.681</a></li>
				<li>Robbins S. (2005). <em class="italic">Essentials of organizational behavior</em>. Prentice Hall</li>
				<li>Steiner, I.D. (1972). <em class="italic">Group process and productivity</em>. Academic Press Inc.</li>
				<li>Forsgren N., Humble, J., and Kim, G. (2018). <em class="italic">Accelerate: The Science of Lean Software and DevOps: Building and Scaling High Performing Technology Organizations</em> (1st ed.) [E-book]. IT Revolution Press</li>
				<li>Skelton M. and Pais M. (2019). <em class="italic">Team Topologies: Organizing Business and Technology Teams for Fast Flow</em>. IT Revolution</li>
				<li>Reinertsen D. (2009). <em class="italic">The Principles of Product Development Flow: Second Generation Lean Product Development</em>. Celeritas Publishing</li>
				<li>Medina A. M. (2021). <em class="italic">Remote debugging on Kubernetes using VS Code</em>: <a href="https://developers.redhat.com/articles/2021/12/13/remote-debugging-kubernetes-using-vs-code">https://developers.redhat.com/articles/2021/12/13/remote-debugging-kubernetes-using-vs-code</a></li>
			</ul>
		</div>
	</body></html>