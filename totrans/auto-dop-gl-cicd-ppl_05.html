<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer056">
			<h1 id="_idParaDest-105" class="chapter-number"><a id="_idTextAnchor110"/>5</h1>
			<h1 id="_idParaDest-106"><a id="_idTextAnchor111"/>Installing and Configuring GitLab Runners</h1>
			<p><a id="_idTextAnchor112"/>In <a href="B18073_04.xhtml#_idTextAnchor084"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, you learned about the fundamentals of GitLab CI/CD. We defined and introduced the vocabulary and concepts around CI/CD pipelines, which included CI/CD pipeline components, different pipeline types, how to observe and interact with pipelines in the GitLab UI, and how to write a pipeline’s configuration using the <strong class="source-inline">.gitlab-ci.yml</strong> file. A few paragraphs were also spent introducing GitLab Runner as the crucial component of GitLab CI/CD, which actually runs pipeline tasks and reports the results back <span class="No-Break">to GitLab.</span></p>
			<p>The sole focus of this chapter will be the topic of GitLab runners. You will learn in this chapter that GitLab runners act as the “muscle” in the CI/CD process. Runners are small programs that are installed separately from the main GitLab application. Their purpose is to receive new CI/CD jobs published by GitLab and follow the jobs’ instructions as specified in the <strong class="source-inline">.gitlab-ci.yml</strong> file. Runners can be installed and configured to work with a variety of types of infrastructure, including standalone servers, VMs, containers, <span class="No-Break">and others.</span></p>
			<p>We’ll begin by introducing the runner architecture as well as comparing and contrasting GitLab Runner with other tools that you may be familiar with. Next, we’ll describe installing and configuring runners so they can be paired with GitLab to run CI/CD jobs. Finally, we’ll end with discussing best practices for using different runner types for <span class="No-Break">different circumstances.</span></p>
			<p>Once you have learned how to install, configure, use, and maintain GitLab runners, you will be well on your way to managing the end-to-end life cycle for building, testing, and deploying your application. Here is how we’ll cover the topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Defining GitLab runners and their relationship <span class="No-Break">to CI/CD</span></li>
				<li>The runner architecture and <span class="No-Break">supported platforms</span></li>
				<li>Installing the <span class="No-Break">Runner agent</span></li>
				<li>Configuring and registering the runner <span class="No-Break">with GitLab</span></li>
				<li>Understanding when and why to use the various runner types <span class="No-Break">and executors</span></li>
			</ul>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor113"/>Technical requirements</h1>
			<p>Like the previous chapters, you’ll get the most out of this chapter if you have an account on a GitLab instance <strong class="bold">software-as-a-service</strong> (<strong class="bold">SaaS</strong>) or self-managed). In addition, installing the GitLab Runner agent requires a computer (Windows, Mac, or Linux) on which to install the runner binary. A personal laptop would be fine—the runner is lightweight and its system requirements are minimal. If you are using GitLab.com, CI/CD pipelines can also be run using GitLab’s SaaS runners, though be aware of possible <span class="No-Break">usage charges.</span></p>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor114"/>Defining GitLab runners and their relationship to CI/CD</h1>
			<p>Recall that GitLab CI/CD<a id="_idIndexMarker319"/> is a series of tasks performed against code in your project, which<a id="_idIndexMarker320"/> often include some combination of build, test, and deploy jobs. Importantly, CI/CD pipelines are not run inside the GitLab application, as each job will generally require some specific platform and set of tools to <span class="No-Break">successfully run.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">GitLab runners are programs that accept CI/CD jobs from GitLab, run the jobs’ tasks in an appropriate execution environment, and then report the results back <span class="No-Break">to GitLab.</span></p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor115"/>GitLab Runner is an open source application written in Go</h2>
			<p>The official repository<a id="_idIndexMarker321"/> for the GitLab Runner application lives<a id="_idIndexMarker322"/> in a project hosted on <a href="http://GitLab.com">GitLab.com</a> called <strong class="source-inline">gitlab-runner</strong>. At the time of writing, you can navigate to <a href="https://gitlab.com/gitlab-org/gitlab-runner">https://gitlab.com/gitlab-org/gitlab-runner</a> to view the project’s development and source code. Like the main GitLab application, GitLab Runner follows a monthly release cadence. The latest version of GitLab Runner is <em class="italic">usually</em> the same major and minor release number as GitLab, though that is not guaranteed to always be the case. Like most of GitLab, GitLab Runner is open source and distributed under the <span class="No-Break">MIT license.</span></p>
			<p>A perusal of the code base referenced<a id="_idIndexMarker323"/> in the previous URL shows us that Gitlab Runner<a id="_idIndexMarker324"/> is written in the Go programming language. The program is compatible with most major computer architectures (x86, AMD64, ARM, and so on) and operating systems (Windows, macOS, and Linux)—really, just about anywhere that supports installing Go binaries. We’ll soon see that installing the runner executable is straightforward and requires <span class="No-Break">few dependencies.</span></p>
			<h2 id="_idParaDest-110"><a id="_idTextAnchor116"/>GitLab Runner runs CI/CD jobs specified in .gitlab-ci.yml</h2>
			<p>Recall from the previous chapter that GitLab CI/CD pipelines<a id="_idIndexMarker325"/> comprise stages and jobs<a id="_idIndexMarker326"/> defined in <strong class="source-inline">.gitlab-ci.yml</strong>. Each job contains a set of instructions, which is often shell-style commands to be run in sequence. By default, every new commit to a branch where a <strong class="source-inline">.gitlab-ci.yml</strong> file is defined launches a new pipeline run. That means the jobs in <strong class="source-inline">.gitlab-ci.yml</strong> will be scheduled to run following the order and logic specified in <span class="No-Break">the configuration.</span></p>
			<p>During a CI/CD pipeline run, when a job arrives at its “turn,” the job will be assigned to an available GitLab runner that is able to run the job’s instructions. One job gets assigned to one runner. After the runner receives the job from GitLab, one of the first things it will do is fetch the commit that launched the pipeline, so it has the relevant snapshot of the code base. The runner may then perform steps such as compiling a build, running unit tests, running security scans, or deploying the application to some kind of environment. Remember, the runner just follows the job’s instructions from <strong class="source-inline">.gitlab-ci.yml</strong>. Once the runner completes the tasks specified in the job, it will report the results back to GitLab. That will almost always include returning a pass or fail status, as well as any artifacts generated or modified during <span class="No-Break">job execution.</span></p>
			<p>As discussed near the beginning of <a href="B18073_04.xhtml#_idTextAnchor084"><span class="No-Break"><em class="italic">Chapter 4</em></span></a> (see the <em class="italic">Viewing a list of pipelines</em> section), the pipeline status and job execution can be monitored in real time via the GitLab UI. The runner constantly communicates with GitLab, and from the UI, you can view available runners, modify runner settings, intervene with pipeline and job execution, view uploaded artifacts, and more. One way to think about the relationship between GitLab’s CI/CD components is to think of runners as the muscles that follow the instructions of <strong class="source-inline">.gitlab-ci.yml</strong> (the brain). GitLab would then be like the nervous system, which coordinates the communication between the brain (the pipeline configuration) and the<a id="_idIndexMarker327"/> muscles (the runners doing<a id="_idIndexMarker328"/> the heavy lifting of running <span class="No-Break">CI/CD jobs).</span></p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor117"/>The runner architecture and supported platforms</h1>
			<p>Before going into further<a id="_idIndexMarker329"/> details about runner components, installation, and configuration<a id="_idIndexMarker330"/>, it’s worth clarifying a few pieces of terminology. So far in this chapter, the words <em class="italic">GitLab Runner</em> and <em class="italic">runner</em> may appear to have been used interchangeably. However, a bit of nuance is required. <em class="italic">GitLab Runner</em> refers to the application installed once on a computer. Once the GitLab Runner application is installed, it does not yet communicate with GitLab or run CI/CD jobs. In order to connect to GitLab and run CI/CD jobs, an administrator will need to execute a GitLab Runner command that <em class="italic">registers </em>individual <em class="italic">runners</em> with GitLab and specifies the execution environment those runners will use. Each registered runner will then be a dedicated process that checks into GitLab and runs <span class="No-Break">CI/CD jobs.</span></p>
			<p>This setup can appear confusing at first because a single GitLab Runner application will normally support registering multiple runner processes on the computer where it’s installed. Moreover, those runner processes might use a variety of execution environments for running their jobs. For example, consider a single, bare-metal Linux server. An admin may install the GitLab Runner application, which they then use to register <span class="No-Break">the following:</span></p>
			<ul>
				<li>A runner process that executes a job in a shell session on the <span class="No-Break">server OS</span></li>
				<li>A second runner process that executes a job in a <span class="No-Break">Docker container</span></li>
				<li>A third runner process that pipes a job’s commands to another server <span class="No-Break">over SSH</span></li>
			</ul>
			<p>That is, a single GitLab Runner application installed on a single computer can register multiple runners. The Gitlab Runner application is responsible for starting, stopping, and managing the individual runner processes and picking up CI/CD jobs from GitLab. <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.1</em> summarizes the flow of information between GitLab, a runner, and the environment used to execute the <span class="No-Break">job payload:</span></p>
			<div>
				<div id="_idContainer048" class="IMG---Figure">
					<img src="image/Figure_5.01_B18073.jpg" alt="Figure 5.1 – GitLab Runner communication and job execution" width="1117" height="934"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – GitLab Runner communication and job execution</p>
			<p>For the purposes<a id="_idIndexMarker331"/> of this chapter, don’t worry too much about the finer details<a id="_idIndexMarker332"/> of this flow. Just understand that runners communicate with GitLab in order to receive and run CI/CD jobs in an associated <span class="No-Break">execution environment.</span></p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor118"/>GitLab Runner is supported on most platforms and architectures</h2>
			<p>At the time of writing this book, GitLab Runner can be installed on every major Linux distribution and architecture, as well as on FreeBSD, Windows, macOS, Docker, and Kubernetes. GitLab also offers a FIPS 140-12 runner binary for those organizations that require it for legal or internal <span class="No-Break">compliance reasons.</span></p>
			<p><em class="italic">Table 5.1</em> summarizes the supported architectures and operating system platforms as of GitLab <span class="No-Break">Runner 15.3:</span></p>
			<table id="table001-1" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><strong class="bold">Officially Supported Computer Architectures</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Officially Supported </strong><span class="No-Break"><strong class="bold">Operating Systems</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">x86</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Debian</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">AMD64</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Ubuntu</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">ARM</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">CentOS</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">ARM64</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Red Hat <span class="No-Break">Enterprise Linux</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">s390x</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Fedora</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">ppx64le</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Linux Mint</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p><span class="No-Break">Microsoft Windows</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p><span class="No-Break">macOS</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p><span class="No-Break">FreeBSD</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 5.1 – GitLab Runner-supported platforms</p>
			<p>This table lists the architecture<a id="_idIndexMarker333"/> and OS platforms that GitLab explicitly supports<a id="_idIndexMarker334"/> per its documentation. For the Linux distributions listed, GitLab makes official GitLab Runner packages available that can be managed with the distribution’s native package manager. However, even if your Linux distribution of choice doesn’t appear in the table, you can generally install the GitLab Runner binary manually on any Linux box provided it has a compatible <span class="No-Break">computer architecture.</span></p>
			<p>As previously mentioned, GitLab Runner can also be hosted in a container or container orchestration system, namely Docker and Kubernetes, respectively. Note this refers to the hosting of the GitLab Runner agent itself, as opposed to the executor or execution environment it uses to run jobs. When we discuss executors in detail later in the chapter, we will learn that a runner can be directed to use Docker or Kubernetes as its executor, regardless of where the GitLab Runner agent is installed, provided it has access to the<a id="_idIndexMarker335"/> relevant <span class="No-Break">container</span><span class="No-Break"><a id="_idIndexMarker336"/></span><span class="No-Break"> tools.</span></p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor119"/>Runners can be specific, group, or shared</h2>
			<p>In <a href="B18073_03.xhtml#_idTextAnchor061"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, we learned that work in GitLab<a id="_idIndexMarker337"/> is organized into projects<a id="_idIndexMarker338"/> and groups. Projects and groups are intended to represent<a id="_idIndexMarker339"/> organizational boundaries such as teams or product lines. Projects normally (though not always) host a Git repository containing source code. Groups are containers that hold projects and other groups, similar to how folders organize files and other folders in <span class="No-Break">a filesystem.</span></p>
			<p><a href="B18073_04.xhtml#_idTextAnchor084"><span class="No-Break"><em class="italic">Chapter 4</em></span></a> then introduced CI/CD pipelines. We learned that CI/CD pipelines run inside a project against that project’s code. How, then, do we organize and assign runners in GitLab, making them available for CI/CD pipelines to run their jobs? It turns out that we can organize runner availability similarly to how we can organize many other GitLab resources: by making them available at the project, group, or <span class="No-Break">instance level.</span></p>
			<h3>Specific runners are enabled for individual projects</h3>
			<p>Project owners<a id="_idIndexMarker340"/> and maintainers may choose<a id="_idIndexMarker341"/> to register runners just for their projects. <strong class="bold">Specific runners</strong> are assigned to specific projects, and only pick up and run jobs from CI/CD pipelines running in the project they’re <span class="No-Break">assigned to.</span></p>
			<p>Using specific runners has a couple of advantages. The first is that specific runners empower project owners and developers to set up the runner infrastructure they need without changing anything outside the project they’re working in. For example, a developer might install GitLab Runner on their local laptop, and register a specific runner to a project where they’re the lead contributor. The developer won’t need to ask IT or platform owners to go through some global change management process. Project-specific runners can be managed under project settings, as shown in <span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/Figure_5.02_B18073.jpg" alt="Figure 5.2 – Project-level runner settings" width="1227" height="865"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – Project-level runner settings</p>
			<p>Another advantage of specific runners is the possibility of dedicated or customized tooling for individual projects. Specific runners allow for easier project-level accounting of resource use. Moreover, security and compliance policies may require that certain projects use dedicated<a id="_idIndexMarker342"/> infrastructure that is separate from the rest<a id="_idIndexMarker343"/> of the organization. A runner registered to one specific project will only run pipeline code from inside that project. Pipelines from other parts of GitLab won’t have access <span class="No-Break">to it.</span></p>
			<h3>Group runners are available for all projects inside a group</h3>
			<p>We’ve learned that some resources<a id="_idIndexMarker344"/> in GitLab are only available in projects, some resources<a id="_idIndexMarker345"/> are only available in groups, and others can be available in both projects and groups. Runners are an example of that third type of resource. Registering a runner at the group level makes that runner available to all pipelines in all projects within that group and its subgroups. <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.3</em> shows that group runners can be registered in a group’s <span class="No-Break">CI/CD settings:</span></p>
			<div>
				<div id="_idContainer050" class="IMG---Figure">
					<img src="image/Figure_5.03_B18073.jpg" alt="Figure 5.3 – Group runner settings" width="1084" height="912"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – Group runner settings</p>
			<p>Group owners can create and manage group<a id="_idIndexMarker346"/> runners, which accept and run CI/CD jobs on a <strong class="bold">first-in, first-out</strong> (<strong class="bold">FIFO</strong>) basis. Group runners are useful for teams that want to share resources<a id="_idIndexMarker347"/> or run multi-project CI/CD pipelines, but still need to manage<a id="_idIndexMarker348"/> their own runners for accounting or <span class="No-Break">compliance reasons.</span></p>
			<h3>Shared runners are available to all projects across GitLab</h3>
			<p>GitLab instance administrators can choose to register runners that can pick up CI/CD jobs from any project<a id="_idIndexMarker349"/> in any group across the GitLab instance. This allows platform<a id="_idIndexMarker350"/> owners to abstract away runner management from developers or project managers. Instance admins can also configure CI/CD quotas at the global level that limit the amount of CI/CD pipeline minutes individual projects can use across available <span class="No-Break">shared runners.</span></p>
			<p class="callout-heading">Shared Runners Only Apply to Self-Managed GitLab</p>
			<p class="callout">Administrators can only<a id="_idIndexMarker351"/> configure shared runners on self-managed GitLab instances. <a href="http://GitLab.com">GitLab.com</a> customers can choose to use SaaS runners provided by GitLab, as well <a id="_idIndexMarker352"/>as register their own group or specific runners. A certain number of pipeline minutes for SaaS runners are included in each GitLab license tier, with additional minutes available for purchase. There is never a charge to use your own group or <span class="No-Break">specific runners.</span></p>
			<p>Container-based platforms such as Kubernetes are a common executor choice for shared runners in order to provide ephemeral resources that can be quickly scaled. Unlike group runners, which pick jobs on a FIFO basis, shared runners operate via a <em class="italic">fair usage queue</em>. Projects with the fewest CI/CD jobs using shared runners have priority over those with more active jobs using shared runners. That helps to ensure that a single massive pipeline from one project doesn’t hog the entire shared <span class="No-Break">runner infrastructure.</span></p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor120"/>Each runner has a defined executor</h2>
			<p>Let’s review some<a id="_idIndexMarker353"/> of the components we have mentioned <span class="No-Break">so far:</span></p>
			<ul>
				<li>The GitLab application, which schedules and coordinates <span class="No-Break">CI/CD pipelines</span></li>
				<li>GitLab Runner, the binary installed on <span class="No-Break">a computer</span></li>
				<li>Individual runners, which are processes that run CI/CD jobs and are managed by the GitLab <span class="No-Break">Runner agent</span></li>
			</ul>
			<p>If you look b<a id="_idTextAnchor121"/>ack at <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.1</em>, you will notice an <strong class="bold">Executor component</strong>, which receiv<a id="_idTextAnchor122"/>es the job payload and returns the job output and status. The executor refers to the environment that a runner process uses to run a received CI/CD job. A runner’s executor is specified when the runner is first registered with GitLab. Recall that multiple runner processes, each with its own executor, can be registered from a single computer<a id="_idIndexMarker354"/> that has the GitLab Runner agent installed. <em class="italic">Table 5.2</em> summarizes the supported <span class="No-Break">runner executors:</span></p>
			<table id="table002" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><strong class="bold">Officially Supported GitLab Runner Executors</strong></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Docker</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Shell</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">VirtualBox</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Parallels</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Kubernetes</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Docker Machine</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">SSH</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Custom</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 5.2 – GitLab Runner supported executors</p>
			<p>We will describe each executor <span class="No-Break">in turn.</span></p>
			<h3>The Docker executor</h3>
			<p>A runner using the Docker executor<a id="_idIndexMarker355"/> runs CI/CD jobs in Docker containers<a id="_idIndexMarker356"/> that are launched from a specified Docker image. This provides a reproducible environment containing the tools needed to run the CI/CD job. Using the Docker executor requires that Docker Engine be installed on the same computer as <span class="No-Break">GitLab Runner.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Docker is the most common executor used among GitLab users. Docker containers are also the default environment used by the shared SaaS runners <span class="No-Break">on GitLab.com.</span></p>
			<p>The Docker executor makes it easy to ensure CI/CD jobs have the tools they need to successfully run. Those tools are provided in the container image that the runner is instructed to use for the job. The image used for a job can be specified in a few <span class="No-Break">separate places:</span></p>
			<ul>
				<li>Inside a job definition <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">.gitlab-ci.yml</strong></span></li>
				<li>Globally in <strong class="source-inline">.gitlab-ci.yml</strong>, so it is used for all jobs in <span class="No-Break">the pipeline</span></li>
				<li>As the default image used by a runner with the Docker executor if <strong class="source-inline">.gitlab-ci.yml</strong> does not specify an image <span class="No-Break">to use</span></li>
			</ul>
			<p>The image the runner<a id="_idIndexMarker357"/> uses can be in a local GitLab container registry, another<a id="_idIndexMarker358"/> external registry, or a public container registry such as Docker Hub. For example, if your CI/CD job requires an environment with Python tooling, you might instruct the runner to fetch the <strong class="source-inline">python:3.10</strong> image from Docker Hub, and then launch a container from that image to run the job. Once the job completes, the runner will delete the container until it receives a new job, at which point the runner will run the job in a <span class="No-Break">fresh container.</span></p>
			<h3>The Shell executor</h3>
			<p>The Shell executor<a id="_idIndexMarker359"/> runs jobs directly<a id="_idIndexMarker360"/> in a shell session on the machine where GitLab Runner is installed. The content of the <strong class="source-inline">script</strong> keyword in each job definition in <strong class="source-inline">.gitlab-ci.yml</strong> is run as if a user were typing commands in a terminal. The key advantage of the Shell executor is that it is simple to get started since it uses the native shell and filesystem of wherever GitLab Runner <span class="No-Break">is installed.</span></p>
			<p>There are, however, a couple of challenges<a id="_idIndexMarker361"/> that make the Shell executor difficult <span class="No-Break">to scale:</span></p>
			<ul>
				<li>The first is that you need to have the necessary build, test, or deploy tools required by the CI/CD job already on the server for the Shell executor to access. Or you would need to have steps in the <strong class="source-inline">script</strong> keyword that install the <span class="No-Break">necessary dependencies.</span></li>
				<li>The second challenge is the lack of a clean-slate environment for CI/CD jobs. It is easy to leave leftover build and test artifacts since the job will be executed directly in the server’s filesystem, rather<a id="_idIndexMarker362"/> than in a reproducible environment such as <span class="No-Break">a container.</span></li>
			</ul>
			<p>So while the Shell executor<a id="_idIndexMarker363"/> may be the best executor to use as a beginner standing up your first pipelines, it is recommended that you use a different executor for more complicated <span class="No-Break">build environments.</span></p>
			<h3>The VirtualBox executor</h3>
			<p>The VirtualBox executor<a id="_idIndexMarker364"/> is a way to provide reproducible<a id="_idIndexMarker365"/> environments for CI/CD jobs that may still require full operating system resources. The executor can only be used on computers that have the VirtualBox hypervisor installed. When you register a runner with the VirtualBox executor, specify a <strong class="bold">virtual machine</strong> (<strong class="bold">VM</strong>) template that the runner will use to run CI/CD jobs. When the runner picks up a job, it will spin up a new VM from the base template, run the job in a shell session on that VM, report the results back to GitLab, and then tear down <span class="No-Break">the VM.</span></p>
			<p>While useful as a way of ensuring clean-slate environments, the VirtualBox executor may not be necessary unless the job requires access to an operating system running on a Type-2 hypervisor. Consider using the Docker or Kubernetes executor if you would like standardization without the overhead of <span class="No-Break">a VM.</span></p>
			<h3>The Parallels executor</h3>
			<p>The Parallels executor<a id="_idIndexMarker366"/> is configured<a id="_idIndexMarker367"/> and runs jobs the same way as the VirtualBox executor, the difference being that it uses the Parallels virtualization platform instead of VirtualBox. This allows you to run CI/CD jobs in a Windows VM running on a macOS <span class="No-Break">host machine.</span></p>
			<h3>The Kubernetes executor</h3>
			<p>When a runner is registered<a id="_idIndexMarker368"/> with the Kubernetes executor, it runs a CI/CD job<a id="_idIndexMarker369"/> in a Pod (that is, a group of one or more containers) in a Kubernetes cluster. This naturally requires you to have a Kubernetes cluster set up, which the runner connects to via the <span class="No-Break">Kubernetes API.</span></p>
			<p>At the time of writing, there are a few different ways that GitLab Runner can connect to a <span class="No-Break">Kubernetes cluster:</span></p>
			<ul>
				<li>GitLab offers an official <strong class="bold">Helm chart</strong> to deploy the Runner<a id="_idIndexMarker370"/> agent into <span class="No-Break">a cluster.</span></li>
				<li>GitLab also includes a broader method to connect<a id="_idIndexMarker371"/> a Kubernetes cluster to a GitLab instance, called <strong class="bold">GitLab Agent for Kubernetes</strong>. Once the GitLab instance is connected to a cluster, you can then use the agent to deploy a runner with the Kubernetes executor onto <span class="No-Break">the cluster.</span></li>
				<li>GitLab is actively working on a tool called <strong class="bold">GitLab Operator</strong> that further automates the provisioning<a id="_idIndexMarker372"/> of GitLab resources in Kubernetes, using container management platforms such as Red Hat OpenShift. Operator will provide another method of deploying a runner with the Kubernetes executor to a cluster. While not yet recommended for production use, Operator can be used to effectively manage resources in your dev and test environments. Refer to the GitLab documentation for <span class="No-Break">more details.</span></li>
			</ul>
			<p>Ultimately, successfully working with container orchestrations requires a high degree of knowledge and experience in networking, storage, and security. If you or your team has Kubernetes expertise, the Kubernetes executor can be a powerful way to implement and scale a cloud-native CI/CD workflow. If not, it is better to stick with previously mentioned executors such <span class="No-Break">as Docker.</span></p>
			<h3>The Docker Machine executor</h3>
			<p>While the Docker executor<a id="_idIndexMarker373"/> provisions individual Docker<a id="_idIndexMarker374"/> containers for running CI/CD jobs, the Docker Machine executor provisions the entire host (VMs) that has Docker Engine instead. Those hosts themselves then support the launching of Docker containers. Docker Machine is normally used with a cloud provider with autoscaling, so you can quickly and flexibly launch container-compatible hosts as <span class="No-Break">demand requires.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Docker (the company) is no longer actively developing Docker Machine in favor of Docker Desktop. GitLab maintains a fork of Docker Machine in order to continue supporting the Docker <span class="No-Break">Machine executor.</span></p>
			<p>You can somewhat think of the Docker Machine executor as a combination of the VirtualBox/Parallels executor and the Docker executor, with additional autoscaling support included. Docker Machine can also be useful to ensure isolated resources for each job, by ensuring containers run on their own dedicated VMs. In fact, GitLab uses Docker Machine for its own Linux SaaS<a id="_idIndexMarker375"/> runners, offering<a id="_idIndexMarker376"/> users runners that are both scalable and properly isolated on the <span class="No-Break">multi-tenant platform.</span></p>
			<h3>The SSH executor</h3>
			<p>Sometimes you might<a id="_idIndexMarker377"/> want to run CI/CD jobs on a piece of infrastructure<a id="_idIndexMarker378"/> where, for technical or compliance reasons, you are unable to install GitLab Runner. If that infrastructure supports SSH access from a computer where you <em class="italic">can</em> install GitLab Runner, you can use the SSH executor to run CI/CD jobs on the <span class="No-Break">remote host.</span></p>
			<p>When you register a GitLab runner using the SSH executor, you will also specify the remote host to run the CI/CD job, and the SSH identity file used to connect to that host. When the runner receives a CI/CD job, it will then “pipe” the commands over SSH so they are execu<a id="_idTextAnchor123"/>ted on the remote host. While the SSH executor currently only supports Bash commands and scripts, you might find it useful if you do not want to install the GitLab Runner program on every machine on which you want to run <span class="No-Break">CI/CD jobs.</span></p>
			<p>So far, we’ve described the major components of GitLab runners: the GitLab Runner agent, its individual registered runner processes, and the executor each runner process might use to run its jobs. There is one more element of runner configuration worth discussing, and that is <span class="No-Break">runner tags.</span></p>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor124"/>Runner tags restrict which runners can pick up which jobs</h2>
			<p><strong class="bold">Runner tags</strong> are labels placed on GitLab runners<a id="_idIndexMarker379"/> that match them with job definitions that also include that tag. Tags can represent the runner’s platform or available tools, such as <strong class="source-inline">apache</strong>, <strong class="source-inline">rhel</strong>, or <strong class="source-inline">ios</strong>. Tags can also represent the runner’s intended use in a certain stage in the CI/CD process, such as <strong class="source-inline">build</strong>, <strong class="source-inline">staging</strong>, or <strong class="source-inline">prod</strong>. When you also specify one or more tags in a CI/CD job definition, you can ensure that the runner has the proper tooling and environment needed to run <span class="No-Break">that job.</span></p>
			<p>For example, consider the example following job in a <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">gitlab-ci.yml</strong></span><span class="No-Break"> file:</span></p>
			<pre class="source-code">
deploy-to-staging:
    stage: staging
    script: ./deploy-staging.sh
    tags:
        - <strong class="bold">windows</strong>
        - <strong class="bold">staging</strong></pre>
			<p>The <strong class="source-inline">windows</strong> and <strong class="source-inline">staging</strong> tags, as included in the CI/CD job definition, ensure that the <strong class="source-inline">deploy-to-staging</strong> job will only ever be assigned to runners that have both the <strong class="source-inline">windows</strong> and <strong class="source-inline">staging</strong> tags also assigned to them. By default, runners that have tags will not run untagged jobs – that is, jobs that do not have tags matching them to a certain tagged runner. This default can be overwritten in the runner’s settings, where you can permit tagged runners to run jobs that do not have tags, and therefore presumably do not care where they <span class="No-Break">are run.</span></p>
			<p class="callout-heading">Runner Tags ≠ Git Tags</p>
			<p class="callout">The word “tag” in GitLab can seem confusing because the term is used in a few different contexts. In this discussion, “tag” is simply a label put on runners that matches them to CI/CD jobs with the same tag or tags. These are not Git tags, which are descriptive labels placed on Git commits, and are also found in GitLab. Runner tags are unrelated to tags used in Git <span class="No-Break">version control.</span></p>
			<p>By now, we’ve covered all the essential information around GitLab runners, how they work conceptually, and the different supported platforms and executors. It is time to walk through the runner <span class="No-Break">installation process.</span></p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor125"/>Installing the Runner agent</h1>
			<p>This section will be most helpful<a id="_idIndexMarker380"/> if you follow along and install and register a runner on your own computer. You will find that the installation steps will differ slightly depending on your system type: Windows, macOS, Linux with a supported package manager, or a generic Linux system. Regardless of platform, the same two-step <span class="No-Break">process holds:</span></p>
			<ol>
				<li>Install the GitLab <span class="No-Break">Runner agent.</span></li>
				<li>Register a runner <span class="No-Break">with GitLab.</span></li>
			</ol>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor126"/>Installing GitLab Runner</h2>
			<p>As previously mentioned, the method of installation will differ slightly depending on your operating system. For major Linux distributions, the documentation (<a href="https://docs.gitlab.com/runner/install/linux-repository.html">https://docs.gitlab.com/runner/install/linux-repository.html</a>) will direct you to add the runner repository<a id="_idIndexMarker381"/> to your system, and then use your native package manager to install the <strong class="source-inline">gitlab-runner</strong> package. For Windows, macOS, and other Linux distros, you will use <strong class="source-inline">curl</strong> to get the program directly from GitLab, make it executable, then install and start the <span class="No-Break">runner agent.</span></p>
			<p>Let’s take the example of a Red Hat Linux Enterprise server with an <em class="italic">x86_64</em> architecture and RPM-based package management system. The GitLab documentation directs us to first download and execute a shell script that adds the <strong class="source-inline">gitlab-runner</strong> repositories to our system’s <span class="No-Break">package manager:</span></p>
			<pre class="console">
sudo curl -L "https://packages.gitlab.com/install/repositories/runner/gitlab-runner/script.rpm.sh" | sudo bash</pre>
			<p>If you were to examine the content of the shell script, you would see that all it does is detect the operating system platform, and then run the relevant package management comment to add the <strong class="source-inline">gitlab-runner</strong> repository. You can verify that this step has been completed by checking your list of available repositories (<strong class="source-inline">sudo dnf repolist</strong> in RHEL). You should see <strong class="source-inline">gitlab-runner</strong> in the list alongside the primary <span class="No-Break">OS repositories.</span></p>
			<p>We’ve added the runner repository, but have not yet installed GitLab Runner. We can easily do so by installing the <span class="No-Break"><strong class="source-inline">gitlab-runner</strong></span><span class="No-Break"> package:</span></p>
			<pre class="console">
sudo dnf install –y gitlab-runner</pre>
			<p>Once the installation completes, GitLab Runner should automatically start in the background (you will need to manually start GitLab Runner if you installed it on Windows or macOS, or installed it manually on Linux). You can verify that the GitLab Runner agent is started and <span class="No-Break">running with:</span></p>
			<pre class="console">
sudo gitlab-runner status</pre>
			<p>You should see confirmation<a id="_idIndexMarker382"/> that the agent is running, and also that there are not yet any runners registered with GitLab. Registering runners is what we will <span class="No-Break">do next.</span></p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor127"/>Registering a runner with GitLab</h2>
			<p>We have so far installed<a id="_idIndexMarker383"/> the GitLab Runner agent on a computer, where<a id="_idIndexMarker384"/> it runs as a background service. However, there are not yet any runners communicating with GitLab. The way we set up runners to communicate with GitLab and run CI/CD jobs is by <em class="italic">registering</em> one or <span class="No-Break">more runners.</span></p>
			<p>Recall the previous discussion on shared, specific, and group runners. When you register a runner with GitLab, you bind runners to an entire GitLab instance (shared runners), a group (group runners), or a project (specific runners). Registration instructions and runner settings after registration appear in the respective part of GitLab where you register the runner (instance, group, or project). For example, recalling <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.2</em>, we see that we can find these details under <strong class="bold">Settings</strong> | <strong class="bold">CI/CD</strong> | <strong class="bold">Runners</strong> in the <em class="italic">Hats for </em><span class="No-Break"><em class="italic">Cats</em></span><span class="No-Break"> project:</span></p>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/Figure_5.04_B18073.jpg" alt="Figure 5.4 – Project-level runner settings" width="658" height="681"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – Project-level runner settings</p>
			<p>In addition, take note of the registration token shown in <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.4</em>. The runner registration token is generated by GitLab<a id="_idIndexMarker385"/> and is used by the runner to authenticate to the correct area of GitLab<a id="_idIndexMarker386"/> where it <span class="No-Break">is registered:</span></p>
			<ol>
				<li value="1">If you are following along on a demo system, copy the registration token to your clipboard, as we will need it when we register a runner from the computer where we have GitLab <span class="No-Break">Runner installed.</span></li>
				<li>Next, return to the computer where GitLab Runner is installed. From a Terminal session, run a prompt-based runner <span class="No-Break">registration script:</span><pre class="source-code">
<strong class="bold">sudo gitlab-runner register</strong></pre></li>
				<li>GitLab will first prompt you for the URL of your GitLab application instance. For SaaS, this will be <a href="https://gitlab.com">https://gitlab.com</a>. Otherwise, it will be the URL you use to reach your self-managed instance. In this example, we will stick <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">gitlab.com</strong></span><span class="No-Break">:</span><pre class="source-code">
<strong class="bold">Enter the GitLab instance URL (for example, </strong>https://gitlab.com):</pre><pre class="source-code">
<strong class="bold">https://gitlab.com</strong></pre></li>
				<li>Next, the script will ask for the<a id="_idIndexMarker387"/> runner registration token. This is the token<a id="_idIndexMarker388"/> shown in <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.2</em> and will be different depending on the project or group with which you are registering a runner. Put another way, the registration token authenticates the runner to GitLab and ensures that it is registered to the correct project <span class="No-Break">or group:</span><pre class="source-code">
<strong class="bold">Enter the registration token:</strong></pre><pre class="source-code">
<strong class="bold">GR1348941Xi_koNdj8AjJMjSzQyYY</strong></pre></li>
				<li>You can then provide an optional description that will show up in the runner’s metadata in the GitLab UI. This example might presume the runner is a Linux server where developers can build and test <span class="No-Break">their code:</span><pre class="source-code">
<strong class="bold">Enter a description for the runner:</strong></pre><pre class="source-code">
<strong class="bold">[localhost] Linux dev server</strong></pre></li>
				<li>The next message prompts you to enter any optional runner tags. Recall that tags are label metadata that you assign to a runner. Tags advertise the runner as being able to pick up CI/CD jobs that have those same tags. For example, a build job might include the <strong class="source-inline">rhel</strong> tag to indicate that the job requires tooling provided by Red Hat Linux. Only runners with that tag will be allowed to pick up the job. Tags can be assigned on runner registration, as shown here, and can also be modified via the runner settings in the <span class="No-Break">GitLab UI:</span><pre class="source-code">
<strong class="bold">Enter tags for the runner (comma-separated):</strong></pre><pre class="source-code">
<strong class="bold">dev,rhel</strong></pre></li>
			</ol>
			<p>The optional maintenance note is another area of descriptive metadata that doesn’t otherwise configure the <span class="No-Break">runner behavior:</span></p>
			<pre class="source-code">
<strong class="bold">Enter optional maintenance note for the runner</strong>
<strong class="bold">&lt;leave blank in this example&gt;</strong></pre>
			<p>At this point in the script, the newly created runner process will reach out to GitLab to confirm that it can communicate <span class="No-Break">and authenticate:</span></p>
			<pre class="source-code">
<strong class="bold">Registering runner... succeeded                     runner=GR1348941Xi_koNdj</strong></pre>
			<ol>
				<li value="7">Lastly, the runner<a id="_idIndexMarker389"/> will ask for the execution environment<a id="_idIndexMarker390"/> it should use to run CI/CD jobs. Also, remember that the executor depends on having the necessary tooling available; for example, selecting Docker requires that Docker Engine is installed and available on the server. In this example, we’ll select <strong class="source-inline">Shell</strong>, as it’s the easiest executor with which to get started and requires <span class="No-Break">no dependencies:</span><pre class="source-code">
<strong class="bold">Enter an executor: parallels, docker-ssh+machine, kubernetes, custom, docker, docker-ssh, docker+machine, shell, ssh, virtualbox:</strong></pre><pre class="source-code">
<strong class="bold">Shell</strong></pre></li>
				<li>The script will finally confirm that runner registration has succeeded. A runner process is now running on the computer, managed by the local GitLab Runner agent, and ready to pick up a CI/CD job from the <span class="No-Break">GitLab instance:</span><pre class="source-code">
<strong class="bold">Runner registered successfully. Feel free to start it, but if it's running already the config should be automatically reloaded!</strong></pre><pre class="source-code">
<strong class="bold">Configuration (with the authentication token) was saved in "/etc/gitlab-runner/config.toml"</strong></pre></li>
			</ol>
			<p>We can verify successful registration and communication in a couple of ways. From where GitLab Runner<a id="_idIndexMarker391"/> is installed, you can view the configured runners <a id="_idIndexMarker392"/>with the <span class="No-Break">following command:</span></p>
			<pre class="console">
sudo gitlab-runner list
Runtime platform                                    arch=amd64 os=linux pid=30148 revision=32fc1585 version=15.2.1
Listing configured runners                          ConfigFile=/etc/gitlab-runner/config.toml
Linux dev server                                    Executor=shell Token=ZLXwxp4KWrQp2jjZRxjj URL=https://gitlab.com</pre>
			<p>A runner with a description of <strong class="source-inline">Linux dev server</strong> is listed, along with its executor, registration token, and the GitLab instance the runner is <span class="No-Break">registered to.</span></p>
			<p>We can also verify that the runner is properly registered from the GitLab side. The runner we just registered is registered with our <em class="italic">Hats for Cats</em> project. <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.5</em> shows that if we return to the project via <strong class="bold">Settings</strong> | <strong class="bold">CI/CD</strong> | <strong class="bold">Runners</strong>, and look under <strong class="bold">Specific Runners</strong>, we see <strong class="source-inline">Linux dev runner</strong> registered and available to <span class="No-Break">the project:</span></p>
			<div>
				<div id="_idContainer052" class="IMG---Figure">
					<img src="image/Figure_5.05_B18073.jpg" alt="Figure 5.5 – Specific runner successfully registered with GitLab" width="1099" height="838"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – Specific runner successfully registered with GitLab</p>
			<p>The GitLab UI shows a couple<a id="_idIndexMarker393"/> of other interesting features from our specific<a id="_idIndexMarker394"/> runner. The <strong class="source-inline">dev</strong> and <strong class="source-inline">rhel</strong> tags are shown alongside the runner ID and description. The lock icon next to the runner ID indicates that the runner is locked to the specific project to which it is registered, and it cannot be assigned to other projects. The pencil icon will take us to runner settings that we can adjust in the GitLab UI, and the pause button will “pause” the runner. Pausing the runner will keep it registered with GitLab, but will prevent the runner from accepting new jobs while it <span class="No-Break">is paused.</span></p>
			<p>We can view existing runner settings and statistics by clicking on the hyperlinked runner ID. <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.6</em> shows information from the runner we registered earlier, which can be viewed in the GitLab UI. This information includes the runner’s architecture and networking details, its activity status, and assignable attributes such as runner tags, its protected or unprotected status, description, and ability to be assigned to <span class="No-Break">other projects:</span></p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/Figure_5.06_B18073.jpg" alt="Figure 5.6 – Runner information in the GitLab UI" width="1099" height="734"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – Runner information in the GitLab UI</p>
			<p>If we return to the runner<a id="_idIndexMarker395"/> settings (as shown in <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.5</em>) and select the edit (pencil) icon, we arrive<a id="_idIndexMarker396"/> at a page that shows additional runner details as well as attributes we can set from the UI. These settings include protecting the runner and modifying the description and runner tags, as shown in <span class="No-Break"><em class="italic">Figure 5</em></span><span class="No-Break"><em class="italic">.7</em></span><span class="No-Break">.</span></p>
			<p>The maximum job timeout field tells the runner to report a job as failed by default after a certain period elapses. Be careful with this option; if you set it, make sure it is a value larger than the maximum amount of time you would expect one of your builds <span class="No-Break">to take.</span></p>
			<div>
				<div id="_idContainer054" class="IMG---Figure">
					<img src="image/Figure_5.07_B18073.jpg" alt="Figure 5.7 – Runner settings in the GitLab UI" width="1100" height="680"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 – Runner settings in the GitLab UI</p>
			<p>At this point, your runner<a id="_idIndexMarker397"/> is registered, active, and ready to start picking<a id="_idIndexMarker398"/> up CI/CD jobs. The topic we will next turn to is considerations around the runner configurations and executors based on your or your <span class="No-Break">organization’s needs.</span></p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor128"/>Considerations regarding the various runner types and executors</h1>
			<p>We’ve learned that there<a id="_idIndexMarker399"/> are many types of runners, configuration options, and execution<a id="_idIndexMarker400"/> environments. In this section, we will discuss some performance, security, and monitoring considerations to help guide your decision-making regarding which runners to use, and when to <span class="No-Break">use them.</span></p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor129"/>Performance considerations</h2>
			<p>As a developer or operator, you want<a id="_idIndexMarker401"/> to make sure that pipelines run as efficiently as possible. Key performance considerations around CI/CD job execution are runner availability and resources, repository size, and how you handle job and <span class="No-Break">application dependencies.</span></p>
			<h3>Runner availability</h3>
			<p>Consider the three scopes<a id="_idIndexMarker402"/> of runners discussed earlier in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Shared runners configured at this instance level (if using self-managed GitLab), available to all projects in <span class="No-Break">the instance</span></li>
				<li>Group runners available to all projects in a group and <span class="No-Break">its subgroups</span></li>
				<li>Specific runners registered only to <span class="No-Break">designated projects</span></li>
			</ul>
			<p>The way each of the types of runners handles CI/CD jobs can affect pipeline efficiency and execution times. Specific runners are a fairly straightforward case. Use specific runners when you know you need dedicated resources for a project. That said, you may gain pipeline efficiency at the expense of the efficient use of resources. Idle server time can be a consequence of widely using specific runners. Moreover, pooling resources together in group and shared runners can also allow you to take advantage of autoscaling features offered by cloud services in a way that may not be economically feasible with specific runners. So, if your application’s resource use and demand are predictable, look to use specific runners. If you expect fluctuation in resource requirements, consider group or <span class="No-Break">shared runners.</span></p>
			<p>Regarding group and shared runners, they may appear to be roughly equivalent in practice, especially if your GitLab instance has a single top-level group storing all your projects. However, group and shared runners are quite different in the way they pick up their respective jobs. Group runners process jobs on a FIFO basis. This means a single resource-intensive pipeline can “hog” a set of group runners as its jobs are queued, especially if there are many jobs in a <span class="No-Break">single stage.</span></p>
			<p>Specific runners, on the other hand, operate via a fair usage queue. That is, projects on the GitLab instance with the fewest jobs already using shared runners are given priority. That may be desirable in some cases, as it suggests more equitable pipeline execution across all your projects in GitLab. In practice, some projects may be more important than others, and you will want those projects to have priority execution, where pending jobs aren’t sent to the back of the line because others in the project have already run. In that case, group runners with their FIFO<a id="_idIndexMarker403"/> assignment may be your <span class="No-Break">best bet.</span></p>
			<h3>Repository size</h3>
			<p>GitLab’s documentation<a id="_idIndexMarker404"/> describes a “large” repository as containing more than 50,000 files in the working tree (that is, in the collection of checked-out files). When repositories are large, a rate-limiting step in the pipeline can be the runner cloning or fetching the <span class="No-Break">project repository.</span></p>
			<p>GitLab Runner already has some optimizations in place to minimize the time and resources it takes to pull down project files. If the project has previously been cloned to the runner’s execution environment, the runner will perform an incremental fetch so that the entire repository isn’t pulled down for each job. Moreover, runners will by default perform a shallow clone, copying down only the latest 20 commits from the project (this setting can be adjusted with the <strong class="source-inline">GIT_DEPTH</strong> variable in your <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">gitlab-ci.yml</strong></span><span class="No-Break"> file).</span></p>
			<p>For some more advanced configuration, you can use the <strong class="source-inline">pre_clone_script</strong> keyword in your <strong class="source-inline">.gitlab-ci.yml</strong> file to set Git configuration commands that run before the runner clones <span class="No-Break">the repository.</span></p>
			<h3>Caching dependencies</h3>
			<p>The considerations<a id="_idIndexMarker405"/> around dependency and artifact caching are conceptually similar to the discussion around large repositories. The idea is that we want to minimize the need for runners to repeatedly download the same files, and download only the files they need for the CI/CD job currently assigned to <span class="No-Break">the runner.</span></p>
			<p>The <strong class="source-inline">cache</strong> keyword in <strong class="source-inline">.gitlab-ci.yml</strong> is where you specify file paths that should remain on the runner between jobs. We recommend combining the <strong class="source-inline">cache</strong> keyword with runner tags so that jobs such as tooling are assigned to runners that have those <span class="No-Break">dependencies pre-cached.</span></p>
			<p>By default, each runner will also download all artifacts for every job that has previously run in that pipeline. You can use the <strong class="source-inline">dependencies</strong> keyword to select which jobs’ artifacts should be downloaded. For example, if you have separate Windows and Linux build jobs, and separate test jobs for your Windows and Linux builds, it makes sense for the test jobs to only download the artifacts from their respective <span class="No-Break">build job.</span></p>
			<p>Finally, if your pipelines are container-based, you might spend heavy amounts of networking resources pulling container images from public registries to run your jobs. GitLab has a feature called Dependency Proxy, where you can configure<a id="_idIndexMarker406"/> a local registry to cache Docker images, so the runner executor does not need to pull from a public source on each run. Rather, the runner will pull from the local registry, and pulling from the public source will only need to take place for updating<a id="_idIndexMarker407"/> the container versions in <span class="No-Break">the cache.</span></p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor130"/>Security considerations</h2>
			<p>There is far more to discuss concerning<a id="_idIndexMarker408"/> security and GitLab than can be covered in this book. However, two considerations are immediately implicated by your choices in installing and configuring runners. Those considerations are the choice of runner executor, and how you handle secrets in your <span class="No-Break">CI/CD pipelines.</span></p>
			<h3>Your choice of runner executor</h3>
			<p>Remember that CI/CD pipelines<a id="_idIndexMarker409"/> are fundamentally the execution of commands on a remote host – that is, hosts where GitLab Runner is installed. You, therefore, run the inherent risk of performing operations not just on your source code but also on the underlying infrastructure hosting <span class="No-Break">the runner.</span></p>
			<p>In general, some runner executers can be thought of as “safer” than others. Using the shell executor, while convenient, exposes your server’s filesystem to the runner, and operations performed against the filesystem may persist across jobs. For example, a CI/CD pipeline job for project A might be able to access files from project B if a pipeline for project B recently used that same runner. The <strong class="source-inline">gitlab-runner</strong> user will run under the authority of whichever user registered the runner. If <strong class="source-inline">sudo</strong> was used for registration, that means the runner will have full root access. Therefore, we recommend using the shell executor only for specific runners in projects <span class="No-Break">you trust.</span></p>
			<p>The Docker executor can be thought of as somewhat safer because containers are an additional abstraction layer away from the host system. The runner clones project code and runs job commands inside an isolated container, and then tears down the container after reporting the results back to GitLab. Of critical importance, though, is making sure the containers run in unprivileged mode. That is, the jobs must be run by non-root users to ensure job execution does not involve access to the <span class="No-Break">host system.</span></p>
			<p>The VirtualBox/Parallels executor can be considered among the safest of the runner executors because jobs are run inside an ephemeral VM with an isolated OS and filesystem. CI/CD jobs will not have access to the underlying hypervisor, and there is minimal risk of information unintentionally<a id="_idIndexMarker410"/> being shared between jobs. Consider using these executors if you are otherwise unsure of your ability to secure shell or <span class="No-Break">Docker environments.</span></p>
			<h3>Secret management</h3>
			<p>Managing secrets<a id="_idIndexMarker411"/> and avoiding their unintentional disclosure is a topic with a larger scope than the focus of this chapter. However, because runners receive both repository information and environment variables from GitLab, it is important to understand how poor secret management can cause your runners to be a vector for exposing <span class="No-Break">sensitive information.</span></p>
			<p>Never, under any circumstances, hardcode secrets (passwords, cloud credentials, deploy keys, and so on) into your project repository. The nature of Git version control is that once information is committed to the project, it is a part of the repository’s immutable snapshot history. Simply removing the secret with a future commit does not remove it from previous commits. Because runners clone project repositories with a certain depth of historic snapshots, secrets accidentally left in a project are propagated to the <span class="No-Break">runner infrastructure.</span></p>
			<p><a href="B18073_07.xhtml#_idTextAnchor162"><span class="No-Break"><em class="italic">Chapter 7</em></span></a> will cover how you can use GitLab’s Secret Detection tool to perform historic scans on your repository for potentially hardcoded secrets. Ultimately, the solution to the “I accidentally committed sensitive information” problem is to consider that information irrevocably exposed, and to therefore reset or rotate the affected credentials <span class="No-Break">or keys.</span></p>
			<p>A similar situation arises with CI/CD variables. Variables used in GitLab CI/CD are exported as environment variables to a runner’s shell session. Unmasked and unprotected variables that store secrets run the risk of ending up on runners that execute untrusted builds. To guard against this possibility, store variables as masked and protected variables at the project or group level, ensuring they can only be used on protected branches, and ensuring their values are not exposed on <span class="No-Break">the runners.</span></p>
			<h2 id="_idParaDest-122"><a id="_idTextAnchor131"/>Monitoring considerations</h2>
			<p>Recall that GitLab Runner<a id="_idIndexMarker412"/> runs as a separate application on infrastructure outside the GitLab instance. Monitoring the data around your runners and pipelines is essential to ensure proper security and resource utilization. </p>
			<p>The three key areas of consideration around monitoring your runners are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>The analytics available in the <span class="No-Break">Gitlab UI</span></li>
				<li>The runner <span class="No-Break">logging system</span></li>
				<li>The exportable metrics produced by the <span class="No-Break">runners themselves</span></li>
			</ul>
			<p>Self-managed GitLab has in-depth logging and monitoring facilities. Most monitoring can be managed by the built-in Prometheus server, and logs<a id="_idIndexMarker413"/> can be exported to aggregation systems such as <strong class="bold">Splunk</strong>. Similarly, GitLab Runner generates log entries that can be managed in the local operating system as well as by external or <span class="No-Break">web-based tools.</span></p>
			<h3>GitLab UI analytics</h3>
			<p>General CI/CD analytics<a id="_idIndexMarker414"/> can be found at the project level under <strong class="bold">Analytics</strong> | <strong class="bold">CI/CD</strong>. <span class="No-Break"><em class="italic">Figure 5</em></span><em class="italic">.8</em> shows statistics for the public GitLab project hosted <span class="No-Break">on </span><a href="http://GitLab.com"><span class="No-Break">GitLab.com</span></a><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer055" class="IMG---Figure">
					<img src="image/Figure_5.08_B18073.jpg" alt="Figure 5.8 – CI/CD analytics for the GitLab project" width="1242" height="1041"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8 – CI/CD analytics for the GitLab project</p>
			<p>The metrics shown in the UI here only account for general pipeline trends, namely overall pipeline success and failure rates. However, this data can serve as a useful starting point from which you can determine whether pipeline failures are caused by logic errors in source code or issues with the underlying infrastructure (that is, your runners). If runners appear<a id="_idIndexMarker415"/> to be the culprit, you can then dive deeper into runner-specific logs and metrics, as discussed in the next <span class="No-Break">few paragraphs.</span></p>
			<h3>Runner logging</h3>
			<p>GitLab Runner does not have a dedicated log file. Rather, messages are published to the general system<a id="_idIndexMarker416"/> log file. Normally that would be <strong class="source-inline">/var/log/syslog</strong> in Debian-flavored operating systems (such as Ubuntu) and <strong class="source-inline">/var/log/messages</strong> in Fedora-flavored operating systems (such as Red Hat Linux). Errors in the runner service, its configuration, or its ability to communicate with GitLab will be logged in <span class="No-Break">these files.</span></p>
			<p>A useful way to confirm that the runner has a valid configuration and that it can communicate properly with GitLab is to run the <strong class="source-inline">gitlab-runner verify</strong> command <span class="No-Break">as shown:</span></p>
			<pre class="console">
$ sudo gitlab-runner verify
Runtime platform             arch=amd64 os=linux pid=84209 revision=32fc1585 version=15.2.1
Running in system-mode.
Verifying runner... is alive                        runner=ZLXwxp4K</pre>
			<p>In the preceding output, you can verify the runner’s architecture, version, process ID, registration ID, and ability to talk <span class="No-Break">to GitLab.</span></p>
			<h3>Runner Prometheus metrics</h3>
			<p>Self-managed GitLab<a id="_idIndexMarker417"/> has in-depth logging and monitoring facilities. Most monitoring can be managed by the built-in Prometheus server. Similarly, GitLab Runner includes an embedded HTTP server that can advertise its metrics to an available <span class="No-Break">Prometheus server.</span></p>
			<p>In order to expose the runner’s metrics, you first need to edit the runner’s main configuration file, <strong class="source-inline">config.toml</strong>, which can normally be found in <strong class="source-inline">/etc/gitlab-runner</strong>. Add the <strong class="source-inline">listen_address</strong> parameter to tell the metrics server which port to listen on. An example <strong class="source-inline">config.toml</strong> file with the <strong class="source-inline">listen_address</strong> parameter added may look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
concurrent = 1
check_interval = 0
listen_address = "localhost:9252"
[session_server]
  session_timeout = 1800
. . .</pre>
			<p>After you edit the configuration file, restart the GitLab Runner service with <strong class="source-inline">sudo gitlab-runner restart</strong>. An available Prometheus server<a id="_idIndexMarker418"/> will then be able to read in and instrument the <span class="No-Break">runner metrics.</span></p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor132"/>Summary</h1>
			<p>In this chapter, we described the part that runners play in GitLab CI/CD pipelines. We learned that runners can be thought of as the “muscle” of CI/CD executing jobs specified in <strong class="source-inline">.gitlab-ci.yml</strong>. Runners can be installed as standalone programs on most computer platforms and can be shared with all projects in GitLab, or with only certain projects or groups. Moreover, wherever you have a runner installed, you can choose the execution environment it uses to run <span class="No-Break">CI/CD tasks.</span></p>
			<p>Regardless of your role, it is helpful to understand how runner settings can affect pipeline performance, application security, and observability in the development life cycle. We encourage you to practice the process of installing and registering runners, even if maintaining the runner infrastructure is not part of your day-to-day responsibilities. A confident knowledge level of runner architecture and workflows will make you a better software practitioner as you continue your <span class="No-Break">GitLab journey.</span></p>
			<p>The next chapter will build upon what we’ve learned so far and will introduce you to building out a robust test infrastructure using GitLab CI/CD. Application verification, and later, security, will serve as core topics whose coverage will enable you to continuously improve the efficiency, sustainability, and security of your <span class="No-Break">DevOps workflows.</span></p>
		</div>
		<div>
			<div id="_idContainer057" class="Content">
			</div>
		</div>
	</div>
</div>
</body></html>