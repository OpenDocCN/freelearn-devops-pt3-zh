["```\n$ kind create cluster\n```", "```\n$ kind get clusters\nkind\n```", "```\n$ kubectl create namespace petstore\n```", "```\n$ cat <<EOF | kubectl create -f -\napiVersion: v1\nkind: Namespace\nmetadata:\n  name: petstore\nEOF\n```", "```\n$ kubectl get namespace petstore -o yaml\napiVersion: v1\nkind: Namespace\nmetadata:\n  creationTimestamp: \"2022-03-06T15:55:09Z\"\n  labels:\n    kubernetes.io/metadata.name: petstore\n  name: petstore\n  resourceVersion: \"2162\"\n  uid: cddb2eb8-9c46-4089-9c99-e31259dfcd1c\nspec:\n  finalizers:\n  - kubernetes\nstatus:\n  phase: Active\n```", "```\n$ cat ~/.kube/config\napiVersion: v1\nclusters:\n- cluster:\n    certificate-authority-data:\n    server: https://127.0.0.1:55451\n  name: kind-kind\ncontexts:\n- context:\n    cluster: kind-kind\n    user: kind-kind\n  name: kind-kind\ncurrent-context: kind-kind\nkind: Config\npreferences: {}\nusers:\n- name: kind-kind\n  user:\n    client-certificate-data:\n    client-key-data:\n```", "```\n$ kind get kubeconfig --name kind > .tmp-kubeconfig\n```", "```\n$ KUBECONFIG=./.tmp-kubeconfig kubectl get namespaces\n```", "```\n$ kubectl delete namespace petstore\n$ kind delete cluster --name kind\n```", "```\n$ kind create cluster --name workloads --config kind-config.yaml\n$ kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/kind/deploy.yaml\n$ kubectl wait --namespace ingress-nginx \\\n  --for=condition=ready pod \\\n  --selector=app.kubernetes.io/component=controller \\\n  --timeout=90s\n$ go run .\n```", "```\n10.244.0.7 - - [07/Mar/2022:02:34:59 +0000] \"GET /hello HTTP/1.1\" 200 7252 \"-\" \"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.3 Safari/605.1.15\" \"172.22.0.1\"\n```", "```\n$ kind delete cluster --name workloads\n```", "```\nfunc main() {\n     ctx, cancel := context.WithCancel(context.Background())\n     defer cancel()\n     clientSet := getClientSet()\n     nsFoo := createNamespace(ctx, clientSet, \"foo\")\n     defer func() {\n          deleteNamespace(ctx, clientSet, nsFoo)\n     }()\n     deployNginx(ctx, clientSet, nsFoo, \"hello-world\")\n     fmt.Printf(\"You can now see your running service: http://localhost:8080/hello\\n\\n\")\n     listenToPodLogs(ctx, clientSet, nsFoo, \"hello-world\")\n     // wait for ctrl-c to exit the program\n     waitForExitSignal()\n}\n```", "```\nfunc getClientSet() *kubernetes.Clientset {\n\tvar kubeconfig *string\n\tif home := homedir.HomeDir(); home != \"\" {\n\t\tkubeconfig = flag.String(\n\t\t\t\"kubeconfig\",\n\t\t\tfilepath.Join(home, \".kube\", \"config\"),\n\t\t\t\"(optional) absolute path to the kubeconfig file\",\n\t\t)\n\t} else {\n\t\tkubeconfig = flag.String(\n\t\t\t\"kubeconfig\",\n\t\t\t\"\",\n\t\t\t\"absolute path to the kubeconfig file\",\n\t\t)\n\t}\n\tflag.Parse()\n\t// use the current context in kubeconfig\n\tconfig, err := clientcmd.BuildConfigFromFlags(\n\t\t\"\",\n\t\t*kubeconfig,\n\t)\n\tpanicIfError(err)\n\n\t// create the clientSet\n\tcs, err := kubernetes.NewForConfig(config)\n\tpanicIfError(err)\n\treturn cs\n}\n```", "```\nfunc createNamespace(\n\tctx context.Context,\n\tclientSet *kubernetes.Clientset,\n\tname string,\n) *corev1.Namespace {\n\tfmt.Printf(\"Creating namespace %q.\\n\\n\", name)\n\tns := &corev1.Namespace{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName: name,\n\t\t},\n\t}\n\tns, err := clientSet.CoreV1().\n\t\tNamespaces().\n\t\tCreate(ctx, ns, metav1.CreateOptions{})\n\tpanicIfError(err)\n\treturn ns\n}\n```", "```\nfunc deployNginx(\n\tctx context.Context,\n\tclientSet *kubernetes.Clientset,\n\tns *corev1.Namespace,\n\tname string,\n) {\n\tdeployment := createNginxDeployment(\n\t\tctx,\n\t\tclientSet,\n\t\tns,\n\t\tname,\n\t)\n\twaitForReadyReplicas(ctx, clientSet, deployment)\n\tcreateNginxService(ctx, clientSet, ns, name)\n\tcreateNginxIngress(ctx, clientSet, ns, name)\n}\n```", "```\nfunc createNginxDeployment(\n\tctx context.Context,\n\tclientSet *kubernetes.Clientset,\n\tns *corev1.Namespace,\n\tname string,\n) *appv1.Deployment {\n\tvar (\n\t\tmatchLabel = map[string]string{\"app\": \"nginx\"}\n\t\tobjMeta    = metav1.ObjectMeta{\n\t\t\tName:      name,\n\t\t\tNamespace: ns.Name,\n\t\t\tLabels:    matchLabel,\n\t\t}\n            [...]\n\t)\n\tdeployment := &appv1.Deployment{\n\t\tObjectMeta: objMeta,\n\t\tSpec: appv1.DeploymentSpec{\n\t\t\tReplicas: to.Int32Ptr(2),\n\t\t\tSelector: &metav1.LabelSelector{\n\t\t\t\tMatchLabels: matchLabel,\n\t\t\t},\n\t\t\tTemplate: template,\n\t\t},\n\t}\n\tdeployment, err := clientSet.\n\t\tAppsV1().\n\t\tDeployments(ns.Name).\n\t\tCreate(ctx, deployment, metav1.CreateOptions{})\n\tpanicIfError(err)\n\treturn deployment\n}\n```", "```\nfunc waitForReadyReplicas(\n\tctx context.Context,\n\tclientSet *kubernetes.Clientset,\n\tdeployment *appv1.Deployment,\n) {\n\tfmt.Printf(\"Waiting for ready replicas in: %q\\n\", deployment.Name)\n\tfor {\n\t\texpectedReplicas := *deployment.Spec.Replicas\n\t\treadyReplicas := getReadyReplicasForDeployment(\n\t\t\tctx,\n\t\t\tclientSet,\n\t\t\tdeployment,\n\t\t)\n\t\tif readyReplicas == expectedReplicas {\n\t\t\tfmt.Printf(\"replicas are ready!\\n\\n\")\n\t\t\treturn\n\t\t}\n\t\tfmt.Printf(\"replicas are not ready yet. %d/%d\\n\",\n\t\t\treadyReplicas, expectedReplicas)\n\t\ttime.Sleep(1 * time.Second)\n\t}\n}\nfunc getReadyReplicasForDeployment(\n\tctx context.Context,\n\tclientSet *kubernetes.Clientset,\n\tdeployment *appv1.Deployment,\n) int32 {\n\tdep, err := clientSet.\n\t\tAppsV1().\n\t\tDeployments(deployment.Namespace).\n\t\tGet(ctx, deployment.Name, metav1.GetOptions{})\n\tpanicIfError(err)\n\treturn dep.Status.ReadyReplicas\n}\n```", "```\nfunc createNginxService(\n\tctx context.Context,\n\tclientSet *kubernetes.Clientset,\n\tns *corev1.Namespace,\n\tname string,\n) {\n\tvar (\n\t\tmatchLabel = map[string]string{\"app\": \"nginx\"}\n\t\tobjMeta    = metav1.ObjectMeta{\n\t\t\tName:      name,\n\t\t\tNamespace: ns.Name,\n\t\t\tLabels:    matchLabel,\n\t\t}\n\t)\n\tservice := &corev1.Service{\n\t\tObjectMeta: objMeta,\n\t\tSpec: corev1.ServiceSpec{\n\t\t\tSelector: matchLabel,\n\t\t\tPorts: []corev1.ServicePort{\n\t\t\t\t{\n\t\t\t\t\tPort:     80,\n\t\t\t\t\tProtocol: corev1.ProtocolTCP,\n\t\t\t\t\tName:     \"http\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tservice, err := clientSet.\n\t\tCoreV1().\n\t\tServices(ns.Name).\n\t\tCreate(ctx, service, metav1.CreateOptions{})\n\tpanicIfError(err)\n}\n```", "```\nfunc createNginxIngress(\n\tctx context.Context,\n\tclientSet *kubernetes.Clientset,\n\tns *corev1.Namespace,\n\tname string,\n) {\n\tvar (\n\t\tprefix  = netv1.PathTypePrefix\n\t\tobjMeta = metav1.ObjectMeta{\n\t\t\tName:      name,\n\t\t\tNamespace: ns.Name,\n\t\t}\n\t\tingressPath = netv1.HTTPIngressPath{\n\t\t\tPathType: &prefix,\n\t\t\tPath:     \"/hello\",\n\t\t\tBackend: netv1.IngressBackend{\n\t\t\t\tService: &netv1.IngressServiceBackend{\n\t\t\t\t\tName: name,\n\t\t\t\t\tPort: netv1.ServiceBackendPort{\n\t\t\t\t\t\tName: \"http\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\tingress := &netv1.Ingress{\n\t\tObjectMeta: objMeta,\n\t\tSpec: netv1.IngressSpec{\n\t\t\tRules: rules,\n\t\t},\n\t}\n\tingress, err := clientSet.\n\t\tNetworkingV1().\n\t\tIngresses(ns.Name).\n\t\tCreate(ctx, ingress, metav1.CreateOptions{})\n\tpanicIfError(err)\n}\n```", "```\nfunc listenToPodLogs(\n\tctx context.Context,\n\tclientSet *kubernetes.Clientset,\n\tns *corev1.Namespace,\n\tcontainerName string,\n) {\n\t// list all the pods in namespace foo\n\tpodList := listPods(ctx, clientSet, ns)\n\tfor _, pod := range podList.Items {\n\t\tpodName := pod.Name\n\t\tgo func() {\n\t\t\topts := &corev1.PodLogOptions{\n\t\t\t\tContainer: containerName,\n\t\t\t\tFollow:    true,\n\t\t\t}\n\t\t\tpodLogs, err := clientSet.\n\t\t\t\tCoreV1().\n\t\t\t\tPods(ns.Name).\n\t\t\t\tGetLogs(podName, opts).\n\t\t\t\tStream(ctx)\n\t\t\tpanicIfError(err)\n\t\t\t_, _ = os.Stdout.ReadFrom(podLogs)\n\t\t}()\n\t}\n}\nfunc listPods(\n\tctx context.Context,\n\tclientSet *kubernetes.Clientset,\n\tns *corev1.Namespace,\n) *corev1.PodList {\n\tpodList, err := clientSet.\n\t\tCoreV1().\n\t\tPods(ns.Name).\n\t\tList(ctx, metav1.ListOptions{})\n\tpanicIfError(err)\n\t/* omitted some logging for brevity */\n\treturn podList\n}\n```", "```\napiVersion: opentelemetry.io/v1alpha1\nkind: OpenTelemetryCollector\nmetadata:\n  name: simplest\nspec:\n  config: |\n    receivers:\n      otlp:\n        protocols:\n          grpc:\n          http:\n    processors:\n    exporters:\n      logging:\n    service:\n      pipelines:\n        traces:\n          receivers: [otlp]\n          processors: []\n          exporters: [logging]\n```", "```\napiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  # name must be in the form: <plural>.<group>\n  name: crontabs.stable.example.com\nspec:\n  # group name to use for REST API: /apis/<group>/<version>\n  group: stable.example.com\n  # list of versions supported by this CustomResourceDefinition\n  versions:\n    - name: v1\n      # Each version can be enabled/disabled by Served flag.\n      served: true\n      # only one version must be marked as the storage version.\n      storage: true\n      schema:\n        openAPIV3Schema:\n          type: object\n          properties:\n            spec:\n              type: object\n              properties:\n                cronSpec:\n                  type: string\n                image:\n                  type: string\n                replicas:\n                  type: integer\n  # either Namespaced or Cluster\n  scope: Namespaced\n  names:\n    plural: crontabs\n    singular: crontab\n    kind: CronTab\n    shortNames:\n    - ct\n```", "```\n$ operator-sdk init --domain example.com --repo github.com/Go-for-DevOps/chapter/14/petstore-operator\nWriting kustomize manifests for you to edit...\nWriting scaffold for you to edit...\nGet controller runtime:\n$ go get sigs.k8s.io/controller-runtime@v0.11.0\nUpdate dependencies:\n$ go mod tidy\nNext: define a resource with:\n$ operator-sdk create api\n```", "```\n$ ls -al\ntotal 368\n-rw-------  1 david  staff    776 Feb 27 10:15 Dockerfile\n-rw-------  1 david  staff   9884 Feb 27 10:16 Makefile\n-rw-------  1 david  staff    261 Feb 27 10:16 PROJECT\ndrwx------  8 david  staff    256 Feb 27 10:16 config/\n-rw-------  1 david  staff   3258 Feb 27 10:16 go.mod\n-rw-r--r--  1 david  staff  94793 Feb 27 10:16 go.sum\ndrwx------  3 david  staff     96 Feb 27 10:15 hack/\n-rw-------  1 david  staff   2791 Feb 27 10:15 main.go\n```", "```\n$ operator-sdk create api --group petstore --version v1alpha1 --kind Pet --resource --controller\nWriting kustomize manifests for you to edit...\nWriting scaffold for you to edit...\napi/v1alpha1/pet_types.go\ncontrollers/pet_controller.go\nUpdate dependencies:\n$ go mod tidy\nRunning make:\n$ make generate\ngo: creating new go.mod: module tmp\n# ... lots of go mod output ...\nNext: implement your new API and generate the manifests (e.g. CRDs,CRs) with:\n$ make manifests\n```", "```\n$ git status\nM  PROJECT\nA  api/v1alpha1/groupversion_info.go\nA  api/v1alpha1/pet_types.go\nA  api/v1alpha1/zz_generated.deepcopy.go\nA  config/crd/bases/petstore.example.com_pets.yaml\nA  config/crd/kustomization.yaml\nA  config/crd/kustomizeconfig.yaml\nA  config/crd/patches/cainjection_in_pets.yaml\nA  config/crd/patches/webhook_in_pets.yaml\nA  config/rbac/pet_editor_role.yaml\nA  config/rbac/pet_viewer_role.yaml\nA  config/samples/kustomization.yaml\nA  config/samples/petstore_v1alpha1_pet.yaml\nA  controllers/pet_controller.go\nA  controllers/suite_test.go\nM  go.mod\nM  main.go\n```", "```\n// EDIT THIS FILE!  THIS IS SCAFFOLDING FOR YOU TO OWN!\n// NOTE: json tags are required.  Any new fields you add must have json tags for the fields to be serialized.\n// PetSpec defines the desired state of Pet\ntype PetSpec struct {\n     // INSERT ADDITIONAL SPEC FIELDS - desired state of cluster\n     // Important: Run \"make\" to regenerate code after modifying this file\n     // Foo is an example field of Pet. Edit pet_types.go to remove/update\n     Foo string `json:\"foo,omitempty\"`\n}\n// PetStatus defines the observed state of Pet\ntype PetStatus struct {\n     // INSERT ADDITIONAL STATUS FIELD - define observed state of cluster\n     // Important: Run \"make\" to regenerate code after modifying this file\n}\n```", "```\n//+kubebuilder:object:root=true\n//+kubebuilder:subresource:status\n// Pet is the Schema for the pets API\ntype Pet struct {\n     metav1.TypeMeta   `json:\",inline\"`\n     metav1.ObjectMeta `json:\"metadata,omitempty\"`\n     Spec   PetSpec   `json:\"spec,omitempty\"`\n     Status PetStatus `json:\"status,omitempty\"`\n}\n//+kubebuilder:object:root=true\n// PetList contains a list of Pet\ntype PetList struct {\n     metav1.TypeMeta `json:\",inline\"`\n     metav1.ListMeta `json:\"metadata,omitempty\"`\n     Items           []Pet `json:\"items\"`\n}\nfunc init() {\n     SchemeBuilder.Register(&Pet{}, &PetList{})\n}\n```", "```\ntype PetReconciler struct {\n     client.Client\n     Scheme *runtime.Scheme\n}\n//+kubebuilder:rbac:groups=petstore.example.com,resources=pets,verbs=get;list;watch;create;update;patch;delete\n//+kubebuilder:rbac:groups=petstore.example.com,resources=pets/status,verbs=get;update;patch\n//+kubebuilder:rbac:groups=petstore.example.com,resources=pets/finalizers,verbs=update\nfunc (r *PetReconciler) Reconcile(ctx context.Context, req ctrl.Request) (ctrl.Result, error) {\n     _ = log.FromContext(ctx)\n     return ctrl.Result{}, nil\n}\nfunc (r *PetReconciler) SetupWithManager(mgr ctrl.Manager) error {\n     return ctrl.NewControllerManagedBy(mgr).\n          For(&petstorev1alpha1.Pet{}).\n          Complete(r)\n}\n```", "```\n// PetType is the type of the pet. For example, a dog.\n// +kubebuilder:validation:Enum=dog;cat;bird;reptile\ntype PetType string\nconst (\n    DogPetType     PetType = \"dog\"\n    CatPetType     PetType = \"cat\"\n    BirdPetType    PetType = \"bird\"\n    ReptilePetType PetType = \"reptile\"\n)\n// PetSpec defines the desired state of Pet\ntype PetSpec struct {\n     // Name is the name of the pet\n     Name string `json:\"name\"`\n     // Type is the type of pet Type PetType `json:\"type\"`\n     // Birthday is the date the pet was born\n     Birthday metav1.Time `json:\"birthday\"`\n}\n// PetStatus defines the observed state of Pet\ntype PetStatus struct {\n    // ID is the unique ID for the pet\n    ID string `json:\"id,omitempty\"`\n}\n```", "```\n// Reconcile moves the current state of the pet to be the desired state described in the pet.spec.\nfunc (r *PetReconciler) Reconcile(ctx context.Context, req ctrl.Request) (result ctrl.Result, errResult error) {\n     logger := log.FromContext(ctx)\n     pet := &petstorev1.Pet{}\n     if err := r.Get(ctx, req.NamespacedName, pet); err != nil {\n          if apierrors.IsNotFound(err) {\n               logger.Info(\"object was not found\")\n               return reconcile.Result{}, nil\n          }\n          logger.Error(err, \"failed to fetch pet from API server\")\n          // this will cause this pet resource to be requeued\n          return ctrl.Result{}, err\n     }\n     helper, err := patch.NewHelper(pet, r.Client)\n     if err != nil {\n          return ctrl.Result{}, errors.Wrap(err, \"failed to create patch helper\")\n     }\n     defer func() {\n          // patch the resource\n          if err := helper.Patch(ctx, pet); err != nil {\n               errResult = err\n          }\n     }()\n     if pet.DeletionTimestamp.IsZero() {\n          // the pet is not marked for delete\n          return r.ReconcileNormal(ctx, pet)\n     }\n     // pet has been marked for delete\n     return r.ReconcileDelete(ctx, pet)\n}\n```", "```\nfunc (r *PetReconciler) ReconcileNormal(ctx context.Context, pet *petstorev1.Pet) (ctrl.Result, error) {\n     controllerutil.AddFinalizer(pet, PetFinalizer)\n     psc, err := getPetstoreClient()\n     if err != nil {\n          return ctrl.Result{}, errors.Wrap(err, \"unable to construct petstore client\")\n     }\n\n     psPet, err := findPetInStore(ctx, psc, pet)\n     if err != nil {\n          return ctrl.Result{}, errors.Wrap(err, \"failed trying to find pet in pet store\")\n     }\n     if psPet == nil {\n          // no pet was found, create a pet in the store\n          err := createPetInStore(ctx, pet, psc)\n          return ctrl.Result{}, err\n     }\n     // pet was found, update the pet in the store\n     if err := updatePetInStore(ctx, psc, pet, psPet.Pet); err != nil {\n          return ctrl.Result{}, err\n     }\n     return ctrl.Result{}, nil\n}\n```", "```\nfunc createPetInStore(ctx context.Context, pet *petstorev1.Pet, psc *psclient.Client) error {\n     pbPet := &pb.Pet{\n          Name:     pet.Spec.Name,\n          Type:     petTypeToProtoPetType(pet.Spec.Type),\n          Birthday: timeToPbDate(pet.Spec.Birthday),\n     }\n     ids, err := psc.AddPets(ctx, []*pb.Pet{pbPet})\n     if err != nil {\n          return errors.Wrap(err, \"failed to create new pet\")\n     }\n     pet.Status.ID = ids[0]\n     return nil\n}\n```", "```\nfunc updatePetInStore(ctx context.Context, psc *psclient.Client, pet *petstorev1.Pet, pbPet *pb.Pet) error {\n     pbPet.Name = pet.Spec.Name\n     pbPet.Type = petTypeToProtoPetType(pet.Spec.Type)\n     pbPet.Birthday = timeToPbDate(pet.Spec.Birthday)\n     if err := psc.UpdatePets(ctx, []*pb.Pet{pbPet}); err != nil {\n          return errors.Wrap(err, \"failed to update the pet in the store\")\n     }\n     return nil\n}\n```", "```\n// ReconcileDelete deletes the pet from the petstore and removes the finalizer.\nfunc (r *PetReconciler) ReconcileDelete(ctx context.Context, pet *petstorev1.Pet) (ctrl.Result, error) {\n     psc, err := getPetstoreClient()\n     if err != nil {\n          return ctrl.Result{}, errors.Wrap(err, \"unable to construct petstore client\")\n     }\n     if pet.Status.ID != \"\" {\n          if err := psc.DeletePets(ctx, []string{pet.Status.ID}); err != nil {\n               return ctrl.Result{}, errors.Wrap(err, \"failed to delete pet\")\n          }\n     }\n     // remove finalizer, so K8s can garbage collect the resource.\n     controllerutil.RemoveFinalizer(pet, PetFinalizer)\n     return ctrl.Result{}, nil\n}\n```", "```\n$ ctlptl create cluster kind --name kind-petstore --registry=ctlptl-registry\n$ tilt up\n```", "```\n---\napiVersion: petstore.example.com/v1alpha1\nkind: Pet\nmetadata:\n  name: pet-sample1\nspec:\n  name: Thor\n  type: dog\n  birthday: 2021-04-01T00:00:00Z\n---\napiVersion: petstore.example.com/v1alpha1\nkind: Pet\nmetadata:\n  name: pet-sample2\nspec:\n  name: Tron\n  type: cat\n  birthday: 2020-06-25T00:00:00Z\n```", "```\n$ kubectl apply -f config/samples/petstore_v1alpha1_pet.yaml\n```", "```\n$ kubectl get pets\nNAME          AGE\npet-sample1   2m17s\npet-sample2   2m17s\n```", "```\n$ kubectl get pets -o yaml\napiVersion: petstore.example.com/v1alpha1\nkind: Pet\nmetadata:\n  finalizers:\n  - pet.petstore.example.com\n  name: pet-sample2\n  namespace: default\nspec:\n  birthday: \"2020-06-25T00:00:00Z\"\n  name: Tron\n  type: cat\nstatus:\n  id: 23743da5-34fe-46f6-bed8-1f5bdbaabbe6\n```", "```\n$ kubectl edit pets pet-sample1\n```", "```\n[manager] 1.6466368389433222e+09     INFO     controller.pet     finding pets in store     {\"reconciler group\": \"petstore.example.com\", \"reconciler kind\": \"Pet\", \"name\": \"pet-sample1\", \"namespace\": \"default\", \"pet\": \"Thorbert\", \"id\": \"cef9499f-6214-4227-b217-265fd8f196e6\"}\n```", "```\n$ kubectl delete pets --all\npet.petstore.example.com \"pet-sample1\" deleted\npet.petstore.example.com \"pet-sample2\" deleted\n```"]