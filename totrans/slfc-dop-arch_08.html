<html><head></head><body>
		<div id="_idContainer032">
			<h1 class="chapter-number" id="_idParaDest-150"><a id="_idTextAnchor177"/>8</h1>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor178"/>Ticketing Systems</h1>
			<p>In this chapter, we’ll discuss the benefits of tracking your Salesforce changes in a ticketing system and how it contributes to a more efficient DevOps process. We’ll then look at three of the most common tools for tracking the progress of changes <span class="No-Break">in Salesforce:</span></p>
			<ul>
				<li><strong class="bold">JIRA</strong> is an issue-tracking <a id="_idIndexMarker329"/>and project management software developed by Atlassian that allows teams to plan, track, and <span class="No-Break">release software</span></li>
				<li><strong class="bold">Asana</strong> is a work <a id="_idIndexMarker330"/>management platform that helps teams collaborate, communicate, and coordinate work <span class="No-Break">across projects</span></li>
				<li><strong class="bold">Azure Work Items</strong> are development tasks that are tracked in Azure DevOps to manage <a id="_idIndexMarker331"/>agile development processes and ship software <span class="No-Break">more frequently</span></li>
			</ul>
			<p>By the end of the chapter, you will have a clear idea of not only the differences between these different types of packages but also when to use them and how to build them <span class="No-Break">in Salesforce.</span></p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor179"/>Technical requirements</h1>
			<p>While this chapter isn’t intended to be a direct step-by-step guide for the products covered, should you wish to explore them, each one provides a free trial with which <span class="No-Break">to learn:</span></p>
			<ul>
				<li>JIRA – <a href="https://www.atlassian.com/software/jira"><span class="No-Break">https://www.atlassian.com/software/jira</span></a></li>
				<li>Asana – <a href="https://asana.com/"><span class="No-Break">https://asana.com/</span></a></li>
				<li>Azure DevOps – <a href="https://azure.microsoft.com/en-gb/free"><span class="No-Break">https://azure.microsoft.com/en-gb/fr<span id="_idTextAnchor180"/>ee</span></a></li>
			</ul>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor181"/>The benefits of tracking your work</h1>
			<p>The foundation of any successful project relies on an organized approach toward task management <a id="_idIndexMarker332"/>and tracking. Utilizing a ticketing system in Salesforce DevOps offers <span class="No-Break">multiple advantages.</span></p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor182"/>Transparency</h2>
			<p>All tasks and their statuses are visible to team members, fostering open communication and promoting teamwork. When everyone has visibility into what needs to be done and who is working on what, it eliminates duplicative work and makes <span class="No-Break">coordinating easier.</span></p>
			<p>This visibility <a id="_idIndexMarker333"/>provides benefits at multiple levels – for individual team members, team managers, cross-functional stakeholders, and leadership. For team members, having all tasks<a id="_idTextAnchor183"/> and current statuses in a central ticketing system lets everyone see what needs to be worked on and who is working on what. Immediately, developers can check which tickets are <strong class="bold">In progress</strong> versus <strong class="bold">In code review</strong> or <strong class="bold">Ready for testing</strong>. Testers can view what items are queued up <span class="No-Break">for validation.</span></p>
			<p>This real-time visibility eliminates duplicating efforts since people can coordinate based on the latest information. Team members don’t waste time working on the same task or miss blockers that are impeding progress. For managers, ticketing transparency helps gauge team workload, identify bottlenecks, and assess resource needs. A ticket backlog provides data to plan capacity. Tickets waiting for acceptance reveal where processes are <span class="No-Break">slowing down.</span></p>
			<p>Across teams such as product, UX, development, and QA, ticketing gives cross-functional transparency. Stakeholders can monitor progress on features or projects that require collaboration. Insight into each other’s workstreams enables <span class="No-Break">better coordination.</span></p>
			<p>For leadership, ticket data rolls up into reports that reflect completion rates, cycle times, and throughput. This high-level transparency helps executives understand team productivity, prioritization, and progress toward <span class="No-Break">strategic goals.</span></p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor184"/>Accountability</h2>
			<p>Each ticket is assigned to a particular team member, which aids in individual performance tracking. With tickets tied to individuals, it is clear who is responsible for completing specific tasks that support <span class="No-Break">monitoring productivity.</span></p>
			<p>With a ticket <a id="_idIndexMarker334"/>assigned to a specific person, there is no ambiguity about who owns the work. Responsibilities are clear, which prevents tasks from slipping through the cracks if no one takes charge. Team members can be held accountable for meeting deadlines and <span class="No-Break">delivering results.</span></p>
			<p>Having tickets tied to owners enables monitoring productivity at an individual level. Both team members and managers can quickly check the status of a person’s assigned tickets to assess workloads and completion rates. This supports tracking performance <span class="No-Break">and progress.</span></p>
			<p>If certain <a id="_idIndexMarker335"/>tickets are stalled, it’s evident which team member needs to be approached to remove roadblocks. Similarly, when tickets exceed <strong class="bold">service-level agreements</strong> (<strong class="bold">SLAs</strong>), the accountable owner can be notified to take expedient action. From a project management perspective, being able to filter and view tickets by assignee makes it easy to gauge capacity and balance workloads across the team. Adding or removing team members from tickets helps scale <span class="No-Break">resources appropriately.</span></p>
			<p>Beyond just assignments, some ticketing systems allow setting due dates, time estimates, and reminders. These features provide further accountability guardrails to help team members manage their time <span class="No-Break">and priorities.</span></p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor185"/>Prioritization</h2>
			<p>Ticketing also facilitates prioritization. Tickets can be marked with priority levels or tagged, which allows the team to focus on the most business-critical <span class="No-Break">items first.</span></p>
			<p>One method is <a id="_idIndexMarker336"/>assigning priority levels such as P1, P2, and P3 to tickets. P1 tickets would be critical issues or high-priority features that need to be worked on first. P2 and P3 tickets have lower priority and can be queued up behind <span class="No-Break">higher-priority work.</span></p>
			<p>Teams can also categorize tickets based on the type of work such as bugs, improvements, new features, and so on. Critical bugs that are impairing production systems would get prioritized above <span class="No-Break">feature enhancements.</span></p>
			<p>In agile frameworks such as Scrum, prioritization is managed through product backlogs. Backlog items are ordered with the highest-value items at the top to be completed first in upcoming sprints. Some ticketing systems have built-in processes for validating and ranking requested work relative to business value before adding tickets. This gates entry into the backlog <a id="_idIndexMarker337"/>based on priority. Within a sprint backlog, assigning point values to tickets based on estimated effort also allows ordering by priority. Larger point tickets get worked <span class="No-Break">on earlier.</span></p>
			<p>At the team level, daily standups provide an opportunity to re-prioritize if any urgent or blocked tasks come up. Adjusting ticket priorities keeps the team focused. From a portfolio perspective, tagging tickets by strategic themes or objectives aids leadership in assessing priority across multiple projects <span class="No-Break">and products.</span></p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor186"/>Documentation</h2>
			<p>In addition, ticketing provides central documentation. Instead of valuable information being scattered <a id="_idIndexMarker338"/>across tools and conversations, details about tasks are documented within each ticket, creating a knowledge base that persists over time. This includes background details and context, requirements, acceptance criteria, design specifications, configurations, procedures, code snippets, testing steps, communications, <span class="No-Break">and more.</span></p>
			<p>Without ticketing, these important work details end up scattered across Slack conversations, emails, wikis, documents, Post-it notes, and individual notebooks. Critical information gets siloed and hard to find. However, with a unified ticketing system, everything related to a task is documented in one place in an organized manner. Team members can easily get up to speed on a ticket by reviewing its history <span class="No-Break">and attachments.</span></p>
			<p>Searching tickets allows quickly finding past solutions that can be applied to current issues or requirements. It prevents duplicating efforts when similar work has already been completed and documented. Well-documented tickets create organizational memory that persists even when team members leave or roles change. Historical tickets become valuable references and <span class="No-Break">training resources.</span></p>
			<p>From a process perspective, ticketing enables standardizing documentation practices across teams. Template ticket types can be defined to guide consistent information capture as tasks flow <span class="No-Break">through workstreams.</span></p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor187"/>Collaboration</h2>
			<p>In each of the chapters so far, collaboration is a recurring element of a successful Salesforce DevOps strategy. Having a unified ticketing system also aids collaboration across teams <a id="_idIndexMarker339"/>such as product, development, QA, support, and so on. It creates a shared source of truth for <span class="No-Break">cross-functional transparency.</span></p>
			<p>This transparency has a great deal of practical advantages. While individual items will still be controlled by the product owner in the early stages, a visible backlog presents a good opportunity for the development team to have input into stories that they feel might be too large or complex and need to break apart. It also allows the team to sketch out high-level implementation plans for stories and keep them together so that an individual developer isn’t left having to create a solution on their own, and that there’s a degree of consistency of approach regardless of who specifically picks up <span class="No-Break">a ticket.</span></p>
			<p>Ticketing systems create a common platform for these diverse teams to gain visibility into each other’s workstreams. For example, the product team can monitor engineering tickets to track progress on new features. Support can check the status of pending bug fixes. This insight across departments enables the identification of dependencies and risks early. Seeing blockers ahead of time allows teams to proactively collaborate on solutions instead of reacting down <span class="No-Break">the line.</span></p>
			<p>Tickets provide a centralized communication channel beyond just status updates. Teams can use the <strong class="source-inline">@mention</strong>  function for relevant members for input, clarifying requirements, request approvals, or escalating issues through comments. For complex projects, people from different teams can be assigned jointly to collaborative tickets. This ensures alignment through <span class="No-Break">shared ownership.</span></p>
			<p>Some ticketing systems have agile project management capabilities, such as Kanban bo<a id="_idTextAnchor188"/>ards. This provides a visual collaborative workspace to manage tickets flowing through various stages. The ability to convert issues into actionable tickets and vice versa streamlines hand-offs between teams. Seamless transitions reduce fall-throughs during cross-functional workflows. An additional benefit of Kanban boards is the ability to limit the amount of work in progress at any given point in the life cycle. Not only does this help not overload development teams, but it also provides great visibility of the efficiency of your process. The limit in a particular column might mean things aren’t leaving quickly enough, are coming in too quickly, <span class="No-Break">or both.</span></p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor189"/>Reporting and analytics</h2>
			<p>Ticketing systems collect valuable data that can be used to generate insightful reports and metrics <a id="_idIndexMarker340"/>on development workflows. This supports data-driven decisions and process improvements. Common ticket reports include summarizing workload by assignee, ticket type, priority, project, and so on. These views help identify bottlenecks and <span class="No-Break">resource gaps.</span></p>
			<p>Trend reports track things such as tickets opened/closed over time. Analytics around cycle time – from ticket creation to completion – help monitor the efficiency of development processes. Cycle time by ticket type or project provides insights into what areas need streamlining. Dashboard views can visually track ticket backlogs and SLA adherence. Other key metrics are lead time, throughput, and WIP limits – all of which help optimize <span class="No-Break">process flows.</span></p>
			<p>Reporting on time logged against tickets aids the accuracy of release and sprint planning based on historical velocity. Comparing estimated versus actual time helps improve effort estimation. For productivity, reports can show ticket completion rates by individual team members. Analyzing patterns may indicate the need for training, tooling improvements, <span class="No-Break">or reallocations.</span></p>
			<p>Overall, data analytics helps correlate how process changes impact ticket throughput and cycle time. This guides where to focus optimization efforts for <span class="No-Break">maximum gains.</span></p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor190"/>Potential pitfalls</h2>
			<p>While ticketing systems in Salesforce DevOps offer considerable advantages, it’s crucial to acknowledge <a id="_idIndexMarker341"/>their potential pitfalls. One major risk is mistaking a backlog of tickets for actual planning. A well-maintained backlog is undoubtedly beneficial, but it’s no substitute for comprehensive plans, such as quarterly roadmaps, that provide a broader strategic view of the project’s objectives <span class="No-Break">and timelines.</span></p>
			<p>Another challenge lies in the nature of the content within the tickets. Relying solely on tickets for documentation can lead to fragmented and scattered information. This fragmentation makes it difficult to form a coherent, up-to-date picture of the project, as opposed to when well-organized, centralized documentation is available. It’s vital to complement ticketing systems with robust documentation practices to ensure clarity <span class="No-Break">and continuity.</span></p>
			<p>Lastly, the explicit handover of tickets between teams, if not managed thoughtfully, can lead to siloed operations. This runs counter to the ethos of DevOps, which emphasizes collaboration <a id="_idIndexMarker342"/>and integration across different teams. It’s essential to foster a culture where ticketing enhances communication and cooperation rather than creating barriers between different parts of <span class="No-Break">the organization.</span></p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor191"/>JIRA</h1>
			<p>JIRA, developed by Atlassian, is one of the most popular ticketing and project management tools, widely used for bug tracking, issue tracking, and agile project management. One of <a id="_idIndexMarker343"/>its main strengths is its flexibility. Teams can customize their workflows, create custom fields, and use various plugins to suit their unique needs. It integrates s<a id="_idTextAnchor192"/>eamlessly with Salesforce, providing a unified and <span class="No-Break">efficient workspace.</span></p>
			<p>In a Salesforce DevOps context, JIRA can streamline the work process by creating a ticket for every task, bug, or feature. These tickets can be assigned, prioritized, and tracked until completion. JIRA’s reporting features give useful insights into the team’s performance, while its robust search capabilities help quickly find issues <span class="No-Break">or tickets.</span></p>
			<p>JIRA plays an integral role in managing end-to-end Salesforce development processes and enhancing DevOps collaboration through its flexible workflows <span class="No-Break">and customizability.</span></p>
			<p>Let’s look at a typical project workflow that uses JIRA to manage tasks. Our example assumes a reasonably large enterprise team made up of multiple roles, as this is the most typical use case seen with <span class="No-Break">JIRA implementations.</span></p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor193"/>The JIRA project life cycle</h2>
			<p>When starting the quarterly road mapping process, product managers rely on JIRA epics to define the <a id="_idIndexMarker344"/>major themes, features, and initiatives slated for the upcoming release. These high-level epics establish goals and direction for the team. As the product team delves further into details, those broad epics become populated with granular user stories, bugs, tasks, and subtasks. This hierarchy of issues captures both the big-picture vision and the incremental work needed to deliver <span class="No-Break">on it.</span></p>
			<p>By sprint planning, JIRA contains a trove of well-defined issues ready for execution. The Scrum team heavily utilizes JIRA’s agile capabilities to estimate issues, apply story points, and negotiate scope for the sprint. Release plans take shape by mapping dependencies and structuring issues into coherent sprints. Owners are assigned, risks discussed, and assumptions challenged so the team <span class="No-Break">is aligned.</span></p>
			<p>Once the sprint is underway, developers take ownership of JIRA issues to build solutions to complex problems. JIRA is tightly integrated into the entire development workflow for traceability and automation. User stories are worked on in feature branches in Git that reference the JIRA issue number. All commits explain the work done and map to an issue in commit messages. Pull requests for peer code reviews also call out the issues <span class="No-Break">they address.</span></p>
			<p>This connectivity between Git and JIRA provides end-to-end traceability on code changes tied to issues. It also enables automation opportunities. Code builds can intake JIRA issue IDs to <a id="_idIndexMarker345"/>automatically link failures and test results as comments or child issues. Transitioning issues through workflow stages can trigger events in continuous integration such as build jobs, deployments, <span class="No-Break">or notifications.</span></p>
			<p>For example, when a developer completes coding for a user story, they merge the feature branch to the main branch. This triggers a continuous integration job that runs Apex tests and static analysis. If any failures arise, they are logged as child issues of the story in JIRA for the developer to address. Successful builds can automatically deploy the code changes to a Salesforce sandbox for QA testing. JIRA issues then progress to the QA testing and validation stages of <span class="No-Break">the workflow.</span></p>
			<p>QA engineers take an active role in Salesforce DevOps by automating validation to accelerate release cycles while improving quality. JIRA supports this through linked test cases, defects, and tight integration with CI/CD pipelines. QA logs detailed test steps, results, questions, media, and other issue comments as they verify user stories against <span class="No-Break">acceptance criteria.</span></p>
			<p>For efficient regression testing, they build automated test suites using frameworks such as Selenium and Jasmine for UI testing, and Apex unit tests for logic testing. These automated tests execute as part of continuous integration against feature branches and mainline code. QA sets up quality gates, so builds only progress if tests pass and code coverage thresholds <span class="No-Break">are met.</span></p>
			<p>Static code analysis is also baked into builds to check for vulnerabilities and enforce custom rulesets around code quality and best practices. Failures from any of these checks are logged as child issues or bugs, providing an audit trail on <span class="No-Break">quality evolution.</span></p>
			<p>When all automated validations pass and QA completes exploratory testing, the user story transitions through the JIRA workflow. This can often trigger a continuous delivery workflow to automatically deploy and validate the changes in a Salesforce sandbox. Downstream teams are notified of the deployment for user acceptance testing. However, there are some caveats to be aware of in this approach – if that deployment fails for some reason, you also need to handle that and revert the status to whatever it was before, which can certainly be more complex. It’s also worth noting that some teams enforce a “swim lane limit” on their JIRA boards to prevent too much work sitting at any one status. So, even if you do manage to revert the status of a ticket that is associated with a failed deployment, there might not be room to move it back to a work-in-progress status. To address these types of issues, many teams take the opposite approach, in which a JIRA ticket status is only updated upon <span class="No-Break">successful deployment.</span></p>
			<p>This comprehensive <a id="_idIndexMarker346"/>automation of unit, integration, UI, performance, security, compliance, and deployment testing enables rapid feedback on quality. JIRA provides traceability on tests, validations, and code changes tied to issues being delivered, while automation frees up QA staff for higher-value testing while enforcing <span class="No-Break">quality standards.</span></p>
			<p>JIRA is invaluable in enabling the communication rhythms and transparency needed for Salesforce DevOps collaboration. Standups centered around JIRA issues provide quick status checks on blockers and progress. Retrospectives leverage JIRA data on cycle times and velocity to continuously <span class="No-Break">improve processes.</span></p>
			<p>JIRA helps embed DevOps practices even without explicit agile frameworks. Breaking work into small issues enables rapid delivery and feedback. Tracking issues through defined workflows mirrors pipeline orchestration. Automated hand-offs based on JIRA transitions increase collaboration <span class="No-Break">across teams.</span></p>
			<p>Powerful reporting and dashboards spotlight trends, risks, and dependencies. Activity streams and notifications keep everyone informed of issue changes in real time. This level of transparency supported by JIRA fosters shared ownership <span class="No-Break">across silos.</span></p>
			<p>Requirements and acceptance criteria logged in JIRA aid collaboration between developers, QA, security, and other teams. Smooth hand-offs happen by aligning early on issue details rather than <span class="No-Break">last-minute surprises.</span></p>
			<p>JIRA provides a digital backbone that enables Salesforce teams to inspect and adapt quickly based on real-time data. Tight integration with version control, test automation, and CI/CD pipelines accelerates <span class="No-Break">feedback cycles.</span></p>
			<p>Standups, retros, sprint planning, and work coordination all revolve around JIRA. It is an indispensable tool that empowers teams to deliver faster while improving quality and processes. JIRA can help cement an environment of continuous improvement, transparency, automation, and collaboration – the foundations <span class="No-Break">of DevOps.</span></p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor194"/>A high-level JIRA workflow</h2>
			<p>Your first step should be to create a JIRA project for your Salesforce release, with issue types for user stories, bugs, tasks, and so on. Within this project, you should then create epics to capture <a id="_idIndexMarker347"/>major features and initiatives for the release, and then break those epics down into <span class="No-Break">user stories.</span></p>
			<p>Developers pick up user stories from the backlog for sprint planning. Stories are estimated and prioritized before the u<a id="_idTextAnchor195"/>ser stories in the sprint are moved to <span class="No-Break"><strong class="bold">In Progress</strong></span><span class="No-Break">.</span></p>
			<p>Developers commit code to Git feature branches, referencing the JIRA issue number that relates to the user story. Once the work for an individual user story is complete, developers open pull requests when feature branches are ready for review. Pull requests link back <span class="No-Break">to JIRA.</span></p>
			<p>After some code review by peers, the pull requests are merged into the main branch, which may kick off automated builds. These builds execute Apex tests and static code analysis, with any failures tracked as issues <span class="No-Break">i<a id="_idTextAnchor196"/>n JIRA.</span></p>
			<p>Successful builds can deploy code to a full copy sandbox for QA testing. QA tests user stories and logs any bugs as issues in JIRA for the developers to remediate. When user story acceptance criteria are met, QA moves the story to the <strong class="bold">QA </strong><span class="No-Break"><strong class="bold">Approved </strong></span><span class="No-Break">state.</span></p>
			<p>A project manager should review the completed stories, with the product owner providing final approval. The project manager then batches approved stories for deployment to production via <span class="No-Break">change sets.</span></p>
			<p>A release manager typically coordinates the User Acceptance Testing (UAT) process and final deployment to production. After a successful release, the user stories are then marked <span class="No-Break">as closed.</span></p>
			<p>In the final review phase following a release, metrics can be gathered on team velocity, defect rates, and so on, and then the process repeats for subsequent sprints <span class="No-Break">and releases.</span></p>
			<p>This covers major steps such as sprint planning, CI/CD, code changes tied to issues, QA testing, approvals, and releases. The workflow is highly customizable in JIRA for each team’s needs – this is just a reasonably <span class="No-Break">typical example.</span></p>
			<h1 id="_idParaDest-164"><a id="_idTextAnchor197"/>Asana</h1>
			<p>Asana provides a powerful work management platform designed to help teams effectively coordinate, track, and deliver work across the organization. At its core, Asana enables the creation <a id="_idIndexMarker348"/>of flexible workflows that map to team processes with customizable stages to track task status. Tasks can be organized in list views, kanban-style board views, or calendar views based on what works best for <span class="No-Break">each team.</span></p>
			<p>Adopting Asana as the project management platform of choice can significantly enhance a Salesforce development team’s ability to plan, track, and collaborate on everything from new feature requests to production bug fixes. By mirroring their entire development life cycle across differentiated Asana projects, teams gain end-to-end visibility and control across <span class="No-Break">the process.</span></p>
			<p>For example, creating separate projects for <strong class="bold">Backlog</strong>, <strong class="bold">In Development</strong>, <strong class="bold">Code Review</strong>, <strong class="bold">QA Testing</strong>, and <strong class="bold">Production Release</strong> provides a logical way to segment work as it flows from idea to deployment. Teams can further organize by dividing each project into sections based on workstream, application, or initiative. This helps cluster-related tasks and ensures continuity <span class="No-Break">of effort.</span></p>
			<p>With this foundation in place, let’s walk through how Asana can optimize productivity and coordination from initial intake through <span class="No-Break">final release.</span></p>
			<h2 id="_idParaDest-165"><a id="_idTextAnchor198"/>The Asana project life cycle</h2>
			<p>First, requirement gathering is streamlined by creating a task for each new feature or enhancement request. The task can include a high-level description, expected delivery timeline, assignment to the appropriate developer or team, links to related documentation or tickets, and any other <span class="No-Break">supporting details.</span></p>
			<p>Capturing requests <a id="_idIndexMarker349"/>in Asana provides traceability and easy reference later in the process. Custom fields can be defined to match the team’s way of working – for example, indicating the priority, level of effort, dependencies, or associated releases for <span class="No-Break">each task.</span></p>
			<p>During sprint planning and backlog grooming, managers can survey the landscape of outstanding requests and schedule the highest-value ones into upcoming iterations. Setting milestones and dependencies between tasks ensures proper sequencing and delivery <span class="No-Break">of functionality.</span></p>
			<p>Once tasks are ready for active development, they can be moved into the <strong class="bold">In Development</strong> project. This provides developers with a clear view of their workload for the sprint. As work gets completed, developers can easily update the task status, log hours, attach screenshots or code snippets, and provide any other relevant commentary right <span class="No-Break">within Asana.</span></p>
			<p>For developers, Asana acts as a central workspace to track and execute their assigned tasks during the development phase. As soon as work is identified during sprint planning, corresponding tasks are created in an <strong class="bold">In Development</strong> Asana project and assigned to developers based on their roles <span class="No-Break">and capabilities.</span></p>
			<p>These tasks c<a id="_idTextAnchor199"/>ontain <a id="_idIndexMarker350"/>all necessary context such as descriptions, due dates, story points, links to tickets or specs, and tags indicating the applications or features being worked on. By consolidating all this information in Asana, developers have clarity on what needs to be done without having to dig through inboxes or <span class="No-Break">chat histories.</span></p>
			<p>As work begins, developers can break down larger tasks into granular subtasks to represent stages of completion. They can also log hours directly within Asana to capture the time spent on each task. Inline comments allow developers to provide updates on progress, ask clarifying questions, or <span class="No-Break">request feedback.</span></p>
			<p>Code samples, screenshots, and other relevant artifacts can be attached to tasks as they are generated. Mentioning colleagues brings them into the conversation as needed. This creates a running record of progress and knowledge sharing that lives with <span class="No-Break">the task.</span></p>
			<p>For blocked or delayed tasks, developers can quickly raise red flags by updating statuses and notifying managers. Upon completion, tasks are marked as <strong class="bold">Ready for QA</strong>, which automatically routes them to the next stage in the workflow. Integrations with source control tools such as Git and Jenkins mean code commits and builds can automatically advance tasks through <span class="No-Break">the pipeline.</span></p>
			<p>Upon feature completion, work moves into the <strong class="bold">Code Review</strong> project where QA engineers validate implementation according to specifications. If issues are identified, they can spawn new bug tasks linked to the parent for traceability. This tightens the feedback loop for developers. Once approved by QA, thoroughly tested code progresses to user acceptance testing and <span class="No-Break">staging deployment.</span></p>
			<p>Automated integrations can be configured to update the task status upon successful deployment to each environment. This saves teams time manually tracking release activity. As work nears production readiness, the change log within Asana gives managers full context into what is slated to be released. Immediately, they can review all completed tasks, affected components, dependencies, and <span class="No-Break">expected impact.</span></p>
			<p>This level of transparency keeps managers informed and surfaces any roadblocks early. Team members can also be <strong class="source-inline">@mentioned</strong> in comments to loop them into discussions or solicit feedback on work in progress. If additional needs come up, new subtasks can be defined while retaining ties back to the original <span class="No-Break">parent task.</span></p>
			<p>With the full narrative visible, any last-minute changes can be minimized. After sign-off, the <strong class="bold">Go</strong> button can be clicked on approved production tasks. Peer reviews and spot checks post-deployment provide validation that everything rolled <span class="No-Break">out smoothly.</span></p>
			<p>Now complete, tasks get marked as <strong class="bold">closed</strong> in Asana, creating a permanent audit trail from inception to completion. When sized correctly, tasks closed per sprint indicate team velocity, which can influence future planning and resourcing. Reviewing cycle time per task also uncovers any lags <span class="No-Break">between environments.</span></p>
			<p>Ongoing governance <a id="_idIndexMarker351"/>of Asana is required to shape role-based permissions, customize fields, set up automation, and monitor adoption. Project and task templates will help codify best practices and give teams a head start. Regular Asana training will ensure that team members are getting the best use of the full breadth <span class="No-Break">of functionality.</span></p>
			<p>In common with other ticket-based task management systems, Asana contributes significantly to communication and collaboration within mature DevOps teams. For standups, tasks assigned to each developer are front-and-center with the latest updates visible. Team members can easily reference blocked tasks, new impediments, and the help needed to unblock progress. Managers gain insight into velocity across <span class="No-Break">working threads.</span></p>
			<p>Retrospectives are enhanced by looking at historical Asana data on cycle times, workload distribution, and completion rates by developer. This spurs data-driven root cause analysis and <span class="No-Break">process improvements.</span></p>
			<p>Backlog grooming is facilitated by having all candidate stories and defects sequenced in Asana with priority, scoping, and effort details. This information guides decision-making on what gets pulled into <span class="No-Break">upcoming sprints.</span></p>
			<p>The common thread is Asana centralizing all tasks, statuses, and supporting context to inform conversations. Unlike chat or email, this knowledge persists attached to tasks for future reference. Asana’s flexibility supports any preferred cadence of <span class="No-Break">team rituals.</span></p>
			<p>By providing transparency into who is doing what and by when, Asana fuels collaborative problem-solving, removal of blockers, and continuous improvement – core DevOps tenets. In this way, Asana contributes significantly to alignment, visibility, and velocity for Salesforce teams on the <span class="No-Break">DevOps journey.</span></p>
			<h2 id="_idParaDest-166"><a id="_idTextAnchor200"/>A high-level Asana workflow</h2>
			<p>Begin with <a id="_idIndexMarker352"/>creating Asana projects to represent each stage of your Salesforce development life cycle (e.g., <strong class="bold">Backlog</strong>, <strong class="bold">In Development</strong>, <strong class="bold">Code Review</strong>, <strong class="bold">QA Testing</strong>, and <strong class="bold">Production Release</strong>). Within each of these Asana projects, create sections for different workstreams such as new features, bugs, enhancements, and so on. When new tasks are created in Asana, link them to the corresponding Git repo for your project and branches that will contain the code changes for <span class="No-Break">each task.</span></p>
			<p>As developers work on tasks, they commit code changes frequently to Git branches named after the associated Asana task IDs. Upon completing development, developers push their feature branches to Git and move the Asana task into <span class="No-Break"><strong class="bold">Code Review</strong></span><span class="No-Break">.</span></p>
			<p>The QA team then pulls the feature branch to locally validate changes described in the Asana task, with any failures logged as new tasks. Once approved, the QA team merges validated code into a release candidate branch in Git. This triggers deployment to <span class="No-Break">downstream environments.</span></p>
			<p>Before the final production deployment, the Git diff is reviewed alongside the Asana change log as a final check. After the release branch is deployed to production, it is merged into the <span class="No-Break">main branch.</span></p>
			<p>All tasks related to the release are closed in Asana and, optionally, Git commit logs are linked to Asana tasks to maintain end-to-end traceability. As part of the release review process, code coverage and quality metrics are taken from Git to provide input on developer performance and areas <span class="No-Break">needing improvement.</span></p>
			<p>By integrating Git version control into this workflow, code changes are synchronized with project planning and testing processes in Asana. This provides comprehensive visibility <span class="No-Break">and traceability.</span></p>
			<h1 id="_idParaDest-167"><a id="_idTextAnchor201"/>Azure Work Items</h1>
			<p>Unlike the previous two solutions, Azure Work Items are a subset of the functionality of a much larger overall DevOps solution – one targeting multiple platforms, not just Salesforce. Azure <a id="_idIndexMarker353"/>DevOps provides a large set of collaborative development tools, including Azure Boards, and the Azure Work Items contained therein, for work tracking. When we look specifically at the parallels with JIRA or Asana, then Azure Boards, with its Work Items feature, helps teams plan, track, and discuss work across the entire <span class="No-Break">development cycle.</span></p>
			<p>Work Items in Azure DevOps are a way to track tasks, bugs, features, and more. They can be organized into a hierarchy, so you can break down a large feature into manageable tasks and track progress at each level. You can visualize your work with Kanban boards, backlogs, custom dashboards, and <span class="No-Break">reporting tools.</span></p>
			<p>Azure DevOps acts as the source of truth for development tasks while Salesforce provides customer insights directly from service, sales, and marketing teams. Viewing each of these data sources, with their different perspectives on the current state of your Salesforce system, creates a valuable view of priorities. For example, customer service agents can view Azure DevOps bugs and features within Salesforce cases to stay updated on issue resolution for customers. They can easily link bugs to support cases to showcase customer impact <span class="No-Break">to developers.</span></p>
			<p>Meanwhile, developers gain visibility into which bugs are linked to high-value accounts and opportunities nearing close. This helps technical teams prioritize the most critical defects over lesser items. Seeing the full context of each work item enables smarter triage and efficient use of development resources. Quicker resolution of high-priority defects improves customer retention <span class="No-Break">and satisfaction.</span></p>
			<p>On the flip side, when development teams complete items linked to Salesforce records, the changes instantly sync both ways. For instance, when a developer resolves a critical bug, the customer service agent sees the update in Salesforce immediately. This avoids unnecessary back-and-forth communication and keeps customers informed through <span class="No-Break">centralized data.</span></p>
			<p>With this bi-directional sync, work item updates in either system remain in real-time sync. Avoiding stale or duplicate data ensures accuracy and a single source of truth across departments. This increases process efficiency for collaborating on <span class="No-Break">defect resolution.</span></p>
			<p>Further enhancing collaboration, Salesforce users can easily track progress on Azure DevOps work from within familiar CRM views. For example, customer service managers can create custom Salesforce dashboards to monitor bug resolution timelines. Account managers can view features planned for a client right on the account record. There is no need to cross-reference disparate systems as all data lives natively in Salesforce. This simplifies how non-technical users interact with vital development tasks without needing to learn <span class="No-Break">Azure DevOps.</span></p>
			<p>Turning to the <a id="_idIndexMarker354"/>developer side, importing Azure DevOps Work Items into Salesforce grants new levels of customer insight to inform technical tasks. In traditional siloed models, developers have limited visibility into client needs and business objectives. By linking work items to accounts, opportunities, and support cases, the full context of each item <span class="No-Break">becomes clear.</span></p>
			<p>With this customer focus, developers can understand the experience and frustration behind certain bugs. Seeing linked support cases with exact user steps to reproduce an error brings clarity faster than traditional isolated tickets. Engineers gain empathy and appreciation for the customer journey, which inspires building features that truly solve <span class="No-Break">pain points.</span></p>
			<h2 id="_idParaDest-168"><a id="_idTextAnchor202"/>The Azure Work Items life cycle</h2>
			<p>Now, diving deeper into Azure DevOps’ role specifically in the development phase of the DevOps life cycle, seamless Azure integration facilitates developer productivity and collaboration. Within <a id="_idIndexMarker355"/>a single Azure DevOps workspace, development teams can plan agile sprints, create work items, conduct repositories for source code, execute builds, manage testing, track defects, deploy to staging environments, <span class="No-Break">and more.</span></p>
			<p>For example, a developer working on a user story can easily view linked bugs, test cases, branches, and builds all in one place. This removes toggling between disjointed systems to piece together context. Azure Boards tie connected items together for efficient coding with reduced overhead. Within boards, developers can assign granular tasks to individuals and track the hours spent on each item. This level of visibility enables accurate tracking of capacity and sprint progress. Automated burndown charts plot completion over time to pinpoint scope creep or blockers <span class="No-Break">needing resolution.</span></p>
			<p>For task management, customizable workflows enabled by Azure Boards allow the creation of subtasks, priority designation, status changes, assignment to individuals, tracking of remaining work, and more. Developers can break down larger stories into executable checklists of actionable <span class="No-Break">development items.</span></p>
			<p>With tasks established, developers utilize Azure Repos for secure source code management across Git and GitHub. Advanced version control features such as branching and merging enable developers to isolate changes during new feature creation. Repos safeguard code integrity throughout the <span class="No-Break">coding process.</span></p>
			<p>Next, by integrating with Azure Pipelines, developers can automatically build, test, and deploy with every code change to provide rapid feedback. Full traceability from commit to deployment simplifies root cause analysis. Failures get flagged quickly to <span class="No-Break">maintain velocity.</span></p>
			<p>For testing, developers <a id="_idIndexMarker356"/>leverage Azure Test Plans to create test cases that automatically integrate with builds. Testers can easily track which test cases need execution, view the status of test runs, and log defects. Linking bugs to failing tests <span class="No-Break">accelerates resolution.</span></p>
			<p>Throughout development, teams utilize collaborative tools such as customizable team dashboards, built-in wikis, and discussion threads for improving visibility and alignment. With everything housed in Azure, developers reduce task switching and stay focused. By centralizing the dev life cycle into Azure DevOps, developers gain an agile, productive, and collaborative environment that is purpose-built for modern development. Integrating these capabilities with customer data from Salesforce completes the contextual picture that developers need to deliver <span class="No-Break">innovative solutions.</span></p>
			<h2 id="_idParaDest-169"><a id="_idTextAnchor203"/>A high-level Azure Work Items workflow</h2>
			<p>To use Azure Work Items for tracking changes in a system using Azure DevOps Repos as the Git provider, you begin by setting up a project in Azure DevOps. This project serves as the central <a id="_idIndexMarker357"/>hub for both your code in Azure Repos and your project management activities in Azure Boards, which include your <span class="No-Break">work items.</span></p>
			<p>Once your project is established, the next step is to configure Azure Repos within this project. This involves initializing a new repository or importing an existing one into Azure Repos. This repository will store your code and track changes made <span class="No-Break">over time.</span></p>
			<p>After setting up your repository, the focus shifts to Azure Boards, where you manage your work items. These work items can range from features and user stories to tasks, bugs, and more, representing the different aspects of your project. The key here is to link these work items directly to the changes in your Azure Repos. This linking provides traceability and a clear history of what code changes relate to which <span class="No-Break">project tasks.</span></p>
			<p>To establish this link, when committing changes to your repository in Azure Repos, you include references to these work items in your commit messages. Azure DevOps automatically links these commits to the mentioned work items. For example, including a phrase such as <strong class="source-inline">Fixes AB#123</strong> in your commit message would link that commit to work item 123 in <span class="No-Break">Azure Boards.</span></p>
			<p>Within Azure Boards, you can view the development status and associated commits for each work item. This visibility allows you to track the progress of your development directly from the work items, offering a comprehensive view of both coding and project <span class="No-Break">management activities.</span></p>
			<p>This high-level <a id="_idIndexMarker358"/>workflow is integral for teams using Azure DevOps for their software development. It ensures a seamless integration between code management and project tracking, enhancing the overall efficiency and transparency of the <span class="No-Break">development process.</span></p>
			<p>For more detailed instructions and best practices, you should consult the official Azure DevOps documentation provided by Microsoft, which offers comprehensive guides and step-by-step tutorials for setting up and managing <span class="No-Break">these integrations.</span></p>
			<h2 id="_idParaDest-170"><a id="_idTextAnchor204"/>Using an Azure Work Items workflow with GitHub</h2>
			<p>It is equally possible to use GitHub as your main Git provider and still take advantage of the tracking <a id="_idIndexMarker359"/>capabilities<a id="_idTextAnchor205"/> of Azure Work Items. We first install the Microsoft Azure Boards application from the GitHub Marketplace, which authorizes the integr<a id="_idTextAnchor206"/>ation between the two systems. Within GitHub, under <strong class="bold">organization settings</strong>, we can verify that the Azure Boards GitHub app has been <span class="No-Break">authorized correctly.</span></p>
			<p>Next, in the <a id="_idIndexMarker360"/>Azure DevOps portal, we connect the Azure Boards organization to the designated GitHub account through <strong class="bold">GitHub Connections</strong>. Here, we specify the Azure DevOps organization, project, and repositories to sync with GitHub. Critical mappings are then configured in Azure Boards under the <em class="italic">repository mapping</em> section, aligning GitHub repos to Azure DevOps teams <span class="No-Break">and branches.</span></p>
			<p>With the integration setup, developers can now create pull requests and commit code changes within GitHub, referencing related Azure DevOps work items directly in the commit messages using the work item ID format prefixed with <strong class="source-inline">AB</strong> (for Azure Boards). For example, adding <strong class="source-inline">AB#206</strong> to your commit message would link to work item <span class="No-Break">ID 206.</span></p>
			<p>In the <a id="_idIndexMarker361"/>other direction, you can click the <strong class="bold">Add Link</strong> button on a work item and select <strong class="bold">Existing Item</strong> to add the URL link to a GitHub commit, pull request, or issue. This bidirectional linking between the two systems <a id="_idIndexMarker362"/>gives full traceability between coding activity and project tasks, user stories, bugs, and other work items managed in Azure Boards. The integration provides an efficient development workflow to maintain progress visibility as <span class="No-Break">code evolves.</span></p>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor207"/>Summary</h1>
			<p>In this chapter, we’ve discussed the enormous value and benefits that having a task tracking or ticketing system can bring when integrated into your DevOps workflow – both at a technical level through Git integration and in terms of giving visibility and organization of <span class="No-Break">your work.</span></p>
			<p>We looked at some of the common choices of tools that provide the capabilities needed to manage your tasks in a DevOps pipeline, as well as a high-level workflow for getting started with each system. Hopefully, this will give you both insight and inspiration to bring order to your development life cycle with these solutions. To aid your decision-making process, here’s a brief overview of each tool’s strengths <span class="No-Break">and weaknesses:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table001-4">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Feature</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">JIRA</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Asana</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Azure </strong><span class="No-Break"><strong class="bold">Work Items</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Strengths</strong></span></p>
						</td>
						<td class="No-Table-Style"/>
						<td class="No-Table-Style"/>
						<td class="No-Table-Style"/>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Project Management</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Advanced agile management, strong <span class="No-Break">bug tracking</span></p>
						</td>
						<td class="No-Table-Style">
							<p>User-friendly, great for task and <span class="No-Break">project management</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Comprehensive agile planning, integrated with <span class="No-Break">Azure DevOps</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Customization</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Highly customizable, adaptable to <span class="No-Break">complex workflows</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Simple, easy to use, with <span class="No-Break">basic customization</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Highly customizable, supports <span class="No-Break">complex workflows</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Integration</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Deep integration with other <span class="No-Break">Atlassian products</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Good integration with various apps, <span class="No-Break">including Salesforce</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Strong integration with Microsoft products <span class="No-Break">and services</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Reporting</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Robust reporting <span class="No-Break">and analytics</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Basic but user-friendly <span class="No-Break">reporting</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Detailed reporting, analytics, <span class="No-Break">and dashboards</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Collaboration</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Good for technical teams, <span class="No-Break">detailed tracking</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Excellent for cross-functional <span class="No-Break">team collaboration</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Effective for teams deeply integrated with the <span class="No-Break">Microsoft ecosystem</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Scalability</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Scales well for large and <span class="No-Break">complex projects</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Suitable for teams of <span class="No-Break">all sizes</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Ideal for large teams, especially in enterprise <span class="No-Break">environments</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Weaknesses</strong></span></p>
						</td>
						<td class="No-Table-Style" colspan="3"/>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">User Interface</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Complex interface, steeper <span class="No-Break">learning curve</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Limited features for complex <span class="No-Break">project management</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Can be overwhelming for <span class="No-Break">non-technical users</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Pricing</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Can be expensive, especially for <span class="No-Break">large teams</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Premium features require <span class="No-Break">paid plans</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Can be costly, especially with additional <span class="No-Break">Azure services</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Flexibility</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>May be overly complex for <span class="No-Break">simple projects</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Less flexible for complex, <span class="No-Break">technical projects</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Tied closely to other Azure services, less <span class="No-Break">standalone capability</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Initial Setup and </strong><span class="No-Break"><strong class="bold">Learning Curve</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Requires time to set up and learn, especially for <span class="No-Break">non-technical users</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Easy to start with but has limitations <span class="No-Break">for scaling</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Requires familiarity with the Microsoft <span class="No-Break">ecosystem</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Collaboration Outside </strong><span class="No-Break"><strong class="bold">Technical Teams</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Less intuitive for non-technical <span class="No-Break">team members</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Excellent for all <span class="No-Break">team types</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Best suited for teams already using <span class="No-Break">Microsoft tools</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 8.1 – A comparison of ticketing systems’ strengths and weaknesses</p>
			<p>In the next chapter, we’ll move on to another of the core pillars of Salesforce DevOps – backing up your data and your metadata. We’ll cover why it’s important to consider both as part of a robust backup strategy and discuss how the effectiveness of any backup lies in your ability to restore it quickly <span class="No-Break">and easily.</span></p>
		</div>
	</body></html>