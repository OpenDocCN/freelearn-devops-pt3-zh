- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How CI/CD Pipelines Enforce Good DevOps Release Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, you’ve learned that CI/CD is a key aspect of DevOps. Reusable, purpose-built
    CI/CD platforms maximize the value of each developer’s time. CI/CD improves an
    organization’s productivity by increasing efficiency and streamlining workflows
    by becoming a confluence of automation, testing, and collaboration. Additional
    DevOps enhancements, such as shifting left and creating tighter feedback loops,
    help enterprises dissolve silos, scale efficiently, and realize business value
    quicker than other release management methods.
  prefs: []
  type: TYPE_NORMAL
- en: Today’s release managers must be fluent in CI/CD procedures, DevOps, and automated
    deployment technologies. They need to be able to recognize problems at an early
    stage and have an understanding of how the CI/CD pipeline operates, which is essential
    to DevOps release management. In this chapter, we’ll discuss how CI/CD pipelines
    enforce good DevOps release management. The topics we’ll cover include managing
    speed-to-market and CI/CD governance, developing your team’s branching strategy,
    constructing release pipelines, implementing a change approval process that is
    appropriate for DevOps release management, and more!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding CI/CD governance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Branching strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Release pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding CI/CD governance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing governance in DevOps release management requires establishing an
    assortment of procedures aimed at creating oversight mechanisms within CI/CD infrastructure.
    This paradigm frequently incorporates a blend of access control management, compliance
    policies, automated testing, and manual review checkpoints. The principal focus
    of DevOps governance necessitates advancing the objectives of operational security
    and establishing a comprehensive framework for monitoring, approving, and documenting
    all modifications to ensure traceability.
  prefs: []
  type: TYPE_NORMAL
- en: To be comfortable with **CI/CD governance**, you must have a comprehensive understanding
    of how CI/CD pipelines function. As you learned in the previous chapter, CI/CD
    pipelines encompass a sequence of automated workflows, systems, and methods that
    are specifically devised to facilitate the swift and dependable delivery of new
    code, starting from a developer’s workstation to the production environment. This
    makes it simpler for developers to receive and act on input from end users. It
    is unambiguous that many risks that are typically associated with software delivery
    can be avoided when utilizing well-architected CI/CD pipeline infrastructure.
    Notably, CI/CD incentivizes development teams to commit software updates in lighter,
    tinier batches, compared to working on them all at once in one magnanimous effort.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, the rapid pace of development that is associated with DevOps release
    management may give rise to difficulties in effectively managing governance and
    mitigating security risks. As just one example, the use of open source software
    in production processes is a frequent source of concern for development teams.
    You won’t be able to predict if and when a vulnerability will affect a critical
    dependency in the source code without proper audits, analysis, and automated tests.
  prefs: []
  type: TYPE_NORMAL
- en: The OWASP Top 10 CI/CD Security Risks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CI/CD has emerged as a crucial element of contemporary software engineering
    practices. Unfortunately, the utilization of CI/CD also presents certain security
    vulnerabilities that necessitate careful consideration. In this section, we’ll
    introduce *The OWASP Top 10 CI/CD Security Risks* ([https://owasp.org/www-project-top-10-ci-cd-security-risks/](https://owasp.org/www-project-top-10-ci-cd-security-risks/)),
    a comprehensive study of the most prevalent security risks that threaten the CI/CD
    pipeline infrastructure in any organization.
  prefs: []
  type: TYPE_NORMAL
- en: The **Open Web Application Security Project** (**OWASP**) is a globally recognized
    non-profit organization that focuses on enhancing web application security. One
    of the fundamental principles upheld by OWASP is provisioning freely accessible
    and readily available resources on their official website. The assortment of resources
    provided encompasses various forms of support, such as written documentation,
    specialized tools, instructional videos, and interactive forums.
  prefs: []
  type: TYPE_NORMAL
- en: 'The OWASP Top 10 CI/CD Security Risks are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Insufficient Flow Control Mechanisms (CICD-SEC-1)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inadequate Identity and Access Management (CICD-SEC-2)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependency Chain Abuse (CICD-SEC-3)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Poisoned Pipeline Execution (CICD-SEC-4)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insufficient Pipeline-Based Access Controls (CICD-SEC-5)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insufficient Credential Hygiene (CICD-SEC-6)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insecure System Configuration (CICD-SEC-7)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ungoverned Usage of 3rd Party Services (CICD-SEC-8)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improper Artifact Integrity Validation (CICD-SEC-9)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Insufficient Logging and Visibility (CICD-SEC-10)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find this list at *OWASP Top 10 CI/CD Security Risks* | *OWASP Foundation.
    (**n.d.)* ([https://owasp.org/www-project-top-10-ci-cd-security-risks/](https://owasp.org/www-project-top-10-ci-cd-security-risks/)).
  prefs: []
  type: TYPE_NORMAL
- en: The details of The OWASP Top 10 CI/CD Security Risks are too extensive to include
    in this chapter. Instead, please reference the [*Appendix*](B21803_Appendix.xhtml#_idTextAnchor223)
    at the back of this book for a detailed examination of these top 10 security risks
    and how you can implement safeguards that protect against them. By familiarizing
    yourself with these risks and implementing the suggested countermeasures, you
    will be emboldened to enhance the security of the CI/CD pipeline infrastructure
    in your organization.
  prefs: []
  type: TYPE_NORMAL
- en: Speed-to-market versus governance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CI/CD makes rapid development and release cycles possible, but comprehensive
    security checks, manual reviews, and approval procedures can drastically slow
    things down. In an ideal world, security checks and compliance evaluations should
    be incorporated into the software delivery life cycle in a way that is both purposeful
    and unobtrusive. The task of reconciling CI/CD governance with efficiency can
    present avoidable difficulties as an excessively lenient approach to governance
    may result in compromised code quality and heightened security risks, while an
    excessively stringent approach can impede the deployment process and stifle innovation.
  prefs: []
  type: TYPE_NORMAL
- en: To optimize productivity and safeguard against potential risks, it is invaluable
    that you establish clearly stated policies and procedures, and diligently enforce
    their adherence. Effective software development strategies should incorporate
    protocols that ensure excellent code quality and minimize security vulnerabilities.
    Some of these practices may include code reviews, automated testing, and push-button
    deployment approvals. By implementing these measures, you can establish quality
    gates to assess code changes and prevent the introduction of unauthorized code,
    which is a major security risk. Regularly reviewing and updating governance standards
    is vital to ensure that the team continues to stay aligned with the goals of the
    organization.
  prefs: []
  type: TYPE_NORMAL
- en: Three common paths to CI/CD governance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Three prominent governance models are employed by experienced DevOps teams
    to manage their application deployments and CI infrastructure. These models exhibit
    variations in the aspects that they govern, namely the infrastructure code, deployment
    toolchain, and supplied cloud resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The central pattern library governance model** is a valuable resource that
    provides a curated collection of deployment templates. These templates are designed
    to be reused by application teams during their deployment processes. By utilizing
    the central pattern library, teams can benefit from pre-developed templates that
    have been carefully selected and organized for easy access and implementation.
    This allows for greater efficiency and consistency in the deployment of applications.
    Another way to think about this governance model is that it decentralizes the
    authority to make decisions by giving that authority back to the independent development
    teams, unified around a pre-approved set of processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The CI/CD-as-a-Service governance model** is a software development practice
    that provides a standardized toolchain for application teams to consume. This
    service allows for the seamless integration and delivery of code changes, ensuring
    a smooth and efficient development process. By offering a reusable toolchain,
    CI/CD-as-a-Service enables application teams to streamline their workflows and
    enhance collaboration within the development environment. Another term that is
    appropriate to describe this governance model is *service catalog*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The centrally managed infrastructure governance model** refers to a system
    where application teams can deploy cloud resources that are managed by central
    operations teams. This arrangement enables a streamlined approach to resource
    deployment and management as the responsibility for overseeing and maintaining
    these resources is centralized. By implementing this approach, organizations can
    ensure efficient utilization of cloud resources while maintaining a cohesive and
    standardized infrastructure across various application teams. Another term that
    is appropriate to associate with this governance model is *DevOps center* *of
    excellence*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Common CI/CD governance obstacles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to CI/CD governance, it can be challenging to find the right blend
    between speed, stability, and reliability. These are just a few of the common
    issues that you might face. Another challenge is the ability of teams to manage
    CI/CD processes and systems on larger scales. The reason for this is that enterprise
    firms have large numbers of employees, complex organizational structures, and
    extensive code bases. These factors result in specific needs and requirements
    that are unique to these types of companies.
  prefs: []
  type: TYPE_NORMAL
- en: The ideal governance architecture optimizes the alignment of infrastructure
    capabilities with business requirements while also providing the highest possible
    value to the final customer. IT organizations can utilize the governance model
    as an efficient tool to implement enterprise standards, introduce new technologies,
    and enforce default regulatory requirements. Notably, it is the responsibility
    of the enterprise architect to ensure that the governance model is aligned with
    the business architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The best practices for creating a governance model include scalability and repeatability.
    When a governance model is built for an organization, the process could be taken
    and repeated for multiple products and services. Items presided over by a governance
    model must be quantifiable if they are to be scrutinized for compliance, monitored
    for availability, and optimized for performance. A governance model should also
    encompass all the possible combinations of infrastructure capabilities, as well
    as different deployment requirements. As a result, the goal of creating a cloud
    governance model is scalability, meaning that the governance model can grow or
    shrink in response to demand in the market or among the targeted audience. It
    should facilitate transparent integration of horizontal and vertical scaling of
    the services offered. A governance model should also be adaptable and take into
    account the ever-evolving needs of end users and the effects on the IT infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: It is essential to keep in mind that creating an optimized cloud governance
    model is impossible unless both the business perspective and the IT perspective
    are considered simultaneously. While developing a CI/CD governance architecture,
    organizations typically face at least one of these four common challenges. These,
    in turn, reflect a wide range of distinct considerations.
  prefs: []
  type: TYPE_NORMAL
- en: The proliferation of tooling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The implementation of CI/CD governance models is frequently hindered by the
    complicated architecture of an organization’s technology stack. In the majority
    of settings, development teams tend to utilize a diverse range of programming
    languages, frameworks, productivity tools, and structural systems. However, this
    proliferation of tools poses a challenge in terms of implementing uniform governance
    practices and processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1: An infographic showing the enormous selection of CI/CD tools
    available](img/B21803_08_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: An infographic showing the enormous selection of CI/CD tools available'
  prefs: []
  type: TYPE_NORMAL
- en: This predicament often leads to a state of tooling paralysis, wherein software
    engineers express dissatisfaction with the existing technological infrastructure
    while also harboring concerns about the investment of time, effort, and potential
    challenges associated with transitioning to alternative solutions. Product owners
    will end up expressing dissatisfaction with inflated estimates and might end up
    questioning the rationale behind needing multiple sprints to develop a particular
    feature.
  prefs: []
  type: TYPE_NORMAL
- en: User access control and authorization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Access and authorization management is a major obstacle for many businesses.
    It is crucial to have the appropriate set of tools that can automate much of that
    process so that the correct individuals have access to the appropriate information
    when it’s needed. There are tools to help govern and manage user access control,
    but not all of them provide the fine-grained authorization management features
    that are necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Automation has eliminated the need for many manual security analysis inspections.
    Now, pipeline integrity is used to streamline the requirements for the separation
    of duties. There needs to be a distinct separation between the teams maintaining
    the pipeline infrastructure and the teams making use of it. You can set the source
    control tool up so that only the engineers working on the CI/CD pipeline infrastructure
    can make changes to the infrastructure components and/or configurations and patterns,
    effectively separating the responsibilities of each group. Exceptions should be
    infrequent, authorized, recorded, and closely supervised during their occurrence.
  prefs: []
  type: TYPE_NORMAL
- en: Systems access management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A typical challenge for many companies is ensuring the safety of network connections
    between the various systems used in CI/CD workflows. The usage of personal access
    tokens as an alternative to passwords and ephemeral, single-use tokens are two
    of the most important tactics for ensuring security. There’s also supplementary
    software and services that are capable of rotating secrets and refreshing credentials
    programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: Attackers take advantage of poor credential management practices by finding
    exposed credentials and using them to gain unauthorized access to systems. Once
    the extraction is complete, the attacker proceeds to verify the validity of the
    credential. This is typically done from a breached or disposable machine to evade
    detection. Once the attacker has obtained the necessary credentials, they can
    gain unauthorized access to the computer system or service. The attacker’s ability
    to access sensitive information, issue commands, or carry out other malicious
    acts is dependent on the permissions and authorization levels affiliated with
    the compromised credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Traceability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Traceability and auditability tend to be mandatory in heavily regulated industries.
    However, traceability is essential irrespective of your regulatory standing. The
    objective is to be able to identify whether or not the features you expect to
    see in the final product are, in fact, present in the software. In the event of
    a security breach, this is critically important.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve the ideal pipeline, the CI/CD ecosystem and its various components
    must work seamlessly without any interruptions of any kind. It is also important
    to have a comprehensive record of all elements (such as code, scripts, tests,
    and development and testing criteria) in existence. Each element’s purpose, creator,
    dependencies, and affiliations must be documented and regularly updated. You must
    ensure that this record is stored and managed under source control.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an enterprise CI/CD governance model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There isn’t a single standard format for CI/CD governance. This is because each
    model is tailored to meet the specific requirements of the company or organization
    that it supports in terms of requirements, legislation, compliance standards,
    and industry norms. However, there are approaches that large enterprises can implement
    to create and sustain a powerful end-to-end CI/CD governance strategy. When formulating
    or conducting an audit of your CI/CD governance standards, think about the techniques
    highlighted in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Map CI/CD systems and processes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The practice of creating visual representations of your CI/CD processes and
    systems offers a comprehensive understanding of your complete CI/CD pipeline.
    This helps with identifying the specific stages where your security is most vulnerable
    to threats. Additionally, this has the potential to unveil additional options
    that improve your procedures, infrastructure, and security posture. An effective
    method to accomplish this task is by generating what’s known as a *value stream
    map*. Value stream mapping should include the CI/CD processes, infrastructure,
    and tooling so that you can fully understand the points of transition and establish
    connections between the business’s controls, compliance requirements, and industry
    regulations. Doing so enables you to optimize current procedures, establish a
    governance model, and prepare your company to undergo audits. Increasing the visibility
    of your process is one of the quickest ways to observe how to improve it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2: A generic example of a value stream map](img/B21803_08_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: A generic example of a value stream map'
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure represents a generic example of a value stream map in the
    context of lean manufacturing. Even though value stream mapping is frequently
    associated with the manufacturing industry, it is also utilized in the fields
    of logistics and supply chain management, service-oriented verticles, software
    development, product development, project management, and many others.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of value stream mapping is to discover and eliminate or minimize wasteful
    activity occurring in a business’ processes, which will ultimately increase the
    overall efficiency of that specific value stream. The goal of waste reduction
    is to boost output by streamlining processes and making it simpler to spot instances
    of poor quality or excessive waste within them.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about value stream mapping, please reference the [*Appendix*](B21803_Appendix.xhtml#_idTextAnchor223)
    at the back of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Express CI/CD pipelines declaratively
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The technique commonly known as *pipeline-as-code* involves defining a CI/CD
    pipeline through the use of code. This process originates by employing a declarative
    technique, which incorporates the use of configuration files and is used most
    effectively with a version control system. One advantage of expressing the CI/CD
    pipeline declaratively *as code* is the ability to incorporate controls, gates,
    and processes, such as governance practices and procedures, and apply them consistently
    across many environments. Furthermore, it facilitates establishing an audit trail
    that enables you to verify compliance with governance standards. Lastly, by expressing
    CI/CD pipelines declaratively *as code*, you will be far better prepared for **disaster
    recovery** (**DR**) scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Define clear roles and responsibilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Examine the steps of your value stream map from earlier and determine the roles
    and duties of each team and individual that interacts with it. This is the most
    effective method to approach the job of designing a governance model for CI/CD.
    Please note that your developers are responsible for the development of code,
    and it is highly undesirable for them to also be the ones to construct and maintain
    a CI/CD pipeline. This will undoubtedly be helpful when you decide what amount
    of authorization you need to provide each team member who requires access to the
    underlying systems, as well as what protocols you need to adopt to ensure good
    governance of your organization.
  prefs: []
  type: TYPE_NORMAL
- en: Regularly audit access and authorization controls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s not easy to manage permissions and access, but you must. Using an **identity
    provider** (**IDP**) such as Azure Active Directory, you can establish a single
    authoritative source for managing user identities and permissions. You should
    identify your most valuable resources and make them the primary focus of your
    infrastructure, regardless of the technology stack you employ.
  prefs: []
  type: TYPE_NORMAL
- en: Give teams flexibility
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: No matter how many precautions you take, people will still create their own
    tools, scripts, and automations. Implementing safeguards to avoid this, or making
    it such that people can build up their own tools and instances in a transparent
    and sanctioned fashion, is an important aspect of good CI/CD governance. The most
    effective method for accomplishing this is to provide workers with the freedom
    they require to carry out their duties, as well as to conduct routine process
    reviews to identify areas in which either extra freedom or, on the flip side,
    increased formality is required. Creative liberty is the best way to build a workforce
    that is invested in a company.
  prefs: []
  type: TYPE_NORMAL
- en: Generously invest in your automated testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An essential element of efficient CI/CD governance models includes incorporating
    suitable testing suites, in particular automated tests that assist teams in *shifting
    left* or prioritizing security and functionality as early as possible in the **software
    development life cycle** (**SDLC**). We strongly advise that, right from the start
    of the SDLC, rapid and cost-effective tests be given top priority. These kinds
    of tests must be finished within a very short amount of time – short enough that
    engineers are not incentivized to switch gears and multitask on another project.
    If the test fails, the development team should be made fully aware of it immediately
    so that the issue can’t be ignored or overlooked by accident. As your SDLC becomes
    more mature, your testing requirements should grow more specific. Traceability
    is another crucial factor to consider regarding automated testing practices. If
    you can identify the failure point, you will be in a much better position to quickly
    diagnose the issue and find a solution.
  prefs: []
  type: TYPE_NORMAL
- en: Standardize code reviews
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The implementation of robust CI/CD governance necessitates the creation of a
    system wherein an individual is unable to arbitrarily author code, commence a
    build process, and deploy this code without undergoing extra validation measures.
    This implies that each modification must have approval from a minimum of two individuals.
    It is important to note that obtaining a second person’s approval for all modifications
    is not always necessary. In certain cases, relying on an automated test can offer
    a satisfactory level of assurance to proceed. Regardless of the strategy that’s
    chosen, it is imperative to establish and articulate rules at the organizational
    level to guarantee that teams adhere to a uniform set of practices and processes.
    The objective is to increase the success of developers in identifying and resolving
    code issues, mitigating the introduction of defects, and guaranteeing compliance
    with the core project specifications. As a result, this can enhance the overall
    productivity and efficiency of the development effort, enabling teams to accelerate
    the delivery of outstanding software to their customers.
  prefs: []
  type: TYPE_NORMAL
- en: Set environment rules in deployment strategies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A central principle that should be followed is establishing environmental consistency
    and the ability to track progress seamlessly throughout the various stages encompassing
    the build, testing, and delivery layers of your SDLC. You must be mindful of the
    potential consequences when introducing conditionality in one environment while
    neglecting to do so in other environments as this is a bad idea. Maintaining environmental
    consistency will expedite the process of software testing in each environment,
    even if production contains unique conditions that are absent in other environments.
  prefs: []
  type: TYPE_NORMAL
- en: It is advisable to use a configuration file’s declarative syntax to treat environments
    as *input parameters*. When it comes to CI/CD pipelines, this is a winning approach.
    Parameterizing your environment as code helps guarantee that all prerequisites
    are standardized from development to release. Additionally, your CI/CD system
    will be easier to maintain as a result of parameterization, which will prevent
    an excessive number of pipelines from being created.
  prefs: []
  type: TYPE_NORMAL
- en: Protect against unauthorized access to CI/CD pipeline infrastructure
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To prevent unwanted access to your systems and code, all the systems involved
    in your CI/CD pipeline must be securely integrated.
  prefs: []
  type: TYPE_NORMAL
- en: In all situations, the principle of least privilege should be applied. Access
    and permissions granted to users, tools, and services should be kept at a bare
    minimum. By doing so, you may be assured that your organization’s most private
    information and systems are safe from prying eyes. Additionally, you must encrypt
    any private information. If it is pragmatic to do so, utilize ephemeral tokens
    that can only be used once and are automatically rotated after each job is completed.
  prefs: []
  type: TYPE_NORMAL
- en: You should always be doing regular security tests on all of your dependencies
    using a **static application security testing** (**SAST**) tool. These tests should
    cover everything from your CI/CD processes to your code base to your underlying
    systems, such as containers. Some tools can be integrated into a CI/CD pipeline
    to conduct automated scans of your code base for any known security flaws and
    to notify the appropriate teams if any flaws are detected. Some examples include
    *SonarQube*, *Fortify*, *CheckMarx*, and *Veracode*.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, carry out security inspections regularly. The purpose of these audits
    is to offer recommendations for strengthening your organization’s overall security
    posture, as well as to document any findings, which may include any problems or
    vulnerabilities. By staying on top of your security testing and being organized,
    you will be well-positioned to respond to a security incident at your organization.
  prefs: []
  type: TYPE_NORMAL
- en: Monitor CI/CD pipeline performance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Key metrics for evaluating the performance of CI/CD processes typically include
    deployment frequency, lead time for changes, time to restore service, and change
    failure rate. The measurement of these indicators can assist organizations in
    identifying potential bottlenecks or inefficiencies within their broader CI/CD
    workflow. Additionally, they can be utilized to monitor the effects of governance
    policies and procedures on the deployment of new code to customers.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing specialized monitoring tools, such as *SigNoz*, *Datadog*, or *New
    Relic*, is one method for keeping tabs on the efficacy of your CI/CD pipelines.
    Although these tools reveal patterns in your pipeline’s overall performance, they
    alone aren’t enough. DORA metrics, as mentioned previously, should be established
    to monitor the efficacy of your pipeline, governance policies, and procedures.
    These metrics give observable signals that, taken together, paint a more complete
    picture of the health of a pipeline and the system as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: Review and update CI/CD governance procedures regularly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To establish an effective review board, it is recommended to assemble the board
    with individuals from many functional areas, including development, security,
    operations, and IT teams. Begin by conducting a thorough analysis of the current
    policies and processes to identify any deficiencies or areas that can be improved.
    Then, assemble the review panel to solicit input on the current policies and procedures
    based on their respective areas of expertise. Next, revise the current policies
    and procedures to incorporate the input provided by the review panel. It is recommended
    to thoroughly evaluate the modifications made to guarantee their alignment with
    the specific requirements of your firm. Finally, execute the implementation process
    by effectively communicating the details to the teams that will be affected. It
    is imperative to systematically monitor and evaluate the effectiveness of newly
    implemented policies, while also being prepared to make necessary revisions as
    required.
  prefs: []
  type: TYPE_NORMAL
- en: Since the governance of CI/CD and the priorities that are most important to
    your company will shift over time, conducting regular reviews should be one of
    the most important functions your company performs to support its success. Effective
    CI/CD governance guarantees that all of the code that is shipped is of high quality,
    that it is safe, and that it can be traced back to its source.
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of DevOps release management governance is to set policies and
    procedures that will help ensure that your organization’s CI/CD pipeline infrastructure
    is efficient, secure, and consistent with industry standards and regulations.
    At the organizational level, companies frequently have trouble implementing the
    appropriate tooling, processes, and procedures to successfully control their CI/CD
    workflows. This is especially the case when the companies are just getting started
    in the process of developing a governance model. It all boils down to scale: at
    the enterprise level, there are far more people, tools, systems, and users, which
    makes effective governance more difficult.'
  prefs: []
  type: TYPE_NORMAL
- en: However, when teams adhere to established processes and effectively implement
    CI/CD methods, there is a higher level of assurance that all released products
    meet the necessary criteria and quality standards. Additionally, these products
    are equipped with the required tags that enable future traceability if required.
    The importance of the initial investment becomes more significant as a result.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our discussion about DevOps release management governance. You
    now have familiarity with the *OWASP Top 10 CI/CD Security Risks*, speed-to-market
    versus governance, common paths to CI/CD governance, common CI/CD governance obstacles,
    and creating a governance model.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, we will be discussing a hotly debated and equally important
    aspect of DevOps release management: branching strategies! Often overlooked, we’ll
    discuss the importance of the four most common software development branching
    strategies and learn when and how to apply them.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding branching strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The majority of contemporary version control systems offer support for branches,
    which are autonomous streams of work that originate from a core code base. The
    nomenclature for the *primary* branch in a version control system may vary, with
    possible designations including master, mainline, default, and trunk, depending
    on the specific system in use. Developers can generate branches derived from the
    source, therefore enabling them to function autonomously in conjunction with it.
  prefs: []
  type: TYPE_NORMAL
- en: The practice of branching facilitates seamless collaboration across teams of
    developers within a unified code repository. When a software developer starts
    creating a branch inside a version control system, a duplicate of the code base
    is generated, capturing the state of the code at that specific moment in time.
    Modifications made to the branch do not have an impact on the other developers
    within the team, but this pattern is undoubtedly advantageous. However, it is
    not strictly necessary for branches to exist in isolation. With branching, developers
    can seamlessly integrate changes made by fellow programmers to engage in collaborative
    development efforts that could relate to a variety of features, all while simultaneously
    ensuring that their branches remain closely aligned with the main branch.
  prefs: []
  type: TYPE_NORMAL
- en: The successful implementation of a branching strategy will play a critical part
    in building effective DevOps workflows. Many of the key objectives of DevOps release
    management is to provide a rapid, optimized, and effective workflow while ensuring
    the integrity and excellence of the final deliverable(s). The branching strategy
    that a software development team operates with and how they handle each new feature,
    upgrade, or bug fix should be managed by a well-planned branching strategy. Doing
    this will simplify the release process by letting software engineers work on individual
    features at a time without affecting other parts of the product or interfering
    with another team’s work.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a branching strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The needs of the users and the requirements of the project should be taken into
    full consideration during the selection process for a branching strategy. This
    selection is heavily influenced by a variety of factors, including the process
    of creation, the scale, and the tastes of the developers. Which branching strategies
    that you use in your DevOps pipeline are influenced by different factors, such
    as the availability of CI/CD integrations. It’s not a good idea to use branching
    strategies in a DevOps-centric organization if they are incompatible with CI/CD
    or make it harder to establish.
  prefs: []
  type: TYPE_NORMAL
- en: Defining an effective branching strategy offers you a well-understood trajectory
    for the progression of the development process, originating with prototype revisions
    and culminating with the final production deployment. This approach empowers developers
    to generate workflows that facilitate well-organized releases. As eluded to earlier,
    a key advantage of having a well-defined branching strategy is to enable parallel
    development, a tactic that enhances the efficiency of each developer’s workflow
    without introducing any significant headwinds. Branching strategies also offer
    seamless integrations with many DevOps technologies and workflows in an efficient
    manner. For advanced teams, branching strategies also open the door to deploying
    with GitOps workflows. Perhaps the best-understood advantage of using a branching
    strategy is its ability to facilitate rapid release cycles. The bottom line is
    that there are no one-size-fits-all techniques available when considering which
    branching strategy is right for you.
  prefs: []
  type: TYPE_NORMAL
- en: Common DevOps branching strategies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you have a better understanding of what a branching strategy is and
    what a team tries to achieve from using one, let’s look at some popular branching
    strategies that are currently in use by software engineering teams. In this section,
    we will focus on the four most common branching strategies used in DevOps release
    management today: Gitflow, GitHub flow, trunk-based development, and GitLab Flow.'
  prefs: []
  type: TYPE_NORMAL
- en: Gitflow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`master` and `development`, both of which are maintained throughout the entirety
    of the development life cycle. The development branch is also known as a `long-lived`
    branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '`master`: This is the primary branch where all of the code for production is
    kept. The modifications that are made in the `develop` branch are merged into
    the `master` branch and used during the deployment process, once the code is ready
    to be distributed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`development`: Change, grow, and evolve. Progress is made in the `develop`
    branch. This branch houses all of the pre-production source code, and all completed
    work from the other branches gets merged into `develop` immediately:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.3: Graphical depiction of the Gitflow branching strategy](img/B21803_08_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: Graphical depiction of the Gitflow branching strategy'
  prefs: []
  type: TYPE_NORMAL
- en: Software developers create many different branches during their development
    process to satisfy various application requirements. The `develop` branch functions
    as the initial starting point – the basis for generating the software product.
  prefs: []
  type: TYPE_NORMAL
- en: Additional branches emerge similarly. For example, when developing software,
    it is common practice to make use of `feature` branches to make creating new features
    easier. These branches are a direct offshoot of the `develop` branch and nothing
    else.
  prefs: []
  type: TYPE_NORMAL
- en: If there are pressing production issues that require quick resolution, a hotfix
    will be developed as a reaction. The ability to `fork` from the `master` branch,
    also known as the `main` branch, is possessed by each of the branches. These forks
    must be merged with both the `master` and `develop` branches so that the changes
    are consistently integrated, and no conflicts arise. To streamline the process
    of releasing to production, the `release` branch collects all of the latest bug
    fixes and features. The new branch will be a child of the `develop` branch that
    will eventually be merged into the `master` branch.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of Gitflow include the ease of implementing distinct and specialized
    branches, each of which serves specific functions and is facilitated by a well-defined
    naming system. This approach is particularly advantageous for managing several
    iterations of the production code.
  prefs: []
  type: TYPE_NORMAL
- en: One of the disadvantages of Gitflow is that you can’t read the Git history anymore.
    Additionally, the *master*/*develop* split isn’t always needed in development,
    and doing so might be challenging when attempting to integrate with some CI/CD
    tools. Further, it’s not suggested for people who need to keep only one working
    version up to date. Finally, depending on the size of the project, this approach
    may make source control too hard to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a summary of Gitflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '`master` contains your distributed production code with tagging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merge only the `hotfix` and `release` branches into master (preferably `release`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feature branches are merged into `develop`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Release branches only include bug fixes, not new features. If a new feature
    needs to be developed, merge it into `develop`, not `release`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub flow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'GitHub is responsible for the inception of this strategy, which aims to provide
    a straightforward and unobtrusive method to manage the development process. When
    maintaining the source code for a single primary branch, **GitHub flow** manages
    the process as per the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '`master` is the primary branch that other branches get split off of and into
    which new code gets merged. Everything that is in the `master` branch, sometimes
    called the `main` branch, should be ready to be deployed at all times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Any modification (be it a feature or a bug) needs to be implemented in a new
    branch that is inherited from the `master` branch, and that branch should have
    a name that is descriptive of the development process. You should commit your
    code changes to a `feature` and/or `bug` branch locally, and push those new changes
    regularly:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.4: Graphical depiction of the GitHub flow branching strategy](img/B21803_08_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.4: Graphical depiction of the GitHub flow branching strategy'
  prefs: []
  type: TYPE_NORMAL
- en: Once the development of the `feature` or `bugfix` branch is complete, you will
    need to create a pull request so that the code can be evaluated. After the code
    has been inspected and validated, it needs to be tested in that same branch before
    it can be merged back into the `master` branch. Users should now be able to directly
    deploy the `master` branch with the latest updates after reaching this point.
  prefs: []
  type: TYPE_NORMAL
- en: The advantages of GitHub flow include that it is relatively easy to understand
    and has a straightforward workflow. Also, this method results in having a Git
    history that is spotless and simple to read. You can also incorporate it into
    CI/CD pipelines with ease. Furthermore, GitHub flow is perfect in situations where
    you only want to keep a single production version.
  prefs: []
  type: TYPE_NORMAL
- en: Some disadvantages of GitHub flow include that it is overly simplistic, and
    it is not compatible with software development that is based on releases. Also,
    GitHub flow is unsuitable for use in situations where several different software
    versions must be maintained simultaneously. Furthermore, if the branches are not
    thoroughly tested before being merged with the `master` branch, this could result
    in an unreliable production code.
  prefs: []
  type: TYPE_NORMAL
- en: Trunk-based development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With trunk-based development, developers are required to integrate their code
    modifications directly into a shared trunk (`master`) at least once each day.
    The shared trunk is maintained in a deployable state that is always ready for
    release, at any time. The code that developers write can be pushed from their
    local repository to the shared trunk after first being pulled from this trunk
    branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5: Graphical depiction of the trunk-based branching strategy](img/B21803_08_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.5: Graphical depiction of the trunk-based branching strategy'
  prefs: []
  type: TYPE_NORMAL
- en: The `release` branches are considered to be *snapshots* of the source code,
    taken from the point in time when they were created and ready for release. This
    means that, in trunk-based development, `release` branches would never be maintained.
    Because this integration takes place frequently, developers can instantly monitor
    one another’s code changes and respond immediately if any problems are detected.
  prefs: []
  type: TYPE_NORMAL
- en: Scaled trunk development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A derivative of trunk-based development, **scaled trunk development** follows
    a similar pattern but is designed for ease of use with large enterprise-sized
    development teams.
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference with trunk-based development is that after completing a build
    and ensuring its functional tests are successful, smaller teams may commit their
    changes straight to the shared trunk. On the other hand, the development process
    for scaled trunk development can be partitioned into short-lived `feature` and
    `bugfix` branches for organizations with larger workforces. After a `feature`
    or `bugfix` branch gets created, developers will continuously submit code to these
    specific branches, and that code can be validated through the use of pull requests
    and automated testing before being merged back into the shared trunk. Scaled trunk
    development allows development teams to do two things at the same time:'
  prefs: []
  type: TYPE_NORMAL
- en: Scale up without putting too much strain on the main branch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Achieve a higher level of regulation and oversight over every change:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.6: Graphical depiction of the scaled trunk development branching
    strategy](img/B21803_08_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.6: Graphical depiction of the scaled trunk development branching strategy'
  prefs: []
  type: TYPE_NORMAL
- en: Notably, scaled trunk development makes use of feature flags to control the
    development activity occurring in the shared trunk, whenever the time comes for
    a release. With the help of these feature flags, development teams can selectively
    activate or deactivate sections of code during the building process and send just
    the essential code to production environments. With this method, teams can release
    straight from the trunk and tag a release number to each commit. Notably, if a
    bug makes its way into a release, then a `release` branch can be generated from
    a past commit and fixes can be cherry-picked into it. This style of branching
    is best suited to expert development teams that are experienced with source control
    management.
  prefs: []
  type: TYPE_NORMAL
- en: Some advantages of trunk-based development include using CI in its purest form,
    with developers continually keeping the trunk up to date. Trunk-based development
    is an excellent option for CI/CD pipelines that include workflows that are more
    straightforward for ease of automated testing. Also, trunk-based development produces
    reduced cycle times and quicker developer feedback. As a result, modifications
    to the code are more readily apparent. With regards to iterations that are less
    frequent, they make it easier for your team to monitor all of the changes while
    also lowering the risk of code conflicts and increasing the overall code quality.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the disadvantages of trunk-based development are due to developers directly
    working with the shared trunk (`master`). Inexperienced developers may discover
    that this technique is intimidating. Furthermore, challenges may arise as a result
    of improper management of feature flags. Another disadvantage is that it increases
    the risk of bug creation since regression testing doesn’t happen on every merge.
    Also bad, this branching strategy requires development teams to wait for changes
    to go through test processes and automated builds before merging. Notably, it
    can be challenging to make the transition from more traditional approaches such
    as GitHub flow.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, trunk-based development promotes collaboration, agility, and faster
    delivery of high-quality software. You can easily implement a solid CI culture
    and use feature toggles to your advantage. Furthermore, by adhering to this methodology,
    you will be able to respond to customer requests more effectively and have source
    code that is simpler to manage and improve over time. Regardless of the size of
    your team or the complexity of your project, using trunk-based development can
    enhance teamwork, speed up time-to-market, and improve your coding practices.
  prefs: []
  type: TYPE_NORMAL
- en: GitLab Flow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'GitLab Flow fuses the principles of feature-driven development and feature
    branches with the utilization of issue tracking. This approach bears similarities
    to the GitHub flow methodology, but in contrast to the other workflows, this particular
    flow incorporates a distinct production branch that fulfills the role of managing
    the code that’s deployed to the production servers. Additionally, it is advisable
    to establish a `pre-production`, `staging`, or `release` branch to serve as a
    representation of your *staging* environment, where you can push your code for
    final testing before deployment. In other words, you need at least three main
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '`master`: This is the line for the local development environment that everyone
    uses.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`staging`: This is the final testing environment before production, where the
    `master` branch is integrated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`production`: Code in staging gets merged into the production branch via tagging.
    If staging is not being used, then this is where you would merge from `master`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 8.7: Graphical depiction of the GitLab Flow branching strategy](img/B21803_08_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.7: Graphical depiction of the GitLab Flow branching strategy'
  prefs: []
  type: TYPE_NORMAL
- en: As described previously, within the context of GitLab Flow, the process of software
    development takes place within three distinct environmental branches. These branches
    serve as designated spaces for verifying and testing code. Once the code has undergone
    the necessary scrutiny and has been deemed suitable, it is merged into the other
    branches, starting with the `master` branch. This iterative merging process continues
    until the code eventually reaches the production branch, which signifies its readiness
    for deployment. Let’s consider the details of the three aforementioned branches
    in the environment.
  prefs: []
  type: TYPE_NORMAL
- en: The master environment serves as the primary site for all developmental activities.
    The developers establish distinct branches for the specific feature or bug fixes
    they are currently working on and subsequently integrate these branches into the
    `master` (main) branch. Subsequently, the new code changes will undergo an additional
    level of evaluation and automated testing. Once new features and bug fixes are
    deemed ready for release, the source code will get merged from the `master` branch
    into a `pre-production` (`staging`) branch, which is the initial phase of production.
    Then, the aforementioned code will undergo further testing and finally get merged
    into the `production` branch for deployment.
  prefs: []
  type: TYPE_NORMAL
- en: The term *production* refers to the process of creating goods or services. Upon
    integrating production-ready code, it becomes acceptable to deploy this branch
    directly into the production environment. This is the branch that’s dedicated
    to this specific environment and will consist exclusively of code that has been
    thoroughly tested and is deemed suitable for deployment to production.
  prefs: []
  type: TYPE_NORMAL
- en: One advantage of GitLab Flow is that implementing GitLab ensures effective separation
    between different development contexts, guaranteeing a pristine state within each
    branch. Also, the software seamlessly fits into CI/CD pipelines. In short, GitLab
    Flow enhances the GitHub flow methodology by optimizing the workflow inside a
    DevOps ecosystem. Another benefit of GitLab Flow is that the Git history is more
    easily accessible and visually organized.
  prefs: []
  type: TYPE_NORMAL
- en: One disadvantage of GitLab Flow is the added work of coordinating many environmental
    branches, which can make implementation difficult. If not managed well, development
    forks can become tangled and confusing. Because of its flexibility, you must carefully
    consider how you will utilize it, making it less straightforward to use than it
    could be. Ensure that everyone on your team is aware of the optional branches
    you want to use.
  prefs: []
  type: TYPE_NORMAL
- en: GitLab is an excellent, mature compromise between Gitflow and GitHub flow since
    it is less complicated than Gitflow but more comprehensive than GitHub flow. It
    is flexible enough to meet your unique requirements thanks to its optional branches
    and performs well in CI circumstances. In its documentation for GitLab Flow, GitLab
    offers a comprehensive set of instructions that cover everything from rebasing
    your repository to crafting effective commit messages. Regardless of the approach
    your team decides on, it is a good idea to read through it.
  prefs: []
  type: TYPE_NORMAL
- en: How to choose your branching strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All of the branching strategies that have been mentioned up to this point have
    been tested and proven, making them a good choice for managing your source code.
    However, each approach possesses a unique set of advantages and disadvantages,
    and you shouldn’t blindly accept one over another without doing an evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: For example, in contexts where DevOps processes are constantly evolving, the
    standard Gitflow will not be the best option. All of the other solutions that
    have been presented here make an effort to enhance Gitflow and modernize it so
    that it is compatible with an agile DevOps process. Therefore, as usual, you will
    need to decide on an ideal strategy that fits all of your requirements and works
    for the operations of your unique business. When making this decision, it is important
    to consider the customer, the company, and your team.
  prefs: []
  type: TYPE_NORMAL
- en: The ultimate goal of a branching strategy is to regulate and organize the changes
    that each team member makes to a code base into a single release. However, orchestrating
    all these changes involves more than just writing code. For example, a new release
    must be deployed somehow, and that’s where a release pipeline comes in.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring release pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **release pipeline** is a workflow or a collection of steps that are undertaken
    to guarantee the swift implementation of recently delivered code. Fundamentally,
    a well-built release pipeline makes delivery to production quick, easy, and reliable.
  prefs: []
  type: TYPE_NORMAL
- en: The exact stages of a release pipeline are different for each organization and
    product, but they often follow one another linearly. Notably, a more complex pipeline
    design may include steps that can be executed in parallel. This trend has become
    more popular in recent years due to the strategic advantages that parallel processing
    provides, but also because contemporary tooling has advanced well enough to make
    this functionality easier to implement without extensive scripting.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, releases are triggered by an event, such as a code commit, although
    there are instances where the release might be explicitly initiated or scheduled
    in advance. You may also wish to automate the execution of your pipeline until
    a specific milestone, such as the conclusion of pre-production testing, followed
    by manual authorization for the actual deployment into production. For example,
    in heavily regulated industries, it may be desirable to incorporate manual triggers
    as conditions for completion, even though the pipeline process is initiated automatically.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, having a proper release pipeline in your team’s portfolio of
    delivery strategies will mean the difference between deploying once a week and
    deploying multiple times a day. But critically, where does a release pipeline
    fit into the spectrum between CI, CD, and continuous deployment? Before we can
    answer that question, we must understand all the components of a release pipeline,
    including the related infrastructure supporting it. The following sections outline
    each element of a release pipeline in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tasks refer to specific activities that are accomplished at a detailed level.
    In the context of a release pipeline, the sequence of tasks within a stage should
    have little to no significance regarding the successful completion of the overall
    process. When it comes to controlling flow, use stages as the gates and tasks
    as the activities that get performed within them.
  prefs: []
  type: TYPE_NORMAL
- en: 'At a bare minimum, your release pipelines must include the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Provisioning infrastructure**: This refers to allocating and configuring
    the necessary resources to establish and operate various applications and services.
    This may require creating new virtual environments for testing purposes, or it
    may involve verifying the proper configuration of a test environment and even
    installing and activating the necessary services, such as a web server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application deployment**: This is the release process that requires the acquisition
    of packaged software and subsequent deployment into the designated server infrastructure,
    accompanied by the implementation of environment-specific configuration adjustments
    as deemed necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Software testing**: This refers to the process of conducting automated tests
    and disseminating the corresponding outcomes. In addition, it is a necessity that
    you provide the capability to designate a particular stage as unsuccessful should
    the test execution yield unfavorable results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decommissioning infrastructure**: You should do this upon completing the
    pipeline phases, regardless of the outcome. It has become commonplace that teams
    leverage Kubernetes clusters to operate ephemeral pipeline phases in immutable
    container instances. The key advantage of this tactic is that container instances
    gracefully terminate all unpreserved resources upon the completion of their assigned
    duties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Certain tasks within the release pipeline may necessitate an asynchronous approach,
    requiring the pipeline to be capable of accommodating a variety of related situations,
    such as the ones mentioned here. As an example, consider an application release
    pipeline that requires server instances to be created in the cloud. During the
    elapsed time between the beginning of infrastructure provisioning and the following
    deployment or testing of the application, it is necessary to allow for an interim
    period of approximately 1 minute. This window of time is needed to adequately
    prepare the environment for the forthcoming tasks of the release pipeline, avoiding
    a race-time condition.
  prefs: []
  type: TYPE_NORMAL
- en: Artifact store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A code change typically initiates the release process, which culminates in supplied
    infrastructure and delivered **software artifacts**. In this process, it may be
    necessary to tailor the packaged software to each environment by making it compatible
    with the relevant requirements and then deploying it. Hence, a repository for
    artifacts is the foundation of the release process, such as jFrog Artifactory
    or Sonatype Nexus Repository Manager.
  prefs: []
  type: TYPE_NORMAL
- en: The requirement for the artifact store is to facilitate the management of discrete
    artifact versions. The key is to ensure that the artifacts that are collected
    concerning a singular build and subsequent release are both indivisible and separate
    from any other release, devoid of any form of intermingling or collateral interference.
  prefs: []
  type: TYPE_NORMAL
- en: In previous years, the realization of this goal was accomplished through the
    establishment of a network share designated for the sole purpose of facilitating
    the build and release process. Within this share, each build was allocated a distinct
    folder to ensure organizational coherence. When it comes to release management,
    the persistence of artifacts is of utmost importance, regardless of the approach
    chosen, be it utilizing a database, employing a specific methodology, or even
    opting to store all data in object storage, such as an S3 bucket or Azure Blob
    Storage.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On the other hand, a configuration store is a repository that houses various
    values that provide consistency across a variety of build/release configurations.
    For example, your CI/CD process and application’s build configuration data will
    likely be kept in a configuration store as a set of key/value pairs. Commonly,
    these pairings are injected as environment variables or as input parameters, in
    the build environment, though information on job completion can also be included.
    Commonly, these values include critical elements such as connection strings, API
    URLs, environment-specific users, permissions, and others.
  prefs: []
  type: TYPE_NORMAL
- en: A release pipeline also needs to be able to extract the necessary configurations
    specific to a given environment during each corresponding stage of the pipeline.
    Once extracted, the configuration should be used to facilitate provisioning and
    deployment processes. Notably, pipeline code can be made reusable by referring
    to the same parameters using appropriate values, depending on the environment.
    It is worth highlighting that the configuration store will ultimately include
    a portion of your production configuration, even if it is solely limited to infrastructure
    details. As a result, your configuration store must be fortified with robust security
    measures and encryption protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With DevOps, it is innately understood that, in the event of issues emerging
    during the execution of your pipeline, it is paramount that you scrutinize your
    logs to determine exactly where to look for problems and identify the root cause
    of the obstacles. There are several popular log aggregation tools on the market,
    a few of which are Splunk, ELK Stack, and Loggly, just to name a few. In a complex
    system characterized by numerous dynamic components, it is strongly recommended
    to establish a mechanism for aggregating the logs in an effective way that facilitates
    awareness and swift analysis.
  prefs: []
  type: TYPE_NORMAL
- en: To ensure proper documentation, it is invaluable that all log entries be accompanied
    by, at the very least, the application name, pipeline stage, build number, and
    timestamp. After these requirements have been satisfied, any additional method
    you use to represent your log entries is entirely subjective. The most fundamental
    system might simply compile them all together and make them searchable, but more
    advanced build pipeline systems will provide you with a graphical representation
    of the execution of your pipeline, along with the ability to drill down into the
    logs that they produce.
  prefs: []
  type: TYPE_NORMAL
- en: Workflow execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A workflow engine facilitates transforming manual workflows, typically driven
    by IT, into processes that are managed by both humans and software. This enables
    the routing and directing of information streams, allocation of tasks, and the
    establishment of collaboration channels to optimize resource utilization. The
    underlying mechanisms of this process vary depending on the specific implementation,
    but the execution of processes is essential. Whether this pertains to a sophisticated
    bash script or a hosted workflow engine such as Jenkins, the tasks must be executed
    in a logical, organized way.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between deployment and release
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By now, you may be wondering what the difference is between a **deployment pipeline**
    and a **release pipeline** since these two terms are often used interchangeably.
    However, deployments and releases are indeed unique! Deployment is a transition
    of software from one controlled environment to another. On the other hand, releases
    are a curated collection of software changes that are intended for end users to
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some critical differences between deployment and release:'
  prefs: []
  type: TYPE_NORMAL
- en: A software release is a set of changes to be delivered in the production environment,
    while a deployment is a transition of code built from one controlled environment
    into another.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is typical for a release to get updated in production environments frequently.
    In contrast, deployment is the last phase of the SDLC and it is executed across
    all environments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Statistically speaking, releases have a higher risk of exposing end users to
    buggy versions, errors, and issues in the software. Conversely, deployments occur
    in both the production environment and the development environments, which users
    will never see.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Release code may not be production-ready, while deployment code is production-ready.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software releases are visible to users, while deployments can run in any target
    environment inside the infrastructure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stated differently, the business justification is the defining feature that
    differentiates a deployment from a release. Commonly, release management leans
    toward being a business-oriented activity rather than a purely technical one.
    Often, the rationale behind the decision to schedule releases is influenced by
    the business strategy, particularly in terms of revenue generation and portfolio
    management.
  prefs: []
  type: TYPE_NORMAL
- en: With the various environments that are involved, it is evident that deployment
    does not necessarily indicate that users will have access to the features that
    have been implemented. Certain organizations may schedule their releases concurrently
    with their deployment phases to production, while others will opt to hold off
    until the company makes a final decision. This means that the new features could
    be approved for release in production but unavailable to users until they have
    been deployed at a future point in time.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you are familiar with the importance of having a sound branching
    strategy. A good branching strategy that is appropriate for your team’s workflow
    allows you to logically organize the myriad of software changes so that cutting
    a new release becomes a straightforward process. You’ve also explored what a release
    pipeline is and how to implement one. However, with all these changes happening
    at once, how can they be managed in a sane way? What is the best way to show value
    for the hard work your team has put in? The answer is having sound change management
    practices.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding change management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Digital services follow a life cycle that must be managed, and most organizations
    accomplish this through a set of dedicated change management processes. These
    actions commonly serve as the first line of defense toward mitigating the potential
    negative effects a change might have on operations and security.
  prefs: []
  type: TYPE_NORMAL
- en: To facilitate the implementation of changes throughout the system, change management
    methods typically involve obtaining clearance from external reviewers or **change
    control boards** (**CCBs**). To validate compliance requirements, compliance managers
    and security managers rely heavily on change management processes to certify an
    entity’s compliance. This is why you must maintain an aggregate log of all changes
    based on detailed records to unambiguously certify your build and release process,
    along with any other compliance requirements. Most notably, many industry regulatory
    requirements often demand evidence that any modifications made are duly authorized
    and include a timestamp of when they occurred.
  prefs: []
  type: TYPE_NORMAL
- en: According to findings that were published in the 2019 *State of DevOps Report*,
    the most effective method for implementing change approvals is to do so via peer
    review during the development process. This method should be reinforced with automation
    to detect, avoid, and fix undesirable changes early in the SDLC. Continuous testing,
    CI, careful oversight, robust observability, and complimentary tactics offer early
    and automatic detection, increased visibility, and rapid feedback. In addition
    to this, companies can boost their performance by doing a better job at communicating
    the processes that are currently established and by assisting teams to easily
    navigate those processes. Senior executives should go see the actual work being
    performed, comprehend the process, understand the work, ask questions, and learn.
  prefs: []
  type: TYPE_NORMAL
- en: Higher performance is the result when all team members have full operational
    awareness of the change approval process. Next, we’ll discuss how to pragmatically
    implement a DevOps-centric change approval process.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a change approval process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Reducing risk associated with implementing changes and meeting the requirements
    set forth by regulators are two of the most significant reasons for adhering to
    the change approval process. Separation of duties is a common multi-industry regulatory
    requirement stipulating that any changes to a process must be approved by an individual
    who is not the original creator of the process. This ensures that no single person
    has complete control over the entirety of a process.
  prefs: []
  type: TYPE_NORMAL
- en: The conventional approach to achieving these results has been to submit a proposed
    change to an external group for approval, such as a **change control board** (**CCB**)
    or a **change advisory board** (**CAB**). However, the DevOps Research and Assessment
    group has released studies revealing that these methods adversely impact the velocity
    of software deployments. Moreover, the belief that formal, external review procedures
    lead to lower change-fail rates was unsupported by the data. These cumbersome
    methods increase the production system’s exposure to risk and hence increase the
    failure rates of changes because they slow down the delivery process and cause
    the developers to release larger batches of work less frequently. The DevOps Research
    and Assessment group’s analysis of the data confirmed the validity of this theory.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, teams should concentrate on the segregation of roles, which can be
    achieved through the use of a peer review. Furthermore, the platform that manages
    software development should be used to record reviews, comments, and approvals.
    Additionally, you should make use of automation, continuous testing, CI, monitoring,
    and observability so that you can quickly discover, avoid, and remedy any undesirable
    changes. Finally, consider your development platform to be a product that, when
    used properly, makes it simple for developers to obtain quick feedback on the
    impact that their changes will have on various axes, such as security, performance,
    and stability, in addition to defects.
  prefs: []
  type: TYPE_NORMAL
- en: Your objective should be to make your standard procedure for managing changes
    quick and dependable enough to be used in times of urgency. In this new light,
    a CCB or CAB still plays an important part in the continuous delivery paradigm,
    which comprises streamlining the process of team communication and collaboration.
    Also, the CCB should facilitate the teams’ efforts to enhance software delivery
    performance through process improvement activities, such as hosting internal *hackathons*.
    Finally, leadership should offer input on strategic business choices that necessitate
    a balance between competing priorities, such as the choice between speed to market
    and business risk, or gaining buy-in from higher-ups in the organization.
  prefs: []
  type: TYPE_NORMAL
- en: The CCB’s new position is strategic. The delegation of meticulous code reviews
    to practitioners and the implementation of automated processes enable individuals
    in leadership and management roles to allocate their time and attention toward
    more strategic endeavors. The strategies of leading-edge software delivery organizations
    mirror this shift from gatekeeper to process architect and information lighthouse.
  prefs: []
  type: TYPE_NORMAL
- en: Obstacles to implementing change approval
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Having too much dependence on a CCB to correct defects and approve changes is
    one of the most common mistakes found today. Choosing to conduct oversight using
    a CCB typically leads to extra waiting and unfortunate communication issues that
    crop up. While it is true that CCBs are effective at disseminating information
    about changes, many teams that operate across diverse time zones could be unintentionally
    misinformed regarding the significance of a new change or policy. Whitewashing
    approval processes is another common mistake that businesses make. This implies
    that the inefficiencies of change reviews arise when all changes are subjected
    to a uniform approval process, preventing individuals from allocating sufficient
    time and individual attention to those changes that require focused consideration
    due to variations in risk profiles or deadlines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another common mistake that companies make is a lack of investment in continuous
    improvement initiatives. To enhance the performance of the change management process,
    it is imperative to focus on key performance indicators such as lead time and
    change fail rate. This necessitates providing teams with the appropriate tools
    and training to facilitate their effective navigation through the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8: Overcoming obstacles in DevOps change management](img/B21803_08_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.8: Overcoming obstacles in DevOps change management'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, adding unnecessary processes is a common error that many companies
    repeat. It is frequently the case that businesses implement extra procedures and
    more rigorous authorization protocols in response to stability issues that are
    encountered during the software manufacturing phases. Real-world analysis indicates
    that adopting this technique will most likely exacerbate the situation due to
    its impact on lead times and batch sizes, consequently producing a negative feedback
    loop. Rather than committing to this, allocate resources toward gradually building
    up the efficiency and security of the change-making process over time, but think
    of them as going hand-in-hand.
  prefs: []
  type: TYPE_NORMAL
- en: Methods to enhance the change approval process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To improve your change approval processes, focus on implementing automated tests
    and the use of peer review processes to evaluate all modifications before they
    are committed. Another way to improve the change approval process includes developing
    methods that automate the detection of issues, including regressions, performance
    issues, and security vulnerabilities, as soon as possible once code changes are
    committed. Also, conduct regular analysis to identify and highlight high-risk
    changes and promptly conduct further investigations if any are found.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, it is good practice to implement methods that move validation
    steps into the development platform. This helps your team study the entire change
    process, look for bottlenecks, and identify potential solutions. Instead of manually
    checking security rules as part of the software delivery process, they are implemented
    at the platform and infrastructure layer and in the development toolchain.
  prefs: []
  type: TYPE_NORMAL
- en: According to findings presented in the 2019 *State of DevOps Report*, improving
    software delivery performance can be as simple as doing a better job of communicating
    the existing process and assisting teams in navigating it efficiently. This can
    have a positive impact on software delivery performance, even though the ultimate
    goal is to move away from traditional, formal change management processes. Outstanding
    performance is accomplished by everyone on the team having a crystal clear awareness
    of the procedures that must be followed to get changes approved for implementation.
    This indicates that they are secure in their ability to get changes through the
    approval process in the shortest time possible and that they are aware of the
    processes required for all of the different types of changes that they generally
    submit.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This marks the conclusion of [*Chapter 8*](B21803_08.xhtml#_idTextAnchor141).
    After reading and comprehending the contents of this chapter, you should now have
    a reliable blueprint in your mind to draw from as you begin conducting your initiatives
    regarding the development and implementation of governance, a branching strategy,
    release pipelines, and change management.
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve seen, by architecting your CI/CD infrastructure to automatically enforce
    these tenets, you minimize the risk of human error and burnout. The implications
    for this should not be taken lightly as we are not replacing or watering down
    governance, branching strategies, release pipelines, and change management in
    our organizations. Rather, we are *baking them into the cake*. This means that
    these duties must still be thoroughly implemented and enforced as before, but
    through the various oversight mechanisms that can be implemented in the configurations
    of your CI/CD pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll discuss effective strategies that you can use to
    develop a culture of DevOps in your organization’s release management strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What are each of the *OWASP Top 10 CI/CD* *Security Risks*?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the three common paths to CI/CD governance?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the significance of mapping CI/CD systems and processes? What term described
    this process?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the four most common branching strategies used by development teams
    today?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between *trunk-based development* and *scaled* *trunk
    development*?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the four branching strategies described in this chapter promote *feature-driven*
    development?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a release pipeline and a deployment pipeline?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between an artifact store and a configuration store?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why are external CCBs and CABs frequently cited as an anti-pattern in the context
    of DevOps release management?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is it considered good practice to implement methods that move validation
    steps into the development platform?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Part 3: Develop a Culture of DevOps in Your Organization’s Release Management
    Strategy'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final section of the book, we’ll begin with understanding what DevOps
    culture is and how you can successfully develop one in your organization. Next,
    we’ll take a look at the crucial aspect of what receiving support from leadership
    and stakeholders looks like. Finally, we’ll explore how to overcome common pitfalls
    in DevOps Release Management by investigating some of the ways that you can hedge
    against these growing pains, leading your organization to become the next success
    story.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B21803_09.xhtml#_idTextAnchor168), *Embracing DevOps Culture
    in Your Release Management Strategy*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B21803_10.xhtml#_idTextAnchor185), *What Does Receiving Support
    from Leadership and Stakeholders Look Like*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B21803_11.xhtml#_idTextAnchor199), *Overcoming Common Pitfalls
    in DevOps Release Management*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
