<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer011">&#13;
			<h1 id="_idParaDest-16" class="chapter-number"><a id="_idTextAnchor015"/>1</h1>&#13;
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Kubernetes in Today’s World</h1>&#13;
			<p>If you’re reading this book, chances are you’ve been, or still are, in the tech/IT world in some capacity, whether it’s from the operations side, the development side, or both – perhaps even technical leadership or product management. In any case, you’ve most likely heard about a platform/technology<a id="_idIndexMarker000"/> called <strong class="bold">Kubernetes</strong>. From how every company, both small and large, is talking about Kubernetes, a lot of engineers and leadership personnel think it’s going to solve many problems. Although that’s true, there’s a twist, and with everything that makes our lives easier, there <span class="No-Break">are caveats.</span></p>&#13;
			<p>This chapter is primarily theoretical and will answer a lot of the questions you most likely have about moving to the cloud, hybrid environments, cloud-native/specific applications, and how Kubernetes is taking over the <span class="No-Break">microservice ecosystem.</span></p>&#13;
			<p>By the end of this chapter, you’ll be able to answer some of the questions about the pros and cons of implementing Kubernetes. You’ll have a solid understanding of why engineers and leadership teams alike are moving to Kubernetes. The gears will also start moving in your head concerning what your current application(s) look like and whether Kubernetes would be a <span class="No-Break">good fit.</span></p>&#13;
			<p>In this chapter, we’re going to cover the <span class="No-Break">following topics:</span></p>&#13;
			<ul>&#13;
				<li>The shift to <span class="No-Break">the cloud</span></li>&#13;
				<li>Kubernetes, the new cloud OS and <span class="No-Break">data center</span></li>&#13;
				<li>Cloud-native applications and why <span class="No-Break">they’re important</span></li>&#13;
				<li>Abstraction is easier, but with <span class="No-Break">a twist</span></li>&#13;
				<li>Start slow and <span class="No-Break">go fast</span></li>&#13;
			</ul>&#13;
			<h1 id="_idParaDest-18"><a id="_idTextAnchor017"/>Technical requirements</h1>&#13;
			<p>This chapter will be more theory than hands-on, so you don’t have to worry about any coding or labs. To follow along with this chapter, and this book in general, you should have beginner-level knowledge of Kubernetes, intermediate knowledge of the cloud, and some experience with applications <span class="No-Break">and architecture.</span></p>&#13;
			<p>Moving forward, a lot of the chapters in this book will include labs and hands-on work. You can find the code for each exercise in this book’s GitHub repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/50-Kubernetes-Concepts-Every-DevOps-Engineer-Should-Know"><span class="No-Break">https://github.com/PacktPublishing/50-Kubernetes-Concepts-Every-DevOps-Engineer-Should-Know</span></a><span class="No-Break">.</span></p>&#13;
			<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>The shift to the cloud</h1>&#13;
			<p>Before diving into Kubernetes, there’s an important question to ask: Why use Kubernetes? The reality is that<a id="_idIndexMarker001"/> organizations have been deploying applications without Kubernetes for years. There wasn’t Kubernetes in the 1980s when engineers were writing software to floppy disks. So, <span class="No-Break">why now?</span></p>&#13;
			<p>The answer to this question is a complicated one and the best place to start is by thinking about what the cloud does for us – not necessarily what the cloud is, but instead what the cloud helps us think about when deploying software and systems from an architect, engineering, and management perspective. In this section, you’re going to learn about the following aspects of <span class="No-Break">the cloud:</span></p>&#13;
			<ul>&#13;
				<li>Why organizations care about <span class="No-Break">the cloud</span></li>&#13;
				<li>What the cloud did <span class="No-Break">for engineers</span></li>&#13;
				<li>How abstraction can help us learn from <span class="No-Break">our mistakes</span></li>&#13;
				<li>How the cloud doesn’t exactly do what people think <span class="No-Break">it does</span></li>&#13;
			</ul>&#13;
			<p>Let’s take a <span class="No-Break">closer look.</span></p>&#13;
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Why organizations care about the cloud</h2>&#13;
			<p>Leadership teams in organizations, whether it’s the CIO, CTO, or someone in a technical leadership position, tend to tie Kubernetes to the cloud. However, this couldn’t be any further from the truth. The reason why could be anything from incredibly good technical marketing to not having enough experience from a hands-on perspective to truly understand what’s happening underneath the hood in a cloud environment. However, let’s digress from that and think about why everyone cares about the cloud. The best way to do this is with a visual, so let’s take a look at the <span class="No-Break">following diagram:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer009" class="IMG---Figure">&#13;
					<img src="Images/B19116_01_01.jpg" alt="Figure 1.1 – Data center web app architecture&#13;&#10;" width="1650" height="1466"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Data center web app architecture</p>&#13;
			<p>The preceding diagram is of a data<a id="_idIndexMarker002"/> center architecture. There are a lot of pieces, some marked and some not, including <span class="No-Break">the following:</span></p>&#13;
			<ul>&#13;
				<li><span class="No-Break">Servers</span></li>&#13;
				<li><span class="No-Break">Network equipment</span></li>&#13;
				<li>Connections <span class="No-Break">between servers</span></li>&#13;
				<li>Ethernet cables and <span class="No-Break">power cables</span></li>&#13;
			</ul>&#13;
			<p>With all of that hardware not only comes costs of actually buying it, but also costs around hiring engineers to manage it, maintain it, and keep the lights on in the data center. Not to mention it takes about 4 to 6 months for a full data center to be up and running. With the time that it takes the data center to get up and running, on top of all of the costs and management of hardware, having cloud-based systems starts to make a lot of sense to senior leadership teams for any organization ranging from start-ups to the <span class="No-Break">Fortune 500.</span></p>&#13;
			<p>Now, let’s take a look at<a id="_idIndexMarker003"/> the architecture in <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.2</em>. This diagram shows a few things, including <span class="No-Break">the following:</span></p>&#13;
			<ul>&#13;
				<li>RDS (Amazon’s <span class="No-Break">database service)</span></li>&#13;
				<li><span class="No-Break">Load balancers</span></li>&#13;
				<li><span class="No-Break">CDNs</span></li>&#13;
				<li>S3 buckets (cloud storage <span class="No-Break">in AWS)</span></li>&#13;
				<li>Route 53 (<span class="No-Break">AWS DNS)</span></li>&#13;
			</ul>&#13;
			<p>The architecture diagram in <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.2</em> is similar to <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.1</em>, in that they are both data centers, but only <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.2</em> is virtualized as exactly what you would see in a data center. You have network components, storage, databases, servers, and everything in between. The biggest difference is what you’re seeing here is virtualized. It’s a virtual data center with virtual services. Because there are engineers that work at AWS managing the hardware, networking, and other peripherals for you, you no longer have to do it. You only have to worry about the services themselves and making sure they’re working <span class="No-Break">as expected.</span></p>&#13;
			<p>No more buying hardware. No more replacing hard drives. No more waiting 4 to 8 months for hardware to arrive at your data center so you can finally build it. Instead, an entire data center is only a few button clicks or a few lines of automation <span class="No-Break">code away:</span></p>&#13;
			<div>&#13;
				<div id="_idContainer010" class="IMG---Figure">&#13;
					<img src="Images/B19116_01_02.jpg" alt="Figure 1.2 – Cloud web app architecture&#13;&#10;" width="1170" height="1285"/>&#13;
				</div>&#13;
			</div>&#13;
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – Cloud web app architecture</p>&#13;
			<p>Going off of the <a id="_idIndexMarker004"/>preceding diagram, here’s where Kubernetes comes into play. Regardless of what option you go with, on-premises or in the cloud, there’s still a ton of stuff to manage. Even though the cloud makes infrastructure easier, there are still major staffing needs and a big cost behind creating all of the <span class="No-Break">cloud infrastructures.</span></p>&#13;
			<p>The following are a few pieces of the puzzle <span class="No-Break">to manage:</span></p>&#13;
			<ul>&#13;
				<li><span class="No-Break">Load balancers</span></li>&#13;
				<li>Virtual machines (or <span class="No-Break">bare-metal servers)</span></li>&#13;
				<li>Network equipment (virtual <span class="No-Break">or physical)</span></li>&#13;
				<li>Subnets, private IPs, public IPs, <span class="No-Break">and gateways</span></li>&#13;
				<li>Security for multiple pieces of virtualized hardware <span class="No-Break">and services</span></li>&#13;
			</ul>&#13;
			<p>And that’s just to name the general categories. Within each category, there are multiple components (physical and/or virtual) to manage. With Kubernetes, it’s all abstracted away from you. There aren’t any firewalls or gateways because that’s managed via kube-proxy. There are <a id="_idIndexMarker005"/>no virtual machines that you have to deploy other than the Kubernetes nodes because the apps are running in <span class="No-Break">Kubernetes Pods.</span></p>&#13;
			<p>If you run Kubernetes in a <a id="_idIndexMarker006"/>Kubernetes service such as <strong class="bold">Azure Kubernetes Service</strong> (<strong class="bold">AKS</strong>) or GKE, the management of the Control Plane, sometimes<a id="_idIndexMarker007"/> referred to as the API server or the master nodes (a now deprecated way to describe Control Planes), is completely abstracted away <span class="No-Break">from you.</span></p>&#13;
			<p>What AKS, GKE, or another one of the cloud Kubernetes services does underneath the hood is the same thing that you would do if you ran a raw Kubernetes cluster in a bunch of virtual machines. The underlying technology, how it works, and how it’s used don’t change. The only thing that changes is <span class="No-Break">the abstraction.</span></p>&#13;
			<p>That’s why the cloud is important for Kubernetes and that’s why CIOs, CTOs, and engineers <span class="No-Break">should care.</span></p>&#13;
			<h2 id="_idParaDest-21"><a id="_idTextAnchor020"/>What the cloud did for engineers</h2>&#13;
			<p>“<em class="italic">The cloud is just someone else’s computer,</em>” as some may say in passing or on funny stickers. As we all know, in every joke is a little truth. The truth is, it’s correct. When you’re interacting with the cloud, it’s<a id="_idIndexMarker008"/> not that you’re interacting with some magical service that is <em class="italic">just there</em>. Instead, you’re interacting with services that are managed by <span class="No-Break">other engineers.</span></p>&#13;
			<p>For example, let’s say you’re working with Azure virtual machines or EC2 instances in AWS. From your perspective, you log into one of the portals or write some <strong class="bold">Infrastructure as Code</strong> (<strong class="bold">IaC</strong>) and in a few<a id="_idIndexMarker009"/> minutes, your new virtual server/cloud server is deployed. On the backend, there’s way more that goes into it. There are a ton of different parts, some of which include <span class="No-Break">the following:</span></p>&#13;
			<ul>&#13;
				<li>Autoscaling <span class="No-Break">the servers</span></li>&#13;
				<li>Doing multiple checks to ensure that there’s enough hard disk, CPU, and RAM space on the physical/bare-metal server that’s <span class="No-Break">being used</span></li>&#13;
				<li><span class="No-Break">Networking setup</span></li>&#13;
				<li>Lots <span class="No-Break">of automation</span></li>&#13;
			</ul>&#13;
			<p>Remember, because the cloud servers that you’re deploying are running on bare-metal servers, people have to be there to manage those servers and maintain them. The cloud is an abstraction layer that you don’t see. With that being said, the cloud has done a lot <span class="No-Break">for engineers.</span></p>&#13;
			<p>Let’s take a start-up company for example. Years ago, if a start-up company wanted to do anything in the tech <a id="_idIndexMarker010"/>space, they needed servers to host applications and websites. For a small company that’s working out of a tiny office or even from someone’s house, it’s not possible to have a layer of high availability, redundancy, and scalability. They simply cannot afford the hardware, the space, and the employees to <span class="No-Break">do it.</span></p>&#13;
			<p>With the cloud, they no longer have to worry about having to do all of that. Instead, the start-up can focus on building applications and deploying them to the cloud. Deploying applications to the cloud is not easy and it certainly has its own complexity, but the idea behind it is to abstract away physical needs (servers, infrastructure, and so on) that your company may not want to/have to worry about. </p>&#13;
			<h1 id="_idParaDest-22"><a id="_idTextAnchor021"/>Kubernetes, the new cloud OS and data center</h1>&#13;
			<p>Kubernetes is a topic that’s on everyone’s mind, but at the same time, a lot of individuals don’t understand <a id="_idIndexMarker011"/>why. Is it the actual platform itself? Or what the platform does for engineers in today’s world? The answer to those questions is – sort of both. Kubernetes does several things, but the primary pieces include <span class="No-Break">the following:</span></p>&#13;
			<ul>&#13;
				<li>Deploying your <span class="No-Break">containerized application</span></li>&#13;
				<li>Scaling <span class="No-Break">your application</span></li>&#13;
				<li>Ensuring that your application is <span class="No-Break">highly available</span></li>&#13;
				<li>Giving you the ability to secure your application and the users accessing <span class="No-Break">the application</span></li>&#13;
			</ul>&#13;
			<p>These four points sound like what engineers have already been doing with computers since the inception <a id="_idIndexMarker012"/>of the first mainframe. The question now becomes, why is Kubernetes <span class="No-Break">so popular?</span></p>&#13;
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Kubernetes in the cloud</h2>&#13;
			<p>Everywhere you look, it feels like there’s a new way to utilize the Kubernetes platform or some new tool that’s<a id="_idIndexMarker013"/> supposed to make your life easier. Some of these platforms include the following (you’ll learn more about these in the <span class="No-Break">upcoming chapters):</span></p>&#13;
			<ul>&#13;
				<li>Cloud Kubernetes services<a id="_idIndexMarker014"/> such as AKS, <strong class="bold">Google Kubernetes Engine</strong> (<strong class="bold">GKE</strong>), and Amazon <strong class="bold">Elastic Kubernetes </strong><span class="No-Break"><strong class="bold">Service</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">EKS</strong></span><span class="No-Break">)</span></li>&#13;
				<li><strong class="bold">Platform-as-a-Service</strong> (<strong class="bold">PaaS</strong>) offerings such <a id="_idIndexMarker015"/><span class="No-Break">as OpenShift</span></li>&#13;
				<li>Serverless Kubernetes platforms such as Azure Container Apps and AWS Fargate profiles <span class="No-Break">on EKS</span></li>&#13;
			</ul>&#13;
			<p>Although that’s not an extensive list, you can see that just the sheer number of platforms that are at your disposal can make it extremely difficult to pick and choose what you should ultimately go with. The semi-agreed-upon answer to this question is that it all depends on your current ecosystem. If you’re in AWS, use EKS. If you’re in Azure, use AKS. If you’re a Red Hat Enterprise customer, check out OpenShift. The reason why is that, at the end of the day, all of the Kubernetes services are doing the same thing. They’re all using Kubernetes under the hood and utilizing cloud services to make your <span class="No-Break">life easier.</span></p>&#13;
			<p>For example, if you’re using AKS, chances are you <a id="_idIndexMarker016"/>probably want to use <strong class="bold">Azure Active Directory</strong> (<strong class="bold">AAD</strong>) to manage who has access to what in the AKS cluster. Azure makes it extremely straightforward to implement this because the goal of a Kubernetes service in the cloud is to do exactly that. All public clouds in general are trying to make your life easier, regardless of what cloud you’re using. A great example of this is how you can use AAD inside of GKE via federation with Cloud Identity to map AAD tenants, users, <span class="No-Break">and groups.</span></p>&#13;
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Why Kubernetes?</h2>&#13;
			<p>The question from the beginning of this chapter around why people want to use Kubernetes has sort of been<a id="_idIndexMarker017"/> answered, but there’s still more to think about. Primarily, we must think about why everyone is flocking toward Kubernetes, especially Kubernetes services in the cloud. The answer to why people are using Kubernetes services in the cloud is typically something similar to one of <span class="No-Break">the following:</span></p>&#13;
			<ul>&#13;
				<li>You don’t have to worry about the <span class="No-Break">underlying infrastructure</span></li>&#13;
				<li>Worker nodes and Control Planes are scaled for <span class="No-Break">you </span><span class="No-Break"><em class="italic">automagically</em></span></li>&#13;
			</ul>&#13;
			<p>And although those are great answers, you’re still not any closer to the answer as to why you should use Kubernetes if all it’s doing is what everyone has been doing in tech for years. It’s not implementing anything new or out of <span class="No-Break">the ordinary.</span></p>&#13;
			<p>Simply put, the reason why people like Kubernetes is that it allows you to interact with your infrastructure via an API. When you run a Kubernetes command such as <strong class="source-inline">kubectl apply -f deployment.yaml</strong>, you’re interacting with the Kubernetes API. When you run a command such as <strong class="source-inline">kubectl get deployments</strong>, you’re interacting with an API. 99% of what you do when interacting with Kubernetes is all API-based. It’s a bunch of <strong class="source-inline">GET</strong> and <strong class="source-inline">POST</strong> requests. The reason why Kubernetes makes engineers’ lives easier is that what you used to have to do to get an application up and running on multiple servers is now abstracted away and it’s all now at the programmatic level. <span class="No-Break">All APIs.</span></p>&#13;
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Kubernetes as a data center</h2>&#13;
			<p>Remember data centers? Those things that have the loud, big computers running with a bunch of fans and air conditioners? Perhaps <a id="_idIndexMarker018"/>you’re from the era of spending hours in a data center, racking and stacking servers, and taking a nap on the data center floor using your backpack as a pillow. If you’ve never done any of that, consider yourself a <span class="No-Break">lucky person!</span></p>&#13;
			<p>When thinking about a data center, there are several components, but let’s think about the main ones that engineers <span class="No-Break">care about:</span></p>&#13;
			<ul>&#13;
				<li><span class="No-Break">Servers</span></li>&#13;
				<li>Network equipment (firewalls, load balancers, routers, switches, gateways, and <span class="No-Break">so on)</span></li>&#13;
				<li>Outbound and <span class="No-Break">inbound connectivity</span></li>&#13;
				<li><span class="No-Break">Security</span></li>&#13;
				<li>The ability to run software and virtualization on <span class="No-Break">the servers</span></li>&#13;
			</ul>&#13;
			<p>Containerization platforms such as LXC and Docker were able to give us the fifth point mentioned here – virtualization <a id="_idIndexMarker019"/>of OSes and the ability to run software – but what about the rest? Engineers needed a way to orchestrate and manage the software and virtualized OSes. That’s where Kubernetes comes <span class="No-Break">into play.</span></p>&#13;
			<p>Kubernetes fills every piece of the data <span class="No-Break">center puzzle:</span></p>&#13;
			<ul>&#13;
				<li>Networking, including Pod-to-Pod communication, services, service meshes, Ingress, load balancing, <span class="No-Break">and routing.</span></li>&#13;
				<li>Security and encryption between Pods <span class="No-Break">and services</span></li>&#13;
				<li>High availability <span class="No-Break">for clusters</span></li>&#13;
				<li>The ability to deploy, manage, scale, and maintain applications of any kind (must <span class="No-Break">be containerized)</span></li>&#13;
				<li>Authentication and authorization capabilities from third-party tools such as AAD and <span class="No-Break">IAM users/roles</span></li>&#13;
			</ul>&#13;
			<p>Kubernetes is a one-stop shop for everything that you would find in a data center. The biggest difference is that the infrastructure (if you’re running in the cloud and not on-premises) is completely abstracted away. You don’t have to worry about the day-one operations; you only have to worry about getting an application deployed, orchestrated, and working as you and your team <span class="No-Break">see fit.</span></p>&#13;
			<p>One important piece of information to think about here is with new technology comes new problems. Kubernetes isn’t easy. Just because you don’t have to deal with sleeping on a data center floor doesn’t mean you won’t have an entirely new set of problems to understand and fix. Does Kubernetes make your life easier as an engineer? Yes. Does Kubernetes make your life harder? Yes. Although, the goal is to make your life a little less hard with Kubernetes, please keep in mind that it isn’t a magic box that you set <span class="No-Break">and forget.</span></p>&#13;
			<h1 id="_idParaDest-26"><a id="_idTextAnchor025"/>Cloud-native apps and why they’re important</h1>&#13;
			<p>When thinking about creating any type of application, automation code, or piece of software, there always needs to be some sort of standard. The thing is, there are many standards and there isn’t a one-size-fits-all solution. Sure, there are (what should be) mandatory standards for writing code such as storing the code in source control and running certain types of tests, but the workflows for each organization will be <span class="No-Break">drastically different.</span></p>&#13;
			<p>When it comes to cloud-native applications and applications running on Kubernetes, the thought process of workflows is the same as any other application, but there are true, standard processes that are <a id="_idIndexMarker020"/>automatically implemented for you. This includes things such as <span class="No-Break">the following:</span></p>&#13;
			<ul>&#13;
				<li><span class="No-Break">Easy autoscaling</span></li>&#13;
				<li><span class="No-Break">Self-healing</span></li>&#13;
				<li>Networking out of <span class="No-Break">the box</span></li>&#13;
				<li>And a <span class="No-Break">lot more</span></li>&#13;
			</ul>&#13;
			<p>In the upcoming section, we’ll build on what you learned previously and dive into what cloud-native apps do <span class="No-Break">for organizations.</span></p>&#13;
			<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/>What cloud-native apps do for organizations</h2>&#13;
			<p>By definition, a <a id="_idIndexMarker021"/>cloud-native application gives you the ability to do <span class="No-Break">the following:</span></p>&#13;
			<ul>&#13;
				<li><span class="No-Break">Easily scale</span></li>&#13;
				<li>Make highly available almost out of <span class="No-Break">the box</span></li>&#13;
				<li>Deploy <span class="No-Break">more efficiently</span></li>&#13;
				<li>Continuously make changes in a much easier fashion versus outside of Kubernetes in a bare-metal/data <span class="No-Break">center environment</span></li>&#13;
			</ul>&#13;
			<p>When thinking about cloud-native applications and the preceding list, microservices typically come to mind. The idea behind microservices, which is a big piece of the idea behind cloud-native, is the ability to make changes faster and more efficiently. When you’re dealing with a monolithic application, the application has many dependencies and is essentially tied together. You can’t update one piece of the application without bringing down the rest of the application. Blue/green and canary deployments are far more complicated<a id="_idIndexMarker022"/> because of the tightly coupled monolithic application. Self-healing and scalability mean scaling the entire application, not just the pieces that need to be scaled, which means more resources (RAM, CPU, and so on) are typically consumed than <span class="No-Break">what’s needed.</span></p>&#13;
			<p>Cloud-native and the microservice mindset aim to fix this problem. With microservices running inside Kubernetes, there are some extreme benefits. You can manage how many replicas (copies) of the application are running. That way, you can scale them out or scale them back when needed. Self-healing of Pods is far more efficient since if a piece of the application that’s running inside of a Pod goes down, it’s not a huge deal because it’ll come right back up automatically. The applications running inside of Pods, which have one or more containers running inside of the Pods, are loosely coupled, so updating/upgrading versions of the application in a blue/green or canary scenario utilizing a rolling update is far less likely <span class="No-Break">to fail.</span></p>&#13;
			<p>When it comes to teams, as in, individual engineers, microservices help a ton. With a monolithic application, there is a fair amount of coordination that has to happen between the team when changing anything in the code base. Although teamwork and communication are crucial, there shouldn’t be a reason to let everyone know about a code change in the development environment that you’re making to test a piece of functionality without breaking everyone else’s code. With how fast organizations want to move in today’s world, this process slows engineering teams down to a grinding halt. Not to mention, if an engineer wants to test how the functionality will work with the rest of the application, they shouldn’t have to worry about every piece of the application breaking. That’s really where <span class="No-Break">microservices shine.</span></p>&#13;
			<p>When the Kubernetes architecture was built, it was thought about in the same way as cloud-native applications – a loosely coupled architecture that is easily scalable and doesn’t have a ton of dependencies (hence, the microservice movement). Can you run monolithic applications on Kubernetes? Absolutely. Will they still self-heal and autoscale? Absolutely. The idea behind a cloud-native application environment and cloud-native Kubernetes is to use a microservice-style architecture, but you shouldn’t let that stop you from jumping into Kubernetes. The primary goal is to have independent services that can be accessed<a id="_idIndexMarker023"/> via an <strong class="bold">Application Programming </strong><span class="No-Break"><strong class="bold">Interface</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">API</strong></span><span class="No-Break">).</span></p>&#13;
			<p>The final piece of the puzzle is containerized applications. Before even running an application inside Kubernetes, it must be containerized. When the idea of containers was thought about way before <a id="_idIndexMarker024"/>Docker was around, the idea was to have the ability to split an entire application into tiny micro-sized pieces. When containers are built, they’re built with the same mindset as the <span class="No-Break">following aspects:</span></p>&#13;
			<ul>&#13;
				<li>Self-contained <span class="No-Break">execution environments</span></li>&#13;
				<li><span class="No-Break">Virtualized OSes</span></li>&#13;
				<li>Microservice architecture with the ability to split up pieces of an entire application and consolidate it into a single container for the ability to easily scale, update, and <span class="No-Break">swap out</span></li>&#13;
			</ul>&#13;
			<h2 id="_idParaDest-28"><a id="_idTextAnchor027"/>The world is cloud-based</h2>&#13;
			<p>One of the worst things that an organization can do in today’s world, from an engineering perspective, is to get left behind. The last thing an organization wants is to realize 10 years later that the systems and dependencies that they have in place are so old that no organization or<a id="_idIndexMarker025"/> software company is even supporting them anymore. The golden rule before 2015/2016 was to ensure that the architecture and the people/engineers running the architecture were up to date every 5 to 10 years. Now, with how fast technology is moving, it’s more like every 2 to <span class="No-Break">5 years.</span></p>&#13;
			<p>When looking at organizations such as Microsoft, Google, and AWS, they’re releasing huge changes and updates all the time. When attending a conference such as Microsoft Build or the AWS Summit, the keynotes are filled with game-changing technology with tons of new services coming to the cloud platforms all the time. The reality is that if organizations don’t want to be left behind, they can’t wait more than 5 years to start thinking about the <span class="No-Break">newest technology.</span></p>&#13;
			<p>With that being said, many organizations can’t simply upgrade systems every 6 months or every year because they’re too large and they don’t have enough people to make those migrations and updates. However, technology leaders need to start thinking about what this will look like because the future of the company will be on the line. For example, let’s look at the change in Windows Server over the past few years. Microsoft used to constantly talk about new Windows Server versions and features at every conference. Now, it’s all about Azure. The technology world is <span class="No-Break">changing drastically.</span></p>&#13;
			<p>Where Kubernetes fits in here is that it helps you make cloud-native and fast-moving decisions almost automatically. For example, let’s say (in a crazy world) Kubernetes goes away in 3 years. You still have your containerized applications and your code base that’s in source control and<a id="_idIndexMarker026"/> loosely coupled, which means you can run it anywhere else, such as in a serverless service or even a virtual machine if it comes down to it. With the way that the world is going, it’s not necessarily about always using Kubernetes to prevent an organization from going down. It’s about what Kubernetes does for engineers, which is that it allows you to manage infrastructure and applications at the <span class="No-Break">API level.</span></p>&#13;
			<h2 id="_idParaDest-29"><a id="_idTextAnchor028"/>Engineering talent is toward the cloud</h2>&#13;
			<p>One last small piece we will talk about is the future of engineers themselves. New technology professionals are all about learning the latest and greatest. Why? Because they want the ability to <a id="_idIndexMarker027"/>stay competitive and get jobs. They want to stay up to date so they can have a long and healthy career. What this means is that they aren’t interested in learning about how to run a data center, because the tech world is telling everyone to learn about <span class="No-Break">the cloud.</span></p>&#13;
			<p>As time goes on, it’s going to become increasingly difficult for organizations to find individuals that can manage and maintain legacy systems. With that being said, there’s no end in sight for legacy systems going away. That’s why organizations such as banks are still looking for COBOL developers. The thing is, no engineer wants to bet their career in their 20s on learning legacy pieces. </p>&#13;
			<h1 id="_idParaDest-30"><a id="_idTextAnchor029"/>Abstraction is easier, but with a twist</h1>&#13;
			<p>One of the biggest buzzwords in<a id="_idIndexMarker028"/> the technology space today is <em class="italic">abstraction</em>. Abstraction, at its highest level, involves removing certain pieces of work from you that you specifically need to do to get the job done. For example, if a developer needs to run code, they need to run code. They don’t need to build virtual machines or deploy networks. They simply need to run an application. Removing the need for a virtual machine or a network is abstracting away what the developer doesn’t need to spend time and <span class="No-Break">focus on.</span></p>&#13;
			<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>What abstraction does</h2>&#13;
			<p>Let’s take a look at what abstraction does from two sides – Dev <span class="No-Break">and Ops.</span></p>&#13;
			<p>From a Dev perspective, the<a id="_idIndexMarker029"/> goal of a developer is to plan out pieces of an application, write the code to make those pieces work, and deploy them to see how the pieces work together. However, to deploy the code, you used to need a server, an OS, and other components. With platforms such as Kubernetes, developers don’t need that anymore. Instead of having to worry about deploying virtual machines, developers simply have to write a Kubernetes manifest that contains a container image with the application inside of it. No more having to worry about <span class="No-Break">day-one operations.</span></p>&#13;
			<p>From an Ops perspective, infrastructure<a id="_idIndexMarker030"/> engineers or cloud engineers no longer have to worry about having to stop what they’re doing to order servers, deploy virtual machines, and fight to make an OS work as expected. Instead, they can write out a Kubernetes manifest and other API-driven techniques (such as IaC) to ensure that a Kubernetes cluster is up and running, operational, and ready to host developer <span class="No-Break">code/container images.</span></p>&#13;
			<h2 id="_idParaDest-32"><a id="_idTextAnchor031"/>What abstraction doesn’t do</h2>&#13;
			<p>One primary thing that<a id="_idIndexMarker031"/> abstraction doesn’t do is remove the need to think logically and from an architectural perspective for engineering-related work. Abstraction removes what’s now considered the <em class="italic">low-hanging fruit</em> of an environment. For example, a virtual machine with the need to deploy an OS and manage all the components can now be considered low-hanging fruit when the other option is to deploy a Kubernetes cluster and manage the infrastructure at the <span class="No-Break">API level.</span></p>&#13;
			<p>The important piece to remember is that engineers and developers still need to think. Abstraction isn’t about having a solution where you press a button or two and poof, your application is up and running with scaling and plenty of high availability. Abstraction at this level still requires solid architecture, planning, and <span class="No-Break">repeatable processes.</span></p>&#13;
			<h1 id="_idParaDest-33"><a id="_idTextAnchor032"/>Start slow and go fast</h1>&#13;
			<p>The final part of this chapter will involve mapping out how you can start slow but, at the same time, go fast when implementing Kubernetes. The idea is that you want to understand what’s happening inside<a id="_idIndexMarker032"/> of your organization so that you truly know the need for Kubernetes. Once you know that, you can start implementing it as fast as possible without taking on technical debt and management worries. When thinking about how to start slow and go fast, the premise is to understand the <em class="italic">why</em> behind the conversation around Kubernetes and then once you know that, <span class="No-Break">start iterating.</span></p>&#13;
			<h2 id="_idParaDest-34"><a id="_idTextAnchor033"/>Understanding the engineering need for Kubernetes</h2>&#13;
			<p>Every good engineer has a<a id="_idIndexMarker033"/> lot of goals, but a few of the primary ones are <span class="No-Break">as follows:</span></p>&#13;
			<ul>&#13;
				<li>Make my <span class="No-Break">life easier</span></li>&#13;
				<li>Remove the work that <span class="No-Break">isn’t important</span></li>&#13;
				<li>Conduct value-driven work for <span class="No-Break">an organization</span></li>&#13;
			</ul>&#13;
			<p>When it comes to putting out fires, waking up at 2:00 A.M. and rushing around to try to get a server up and running for a developer isn’t the most fun part of an engineer’s day. Instead, they want to focus on providing value to an organization. Abstraction helps a ton with removing what isn’t needed, as does <span class="No-Break">removing toil.</span></p>&#13;
			<p>The same goes for developers. They don’t want to worry about waiting days or weeks (or longer) to get a server up and running to host an application. They want a quick, efficient, and scalable way to host applications without having to sit around <span class="No-Break">and wait.</span></p>&#13;
			<p>The goal is for an engineer to understand the need for Kubernetes. It’s easy to look at the latest and greatest technology so that it can be implemented. That’s typically the fun part for many engineers, both on the Ops and Dev sides. However, the most important piece is understanding that Kubernetes removes the low-hanging fruit for setting up environments and instead allows you to focus on <span class="No-Break">value-driven work.</span></p>&#13;
			<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/>Understanding the business need for Kubernetes</h2>&#13;
			<p>There are always two sides to <a id="_idIndexMarker034"/>a tech plan in any organization – the technical/engineering side and the business side. On the business side, the primary important pieces are <span class="No-Break">as follows:</span></p>&#13;
			<ul>&#13;
				<li>Will Kubernetes help us <span class="No-Break">go faster?</span></li>&#13;
				<li>Will Kubernetes make us <span class="No-Break">more efficient?</span></li>&#13;
				<li>Will Kubernetes help us get to <span class="No-Break">market faster?</span></li>&#13;
				<li>Will Kubernetes help us reduce downtime and <span class="No-Break">engineering overhead?</span></li>&#13;
			</ul>&#13;
			<p>The answers to those questions are yes and no, and as an engineer, you have to be prepared to answer them. The golden rule is that Kubernetes removes the incredible complexity of racking and stacking a data center, much like the cloud. When talking about Kubernetes to the business, it isn’t a conversation around <em class="italic">implementing this Kubernetes thing and all our problems go away</em>. The conversation is more around <em class="italic">this Kubernetes thing will make our </em><span class="No-Break"><em class="italic">lives easier</em></span><span class="No-Break">.</span></p>&#13;
			<h2 id="_idParaDest-36"><a id="_idTextAnchor035"/>Planning is the hard part</h2>&#13;
			<p>As engineers, both on the Dev and Ops sides, playing with new technology is fun. Learning new tricks, new <a id="_idIndexMarker035"/>platforms, and beefing up your resume to stay competitive in the market is what a lot of individuals think about. Although that’s great, you also must think about the <em class="italic">why</em> behind <span class="No-Break">implementing Kubernetes.</span></p>&#13;
			<p>Before moving on to the next chapter, think about these <span class="No-Break">three things:</span></p>&#13;
			<ul>&#13;
				<li>Why do I feel like Kubernetes <span class="No-Break">is important?</span></li>&#13;
				<li>How can Kubernetes help my <span class="No-Break">environment progress?</span></li>&#13;
				<li>How can Kubernetes make deploying <span class="No-Break">software easier?</span></li>&#13;
			</ul>&#13;
			<p>Now, let’s summarize what we’ve learned in <span class="No-Break">this chapter.</span></p>&#13;
			<h1 id="_idParaDest-37"><a id="_idTextAnchor036"/>Summary</h1>&#13;
			<p>Before you can even think about implementing Kubernetes, you need to learn about what the cloud is doing for engineers, what cloud-native applications are doing for engineers, and why organizations need to start thinking about Kubernetes. This is always the first step in any engineering-related decision since it impacts not only you but the organization as a whole. Because of the way that the tech world is changing, understanding the need for implementing cloud-based solutions and how to move fast but start slow is how organizations have successful Kubernetes deployments and a smooth on-ramp from traditional monolithic applications to <span class="No-Break">implementing microservices.</span></p>&#13;
			<p>Now that you know the <em class="italic">why</em> behind implementing cloud-native technologies such as Kubernetes and what cloud-native applications do for organizations, it’s time to start learning about how to get started with Kubernetes. We will start the next chapter by understanding how to implement a Kubernetes service in the top <span class="No-Break">three clouds.</span></p>&#13;
			<h1 id="_idParaDest-38"><a id="_idTextAnchor037"/>Further reading</h1>&#13;
			<p>To learn more about the topics that were covered in this chapter, take a look at the <span class="No-Break">following resources:</span></p>&#13;
			<ul>&#13;
				<li><em class="italic">Architecting Cloud Computing Solutions</em>, by Kevin L. Jackson and Scott <span class="No-Break">Goessling: </span><a href="https://www.packtpub.com/cloud-networking/cloud-computing"><span class="No-Break">https://www.packtpub.com/cloud-networking/cloud-computing</span></a></li>&#13;
				<li> <em class="italic">vSphere Virtual Machine Management</em>, by Rebecca <span class="No-Break">Fitzhugh: </span><a href="https://www.packtpub.com/product/vsphere-virtual-machine-management/9781782172185"><span class="No-Break">https://www.packtpub.com/product/vsphere-virtual-machine-management/9781782172185</span></a></li>&#13;
				<li><em class="italic">Cloud Native Architectures</em>, by Tom Laszewski, Kamal Arora, Erik Farr, and Piyum <span class="No-Break">Zonooz: </span><a href="https://www.packtpub.com/product/cloud-native-architectures/9781787280540"><span class="No-Break">https://www.packtpub.com/product/cloud-native-architectures/9781787280540</span></a></li>&#13;
			</ul>&#13;
		</div>&#13;
	</div></body></html>