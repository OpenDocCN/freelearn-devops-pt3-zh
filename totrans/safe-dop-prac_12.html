<html><head></head><body>
		<div id="_idContainer124">
			<h1 id="_idParaDest-268" class="chapter-number"><a id="_idTextAnchor268"/>12</h1>
			<h1 id="_idParaDest-269"><a id="_idTextAnchor269"/>Continuous Deployment to Production</h1>
			<p>As we continue our journey through the Continuous Delivery Pipeline, we have designed features to test a benefit hypothesis during Continuous Exploration. Implementation of these features happened during Continuous Integration where we created stories, developed changes and tests, and put our changes through the build and test process. Ultimately, our change is placed in a <span class="No-Break">staging environment.</span></p>
			<p>With Continuous Deployment, we complete the journey of the change to the production environment. However, the activities don’t end with the deployment <span class="No-Break">to production.</span></p>
			<p>In this chapter, we will take a look at the practices that enable the following actions in <span class="No-Break">Continuous Deployment:</span></p>
			<ul>
				<li>Deploying a change <span class="No-Break">to production</span></li>
				<li>Verifying proper operation of changes in the <span class="No-Break">production environment</span></li>
				<li>Monitoring the <span class="No-Break">production environment</span></li>
				<li>Responding to and recovering from <span class="No-Break">production failures</span></li>
			</ul>
			<p>It’s important to remember that we separate deployment from release. We viewed the architectural concerns of enabling new changes to be automatically deployed to production environments in <a href="B18756_10.xhtml#_idTextAnchor221"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Continuous Exploration and Finding New Features</em>. While we continuously deploy to production, those changes are not visible to the customer until we release them. We talk about allowing only select people to view those changes in production in this chapter. We will talk about releasing on demand in our next chapter, <a href="B18756_13.xhtml#_idTextAnchor292"><span class="No-Break"><em class="italic">Chapter 13</em></span></a>, <em class="italic">Releasing on Demand to </em><span class="No-Break"><em class="italic">Realize Value</em></span><span class="No-Break">.</span></p>
			<p>Let’s begin our exploration of Continuous Deployment by looking at the first activity: deploying to the <span class="No-Break">production environment.</span></p>
			<h1 id="_idParaDest-270"><a id="_idTextAnchor270"/>Deploying to production</h1>
			<p>The goal of deployment is to get our solution in terms of a new product or enhancements <a id="_idIndexMarker866"/>to an existing product into a production environment. With Continuous Deployment, we want to move this solution as frequently as we can while minimizing the risk to our <span class="No-Break">production environment.</span></p>
			<p>The following practices allow us to deploy more frequently and reduce the risk of failures in the <span class="No-Break">production environment:</span></p>
			<ul>
				<li>Setting up <span class="No-Break">dark launches</span></li>
				<li>Employing <span class="No-Break">feature flags</span></li>
				<li><span class="No-Break">Automating deployment</span></li>
				<li>Infrastructure <span class="No-Break">as code</span></li>
				<li><span class="No-Break">Selective deployment</span></li>
				<li><span class="No-Break">Self-service deployment</span></li>
				<li><span class="No-Break">Version control</span></li>
				<li><span class="No-Break">Blue/green deployment</span></li>
			</ul>
			<p>We have looked at version control in previous chapters, notably <a href="B18756_11.xhtml#_idTextAnchor244"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, <em class="italic">Continuous Integration of Solution Development</em>. We have also discussed blue/green deployment in that <span class="No-Break">same chapter.</span></p>
			<p>Let’s examine the remaining practices and how they can increase deployment frequency while <span class="No-Break">reducing risk.</span></p>
			<h2 id="_idParaDest-271"><a id="_idTextAnchor271"/>Increasing deployment frequency</h2>
			<p>We saw in <a href="B18756_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Introducing SAFe® and DevOps</em>, the set of practices that allowed Flickr to <a id="_idIndexMarker867"/>announce at the Velocity conference that they were able to perform 10 deploys in a day. They accomplished this with the creation of scripts that would deploy upon passage of <span class="No-Break">all tests.</span></p>
			<p>Today’s automation and practices are an evolution of Flickr’s initial successes with automated <a id="_idIndexMarker868"/>deployment. To that end, we will examine which practices are in use today <span class="No-Break">and how.</span></p>
			<p>Let’s begin our exploration with a look at today’s <span class="No-Break">deployment automation.</span></p>
			<h3>Deployment automation</h3>
			<p>The scripting that <a id="_idIndexMarker869"/>allowed Flickr to automate their deployments reduced the time from code commit to deployment from days to hours. With the modern evolution of that scripting, the CI/CD pipeline further reduces the time of deployment from hours to minutes or even seconds. Let’s see how that <span class="No-Break">is done.</span></p>
			<p>In the overall Continuous Delivery Pipeline, we saw the introduction of automation during Continuous Integration. The automation allows for building, testing, merging, and packaging operations without manual intervention as much as possible, as shown in the <span class="No-Break">following diagram.</span></p>
			<div>
				<div id="_idContainer119" class="IMG---Figure">
					<img src="image/B18756_12_01.jpg" alt="Figure 12.1 – CI and CD ﻿automation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – CI and CD automation</p>
			<p>We continue the use of automation in Continuous Deployment as illustrated in the preceding diagram. In Continuous Deployment, we take the application packaged at the tail end of Continuous Integration and deploy it to the test environment. After system-level testing is performed on the test environment, the application package is then deployed to the production environment. Such automation may be done by tools that combine Continuous Integration and Continuous Deployment, such as Jenkins and pipelines from GitLab <a id="_idIndexMarker870"/>and Bitbucket. Continuous <a id="_idIndexMarker871"/>Deployment automation may be separate from Continuous Integration in tools such as ArgoCD. Several pieces in terms of technology and practices help enable effective automation in <span class="No-Break">Continuous Deployment.</span></p>
			<p>The first important piece is version control. We’ve seen the importance of version control for text-based artifacts as the trigger for the CI/CD pipeline and as a way of connecting all artifacts together for understanding everything involved in a particular deployment <span class="No-Break">or release.</span></p>
			<p>Artifact repositories can act as version control for large, binary-based artifacts that can’t be stored in text-based version control systems. They store intermediate builds, code libraries, virtual machine images, and Docker containers that may be created as part of a build process. If a component does not require a rebuild and test, its artifacts may be directly retrieved from the artifact repository, saving time <span class="No-Break">and effort.</span></p>
			<p>The size of changes is another factor that can also reduce the time automation takes to deploy to production. We’ve seen in <a href="B18756_04.xhtml#_idTextAnchor086"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Leveraging</em> <em class="italic">Lean Flow to Keep the Work Moving</em>, that batch size is an important factor in encouraging flow. A small independent change will go through much faster than a large change that may start a lot of rebuilding and testing in the <span class="No-Break">CI/CD pipeline.</span></p>
			<p>Automating as many steps as possible, including the push to deployment, will dramatically reduce <a id="_idIndexMarker872"/>the lead time for deployment. Allowing automation to proceed to further steps in building and testing throughout the Continuous Integration and Continuous Deployment stages keeps the momentum happening without delays because manual actions are needed to proceed to the next step. This may reduce the deployment time to seconds instead <span class="No-Break">of minutes.</span></p>
			<h3>Infrastructure as code</h3>
			<p>A key part of deployment automation is the creation and configuration of resources in production <a id="_idIndexMarker873"/>environments. <strong class="bold">Infrastructure as Code</strong> (<strong class="bold">IaC</strong>) allows us to define the desired infrastructure in terms of the resources and their configuration in terms of text-based descriptions. These configuration files are used by tools in conjunction with configuration management to create new resources, update resource configurations, or even tear them down if required. As mentioned in <a href="B18756_03.xhtml#_idTextAnchor066"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Automation for Efficiency and Quality</em>, popular IaC tools include Hashicorp’s Terraform and AWS CloudFormation for Amazon Web <span class="No-Break">Services environments.</span></p>
			<p>Version control plays a key part in establishing a smooth IaC process by ensuring that the evolution of configuration files is recorded and maintained. If a change to a product requires a change to the configuration in the production environment, the changes to the configuration file are created and tested in the staging environment. Tags in version control would serve to link together all artifacts associated with the change, from source code to tests to configuration file changes. </p>
			<p>This process of building and testing the configuration files is no different than developing the product <a id="_idIndexMarker874"/>or its tests. This helps ensure that the resulting resources created in the production environment are reliable and in sync with any <span class="No-Break">product changes.</span></p>
			<h3>Selective deployment</h3>
			<p>In some organizations, a <a id="_idIndexMarker875"/>production environment can be separated into multiple production environments. This separation can be based on some of the <span class="No-Break">following factors:</span></p>
			<ul>
				<li><span class="No-Break">Infrastructure/resources</span></li>
				<li><span class="No-Break">Geography</span></li>
				<li><span class="No-Break">Customer</span></li>
			</ul>
			<p>A selective deployment takes advantage of the separation by allowing deployment to happen at one instance of the production environment. An example of a selective deployment to an environment dedicated to a single customer is shown in the <span class="No-Break">following illustration.</span></p>
			<div>
				<div id="_idContainer120" class="IMG---Figure">
					<img src="image/B18756_12_02.jpg" alt="Figure 12.2 – Selective deployment to Customer A’s production environment"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – Selective deployment to Customer A’s production environment</p>
			<p>Our preceding example allows for testing to occur in a limited production capacity with Customer A, while other customers in other production environments do not see the change. Deployment in one of several environments allows for a flexible release strategy, such as a canary release where changes are released to specific regions or customers before releasing to the entire customer base. We will discuss canary releases in more detail in <a href="B18756_13.xhtml#_idTextAnchor292"><span class="No-Break"><em class="italic">Chapter 13</em></span></a>, <em class="italic">Releasing on Demand to </em><span class="No-Break"><em class="italic">Realize Value</em></span><span class="No-Break">.</span></p>
			<p>An example of <a id="_idIndexMarker876"/>real-world selective deployment happens at Facebook. As Facebook grew in popularity, the release engineering team kept up with the development activity by working on a <em class="italic">push from master</em> system that allowed for changes to be released more frequently. As detailed in <a href="https://engineering.fb.com/2017/08/31/web/rapid-release-at-massive-scale/">https://engineering.fb.com/2017/08/31/web/rapid-release-at-massive-scale/</a>, deployments started with 50% Facebook employees, then 0.1% of the Facebook production traffic, eventually rolling out to 10% of Facebook <span class="No-Break">production traffic.</span></p>
			<h3>Self-service deployment</h3>
			<p>There may be justifiable reasons that your organization cannot allow automation to deploy to your production environment. Generally, this is done to adhere to <span class="No-Break">compliance policies.</span></p>
			<p>If this is the case, self-service deployment (often called one-button deployment) allows anyone, usually <a id="_idIndexMarker877"/>developers, to deploy changes that have passed Continuous Integration <a id="_idIndexMarker878"/>into production. This method still uses automation to perform the actual deployment, so developers do not have unrestricted access to the <span class="No-Break">production environment.</span></p>
			<p>The deployment using automation is still recorded and audited so that the complete activities are tracked. This traceability of every automated deployment may give confidence to business compliance offices to allow a move to <span class="No-Break">automating deployment.</span></p>
			<h2 id="_idParaDest-272"><a id="_idTextAnchor272"/>Reducing risk </h2>
			<p>Jez Humble, in the book <em class="italic">Continuous Delivery: Reliable Software Releases through Build, Test, and Deployment Automation</em>, famously said the following about deployment: “<em class="italic">If it hurts, do it more frequently, and bring the pain forward</em>.” We have seen key <a id="_idIndexMarker879"/>methods for doing deployment more frequently. We will now look at practices that may help us deal with the pain <span class="No-Break">of deployments.</span></p>
			<p>The following practices allow us to mitigate the risk of introducing failures in the <span class="No-Break">production environment:</span></p>
			<ul>
				<li><span class="No-Break">Dark launches</span></li>
				<li><span class="No-Break">Feature flags</span></li>
				<li><span class="No-Break">Blue/green deployments</span></li>
				<li><span class="No-Break">Version control</span></li>
			</ul>
			<p>Blue/green <a id="_idIndexMarker880"/>deployments and version control were discussed in previous chapters. For this chapter, let’s focus our exploration on the <span class="No-Break">other mitigations.</span></p>
			<h3>Feature flags</h3>
			<p>Feature flags (or feature toggles) are the primary mechanism for implementing both dark launches and canary <a id="_idIndexMarker881"/>releases. By selecting the visibility of the feature in terms of whether the flag is enabled or disabled, you effectively separate the deployment of new features with the release of the feature where it is available to <span class="No-Break">all users.</span></p>
			<p>Feature flags also allow for quick rollbacks should problems arise in production. At the first sign of a problem, simply disable the <span class="No-Break">feature flag.</span></p>
			<p>When setting up feature flags, it is important to test the behavior of the feature flag at both positions: test the effects when the feature flag is enabled, and then when it is disabled. This testing should be done in the staging environment, well before it is deployed <span class="No-Break">to production.</span></p>
			<p>The presence of feature flags does add to the overall complexity of the solution by adding more permutations for testing behavior. Too many feature flags in play, especially obsolete feature flags for features long released, introduce more complexity in testing and technical debt. Obsolete feature flags should be removed at the <span class="No-Break">first opportunity.</span></p>
			<h3>Dark launches</h3>
			<p>Dark launches allow <a id="_idIndexMarker882"/>features in the production environment to be visible to only developers, testers, and generally beta or select customers and not to the entire customer pool of users. To allow for dark launches, organizations typically use feature flags to allow or disallow the visibility of the feature based on the group that <span class="No-Break">requires visibility.</span></p>
			<p>An example of a dark <a id="_idIndexMarker883"/>launch for developers and testers using feature flags is <a id="_idIndexMarker884"/>detailed in the <span class="No-Break">following illustration.</span></p>
			<div>
				<div id="_idContainer121" class="IMG---Figure">
					<img src="image/B18756_12_03.jpg" alt="Figure 12.3 – Example of a dark launch using feature flags"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3 – Example of a dark launch using feature flags</p>
			<p>In our preceding example, a new feature is visible to the developers and testers in the production environment. This visibility allows them to run experiments on this feature without affecting the customers, who do not see <span class="No-Break">the feature.</span></p>
			<p>Developers and testers can use dark launches in the <span class="No-Break">following ways:</span></p>
			<ul>
				<li>Testing new <span class="No-Break">application infrastructure</span></li>
				<li>Dynamically control which early customers can see <span class="No-Break">new features</span></li>
				<li>Experimentation of <span class="No-Break">new features</span></li>
			</ul>
			<p>Dark launches are often synonymous with canary releases. The primary difference between a dark launch and <a id="_idIndexMarker885"/>a canary release is that the feature flag allows visibility to a select group of customers to determine their reaction to the new feature in <span class="No-Break">canary releases.</span></p>
			<p>We now need to see that these changes do not adversely affect our current production environment, even if these deployed changes are not released. To do this, we need to test. Let’s examine our testing process <span class="No-Break">in production.</span></p>
			<h1 id="_idParaDest-273"><a id="_idTextAnchor273"/>Verifying proper operation</h1>
			<p>The changes to the product, in the form of new features, are now in the production environment, but this doesn’t mean that the work is over. In fact, it has only begun. We need to see that our features function as we expect. This is true from a functional perspective, but also from other perspectives relating <span class="No-Break">to NFRs.</span></p>
			<p>The following practices allow us to verify correct behavior in the <span class="No-Break">production environment:</span></p>
			<ul>
				<li><span class="No-Break">Production testing</span></li>
				<li>Test automation <span class="No-Break">in production</span></li>
				<li>Test <span class="No-Break">data management</span></li>
				<li><span class="No-Break">Testing NFRs</span></li>
			</ul>
			<p>Some of these practices were introduced in the previous chapter but now that we are looking at the production environment, we can examine them closely. Let’s look at all these practices and their application <span class="No-Break">to production.</span></p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor274"/>Production testing</h2>
			<p>With feature flags in <a id="_idIndexMarker886"/>place as part of a dark launch, testing can continue against the resources of the production environment. While testing in the production environment is no greater simulation of the conditions that the production environment has, the tester should still approach testing in the production <a id="_idIndexMarker887"/>environment with caution. Production testing offers the <span class="No-Break">following advantages:</span></p>
			<ul>
				<li>Allows for monitoring application performance in real-time, <span class="No-Break">realistic scenarios</span></li>
				<li>Monitoring application performance against <span class="No-Break">real-time traffic</span></li>
				<li>Further detection of bugs and <span class="No-Break">malicious attacks</span></li>
				<li>Helps maintain the quality of <span class="No-Break">the application</span></li>
			</ul>
			<p>The tests run in production really should be the ones near the top of the testing pyramid in combination with a subset of tests run in the previous stage of Continuous Integration as a sanity check. We <a id="_idIndexMarker888"/>are really looking to confirm that the behavior of the features we are about to release is what we expect. All other aspects of the testing pyramid should have been covered in the tests run in test environments and in the staging environment. Testing in production complements the earlier testing. It is not meant to substitute for <span class="No-Break">earlier testing.</span></p>
			<p>Successful testing in production requires a detailed understanding of the <span class="No-Break">following factors:</span></p>
			<ul>
				<li>Use real browsers and devices in the production environment. Emulators or simulators may have been used in testing environments, but they may not exhibit the same behavior as the “<span class="No-Break">real thing.”</span></li>
				<li>Allow real traffic of the production environment for the measuring of application performance under load. This is, after all, the traffic the application <span class="No-Break">will face.</span></li>
				<li>Use feature flags to allow for a small population of developers, testers, and beta customers to experience the new feature. Feature flags also allow for the quick disabling of features to everyone if <span class="No-Break">problems occur.</span></li>
				<li>While production testing is occurring, the monitoring of the production environment must be continuous. This allows for the rapid shutdown of any tests at the first sign of a problem. In addition, reversion of test operations may <span class="No-Break">be necessary.</span></li>
				<li>Use dedicated test user accounts so logging can determine what test transactions are versus <span class="No-Break">real transactions.</span></li>
			</ul>
			<p>A key test performed in production is an A/B test. In A/B testing, feature flags may direct beta customers to <a id="_idIndexMarker889"/>the new feature under test (option “A”) to gauge whether that new option has a change in behavior over the current application available to the rest of the user population (<span class="No-Break">option “B”).</span></p>
			<h2 id="_idParaDest-275"><a id="_idTextAnchor275"/>Test automation in production</h2>
			<p>Feature flag management is <a id="_idIndexMarker890"/>important when testing in <a id="_idIndexMarker891"/>production. Feature flags will not only determine whether a feature is visible, but also to whom that feature <span class="No-Break">is visible.</span></p>
			<p>A key use case of feature flag <a id="_idIndexMarker892"/>management occurs at Facebook. In the blog article at <a href="https://www.facebook.com/notes/10158791573022200">https://www.facebook.com/notes/10158791573022200</a>, an engineer at Meta, Facebook’s parent company, describes how they use Gatekeeper to establish A/B testing for every UI change with real Facebook users. Gatekeeper ensures that real users are subjected to the testing of a single UI element and that the A/B tests <span class="No-Break">don’t conflict.</span></p>
			<p>Because they are evaluating small changes, Facebook knows that some users may have a less than ideal user experience, but Facebook is striving for a better overall product. To that end, if enough users don’t use the UI element change, it is regarded as a failed test and never makes its way to the entire <span class="No-Break">Facebook population.</span></p>
			<h2 id="_idParaDest-276"><a id="_idTextAnchor276"/>Test data management</h2>
			<p>While A/B testing <a id="_idIndexMarker893"/>may work to determine whether a given feature will be used by the end users, other testing may have to occur in production to see whether the desired flow and messaging occur for <span class="No-Break">that feature.</span></p>
			<p>Synthetic transactions use automated testing scripts to verify the end-to-end performance of our application in production. The scripts simulate the actions a user would make to complete a transaction. The synthetic transactions, and their responses made by the <a id="_idIndexMarker894"/>application, are recorded by synthetic monitoring tools. Allowing synthetic monitoring and testing with synthetic transactions allow testers behind feature flags to verify the following characteristics of <span class="No-Break">the application:</span></p>
			<ul>
				<li><strong class="bold">Functionality</strong>: Is the application moving through the <span class="No-Break">correct pathways?</span></li>
				<li><strong class="bold">Availability</strong>: Is the <a id="_idIndexMarker895"/>performance of the application in the production <span class="No-Break">environment adequate?</span></li>
				<li><strong class="bold">Response time</strong>: This is another measure of the application’s performance in the <span class="No-Break">production environment.</span></li>
			</ul>
			<p>Synthetic monitoring allows <a id="_idIndexMarker896"/>you to understand the key flows of your application and how well they are performing. These may also provide important things to check with monitoring tools <span class="No-Break">when released.</span></p>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor277"/>Testing NFRs</h2>
			<p>Having the new <a id="_idIndexMarker897"/>features deployed into the production <a id="_idIndexMarker898"/>environment while visible to a select few through feature flags allows for the evaluation of key NFRs <span class="No-Break">before release.</span></p>
			<p>Synthetic transactions and monitoring allow for performance testing while in the production environment. The reception of a sample of the real traffic in the production environment allows for <span class="No-Break">vulnerability testing.</span></p>
			<p>Testing of NFRs in the production environment is one of the important last checks of a feature before release. This is an important step that cannot be missed. Synthetic transactions and feature flags can allow for low-risk testing of NFRs to ensure that the production environment <span class="No-Break">remains robust.</span></p>
			<p>As we examined performing tests in the production environment, we have discovered that a pivotal part of the verification is continuous monitoring. We will now discover what is needed for continuous monitoring <span class="No-Break">to occur.</span></p>
			<h1 id="_idParaDest-278"><a id="_idTextAnchor278"/>Monitoring the production environment</h1>
			<p>Monitoring the production environment allows us to understand whether the NFRs of the environment are <a id="_idIndexMarker899"/>still being maintained as well as whether new functionality deployed as features are functional and performing based on the constraints identified <span class="No-Break">in NFRs.</span></p>
			<p>There are a few practices that are instrumental in providing continuous monitoring. Let’s examine what <a id="_idIndexMarker900"/>these practices are and how to ensure that they are established in our <span class="No-Break">production environment.</span></p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor279"/>Full-stack telemetry</h2>
			<p>We need to monitor at <a id="_idIndexMarker901"/>various levels important measurements of our solution for a number of reasons. At the lower levels, we want to ensure that our production environment is stable and in no danger of failure. As we move to look at our system at higher levels, we want to ensure that we have measurements that allow us to determine whether our business hypothesis that started the development can be proven. Ultimately, at the business level, the measurements we take can gauge whether development is in line with our strategy or whether strategic alignments must <span class="No-Break">be made.</span></p>
			<p>These measurements taken for the range of levels we want are called full-stack telemetry. An example detailing the levels and sample measurements is in the <span class="No-Break">following table.</span></p>
			<table id="table001-8" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Level </strong><span class="No-Break"><strong class="bold">for Measurement</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Sample Measurements</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Business</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Value Stream KPIs (Cycle Time, Lead Time) and Solution KPIs (revenue, NPS, and <span class="No-Break">conversion rate).</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>IT Service <span class="No-Break">Management (ITSM)</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Service Level Objectives and other Service KPIs (Server uptime and <span class="No-Break">network availability).</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Product <span class="No-Break">or Solution</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Garbage Collection metrics, Response Time, Availability, and <span class="No-Break">Application logs.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Infrastructure</span></p>
						</td>
						<td class="No-Table-Style">
							<p>CPU Utilization, RAM Utilization, Networking metrics, and <span class="No-Break">Event logs.</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 12.1 – Sample measurements for levels of the solution</p>
			<p>The required measurements must be designed during the Continuous Exploration stage of the Continuous Delivery Pipeline to ensure they can be easily collected during Continuous <a id="_idIndexMarker902"/>Deployment and beyond. The planned measurements should include data for both business use for measuring the benefit hypothesis as well as technical data that can tell us the state of the system <span class="No-Break">in production.</span></p>
			<h2 id="_idParaDest-280"><a id="_idTextAnchor280"/>Visual displays</h2>
			<p>Mountains of data <a id="_idIndexMarker903"/>can be collected through full-stack telemetry. What makes the data useful is organizing the data so that users can tell the state of the environment at a glance as well as identify when action must be <span class="No-Break">taken quickly.</span></p>
			<p>Dashboards provide a key way of visualizing data collected. The visualization is beneficial for identifying trends or understanding whether an important metric has exceeded a threshold that may indicate a failure <span class="No-Break">in production.</span></p>
			<p>The following is an example dashboard. This is the public dashboard for the cloud version of Grafana, a product used to <span class="No-Break">create dashboards.</span></p>
			<p class="IMG---Figure"> </p>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="image/B18756_12_04.jpg" alt="Figure 12.4 – Example dashboard from grafana.org"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4 – Example dashboard from grafana.org</p>
			<p>As important as it is to have a dashboard, it is just as important that the dashboards are visible to everyone <a id="_idIndexMarker904"/>in the organization. Transparency allows everyone on the value stream to have all the necessary information without waiting for approvals or debating whether they’re <em class="italic">allowed</em> to see <span class="No-Break">individual measurements.</span></p>
			<h2 id="_idParaDest-281"><a id="_idTextAnchor281"/>Federated monitoring</h2>
			<p>Transparency in <a id="_idIndexMarker905"/>displaying data visualization may be difficult in complex organizations with many lines of business, business units, and other groups. To ensure information is not placed in silos, thought may be placed onto how to ensure the information is federated and easy to share and exchange. The following figure is an illustration of a dashboard that displays <span class="No-Break">federated information.</span></p>
			<div>
				<div id="_idContainer123" class="IMG---Figure">
					<img src="image/B18756_12_05.jpg" alt="Figure 12.5 – Example of a federated dashboard"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5 – Example of a federated dashboard</p>
			<p>In the preceding figure, the dashboard displays the measurements for the selected system (System B). Information for the other systems is available by selecting the appropriate system in <span class="No-Break">the control.</span></p>
			<p>Sharing information in a federated structure allows for more transparency while encouraging agility in individual business units. This data from other sources should be combined with the local business unit information, allowing for a more holistic view of the business unit’s <a id="_idIndexMarker906"/>system. Dashboards and other information display mechanisms can display the system data and allow ways to drill down and view the data and <span class="No-Break">its source.</span></p>
			<p>With the wide variety of data shared and visible on dashboards, organizations can continuously monitor their production environment. This can prepare them for production failures that may occur when releasing new features. Let’s examine the practices <a id="_idIndexMarker907"/>they can employ when a production <span class="No-Break">failure occurs.</span></p>
			<h1 id="_idParaDest-282"><a id="_idTextAnchor282"/>Responding and recovering when disaster strikes</h1>
			<p>The ability to recover quickly is a key feature of a DevOps approach. One of the key DORA metrics is <strong class="bold">Time to Restore Service</strong>, with elite functioning DevOps organizations <a id="_idIndexMarker908"/>able to do so in minutes. Preparing for recovery is a major part of the <span class="No-Break">CALMR approach.</span></p>
			<p>To facilitate recovery, we look at the <span class="No-Break">following practices:</span></p>
			<ul>
				<li><span class="No-Break">Proactive detection</span></li>
				<li><span class="No-Break">Cross-team collaboration</span></li>
				<li><span class="No-Break">Chaos engineering</span></li>
				<li><span class="No-Break">Session replay</span></li>
				<li>Rollback and <span class="No-Break">fix forward</span></li>
				<li><span class="No-Break">Immutable infrastructure</span></li>
			</ul>
			<p>A proactive response is important in production because this is the environment where the end users are. Problems here are visible and affect our customers. Problems not immediately handled can affect other work in other parts of the Continuous <span class="No-Break">Delivery Pipeline.</span></p>
			<p>Let’s examine the <a id="_idIndexMarker909"/>practices that allow us to be proactive in the <span class="No-Break">production environment.</span></p>
			<h2 id="_idParaDest-283"><a id="_idTextAnchor283"/>Proactive detection</h2>
			<p>Because we are <a id="_idIndexMarker910"/>using feature flags to separate deployment from release, we can proactively test and look for problems without disrupting customers, or worse, having our customers discover the problems. Feature flags enabled for testers allow them to examine new features in the <span class="No-Break">production environment.</span></p>
			<p>With this unique opportunity to have new features in the production environment without <a id="_idIndexMarker911"/>disturbing customer traffic, testers can perform additional testing, employ “what-if” scenarios, and eventually plan disaster recovery procedures involving the release of the <span class="No-Break">new feature.</span></p>
			<h2 id="_idParaDest-284"><a id="_idTextAnchor284"/>Cross-team collaboration</h2>
			<p>Problems that are visible to the customer and that have little information to start with may be a <a id="_idIndexMarker912"/>breeding ground for people to blame one another. The pressure increases on a very visible problem with feedback from angry customers. A solution may not be apparent early on. It is this type of stress that may test the idea of cross-team collaboration working, but it has shown itself the most effective way to solve <span class="No-Break">such problems.</span></p>
			<p>Having people from various disciplines in Development and Operations was one of the keys to the success at Flickr that we originally discussed in <a href="B18756_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Introducing SAFe® and DevOps</em>. This collaboration across the different groups is still key to <span class="No-Break">this day.</span></p>
			<p>To have true collaboration, we need to work toward the mission-based, psychologically-safe generative culture we identified in <a href="B18756_02.xhtml#_idTextAnchor040"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Culture of Shared Responsibility</em>. With the movement to that type of culture, collective ownership happens and teams work together across disciplines to identify the root cause of problems and find solutions quickly. The problems then become opportunities <span class="No-Break">for learning.</span></p>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor285"/>Chaos engineering</h2>
			<p>A worthwhile <a id="_idIndexMarker913"/>exercise that you can do proactively before releasing the feature is to perform a chaos engineering exercise, taking advantage of the feature flag so the effects are not seen by <span class="No-Break">active customers.</span></p>
			<p>The most famous example of chaos engineering is done by Netflix. As detailed in the blog article at <a href="https://netflixtechblog.com/the-netflix-simian-army-16e57fbab116">https://netflixtechblog.com/the-netflix-simian-army-16e57fbab116</a>, Netflix runs a set of tools they call the Simian Army to simulate production outages in the Amazon Web Services cloud. The most famous of these is Chaos Monkey, which simulates a virtual server going down. These experiments are run during the business day, with plenty of engineers watching and addressing <span class="No-Break">problems found.</span></p>
			<p>You can run an exercise that is similar to an execution of Chaos Monkey. Run the experiment to simulate an outage condition to see whether your new feature is resilient enough. At the end of the experiment, determine the next steps with <span class="No-Break">a debrief.</span></p>
			<p>The complete approach is detailed in <a href="B18756_06.xhtml#_idTextAnchor138"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Recovering</em><em class="italic"> </em><em class="italic">from Production Failures</em>. Chaos engineering <a id="_idIndexMarker914"/>exercises can be performed on existing features that have been already released if there is sufficient time available in the error budget. Exercises can be performed on unreleased features with robust feature <span class="No-Break">flag management.</span></p>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor286"/>Session replay</h2>
			<p>A useful tool for <a id="_idIndexMarker915"/>troubleshooting is session replay. Session replay is the ability to <a id="_idIndexMarker916"/>record individual users’ transactions and replay those transactions. The <a id="_idIndexMarker917"/>ability to perform session replay has the <span class="No-Break">following benefits:</span></p>
			<ul>
				<li>Developers can understand where users may have problems with the usability of a website and it gives insight on how users are really using a <span class="No-Break">given feature</span></li>
				<li>Developers can see the actions used to perform a fraudulent transaction on a website, which can lead to <span class="No-Break">closing vulnerabilities</span></li>
				<li>For a production failure, developers can see the exact sequence of actions that users perform to cause <span class="No-Break">the failure</span></li>
			</ul>
			<p>Session replay that is performed on the client side presents the action from the end user’s point of view. These <a id="_idIndexMarker918"/>tools allow developers to see the position of the cursor, what clicks are made, and what gets typed in a video-like replay session. Dynatrace and Datadog are examples of tools that offer <span class="No-Break">session replay.</span></p>
			<p>Server-side-based session replay captures all website traffic and includes input of what gets typed and what gets clicked. Scrolling and mouse movements are <span class="No-Break">not captured.</span></p>
			<p>When using session replay, attention must be given to the session data. Such data typically contains private information such as passwords and may require large amounts of <span class="No-Break">storage capability.</span></p>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor287"/>Rollback and fix forward</h2>
			<p>When production failures do occur, two quick methods to return to a stable environment include rollback and <span class="No-Break">fix forward.</span></p>
			<p>Rollback involves reverting <a id="_idIndexMarker919"/>the production to a <a id="_idIndexMarker920"/>previous iteration, one that doesn’t include the most recent change that probably caused the production failure. As we saw in <a href="B18756_06.xhtml#_idTextAnchor138"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Recovering from Production Failures</em>, two common methods of rolling back are blue/green deployments and feature flags. </p>
			<p>Blue/green deployment is an easy way to roll back a production environment to an idle environment <a id="_idIndexMarker921"/>and the formerly idle environment back to the active state. Attention must be paid to components that represent state, such as databases or volatile storage. Those components require careful reversion when the transition <span class="No-Break">back occurs.</span></p>
			<p>Feature flags are an easy <a id="_idIndexMarker922"/>way to remove the visibility of the new feature when its release causes a production failure. A toggle of a feature flag back to off does not require an extensive code or <span class="No-Break">configuration change.</span></p>
			<p>Fixing forward is another <a id="_idIndexMarker923"/>method for getting the <a id="_idIndexMarker924"/>production environment stable after a production failure. To fix forward, you develop and propagate the fix for the failure through the Continuous Delivery Pipeline so that it is deployed and released to production. When performing a fix forward, it is recommended that you use the standard deployment process through the Continuous Delivery Pipeline and not skip any testing. Bypassing testing to create a “quick fix” can lead to greater <span class="No-Break">technical debt.</span></p>
			<h2 id="_idParaDest-288"><a id="_idTextAnchor288"/>Immutable architecture</h2>
			<p>A primary <a id="_idIndexMarker925"/>reason for automating deployment to testing, staging, and ultimately the production environment is to make the architecture immutable. That is, any change in the environment cannot be <span class="No-Break">made manually.</span></p>
			<p>Any change in any environment must be made through the Continuous Delivery Pipeline and every artifact needed for that change must be recorded in version control. The close coupling with version control and the Continuous Delivery Pipeline prevents configuration drift or the difference in changes <span class="No-Break">between environments.</span></p>
			<h1 id="_idParaDest-289"><a id="_idTextAnchor289"/>Summary</h1>
			<p>In this chapter, we continued our exploration of the Continuous Delivery Pipeline into the production environment. Our feature after having finished design in Continuous Exploration and development and testing in Continuous Integration, now finds itself ready for deployment to production. Automation plays a key role here in executing the steps to bring the change into the production environment, possibly using IaC to create and configure new <span class="No-Break">production resources.</span></p>
			<p>Even with the new change in production, testing is performed to build confidence before release. Feature flags allow engineers and select beta customers to perform testing on new changes in production while concealed from the general user population. Test data in the form of synthetic transactions allow functional testing and testing of NFRs <span class="No-Break">to occur.</span></p>
			<p>Monitoring in the production environment allows us to see the success or failure of the testing in production. We want to ensure we are looking at the correct measurements from system resources all the way to those metrics that may serve as leading indicators that the changes we want are realizing our benefit hypothesis. We want this data visible on dashboards and transparent to everyone. If monitoring indicates problems in production, we are ready to act. The entire value stream works together to find the root cause. We can roll back to a previous version or fix the problem and propagate the fix using the Continuous Delivery Pipeline. </p>
			<p>Our change is now in the production environment. We now wait for the last event: releasing to our users so they can use it to their advantage. For this, we will examine the last stage of our Continuous Delivery Pipeline, release on demand, in our <span class="No-Break">next chapter.</span></p>
			<h1 id="_idParaDest-290"><a id="_idTextAnchor290"/>Questions</h1>
			<ol>
				<li>What helps reduce the lead time to deploy to production? (<span class="No-Break">pick 3)</span><ol><li><span class="No-Break">Unit testing</span></li><li>Small batches <span class="No-Break">of change</span></li><li><span class="No-Break">Version control</span></li><li><span class="No-Break">Behavior-driven development</span></li><li><span class="No-Break">Automating deployment</span></li></ol></li>
				<li>What practice allows you to perform <span class="No-Break">canary releases?</span><ol><li>Infrastructure <span class="No-Break">as code</span></li><li><span class="No-Break">Blue/green development</span></li><li><span class="No-Break">Selective deployment</span></li><li><span class="No-Break">Self-service deployment</span></li></ol></li>
				<li>Feature flags allow … (<span class="No-Break">pick 3)</span><ol><li>Testers to view unreleased features <span class="No-Break">in production</span></li><li>You to run unit <span class="No-Break">tests faster</span></li><li>Developers to start a deployment <span class="No-Break">to production</span></li><li>Rollback of a new feature in the event of a <span class="No-Break">production failure</span></li><li>A select group of customers to do <span class="No-Break">A/B testing</span></li><li>The execution of a <span class="No-Break">CI/CD pipeline</span></li></ol></li>
				<li>Running a synthetic transaction in production can help measure … (<span class="No-Break">pick 3)</span><ol><li><span class="No-Break">Cycle time</span></li><li><span class="No-Break">Functionality</span></li><li><span class="No-Break">Scalability</span></li><li><span class="No-Break">Availability</span></li><li><span class="No-Break">Response time</span></li></ol></li>
				<li>What levels of operation should full-stack <span class="No-Break">telemetry measure?</span><ol><li>IT <span class="No-Break">service management</span></li><li><span class="No-Break">Business</span></li><li><span class="No-Break">Solution</span></li><li><span class="No-Break">Infrastructure</span></li><li>All of <span class="No-Break">the above</span></li></ol></li>
				<li>What information can be played back in a server-side <span class="No-Break">session replay?</span><ol><li>Scrolling down the <span class="No-Break">web page</span></li><li>Input fields on a <span class="No-Break">web form</span></li><li>Moving the mouse cursor from left <span class="No-Break">to right</span></li><li>Horizontal scrolling to <span class="No-Break">a button</span></li></ol></li>
				<li>How are changes to production made in an <span class="No-Break">immutable architecture?</span><ol><li>The administrator changes a file in the <span class="No-Break">production environment.</span></li><li>The administrator changes a configuration file and executes the IaC tool to create <span class="No-Break">the change.</span></li><li>The administrator changes a configuration file, submits the change into version control, and executes the CI/CD pipeline. </li><li>The administrator restarts the <span class="No-Break">production server.</span></li></ol></li>
				<li>Name two practices that help enable <span class="No-Break">immutable architecture.</span><ol><li><span class="No-Break">Feature flags</span></li><li><span class="No-Break">Version control</span></li><li><span class="No-Break">CI/CD pipeline</span></li><li><span class="No-Break">Blue/green deployment</span></li><li><span class="No-Break">Behavior-driven development</span></li></ol></li>
			</ol>
			<h1 id="_idParaDest-291"><a id="_idTextAnchor291"/>Further reading</h1>
			<ul>
				<li>A summary from Scaled Agile feature guidance on Continuous Deployment in the Continuous Delivery <span class="No-Break">Pipeline: </span><a href="https://www.scaledagileframework.com/continuous-deployment/&#13;"><span class="No-Break">https://www.scaledagileframework.com/continuous-deployment/</span></a></li>
				<li>A look from a Meta (Facebook’s parent company) engineer describing how Facebook performs testing, deployment, and release: <a href="https://engineering.fb.com/2017/08/31/web/rapid-release-at-massive-scale/">https://engineering.fb.com/2017/08/31/web/rapid-release-at-massive-scale/</a> </li>
				<li><em class="italic">Continuous Delivery: Reliable Software Releases through Build, Test, and Deployment Automation</em> by Jez Humble and David Farley – The authoritative guide on creating a CI/CD pipeline and detailing integration, deployment, <span class="No-Break">and release.</span></li>
				<li>A blog article from LaunchDarkly, a vendor for feature flag management, describing the uses and benefits of feature <span class="No-Break">flags: </span><a href="https://launchdarkly.com/blog/guide-to-dark-launching/"><span class="No-Break">https://launchdarkly.com/blog/guide-to-dark-launching/</span></a></li>
				<li>An article describing the advantages of performing testing in <span class="No-Break">production: </span><a href="https://www.softwaretestingmaterial.com/testing-in-production/"><span class="No-Break">https://www.softwaretestingmaterial.com/testing-in-production/</span></a></li>
				<li>A detailed blog article describing the uses and advantages of testing in <span class="No-Break">production: </span><a href="https://www.tothenew.com/blog/testing-in-production-environment-what-why-and-how/"><span class="No-Break">https://www.tothenew.com/blog/testing-in-production-environment-what-why-and-how/</span></a></li>
				<li>An article describing how testing is done in production at Facebook using Gatekeeper to monitor the user tests in <span class="No-Break">production: </span><a href="https://www.facebook.com/notes/10158791573022200/"><span class="No-Break">https://www.facebook.com/notes/10158791573022200/</span></a></li>
				<li>A blog article describing the use of synthetic transactions in testing new <span class="No-Break">features: </span><a href="https://www.netreo.com/blog/synthetic-transactions/"><span class="No-Break">https://www.netreo.com/blog/synthetic-transactions/</span></a></li>
				<li>A blog article from Netflix engineers describing how they perform chaos engineering with the set of tools they call “the Simian <span class="No-Break">Army”: </span><a href="https://netflixtechblog.com/the-netflix-simian-army-16e57fbab116"><span class="No-Break">https://netflixtechblog.com/the-netflix-simian-army-16e57fbab116</span></a></li>
			</ul>
		</div>
	</body></html>