<html><head></head><body>
		<div id="_idContainer274">
			<h1 id="_idParaDest-394"><em class="italic"><a id="_idTextAnchor398"/>Chapter 21</em>: Migrating to GitHub</h1>
			<p>If you are not a start-up, then you always have existing tools and processes that must be considered when moving to a new platform. In this chapter, we will discuss different strategies related to migrating to GitHub from different platforms.</p>
			<p>In this chapter, we will cover the following:</p>
			<ul>
				<li>Picking the right migration strategy</li>
				<li>Achieving compliance with low-fidelity migrations</li>
				<li>Synchronizing requirements for a smooth transition</li>
				<li>Migrating from Azure DevOps with the GitHub Enterprise Importer</li>
				<li>Migrating pipelines using Valet</li>
			</ul>
			<h1 id="_idParaDest-395"><a id="_idTextAnchor399"/>Picking the right migration strategy</h1>
			<p>When migrating to <a id="_idIndexMarker1324"/>a new platform, you have different options:</p>
			<ul>
				<li><strong class="bold">High-fidelity migration</strong>: You try to migrate as much as possible to the new platform.</li>
				<li><strong class="bold">Clean cut-over migration</strong>: You only migrate the bare minimum that is necessary to start working on the new platform.</li>
			</ul>
			<p><strong class="bold">High-fidelity migrations</strong> to complex platforms have different problems. The main problem is that <a id="_idIndexMarker1325"/>there is not a 1-to-1 mapping of all entities <a id="_idIndexMarker1326"/>and that things just work differently on different platforms. By migrating everything over, you influence the way people use the new system. The data is optimized for the old system using old processes. Also, the time, costs, and complexity involved in a high-fidelity migration are not linear. The more you try to get to 100% fidelity, the more complex and expensive it gets, and 100% is normally not achievable at all (see <em class="italic">Figure 21.1</em>).</p>
			<div>
				<div id="_idContainer272" class="IMG---Figure">
					<img src="image/B17827_21_001.jpg" alt="Figure 21.1 – Complexity, time, and costs for different levels of fidelity&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 21.1 – Complexity, time, and costs for different levels of fidelity</p>
			<p><strong class="bold">Clean cut-over migrations</strong> are optimal if you want to achieve a change in behavior and use the <a id="_idIndexMarker1327"/>new platform optimally. In the case <a id="_idIndexMarker1328"/>study in this book, I assume a clean cut-over migration: the teams start on the new platform and only move over what is absolutely necessary.</p>
			<p>The reality is somewhere in between these two extremes. If you want to accelerate software delivery, you start with a clean cut-over migration, but to scale in your enterprise and drive adoption, you provide some migration paths and tooling for the teams to move over fast. And there will be some dormant projects/products that you may want to archive for later reactivation. Keep all the old systems running or just migrate them over.</p>
			<h1 id="_idParaDest-396"><a id="_idTextAnchor400"/>Achieving compliance with low-fidelity migrations</h1>
			<p>One concern that many customers have is <strong class="bold">end-to-end traceability</strong> for <strong class="bold">compliance</strong> reasons. In many <a id="_idIndexMarker1329"/>highly-regulated industries, you have to provide end-to-end <a id="_idIndexMarker1330"/>traceability <a id="_idIndexMarker1331"/>for all requirements and final functional tests. The problem with low-fidelity migration is that you will get a cut in that traceability chain.</p>
			<p>But that does not mean that the only solution is high-fidelity migration. You can still do a clean cut-over <a id="_idIndexMarker1332"/>and keep the old systems in <a id="_idIndexMarker1333"/>read-only mode running for as long as necessary. In the new system, you must achieve end-to-end traceability anyway. To stay compliant, you need a mapping of the old system identifiers to the new system for the requirements that span both systems.</p>
			<p>In the case of an audit, you can provide reports from both systems – both the old and the new. For some requirements, you might have to look at both reports, but that will still provide valid traceability if you have identifiers that allow mapping between the systems.</p>
			<p>The inconvenience of keeping the old system running is normally far less than trying to perform a high-fidelity migration, but this depends on many things, such as the licenses of the old system.</p>
			<h1 id="_idParaDest-397"><a id="_idTextAnchor401"/>Synchronizing requirements for a smooth transition</h1>
			<p>One option that is interesting in this context, especially for big enterprises with many different tools, is the <a id="_idIndexMarker1334"/>synchronization of requirements across different <a id="_idIndexMarker1335"/>platforms with a product like <strong class="bold">Tasktop</strong> (https://www.tasktop.com/). Tasktop has connectors to many products like Jira, Salesforce, ServiceNow, IBM Rational, IBM DOORS, Polarion ALM, Azure DevOps, and many more. Synchronizing requirements and work items between tools enables multiple use cases:</p>
			<ul>
				<li>Work in both tools – the old and the new – at the same time during a migration period. This gives you more time for the migration and allows you to move over one team after the other while maintaining full traceability.</li>
				<li>Give different roles and teams the freedom to work using the tools they prefer. Your project managers prefer Jira, the architects IBM Rational, operations ServiceNow, and your developers want to switch to GitHub? You can enable these kinds of workflows by synching data between these tools.</li>
			</ul>
			<p>Especially in complex environments where you have a large product that multiple teams work on <a id="_idIndexMarker1336"/>simultaneously, synchronizing requirements and work items can help you to optimize migration.</p>
			<h1 id="_idParaDest-398"><a id="_idTextAnchor402"/>Migrating your code</h1>
			<p>The easiest thing <a id="_idIndexMarker1337"/>to do when moving to GitHub is migrating <a id="_idIndexMarker1338"/>your code, especially when the code is already stored in another Git repository. Just clone the repository using <strong class="source-inline">--bare</strong> to make sure the repository is in a clean state:</p>
			<pre class="source-code">$ git clone --bare &lt;URL to old system&gt;</pre>
			<p>Then push the code to the repository:</p>
			<pre class="source-code">$ git push --mirror &lt;URL to new repository&gt;</pre>
			<p>If the repository already contains code, you must add the <strong class="source-inline">--force</strong> parameter to override. You can also use the GitHub CLI to create a repository on the fly when pushing an existing one:</p>
			<pre class="source-code">$ gh repo create &lt;NAME&gt; --private --source &lt;local path&gt;</pre>
			<p>Since in Git the author information is matched using an email address, you just have to create user accounts in GitHub for all users and assign them the email address used in your previous Git system. The authors will then be resolved correctly.</p>
			<p>You can also <a id="_idIndexMarker1339"/>import code <a id="_idIndexMarker1340"/>using the <strong class="bold">GitHub Importer</strong>. Besides Git, the <a id="_idIndexMarker1341"/>following repository <a id="_idIndexMarker1342"/>types are supported:</p>
			<ul>
				<li><strong class="bold">Subversion</strong></li>
				<li><strong class="bold">Mercurial</strong></li>
				<li><strong class="bold">Team Foundation Version Control</strong> (<strong class="bold">TFVC</strong>)</li>
			</ul>
			<p>The GitHub Importer takes the URL to the source system and creates a new repository. Files larger than 100 MB can <a id="_idIndexMarker1343"/>be excluded or added to the Git <strong class="bold">Large File Storage</strong> (<strong class="bold">LFS</strong>).</p>
			<p>To import a repository using the GitHub Importer, click the plus next to your profile picture and select <strong class="bold">Import repository</strong> (see <em class="italic">Figure 21.2</em>):</p>
			<div>
				<div id="_idContainer273" class="IMG---Figure">
					<img src="image/B17827_21_002.jpg" alt="Figure 21.2 – Importing a repository&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 21.2 – Importing a repository</p>
			<p>If you migrate from <strong class="bold">Subversion</strong>, you can use <strong class="bold">git-svn</strong> (<a href="https://git-scm.com/docs/git-svn">https://git-scm.com/docs/git-svn</a>) to sync your <a id="_idIndexMarker1344"/>changes between <a id="_idIndexMarker1345"/>a Git and <a id="_idIndexMarker1346"/>a Subversion repository:</p>
			<pre class="source-code">$ git svn &lt;command&gt;</pre>
			<p>If you migrate from <strong class="bold">Azure DevOps</strong>/<strong class="bold">Team Foundation Server</strong>, the best way is to migrate to Git from <strong class="bold">TFVC</strong> first, and then migrate to <a id="_idIndexMarker1347"/>GitHub. There is also a tool <a id="_idIndexMarker1348"/>similar to git-svn: <strong class="bold">git-tfs</strong> (<a href="https://github.com/git-tfs/git-tfs">https://github.com/git-tfs/git-tfs</a>). This allows you also to sync changes <a id="_idIndexMarker1349"/>between Git and TFVC or directly migrate <a id="_idIndexMarker1350"/>to GitHub:</p>
			<pre class="source-code">$ git tfs &lt;command&gt;</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">Git is optimized for short-lived branches – TFVC isn’t. You should not just migrate your code and all branches over. Use the chance for a clean cut-over and start with a new branching model. Migrating code to Git can be a first step to keeping parts of your history, but you should adjust your branching model after the migration.</p>
			<p>Migrating your code to GitHub is not the challenge. There are many tools that can help you. The challenge is to get from an older branching model to a new one that is optimized for your new platform <a id="_idIndexMarker1351"/>and offers accelerated software <a id="_idIndexMarker1352"/>delivery performance (see <a href="B17827_11_Epub.xhtml#_idTextAnchor249"><em class="italic">Chapter 11</em></a>, <em class="italic">Trunk-Based Development</em>).</p>
			<p>The challenge lies in the things that are not directly stored in Git: pull requests, linked work items, and pipelines. These need more attention than just the Git repository itself.</p>
			<h1 id="_idParaDest-399"><a id="_idTextAnchor403"/>Migrating from Azure DevOps or GitHub</h1>
			<p>If you migrate <a id="_idIndexMarker1353"/>from GitHub to <a id="_idIndexMarker1354"/>GitHub or from <a id="_idIndexMarker1355"/>Azure DevOps to GitHub, you <a id="_idIndexMarker1356"/>can use the <strong class="bold">GitHub Enterprise Importer</strong> (<strong class="bold">GEI</strong>) (see https://github.com/github/gh-gei). It is an extension for the GitHub CLI and can be installed using <strong class="source-inline">extension install</strong>:</p>
			<pre class="source-code">$ gh extension install github/gh-gei</pre>
			<pre class="source-code">$ gh gei --help</pre>
			<p>You can set the <strong class="bold">Personal Access Tokens</strong> (<strong class="bold">PAT</strong>) as environment variables to authenticate <a id="_idIndexMarker1357"/>to the source and target system:</p>
			<pre class="source-code">$ export ADO_PAT=<strong class="bold">&lt;personal access token&gt;</strong></pre>
			<pre class="source-code">$ export GH_SOURCE_PAT=<strong class="bold">&lt;personal access token&gt;</strong></pre>
			<pre class="source-code">$ export GH_PAT=<strong class="bold">&lt;personal access token&gt;</strong></pre>
			<p>You could also pass them to <strong class="source-inline">generate-script</strong> using <strong class="source-inline">--github-source-pat</strong> and <strong class="source-inline">--ado-pat</strong> parameters.</p>
			<p>To create the migration script, execute one of the following commands depending on whether you want to migrate from GitHub or Azure DevOps:</p>
			<pre class="source-code">$ gh gei generate-script --ado-source-org &lt;source&gt; --github-target-org &lt;target&gt;</pre>
			<pre class="source-code">$ gh gei generate-script --github-source-org &lt;source&gt; --github-target-org &lt;target&gt;</pre>
			<p>This will generate a PowerShell script <strong class="source-inline">migrate.ps1</strong> that can be used for the actual migration. The script will call <strong class="source-inline">gh gei migrate-repo</strong> for all team projects found in Azure DevOps <a id="_idIndexMarker1358"/>or GitHub organization. This will queue the actual <a id="_idIndexMarker1359"/>migration. It then gets the status by executing <strong class="source-inline">gh gei wait-for-migration --migration-id</strong> with the output of the previous command.</p>
			<p>GEI currently supports the following:</p>
			<ul>
				<li><strong class="bold">Azure DevOps</strong> (<strong class="bold">ADO</strong>)</li>
				<li><strong class="bold">GitHub Enterprise Server</strong> (<strong class="bold">GHES</strong>) 3.4.1+</li>
				<li>GitHub Enterprise Cloud</li>
			</ul>
			<p>For Azure DevOps, the following items will be migrated:</p>
			<ul>
				<li>Git source</li>
				<li>Pull requests</li>
				<li>User history for pull requests</li>
				<li>Work item links on pull requests</li>
				<li>Attachments on pull requests</li>
				<li>Branch protections for the repository</li>
			</ul>
			<p>For GitHub Enterprise Server and Cloud, the following items are migrated additionally:</p>
			<ul>
				<li>Issues</li>
				<li>Milestones</li>
				<li>Wikis</li>
				<li>Project boards at the repository level</li>
				<li>GitHub Actions workflows (secrets and workflow run history not included)</li>
				<li>Commit comments</li>
				<li>Active webhooks</li>
				<li>Repository settings</li>
				<li>Branch protections</li>
				<li>GitHub Pages settings</li>
				<li>User history for the above data</li>
			</ul>
			<p>See <a href="https://docs.github.com/en/early-access/github/migrating-with-github-enterprise-importer">https://docs.github.com/en/early-access/github/migrating-with-github-enterprise-importer</a> for more information. Note that GEI is still in beta and might change <a id="_idIndexMarker1360"/>frequently.</p>
			<p>If you are using <a id="_idIndexMarker1361"/>GitHub Enterprise Server, you can also <a id="_idIndexMarker1362"/>use <strong class="source-inline">ghe-migrator</strong> to import data, either <a id="_idIndexMarker1363"/>from another server instance, or from GitHub Enterprise Cloud. See <a href="mailto:https://docs.github.com/en/enterprise-server@3.4/admin/user-management/migrating-data-to-and-from-your-enterprise/about-migrations">https://docs.github.com/en/enterprise-server@3.4/admin/user-management/migrating-data-to-and-from-your-enterprise/about-migrations</a> for more information on data export and import on GitHub Enterprise Server.</p>
			<h1 id="_idParaDest-400"><a id="_idTextAnchor404"/>Migrating your pipelines</h1>
			<p>To migrate your <a id="_idIndexMarker1364"/>pipelines to GitHub Actions, you <a id="_idIndexMarker1365"/>can use a tool called <strong class="bold">Valet</strong>. It supports the <a id="_idIndexMarker1366"/>following sources:</p>
			<ul>
				<li>Azure DevOps (Classic pipelines, YAML pipelines, and releases)</li>
				<li>Jenkins</li>
				<li>Travis CI</li>
				<li>Circle CI</li>
				<li>GitLab CI</li>
			</ul>
			<p>Valet is a Ruby-based command-line tool that gets installed using Docker.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Valet is still in private beta at the time of writing and is still subject to change. Valet is not intended to be a <a id="_idIndexMarker1367"/>100% effective solution that can migrate everything! It is extensible and you will have to write your own transformers and probably still need to do some manual steps after the migration.</p>
			<p>The distribution of Valet happens by pulling down a container image and using the two scripts <strong class="source-inline">valet</strong> and <strong class="source-inline">valet-update</strong> to interact with it:</p>
			<pre class="source-code">$ docker pull ghcr.io/valet-customers/valet-cli</pre>
			<p>You have to authenticate to <strong class="source-inline">ghcr.io</strong> once you have access to the private beta using your username and a PAT token with <strong class="source-inline">read:packages</strong> access:</p>
			<pre class="source-code">$ docker login ghcr.io -u <strong class="bold">&lt;USERNAME&gt;</strong></pre>
			<p>The best way is to <a id="_idIndexMarker1368"/>install Valet as a GitHub CLI extension, but <a id="_idIndexMarker1369"/>you still need Docker running on your machine and you have to be authenticated to the registry. To install Valet as a GitHub CLI extension, execute the following command:</p>
			<pre class="source-code">$ gh extension install github/gh-valet</pre>
			<p>You can now easily update Valet using <strong class="source-inline">gh valet update</strong>.</p>
			<p>Valet is configured using environment variables. The easiest way to do this is to set these in a file called <strong class="source-inline">.env.local</strong> in the folder that you are using Valet in. This, for example, is the configuration for migrating pipelines from Azure to GitHub Enterprise Cloud:</p>
			<pre class="source-code">GITHUB_ACCESS_TOKEN=<strong class="bold">&lt;GitHub PAT&gt;</strong></pre>
			<pre class="source-code">GITHUB_INSTANCE_URL=https://github.com</pre>
			<pre class="source-code">AZURE_DEVOPS_PROJECT=<strong class="bold">&lt;project name&gt;</strong></pre>
			<pre class="source-code">AZURE_DEVOPS_ORGANIZATION=<strong class="bold">&lt;org name&gt;</strong></pre>
			<pre class="source-code">AZURE_DEVOPS_INSTANCE_URL=https://dev.azure.com/<strong class="bold">&lt;org&gt;</strong></pre>
			<p>Valet has <a id="_idIndexMarker1370"/>three modes:</p>
			<ul>
				<li><strong class="source-inline">gh valet audit</strong> will analyze the source download information about all pipelines supported. It will create an audit summary report (Markdown) with all the pipelines, build steps, and environments found. You can use an audit to plan your migrations.</li>
				<li><strong class="source-inline">gh valet dry-run</strong> will convert the pipelines to a GitHub Actions workflow file and output the YAML file.</li>
				<li><strong class="source-inline">gh valet migrate</strong> will convert the pipeline to a GitHub Actions workflow file and create a pull request <a id="_idIndexMarker1371"/>in the target GitHub repository containing the changes to the workflow file.</li>
				<li><strong class="source-inline">gh valet forecast</strong> forecasts the usage of GitHub Actions based on historical pipeline utilization.</li>
			</ul>
			<p>To run an audit using the previous configuration and create a report, just run the following command:</p>
			<pre class="source-code">$ gh valet audit azure-devops --output-dir .</pre>
			<p>This will generate an <strong class="source-inline">audit_summary.md</strong> report and three files for every supported pipeline: a <strong class="source-inline">.config.json</strong> file containing the configuration, a <strong class="source-inline">.source.yml</strong> file containing the <a id="_idIndexMarker1372"/>source pipeline converted to YAML, and a <strong class="source-inline">.yml</strong> file <a id="_idIndexMarker1373"/>containing the transformed GitHub Actions workflow that will later be migrated. To execute the migration for one pipeline, run <strong class="source-inline">valet migrate</strong>:</p>
			<pre class="source-code">$ valet migrate azure-devops pipeline \</pre>
			<pre class="source-code">  --target-url https://github.com/<strong class="bold">&lt;org&gt;</strong>/<strong class="bold">&lt;repo-name&gt;</strong> \</pre>
			<pre class="source-code">  --pipeline-id <strong class="bold">&lt;definition-id&gt;</strong></pre>
			<p>Remember that this is a best-effort migration! Not everything can be migrated. For example, the following elements cannot be migrated:</p>
			<ul>
				<li>Secrets</li>
				<li>Service connections</li>
				<li>Unknown tasks</li>
				<li>Self-hosted runners</li>
				<li>Variables from Key Vault</li>
			</ul>
			<p>You can write your own transformers for pipeline steps, either for unknown steps or to override existing behavior from Valet. Create a new Ruby file (<strong class="source-inline">.rb</strong>) and add a function in the following format:</p>
			<pre class="source-code">transform "<strong class="bold">taskname</strong>" do |item|</pre>
			<pre class="source-code">end</pre>
			<p>For Azure DevOps tasks, the name includes the version number. To see what the item object contains, you can output it to the console using <strong class="source-inline">puts item</strong>.</p>
			<p>Here is a sample <a id="_idIndexMarker1374"/>transformer that would override <a id="_idIndexMarker1375"/>the <strong class="source-inline">DotNetCoreCLI</strong> task version 2 and replace it with a run step on Bash that uses the <strong class="source-inline">globstar</strong> syntax to iterate all <strong class="source-inline">.csproj</strong> files and execute the command using the arguments from the source pipeline:</p>
			<pre class="source-code">transform "DotNetCoreCLI@2" do |item|</pre>
			<pre class="source-code">  if(item["command"].nil?)</pre>
			<pre class="source-code">    item["command"] = "build"</pre>
			<pre class="source-code">  end</pre>
			<pre class="source-code">  {</pre>
			<pre class="source-code">    shell: "bash",</pre>
			<pre class="source-code">    run: "shopt -s globstar; for f in ./**/*.csproj; do dotnet #{ item['command']} $f #{item['arguments'] } ; done"</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">end</pre>
			<p>To use your custom transformers, you can use the <strong class="source-inline">--custom-transformers</strong> parameter. You can specify individual transformers or entire directories if you have many transformers:</p>
			<pre class="source-code">$ valet migrate azure-devops pipeline \</pre>
			<pre class="source-code">  --target-url https://github.com/<strong class="bold">&lt;org&gt;</strong>/<strong class="bold">&lt;repo-name&gt;</strong> \</pre>
			<pre class="source-code">  --pipeline-id <strong class="bold">&lt;definition-id&gt; \</strong></pre>
			<pre class="source-code">  --custom-transformers <strong class="bold">plugin/*</strong></pre>
			<p>Each workflow <a id="_idIndexMarker1376"/>system is different! Make sure to spend time <a id="_idIndexMarker1377"/>analyzing how you want your pipelines to be transformed to optimize for the new platform instead of just trying to migrate everything over. If you’ve figured that out, then Valet will be a great tool that can help you to transition your teams faster to GitHub.</p>
			<h1 id="_idParaDest-401"><a id="_idTextAnchor405"/>Summary</h1>
			<p>GitHub is a complex, fast-growing ecosystem that is challenging for any kind of migration. When migrating, make sure to focus on optimizing for productivity on the new platform rather than on migrating everything over and then letting your teams deal with the mess. Depending on the size of your organization and the source platforms, your migration story might look completely different.</p>
			<p>In this chapter, you’ve learned about the different tools from GitHub and partners that can help you facilitate your migration.</p>
			<p>In the next chapter, we’ll talk about organizing your teams and repositories for optimal collaboration.</p>
			<h1 id="_idParaDest-402"><a id="_idTextAnchor406"/>Further reading</h1>
			<p>These are the links from this chapter that you can use to get more information on the topics discussed:</p>
			<ul>
				<li><em class="italic">GitHub Importer</em>: <a href="https://docs.github.com/en/get-started/importing-your-projects-to-github/importing-source-code-to-github/importing-a-repository-with-github-importer">https://docs.github.com/en/get-started/importing-your-projects-to-github/importing-source-code-to-github/importing-a-repository-with-github-importer</a></li>
				<li><em class="italic">GitHub Enterprise Importer </em><em class="italic">CLI</em>: <a href="https://github.com/github/gh-gei">https://github.com/github/gh-gei</a> and https://docs.github.com/en/early-access/github/migrating-with-github-enterprise-importer</li>
				<li><em class="italic">GitHub Enterprise Server Importer:</em> <a href="mailto:https://docs.github.com/en/enterprise-server@3.4/admin/user-management/migrating-data-to-and-from-your-enterprise/about-migrations">https://docs.github.com/en/enterprise-server@3.4/admin/user-management/migrating-data-to-and-from-your-enterprise/about-migrations</a></li>
				<li><em class="italic">ghe-migrator</em>: https://docs.github.com/en/enterprise-server@3.4/admin/user-management/migrating-data-to-and-from-your-enterprise/about-migrations</li>
				<li><em class="italic">Tasktop</em>: https://www.tasktop.com/</li>
				<li><em class="italic">git-svn</em>: <a href="https://git-scm.com/docs/git-svn">https://git-scm.com/docs/git-svn</a></li>
				<li><em class="italic">git-tfs</em>: <a href="https://github.com/git-tfs/git-tfs">https://github.com/git-tfs/git-tfs</a></li>
			</ul>
		</div>
	</body></html>