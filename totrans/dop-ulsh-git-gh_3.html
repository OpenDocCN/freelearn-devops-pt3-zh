<html><head></head><body>
<div id="_idContainer067">
<h1 class="chapter-number" id="_idParaDest-52"><a id="_idTextAnchor053"/><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-53"><a id="_idTextAnchor054"/><span class="koboSpan" id="kobo.2.1">Advanced Git Usage for Team Collaboration</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Now, we move on to the aspect of actual collaboration. </span><span class="koboSpan" id="kobo.3.2">In this chapter, we will delve into various collaboration practices that you will want to adopt. </span><span class="koboSpan" id="kobo.3.3">You will learn how to organize your commit history, manage complex branches, and resolve conflicts during merges. </span><span class="koboSpan" id="kobo.3.4">The goal of this chapter is to help you become wonderfully in control of this branch flow </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">team collaboration.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Here, the focus is not just on getting the job done but also on doing it in a way that enhances teamwork. </span><span class="koboSpan" id="kobo.5.2">Recognize that there is a thoughtful strategy behind managing an entire code base to maximize the teams’ productivity and impact. </span><span class="koboSpan" id="kobo.5.3">Different strategies are employed based on the type of products or projects, the team size, and its maturity. </span><span class="koboSpan" id="kobo.5.4">Before we plunge into the Git commands, it is crucial to comprehend this underlying </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">strategy—branching strategies.</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">So, let’s get started on making your collaboration seamless </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">and efficient.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">We will cover the following topics in </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">this chapter:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">Branching strategy for </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">team collaboration</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Ways to apply your changes on </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">a branch</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.15.1">Navigating conflicts</span></span></li>
<li><span class="koboSpan" id="kobo.16.1">Mastering </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">better collaboration</span></span></li>
</ul>
<h1 id="_idParaDest-54"><a id="_idTextAnchor055"/><span class="koboSpan" id="kobo.18.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.19.1">Configuration instructions for proceeding with this section can be found in the following GitHub repository link. </span><span class="koboSpan" id="kobo.19.2">Please make sure Git and SSH tools are installed. </span><span class="koboSpan" id="kobo.19.3">For Windows users, it is recommended to use PowerShell. </span><span class="koboSpan" id="kobo.19.4">I also encourage you to get the most up-to-date information written about the different commands </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">and environments.</span></span></p>
<p><a href="https://github.com/PacktPublishing/DevOps-Unleashed-with-Git-and-GitHub"><span class="No-Break"><span class="koboSpan" id="kobo.21.1">https://github.com/PacktPublishing/DevOps-Unleashed-with-Git-and-GitHub</span></span></a></p>
<h1 id="_idParaDest-55"><a id="_idTextAnchor056"/><span class="koboSpan" id="kobo.22.1">Branching strategies for team collaboration</span></h1>
<p><span class="koboSpan" id="kobo.23.1">In the realm of team collaboration, commits act as the essential building blocks. </span><span class="koboSpan" id="kobo.23.2">These commits link together to form a chronological history, a record of your project’s evolution. </span><span class="koboSpan" id="kobo.23.3">This history is organized and maintained </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">through branches.</span></span></p>
<p><span class="koboSpan" id="kobo.25.1">So, how can engineers and teams knit this history into a cohesive meaningful narrative? </span><span class="koboSpan" id="kobo.25.2">The branching strategy is the answer to this question. </span><span class="koboSpan" id="kobo.25.3">The branching strategy is a development strategy for effectively managing branches in Git to enable smooth collaboration and </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">service delivery.</span></span></p>
<h2 id="_idParaDest-56"><a id="_idTextAnchor057"/><span class="koboSpan" id="kobo.27.1">Why a branching strategy is important</span></h2>
<p><span class="koboSpan" id="kobo.28.1">A well-crafted </span><a id="_idIndexMarker204"/><span class="koboSpan" id="kobo.29.1">branching strategy is not just nice to have; it is crucial in a team development environment. </span><span class="koboSpan" id="kobo.29.2">Your branching strategy has a ripple effect on your DevOps processes, affecting deployment units and workflow efficiency. </span><span class="koboSpan" id="kobo.29.3">The ability to collaborate smoothly depends not only on good communication within the team but also impacts the speed at which your product evolves. </span><span class="koboSpan" id="kobo.29.4">This ties back into all the elements we have covered in the previous chapters, such as the frequency and methodology of your CI/CD tests. </span><span class="koboSpan" id="kobo.29.5">In essence, your branching strategy is pivotal in removing organizational friction, which is the ultimate aim </span><span class="No-Break"><span class="koboSpan" id="kobo.30.1">of DevOps.</span></span></p>
<p><span class="koboSpan" id="kobo.31.1">Here are some reasons why a well-thought-out branching strategy </span><span class="No-Break"><span class="koboSpan" id="kobo.32.1">is non-negotiable:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.33.1">Isolation of changes</span></strong><span class="koboSpan" id="kobo.34.1">: It allows</span><a id="_idIndexMarker205"/><span class="koboSpan" id="kobo.35.1"> individual team members to work on distinct features or bugs without interfering with each </span><span class="No-Break"><span class="koboSpan" id="kobo.36.1">other’s work.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.37.1">Risk mitigation</span></strong><span class="koboSpan" id="kobo.38.1">: A branching strategy safeguards the main (often called master) branch from being destabilized by untested or </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">volatile code.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.40.1">Facilitates collaboration</span></strong><span class="koboSpan" id="kobo.41.1">: With a good branching strategy, multiple team members can work on different branches in parallel, thereby increasing overall </span><span class="No-Break"><span class="koboSpan" id="kobo.42.1">team efficiency.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.43.1">In the context of DevOps, a branching strategy also does </span><span class="No-Break"><span class="koboSpan" id="kobo.44.1">the following:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.45.1">Automated testing integration</span></strong><span class="koboSpan" id="kobo.46.1">: A branching strategy can be designed to trigger automated tests at various stages. </span><span class="koboSpan" id="kobo.46.2">This ensures that only well-tested code is merged back into the main branch, aiding in </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">continuous integration.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.48.1">Simplifies deployment</span></strong><span class="koboSpan" id="kobo.49.1">: A well-organized branch structure can streamline the deployment process, making it easier to move code from development environments to staging and finally </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">to production.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.51.1">Enhances developer experience</span></strong><span class="koboSpan" id="kobo.52.1">: It improves the overall </span><strong class="bold"><span class="koboSpan" id="kobo.53.1">Developer Experience</span></strong><span class="koboSpan" id="kobo.54.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.55.1">DX</span></strong><span class="koboSpan" id="kobo.56.1">) by making </span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.57.1">collaboration more transparent and efficient, a key strategy for </span><span class="No-Break"><span class="koboSpan" id="kobo.58.1">successful DevOps.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.59.1">Environment-specific branches</span></strong><span class="koboSpan" id="kobo.60.1">: Having branches dedicated to particular environments (development, staging, production, etc.) allows for smoother and more </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">controlled deployments.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.62.1">Enhances security</span></strong><span class="koboSpan" id="kobo.63.1">: By establishing clear boundaries between branches, a branching strategy can enhance security by controlling access to sensitive code and ensuring that changes undergo proper review and approval processes before being merged into </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">critical </span></span><span class="No-Break"><a id="_idIndexMarker207"/></span><span class="No-Break"><span class="koboSpan" id="kobo.65.1">environments.</span></span></li>
</ul>
<h2 id="_idParaDest-57"><a id="_idTextAnchor058"/><span class="koboSpan" id="kobo.66.1">Branch strategy and branch policy</span></h2>
<p><span class="koboSpan" id="kobo.67.1">In the landscape of software development and DevOps, the</span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.68.1"> terms </span><strong class="bold"><span class="koboSpan" id="kobo.69.1">branching strategy</span></strong><span class="koboSpan" id="kobo.70.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.71.1">branching policy</span></strong><span class="koboSpan" id="kobo.72.1"> might</span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.73.1"> appear synonymous. </span><span class="koboSpan" id="kobo.73.2">While they are frequently mistaken for one another, it is vital to recognize that a branching strategy is a more expansive concept that encompasses a </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">branching policy.</span></span></p>
<p><span class="koboSpan" id="kobo.75.1">A branching strategy is </span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.76.1">a comprehensive plan that outlines how branches are managed, created, and integrated within your development workflow. </span><span class="koboSpan" id="kobo.76.2">It encapsulates more than just the technical aspects of handling branches. </span><span class="koboSpan" id="kobo.76.3">It also involves contextual variables such as the size of your organization, the culture within your team, and the specific requirements of your project </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">or product.</span></span></p>
<p><span class="koboSpan" id="kobo.78.1">Branching policies, on </span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.79.1">the other hand, are more specific sets of rules or guidelines for branch management. </span><span class="koboSpan" id="kobo.79.2">These often form the backbone of a branching strategy, serving as templates to be customized </span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.80.1">according to your specific needs. </span><span class="koboSpan" id="kobo.80.2">Sometimes, policies such as </span><strong class="bold"><span class="koboSpan" id="kobo.81.1">Git Flow</span></strong><span class="koboSpan" id="kobo.82.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.83.1">GitHub Flow</span></strong><span class="koboSpan" id="kobo.84.1">, which</span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.85.1"> we will discover in this chapter, are used as the names of strategies for development. </span><span class="koboSpan" id="kobo.85.2">They should be considered as types of branching policies. </span><span class="koboSpan" id="kobo.85.3">Renowned software thought leader Martin Fowler discusses these items not as strategies themselves but rather under the </span><em class="italic"><span class="koboSpan" id="kobo.86.1">Looking at some branching policies</span></em><span class="koboSpan" id="kobo.87.1"> section in his article </span><em class="italic"><span class="koboSpan" id="kobo.88.1">Patterns for Managing Source Code </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.89.1">Branches</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.90.1"> (</span></span><a href="https://martinfowler.com/articles/branching-patterns.html"><span class="No-Break"><span class="koboSpan" id="kobo.91.1">https://martinfowler.com/articles/branching-patterns.html</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.92.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.93.1">Therefore, when establishing a branching approach, it is crucial to choose a branching policy that serves as a foundation. </span><span class="koboSpan" id="kobo.93.2">This policy should then be customized to align with your organization’s unique needs and objectives to effectively mitigate friction in development processes and accelerate software releases. </span><span class="koboSpan" id="kobo.93.3">This tailored approach ensures that your branching strategy not only optimizes workflow but also integrates seamlessly with the cultural and organizational aspects of </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">your team.</span></span></p>
<h2 id="_idParaDest-58"><a id="_idTextAnchor059"/><span class="koboSpan" id="kobo.95.1">Smaller and frequent versus larger and less frequent</span></h2>
<p><span class="koboSpan" id="kobo.96.1">There are many branching policies in existence. </span><span class="koboSpan" id="kobo.96.2">Companies often coin specific branching policy names and publish them as best practices, such</span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.97.1"> as </span><strong class="bold"><span class="koboSpan" id="kobo.98.1">GitHub Flow</span></strong><span class="koboSpan" id="kobo.99.1">. </span><span class="koboSpan" id="kobo.99.2">Fundamentally, all branching strategies map to one of two principles: make smaller changes frequently or make larger </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">changes occasionally.</span></span></p>
<p><span class="koboSpan" id="kobo.101.1">For smaller teams, naturally, the friction in integrating changes and pushing releases quickly is less. </span><span class="koboSpan" id="kobo.101.2">But in larger organizations, with larger products or a lengthy approval process, the friction inevitably increases. </span><span class="koboSpan" id="kobo.101.3">More conflicts arise, and more checks are needed to </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">prevent them.</span></span></p>
<p><span class="koboSpan" id="kobo.103.1">However, allowing these challenges to slow down your development process can adversely affect the timeliness of your product or project releases, ultimately impacting </span><span class="No-Break"><span class="koboSpan" id="kobo.104.1">business success.</span></span></p>
<p><span class="koboSpan" id="kobo.105.1">Over time, various companies have devised a multitude of branching strategies to mitigate these issues. </span><span class="koboSpan" id="kobo.105.2">Most of them are extensions of existing practices, designed to reduce friction within the constraints of an organization or product, aiming for </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">faster releases.</span></span></p>
<p><span class="koboSpan" id="kobo.107.1">It is crucial to understand that no branching strategy serves as a one-size-fits-all solution. </span><span class="koboSpan" id="kobo.107.2">The base strategy often gets selected depending on the team’s composition and culture, and from there, customizations are made to fit </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">specific needs.</span></span></p>
<p><span class="koboSpan" id="kobo.109.1">This section introduces the branch policies trunk-based development, Git Flow, and GitHub Flow, each mapped </span><span class="No-Break"><span class="koboSpan" id="kobo.110.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer037">
<span class="koboSpan" id="kobo.111.1"><img alt="Figure 3.1 – Branching policies mapping" src="image/B21203_03_001.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.112.1">Figure 3.1 – Branching policies mapping</span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.113.1">Trunk-based development</span></strong><span class="koboSpan" id="kobo.114.1"> is</span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.115.1"> renowned for integrating smaller, frequent changes directly into the main branch. </span><span class="koboSpan" id="kobo.115.2">In contrast, Git Flow is known for a strategy that integrates larger changes less frequently. </span><span class="koboSpan" id="kobo.115.3">Both have their pros and cons, and your choice between them often boils down to your team’s specific requirements </span><span class="No-Break"><span class="koboSpan" id="kobo.116.1">and workflows.</span></span></p>
<p><span class="koboSpan" id="kobo.117.1">For larger organizations aiming to release a higher volume of changes more frequently with reduced friction, GitHub Flow serves as an excellent representative. </span><span class="koboSpan" id="kobo.117.2">These strategies are essentially designed to adapt the core principles of frequent, small changes to fit the complexity and scale of </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">larger enterprises.</span></span></p>
<p><span class="koboSpan" id="kobo.119.1">Policies such as GitHub Flow</span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.120.1"> are built under the influence of Git Flow, but many companies</span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.121.1"> nowadays use GitHub Flow as a template upon which they build their own customized </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">branching policies.</span></span></p>
<h2 id="_idParaDest-59"><a id="_idTextAnchor060"/><span class="koboSpan" id="kobo.123.1">Types of branch policies branch policies</span></h2>
<p><span class="koboSpan" id="kobo.124.1">Now then, let’s look at a typical </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">branch policy.</span></span></p>
<p><span class="koboSpan" id="kobo.126.1">This section introduces three typical </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">branching policies:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.128.1">Trunk-based development</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.129.1">Git Flow</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.130.1">GitHub Flow</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.131.1">Consider each in terms of how frequently your team or organization needs to release and how large your product and </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">project are.</span></span></p>
<h3><span class="koboSpan" id="kobo.133.1">Trunk-based development</span></h3>
<p><strong class="bold"><span class="koboSpan" id="kobo.134.1">Trunk-based development</span></strong><span class="koboSpan" id="kobo.135.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.136.1">TBD</span></strong><span class="koboSpan" id="kobo.137.1">) is a </span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.138.1">software development approach </span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.139.1">where developers work in short-lived branches, typically less than a day, or directly off a single branch called the </span><strong class="bold"><span class="koboSpan" id="kobo.140.1">trunk</span></strong><span class="koboSpan" id="kobo.141.1"> or the </span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.142.1">mainline. </span><span class="koboSpan" id="kobo.142.2">The key principle is to minimize the lifespan of branches to promote frequent integrations and to avoid the pitfalls of long-lived feature branches, such as merge conflicts and </span><span class="No-Break"><span class="koboSpan" id="kobo.143.1">diverging codebases.</span></span></p>
<p><span class="koboSpan" id="kobo.144.1">In TBD, the trunk is always in working and healthy condition, and it should always be in a deployable state. </span><span class="koboSpan" id="kobo.144.2">Developers take a small chunk of a feature or task and work on it, aiming to merge it back into the trunk as soon as possible. </span><span class="koboSpan" id="kobo.144.3">If a feature is not yet ready for production, </span><strong class="bold"><span class="koboSpan" id="kobo.145.1">feature flags</span></strong><span class="koboSpan" id="kobo.146.1"> can</span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.147.1"> be used to hide these functionalities until they are complete, allowing the code to be merged without affecting the end users. </span><span class="koboSpan" id="kobo.147.2">Release practices such as feature flags are covered in </span><a href="B21203_05.xhtml#_idTextAnchor109"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.148.1">Chapter 5</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.149.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.150.1">As shown in the </span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.151.1">figure, in the TBD, many short-lived branches are </span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.152.1">created, and they are merged into </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">the mainline.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer038">
<span class="koboSpan" id="kobo.154.1"><img alt="Figure 3.2 – Trunk-based development" src="image/B21203_03_002.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.155.1">Figure 3.2 – Trunk-based development</span></p>
<p><span class="koboSpan" id="kobo.156.1">Since integration happens frequently, it is crucial to have a robust suite of automated tests to run every time code is merged into the trunk. </span><span class="koboSpan" id="kobo.156.2">This ensures that the code base remains stable and deployable at all times. </span><strong class="bold"><span class="koboSpan" id="kobo.157.1">Continuous Integration</span></strong><span class="koboSpan" id="kobo.158.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.159.1">CI</span></strong><span class="koboSpan" id="kobo.160.1">) tools</span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.161.1"> are commonly used in conjunction with TBD to automate the testing and build processes, ensuring that the trunk is always in a </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">good state.</span></span></p>
<p><span class="koboSpan" id="kobo.163.1">To accommodate hotfixes that provide urgent fixes, developers may create short-lived branches that are immediately merged back into the trunk upon completion. </span><span class="koboSpan" id="kobo.163.2">This ensures that critical issues can be addressed quickly without jeopardizing the stability of </span><span class="No-Break"><span class="koboSpan" id="kobo.164.1">the mainline.</span></span></p>
<p><span class="koboSpan" id="kobo.165.1">One of the main advantages </span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.166.1">of TBD is its simplicity and focus on producing a clean, deployable code base. </span><span class="koboSpan" id="kobo.166.2">Encouraging frequent merges reduces the likelihood of merge conflicts and keeps all developers aligned with the latest version of the code. </span><span class="koboSpan" id="kobo.166.3">This is particularly beneficial in a DevOps culture that prioritizes quick iterations and </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">rapid delivery.</span></span></p>
<p><span class="koboSpan" id="kobo.168.1">Here are the pros and cons of </span><span class="No-Break"><span class="koboSpan" id="kobo.169.1">trunk-based development.</span></span></p>
<p><span class="No-Break"><span class="koboSpan" id="kobo.170.1">Pros:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.171.1">Frequent integration</span></strong><span class="koboSpan" id="kobo.172.1">: Because </span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.173.1">code is merged frequently, merge conflicts are less likely and easier </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">to resolve</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.175.1">Fast feedback loop</span></strong><span class="koboSpan" id="kobo.176.1">: Integrating changes often helps in identifying issues earlier in the </span><span class="No-Break"><span class="koboSpan" id="kobo.177.1">development process</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.178.1">Simplified workflow</span></strong><span class="koboSpan" id="kobo.179.1">: Without a proliferation of long-lived feature branches, the development workflow is simplified, making it easier </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">to manage</span></span></li>
</ul>
<p><span class="No-Break"><span class="koboSpan" id="kobo.181.1">Cons:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.182.1">Risk of instability</span></strong><span class="koboSpan" id="kobo.183.1">: If not </span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.184.1">properly tested, frequent merges can lead to unstable code getting into </span><span class="No-Break"><span class="koboSpan" id="kobo.185.1">the mainline</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.186.1">Not ideal for large features</span></strong><span class="koboSpan" id="kobo.187.1">: For very large or disruptive changes, this approach can cause problems, as those changes might destabilize the mainline for an </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">extended period</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.189.1">In summary, TBD is all about rapid integrations, keeping the trunk always deployable, and employing automated testing to maintain code quality. </span><span class="koboSpan" id="kobo.189.2">It aligns well with Agile and DevOps methodologies, aiming to remove friction and improve developer experience by streamlining the </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">development process.</span></span></p>
<h3><span class="koboSpan" id="kobo.191.1">Git Flow</span></h3>
<p><span class="koboSpan" id="kobo.192.1">Git Flow</span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.193.1"> is a </span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.194.1">branching policy mainly aimed at robust project versioning and is particularly well-suited for projects that have a scheduled release cycle. </span><span class="koboSpan" id="kobo.194.2">It introduces a structured approach involving multiple types of branches, including </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">feature</span></strong><span class="koboSpan" id="kobo.196.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">release</span></strong><span class="koboSpan" id="kobo.198.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.199.1">develop</span></strong><span class="koboSpan" id="kobo.200.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.201.1">hotfix</span></strong><span class="koboSpan" id="kobo.202.1">, alongside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.203.1">main</span></strong><span class="koboSpan" id="kobo.204.1"> (or </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.205.1">master</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.206.1">) branch.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer039">
<span class="koboSpan" id="kobo.207.1"><img alt="Figure 3.3 – Git Flow" src="image/B21203_03_003.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.208.1">Figure 3.3 – Git Flow</span></p>
<p><span class="koboSpan" id="kobo.209.1">In Git Flow, development begins by branching off a </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">develop</span></strong><span class="koboSpan" id="kobo.211.1"> branch from </span><strong class="source-inline"><span class="koboSpan" id="kobo.212.1">main</span></strong><span class="koboSpan" id="kobo.213.1">. </span><span class="koboSpan" id="kobo.213.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.214.1">develop</span></strong><span class="koboSpan" id="kobo.215.1"> branch serves as the integration branch for features and is where all developers’ branches get merged. </span><span class="koboSpan" id="kobo.215.2">When you are set to work on a new feature or a bug, you branch off a </span><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">feature</span></strong><span class="koboSpan" id="kobo.217.1"> branch from </span><strong class="source-inline"><span class="koboSpan" id="kobo.218.1">develop</span></strong><span class="koboSpan" id="kobo.219.1">. </span><span class="koboSpan" id="kobo.219.2">This isolated environment allows you to work without affecting the broader </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">code base.</span></span></p>
<p><span class="koboSpan" id="kobo.221.1">As the feature progresses, incremental changes are committed to this </span><strong class="source-inline"><span class="koboSpan" id="kobo.222.1">feature</span></strong><span class="koboSpan" id="kobo.223.1"> branch. </span><span class="koboSpan" id="kobo.223.2">Once the feature is complete and tested, it gets merged back into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.224.1">develop</span></strong><span class="koboSpan" id="kobo.225.1"> branch. </span><span class="koboSpan" id="kobo.225.2">For release preparation, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">release</span></strong><span class="koboSpan" id="kobo.227.1"> branch is created from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.228.1">develop</span></strong><span class="koboSpan" id="kobo.229.1"> branch. </span><span class="koboSpan" id="kobo.229.2">This branch is where any final minor bug fixes or documentation updates occur. </span><span class="koboSpan" id="kobo.229.3">Once everything is ready, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">release</span></strong><span class="koboSpan" id="kobo.231.1"> branch is merged into </span><strong class="source-inline"><span class="koboSpan" id="kobo.232.1">main</span></strong><span class="koboSpan" id="kobo.233.1"> and tagged with a version number. </span><span class="koboSpan" id="kobo.233.2">Simultaneously, it should also be merged back into </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">develop</span></strong><span class="koboSpan" id="kobo.235.1"> to ensure that future releases also have these changes. </span><span class="koboSpan" id="kobo.235.2">For immediate, critical fixes, a </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">hotfix</span></strong><span class="koboSpan" id="kobo.237.1"> branch may be created directly off the </span><span class="No-Break"><span class="koboSpan" id="kobo.238.1">main branch.</span></span></p>
<p><span class="koboSpan" id="kobo.239.1">Git Flow</span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.240.1"> provides a rigid structure that can be beneficial for large projects with multiple developers, requiring a balance of stability and new features. </span><span class="koboSpan" id="kobo.240.2">It ensures that development processes are separate but parallel, allowing for project history to be more legible </span><span class="No-Break"><span class="koboSpan" id="kobo.241.1">and revertible.</span></span></p>
<p><span class="koboSpan" id="kobo.242.1">Here are the pros and cons of the </span><span class="No-Break"><span class="koboSpan" id="kobo.243.1">Git Flow.</span></span></p>
<p><span class="No-Break"><span class="koboSpan" id="kobo.244.1">Pros:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.245.1">Structured workflow</span></strong><span class="koboSpan" id="kobo.246.1">: It’s</span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.247.1"> suitable for projects that have scheduled </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">release cycles</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.249.1">Isolation</span></strong><span class="koboSpan" id="kobo.250.1">: Feature branches allow developers to work in isolation, making it easier to manage </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">complex features</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.252.1">Hotfix support</span></strong><span class="koboSpan" id="kobo.253.1">: The dedicated hotfix branches make it easy to quickly patch </span><span class="No-Break"><span class="koboSpan" id="kobo.254.1">production releases</span></span></li>
</ul>
<p><span class="No-Break"><span class="koboSpan" id="kobo.255.1">Cons:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.256.1">Complexity</span></strong><span class="koboSpan" id="kobo.257.1">: For smaller </span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.258.1">teams or projects, Git Flow may introduce </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">unnecessary complexity</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.260.1">Delayed Integration</span></strong><span class="koboSpan" id="kobo.261.1">: As feature branches are long-lived, this could lead to merge conflicts or bugs that are discovered late in the </span><span class="No-Break"><span class="koboSpan" id="kobo.262.1">development process</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.263.1">In summary, Git Flow provides a model for more complex projects, ensuring that the code base remains organized and that releases are well managed. </span><span class="koboSpan" id="kobo.263.2">It is especially useful for larger teams where coordination and release planning </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">are critical.</span></span></p>
<h3><span class="koboSpan" id="kobo.265.1">GitHub Flow</span></h3>
<p><span class="koboSpan" id="kobo.266.1">GitHub Flow is </span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.267.1">a simplified</span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.268.1"> workflow that encourages continuous delivery practices. </span><span class="koboSpan" id="kobo.268.2">It consists of just the mainline and short-lived feature branches. </span><span class="koboSpan" id="kobo.268.3">The main principle is to branch off, develop a new feature, submit a pull request, and review the code before deploying. </span><span class="koboSpan" id="kobo.268.4">Pull request is an invention by GitHub and is a method for developers to notify team members that they have completed a feature or fix, which is then reviewed and discussed before being merged into the main branch of a code base. </span><span class="koboSpan" id="kobo.268.5">It will be covered in </span><a href="B21203_04.xhtml#_idTextAnchor077"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.269.1">Chapter 4</span></em></span></a><span class="No-Break"><span class="koboSpan" id="kobo.270.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.271.1">The GitHub Flow is simple, but the context is not confined to Git alone. </span><span class="koboSpan" id="kobo.271.2">Note the inclusion of GitHub processes such as pull requests and approvals, as shown in </span><span class="No-Break"><span class="koboSpan" id="kobo.272.1">the figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer040">
<span class="koboSpan" id="kobo.273.1"><img alt="Figure 3.4 – GitHub Flow" src="image/B21203_03_004.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.274.1">Figure 3.4 – GitHub Flow</span></p>
<p><span class="koboSpan" id="kobo.275.1">It begins with creating a new, descriptive branch off the default repository branch, serving as a safe environment for making changes without affecting the main code base. </span><span class="koboSpan" id="kobo.275.2">Changes are committed and pushed to this remote branch. </span><span class="koboSpan" id="kobo.275.3">When ready, a detailed pull request is created for team reviews, often linked to related issues for context. </span><span class="koboSpan" id="kobo.275.4">Reviews might include questions, suggestions, or line-specific comments. </span><span class="koboSpan" id="kobo.275.5">Subsequent commits addressing feedback are automatically added to the pull request. </span><span class="koboSpan" id="kobo.275.6">After approval, the pull request is merged into the default branch, making your contributions part of the main code base. </span><span class="koboSpan" id="kobo.275.7">Depending on settings, resolving merge conflicts or meeting approval criteria may be required. </span><span class="koboSpan" id="kobo.275.8">Post-merge, the working branch is deleted but the commit history and discussions remain accessible for </span><span class="No-Break"><span class="koboSpan" id="kobo.276.1">future reference.</span></span></p>
<p><span class="koboSpan" id="kobo.277.1">In essence, GitHub Flow fosters collaboration, transparency, and incremental development, offering a flexible yet structured approach for </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">team projects.</span></span></p>
<p><span class="koboSpan" id="kobo.279.1">Here are the pros and cons of the </span><span class="No-Break"><span class="koboSpan" id="kobo.280.1">GitHub Flow.</span></span></p>
<p><span class="No-Break"><span class="koboSpan" id="kobo.281.1">Pros:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.282.1">Simplicity</span></strong><span class="koboSpan" id="kobo.283.1">: GitHub Flow </span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.284.1">offers a straightforward approach with a single mainline and short-lived feature branches, making it accessible and easy to manage, even for newcomers. </span><span class="koboSpan" id="kobo.284.2">This simplicity streamlines development, allowing </span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.285.1">for a focus on productivity rather than complex </span><span class="No-Break"><span class="koboSpan" id="kobo.286.1">branching strategies.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.287.1">Faster deployment</span></strong><span class="koboSpan" id="kobo.288.1">: By encouraging continuous integration and delivery, GitHub Flow enables teams to release updates more frequently. </span><span class="koboSpan" id="kobo.288.2">This rapid deployment cycle allows for immediate feedback and quicker iteration, reducing the time from development </span><span class="No-Break"><span class="koboSpan" id="kobo.289.1">to market.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.290.1">Enhanced collaboration</span></strong><span class="koboSpan" id="kobo.291.1">: The pull request mechanism central to GitHub Flow fosters transparent code reviews and collaboration. </span><span class="koboSpan" id="kobo.291.2">It allows every team member to contribute to discussions, ensuring code quality and collective ownership of </span><span class="No-Break"><span class="koboSpan" id="kobo.292.1">the project.</span></span></li>
</ul>
<p><span class="No-Break"><span class="koboSpan" id="kobo.293.1">Cons:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.294.1">Platform compatibility considerations</span></strong><span class="koboSpan" id="kobo.295.1">: Adopting GitHub Flow enhances collaboration and </span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.296.1">efficiency, particularly on GitHub where it is fully supported. </span><span class="koboSpan" id="kobo.296.2">However, when integrating with different platforms, it might necessitate supplementary tools or adjustments to harness its full potential, ensuring seamless project management across </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">diverse environments.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.298.1">Adaptability for complex projects:</span></strong><span class="koboSpan" id="kobo.299.1"> While GitHub Flow offers a streamlined, straightforward approach conducive to rapid deployment and continuous delivery, larger teams working on multifaceted projects may encounter challenges. </span><span class="koboSpan" id="kobo.299.2">This workflow’s emphasis on simplicity and single mainline development can sometimes limit the granularity of control over multiple simultaneous developments or the nuanced handling of various project timelines. </span><span class="koboSpan" id="kobo.299.3">For instance, in projects requiring extensive integration testing or coordination across multiple sub-teams, the need for additional branch management</span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.300.1"> strategies or</span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.301.1"> more robust release planning mechanisms </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">becomes apparent.</span></span></li>
</ul>
<h2 id="_idParaDest-60"><a id="_idTextAnchor061"/><span class="koboSpan" id="kobo.303.1">Branch naming conventions – Discover the best practices for naming branches in Git</span></h2>
<p><span class="koboSpan" id="kobo.304.1">In the realm of Git and DevOps, naming</span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.305.1"> is a crucial aspect of effective team collaboration and code management. </span><span class="koboSpan" id="kobo.305.2">A clear, descriptive name can make a world of difference when you are navigating through a sea of branches, trying to understand their specific functions, ownership, and lifecycle status. </span><span class="koboSpan" id="kobo.305.3">Establishing a coherent branching naming convention is an integral part of an effective </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">branching strategy.</span></span></p>
<p><span class="koboSpan" id="kobo.307.1">Let’s delve into the best practices for naming branches in Git, aiming to remove organizational friction and accelerate releases. </span><span class="koboSpan" id="kobo.307.2">A well-defined naming convention allows engineers to instantly understand the purpose of a branch, whether it is for a feature, a bug fix, a hotfix, or an experimental endeavor. </span><span class="koboSpan" id="kobo.307.3">This clarity is vital when a team is sifting through dozens, or even hundreds, of branches. </span><span class="koboSpan" id="kobo.307.4">Naming conventions set the stage for a more transparent, efficient, and streamlined workflow, making it easier for everyone on the DevOps team </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">to collaborate.</span></span></p>
<h3><span class="koboSpan" id="kobo.309.1">Branch naming guidelines and examples</span></h3>
<p><span class="koboSpan" id="kobo.310.1">The following are the </span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.311.1">main guidelines and examples for naming each topic. </span><span class="koboSpan" id="kobo.311.2">Please note that these are only examples, and each team can have very different </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">naming conventions.</span></span></p>
<p><span class="koboSpan" id="kobo.313.1">Here’s some </span><span class="No-Break"><span class="koboSpan" id="kobo.314.1">general guidance:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.315.1">Use hyphens, underscores, or slashes</span></strong><span class="koboSpan" id="kobo.316.1">: Using spaces in branch names can lead to errors and complications when interacting with the Git command line. </span><span class="koboSpan" id="kobo.316.2">Instead, use hyphens (</span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">-</span></strong><span class="koboSpan" id="kobo.318.1">), underscores (</span><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">_</span></strong><span class="koboSpan" id="kobo.320.1">), or slashes (</span><strong class="source-inline"><span class="koboSpan" id="kobo.321.1">/</span></strong><span class="koboSpan" id="kobo.322.1">) to separate words. </span><span class="koboSpan" id="kobo.322.2">Slashes are especially used as a separator when dealing with topics such as hotfixes </span><span class="No-Break"><span class="koboSpan" id="kobo.323.1">and features.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.324.1">Lowercase names</span></strong><span class="koboSpan" id="kobo.325.1">: While Git is case-sensitive, sticking to lowercase letters helps maintain consistency and </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">avoids confusion.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.327.1">Make it descriptive but short</span></strong><span class="koboSpan" id="kobo.328.1">: The name should give an instant idea of what the branch is about while </span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.329.1">remaining as succinct </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">as possible.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.331.1">Here are examples of names for </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">each branch:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.333.1">Feature branches</span></strong><span class="koboSpan" id="kobo.334.1">: A feature branch</span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.335.1"> is typically where new functionalities are developed. </span><span class="koboSpan" id="kobo.335.2">Names for feature branches should start with </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">feature/</span></strong><span class="koboSpan" id="kobo.337.1">, followed by a brief description. </span><span class="koboSpan" id="kobo.337.2">An example would be </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.338.1">feature/user authentication</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.339.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.340.1">Bugfix branches</span></strong><span class="koboSpan" id="kobo.341.1">: If a branch </span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.342.1">is specifically for fixing a bug, name it starting with </span><strong class="source-inline"><span class="koboSpan" id="kobo.343.1">bugfix/</span></strong><span class="koboSpan" id="kobo.344.1">, followed by a short descriptor. </span><span class="koboSpan" id="kobo.344.2">For </span><span class="No-Break"><span class="koboSpan" id="kobo.345.1">example, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.346.1">bugfix/login-error</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.347.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.348.1">Hotfix branches</span></strong><span class="koboSpan" id="kobo.349.1">: A hotfix</span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.350.1"> branch is for urgent fixes that need to be pushed to production as quickly as possible. </span><span class="koboSpan" id="kobo.350.2">Begin these with </span><strong class="source-inline"><span class="koboSpan" id="kobo.351.1">hotfix/</span></strong><span class="koboSpan" id="kobo.352.1">. </span><span class="koboSpan" id="kobo.352.2">For </span><span class="No-Break"><span class="koboSpan" id="kobo.353.1">example, </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">hotfix/xyz-security-vulnerability</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.355.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.356.1">Release branches</span></strong><span class="koboSpan" id="kobo.357.1">: For </span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.358.1">branches that are in preparation for a release, use </span><strong class="source-inline"><span class="koboSpan" id="kobo.359.1">release/</span></strong><span class="koboSpan" id="kobo.360.1"> as a prefix. </span><span class="koboSpan" id="kobo.360.2">An example </span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.361.1">would </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">be </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.363.1">release/v1.2</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.364.1">.</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.365.1">Contextual naming</span></h3>
<p><span class="koboSpan" id="kobo.366.1">While these categories </span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.367.1">offer a good starting point, you may also consider adding more contextual information to the branch name. </span><span class="koboSpan" id="kobo.367.2">For example, you could append the issue number at the end (</span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">feature/123-user-authentication</span></strong><span class="koboSpan" id="kobo.369.1">) or include the name of the person responsible for the </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">branch (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.371.1">feature/teamxyz-authentication</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.372.1">).</span></span></p>
<p><span class="koboSpan" id="kobo.373.1">In this section, we recognized that a solid branching strategy stands as the backbone of any collaborative development project. </span><span class="koboSpan" id="kobo.373.2">We have explored the significance of branch strategies in maintaining a stable code base while facilitating continuous integration and delivery. </span><span class="koboSpan" id="kobo.373.3">Whether it is adopting the small and frequent commits of TBD, the structured roles of Git Flow, or the simplicity of GitHub Flow, the right strategy is paramount to a </span><span class="No-Break"><span class="koboSpan" id="kobo.374.1">team’s success.</span></span></p>
<p><span class="koboSpan" id="kobo.375.1">Remember, these conventions should align with your broader branching strategy and policy and be adapted to the size of your team and the project and your organization’s unique constraints and goals. </span><span class="koboSpan" id="kobo.375.2">A well-chosen naming convention will reinforce the effectiveness of your branching policy, aiding in the quest to mitigate friction and accelerate releases. </span><span class="koboSpan" id="kobo.375.3">By adhering to a well-defined naming convention, you empower your team to work more efficiently and foster a culture of clarity </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">and accountability.</span></span></p>
<p><span class="koboSpan" id="kobo.377.1">In the upcoming section, you will learn how to bring together disparate lines of development while maintaining the integrity and history of your code. </span><span class="koboSpan" id="kobo.377.2">Let’s move forward with confidence, ready to merge our knowledge of branching into the practical skills of </span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">Git merging.</span></span></p>
<h1 id="_idParaDest-61"><a id="_idTextAnchor062"/><span class="koboSpan" id="kobo.379.1">Ways to apply your changes on a branch</span></h1>
<p><span class="koboSpan" id="kobo.380.1">Now that you have delved into the intricacies of branch management and workflows in DevOps, you are likely starting to see the big picture. </span><span class="koboSpan" id="kobo.380.2">You have come to understand how your individual commits contribute to the overall development stream. </span><span class="koboSpan" id="kobo.380.3">The next step in this journey is </span><em class="italic"><span class="koboSpan" id="kobo.381.1">to connect the dots</span></em><span class="koboSpan" id="kobo.382.1">—more specifically, consider how the code you have written gets merged into </span><span class="No-Break"><span class="koboSpan" id="kobo.383.1">the mainline.</span></span></p>
<p><span class="koboSpan" id="kobo.384.1">The code base is a living, collaborative environment; it holds a history of contributions from various team members. </span><span class="koboSpan" id="kobo.384.2">In a fast-paced environment, it may be tempting to rush through commits or push large chunks of changes all at once to meet deadlines. </span><span class="koboSpan" id="kobo.384.3">However, when merging, it is crucial to consider how your changes contribute to a consistent, understandable, and stable shared environment. </span><span class="koboSpan" id="kobo.384.4">This consideration becomes particularly vital in a DevOps culture, where the objective is not just rapid deployment but also </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">frictionless collaboration.</span></span></p>
<p><span class="koboSpan" id="kobo.386.1">In the upcoming sections, we will explore various tactics and best practices for executing successful merges in Git, particularly tailored to the needs and challenges that arise in a </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">DevOps setting.</span></span></p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor063"/><span class="koboSpan" id="kobo.388.1">Merging vs rebasing</span></h2>
<p><span class="koboSpan" id="kobo.389.1">Git offers two main techniques for integrating these changes: merging and rebasing. </span><span class="koboSpan" id="kobo.389.2">While they serve the same ultimate purpose—bringing different strands of code together—they have distinct operational nuances. </span><span class="koboSpan" id="kobo.389.3">Before diving into various actual commands, let’s distinguish between merging </span><span class="No-Break"><span class="koboSpan" id="kobo.390.1">and rebasing.</span></span></p>
<h3><span class="koboSpan" id="kobo.391.1">Merging</span></h3>
<p><span class="koboSpan" id="kobo.392.1">Merging </span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.393.1">takes the content of a source branch and integrates it with a target branch. </span><span class="koboSpan" id="kobo.393.2">This new commit will have two parent commits, preserving the independent histories of the branches being merged. </span><span class="koboSpan" id="kobo.393.3">Merging can be cumbersome because it keeps the history from the various branches as it is, but it is also good in terms of flexibility during integration when various people are working on a project at the same time. </span><span class="koboSpan" id="kobo.393.4">Mainly, there are two types of merge options: </span><strong class="bold"><span class="koboSpan" id="kobo.394.1">non-fast-forward merge</span></strong><span class="koboSpan" id="kobo.395.1">, which</span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.396.1"> creates a new merge commit to log the merge, and </span><strong class="bold"><span class="koboSpan" id="kobo.397.1">fast-forward merge</span></strong><span class="koboSpan" id="kobo.398.1">, which </span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.399.1">does not create a merge commit. </span><span class="koboSpan" id="kobo.399.2">There is also the squash function—an option that compresses multiple commits into a single commit </span><span class="No-Break"><span class="koboSpan" id="kobo.400.1">for merging.</span></span></p>
<p><span class="koboSpan" id="kobo.401.1">On platforms such as GitHub, the default setting is for merge commits to be made like in the </span><span class="No-Break"><span class="koboSpan" id="kobo.402.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer041">
<span class="koboSpan" id="kobo.403.1"><img alt="Figure 3.5 – Merging example (non-fast-forward)" src="image/B21203_03_005.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.404.1">Figure 3.5 – Merging example (non-fast-forward)</span></p>
<p><span class="koboSpan" id="kobo.405.1">Here are the pros and cons </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">of merging.</span></span></p>
<p><span class="No-Break"><span class="koboSpan" id="kobo.407.1">Pros:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.408.1">History preservation</span></strong><span class="koboSpan" id="kobo.409.1">: Merging</span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.410.1"> keeps the history of both branches, offering a </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">detailed log</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.412.1">Simplicity</span></strong><span class="koboSpan" id="kobo.413.1">: It is usually easier for beginners </span><span class="No-Break"><span class="koboSpan" id="kobo.414.1">to understand</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.415.1">Branch isolation</span></strong><span class="koboSpan" id="kobo.416.1">: Individual branches can continue to make separate changes without affecting </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">the merge</span></span></li>
</ul>
<p><span class="No-Break"><span class="koboSpan" id="kobo.418.1">Cons:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.419.1">Complex log</span></strong><span class="koboSpan" id="kobo.420.1">: While </span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.421.1">preserving history, merges can lead to a complicated and cluttered </span><span class="No-Break"><span class="koboSpan" id="kobo.422.1">log history</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.423.1">Lack of linearity</span></strong><span class="koboSpan" id="kobo.424.1">: The project history becomes non-linear, making it challenging to navigate the </span><span class="No-Break"><span class="koboSpan" id="kobo.425.1">commit history</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.426.1">Rebasing</span></h3>
<p><span class="koboSpan" id="kobo.427.1">Rebasing is the </span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.428.1">process of moving or combining a sequence of commits to a new base commit. </span><span class="koboSpan" id="kobo.428.2">It essentially takes the changes made in a feature branch and replays them on top of another branch. </span><span class="koboSpan" id="kobo.428.3">Instead of creating a new commit, as is the case with merging, rebasing rewrites the commit history to produce a linear succession of commits. </span><span class="koboSpan" id="kobo.428.4">The great thing about rebasing is the linearity of its history. </span><span class="koboSpan" id="kobo.428.5">When looking back in time, it is easy to follow the flow of what happened in the mainline branch, which is very good in terms of </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">bug fixes.</span></span></p>
<p><span class="koboSpan" id="kobo.430.1">Once you master rebasing, you can contribute to a </span><span class="No-Break"><span class="koboSpan" id="kobo.431.1">noise-free history:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer042">
<span class="koboSpan" id="kobo.432.1"><img alt="Figure 3.6 – Rebasing" src="image/B21203_03_006.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.433.1">Figure 3.6 – Rebasing</span></p>
<p><span class="koboSpan" id="kobo.434.1">Here are the pros and cons </span><span class="No-Break"><span class="koboSpan" id="kobo.435.1">of rebasing.</span></span></p>
<p><span class="No-Break"><span class="koboSpan" id="kobo.436.1">Pros:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.437.1">Cleaner history</span></strong><span class="koboSpan" id="kobo.438.1">: Rebasing</span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.439.1"> results in a much cleaner, linear </span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">project history</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.441.1">Eliminates Noise</span></strong><span class="koboSpan" id="kobo.442.1">: It removes unnecessary merge commits that appear when performing the </span><span class="No-Break"><span class="koboSpan" id="kobo.443.1">git merge</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.444.1">Simpler Debugging</span></strong><span class="koboSpan" id="kobo.445.1">: With a </span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.446.1">cleaner history, debugging </span><span class="No-Break"><span class="koboSpan" id="kobo.447.1">becomes easier</span></span></li>
</ul>
<p><span class="No-Break"><span class="koboSpan" id="kobo.448.1">Cons:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.449.1">Shared Branch Risk</span></strong><span class="koboSpan" id="kobo.450.1">: Rebasing </span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.451.1">can be destructive; it can be risky on shared branches because it rewrites </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">commit history</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.453.1">Complexity</span></strong><span class="koboSpan" id="kobo.454.1">: Rebasing can be more complicated to understand and </span><span class="No-Break"><span class="koboSpan" id="kobo.455.1">execute correctly</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.456.1">Both techniques have their pros and cons. </span><span class="koboSpan" id="kobo.456.2">Merging preserves the original branch history but can lead to a complicated log. </span><span class="koboSpan" id="kobo.456.3">Rebasing offers a cleaner, more linear project history but carries risks, especially when working on a </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">shared branch.</span></span></p>
<h2 id="_idParaDest-63"><a id="_idTextAnchor064"/><span class="koboSpan" id="kobo.458.1">Exploring different ways to merge in Git</span></h2>
<p><span class="koboSpan" id="kobo.459.1">Now let’s dive into the practical steps. </span><span class="koboSpan" id="kobo.459.2">We will explore the process of merging two branches, offering hands-on experience to help you better understand each method. </span><span class="koboSpan" id="kobo.459.3">In this section, we will cover some of the most commonly used methods to merge branches, enabling you to make informed decisions based on your </span><span class="No-Break"><span class="koboSpan" id="kobo.460.1">project needs.</span></span></p>
<h3><span class="koboSpan" id="kobo.461.1">git merge --ff – Keeping it straight</span></h3>
<p><span class="koboSpan" id="kobo.462.1">Let’s dig into the practical </span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.463.1">aspects now. </span><span class="koboSpan" id="kobo.463.2">This section focuses on a common default behavior in Git merging </span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.464.1">called </span><strong class="bold"><span class="koboSpan" id="kobo.465.1">fast-forward</span></strong><span class="koboSpan" id="kobo.466.1">, which is </span><strong class="source-inline"><span class="koboSpan" id="kobo.467.1">--ff</span></strong><span class="koboSpan" id="kobo.468.1"> as a command option. </span><span class="koboSpan" id="kobo.468.2">We will go through the process, ensuring you understand how it works and when to </span><span class="No-Break"><span class="koboSpan" id="kobo.469.1">use it.</span></span></p>
<p><span class="koboSpan" id="kobo.470.1">Fast-forward merging is one of the simplest ways to integrate branches in Git. </span><span class="koboSpan" id="kobo.470.2">In essence, a fast-forward merge moves the tip of the targeted branch to the latest commit on the </span><span class="No-Break"><span class="koboSpan" id="kobo.471.1">source branch.</span></span></p>
<p><span class="koboSpan" id="kobo.472.1">With fast-forward merges, when looking at the history, nothing actually appears to have changed, as shown in the following figure. </span><span class="koboSpan" id="kobo.472.2">That is the benefit of fast-forward merging. </span><span class="koboSpan" id="kobo.472.3">HEAD is moving without fail and merging can be </span><span class="No-Break"><span class="koboSpan" id="kobo.473.1">done smoothly:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer043">
<span class="koboSpan" id="kobo.474.1"><img alt="Figure 3.7 – Fast-forward merging" src="image/B21203_03_007.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.475.1">Figure 3.7 – Fast-forward merging</span></p>
<p><span class="koboSpan" id="kobo.476.1">In Git, a</span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.477.1"> fast-forward merge is possible when there are no new commits on the base (or target) branch that occurred after the feature branch was created. </span><span class="koboSpan" id="kobo.477.2">Essentially, it eliminates the need for a new commit to join the branches, keeping your project </span><span class="No-Break"><span class="koboSpan" id="kobo.478.1">history linear.</span></span></p>
<h4><span class="koboSpan" id="kobo.479.1">Practical steps for fast-forward merging</span></h4>
<p><span class="koboSpan" id="kobo.480.1">For the context of</span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.481.1"> this guide, assume you have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.482.1">main</span></strong><span class="koboSpan" id="kobo.483.1"> branch and an </span><strong class="source-inline"><span class="koboSpan" id="kobo.484.1">add-description</span></strong><span class="koboSpan" id="kobo.485.1"> branch. </span><span class="koboSpan" id="kobo.485.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.486.1">add-description</span></strong><span class="koboSpan" id="kobo.487.1"> branch has derived from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">main</span></strong><span class="koboSpan" id="kobo.489.1"> and you are planning to merge the feature back </span><span class="No-Break"><span class="koboSpan" id="kobo.490.1">into </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">master</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.492.1">:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.493.1">
# Initialize a new repository
$ mkdir try-fast-forward-merge
$ cd try-fast-forward-merge
$ git init
# Add and commit initial README.md to master
$ echo "# My Project" &gt; README.md
$ git add README.md
$ git commit -m "Initial commit on master"
# Create and switch to a new branch 'add-description'
$ git checkout -b add-description
# Make changes to add a description, add and commit changes
$ echo "This project is an example of how to use Git." </span><span class="koboSpan" id="kobo.493.2">&gt;&gt; README.md
$ git add README.md
$ git commit -m "Add project description to README.md"</span></pre> <p><span class="koboSpan" id="kobo.494.1">At this point, your </span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.495.1">repository structure would resemble the </span><a id="_idIndexMarker263"/><span class="No-Break"><span class="koboSpan" id="kobo.496.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer044">
<span class="koboSpan" id="kobo.497.1"><img alt="Figure 3.8 – git merge –ff (1)" src="image/B21203_03_008.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.498.1">Figure 3.8 – git merge –ff (1)</span></p>
<p><span class="koboSpan" id="kobo.499.1">Now, let’s proceed to </span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.500.1">merge these </span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.501.1">branches by switching back to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">main</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.503.1"> branch:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.504.1">
# Switch back to 'main' and perform a Fast-Forward merge
$ git checkout main
$ git merge add-description
# View the linear history
$ git log --graph --oneline
* 26d90bf (HEAD -&gt; main, add-description) Add project description to README.md
* 37ecd54 Add project description to README.md
* a1164b9 Initial commit on master</span></pre> <p><span class="koboSpan" id="kobo.505.1">Now, your repository history would look </span><span class="No-Break"><span class="koboSpan" id="kobo.506.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer045">
<span class="koboSpan" id="kobo.507.1"><img alt="Figure 3.9 – git merge –ff (2)" src="image/B21203_03_009.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.508.1">Figure 3.9 – git merge –ff (2)</span></p>
<h4><span class="koboSpan" id="kobo.509.1">Why fast-forward merges are preferred in DevOps and team collaboration</span></h4>
<p><span class="koboSpan" id="kobo.510.1">Behind the </span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.511.1">scenes, a fast-forward merge merely moves HEAD, the pointer, to the latest commit. </span><span class="koboSpan" id="kobo.511.2">Moreover, fast-forward merges do not create a new merge commit, keeping the Git history clean and linear. </span><span class="koboSpan" id="kobo.511.3">This makes it a simple and </span><span class="No-Break"><span class="koboSpan" id="kobo.512.1">efficient operation.</span></span></p>
<p><span class="koboSpan" id="kobo.513.1">Fast-forward merges are often preferred in team collaboration for a </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">few reasons:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.515.1">Simplicity</span></strong><span class="koboSpan" id="kobo.516.1">: They </span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.517.1">keep the git history linear, which makes it easier </span><span class="No-Break"><span class="koboSpan" id="kobo.518.1">to follow</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.519.1">Transparency</span></strong><span class="koboSpan" id="kobo.520.1">: With a straightforward history, it is easier to track changes, debug issues, and understand the sequence of </span><span class="No-Break"><span class="koboSpan" id="kobo.521.1">feature integrations</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.522.1">Efficiency</span></strong><span class="koboSpan" id="kobo.523.1">: Fast-forward merges eliminate the need for an extra merge commit, simplifying </span><span class="No-Break"><span class="koboSpan" id="kobo.524.1">code reviews</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.525.1">However, keep in</span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.526.1"> mind that fast-forward merges are not always possible. </span><span class="koboSpan" id="kobo.526.2">You can use this way when you are developing with just yourself or when doing simple development, but in most development, there are many things going on in parallel. </span><span class="koboSpan" id="kobo.526.3">When simultaneous changes occur in the master and feature branches, a non-fast-forward merge, which is sometimes called a three-way merge, may </span><span class="No-Break"><span class="koboSpan" id="kobo.527.1">be necessary.</span></span></p>
<h3><span class="koboSpan" id="kobo.528.1">git merge --no-ff – Preserving branch history</span></h3>
<p><span class="koboSpan" id="kobo.529.1">Non-fast-forward merges, commonly </span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.530.1">invoked with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.531.1">--no-ff</span></strong><span class="koboSpan" id="kobo.532.1"> flag, offer an alternative merging strategy that differs from the fast-forward merges we discussed earlier. </span><span class="koboSpan" id="kobo.532.2">Unlike fast-forward merges, which move the tip of the targeted branch to the latest commit of the source branch, non-fast-forward merges generate a new merge commit. </span><span class="koboSpan" id="kobo.532.3">This new commit has two parent commits: one from the source branch and one from the </span><span class="No-Break"><span class="koboSpan" id="kobo.533.1">target branch.</span></span></p>
<p><span class="koboSpan" id="kobo.534.1">Non-fast-forward merges</span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.535.1"> can embed context into the merge commit so that it is possible to look back later to see why this merge </span><span class="No-Break"><span class="koboSpan" id="kobo.536.1">was performed.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer046">
<span class="koboSpan" id="kobo.537.1"><img alt="Figure 3.10 – Non-fast-forward merging" src="image/B21203_03_010.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.538.1">Figure 3.10 – Non-fast-forward merging</span></p>
<p><span class="koboSpan" id="kobo.539.1">This approach keeps track of the fact that a feature branch was merged into the main branch, preserving the context in which past commits </span><span class="No-Break"><span class="koboSpan" id="kobo.540.1">were made.</span></span></p>
<h4><span class="koboSpan" id="kobo.541.1">Practical steps for non-fast-forward merging</span></h4>
<p><span class="koboSpan" id="kobo.542.1">Let’s assume you</span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.543.1"> are working with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.544.1">main</span></strong><span class="koboSpan" id="kobo.545.1"> branch and </span><strong class="source-inline"><span class="koboSpan" id="kobo.546.1">add-feature</span></strong><span class="koboSpan" id="kobo.547.1"> branch. </span><span class="koboSpan" id="kobo.547.2">The </span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.548.1">following are the steps to perform a </span><span class="No-Break"><span class="koboSpan" id="kobo.549.1">non-fast-forward merge:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.550.1">
# Initialize a new repository
$ mkdir try-no-fast-forward-merge
$ cd try-no-fast-forward-merge
$ git init
# Add and commit initial README.md to master
$ echo "# My Project" &gt; README.md
$ git add README.md
$ git commit -m "Initial commit on main"
# Create and switch to a new branch 'add-feature'
$ git checkout -b add-feature
# Make changes, add and commit them
$ echo "Adding a new feature..." </span><span class="koboSpan" id="kobo.550.2">&gt;&gt; README.md
$ git add README.md
$ git commit -m "Implement a new feature"</span></pre> <p><span class="koboSpan" id="kobo.551.1">Now the </span><strong class="source-inline"><span class="koboSpan" id="kobo.552.1">commit</span></strong><span class="koboSpan" id="kobo.553.1"> log is as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.554.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.555.1">.11</span></em><span class="koboSpan" id="kobo.556.1">. </span><span class="koboSpan" id="kobo.556.2">What you did so far is the same as what you did in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">git merge --</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">ff</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.559.1"> section.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer047">
<span class="koboSpan" id="kobo.560.1"><img alt="Figure 3.11 – git merge --no-ff (1)" src="image/B21203_03_011.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.561.1">Figure 3.11 – git merge --no-ff (1)</span></p>
<p><span class="koboSpan" id="kobo.562.1">Then, let’s </span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.563.1">switch back</span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.564.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">main</span></strong><span class="koboSpan" id="kobo.566.1"> and perform a </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.567.1">non-fast-forward</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.568.1"> merge:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.569.1">
$ git checkout main
$ git merge --no-ff add-feature</span></pre> <p><span class="koboSpan" id="kobo.570.1">The following edit message will appear in the terminal. </span><span class="koboSpan" id="kobo.570.2">Edit the commit message and </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">save it:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.572.1">
git merge branch 'add-feature'</span></pre> <p><span class="koboSpan" id="kobo.573.1">After the edit, let’s see the </span><span class="No-Break"><span class="koboSpan" id="kobo.574.1">log now:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.575.1">
# View the history
$ git log --graph --oneline
*   f58977f (HEAD -&gt; main) Merge branch 'add-feature'
|\
| * a48c0a9 (add-feature) Implement new feature
|/
* fe93feb Initial commit on main</span></pre> <p><span class="koboSpan" id="kobo.576.1">Your repository </span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.577.1">history will show a new merge commit indicating where the </span><strong class="source-inline"><span class="koboSpan" id="kobo.578.1">add-feature</span></strong><span class="koboSpan" id="kobo.579.1"> branch was integrated into the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.580.1">main</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.581.1"> branch.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer048">
<span class="koboSpan" id="kobo.582.1"><img alt="Figure 3.12 – git merge --no-ff (2)" src="image/B21203_03_012.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.583.1">Figure 3.12 – git merge --no-ff (2)</span></p>
<h4><span class="koboSpan" id="kobo.584.1">Why use non-fast-forward merges in DevOps and team collaboration?</span></h4>
<p><span class="koboSpan" id="kobo.585.1">Non-fast-forward </span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.586.1">merges offer benefits that can be valuable in various DevOps and team </span><span class="No-Break"><span class="koboSpan" id="kobo.587.1">collaboration scenarios:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.588.1">Context preservation</span></strong><span class="koboSpan" id="kobo.589.1">: Generating a </span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.590.1">new commit during the merging process preserves not just the code but the history and context as well. </span><span class="koboSpan" id="kobo.590.2">This clear record of integration makes it much easier to understand when and how changes from different branches </span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">were combined.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.592.1">Traceability</span></strong><span class="koboSpan" id="kobo.593.1">: Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.594.1">--no-ff</span></strong><span class="koboSpan" id="kobo.595.1"> offers invaluable transparency, providing a clear record of who made what changes, when they made them, and why. </span><span class="koboSpan" id="kobo.595.2">This is particularly beneficial</span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.596.1"> in larger teams and complex projects where it is crucial to understand the flow </span><span class="No-Break"><span class="koboSpan" id="kobo.597.1">of contributions.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.598.1">While merge </span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.599.1">commits can provide rich context and history, they can also clutter the Git history if overused or poorly documented. </span><span class="koboSpan" id="kobo.599.2">It is important for teams to consider their merging strategy carefully and make concerted efforts to maintain a clean </span><span class="No-Break"><span class="koboSpan" id="kobo.600.1">shared repository.</span></span></p>
<h3><span class="koboSpan" id="kobo.601.1">git merge --squash – Squashing complexity</span></h3>
<p><span class="koboSpan" id="kobo.602.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.603.1">git merge --squash</span></strong><span class="koboSpan" id="kobo.604.1"> option</span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.605.1"> provides a different merging technique that offers both clarity and tidiness. </span><span class="koboSpan" id="kobo.605.2">While fast-forward and non-fast-forward merges are excellent for tracking branch histories, there might be cases where you want to condense your </span><strong class="source-inline"><span class="koboSpan" id="kobo.606.1">feature</span></strong><span class="koboSpan" id="kobo.607.1"> branch changes into a single commit before merging. </span><span class="koboSpan" id="kobo.607.2">That’s where </span><strong class="source-inline"><span class="koboSpan" id="kobo.608.1">git merge --</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">squash</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.610.1"> shines.</span></span></p>
<p><span class="koboSpan" id="kobo.611.1">In a squashed merge, all</span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.612.1"> changes from the source (or feature) branch are combined into a single commit on the target (or main) branch. </span><span class="koboSpan" id="kobo.612.2">This action effectively condenses the feature branch history into one commit while merging, offering a clean, easy-to-follow Git history. </span><span class="koboSpan" id="kobo.612.3">This leaves the changes in an uncommitted state, allowing you to modify the differences before finalizing </span><span class="No-Break"><span class="koboSpan" id="kobo.613.1">the commit.</span></span></p>
<p><span class="koboSpan" id="kobo.614.1">While teams are committed to maintaining a clean shared repository, individual development branches often become cluttered with various trial-and-error attempts. </span><span class="koboSpan" id="kobo.614.2">Squash merges contribute to preserving the cleanliness of the main code base by preventing these messy, experimental logs from infiltrating the </span><span class="No-Break"><span class="koboSpan" id="kobo.615.1">production history.</span></span></p>
<p><span class="koboSpan" id="kobo.616.1">The squash merge, as shown in the following figure, is in some ways the cleanest merge, and it has a lot of benefits. </span><span class="koboSpan" id="kobo.616.2">However, keep in mind that it is a way of incorporating changes that lose the previous change history and the commit history of other companies. </span><span class="koboSpan" id="kobo.616.3">This will be mentioned later in </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">this section.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer049">
<span class="koboSpan" id="kobo.618.1"><img alt="Figure 3.13 – Squash merging" src="image/B21203_03_013.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.619.1">Figure 3.13 – Squash merging</span></p>
<h4><span class="koboSpan" id="kobo.620.1">Practical steps for squash merging</span></h4>
<p><span class="koboSpan" id="kobo.621.1">Let’s say you </span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.622.1">have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">main</span></strong><span class="koboSpan" id="kobo.624.1"> branch and an </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">add-multiple-features</span></strong><span class="koboSpan" id="kobo.626.1"> branch. </span><span class="koboSpan" id="kobo.626.2">To perform </span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.627.1">a squash merge, do </span><span class="No-Break"><span class="koboSpan" id="kobo.628.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.629.1">
# Initialize a new repository
$ mkdir try-squash-merge
$ cd try-squash-merge
$ git init
# Add and commit initial README.md to main
$ echo "# My Project" &gt; README.md
$ git add README.md
$ git commit -m "Initial commit on main"
# Create and switch to a new branch 'add-multiple-files
$ git checkout -b add-basic-files
# Make some changes, add and commit them
$ echo "# HOW TO CONTRIBUTE" &gt;&gt; CONTRIBUTING.md
$ git add CONTRIBUTING.md
$ git commit -m "Add CONTRIBUTING.md"
$ echo "# LICENSE" &gt;&gt; LICENSE.txt
$ git add LICENSE.txt
$ git commit -m "Add LICENSE.txt"</span></pre> <p><span class="koboSpan" id="kobo.630.1">Now the branches should look like those in the </span><span class="No-Break"><span class="koboSpan" id="kobo.631.1">following figure:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer050">
<span class="koboSpan" id="kobo.632.1"><img alt="Figure 3.14 – git merge --squash (1)" src="image/B21203_03_014.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.633.1">Figure 3.14 – git merge --squash (1)</span></p>
<p><span class="koboSpan" id="kobo.634.1">Let’s switch</span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.635.1"> back to the</span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.636.1"> mainline and perform a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.637.1">squash</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.638.1"> merge:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.639.1">
# Switch back to 'main' and perform a squash merge
$ git checkout main
$ git merge --squash add-basic-files</span></pre> <p><span class="koboSpan" id="kobo.640.1">The commits are then squashed and become a </span><span class="No-Break"><span class="koboSpan" id="kobo.641.1">single commit:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer051">
<span class="koboSpan" id="kobo.642.1"><img alt="Figure 3.15 – git merge --squash (2)" src="image/B21203_03_015.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.643.1">Figure 3.15 – git merge --squash (2)</span></p>
<p><span class="koboSpan" id="kobo.644.1">Then, Git will add uncommitted changes to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.645.1">main</span></strong><span class="koboSpan" id="kobo.646.1"> branch. </span><span class="koboSpan" id="kobo.646.2">It is time to complete the merge process. </span><span class="koboSpan" id="kobo.646.3">To complete the merge, you need to commit those </span><span class="No-Break"><span class="koboSpan" id="kobo.647.1">uncommitted changes:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.648.1">
$ git add .
</span><span class="koboSpan" id="kobo.648.2">$ git commit -m "Add repository standard docs"
$ git log --graph --oneline
* 6eb6df3 (HEAD -&gt; main) Add repository standard docs
* ffc2ed5 Add CONTRIBUTING.md
* 2c5ad11 Initial commit on main</span></pre> <p><span class="koboSpan" id="kobo.649.1">This will combine all the </span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.650.1">changes from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">add-multiple-features</span></strong><span class="koboSpan" id="kobo.652.1"> branch into a </span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.653.1">single new commit on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.654.1">main</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.655.1"> branch:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer052">
<span class="koboSpan" id="kobo.656.1"><img alt="Figure 3.16 – git merge --squash (3)" src="image/B21203_03_016.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.657.1">Figure 3.16 – git merge --squash (3)</span></p>
<h4><span class="koboSpan" id="kobo.658.1">Why use squash merges in DevOps and team collaboration?</span></h4>
<p><span class="koboSpan" id="kobo.659.1">Squash merges </span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.660.1">offer a unique set of benefits for DevOps and </span><span class="No-Break"><span class="koboSpan" id="kobo.661.1">collaborative development:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.662.1">Atomic changes</span></strong><span class="koboSpan" id="kobo.663.1">: A squashed </span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.664.1">merge creates a single commit that contains all the feature changes, making it easier to roll back </span><span class="No-Break"><span class="koboSpan" id="kobo.665.1">if needed.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.666.1">Reduced noise</span></strong><span class="koboSpan" id="kobo.667.1">: Squash merges eliminate the clutter of many small, perhaps experimental, commits from the main branch. </span><span class="koboSpan" id="kobo.667.2">This makes for a cleaner log history that’s easier to read </span><span class="No-Break"><span class="koboSpan" id="kobo.668.1">and understand.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.669.1">Strategic commit messages</span></strong><span class="koboSpan" id="kobo.670.1">: Squashing allows you to create a comprehensive commit message that can encapsulate the purpose and impact of a feature more effectively than a series of </span><span class="No-Break"><span class="koboSpan" id="kobo.671.1">smaller commits.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.672.1">However, it is worth noting that while squash merges can simplify history, they can also obfuscate it. </span><span class="koboSpan" id="kobo.672.2">Individual commits from the feature branch are lost in the main branch, making it hard to understand the development context of each separate change. </span><span class="koboSpan" id="kobo.672.3">Use this merge strategy judiciously and understand its impact on your </span><span class="No-Break"><span class="koboSpan" id="kobo.673.1">development history.</span></span></p>
<h4><span class="koboSpan" id="kobo.674.1">The ethics and pitfalls of squash merging</span></h4>
<p><span class="koboSpan" id="kobo.675.1">Squashing someone else’s commits can sometimes </span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">be problematic.</span></span></p>
<p><span class="koboSpan" id="kobo.677.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.678.1">git merge --squash</span></strong><span class="koboSpan" id="kobo.679.1"> command </span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.680.1">is a powerful tool for consolidating multiple commits into a single one. </span><span class="koboSpan" id="kobo.680.2">While this function keeps your commit history clean and manageable, it raises ethical and practical issues when used on commits made </span><span class="No-Break"><span class="koboSpan" id="kobo.681.1">by others.</span></span></p>
<p><span class="koboSpan" id="kobo.682.1">It is important to be aware of the following concerns in </span><span class="No-Break"><span class="koboSpan" id="kobo.683.1">team collaboration:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.684.1">Authorship misattribution</span></strong><span class="koboSpan" id="kobo.685.1">: By default, the person who performs the squash becomes the author of the consolidated commit, effectively erasing the original contributors’ history. </span><span class="koboSpan" id="kobo.685.2">This could demotivate team members by not recognizing </span><span class="No-Break"><span class="koboSpan" id="kobo.686.1">their contributions.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.687.1">History alteration</span></strong><span class="koboSpan" id="kobo.688.1">: The command alters the commit history, which could be considered disrespectful to the original </span><span class="No-Break"><span class="koboSpan" id="kobo.689.1">author’s work.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.690.1">If maintaining the integrity of individual </span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.691.1">commits is important, consider using a standard merge. </span><span class="koboSpan" id="kobo.691.2">This may result in a messier history, but it preserves the work and recognition of </span><span class="No-Break"><span class="koboSpan" id="kobo.692.1">all contributors.</span></span></p>
<p><span class="koboSpan" id="kobo.693.1">Additionally, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.694.1">git rebase</span></strong><span class="koboSpan" id="kobo.695.1"> command</span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.696.1"> offers more control over the commit history, which is useful for cleaning up or rearranging your own work without </span><span class="No-Break"><span class="koboSpan" id="kobo.697.1">affecting others.</span></span></p>
<p><span class="koboSpan" id="kobo.698.1">Let’s explore this </span><span class="No-Break"><span class="koboSpan" id="kobo.699.1">command next.</span></span></p>
<h3><span class="koboSpan" id="kobo.700.1">git rebase – Rewriting for clarity</span></h3>
<p><span class="koboSpan" id="kobo.701.1">Rebasing is another powerful technique in Git that differs significantly from merging. </span><span class="koboSpan" id="kobo.701.2">The primary difference between merging and rebasing is how they integrate changes. </span><span class="koboSpan" id="kobo.701.3">While </span><strong class="source-inline"><span class="koboSpan" id="kobo.702.1">git merge</span></strong><span class="koboSpan" id="kobo.703.1"> integrates changes from</span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.704.1"> one branch into another, </span><strong class="source-inline"><span class="koboSpan" id="kobo.705.1">git rebase</span></strong><span class="koboSpan" id="kobo.706.1"> moves or combines a sequence of commits to a new </span><span class="No-Break"><span class="koboSpan" id="kobo.707.1">base commit.</span></span></p>
<p><span class="koboSpan" id="kobo.708.1">In the team collaboration context, rebasing is used to maintain a linear project history, which simplifies debugging and makes code reviews easier. </span><span class="koboSpan" id="kobo.708.2">However, rebase comes with its share of complexities and pitfalls and is generally best used in </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">specific circumstances.</span></span></p>
<p><span class="koboSpan" id="kobo.710.1">Before delving into the hands-on tutorial, let’s understand how </span><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">git rebase</span></strong><span class="koboSpan" id="kobo.712.1"> works at a high level. </span><span class="koboSpan" id="kobo.712.2">The primary utility of rebasing is to place the changes from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.713.1">feature</span></strong><span class="koboSpan" id="kobo.714.1"> branch on top of </span><span class="No-Break"><span class="koboSpan" id="kobo.715.1">another branch.</span></span></p>
<p><span class="koboSpan" id="kobo.716.1">For example, consider the </span><span class="No-Break"><span class="koboSpan" id="kobo.717.1">following branches:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer053">
<span class="koboSpan" id="kobo.718.1"><img alt="Figure 3.17 – Rebasing (1)" src="image/B21203_03_017.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.719.1">Figure 3.17 – Rebasing (1)</span></p>
<p><span class="koboSpan" id="kobo.720.1">After rebasing </span><strong class="source-inline"><span class="koboSpan" id="kobo.721.1">feature</span></strong><span class="koboSpan" id="kobo.722.1"> onto </span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">main</span></strong><span class="koboSpan" id="kobo.724.1">, your branch might look </span><span class="No-Break"><span class="koboSpan" id="kobo.725.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer054">
<span class="koboSpan" id="kobo.726.1"><img alt="Figure 3.18 – Rebasing (2)" src="image/B21203_03_018.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.727.1">Figure 3.18 – Rebasing (2)</span></p>
<p><span class="koboSpan" id="kobo.728.1">Finally, you </span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.729.1">can merge back to main, at which point a fast-forward merge can </span><span class="No-Break"><span class="koboSpan" id="kobo.730.1">be performed:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer055">
<span class="koboSpan" id="kobo.731.1"><img alt="Figure 3.19 – Rebasing (3)" src="image/B21203_03_019.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.732.1">Figure 3.19 – Rebasing (3)</span></p>
<h4><span class="koboSpan" id="kobo.733.1">Practical steps for git rebase</span></h4>
<p><span class="koboSpan" id="kobo.734.1">Let’s take a practical</span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.735.1"> example with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.736.1">main</span></strong><span class="koboSpan" id="kobo.737.1"> branch and a </span><strong class="source-inline"><span class="koboSpan" id="kobo.738.1">new-feature</span></strong><span class="koboSpan" id="kobo.739.1"> branch. </span><span class="koboSpan" id="kobo.739.2">Here’s how to </span><span class="No-Break"><span class="koboSpan" id="kobo.740.1">perform rebase:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.741.1">
# Initialize a new repository
$ mkdir try-git-rebase
$ cd try-git-rebase
$ git init
# Add and commit initial README.md to main
$ echo "# My Rebase Project" &gt; README.md
$ git add README.md
$ git commit -m "Initial commit on main"
# Create and switch to a new branch 'new-feature'
$ git checkout -b new-feature
# Make some changes, add and commit them
$ echo "This is a new feature." </span><span class="koboSpan" id="kobo.741.2">&gt;&gt; NewFeature.md
$ git add NewFeature.md
$ git commit -m "Add new feature"</span></pre> <p><span class="koboSpan" id="kobo.742.1">At this point, your </span><a id="_idIndexMarker296"/><span class="koboSpan" id="kobo.743.1">branch history may look something </span><span class="No-Break"><span class="koboSpan" id="kobo.744.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer056">
<span class="koboSpan" id="kobo.745.1"><img alt="Figure 3.20 – git rebase (1)" src="image/B21203_03_020.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.746.1">Figure 3.20 – git rebase (1)</span></p>
<p><span class="koboSpan" id="kobo.747.1">Now, let’s say new </span><a id="_idIndexMarker297"/><span class="koboSpan" id="kobo.748.1">commits have been added to </span><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">main</span></strong><span class="koboSpan" id="kobo.750.1"> while you were working </span><span class="No-Break"><span class="koboSpan" id="kobo.751.1">on </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.752.1">new-feature</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.753.1">:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.754.1">
# Switch back to 'main' and add new commits
$ git checkout main
$ echo "Updates to the project." </span><span class="koboSpan" id="kobo.754.2">&gt;&gt; Updates.md
$ git add Updates.md
$ git commit -m "Update main"</span></pre> <p><span class="koboSpan" id="kobo.755.1">Your commit graph </span><span class="No-Break"><span class="koboSpan" id="kobo.756.1">now diverges:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer057">
<span class="koboSpan" id="kobo.757.1"><img alt="Figure 3.21 – git rebase (2)" src="image/B21203_03_021.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.758.1">Figure 3.21 – git rebase (2)</span></p>
<p><span class="koboSpan" id="kobo.759.1">Now, rebase </span><strong class="source-inline"><span class="koboSpan" id="kobo.760.1">new-feature</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.761.1">onto </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.762.1">main</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.763.1">:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.764.1">
# Switch to 'new-feature' and rebase onto main
git checkout new-feature
git rebase main</span></pre> <p><span class="koboSpan" id="kobo.765.1">Let’s check </span><a id="_idIndexMarker298"/><span class="koboSpan" id="kobo.766.1">what it looks </span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">like now:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.768.1">
$ git log --graph --online
* 43ea59e (HEAD -&gt; new-feature) Add new feature
* 16e1878 (main) Update main
* 3021494 Initial commit on main</span></pre> <p><span class="koboSpan" id="kobo.769.1">After this, your branches will look </span><span class="No-Break"><span class="koboSpan" id="kobo.770.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer058">
<span class="koboSpan" id="kobo.771.1"><img alt="Figure 3.22 – git rebase (3)" src="image/B21203_03_022.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.772.1">Figure 3.22 – git rebase (3)</span></p>
<p><span class="koboSpan" id="kobo.773.1">Now it is time to merge and complete the </span><strong class="source-inline"><span class="koboSpan" id="kobo.774.1">git </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.775.1">rebase</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.776.1"> process:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.777.1">
# Switch to 'main' and perform fast-forward-merge
$ git checkout main
$ git merge new-feature</span></pre> <p><span class="koboSpan" id="kobo.778.1">When a fast-forward </span><a id="_idIndexMarker299"/><span class="koboSpan" id="kobo.779.1">merge is performed, the HEADs of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.780.1">main</span></strong><span class="koboSpan" id="kobo.781.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.782.1">new-feature</span></strong><span class="koboSpan" id="kobo.783.1"> branches will be the corresponding commits, </span><span class="No-Break"><span class="koboSpan" id="kobo.784.1">as shown:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer059">
<span class="koboSpan" id="kobo.785.1"><img alt="Figure 3.23 – git rebase (4)" src="image/B21203_03_023.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.786.1">Figure 3.23 – git rebase (4)</span></p>
<h4><span class="koboSpan" id="kobo.787.1">Why rebasing is powerful in DevOps and team collaboration</span></h4>
<p><span class="koboSpan" id="kobo.788.1">The primary advantage of rebasing in a DevOps culture is that it results in a much cleaner project history than merging. </span><span class="koboSpan" id="kobo.788.2">Cleaner histories are easier to debug and simpler to understand, and they make more logical sense to developers who join the project at a </span><span class="No-Break"><span class="koboSpan" id="kobo.789.1">later time.</span></span></p>
<p><span class="koboSpan" id="kobo.790.1">Here are </span><span class="No-Break"><span class="koboSpan" id="kobo.791.1">some </span></span><span class="No-Break"><a id="_idIndexMarker300"/></span><span class="No-Break"><span class="koboSpan" id="kobo.792.1">benefits:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.793.1">Linear history</span></strong><span class="koboSpan" id="kobo.794.1">: It is easier to understand than the non-linear history created by </span><span class="No-Break"><span class="koboSpan" id="kobo.795.1">git merge</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.796.1">Simplified debugging</span></strong><span class="koboSpan" id="kobo.797.1">: With a cleaner history, tracking down when a particular bug was introduced </span><span class="No-Break"><span class="koboSpan" id="kobo.798.1">becomes easier</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.799.1">Code hygiene</span></strong><span class="koboSpan" id="kobo.800.1">: Rebasing encourages you to squash fixup commits or split larger commits, making your changes more understandable compared to the </span><span class="No-Break"><span class="koboSpan" id="kobo.801.1">other developers’</span></span></li>
</ul>
<h4><span class="koboSpan" id="kobo.802.1">The cautions and pitfalls of git rebase</span></h4>
<p><span class="koboSpan" id="kobo.803.1">There are golden </span><a id="_idIndexMarker301"/><span class="koboSpan" id="kobo.804.1">rules to follow: </span><em class="italic"><span class="koboSpan" id="kobo.805.1">do not rebase public (team) branches</span></em><span class="koboSpan" id="kobo.806.1">. </span><span class="koboSpan" id="kobo.806.2">One such cardinal rule is to avoid rebasing public branches. </span><span class="koboSpan" id="kobo.806.3">Rebasing can be a great tool for cleaning up a feature branch, but when done on branches that are publicly available, it can become </span><span class="No-Break"><span class="koboSpan" id="kobo.807.1">a disaster.</span></span></p>
<p><span class="koboSpan" id="kobo.808.1">Here are the things to consider when you use </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">git rebase</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.810.1">:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.811.1">Conflicts for collaborators</span></strong><span class="koboSpan" id="kobo.812.1">: Imagine that you have rebased a public branch and pushed the changes. </span><span class="koboSpan" id="kobo.812.2">Other developers who have already pulled the old version of the branch now have a divergent history. </span><span class="koboSpan" id="kobo.812.3">When they try to push their changes, Git will reject the push, forcing them to reconcile the histories. </span><span class="koboSpan" id="kobo.812.4">This creates extra work and increases the chance of </span><span class="No-Break"><span class="koboSpan" id="kobo.813.1">merge conflicts.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.814.1">Complex merges</span></strong><span class="koboSpan" id="kobo.815.1">: After a public branch has been rebased and the history altered, merging it with other branches can become a real challenge. </span><span class="koboSpan" id="kobo.815.2">Because Git uses the commit history to determine how to integrate changes, modifying that history can make merging far more complicated than it needs </span><span class="No-Break"><span class="koboSpan" id="kobo.816.1">to be.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.817.1">Loss of context</span></strong><span class="koboSpan" id="kobo.818.1">: Rebasing can squash commits together or change their order, which may result in a loss of context for those changes. </span><span class="koboSpan" id="kobo.818.2">This makes debugging more difficult and can complicate the task of understanding the development </span><a id="_idIndexMarker302"/><span class="koboSpan" id="kobo.819.1">process that led to the current </span><span class="No-Break"><span class="koboSpan" id="kobo.820.1">code base.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.821.1">Rebasing can be complex and risky, especially for inexperienced developers. </span><span class="koboSpan" id="kobo.821.2">In worst-case scenarios, you may have to resolve many conflicts, leading to errors and bugs if not </span><span class="No-Break"><span class="koboSpan" id="kobo.822.1">done carefully.</span></span></p>
<p><span class="koboSpan" id="kobo.823.1">By understanding and using </span><strong class="source-inline"><span class="koboSpan" id="kobo.824.1">git merge</span></strong><span class="koboSpan" id="kobo.825.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.826.1">git rebase</span></strong><span class="koboSpan" id="kobo.827.1">, you can handle pretty much any situation that requires combining different lines of development. </span><span class="koboSpan" id="kobo.827.2">Each has its place in a Git command, and understanding when to use each one is the key to maintaining a clean and understandable code base—something that is highly valuable in the world </span><span class="No-Break"><span class="koboSpan" id="kobo.828.1">of DevOps.</span></span></p>
<h3><span class="koboSpan" id="kobo.829.1">git cherry-pick – Picking specific commits</span></h3>
<p><span class="koboSpan" id="kobo.830.1">One of the most flexible tools in the Git commands is the </span><strong class="source-inline"><span class="koboSpan" id="kobo.831.1">git cherry-pick</span></strong><span class="koboSpan" id="kobo.832.1"> command. </span><span class="koboSpan" id="kobo.832.2">While the </span><a id="_idIndexMarker303"/><span class="koboSpan" id="kobo.833.1">previous merge methods were mainly used for integrating entire branches, </span><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">git cherry-pick</span></strong><span class="koboSpan" id="kobo.835.1"> allows you to select specific commits from one branch and apply them to another branch. </span><span class="koboSpan" id="kobo.835.2">This method can be incredibly useful when you need to apply just a few specific changes without taking all the modifications from a </span><span class="No-Break"><span class="koboSpan" id="kobo.836.1">different branch.</span></span></p>
<p><span class="koboSpan" id="kobo.837.1">Imagine you have two branches, </span><strong class="source-inline"><span class="koboSpan" id="kobo.838.1">main</span></strong><span class="koboSpan" id="kobo.839.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.840.1">feature</span></strong><span class="koboSpan" id="kobo.841.1">. </span><span class="koboSpan" id="kobo.841.2">You realize that one or two commits from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.842.1">feature</span></strong><span class="koboSpan" id="kobo.843.1"> branch should be moved to </span><strong class="source-inline"><span class="koboSpan" id="kobo.844.1">main</span></strong><span class="koboSpan" id="kobo.845.1">, but you are not ready to merge the entire branch. </span><span class="koboSpan" id="kobo.845.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.846.1">git cherry-pick</span></strong><span class="koboSpan" id="kobo.847.1"> command allows you to do </span><span class="No-Break"><span class="koboSpan" id="kobo.848.1">just that:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer060">
<span class="koboSpan" id="kobo.849.1"><img alt="Figure 3.24 – Cherry-picking (1)" src="image/B21203_03_024.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.850.1">Figure 3.24 – Cherry-picking (1)</span></p>
<p><span class="koboSpan" id="kobo.851.1">You can cherry-pick the</span><a id="_idIndexMarker304"/><span class="koboSpan" id="kobo.852.1"> changes from a specific commit in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">feature</span></strong><span class="koboSpan" id="kobo.854.1"> branch and apply them to </span><strong class="source-inline"><span class="koboSpan" id="kobo.855.1">main</span></strong><span class="koboSpan" id="kobo.856.1">. </span><span class="koboSpan" id="kobo.856.2">This action will create a new commit on the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.857.1">main</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.858.1"> branch:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer061">
<span class="koboSpan" id="kobo.859.1"><img alt="Figure 3.25 – Cherry-picking (2)" src="image/B21203_03_025.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.860.1">Figure 3.25 – Cherry-picking (2)</span></p>
<h4><span class="koboSpan" id="kobo.861.1">Practical steps for cherry-picking</span></h4>
<p><span class="koboSpan" id="kobo.862.1">Now let’s go over the</span><a id="_idIndexMarker305"/><span class="koboSpan" id="kobo.863.1"> practical steps for cherry-picking changes and merging them into a branch. </span><span class="koboSpan" id="kobo.863.2">Each commit adds a file to each of them. </span><span class="koboSpan" id="kobo.863.3">Let’s take some of those commits and merge them into </span><strong class="source-inline"><span class="koboSpan" id="kobo.864.1">main</span></strong><span class="koboSpan" id="kobo.865.1">. </span><span class="koboSpan" id="kobo.865.2">First, we add </span><span class="No-Break"><span class="koboSpan" id="kobo.866.1">the files:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.867.1">
# Initialize a new repository
$ mkdir try-cherry-pick
$ cd try-cherry-pick
$ git init
# Add and commit initial README.md to main
$ echo "# My Project" &gt; README.md
$ git add README.md
$ git commit -m "Initial commit"
# Create and switch to a new branch 'add-base-documents'
$ git checkout -b add-base-documents
# Make changes and commit
# Add CONTRIBUTING.md
$ echo "# CONTRIBUTING" &gt;&gt; CONTRIBUTING.md
$ git add CONTRIBUTING.md
$ git commit -m "Add CONTRIBUTING.md"
# Add LICENSE.txt
$ echo "LICENSE" &gt;&gt; LICENSE.txt
$ git add LICENSE.txt
$ git commit -m "Add LICENSE.txt"
# Take a look at the 'add-base-documents' branch log
$ git log add-base-documents --graph --oneline
* 02ee2b4 (HEAD -&gt; add-base-documents) Add LICENSE.txt
* a80e8ad Add CONTRIBUTING.md
* cfb060a (main) Initial commit</span></pre> <p><span class="koboSpan" id="kobo.868.1">Now the branches </span><a id="_idIndexMarker306"/><span class="koboSpan" id="kobo.869.1">look like those in the </span><span class="No-Break"><span class="koboSpan" id="kobo.870.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer062">
<span class="koboSpan" id="kobo.871.1"><img alt="Figure 3.26 – git cherry-pick (1)" src="image/B21203_03_026.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.872.1">Figure 3.26 – git cherry-pick (1)</span></p>
<p><span class="koboSpan" id="kobo.873.1">Now, let’s only pick the </span><strong class="source-inline"><span class="koboSpan" id="kobo.874.1">a80e8ad</span></strong><span class="koboSpan" id="kobo.875.1"> commit and put it on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.876.1">main</span></strong><span class="koboSpan" id="kobo.877.1"> branch. </span><span class="koboSpan" id="kobo.877.2">Please replace the hash value in </span><span class="No-Break"><span class="koboSpan" id="kobo.878.1">your environment:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.879.1">
# Now switch back to the 'main' branch and cherry-pick the commit
$ git checkout main
$ git cherry-pick a80e8ad
[main 9a36741] Add CONTRIBUTING.md
Date: Sun Oct 29 16:04:56 2023 +0900
1 file changed, 1 insertion(+)
create mode 100644 CONTRIBUTING.md
# Let's check the 'main' branch log
$ git log --graph --oneline
* 9a36741 (HEAD -&gt; main) Add CONTRIBUTING.md
* cfb060a Initial commit</span></pre> <p><span class="koboSpan" id="kobo.880.1">After you have successfully cherry-picked the commit, a new commit will be added to your current branch (</span><strong class="source-inline"><span class="koboSpan" id="kobo.881.1">main</span></strong><span class="koboSpan" id="kobo.882.1"> in this example) and it will include the changes from the cherry-picked commit. </span><span class="koboSpan" id="kobo.882.2">Note</span><a id="_idIndexMarker307"/><span class="koboSpan" id="kobo.883.1"> that the new commit has the same changes but a different commit </span><span class="No-Break"><span class="koboSpan" id="kobo.884.1">hash value:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer063">
<span class="koboSpan" id="kobo.885.1"><img alt="Figure 3.27 – git cherry-pick (2)" src="image/B21203_03_027.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.886.1">Figure 3.27 – git cherry-pick (2)</span></p>
<h4><span class="koboSpan" id="kobo.887.1">Why cherry-pick is useful in DevOps and team collaboration</span></h4>
<p><span class="koboSpan" id="kobo.888.1">Team development requires flexible development. </span><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">git cherry-pick</span></strong><span class="koboSpan" id="kobo.890.1"> is a useful command in collaborative coding environments, allowing teams to selectively integrate changes and maintain </span><span class="No-Break"><span class="koboSpan" id="kobo.891.1">code integrity.</span></span></p>
<p><span class="koboSpan" id="kobo.892.1">Let’s see what value </span><strong class="source-inline"><span class="koboSpan" id="kobo.893.1">cherry-pick</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.894.1">can offer:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.895.1">Selective integration</span></strong><span class="koboSpan" id="kobo.896.1">: It allows</span><a id="_idIndexMarker308"/><span class="koboSpan" id="kobo.897.1"> specific bug fixes or features to be moved into production without having to move all changes from a </span><span class="No-Break"><span class="koboSpan" id="kobo.898.1">development branch</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.899.1">Easy reversion</span></strong><span class="koboSpan" id="kobo.900.1">: If something goes wrong, you only need to revert a small change rather than an entire </span><span class="No-Break"><span class="koboSpan" id="kobo.901.1">branch merge</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.902.1">Clean history</span></strong><span class="koboSpan" id="kobo.903.1">: Keeps your Git history tidy by only including relevant commits, making it easier to read </span><span class="No-Break"><span class="koboSpan" id="kobo.904.1">and understand</span></span></li>
</ul>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.905.1">git cherry-pick</span></strong><span class="koboSpan" id="kobo.906.1"> offers a high level of precision for integrating changes between branches. </span><span class="koboSpan" id="kobo.906.2">It allows you to select exactly which commits to include, providing granular control over your project history. </span><span class="koboSpan" id="kobo.906.3">This makes it an invaluable tool for any DevOps engineer aiming for a flexible and efficient version </span><span class="No-Break"><span class="koboSpan" id="kobo.907.1">control workflow.</span></span></p>
<p><span class="koboSpan" id="kobo.908.1">After exploring the various merging strategies in Git, you might be asking yourself, “</span><em class="italic"><span class="koboSpan" id="kobo.909.1">Which method should I use?</span></em><span class="koboSpan" id="kobo.910.1">” The answer, as with most things in engineering, is, “</span><em class="italic"><span class="koboSpan" id="kobo.911.1">It depends.</span></em><span class="koboSpan" id="kobo.912.1">” Several factors come into play when determining which Git merge strategy best suits your needs. </span><span class="koboSpan" id="kobo.912.2">Additionally, it is worth noting that you do not have to stick to a single method; you can vary your approach depending on the situation. </span><span class="koboSpan" id="kobo.912.3">Understanding these factors can help you make an </span><span class="No-Break"><span class="koboSpan" id="kobo.913.1">informed decision.</span></span></p>
<p><span class="koboSpan" id="kobo.914.1">Let’s check the</span><a id="_idIndexMarker309"/><span class="koboSpan" id="kobo.915.1"> following factors to see how you </span><span class="No-Break"><span class="koboSpan" id="kobo.916.1">should choose:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.917.1">Project complexity</span></strong><span class="koboSpan" id="kobo.918.1">: Complex projects with multiple contributors and parallel development lines may require a more consistent merging approach to minimize conflicts. </span><span class="koboSpan" id="kobo.918.2">Platforms such as GitHub allow you to set merge strategies for </span><span class="No-Break"><span class="koboSpan" id="kobo.919.1">your projects.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.920.1">Team preferences and skill level</span></strong><span class="koboSpan" id="kobo.921.1">: The merging strategy you choose should be one that your team is comfortable with. </span><span class="koboSpan" id="kobo.921.2">This could depend on the experience level of the team members and their familiarity with Git commands and practices. </span><span class="koboSpan" id="kobo.921.3">When a development team consists of members with varying skill levels, sticking to simpler methods such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.922.1">git merge</span></strong><span class="koboSpan" id="kobo.923.1"> can reduce the chances of mistakes. </span><span class="koboSpan" id="kobo.923.2">However, if the majority of the team is experienced, you may want to leverage the benefits of </span><strong class="source-inline"><span class="koboSpan" id="kobo.924.1">rebase</span></strong><span class="koboSpan" id="kobo.925.1"> to maintain a cleaner Git history while also facilitating </span><span class="No-Break"><span class="koboSpan" id="kobo.926.1">smoother communication.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.927.1">Desired cleanliness of Git history</span></strong><span class="koboSpan" id="kobo.928.1">: If a clean, linear Git history is of utmost importance to you, then opting for fast-forward merges or rebasing might be the best route. </span><span class="koboSpan" id="kobo.928.2">On the other hand, if you value detailed documentation of your project’s development process, a non-fast-forward merge would be a better choice for maintaining a comprehensive record </span><span class="No-Break"><span class="koboSpan" id="kobo.929.1">of changes.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.930.1">As you move forward, let the knowledge from this section guide you in choosing the appropriate merge approach for your projects. </span><span class="koboSpan" id="kobo.930.2">Practice with real-world scenarios to gain confidence. </span><span class="koboSpan" id="kobo.930.3">Remember, there is no one-size-fits-all answer in Git—flexibility and adaptability are </span><span class="No-Break"><span class="koboSpan" id="kobo.931.1">your allies</span></span></p>
<h1 id="_idParaDest-64"><a id="_idTextAnchor065"/><span class="koboSpan" id="kobo.932.1">Navigating conflicts</span></h1>
<p><span class="koboSpan" id="kobo.933.1">In a collaborative development </span><a id="_idIndexMarker310"/><span class="koboSpan" id="kobo.934.1">environment, conflicts are not just possible—they are inevitable. </span><span class="koboSpan" id="kobo.934.2">When multiple developers are working on the same code base, or even the same files, there is a good chance that changes will overlap, leading to conflicts. </span><span class="koboSpan" id="kobo.934.3">Navigating and resolving these conflicts is crucial for maintaining a smooth and efficient </span><span class="No-Break"><span class="koboSpan" id="kobo.935.1">DevOps workflow.</span></span></p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor066"/><span class="koboSpan" id="kobo.936.1">Why conflict happens</span></h2>
<p><span class="koboSpan" id="kobo.937.1">Conflicts generally occur</span><a id="_idIndexMarker311"/><span class="koboSpan" id="kobo.938.1"> when two branches have changes in the same line or section of a file and are then attempted to be merged. </span><span class="koboSpan" id="kobo.938.2">Git, as sophisticated as it is, can not decide which change to take precedence. </span><span class="koboSpan" id="kobo.938.3">The key to efficiently resolving these conflicts is understanding why they occur and being proactive in preventing them </span><span class="No-Break"><span class="koboSpan" id="kobo.939.1">when possible.</span></span></p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor067"/><span class="koboSpan" id="kobo.940.1">How to merge conflicts in Git</span></h2>
<p><span class="koboSpan" id="kobo.941.1">Let’s start with the basics. </span><span class="koboSpan" id="kobo.941.2">Conflict resolution</span><a id="_idIndexMarker312"/><span class="koboSpan" id="kobo.942.1"> in Git usually involves manual intervention. </span><span class="koboSpan" id="kobo.942.2">Here is how to go </span><span class="No-Break"><span class="koboSpan" id="kobo.943.1">about it:</span></span></p>
<ol>
<li><span class="koboSpan" id="kobo.944.1">Identify conflicts. </span><span class="koboSpan" id="kobo.944.2">Use </span><strong class="source-inline"><span class="koboSpan" id="kobo.945.1">git status</span></strong><span class="koboSpan" id="kobo.946.1"> to see which files </span><span class="No-Break"><span class="koboSpan" id="kobo.947.1">are conflicted.</span></span></li>
<li><span class="koboSpan" id="kobo.948.1">Examine the conflicted files. </span><span class="koboSpan" id="kobo.948.2">Open them up and look for the conflict markers (</span><strong class="source-inline"><span class="koboSpan" id="kobo.949.1">&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span></strong><span class="koboSpan" id="kobo.950.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.951.1">=======</span></strong><span class="koboSpan" id="kobo.952.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.953.1">&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span></strong><span class="koboSpan" id="kobo.954.1">). </span><span class="koboSpan" id="kobo.954.2">These markers delineate the changes from the </span><span class="No-Break"><span class="koboSpan" id="kobo.955.1">different branches:</span></span><pre class="source-code"><span class="koboSpan" id="kobo.956.1">
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
Someone's change is here
=======
Your change is here
&gt;&gt;&gt;&gt;&gt;&gt;&gt; branch-you-want-to-merge</span></pre></li> <li><span class="koboSpan" id="kobo.957.1">Resolve the conflicts. </span><span class="koboSpan" id="kobo.957.2">Choose which changes to keep. </span><span class="koboSpan" id="kobo.957.3">You can keep the changes from one branch, mix both, or even add something </span><span class="No-Break"><span class="koboSpan" id="kobo.958.1">entirely new.</span></span></li>
<li><span class="koboSpan" id="kobo.959.1">Commit the </span><a id="_idIndexMarker313"/><span class="koboSpan" id="kobo.960.1">resolved files. </span><span class="koboSpan" id="kobo.960.2">After resolving, you need to add the files to the staging area and </span><span class="No-Break"><span class="koboSpan" id="kobo.961.1">commit them.</span></span></li>
</ol>
<h2 id="_idParaDest-67"><a id="_idTextAnchor068"/><span class="koboSpan" id="kobo.962.1">How to resolve merge conflicts</span></h2>
<p><span class="koboSpan" id="kobo.963.1">Merge conflicts are</span><a id="_idIndexMarker314"/><span class="koboSpan" id="kobo.964.1"> inevitable in a collaborative development environment. </span><span class="koboSpan" id="kobo.964.2">The key is knowing how to resolve them efficiently. </span><span class="koboSpan" id="kobo.964.3">There are several patterns you can follow, depending on the nature of </span><span class="No-Break"><span class="koboSpan" id="kobo.965.1">the conflict.</span></span></p>
<h3><span class="koboSpan" id="kobo.966.1">When there is a definitive version to retain</span></h3>
<p><span class="koboSpan" id="kobo.967.1">If you have merged two </span><a id="_idIndexMarker315"/><span class="koboSpan" id="kobo.968.1">branches and want to fully accept one version over the other, you can opt to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.969.1">git checkout --ours</span></strong><span class="koboSpan" id="kobo.970.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.971.1">git </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.972.1">checkout --theirs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.973.1">:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.974.1">checkout --ours</span></strong><span class="koboSpan" id="kobo.975.1">: Use this command to keep the files from your branch when a merge </span><span class="No-Break"><span class="koboSpan" id="kobo.976.1">conflict arises:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.977.1">$ git checkout --ours -- &lt;file-path&gt;</span></strong></pre></li> <li><strong class="source-inline"><span class="koboSpan" id="kobo.978.1">checkout --theirs</span></strong><span class="koboSpan" id="kobo.979.1">: This command will retain the files from the merged branch, discarding the ones in your </span><span class="No-Break"><span class="koboSpan" id="kobo.980.1">current branch:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.981.1">$ git checkout --theirs -- &lt;file-path&gt;</span></strong></pre></li> </ul>
<p><span class="koboSpan" id="kobo.982.1">After running one of these commands, you will need to add the updated files to the staging area and then </span><span class="No-Break"><span class="koboSpan" id="kobo.983.1">commit them.</span></span></p>
<h3><span class="koboSpan" id="kobo.984.1">When you need to evaluate both versions</span></h3>
<p><span class="koboSpan" id="kobo.985.1">In cases where it is </span><a id="_idIndexMarker316"/><span class="koboSpan" id="kobo.986.1">not clear which version should take precedence, a more nuanced approach </span><span class="No-Break"><span class="koboSpan" id="kobo.987.1">is required.</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.988.1">Review the code</span></strong><span class="koboSpan" id="kobo.989.1">: Open the conflicting files in a text editor to manually inspect the clashing lines of code. </span><span class="koboSpan" id="kobo.989.2">Decide which parts to keep and edit the </span><span class="No-Break"><span class="koboSpan" id="kobo.990.1">files accordingly.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.991.1">Communication</span></strong><span class="koboSpan" id="kobo.992.1">: If necessary, consult with your teammates to decide which changes should be kept. </span><span class="koboSpan" id="kobo.992.2">This can be done through in-person discussions, virtual meetings, or code </span><span class="No-Break"><span class="koboSpan" id="kobo.993.1">review tools.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.994.1">Run tests</span></strong><span class="koboSpan" id="kobo.995.1">: Once you have resolved the conflicts manually, it is crucial to run tests to ensure that the code base is </span><span class="No-Break"><span class="koboSpan" id="kobo.996.1">still stable.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.997.1">Commit the changes</span></strong><span class="koboSpan" id="kobo.998.1">: After successful testing, stage the resolved files and commit them to </span><span class="No-Break"><span class="koboSpan" id="kobo.999.1">your repository.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1000.1">By carefully handling merge conflicts, you can help maintain a clean code base and foster better communication within </span><span class="No-Break"><span class="koboSpan" id="kobo.1001.1">your team.</span></span></p>
<h2 id="_idParaDest-68"><a id="_idTextAnchor069"/><span class="koboSpan" id="kobo.1002.1">Useful commands for supporting merge activities</span></h2>
<p><span class="koboSpan" id="kobo.1003.1">Merging</span><a id="_idIndexMarker317"/><span class="koboSpan" id="kobo.1004.1"> is an activity that comes with its own set of challenges. </span><span class="koboSpan" id="kobo.1004.2">Having the right set of tools and commands at your disposal can make the process smoother and less error-prone. </span><span class="koboSpan" id="kobo.1004.3">In this section, there are some useful Git commands that can help you effectively manage </span><span class="No-Break"><span class="koboSpan" id="kobo.1005.1">your merges.</span></span></p>
<h3><span class="koboSpan" id="kobo.1006.1">git diff – Spot the difference</span></h3>
<p><span class="koboSpan" id="kobo.1007.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1008.1">git diff</span></strong><span class="koboSpan" id="kobo.1009.1"> command</span><a id="_idIndexMarker318"/><span class="koboSpan" id="kobo.1010.1"> is an essential tool for identifying the differences between two sets of code. </span><span class="koboSpan" id="kobo.1010.2">It helps you see what exactly has changed between two branches or two commits, making it much easier to resolve conflicts when </span><span class="No-Break"><span class="koboSpan" id="kobo.1011.1">they arise.</span></span></p>
<p><span class="koboSpan" id="kobo.1012.1">You can compare the current branch to a target branch </span><span class="No-Break"><span class="koboSpan" id="kobo.1013.1">like so:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1014.1">
$ git diff feature-branch..main</span></pre> <p><span class="koboSpan" id="kobo.1015.1">This command displays a line-by-line comparison of the changes between </span><strong class="source-inline"><span class="koboSpan" id="kobo.1016.1">feature-branch</span></strong><span class="koboSpan" id="kobo.1017.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1018.1">main</span></strong><span class="koboSpan" id="kobo.1019.1">. </span><span class="koboSpan" id="kobo.1019.2">You can also focus on specific files or even specific lines of code, which makes it a flexible tool for spotting differences at </span><span class="No-Break"><span class="koboSpan" id="kobo.1020.1">various granularities.</span></span></p>
<p><span class="koboSpan" id="kobo.1021.1">Although Git does not have a built-in dry-run option for </span><strong class="source-inline"><span class="koboSpan" id="kobo.1022.1">git merge</span></strong><span class="koboSpan" id="kobo.1023.1">, you can simulate a merge to see what </span><span class="No-Break"><span class="koboSpan" id="kobo.1024.1">will happen:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1025.1">
$ git merge --no-commit --no-ff feature-branch
$ git diff --cached</span></pre> <p><span class="koboSpan" id="kobo.1026.1">This command</span><a id="_idIndexMarker319"/><span class="koboSpan" id="kobo.1027.1"> sequence attempts to merge changes from develop into your current branch but stops just before committing them. </span><span class="koboSpan" id="kobo.1027.2">You can then use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1028.1">git diff --cached</span></strong><span class="koboSpan" id="kobo.1029.1"> to view the staged changes. </span><span class="koboSpan" id="kobo.1029.2">If the merge is not what you expected, you can </span><span class="No-Break"><span class="koboSpan" id="kobo.1030.1">simply abort:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1031.1">
$ git merge --abort</span></pre> <h3><span class="koboSpan" id="kobo.1032.1">git mergetool – A simplified guide tooling to visual conflict resolution</span></h3>
<p><span class="koboSpan" id="kobo.1033.1">When you run into a merge</span><a id="_idIndexMarker320"/><span class="koboSpan" id="kobo.1034.1"> conflict that’s challenging to resolve manually, or if you are more comfortable with a graphical interface, Git’s built-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1035.1">git mergetool</span></strong><span class="koboSpan" id="kobo.1036.1"> can come to </span><span class="No-Break"><span class="koboSpan" id="kobo.1037.1">your rescue.</span></span></p>
<p><span class="koboSpan" id="kobo.1038.1">The following items can </span><span class="No-Break"><span class="koboSpan" id="kobo.1039.1">be set:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.1040.1">Choose your merge tool</span></strong><span class="koboSpan" id="kobo.1041.1">: First, decide which merge tool you’d like to use. </span><span class="koboSpan" id="kobo.1041.2">Common options include </span><strong class="source-inline"><span class="koboSpan" id="kobo.1042.1">kdiff3</span></strong><span class="koboSpan" id="kobo.1043.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1044.1">meld</span></strong><span class="koboSpan" id="kobo.1045.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.1046.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1047.1">vimdiff</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1048.1">.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1049.1">Global configuration</span></strong><span class="koboSpan" id="kobo.1050.1">: Set your chosen tool as the default for all your Git repositories with the </span><span class="No-Break"><span class="koboSpan" id="kobo.1051.1">following command:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1052.1"># For example, if you chose vimdiff, you would run:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1053.1">$ git config --global merge.tool vimdiff</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.1054.1">Once configured, you can activate </span><strong class="source-inline"><span class="koboSpan" id="kobo.1055.1">git mergetool</span></strong><span class="koboSpan" id="kobo.1056.1"> whenever you face a </span><span class="No-Break"><span class="koboSpan" id="kobo.1057.1">merge conflict:</span></span></p><pre class="source-code"><strong class="bold"><span class="koboSpan" id="kobo.1058.1">$ git mergetool</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.1059.1">This command opens your chosen graphical tool and displays the conflicting changes side by side. </span><span class="koboSpan" id="kobo.1059.2">This interface simplifies the process of understanding conflicts and deciding which changes to keep. </span><span class="koboSpan" id="kobo.1059.3">This setting allows you to specify not only command line tools but also modern tools such as Visual Studio Code to resolve </span><span class="No-Break"><span class="koboSpan" id="kobo.1060.1">merges</span></span><span class="No-Break"><a id="_idIndexMarker321"/></span><span class="No-Break"><span class="koboSpan" id="kobo.1061.1"> graphically.</span></span></p></li> </ul>
<p><span class="koboSpan" id="kobo.1062.1">By following these straightforward steps, you can resolve complex merge conflicts in a more intuitive way, making the process accessible for team members of all </span><span class="No-Break"><span class="koboSpan" id="kobo.1063.1">skill levels.</span></span></p>
<p><span class="koboSpan" id="kobo.1064.1">In a nutshell, conflict resolution is an essential skill for any engineer. </span><span class="koboSpan" id="kobo.1064.2">While conflicts can be complex and challenging, knowing how to navigate them efficiently can make your development workflow much smoother. </span><span class="koboSpan" id="kobo.1064.3">It is not just about resolving the conflicts themselves but understanding the underlying issues that lead to them. </span><span class="koboSpan" id="kobo.1064.4">This nuanced approach is crucial for fostering better communication and collaboration within your </span><span class="No-Break"><span class="koboSpan" id="kobo.1065.1">development team.</span></span></p>
<p><span class="koboSpan" id="kobo.1066.1">As team development progresses, projects become more complex. </span><span class="koboSpan" id="kobo.1066.2">Conflicts are inevitable. </span><span class="koboSpan" id="kobo.1066.3">Conflict is a great opportunity to help your team to improve its collaboration skills. </span><span class="koboSpan" id="kobo.1066.4">You should not be afraid of conflicts, and you should also learn how to communicate best for your team by solving them one </span><span class="No-Break"><span class="koboSpan" id="kobo.1067.1">by one.</span></span></p>
<h1 id="_idParaDest-69"><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.1068.1">Mastering better collaboration</span></h1>
<p><span class="koboSpan" id="kobo.1069.1">Up until now, we have discussed how to handle merges and resolve conflicts in Git. </span><span class="koboSpan" id="kobo.1069.2">We have seen that you can clean up your local changes with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1070.1">git merge --squash</span></strong><span class="koboSpan" id="kobo.1071.1"> or adjust commit history with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1072.1">git rebase</span></strong><span class="koboSpan" id="kobo.1073.1">. </span><span class="koboSpan" id="kobo.1073.2">While it is great to keep your workspace neat, the ideal scenario is to maintain a clean code base, especially when you push to a shared environment. </span><span class="koboSpan" id="kobo.1073.3">Next, let’s talk about the commands that enable you to be an excellent collaborator, whether you are an individual contributor or a team leader managing the main </span><span class="No-Break"><span class="koboSpan" id="kobo.1074.1">shared branch.</span></span></p>
<h2 id="_idParaDest-70"><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.1075.1">Rolling back time</span></h2>
<p><span class="koboSpan" id="kobo.1076.1">In any collaborative project, mistakes are inevitable. </span><span class="koboSpan" id="kobo.1076.2">Even if it was not a mistake, there will be many times you will want to rewind and go back in time. </span><span class="koboSpan" id="kobo.1076.3">Whether it is a bad commit that breaks the build or a feature that did not pan out as expected, the ability to roll back changes is crucial. </span><span class="koboSpan" id="kobo.1076.4">Two commands that are indispensable for this are </span><strong class="source-inline"><span class="koboSpan" id="kobo.1077.1">git reset</span></strong><span class="koboSpan" id="kobo.1078.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1079.1">git revert</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1080.1">.</span></span></p>
<h3><span class="koboSpan" id="kobo.1081.1">git reset – Rolling back changes</span></h3>
<p><span class="koboSpan" id="kobo.1082.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1083.1">git reset</span></strong><span class="koboSpan" id="kobo.1084.1"> command</span><a id="_idIndexMarker322"/><span class="koboSpan" id="kobo.1085.1"> allows you to </span><em class="italic"><span class="koboSpan" id="kobo.1086.1">rewind</span></em><span class="koboSpan" id="kobo.1087.1"> your Git history, essentially moving HEAD and, optionally, the working directory to a specific commit. </span><span class="koboSpan" id="kobo.1087.2">This is incredibly powerful but should be used cautiously. </span><span class="koboSpan" id="kobo.1087.3">There are several different ways to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1088.1">git reset</span></strong><span class="koboSpan" id="kobo.1089.1">. </span><span class="koboSpan" id="kobo.1089.2">Know them so that you can organize your </span><span class="No-Break"><span class="koboSpan" id="kobo.1090.1">environment efficiently:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.1091.1">Soft reset</span></strong><span class="koboSpan" id="kobo.1092.1">: This </span><a id="_idIndexMarker323"/><span class="koboSpan" id="kobo.1093.1">keeps your working directory and index intact but moves HEAD. </span><span class="koboSpan" id="kobo.1093.2">This command is used when you want to leave the index working tree untouched and only undo </span><span class="No-Break"><span class="koboSpan" id="kobo.1094.1">the commit:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1095.1">$ git reset --soft &lt;commit hash&gt;</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.1096.1"> The following is the area of impact of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1097.1">git reset --</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1098.1">soft</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1099.1"> command:</span></span></p></li> </ul>
<div>
<span class="koboSpan" id="kobo.1100.1"><img alt="Figure 3.28 – git reset --soft" src="image/B21203_03_028.png"/></span>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1101.1">Figure 3.28 – git reset --soft</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.1102.1">Mixed reset</span></strong><span class="koboSpan" id="kobo.1103.1">: This </span><a id="_idIndexMarker324"/><span class="koboSpan" id="kobo.1104.1">resets the index but keeps the working directory unchanged. </span><span class="koboSpan" id="kobo.1104.2">This command is used when you want to undo only what you </span><strong class="source-inline"><span class="koboSpan" id="kobo.1105.1">git add</span></strong><span class="koboSpan" id="kobo.1106.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1107.1">git commit</span></strong><span class="koboSpan" id="kobo.1108.1">. </span><span class="koboSpan" id="kobo.1108.2">File changes will remain; this is the default when no options are specified with </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1109.1">git reset</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1110.1">:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1111.1">$ git reset --mixed &lt;commit hash&gt;</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.1112.1">The following is the area of impact of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1113.1">git reset --</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1114.1">mixed</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1115.1"> command:</span></span></p></li> </ul>
<div>
<div class="IMG---Figure" id="_idContainer064">
<span class="koboSpan" id="kobo.1116.1"><img alt="Figure 3.29 – git reset --mixed" src="image/B21203_03_029.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1117.1">Figure 3.29 – git reset --mixed</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.1118.1">Hard reset</span></strong><span class="koboSpan" id="kobo.1119.1">: This </span><a id="_idIndexMarker325"/><span class="koboSpan" id="kobo.1120.1">resets the index and working directory, permanently deleting uncommitted changes. </span><span class="koboSpan" id="kobo.1120.2">It deletes all changes to commits, indexes, and files, so all the changes themselves do not remain with you. </span><span class="koboSpan" id="kobo.1120.3">If you want to delete everything, this is the way to </span><span class="No-Break"><span class="koboSpan" id="kobo.1121.1">do it:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1122.1">$ git reset --hard &lt;commit hash&gt;</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.1123.1">The following is the area of impact of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1124.1">git reset --</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1125.1">hard</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1126.1"> command:</span></span></p></li> </ul>
<div>
<div class="IMG---Figure" id="_idContainer065">
<span class="koboSpan" id="kobo.1127.1"><img alt="Figure 3.30 – git reset --hard" src="image/B21203_03_030.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1128.1">Figure 3.30 – git reset --hard</span></p>
<h3><span class="koboSpan" id="kobo.1129.1">git revert – Undoing without rewriting history</span></h3>
<p><span class="koboSpan" id="kobo.1130.1">Unlike </span><strong class="source-inline"><span class="koboSpan" id="kobo.1131.1">git reset</span></strong><span class="koboSpan" id="kobo.1132.1">, which</span><a id="_idIndexMarker326"/><span class="koboSpan" id="kobo.1133.1"> alters commit history, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1134.1">git revert</span></strong><span class="koboSpan" id="kobo.1135.1"> creates a new commit that undoes the changes made by a previous commit. </span><span class="koboSpan" id="kobo.1135.2">This is extremely useful in a shared environment where rewriting history is </span><span class="No-Break"><span class="koboSpan" id="kobo.1136.1">highly discouraged.</span></span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1137.1">git revert</span></strong><span class="koboSpan" id="kobo.1138.1"> creates a reverse commit </span><span class="No-Break"><span class="koboSpan" id="kobo.1139.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer066">
<span class="koboSpan" id="kobo.1140.1"><img alt="Figure 3.31 – git-revert creates a commit to cancel the commit" src="image/B21203_03_031.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1141.1">Figure 3.31 – git-revert creates a commit to cancel the commit</span></p>
<p><span class="koboSpan" id="kobo.1142.1">This command will undo the changes made by the commit with the specified hash and create a new commit to record </span><span class="No-Break"><span class="koboSpan" id="kobo.1143.1">this action:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1144.1">
$ git revert &lt;commit_hash&gt;</span></pre> <p><span class="koboSpan" id="kobo.1145.1">The following are cases when you can use </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1146.1">git revert</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1147.1">:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.1148.1">Shared branches</span></strong><span class="koboSpan" id="kobo.1149.1">: Since </span><strong class="source-inline"><span class="koboSpan" id="kobo.1150.1">git revert</span></strong><span class="koboSpan" id="kobo.1151.1"> does not rewrite history, it is safe to use on </span><span class="No-Break"><span class="koboSpan" id="kobo.1152.1">shared branches</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1153.1">Rolling back features</span></strong><span class="koboSpan" id="kobo.1154.1">: If a feature turns out to be buggy or unwanted, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1155.1">git revert</span></strong><span class="koboSpan" id="kobo.1156.1"> is a clean way to </span><span class="No-Break"><span class="koboSpan" id="kobo.1157.1">remove it</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1158.1">Automated deployments</span></strong><span class="koboSpan" id="kobo.1159.1">: In a CI/CD pipeline, you can automate the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1160.1">git revert</span></strong><span class="koboSpan" id="kobo.1161.1"> operation as part of your </span><span class="No-Break"><span class="koboSpan" id="kobo.1162.1">rollback strategy</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1163.1">Let’s learn about some additional advanced </span><strong class="source-inline"><span class="koboSpan" id="kobo.1164.1">git </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1165.1">revert</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1166.1"> options:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.1167.1">Reverting multiple commits</span></strong><span class="koboSpan" id="kobo.1168.1">: You can revert a range of commits by specifying a </span><span class="No-Break"><span class="koboSpan" id="kobo.1169.1">commit range:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1170.1">git revert OLDEST_COMMIT^..NEWEST_COMMIT</span></strong></pre></li> <li><strong class="bold"><span class="koboSpan" id="kobo.1171.1">Revert with manual edit</span></strong><span class="koboSpan" id="kobo.1172.1">: If you want to manually edit the changes before committing them, you can</span><a id="_idIndexMarker327"/><span class="koboSpan" id="kobo.1173.1"> use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1174.1">-n</span></strong><span class="koboSpan" id="kobo.1175.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.1176.1">--</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1177.1">no-commit</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1178.1"> flags:</span></span><pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1179.1">git revert -n &lt;commit_hash&gt;</span></strong></pre><p class="list-inset"><span class="koboSpan" id="kobo.1180.1">This will apply the revert changes to your working directory but will not commit them. </span><span class="koboSpan" id="kobo.1180.2">You can then make further changes and </span><span class="No-Break"><span class="koboSpan" id="kobo.1181.1">commit manually.</span></span></p></li> </ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.1182.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1183.1">Note the caret (</span><strong class="source-inline"><span class="koboSpan" id="kobo.1184.1">^</span></strong><span class="koboSpan" id="kobo.1185.1">) symbol. </span><span class="koboSpan" id="kobo.1185.2">This means the oldest commit in the range of commits to revert </span><span class="No-Break"><span class="koboSpan" id="kobo.1186.1">is included.</span></span></p>
<p><span class="koboSpan" id="kobo.1187.1">Mastering </span><strong class="source-inline"><span class="koboSpan" id="kobo.1188.1">git revert</span></strong><span class="koboSpan" id="kobo.1189.1"> is crucial for any developer or DevOps professional. </span><span class="koboSpan" id="kobo.1189.2">It provides a safe mechanism for undoing changes, enabling better collaboration and more </span><span class="No-Break"><span class="koboSpan" id="kobo.1190.1">reliable code.</span></span></p>
<h3><span class="koboSpan" id="kobo.1191.1">git checkout – More than just branch hopping</span></h3>
<p><span class="koboSpan" id="kobo.1192.1">In previous discussions, we have touched on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1193.1">git checkout</span></strong><span class="koboSpan" id="kobo.1194.1"> command</span><a id="_idIndexMarker328"/><span class="koboSpan" id="kobo.1195.1"> mainly in the context of switching between branches. </span><span class="koboSpan" id="kobo.1195.2">While this is certainly one of its primary functions, it is crucial to understand that </span><strong class="source-inline"><span class="koboSpan" id="kobo.1196.1">git checkout</span></strong><span class="koboSpan" id="kobo.1197.1"> is a multi-purpose tool that can operate at the granularity of individual files or directories as well. </span><span class="koboSpan" id="kobo.1197.2">In this section, let’s expand our understanding of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1198.1">git checkout</span></strong><span class="koboSpan" id="kobo.1199.1"> and see how it plays a vital role in efficient collaboration and </span><span class="No-Break"><span class="koboSpan" id="kobo.1200.1">error correction.</span></span></p>
<p><span class="koboSpan" id="kobo.1201.1">Here’s a refresher on the basic command for </span><span class="No-Break"><span class="koboSpan" id="kobo.1202.1">switching branches:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1203.1">
$ git checkout &lt;branch_name&gt;</span></pre> <p><span class="koboSpan" id="kobo.1204.1">But what if you only need to restore a single file to a previous state? </span><strong class="source-inline"><span class="koboSpan" id="kobo.1205.1">git checkout</span></strong><span class="koboSpan" id="kobo.1206.1"> has got you covered. </span><span class="koboSpan" id="kobo.1206.2">If you have made changes to a file but have not committed yet and you decide you want to undo those changes, you can </span><span class="No-Break"><span class="koboSpan" id="kobo.1207.1">do this:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1208.1">
$ git checkout -- &lt;file_name&gt;</span></pre> <p><span class="koboSpan" id="kobo.1209.1">This will discard changes in your working directory and revert the file back to the state of the last commit. </span><span class="koboSpan" id="kobo.1209.2">Sometimes, you might want to partially apply changes from another branch to your current working branch. </span><span class="koboSpan" id="kobo.1209.3">git checkout can also </span><span class="No-Break"><span class="koboSpan" id="kobo.1210.1">do this:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1211.1">
$ git checkout &lt;branch_name&gt; -- &lt;file_name&gt;</span></pre> <p><span class="koboSpan" id="kobo.1212.1">This command will check out a specific file from another branch into your current working branch, allowing you to mix and match code </span><span class="No-Break"><span class="koboSpan" id="kobo.1213.1">as needed.</span></span></p>
<p><span class="koboSpan" id="kobo.1214.1">It offers versatility in </span><a id="_idIndexMarker329"/><span class="No-Break"><span class="koboSpan" id="kobo.1215.1">team collaboration:</span></span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.1216.1">Quick rollbacks</span></strong><span class="koboSpan" id="kobo.1217.1">: If something goes wrong in the production, you can quickly check out the specific files from a </span><span class="No-Break"><span class="koboSpan" id="kobo.1218.1">stable branch.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1219.1">Selective feature testing</span></strong><span class="koboSpan" id="kobo.1220.1">: Before merging a new feature, you can check out only the files relevant to that feature </span><span class="No-Break"><span class="koboSpan" id="kobo.1221.1">for testing.</span></span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.1222.1">Easy error correction</span></strong><span class="koboSpan" id="kobo.1223.1">: Mistakes happen all the time. </span><span class="koboSpan" id="kobo.1223.2">The ability to check out individual files makes it easier to correct them without affecting other parts of the </span><span class="No-Break"><span class="koboSpan" id="kobo.1224.1">code base.</span></span></li>
</ul>
<p class="callout-heading"><span class="koboSpan" id="kobo.1225.1">Note</span></p>
<p class="callout"><span class="koboSpan" id="kobo.1226.1">Using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1227.1">git checkout</span></strong><span class="koboSpan" id="kobo.1228.1"> on files will discard changes. </span><span class="koboSpan" id="kobo.1228.2">Make sure this is what you intend to do. </span><span class="koboSpan" id="kobo.1228.3">If you are experimenting, it is a good idea to commit your changes often. </span><span class="koboSpan" id="kobo.1228.4">That way, you can easily revert back to a specific commit </span><span class="No-Break"><span class="koboSpan" id="kobo.1229.1">if needed.</span></span></p>
<p><span class="koboSpan" id="kobo.1230.1">Understanding the full range of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1231.1">git checkout</span></strong><span class="koboSpan" id="kobo.1232.1"> capabilities can significantly enhance your workflow and collaboration efficiency. </span><span class="koboSpan" id="kobo.1232.2">Whether you are working alone or as part of a team, the ability to manipulate not just branches but also individual files grants you a higher degree of control and adaptability in your </span><span class="No-Break"><span class="koboSpan" id="kobo.1233.1">team collaboration.</span></span></p>
<h2 id="_idParaDest-71"><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.1234.1">Organizing your working environment</span></h2>
<p><span class="koboSpan" id="kobo.1235.1">In the realm of team development, your individual workspace is your personal lab—a space where you can innovate, debug, and test freely without affecting the broader project. </span><span class="koboSpan" id="kobo.1235.2">Managing this space efficiently is crucial, and Git offers a set of powerful commands to help you do just that. </span><span class="koboSpan" id="kobo.1235.3">In this section, we will explore three essential Git commands—</span><strong class="source-inline"><span class="koboSpan" id="kobo.1236.1">git clean</span></strong><span class="koboSpan" id="kobo.1237.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1238.1">git stash</span></strong><span class="koboSpan" id="kobo.1239.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1240.1">.gitignore</span></strong><span class="koboSpan" id="kobo.1241.1">—that can easily keep your </span><span class="No-Break"><span class="koboSpan" id="kobo.1242.1">workspace clean.</span></span></p>
<h3><span class="koboSpan" id="kobo.1243.1">git clean – A fresh start</span></h3>
<p><span class="koboSpan" id="kobo.1244.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1245.1">git clean</span></strong><span class="koboSpan" id="kobo.1246.1"> command</span><a id="_idIndexMarker330"/><span class="koboSpan" id="kobo.1247.1"> offers a quick way to clear your working directory of untracked files and directories, essentially providing a clean slate. </span><span class="koboSpan" id="kobo.1247.2">This can be especially useful before or after executing a merge, or when you want to remove any clutter that does not need to </span><span class="No-Break"><span class="koboSpan" id="kobo.1248.1">be version-controlled:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1249.1">
# Remove untracked files and directories
$ git clean -fd</span></pre> <h3><span class="koboSpan" id="kobo.1250.1">git stash – Pause and resume work effortlessly</span></h3>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.1251.1">git stash</span></strong><span class="koboSpan" id="kobo.1252.1"> is an </span><a id="_idIndexMarker331"/><span class="koboSpan" id="kobo.1253.1">invaluable tool for temporarily stashing away changes that you have made but are not yet ready </span><span class="No-Break"><span class="koboSpan" id="kobo.1254.1">to commit.</span></span></p>
<p><span class="koboSpan" id="kobo.1255.1">As a developer, multitasking is often the name of the game. </span><span class="koboSpan" id="kobo.1255.2">Whether you are interrupted by an urgent bug fix or need to switch context temporarily, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1256.1">git stash</span></strong><span class="koboSpan" id="kobo.1257.1"> comes to the rescue. </span><span class="koboSpan" id="kobo.1257.2">This command allows you to save your current changes without making a formal commit, giving you the freedom to switch tasks and then return to where you </span><span class="No-Break"><span class="koboSpan" id="kobo.1258.1">left off:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1259.1">
# Stash changes with a description
$ git stash save "WIP: New Feature"
# Reapply the stashed changes
$ git stash apply stash@{0}</span></pre> <p><span class="koboSpan" id="kobo.1260.1">In addition, here is a rundown of common </span><strong class="source-inline"><span class="koboSpan" id="kobo.1261.1">git stash</span></strong><span class="koboSpan" id="kobo.1262.1"> commands that can significantly enhance your </span><a id="_idIndexMarker332"/><span class="No-Break"><span class="koboSpan" id="kobo.1263.1">workspace management:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1264.1">git stash</span></strong><span class="koboSpan" id="kobo.1265.1">: This stashes your changes, leaving your working directory clean. </span><span class="koboSpan" id="kobo.1265.2">Untracked files are </span><span class="No-Break"><span class="koboSpan" id="kobo.1266.1">not stashed.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1267.1">git stash save "Your Comment"</span></strong><span class="koboSpan" id="kobo.1268.1">: This stashes your changes and allows you to attach a comment. </span><span class="koboSpan" id="kobo.1268.2">This is useful for identifying stashes later with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1269.1">git </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1270.1">stash list</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1271.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1272.1">git stash list</span></strong><span class="koboSpan" id="kobo.1273.1">: This displays a list of all your stashed changes. </span><span class="koboSpan" id="kobo.1273.2">If you used </span><strong class="source-inline"><span class="koboSpan" id="kobo.1274.1">git stash save</span></strong><span class="koboSpan" id="kobo.1275.1">, you will see your comments here, making it easier to identify </span><span class="No-Break"><span class="koboSpan" id="kobo.1276.1">each stash.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1277.1">git stash apply</span></strong><span class="koboSpan" id="kobo.1278.1">: This restores the most recently stashed changes to your working directory. </span><span class="koboSpan" id="kobo.1278.2">The stash remains in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1279.1">git </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1280.1">stash list</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1281.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1282.1">git stash apply [stash@{n}]</span></strong><span class="koboSpan" id="kobo.1283.1">: This restores a specific stash based on its index number, which you can find using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1284.1">git </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1285.1">stash list</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1286.1">.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1287.1">git stash drop</span></strong><span class="koboSpan" id="kobo.1288.1">: This deletes a specific stash from the </span><span class="No-Break"><span class="koboSpan" id="kobo.1289.1">stash list.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1290.1">git stash drop [stash@{n}]</span></strong><span class="koboSpan" id="kobo.1291.1">: This deletes a specific stash based on its </span><span class="No-Break"><span class="koboSpan" id="kobo.1292.1">index number.</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.1293.1">git stash clear</span></strong><span class="koboSpan" id="kobo.1294.1">: This </span><a id="_idIndexMarker333"/><span class="koboSpan" id="kobo.1295.1">deletes all stashes, clearing your </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1296.1">stash list</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1297.1">.</span></span></li>
</ul>
<h3><span class="koboSpan" id="kobo.1298.1">.gitignore – Personalize what gets shared</span></h3>
<p><span class="koboSpan" id="kobo.1299.1">When working on complex projects, your local environment may generate files such as logs or contain personal configuration settings—things you do not want to share with the rest of the team. </span><span class="koboSpan" id="kobo.1299.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1300.1">.gitignore</span></strong><span class="koboSpan" id="kobo.1301.1"> file enables </span><a id="_idIndexMarker334"/><span class="koboSpan" id="kobo.1302.1">you to specify which files and folders should be ignored during a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1303.1">git add</span></strong><span class="koboSpan" id="kobo.1304.1">, ensuring they remain exclusive to your </span><span class="No-Break"><span class="koboSpan" id="kobo.1305.1">local environment.</span></span></p>
<p><span class="koboSpan" id="kobo.1306.1">This is an</span><a id="_idIndexMarker335"/><span class="koboSpan" id="kobo.1307.1"> example of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1308.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1309.1">gitignore</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1310.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1311.1">
# Ignore all log files
*.log
# Ignore personal config files
config/personal/</span></pre> <h2 id="_idParaDest-72"><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.1312.1">Who did what? </span><span class="koboSpan" id="kobo.1312.2">Great ways to help you debug</span></h2>
<p><span class="koboSpan" id="kobo.1313.1">Git has a couple of typical ways to analyze the past. </span><strong class="source-inline"><span class="koboSpan" id="kobo.1314.1">git blame</span></strong><span class="koboSpan" id="kobo.1315.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1316.1">git bisect</span></strong><span class="koboSpan" id="kobo.1317.1"> are useful to remember because they are easy to use to go back and debug who made </span><span class="No-Break"><span class="koboSpan" id="kobo.1318.1">what changes.</span></span></p>
<h3><span class="koboSpan" id="kobo.1319.1">git blame – Who did what?</span></h3>
<p><span class="koboSpan" id="kobo.1320.1">When working in a shared code base, there may be instances where you need to understand the history of specific lines of code. </span><span class="koboSpan" id="kobo.1320.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1321.1">git blame</span></strong><span class="koboSpan" id="kobo.1322.1"> command</span><a id="_idIndexMarker336"/><span class="koboSpan" id="kobo.1323.1"> provides a breakdown of a file, annotating each line to show the last person who modified it and what commit it belongs to. </span><span class="koboSpan" id="kobo.1323.2">This helps in identifying the responsible parties for particular changes, which is useful for debugging, refactoring, or simply understanding why a particular piece of </span><span class="No-Break"><span class="koboSpan" id="kobo.1324.1">code exists.</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1325.1">
$ git blame file.txt</span></pre> <p><span class="koboSpan" id="kobo.1326.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1327.1">-L</span></strong><span class="koboSpan" id="kobo.1328.1"> option allows you to specify the lines </span><span class="No-Break"><span class="koboSpan" id="kobo.1329.1">of output:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1330.1">
$ git blame -L 5,10 README.md
$ git blame -L 5,+5 README.md</span></pre> <p><span class="koboSpan" id="kobo.1331.1">It is essential to highlight that the aim of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1332.1">git blame</span></strong><span class="koboSpan" id="kobo.1333.1"> is not to single out individuals for errors or questionable decisions. </span><span class="koboSpan" id="kobo.1333.2">In any collaborative setting—especially in DevOps where teamwork is paramount—it is crucial to remember that mistakes are a collective responsibility. </span><span class="koboSpan" id="kobo.1333.3">Everyone can err; what is important is how the team collaborates to fix those errors. </span><span class="koboSpan" id="kobo.1333.4">From a psychosocial safety perspective, using </span><strong class="source-inline"><span class="koboSpan" id="kobo.1334.1">git blame</span></strong><span class="koboSpan" id="kobo.1335.1"> should be approached as a way to enhance team communication and identify areas for improvement rather than as a mechanism for </span><span class="No-Break"><span class="koboSpan" id="kobo.1336.1">casting blame.</span></span></p>
<h3><span class="koboSpan" id="kobo.1337.1">git bisect – Efficient bug hunting in commit ranges</span></h3>
<p><span class="koboSpan" id="kobo.1338.1">Debugging can often feel like looking for a needle in a haystack, especially in large codebases with a long history of commits. </span><span class="koboSpan" id="kobo.1338.2">In the realm of DevOps, where rapid deployment cycles are the norm, a bug introduced in any of the numerous changes can wreak havoc. </span><span class="koboSpan" id="kobo.1338.3">This is where </span><strong class="source-inline"><span class="koboSpan" id="kobo.1339.1">git bisect</span></strong><span class="koboSpan" id="kobo.1340.1"> comes</span><a id="_idIndexMarker337"/><span class="koboSpan" id="kobo.1341.1"> into play, serving as a powerful tool for isolating the specific commit that introduced </span><span class="No-Break"><span class="koboSpan" id="kobo.1342.1">a bug.</span></span></p>
<p><span class="koboSpan" id="kobo.1343.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1344.1">git bisect</span></strong><span class="koboSpan" id="kobo.1345.1"> command performs a binary search through your commit history to find the commit that introduced the bug. </span><span class="koboSpan" id="kobo.1345.2">The process begins by marking a known good commit and a known </span><span class="No-Break"><span class="koboSpan" id="kobo.1346.1">bad commit:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1347.1">
$ git bisect start
$ git bisect bad   # If the current version is bad
$ git bisect good &lt;Last known good version commit hash&gt;</span></pre> <p><span class="koboSpan" id="kobo.1348.1">Git will then automatically check out a commit halfway between the good and bad commits. </span><span class="koboSpan" id="kobo.1348.2">You test this commit and then mark it as either good </span><span class="No-Break"><span class="koboSpan" id="kobo.1349.1">or bad:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1350.1">
$ git bisect good # or
$ git bisect bad</span></pre> <p><span class="koboSpan" id="kobo.1351.1">Git will continue this process, narrowing down the range of commits until it identifies the culprit. </span><span class="koboSpan" id="kobo.1351.2">Once you find the problematic commit, it is easier to understand what went wrong and to devise </span><span class="No-Break"><span class="koboSpan" id="kobo.1352.1">a fix:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1353.1">
# Exit bisect mode and return to your branch
$ git bisect reset</span></pre> <p><span class="koboSpan" id="kobo.1354.1">In DevOps, where the speed of identifying and resolving issues is crucial for maintaining operational excellence, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1355.1">git bisect</span></strong><span class="koboSpan" id="kobo.1356.1"> becomes an invaluable tool. </span><span class="koboSpan" id="kobo.1356.2">It integrates well into a DevOps toolchain, allowing for automated testing and facilitating quicker rollbacks and patches. </span><span class="koboSpan" id="kobo.1356.3">By efficiently pinpointing errors, it enhances the team’s ability to collaborate on solutions, underscoring the essential DevOps principles of rapid feedback and </span><span class="No-Break"><span class="koboSpan" id="kobo.1357.1">continuous improvement.</span></span></p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.1358.1">Versioning excellence</span></h2>
<p><span class="koboSpan" id="kobo.1359.1">In the DevOps ecosystem, </span><strong class="bold"><span class="koboSpan" id="kobo.1360.1">CI/CD</span></strong><span class="koboSpan" id="kobo.1361.1"> make everything</span><a id="_idIndexMarker338"/><span class="koboSpan" id="kobo.1362.1"> incremental. </span><span class="koboSpan" id="kobo.1362.2">Yet, it is essential to have concrete versions of your software to serve as milestones. </span><span class="koboSpan" id="kobo.1362.3">These versions are not just markers in time; they indicate the stability, new features, and overall health of your code base. </span><span class="koboSpan" id="kobo.1362.4">They also facilitate smoother rollbacks and make it easier to </span><span class="No-Break"><span class="koboSpan" id="kobo.1363.1">isolate issues.</span></span></p>
<h3><span class="koboSpan" id="kobo.1364.1">What is semantic versioning</span></h3>
<p><span class="koboSpan" id="kobo.1365.1">Semantic versioning is</span><a id="_idIndexMarker339"/><span class="koboSpan" id="kobo.1366.1"> a versioning scheme designed to convey specific meanings about the underlying changes with each new release. </span><span class="koboSpan" id="kobo.1366.2">The format consists of three numbers separated by dots (e.g., 2.4.4). </span><span class="koboSpan" id="kobo.1366.3">Each number has a particular significance related to backward compatibility and the types of </span><span class="No-Break"><span class="koboSpan" id="kobo.1367.1">changes introduced.</span></span></p>
<h3><span class="koboSpan" id="kobo.1368.1">Tagging in Git</span></h3>
<p><span class="koboSpan" id="kobo.1369.1">Tagging</span><a id="_idIndexMarker340"/><span class="koboSpan" id="kobo.1370.1"> becomes a cornerstone of effective version control within a DevOps environment. </span><span class="koboSpan" id="kobo.1370.2">By marking specific points in your repository’s history, you can create anchors that serve as stable release points or significant milestones. </span><span class="koboSpan" id="kobo.1370.3">These tagged versions form the basis for your CI/CD pipelines, ensuring consistent and </span><span class="No-Break"><span class="koboSpan" id="kobo.1371.1">reliable deployments.</span></span></p>
<p><span class="koboSpan" id="kobo.1372.1">To make your tags more informative, consider annotating them with useful metadata </span><span class="No-Break"><span class="koboSpan" id="kobo.1373.1">and context:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1374.1">
$ git tag -a v1.0 -m "Initial stable release"</span></pre> <p><span class="koboSpan" id="kobo.1375.1">The commits you tag should typically represent stable release points or crucial milestones. </span><span class="koboSpan" id="kobo.1375.2">These are the commits where all the automated tests have passed, features are complete, and the code has undergone peer review. </span><span class="koboSpan" id="kobo.1375.3">In essence, they are your </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.1376.1">production-ready</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.1377.1"> commits.</span></span></p>
<p><span class="koboSpan" id="kobo.1378.1">To tag a specific commit, use </span><span class="No-Break"><span class="koboSpan" id="kobo.1379.1">the following:</span></span></p>
<pre class="console"><span class="koboSpan" id="kobo.1380.1">
$ git tag v2.4.4 32de0b2</span></pre> <p><span class="koboSpan" id="kobo.1381.1">Git tagging </span><a id="_idIndexMarker341"/><span class="koboSpan" id="kobo.1382.1">and semantic versioning are not just technical procedures but strategic</span><a id="_idIndexMarker342"/><span class="koboSpan" id="kobo.1383.1"> actions. </span><span class="koboSpan" id="kobo.1383.2">They ensure that everyone is on the same page regarding what is being deployed and what it </span><span class="No-Break"><span class="koboSpan" id="kobo.1384.1">can do.</span></span></p>
<p><span class="koboSpan" id="kobo.1385.1">In this section, we have equipped ourselves with the knowledge to roll back time in our repositories, understanding when and how to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.1386.1">git reset</span></strong><span class="koboSpan" id="kobo.1387.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1388.1">git revert</span></strong><span class="koboSpan" id="kobo.1389.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1390.1">git checkout</span></strong><span class="koboSpan" id="kobo.1391.1">. </span><span class="koboSpan" id="kobo.1391.2">These powerful commands ensure that we can gracefully undo changes, correct course, and maintain a clean project history—all essential for a collaborative setting. </span><span class="koboSpan" id="kobo.1391.3">Organizing your working environment with </span><strong class="source-inline"><span class="koboSpan" id="kobo.1392.1">git clean</span></strong><span class="koboSpan" id="kobo.1393.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1394.1">git stash</span></strong><span class="koboSpan" id="kobo.1395.1">, and the right </span><strong class="source-inline"><span class="koboSpan" id="kobo.1396.1">.gitignore</span></strong><span class="koboSpan" id="kobo.1397.1"> settings offers you a pristine workspace where focus and clarity replace clutter and chaos. </span><span class="koboSpan" id="kobo.1397.2">This clean slate is not just about personal preference; it is about setting a standard for the team and ensuring that only intentional changes make their way into the </span><span class="No-Break"><span class="koboSpan" id="kobo.1398.1">shared repository.</span></span></p>
<p><span class="koboSpan" id="kobo.1399.1">Incorporating these techniques into your routine not only prepares you for better personal performance but also strengthens the </span><span class="No-Break"><span class="koboSpan" id="kobo.1400.1">whole team.</span></span></p>
<h1 id="_idParaDest-74"><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.1401.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1402.1">In this chapter, we delved deep into the nuances of branch strategies, the intricacies of merging and rebasing, and the art of navigating conflicts with the goal of mastering better collaboration within your teams. </span><span class="koboSpan" id="kobo.1402.2">From understanding why a branching strategy is crucial to aligning branch naming with organizational objectives, we have laid out the groundwork for you to build a </span><span class="No-Break"><span class="koboSpan" id="kobo.1403.1">robust workflow.</span></span></p>
<p><span class="koboSpan" id="kobo.1404.1">We explored the various branching models, such as trunk-based development, Git Flow, and GitHub Flow, highlighting their unique benefits and scenarios where they fit best. </span><span class="koboSpan" id="kobo.1404.2">The discussion around merge approaches provided insight into the tools at your disposal for maintaining a clean and informative project history while also addressing the sometimes daunting task of </span><span class="No-Break"><span class="koboSpan" id="kobo.1405.1">conflict resolution.</span></span></p>
<p><span class="koboSpan" id="kobo.1406.1">As you close this chapter, remember that the path to mastering Git is ongoing. </span><span class="koboSpan" id="kobo.1406.2">Encourage yourself to discover more and to practice these skills through your development work with confidence. </span><span class="koboSpan" id="kobo.1406.3">Embrace the challenges and the learning opportunities they bring and continue to grow as a developer. </span><span class="koboSpan" id="kobo.1406.4">Git is not just a tool; it is a companion in your DevOps journey that enhances the developer’s experience by removing friction and fostering a culture </span><span class="No-Break"><span class="koboSpan" id="kobo.1407.1">of collaboration.</span></span></p>
</div>


<div class="Content" id="_idContainer068">
<h1 id="_idParaDest-75" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.1.1">Part 2: GitHub Excellence and CI/CD Fundamentals</span></h1>
<p><span class="koboSpan" id="kobo.2.1">This part highlights GitHub’s role in DevOps, expanding its use beyond just code hosting. </span><span class="koboSpan" id="kobo.2.2">It discusses GitHub’s features that enhance team collaboration and the transition to modern DevOps practices. </span><span class="koboSpan" id="kobo.2.3">Additionally, it delves into GitHub Actions, focusing on workflow optimization, advanced deployment methods such as blue-green and canary deployments, and feature release strategies. </span><span class="koboSpan" id="kobo.2.4">This provides an in-depth understanding of GitHub’s capabilities in continuous integration </span><span class="No-Break"><span class="koboSpan" id="kobo.3.1">and deployment.</span></span></p>
<p><span class="koboSpan" id="kobo.4.1">This part has the </span><span class="No-Break"><span class="koboSpan" id="kobo.5.1">following chapters:</span></span></p>
<ul>
<li><a href="B21203_04.xhtml#_idTextAnchor077"><em class="italic"><span class="koboSpan" id="kobo.6.1">Chapter 4</span></em></a><span class="koboSpan" id="kobo.7.1">, </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Elevating Team Collaboration with GitHub</span></em></li>
<li><a href="B21203_05.xhtml#_idTextAnchor109"><em class="italic"><span class="koboSpan" id="kobo.9.1">Chapter 5</span></em></a><span class="koboSpan" id="kobo.10.1">, </span><em class="italic"><span class="koboSpan" id="kobo.11.1">Driving CI/CD with GitHub</span></em></li>
</ul>
</div>
<div>
<div id="_idContainer069">
</div>
</div>
<div>
<div class="Basic-Graphics-Frame" id="_idContainer070">
</div>
</div>
</body></html>