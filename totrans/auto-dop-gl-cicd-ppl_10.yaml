- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Extending the Reach of CI/CD Pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we aim to extend the reach of CI/CD pipelines into common automation
    use cases. By the end of this chapter, you should have an idea of what’s possible
    with CI/CD pipelines. You’ll see that they are not necessarily just for build
    and deployment tasks, but also automation tasks, which make the job of an engineer
    easier, repeatable, and more reliable. CI/CD pipelines are always meant to ease
    the burden of work on an engineer so that they can focus on more novel and important
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Using CI/CD pipelines to spot performance problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating third-party tools into your CI/CD pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using CI/CD pipelines for developing mobile apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using CI/CD pipelines to spot performance problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is no better time to do performance testing than during an automated CI/CD
    pipeline. With performance tests, you want them to be routine and against a stable
    unchanging environment or deployment. If you run performance tests against an
    environment or deployment that constantly changes, you will not have reliable
    results. Without reliable results, the entire notion of performance tests goes
    out the window. You want to understand how your changes affect your performance;
    without stable results, you can’t infer that understanding.
  prefs: []
  type: TYPE_NORMAL
- en: With GitLab, there are multiple ways to run performance tests. For web or API-based
    deployments, GitLab includes a native performance tool that will cover in this
    chapter and go over its integration. However, you, the end user, can take this
    a step further and cover more metrics such as CPU/memory/storage usage in a CI/CD
    pipeline. We will not be covering how to collect these metrics in this chapter
    since that is unique to every user’s environment. However, we strongly recommend
    that you capture these metrics as part of your CI/CD pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'GitLab’s native integrated performance testing tool for API and web-based deployments
    will check numerous metrics for active deployment. Some of those metrics include
    page load time, first page paint time, and total blocking time. In a merge request
    (pictured in the following screenshot) you can see how your code changes will
    impact the performance of the web/API deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1: Performance metrics view in a merge request](img/B18073_10_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.1: Performance metrics view in a merge request'
  prefs: []
  type: TYPE_NORMAL
- en: Always double-check your testing criteria
  prefs: []
  type: TYPE_NORMAL
- en: Your testing results are going to be directly dependent on your testing criteria,
    test settings, and environments. You should always question if your testing criteria,
    settings, and environments are accurate. You should never assume they are accurate.
    If they are not accurate, your test results will never be accurate.
  prefs: []
  type: TYPE_NORMAL
- en: How to integrate browser performance testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Integrating browser performance testing is quite easy – you just need to include
    the GitLab templates as part of your CI/CD pipeline and then instruct GitLab where
    your API or web deployment can be accessed. See the following example.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding job template, we’re invoking the `browser_performance:` templates
    from GitLab. Then, we’re overwriting the `URL` variable of the job. This URL is
    what tells the Performance Testing Suite where to reach out and scan our application
    for performance. With this configuration, GitLab will check our application and
    report the results back to our merge request.
  prefs: []
  type: TYPE_NORMAL
- en: How to integrate load performance testing with k6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second type of testing that is used in GitLab CI/CD by default is load testing
    with a tool named k6, provided by the company Grafana. GitLab provides a template
    for running this tool as part of your CI/CD pipeline as well. However, there is
    an additional step of creating and specifying a k6 configuration file to run a
    proper k6 load test.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re going to go over this process here. Before we do, note that you should
    never run these load tests in production. Production load tests should run on
    an identical non-production environment. To get accurate load testing results,
    the load testing tool should be the only item communicating with your environment.
    Without further ado, let’s integrate load testing. Add the following code to your
    `.``gitlab-ci.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will execute k6 as part of our pipeline. However, now, we
    need to inform k6 how to test our application and provide GitLab with a test file
    to run. We’re going to assume that this file lives at the`.gitlab/test/k6.js`
    path. We’re going to walk through how to build this file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is going to load the libraries and functions that will affect
    our load test. Without these, the remainder of our load test file will fail. Next,
    we’re going to add our settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is going to define the options for our test. For 5 minutes,
    we’re going to ramp up to 100 users accessing the website. Then, we’re going to
    hold at 100 users for 10 minutes. Finally, over 5 minutes, we’re going to ramp
    down to 0 users. That means this test will run for 20 minutes in total:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Then, we must set the threshold for failure. We want to see 99% of all requests
    respond within 1,500 milliseconds. Anything outside that will fail. Next, we’re
    going to execute the actual load test.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code will execute our performance tests using k6 against our
    website. With this file now being successfully built, we can execute our pipeline
    and have repeatable load tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With the performance testing set up, we’re going to shift our focus to how to
    utilize feature flags to enable and disable parts of our application after deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Using feature flags to allow business-driven release decisions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'GitLab comes with the ability to set up feature flags in the UI. It is based
    on the *third-party* `unleash` library. Once you set up the feature flags in the
    GitLab UI, you will need to set up your application to communicate with GitLab
    to check for feature flags. We’ll cover examples of both of these steps, but GitLab
    does not do this for you: it is up to your application developers to do this work.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the feature flags have been configured in the UI, an API call from the
    application is necessary to check the flag and change the logic of the application
    accordingly. Let’s walk through how to set up the feature flags in the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a project, open the navigation pane on the left-hand side. Click **Deployments**
    | **Feature Flags**. This will take you to the main feature flag section. In the
    top right, click **New feature flag**. This will take you to a new view:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.2: Feature Flags in GitLab’s navigation pane](img/B18073_10_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.2: Feature Flags in GitLab’s navigation pane'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be presented with a form. Fill it out and plan your strategies accordingly.
    You can set multiple strategies based on environments, user lists, and user IDs,
    and assign percentages to different groups. Once submitted, it will look like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.3: Main feature flag view](img/B18073_10_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.3: Main feature flag view'
  prefs: []
  type: TYPE_NORMAL
- en: 'Feature flags are exceptionally powerful when launching new features. By placing
    a new feature behind a feature flag, you can turn off part of your application
    by toggling a flag. This can help prevent a rollback of a release or an emergency
    support ticket:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.4: Feature Flags detail view](img/B18073_10_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10.4: Feature Flags detail view'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 10**.4*, you can see the presence of our newly created feature flag.
    On the left-hand side, under **Status**, you can see a checkbox, which is used
    to enable or disable this flag.
  prefs: []
  type: TYPE_NORMAL
- en: How to configure your application for feature flags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we’re going to cover a single use case for checking feature
    flags in an application. The following is a Ruby code sample that will check for
    feature flags and toggle a code path based on the flag that is set. Your team’s
    application developers will need to set up their applications based on their toolchains
    and language usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this Ruby example, you begin by setting the GitLab information, including
    the URL of the GitLab instance, the app’s name (corresponding to the environment
    in GitLab), and the instance ID (the numeric ID of your GitLab project).
  prefs: []
  type: TYPE_NORMAL
- en: The `user_id` parameter is an example of passing information to GitLab. In this
    example, we’re passing a user ID that GitLab will match with your feature flag
    strategy if configured. The next step is invoking `unclear.is_enabled`, which
    accepts a feature name as a variable, then reaches out to GitLab to determine
    if you are in the group that has the flag enabled. Then, the code path that is
    enabled will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve covered the usage and purpose of feature flags, we’re going to
    work on how to integrate third-party tools into your CI/CD pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating third-party tools into your CI/CD pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’re going to cover how to integrate third-party tools into
    a CI/CD pipeline. The preferred method to integrate a third-party tool into a
    CI/CD pipeline is to containerize it, create a CI/CD job that uses that container,
    and then invoke our tool as part of that job. In many cases, this is a requirement
    and is the first step in setting up an integration.
  prefs: []
  type: TYPE_NORMAL
- en: Tool format expectations
  prefs: []
  type: TYPE_NORMAL
- en: This section is based on the belief that the tool you want to integrate is already
    compiled and ready to be integrated into your pipeline. In the event it is not,
    you can add CI jobs before those mentioned here to compile or assemble the tool.
    Then, you can invoke the CI jobs and steps in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our tool container’s Dockerfile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed how to build purpose-built containers.
    We’re going to use that method here to integrate your tool. If you haven’t read
    the *Securing and accelerating jobs with purpose-built containers* section of
    the previous chapter yet, we highly recommend that you read it first and then
    come back.
  prefs: []
  type: TYPE_NORMAL
- en: The first step in this process is to set up a new GitLab project for your tool
    and container. Once you have this set up, commit the binaries, configuration,
    and other files you wish to be placed in the container. The next step is building
    the container and placing those items inside of it. Create a Dockerfile in your
    repository and add the following sample code. `$mybinary` is a placeholder for
    your binary’s filename; `myTool` will be your tool’s name.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in the following code, we have created a new container derived from
    `alpine:3.13.0`. We updated the container, then created a directory for our tool.
    After that directory was created, we added all the files in our repository to
    that folder, permissioned them with a wide permission, and set our binary as executable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is a simplified example of how to integrate a third-party tool. You should
    always customize the permission’s values to the least privilege necessary to run
    your tool. You should also only put the files required for your tool to run in
    the container. For this example, we’re casting a wide net and including everything,
    as well as wide permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Automating our container’s build
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have a Dockerfile, we want to build the container. As a bonus,
    we’re also going to turn on container scanning. Create a `.gitlab-ci.yml` file
    in your repository if you haven’t already. We’re going to populate that `.gitlab-ci.yml`
    file with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Avoiding a pipeline run on every commit
  prefs: []
  type: TYPE_NORMAL
- en: When making multiple pipeline changes, you may not want to kick off a pipeline
    run every time you make a change. If you start your commit message with `[CI SKIP]`,
    GitLab will not start a pipeline for that commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code is the most basic example of a Docker-in-Docker build. First,
    we utilize `image: docker:20.10.16` to define the version of Docker we want to
    build against. Then, we define the Docker service we want to build with – that
    is, the `dind` container. Next, we set the `DOCKER_HOST` and `DOCKER_TLS_VERIFY`
    variables so that the Docker and `dind` containers can talk to each other. Finally,
    we invoke the `docker build` command to build our container, and the `docker push`
    command to upload it to GitLab’s container registry.'
  prefs: []
  type: TYPE_NORMAL
- en: GitLab Runner requirements for Docker
  prefs: []
  type: TYPE_NORMAL
- en: Building a Docker container typically requires the usage of a GitLab Runner
    capable of doing Docker-in-Docker container builds. GitLab.com shared Runners
    come with this capability preconfigured. If you’re using a self-hosted Runner,
    you may need to reconfigure it. Refer to the GitLab documentation for how to achieve
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Container scanning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'GitLab offers container scanning as part of the container-building process.
    We want to take advantage of this to identify any dependency or other vulnerabilities
    with our container. Enabling this is simple: you need to have a test stage defined
    in your `.gitlab-ci.yml` file. Then, simply add the following code block to the
    top of your `.``gitlab-ci.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Invoking the third-party tool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, we should have a container with our third-party tool built,
    scanned, and placed inside the GitLab container registry. All that is left now
    is to invoke our tool. We can do this by creating a CI/CD job that’s pointing
    to our container and calling our executable in the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So far, we’ve walked through how to build a container with tools, how to scan
    a container, and how to invoke that tool via a CI/CD job. This is a basic example
    to show you the art of what is possible. With this process, you can clone third-party
    tools, custom scripts, custom configurations, or whatever else you want to include
    as part of your CI/CD pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: There are major benefits to doing this. For example, any container that runs
    as part of a CI/CD pipeline has access to the GitLab API and GitLab repository.
    This means you can run a CI/CD job as part of your pipeline for something such
    as metrics collection or configuration verification as well. CI/CD jobs built
    in this way can automate almost anything.
  prefs: []
  type: TYPE_NORMAL
- en: If you build and containerize a custom tool, be sure to share it with the community.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’re going to discuss how to build mobile applications
    using GitLab CI/CD and Fastlane.
  prefs: []
  type: TYPE_NORMAL
- en: Using CI/CD pipelines for developing mobile apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’re going to discuss how to set up CI/CD pipelines in GitLab
    for mobile application development. There are many benefits to automating the
    mobile development process at the packaging stage, most notably the fact that
    packaging a mobile application involves multiple certificates, entitlements, and
    configuration files, which take a substantial amount of time to assemble when
    packaging an application. In addition to that, the testing process around mobile
    applications can be manual and tedious. By automating things such as screenshots
    across multiple devices, we can shave hours off a developer’s workload.
  prefs: []
  type: TYPE_NORMAL
- en: This section assumes you have all the requirements listed next configured and
    working already. We’re not going to cover how to do mobile development, but rather
    how to automate your mobile development practices using Fastlane and GitLab.
  prefs: []
  type: TYPE_NORMAL
- en: Requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this section, you will need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A macOS device or VM running the latest version of OS X, with Fastlane installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitLab Runner installed on your macOS device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Apple developer account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Google developer account
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An application that can be built successfully on your macOS device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read this before proceeding
  prefs: []
  type: TYPE_NORMAL
- en: If you can’t meet these requirements, you should stop here until you can. This
    guide assumes you have a working, provisioned macOS device. It also assumes you
    can build a mobile application on the device.
  prefs: []
  type: TYPE_NORMAL
- en: Fastlane
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we’re going to be utilizing the Fastlane CLI tool to automate
    our tests, builds, and deployments. Fastlane is a tool that works with both Android
    and iOS build processes. It is an opensource tool that can be installed for free
    on macOS and Windows platforms. You can read more about it in the Fastlane documentation
    located at [https://docs.fastlane.tools/getting-started/ios/setup/](https://docs.fastlane.tools/getting-started/ios/setup/).
  prefs: []
  type: TYPE_NORMAL
- en: 'We’re going to assume you have Fastlane installed on your machine. If not,
    please refer to the Fastlane documentation linked previously for your platform.
    The first step in this process is to open your mobile application project and
    create a Fastlane configuration file named `Fastfile`. Fastfile is the primary
    configuration file used by Fastlane. We’re going to make our Fastfile look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'To build our mobile application for both iOS and Android, we simply need to
    run the `fastlane beta` command. Assuming your iOS and Android applications can
    already be built on the macOS device, this command should automate their building.
    We can put this into a GitLab CI file like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This GitLab CI job will automate the Fastlane process via GitLab pipelines.
    We are leveraging the `tags:` keyword to ensure that this build happens on a specific
    macOS device. Without this keyword, the build could happen on any GitLab Runner.
  prefs: []
  type: TYPE_NORMAL
- en: Fastlane – deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can deploy your mobile application to the Android and Apple stores. However,
    you will need to set up all mobile certificates for production use before setting
    up Fastlane. When those certificates expire, someone will need to update them
    on the macOS device. Nevertheless, if they have been set up, you can modify your
    `Fastfile` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding additions to your Fastfile will build your application and release
    it to the respective app stores. You simply need to run the `Fastlane appstore`
    and `Fastlane playstore` commands. A corresponding GitLab CI/CD configuration
    file would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Fastlane – automated testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Assuming you have unit tests set up for your projects already, Fastlane can
    automate those as well. It does not automatically set up the tests, but if you
    have them built as part of your project’s configuration, Fastlane can invoke them.
    This process is similar to every step before – we begin with Fastfile modifications,
    as seen in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Just like before, we can amend our GitLab CI/CD configuration file to add automated
    testing as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: At times, using Fastlane may feel like you’re cheating. Once you have an established
    mobile project on a device, Fastlane can take it from there. Mobile development
    before Fastlane was a tedious and manual process. CI/CD pipelines were filled
    with a large amount of code and logic to make a build happen and then be deployed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we discussed how to build a Fastfile to configure Fastlane,
    how to run Fastlane commands, and, most importantly, how to add them to a GitLab
    CI/CD configuration file. We’ve said it before, but in closing, it’s worth repeating:
    Fastlane and automating mobile development with GitLab CI/CD pipelines is best
    suited for a macOS device that is already provisioned and set up to build a mobile
    application. Start there, and then use GitLab CI and Fastlane to handle the rest.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the benefits of including performance checks inside
    your CI/CD pipeline. We also covered how to include GitLab’s native performance
    testing tools. Following that, we covered the benefits of feature flags and how
    they can protect your deployments and prevent time-consuming rollbacks. Then,
    we moved on to integrating third-party tools as part of your CI/CD pipeline and
    how to containerize them for use. Finally, we walked through how to automate the
    creation and deployment of mobile applications using Fastlane.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’re going to cover an end-to-end example that leverages
    everything you’ve learned about in this book.
  prefs: []
  type: TYPE_NORMAL
