- en: 'Chapter 11: Using ChatOps to Increase Efficiency'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As DevOps engineers, we often work as part of a team of engineers that help
    manage a network, service infrastructure, and public-facing services. This means
    there are a lot of moving parts and communication that needs to occur, especially
    in an emergency.
  prefs: []
  type: TYPE_NORMAL
- en: ChatOps provides teams with a central interface to tooling to ask questions
    about current states and to interact with other DevOps tools while recording those
    interactions for posterity. This can improve feedback loops and real-time communication
    between teams and help manage incidents effectively.
  prefs: []
  type: TYPE_NORMAL
- en: One of our colleagues, Sarah Murphy, has a saying – *Don't talk to the bus driver*.
    As a release engineer for Facebook in the early days, she was responsible for
    releasing Facebook across their data centers. This was a high-stress and detail-oriented
    job that required her complete attention. Many of the engineers wanted to know
    if their feature or patch was being included in the current release and, of course,
    asked the release engineer.
  prefs: []
  type: TYPE_NORMAL
- en: As any engineer who does high-impact rollouts will tell you, you need to focus.
    Having hundreds of engineers ping you about the status of their particular patch
    is not ideal. This is where ChatOps comes into play. Instrumenting ChatOps can
    allow a central place where questions about rollout status and what revision is
    in a release can stave off those hundreds of questions. It certainly did for Sarah.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will dive into how to build a ChatOps bot for Slack. We
    will show how we can use that bot to ask the status of a service. We will show
    how we can use a bot to get deployment information. And finally, we will show
    how we can use the bot to deploy our software.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Environment architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an Ops service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a basic chatbot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating event handlers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating our Slack application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the prerequisites for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A Slack user account: Create a Slack user if you do not have one by following
    the instructions here: [https://slack.com/get-started#/createnew](https://slack.com/get-started#/createnew).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A Slack workspace to experiment: Instructions for creating a Slack workspace
    can be found here: [https://slack.com/help/articles/206845317-Create-a-Slack-workspace](https://slack.com/help/articles/206845317-Create-a-Slack-workspace).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creation of a Slack application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is highly suggested that you use a workspace you control instead of using
    a corporate one. That process requires approval by admins for your corporate Slack.
  prefs: []
  type: TYPE_NORMAL
- en: You will also need to create a Slack application, but this is covered in a later
    section.
  prefs: []
  type: TYPE_NORMAL
- en: The code files for this chapter can be downloaded from [https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/11](https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/11)
  prefs: []
  type: TYPE_NORMAL
- en: Environment architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our example ChatOps program will need to interact with several services to provide
    information to users.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable this, we have built a more robust version of the `Petstore` application
    that we built in our previous chapters. This version does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Implements **create, read, update and delete** (**CRUD**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is gRPC based.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Has deeper Open Telemetry tracing that flows through RPC calls and records events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deeper metrics that can be used to inform Prometheus alarms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replaces logging with tracing events.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All errors are automatically added to traces.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traces can be turned on by a client.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Traces are sampled by default but can be changed via an RPC.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find this new Petstore here: [https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/11/petstore](https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/11/petstore).
    There is a `README` file that details the architecture if you want to dive into
    the details, but you do not need to for this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Our new Petstore is more capable and will allow us to show some of the power
    ChatOps can provide by combining our other lessons from this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is what our service architecture would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – ChatOps and Petstore architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17626_11_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.1 – ChatOps and Petstore architecture
  prefs: []
  type: TYPE_NORMAL
- en: Attribution
  prefs: []
  type: TYPE_NORMAL
- en: Poodle dog vector created by `gstudioimagen` - [www.freepik.com](http://www.freepik.com)
  prefs: []
  type: TYPE_NORMAL
- en: 'Gophers by Egon Elbe: [github.com/egonelbre/gophers](http://github.com/egonelbre/gophers)'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two services we will concentrate on creating here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Ops service**: The Ops service does the real work, such as talking to Jaeger,
    Prometheus, running jobs, or anything else that is needed. This allows us to have
    multiple ChatOps services running in parallel (which might be needed if your company
    migrates from Slack to Microsoft Teams, for example).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This architecture has the benefit of allowing other teams to write tools using
    these functions in any language they choose.
  prefs: []
  type: TYPE_NORMAL
- en: '`slack-go` package, which can be found at [https://github.com/slack-go/slack](https://github.com/slack-go/slack).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's jump into the basic details of the Ops service.
  prefs: []
  type: TYPE_NORMAL
- en: Using an Ops service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are not going to go into complete detail about this service, as we have covered
    how gRPC works in previous chapters. As this service just makes gRPC or REST calls
    to other services, let's talk about the calls that need to be implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'The protocol buffer service definition is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: For our example service, these RPCs are targeted at a single deployed instance,
    but in a production environment, this would work on multiple entities that exist
    on a site.
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows users to get some information quickly, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: See the traces we have in a certain time period, and the ability to filter by
    tags (such as `error`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieve basic trace data and the Jaeger URL of a trace given a trace ID.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the sampling type and rate for traces in the service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tell us what version has been deployed according to Prometheus.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display any alerts that Prometheus shows are firing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can read the code on how this is implemented here: [https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/11/ops](https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/11/ops).'
  prefs: []
  type: TYPE_NORMAL
- en: We include a `README` file that goes over the basic architecture, but it is
    your standard gRPC service that makes calls using gRPC to the Petstore service/Jaeger
    and REST calls to Prometheus.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's jump into something new, writing the basic Slack bot.
  prefs: []
  type: TYPE_NORMAL
- en: Building a basic chatbot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go has a few clients that can interact with popular chat services such as Slack,
    either as a general Slack client or as a ChatOps-focused bot.
  prefs: []
  type: TYPE_NORMAL
- en: We have found that it is best to have an architecture that separates the bot
    from the operations that you want to perform. This allows other tooling in other
    languages to access the capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: By keeping the chatbot separate, you can focus on a single type of chat service
    and use all its features, instead of only features shared by each chat service
    client.
  prefs: []
  type: TYPE_NORMAL
- en: For this reason, we will use the `slack-go` package to interact with Slack.
  prefs: []
  type: TYPE_NORMAL
- en: Our bot will be basic, simply listening to when someone mentions our bot in
    a message. This is called an `AppMention` event. Slack supports other events and
    has events specifically for commands that you can install. In our case, we just
    want to answer whenever we are mentioned, but `slack-go` has many other capabilities
    we will not explore.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a package called `bot` and add some imports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Details on our third-party package are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`slack` is what is used to build a basic client.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`slackevents` details the various events we can receive.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`socketmode` provides a method of connecting to Slack from a bot that is behind
    a firewall.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s create a type that can handle an event we receive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`HandleFunc` receives a message that can be used to write to channels and get
    information about the message that was received.'
  prefs: []
  type: TYPE_NORMAL
- en: We have also defined a register type that is used to register a `HandleFunc`
    with a `HandleFunc`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s define the `Message` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This contains information about the Slack user who sent the message, information
    about the `AppMention` event, and the cleaned-up text that the user sent (removes
    the `@User` text and leading/trailing spaces).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s define our `Bot` type and its constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This code contains our clients that will be used to interact with Slack, a context
    for canceling our bot's goroutines, `defaultHandler` for handling the case where
    no regex matches happen, and a list of registrations that we check on any message
    receipt.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need some methods to start and stop our bot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This simply starts our event loop and calls `RunContext` to listen to our event
    stream. We cancel our bot using the supplied `context.Bot`. `Start()` blocks until
    `Stop()` is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our next method will allow us to register our regexes and their handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this code, if we don't supply a regex, then `HandleFunc` is used as the default
    handler when no regexes match. You can only have one default handler. When the
    bot checks a message, it matches regexes in the order they are added; the first
    match wins.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at our event loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we pull events off the `socketmode` client. We switch on the type of
    event. For our purposes, we are only interested in two types of events:'
  prefs: []
  type: TYPE_NORMAL
- en: Error connecting to the WebSocket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `EventTypeEventsAPI` event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `EventTypeEventsAPI` type is an interface that we turn into its concrete
    type, `slackevents.EventsAPIEvent`. We acknowledge receipt of the event and send
    the event to be handled by a method called `appMentioned()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are other events you might be interested in. You can find a list of the
    official events supported by Slack here: [https://api.slack.com/events](https://api.slack.com/events).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Go package event support may be slightly different and can be found here:
    [https://pkg.go.dev/github.com/slack-go/slack/slackevents#pkg-constants](https://pkg.go.dev/github.com/slack-go/slack/slackevents#pkg-constants).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s build `appMentioned()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Slack events are events wrapped inside events, so it takes a little decoding
    to get to the information you need. This code looks at the event data type and
    uses that information to know what type to decode.
  prefs: []
  type: TYPE_NORMAL
- en: For `appMentioned()`, this should always be `slackevents.CallbackEvent`, which
    decodes its `.Data` field into a `*slackevents.EventsAPICallbackEvent` type.
  prefs: []
  type: TYPE_NORMAL
- en: That has `.InnerEvent`, which can decode into a few other event types. We are
    only interested if it decodes to `*slackevents.AppMentionEvent`.
  prefs: []
  type: TYPE_NORMAL
- en: If it does, we call another internal method called `makeMsg()` that returns
    the message type we defined earlier. We are going to skip the `makeMsg()` implementation,
    as it has some deep JSON data conversions that, due to the nature of JSON, are
    a little convoluted and uninteresting. You can just lift it from the linked code.
  prefs: []
  type: TYPE_NORMAL
- en: We then loop through our regexes looking for a match. If we find one, we call
    `HandleFunc` on that message and stop processing. If we don't find a match, we
    call `defaultHandler`, if it exists.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have a bot that can listen for when it is mentioned in a message and
    dispatch the message to a handler. Let's tie that into making some calls to our
    Ops service.
  prefs: []
  type: TYPE_NORMAL
- en: Creating event handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `HandleFunc` type we defined in the last sections handles the core of our
    functionality. This is also where we decide on how we want to turn a bunch of
    text into a command to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few ways to interpret raw text:'
  prefs: []
  type: TYPE_NORMAL
- en: Regexes via the `regexp` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: String manipulation via the `strings` package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing or using a lexer and parser
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regexes and string manipulation are the fastest ways for an application of this
    type where we have single lines of text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lexers and parsers are great when you need to deal with complex inputs or multi-line
    text and cannot afford mistakes. This is the method that compilers use to read
    your textual code into instructions that eventually lead to a compiled binary.
    Rob Pike has a great talk on writing one in Go that you can view here: [https://www.youtube.com/watch?v=HxaD_trXwRE](https://www.youtube.com/watch?v=HxaD_trXwRE).
    The downside is that they are tedious to build and hard to train new people on.
    If you need to watch that video a few times to get the concept, you are not alone.'
  prefs: []
  type: TYPE_NORMAL
- en: Case Study – Regexes versus Lexer and Parser
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the biggest jobs for network automation is getting information out of
    different devices made by different vendors. Some vendors provide information
    via the **Simple Network Management Protocol** (**SNMP**), but for many types
    of information or debugging, you have to go to the CLI to get information.
  prefs: []
  type: TYPE_NORMAL
- en: On newer platforms, this can come in the form of JSON or XML. Many platforms
    don't have structured output, and sometimes, the XML is so badly formed that it
    is easier to use unstructured data.
  prefs: []
  type: TYPE_NORMAL
- en: At Google, we started with writing tools that used regexes. Regexes were buried
    in every individual tool, which lead to multiple implementations of data wrangling
    for the same data. This was a huge waste of effort and introduced different bugs
    to different tools.
  prefs: []
  type: TYPE_NORMAL
- en: Router output can be complex, so eventually, a special regex engine was made
    to deal with these complex multi-line regexes and a central repository was created
    where command output regexes could be found.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, we were trying to use a tool that wasn't suited for the job.
    That package was so complex that it required its own debugger for development.
    More importantly, it would fail silently, inputting zero values in fields when
    a vendor would change the output slightly on new OS releases. This caused a few
    not-so-minor issues in production.
  prefs: []
  type: TYPE_NORMAL
- en: We eventually moved to a lexer and parser that would always detect when the
    output was not as expected. We didn't want it to be quite as complex as a full
    lexer and parser, so we wrote a package that allowed very limited regex usage
    and validation of many of the data fields.
  prefs: []
  type: TYPE_NORMAL
- en: There is a certain amount of love/hate for that package when you have to interpret
    new data with it. The great thing is it doesn't fail silently on changes, it is
    lightning fast, requires minimal effort to update, and uses minimal memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'But it does take a while to get your brain around the concepts and it takes
    a lot longer to write the matches. There is a public version I recreated after
    I left Google called the Half-Pike that you can find here: [https://github.com/johnsiilver/halfpike](https://github.com/johnsiilver/halfpike).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For our first handler, we want to return a list of traces to the user. The
    main command is `list` `traces` followed by optional arguments. For options, we
    want the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`operation=<operation name>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start=<mm/dd/yyyy-hh:mm>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`end=<mm/dd/yyyy-hh:mm, now>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limit=<number of items>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tags=<[tag1,tag2]>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These options allow us to limit what traces we see. Maybe we only want to see
    traces for some certain period and only want the ones we tagged with `error`.
    This allows us to do filtered diagnostics.
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick example of using this command would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'All of our handlers will be talking to the Ops service via gRPC. We will create
    a type that can hold all the `HandlFunc` types we define and the clients they
    will need to access our Ops service and Slack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This defines our basic type that will hold a single client to our Ops service.
    We will attach methods that implement the `HandleFunc` type. It also defines a
    `write()` method for writing text back to the user in Slack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to define a package level variable for the regex we need to tease
    apart our options. We define it at the package level so that we only need to compile
    it once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can see how our regex matches a key/value pair separated by `=`. The `opt`
    type is meant to hold our option key and value once we tease it apart with the
    regex.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now for the handler that lists the traces we specify with our filters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`ListTraces` implements the `HandleFunc` type we created earlier. We split
    the list traces text from `Message.Text` that the user sent and remove any excess
    space at the beginning or end using `strings.TrimSpace()`. We then use our regex
    to create all our options.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to process those options so we can send them to the Ops server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This code loops through the options we teased from the command and appends call
    options for sending to the Ops service. If there are any errors, we write to Slack
    to let them know there was a problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s make our gRPC call to the Ops service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This code uses our Ops service client to get a list of traces with the options
    that we passed. We use an ASCII table writing package ([github.com/olekukonko/tablewriter](http://github.com/olekukonko/tablewriter))
    to write out our traces table.
  prefs: []
  type: TYPE_NORMAL
- en: 'But how do users know what commands they can send? This is handled by providing
    a help handler for the bot. We will create a map that will hold our various help
    messages and another variable that will hold a list of all commands in alphabetical
    order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Our help text is indexed in our `help` map. `init()` sets up a complete list
    of commands in `cmdList` during program initialization.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s use those commands in a handler that provides help text if a user
    passed `help` to our bot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This code receives as input the command they want help with and outputs the
    help text if it exists. If they don't pass a command, it simply prints the list
    of commands we support.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we don''t have a handler to handle a particular command (maybe they misspelled
    the command), we need a handler as the last resort:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This simply informs the user that we don't know what they want, as it is not
    something we support.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a minimum set of handlers, but we still need to have a way to register
    it with the bot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This takes in a bot and registers our three handlers with regexes that will
    are used to determine which handler to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time for our `main()` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates our Ops object and registers any `HandleFunc` types we created
    with our bot. You can find the full code for the ChatOps bot here: [https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/11/chatbot/](https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/11/chatbot/).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've seen the foundation of writing our bot, let’s setup our Slack
    application and run our example code.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our Slack application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the bot to interact with Slack, we need to set up a Slack application:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to [https://api.slack.com/apps](https://api.slack.com/apps) on your
    browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here, you will need to click on the following button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Create New App button'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17626_11_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.2 – Create New App button
  prefs: []
  type: TYPE_NORMAL
- en: 'You will then be presented with the following dialog box:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Create an app options'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17626_11_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.3 – Create an app options
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose the **From an app manifest** option. This will present the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Choosing a workspace'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17626_11_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.4 – Choosing a workspace
  prefs: []
  type: TYPE_NORMAL
- en: Choose the workspace you created at the beginning of this section and then press
    **Create App**. Click the **Next** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy the text from the file present at [https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/11/chatbot/slack.manifest](https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/11/chatbot/slack.manifest)
    and paste it onto the screen that is shown as follows as YAML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.5 – App manifest configuration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17626_11_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.5 – App manifest configuration
  prefs: []
  type: TYPE_NORMAL
- en: The text you see in the preceding figure should be replaced with the text from
    the file. Click the **Next** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will be presented with a summary of the bots permissions, shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6 – Bot creation summary'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17626_11_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.6 – Bot creation summary
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Create** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will move you to a page that is called **Basic Information**. Scroll down
    the page until you get to **App-Level Tokens**, as can be seen in the following
    figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.7 – App-level token list'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17626_11_007.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.7 – App-level token list
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **Generate Token and Scopes** button. This will lead you to the following
    dialog box:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.8 – App token creation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17626_11_008.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.8 – App token creation
  prefs: []
  type: TYPE_NORMAL
- en: Set the token name to `petstore-bot`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide these scopes in the `connections:write` and `authorizations:read`. Now,
    click **Generate**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next screen, you will receive an app-level token. You will need to hit
    the **Copy** button and put the token somewhere for the time being.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.9 – App token information'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17626_11_009.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.9 – App token information
  prefs: []
  type: TYPE_NORMAL
- en: In a production environment, you want to put this in some type of secure key
    store, such as Azure Key Vault or AWS Key Management Service. You will need to
    put it in a file called the `.env` file that you should never check into a repository.
    We will cover making this file in the *Running the applications* section.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The key here is for a bot that was deleted right after this screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Done** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the left menu pane, choose **OAuth and Permissions**. On the screen that
    looks like the following, click **Install to Workspace**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.10 – Install tokens in your workspace'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17626_11_010.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.10 – Install tokens in your workspace
  prefs: []
  type: TYPE_NORMAL
- en: There is a dialog box that asks for a channel to post as an app. Choose any
    channel you like and hit **Allow**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You are now back to **OAuth and Permissions**, but you will see your bot's **auth
    token** listed. Hit the **Copy** button and store this where you stored the app
    token from earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Running the applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we are going to use Docker Compose to turn up our Open Telemetry services,
    Jaeger, Prometheus, and our Petstore application. Once those are running we will
    use Go to compile and run our ChatOps service that implements the chatbot connected
    to Slack:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Go-for-DevOps` repository ([https://github.com/PacktPublishing/Go-for-DevOps/](https://github.com/PacktPublishing/Go-for-DevOps/)),
    go to the `chapter/11` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Turn up the Docker containers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once the environment is running, change to the `chapter/11/chatops` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will need to create a `.env` file in this directory that contains the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These were generated when we set up the Slack app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the ChatOps server with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should be able to see the following message printed to standard output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the background, there is a demonstration client that is adding pets to the
    pet store and doing searches for pets (some searches will cause errors). The service
    is set to Float sampling, so not every call will generate a trace.
  prefs: []
  type: TYPE_NORMAL
- en: 'In another terminal, you can interact with the pet store by using the CLI application.
    This will let you add your own pets, delete pets, and search for pets with a filter.
    That client can be found here: `chapter/11/petstore/client/cli/petstore`. You
    can find instructions on its use by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Traces can be observed at `http://127.0.0.1:16686/search`.
  prefs: []
  type: TYPE_NORMAL
- en: Prometheus metrics can be queried at `http://127.0.0.1:9090/graph`.
  prefs: []
  type: TYPE_NORMAL
- en: To interact with our ChatOps bot, you need to open Slack and add the bot to
    a channel. You can do this simply by doing a `@PetStore` mention in a channel.
    Slack will ask if you would like to add the bot to the channel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once that happens, you can try out various operations. Start by asking the
    bot for help, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.11 – Basic help command output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17626_11_011.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.11 – Basic help command output
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s ask for some help on how we can list some traces:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.12 – Help output for the list traces command'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17626_11_012.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.12 – Help output for the list traces command
  prefs: []
  type: TYPE_NORMAL
- en: 'How about we ask the system to give us five recent traces:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.13 – Output from a command to list the last five traces'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17626_11_013.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.13 – Output from a command to list the last five traces
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also ask about a particular trace:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.14 – Output showing a specific trace''s data'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17626_11_014.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.14 – Output showing a specific trace's data
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You cannot directly paste a trace ID copied from list traces. This is because
    those are hyperlinks; you need to remove the rich text from an ID if you want
    to directly paste it for `show trace`.
  prefs: []
  type: TYPE_NORMAL
- en: There are more options for you to play with in the bot. Give them a try.
  prefs: []
  type: TYPE_NORMAL
- en: This ChatOps application is just the tip of the iceberg. You can make the ChatOps
    application more powerful than the one we have here. You can have it display graphs,
    grab profile information from a `pprof` dump from the service and give you a link
    to view it, have it deploy new versions of your application, or roll a version
    back. Push files to the service by simply dragging them into the Slack window
    (such as a configuration change). Important events such as alerts can be broadcast
    to people who are on call by having the Ops service send messages to the ChatOps
    service, and the use of ChatOps increases observability of what your service is
    doing and what operations are being done against the service.
  prefs: []
  type: TYPE_NORMAL
- en: And as a side effect, unlike tools that must be run on a laptop or desktop,
    Slack and many other chat applications have mobile versions, so you can interact
    or do emergency operations with your cell phone with no extra cost in development.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [*Chapter 9*](B17626_09.xhtml#_idTextAnchor461), *Observability with OpenTelemetry*,
    we explored how using Open Telemetry can provide observability into your application
    and the applications it depends on. We discussed how to set up telemetry for your
    application using the two most popular backends: Jaeger and Prometheus, which
    are both written in Go. In [*Chapter 10*](B17626_10.xhtml#_idTextAnchor496), *Automating
    Workflows with GitHub Actions*, we showed how you can use GitHub actions to automate
    your code deployments and how to add custom actions using Go. Finally, in this
    chapter, we looked at the architecture for interacting with a service. We built
    an interaction layer using Slack to do operations such as filtering traces, getting
    the currently deployed version, and showing alerts.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next set of chapters, we will talk about how to use Go, and tools written
    in Go, to ease the burden of working in the cloud. This will cover building standard
    images that can be deployed to VMs or other node infrastructure. We will show
    how you can extend Kubernetes, the most popular container orchestration system
    on the market today. Finally, we will guide you on how you can design DevOps workflows
    and systems to protect yourself from the chaos that is inherent in running operations
    against infrastructure.
  prefs: []
  type: TYPE_NORMAL
