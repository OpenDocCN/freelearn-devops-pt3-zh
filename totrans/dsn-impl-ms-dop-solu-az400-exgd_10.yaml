- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Integrating Continuous Testing
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整合持续测试
- en: In previous chapters, you learned about the different types of techniques that
    are used to help increase the rate at which you deliver changes to your production
    environment. If you are already using these techniques in your daily work, you
    will quickly notice that this is only possible if your work is of sufficient quality.
    If the quality of your work is not high enough, you will face many outages or
    issues and your end users will not be happy. To be successful, increasing the
    rate of change and increasing the quality of your work must go hand in hand. To
    assess the quality of your work and increase it, you first need to know what is
    meant by quality. This is where testing comes in. Testing is the discipline of
    reporting on the quality of software.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，你了解了不同的技术，这些技术有助于提高你将变更交付到生产环境的速度。如果你已经在日常工作中使用这些技术，你会很快发现，这只有在你的工作质量足够高时才可能实现。如果你的工作质量不够高，你将面临许多故障或问题，最终用户也不会满意。要取得成功，提高变更的速度和提高工作质量必须齐头并进。要评估并提高工作质量，你首先需要知道什么是质量。这就是测试的作用所在。测试是报告软件质量的学科。
- en: To introduce the topic of testing, this chapter will start by looking at how
    the quality of software development can be measured. After that, the topic of
    functional testing will be explored. As we progress through this chapter, we will
    explore the different testing strategies to determine what types of tests are
    needed and how many of each should be used. After this, the different types of
    tests will be discussed one by one. You will learn about how they work, what they
    test, and the benefits and downsides of each one. Finally, the last section will
    focus on how all metrics and test results, once generated and collected by your
    pipelines, can continuously report on the quality of the work of your team and
    even prevent changes of insufficient quality propagating to your users. All of
    this will help you maintain the high quality of your software and enable you to
    confidently deliver that software quickly and frequently.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了引入测试的主题，本章将首先讨论如何衡量软件开发的质量。之后，将深入探讨功能测试的主题。在本章的进展过程中，我们将探讨不同的测试策略，以确定需要哪些类型的测试，以及每种测试应使用多少次。之后，我们将逐一讨论不同类型的测试。你将了解它们的工作原理、测试内容以及每种测试的优缺点。最后，最后一部分将重点讨论如何利用你的管道生成和收集的所有指标和测试结果，持续报告团队工作的质量，甚至防止质量不足的变更传播到用户。所有这些都将帮助你保持软件的高质量，并使你能够自信地快速频繁地交付软件。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Defining quality
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义质量
- en: Understanding test types
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解测试类型
- en: Executing tests in a pipeline
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在管道中执行测试
- en: Maintaining quality
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 维护质量
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To experiment with the techniques described in this chapter, you might need
    one or more of the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要实验本章中描述的技术，你可能需要以下一项或多项：
- en: An Azure DevOps project with access to build and release pipelines and dashboards
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个具有构建和发布管道及仪表板访问权限的 Azure DevOps 项目
- en: Visual Studio Code, Visual Studio 2019, or Visual Studio 2022
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code、Visual Studio 2019 或 Visual Studio 2022
- en: A Basic + Test Plans license for Azure DevOps
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure DevOps 的 Basic + 测试计划许可
- en: A SonarCloud subscription
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 SonarCloud 订阅
- en: All of these are available for free or can be obtained for free for a limited
    trial period.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以免费获得，或在有限的试用期内免费提供。
- en: Defining quality
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义质量
- en: 'One of the primary goals of the DevOps mindset discussed in [*Chapter 1*](B18655_01.xhtml#_idTextAnchor014),
    *Introduction to DevOps*, is increasing the flow of value to end users. To do
    this, software must be deployed frequently, maybe even multiple times per day.
    To make frequent deployments possible, two things are important: automation and
    quality. Automation has been discussed extensively in the previous chapters, so
    now it is time to move on to the topic of quality.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第1章*](B18655_01.xhtml#_idTextAnchor014)中讨论的 DevOps 思维模式的主要目标之一是增加价值流向最终用户。为了做到这一点，软件必须频繁部署，甚至可能一天多次部署。要使频繁部署成为可能，有两个重要因素：自动化和质量。自动化在前面的章节中已经讨论过了，因此现在是时候转向质量的主题了。'
- en: Once an automated build and release pipeline is in place and changes are starting
    to flow to production at an increasing speed, it is time to start measuring the
    quality of these changes. Even more importantly, this allows us to abort changes
    that are not of sufficient quality.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦自动构建和发布流水线就绪，且更改开始以越来越快的速度流向生产环境，就该开始衡量这些更改的质量了。更重要的是，这使我们能够中止质量不够高的更改。
- en: What actually makes quality *sufficient* can differ from project to project.
    When creating games, a few bugs might be annoying for the user but nothing more.
    When creating software for airplanes or medical use, a single bug may cost lives.
    In software, higher quality is more expensive and/or takes more time. So, there
    is a trade-off between the number of features we can deliver and the quality that
    can be guaranteed. For every project, there is a different optimal trade-off between
    these.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，什么构成足够的质量可能因项目而异。在创建游戏时，一些小错误可能对用户造成困扰，但不会造成其他影响。而在为飞机或医疗用途开发软件时，一个错误可能会危及生命。在软件开发中，较高的质量通常更昂贵且/或需要更多时间。因此，我们在交付功能的数量和能够保证的质量之间存在权衡。每个项目都有不同的最佳权衡点。
- en: 'Before quality can be measured, it is important that you first establish how
    to measure the quality of software. A common approach to monitoring the quality
    of software is to gather one or more metrics. For example, it could be decided
    to collect a set of five measurements every week. Graphing these metrics over
    time provides insight into how the quality of the software is evolving. An example
    of this might look something like the graph shown here:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在质量得以衡量之前，首先要确定如何衡量软件的质量。监控软件质量的常见方法是收集一个或多个度量。例如，可以决定每周收集五个度量值。随着时间的推移，将这些度量值绘制成图表，可以深入了解软件质量如何变化。一个例子可能像这里显示的图表那样：
- en: '![Figure 10.1 – Software quality metrics measurement example ](img/B18655_10_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – 软件质量度量示例](img/B18655_10_01.jpg)'
- en: Figure 10.1 – Software quality metrics measurement example
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – 软件质量度量示例
- en: The next sections discuss several examples of metrics.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分讨论了几个度量示例。
- en: Metrics for quality
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 质量度量
- en: Metrics are a means of capturing something that is measured as a number. In
    software development, metrics are often used to represent a particular quality
    aspect that can be hard to quantify in itself. For example, the quality of a piece
    of software can be very hard to describe by itself. This holds even more for how
    quality changes. For this reason, we often capture numbers that, taken together,
    say something about the quality of software.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 度量是捕捉某些内容的手段，这些内容通过数字来表示。在软件开发中，度量通常用于表示一个特定的质量方面，这个方面本身可能很难量化。例如，一段软件的质量可能很难单独描述。这一点对于质量变化的描述尤为明显。出于这个原因，我们通常会收集多个数字，综合来看它们能反映软件的质量。
- en: It is important to realize that metrics are a great tool but should always be
    used with caution. For one thing, there might be more factors influencing the
    (perceived) quality of software than the metrics that are being measured. Also,
    once people know that a specific metric is recorded, they can optimize their work
    to increase or decrease the metric. While this might show the desired numbers
    in reports, it might not necessarily mean software quality is really improving.
    To combat this, often, more than one metric is recorded.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 需要意识到，度量是一个很好的工具，但应该谨慎使用。一方面，可能有比正在测量的度量值更多的因素影响软件的（感知）质量。另外，一旦人们知道某个特定的度量值被记录下来，他们可能会优化工作方式以提高或降低该度量值。虽然这可能在报告中显示出期望的数字，但并不一定意味着软件质量真正得到了改善。为了解决这个问题，通常会记录多个度量值。
- en: A well-known example is that of story point velocity in Agile work environments.
    Recording the sprint velocity for a team to see whether it is becoming more efficient
    over time sounds effective; however, if the team size varies from sprint to sprint,
    then the metric might be useless since attendance is influencing velocity as well.
    Also, the metric can be easily falsified by a team agreeing on multiplying all
    estimations by a random number every sprint. While this would increase the numbers
    every sprint, it would not relate to an increase in team throughput anymore.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一个广为人知的例子是在敏捷工作环境中使用故事点速度。记录团队的迭代速度，以观察其是否随着时间变得更加高效，这听起来很有效；然而，如果团队规模在每次迭代中都不同，那么这个度量可能就没什么用处，因为团队成员的出席情况会影响速度。此外，团队可以轻松地通过每次迭代时将所有估算值乘以一个随机数来伪造这个度量。尽管这样每次迭代的数字会增加，但它与团队的生产力增长并无关系。
- en: Moving on to metrics for measuring the quality of software, it can be difficult
    to objectively measure the quality of written code. Developers often have many
    opinions as to what constitutes *good code*, and the more the topic is discussed,
    the harder it can be to find consensus in a team; however, when shifting attention
    to the results that come from using that code, it becomes easier to identify metrics
    that can help provide insights into the quality of the code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 进入到衡量软件质量的指标时，客观地衡量编写代码的质量可能会很困难。开发人员通常对什么构成*优质代码*有许多看法，讨论越多，团队越难达成共识；然而，当我们将注意力转向使用这些代码后产生的结果时，就更容易识别出可以帮助提供代码质量洞察的指标。
- en: 'Some examples of this are as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一些例子：
- en: '**The percentage of integration builds that fail**: If code does not compile
    or pass automated tests, then this is an indication that it is of insufficient
    quality. Since tests can be executed automatically by build pipelines whenever
    a new change is pushed, they are an excellent tool for determining the quality
    of code. Also, since they can be run and their results gathered before we deploy
    a change to production, the results can be used to cancel a change of insufficient
    quality or that might impact certain system functionality before deploying it
    to the next stage of a release pipeline. This way, only changes of sufficient
    quality propagate to the next stage.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成构建失败的百分比**：如果代码无法编译或无法通过自动化测试，这表明代码的质量不足。由于测试可以通过构建流水线在每次推送新变化时自动执行，它们是判断代码质量的绝佳工具。而且，由于它们可以在将变更部署到生产环境之前执行并收集结果，这些结果可以用来取消那些质量不足或可能影响某些系统功能的变更，从而在发布流水线的下一个阶段前阻止这些问题。这种方式保证了只有质量足够的变更才会传递到下一个阶段。'
- en: '**The percentage of code covered by automated tests**: If a large part of the
    code is being tested by unit tests, this increases the quality of the software.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化测试覆盖的代码百分比**：如果大部分代码都通过单元测试进行测试，这将提高软件的质量。'
- en: '**The change failure rate**: This is the percentage of deployments of new versions
    of the code that lead to issues. An example of this is a situation where the web
    server runs out of memory after the deployment of a new version of the application.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变更失败率**：这是指部署新版本代码后导致问题的百分比。一个例子是应用程序的新版本部署后，Web服务器内存耗尽的情况。'
- en: '**The amount of unplanned work**: The amount of unplanned work that has to
    be performed in any period of time can be a great metric of quality. If the team
    is creating a SaaS offering that is also operating, there will be time spent on
    operational duties. This is often referred to as unplanned work. The amount of
    unplanned work can be an indicator of the quality of the planned work. If the
    amount of unplanned work increases, then this may be because the quality has gone
    down. Examples of unplanned work can be live site incidents, following up on alerts,
    hotfixes, and patches.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计划外工作的数量**：在任何一段时间内必须执行的计划外工作的数量是衡量质量的一个重要指标。如果团队正在创建一个同时在运行的SaaS产品，那么就会有时间花费在运营职责上。这通常被称为计划外工作。计划外工作的数量可以反映计划工作质量的情况。如果计划外工作的数量增加，可能是因为质量下降了。计划外工作的例子包括现场故障事件、跟进警报、热修复和补丁。'
- en: '**The number of defects that are being reported by users**: If the number of
    bugs reported by users increases, this can be a sign that quality has been declining.
    Often, this is a lagging indicator, so once this number starts increasing, quality
    might have been going down for a while already. Of course, there can be many other
    reasons for this number increasing, such as new operating systems, an increase
    in the number of users, or changing expectations from users.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用户报告的缺陷数量**：如果用户报告的错误数量增加，这可能是质量下降的迹象。通常，这是一种滞后性指标，一旦这个数字开始上升，质量可能已经在一段时间内下滑了。当然，这个数字增加可能有很多其他原因，比如新的操作系统，用户数量的增加，或用户期望的变化。'
- en: '**The number of known issues**: Even if there are very few new defects being
    found or reported, if defects are never fixed and the number of known issues keeps
    increasing slowly, then the quality of the software will slowly decline over time.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已知问题的数量**：即使发现或报告的新缺陷很少，如果缺陷从未被修复，并且已知问题的数量一直在缓慢增加，那么软件的质量将随着时间的推移而逐渐下降。'
- en: '**The amount of technical debt**: Technical debt is a term used to describe
    the consequences of sacrificing code quality for short-term gains, such as the
    quick delivery of code. Technical debt is discussed in detail in the next section.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术债务的量**：技术债务是一个术语，用来描述为短期利益（例如快速交付代码）而牺牲代码质量的后果。技术债务将在下一节中详细讨论。'
- en: Testing is an activity that is performed to find and report on the quality of
    software. Test results (insights into quality) can be used to allow or cancel
    a change progressing to the next release stage.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是一项活动，旨在发现并报告软件的质量。测试结果（对质量的洞察）可以用来决定是否允许或取消某个更改进入下一个发布阶段。
- en: 'In the next section, another dimension of quality is explored: the amount of
    technical debt in a code base.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，将探讨质量的另一个维度：代码库中的技术债务量。
- en: Technical debt
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术债务
- en: Technical debt is a term that describes the future costs of sacrificing code
    quality for something else. For example, to expedite the delivery of a new feature,
    a developer may choose to quickly expand an existing class with a few new methods.
    If the resulting class does not adhere to the principles of object-oriented design
    or grows to be too large, this can make for a class that is difficult to understand
    and maintain or change later. The term *debt* implies that something (time, quality,
    attention, or work) is owed to the solution. So long as this debt is not paid
    off, you have to pay interest in the form of all other work being slowed down
    a little bit.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 技术债务是一个术语，用来描述为追求其他目标而牺牲代码质量所带来的未来成本。例如，为了加快新特性的交付，开发者可能选择快速扩展现有类并添加一些新方法。如果由此产生的类不符合面向对象设计原则，或者变得过于庞大，那么这个类可能会变得难以理解、维护或以后进行更改。术语*债务*意味着某种东西（时间、质量、注意力或工作）在解决方案中仍然欠缺。只要这笔债务没有偿还，你就必须支付“利息”，即所有其他工作的进度都会稍微放慢。
- en: 'Technical debt can take many forms, but some examples are as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 技术债务有许多形式，以下是一些示例：
- en: Code that is not covered by any unit test where changes to the implementation
    of said code cannot be verified using the original tests that were used to create
    it
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有任何单元测试覆盖的代码，其中对该代码的实现进行更改时无法使用原始测试来验证
- en: Code that is not written in a self-explanatory fashion using meaningful variable
    and method names
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有以自解释的方式编写的代码，即没有使用有意义的变量和方法名称
- en: Code that does not adhere to coding principles, such as KISS, YAGNI, DRY, and/or
    SOLID
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不遵循编码原则的代码，例如 KISS、YAGNI、DRY 和/或 SOLID
- en: Classes that are too complex because they have too many variables and methods
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类因为变量和方法太多而变得过于复杂
- en: Methods that are too complex because they have too many statements (flow control
    statements specifically)
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法因为语句太多（尤其是流程控制语句）而变得过于复杂
- en: Classes or namespaces that have circular dependencies through different parts
    of the application
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在应用程序的不同部分之间存在循环依赖的类或命名空间
- en: Classes that do not adhere to the architectural design of the application
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不遵循应用程序架构设计的类
- en: There are many forms of technical debt, and it can be daunting to oversee all
    of them. For this reason, there are many tools available that can measure the
    technical debt in a code base automatically and report on it. Tools for doing
    this will be discussed in the *Maintaining quality* section.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 技术债务有许多形式，监督所有这些形式可能会让人感到艰难。因此，市面上有很多工具可以自动衡量代码库中的技术债务并报告它。处理这些问题的工具将在*维护质量*一节中讨论。
- en: While technical debt is often considered a bad thing, there might be good reasons
    for creating technical debt on purpose. Just as with a regular debt, it is important
    to manage the height of the debt and ensure that interest can be paid and the
    debt itself can be paid off.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然技术债务通常被认为是一件坏事，但有时故意制造技术债务也可能有正当理由。就像常规债务一样，管理债务的规模并确保能够支付利息并偿还债务是非常重要的。
- en: Companies often take on technical debt during the start-up phase, where it is
    often a conscious decision to quickly create a working solution. While this first
    version is used to validate the business proposition and attract funds, developers
    can pay off this debt by reimplementing or refactoring (parts of) the application.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 公司在初创阶段通常会承担技术债务，这往往是为了快速创建一个可用的解决方案而做出的有意识决定。虽然这个初始版本用于验证商业提案并吸引资金，但开发者可以通过重新实现或重构（部分）应用程序来偿还这笔债务。
- en: Another reason might be a market opportunity or an important business event
    that has been planned months in advance. Taking on some technical debt to meet
    deadlines and deliver on time can be worth the cost.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个原因可能是市场机会或已提前几个月计划的重要商业事件。为了按时交付并满足截止日期，承担一定的技术债务可能是值得的。
- en: However, never paying the debt and only taking on more debt over time will also
    increase the metaphorical interest to be paid every time a developer needs to
    make a change. The result will be that any change will take longer than the previous
    one. If this starts happening, it is unavoidable that at some point no change
    will be worthwhile anymore, since the cost always outweighs the benefits. At this
    point, a project or product has failed.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果从未偿还债务，而只是随着时间推移不断增加更多债务，这也会增加隐喻上的利息，每次开发者需要进行更改时都需要支付。结果是，任何更改都将比上一次花费更多时间。如果这种情况开始发生，最终会不可避免地出现某个时候任何更改都不再值得进行，因为成本总是大于收益。在这一点上，项目或产品就失败了。
- en: When talking about tests, it is important to understand which types of tests
    exist. The next section will go into this subject.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论测试时，理解存在哪些类型的测试是非常重要的。下一节将深入探讨这个话题。
- en: Understanding test types
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解测试类型
- en: In traditional software development, tests were often executed when *development
    was complete*, the *application was declared dev-done*, the *feature set was frozen*,
    or a similar situation. After declaring the development done, testing was performed,
    and often, a long period of going back and forth between testing and bug fixing
    started. The result was often that many bugs were still found after going live.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的软件开发中，测试通常在*开发完成*、*应用程序被声明为开发完成*、*功能集被冻结*或类似的情况下执行。在宣布开发完成后进行测试，通常会进入一个长时间的测试与修复
    bug 往返周期。结果通常是，在上线后仍然发现许多 bug。
- en: Shifting left is a testing principle that states that automated testing should
    be done earlier in the development process. If all activities involved with software
    development are drawn on a line from inception to release, then shifting left
    means moving automated testing activities closer to inception.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 向左移动（Shifting left）是一个测试原则，指的是应该在开发过程的早期进行自动化测试。如果将与软件开发相关的所有活动绘制成从初始到发布的时间线，那么向左移动意味着将自动化测试活动更靠近初始阶段。
- en: 'To do this, a wide selection of different types of tests is recognized—for
    example, unit tests, integration tests, and system tests. Different sources can
    suggest different types of tests, but these are some of the more well-known types.
    No matter the specific name of a type of test, when looking at tests with a high
    level of abstraction, they are often divided into the following two categories:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，已经认识到许多不同类型的测试——例如单元测试、集成测试和系统测试。不同的来源可能会建议不同类型的测试，但这些是一些比较知名的类型。不管测试的具体名称是什么，从高度抽象的层面来看，它们通常被分为以下两类：
- en: '**Functional tests**: Functional tests are used to test whether the desired
    functionality is actually realized by the application.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能测试**：功能测试用于测试应用程序是否实际实现了所需的功能。'
- en: '**Non-functional tests**: Non-functional tests are used to verify whether the
    other desired properties of an application are realized and that undesirable properties
    are not present.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非功能测试**：非功能测试用于验证应用程序的其他期望属性是否得以实现，并确保没有出现不期望的属性。'
- en: 'These types are further broken down into smaller subcategories, as shown in
    the following diagram:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类型进一步细分为更小的子类别，如下图所示：
- en: '![Figure 10.2 – Understanding test types ](img/B18655_10_02.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图10.2 – 理解测试类型](img/B18655_10_02.jpg)'
- en: Figure 10.2 – Understanding test types
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.2 – 理解测试类型
- en: The following three sections contain brief recaps of the different types of
    functional and non-functional tests. This is to facilitate later discussions on
    which type of test to choose in which situation and how much of each type of test
    your project might need.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三节内容简要回顾了不同类型的功能性测试和非功能性测试。这是为了便于后续讨论在不同情况下选择哪种测试类型以及项目可能需要多少种测试。
- en: Types of automated functional tests
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化功能测试的类型
- en: 'When talking about automated functional tests, the three most-used types are
    unit tests, integration tests, and system tests. These types of tests can be compared
    along several axes: the time it takes to create a test, the time it takes to execute
    a test, and the scope that they test:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在谈论自动化功能测试时，三种最常用的类型是单元测试、集成测试和系统测试。这些测试类型可以从多个维度进行比较：创建测试所需的时间、执行测试所需的时间以及它们测试的范围：
- en: '**Unit tests**: Unit tests are the quickest to write, and they execute very
    quickly, often in less than a millisecond. They test the smallest possible scope
    in an application, often a single class or method. This means that, once written,
    it should virtually never be necessary to change a unit test. For many systems,
    it is more likely that a test will be deleted rather than changed.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：单元测试是最快编写的，它们的执行速度非常快，通常在不到一毫秒的时间内完成。它们测试的是应用程序中最小的范围，通常是单个类或方法。这意味着，一旦编写完成，几乎不需要更改单元测试。对于许多系统来说，更有可能的是测试会被删除，而不是被修改。'
- en: '**Integration tests**: Integration tests take more time to write since they
    are concerned with multiple units that have to be set up to work together. The
    execution of these tests should still be fast, averaging from below a second up
    to tens of seconds. Integration tests have a larger test scope, which means that,
    in return for this, they will cover a larger part of the code and are more likely
    to detect defects that are introduced with a change.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：集成测试需要更多的时间来编写，因为它们涉及多个必须设置以便协同工作的单元。这些测试的执行仍然应该很快，通常从不到一秒到几十秒不等。集成测试的测试范围更大，这意味着，作为回报，它们将覆盖更多的代码部分，更有可能检测到因更改而引入的缺陷。'
- en: '**System tests**: System tests test a fully assembled and running application.
    Depending on the type of application, these are often API tests or automated UI
    tests. These tests take a lot of time to create since they rely on a deployed
    system to run and often require the setting up of an initial state in a database
    or another persistent store. The tests take a long time to execute, sometimes
    minutes per test. They are also less reliable and much more fragile than unit
    and integration tests. Even a minor change in an interface can cause a whole series
    of tests to fail. On the other hand, system tests can detect errors that both
    unit and integration tests cannot, since they actually test the running system.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统测试**：系统测试测试的是一个完全组装并正在运行的应用程序。根据应用程序的类型，这些通常是API测试或自动化UI测试。由于这些测试依赖于已部署的系统运行，并且通常需要在数据库或其他持久存储中设置初始状态，所以创建这些测试需要大量时间。它们的执行时间很长，有时每个测试需要几分钟。与单元测试和集成测试相比，系统测试的可靠性较差且更脆弱。即使是接口的小改动，也可能导致一系列测试失败。另一方面，系统测试能够检测到单元测试和集成测试无法检测的错误，因为它们实际测试的是正在运行的系统。'
- en: Important Note
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: Please note that having a large test scope in a test has both an upside and
    a downside. The upside is that it can detect many errors. The downside is that
    a failing test with a very large test scope provides only a limited insight into
    what has gone wrong. Such a test failure will often require more investigation
    than a failing test with a smaller test scope.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，测试中拥有较大测试范围既有优点也有缺点。优点是它可以检测到许多错误。缺点是，当测试范围非常大时，测试失败只提供有限的关于错误发生原因的信息。此类测试失败通常需要比小范围测试失败更多的调查。
- en: The following sections explore each type of test in more detail.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将更详细地探讨每种测试类型。
- en: Unit tests
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单元测试
- en: Unit tests are used to test a single unit in isolation. When working in an object-oriented
    programming language, this will come down to having one test class for every class
    in an application. For full test coverage, the test class will then have one or
    more tests for every public method of the corresponding application class.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试用于测试单个单元的独立性。在面向对象编程语言中，这通常意味着为应用程序中的每个类编写一个测试类。为了实现完全的测试覆盖，测试类将为对应应用程序类的每个公共方法编写一个或多个测试。
- en: 'Unit tests should run extremely fast—on average, in a few milliseconds or less.
    To make this possible, each class is instantiated without its dependencies. This
    is enabled by the use of interfaces, where classes depend on interfaces instead
    of directly on other classes. For tests, the dependencies are then replaced with
    mock classes, as shown in the following diagram. On the left, the runtime configuration
    is shown; on the right, the configuration during tests is shown:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试应该运行得非常快——平均来说，应该在几毫秒内完成。为了实现这一点，每个类都是在没有其依赖项的情况下实例化的。这是通过使用接口来实现的，类依赖接口，而不是直接依赖其他类。在测试中，依赖项会被模拟类替代，如下图所示。左侧显示的是运行时配置，右侧显示的是测试期间的配置：
- en: '![Figure 10.3 – Interface testing  ](img/B18655_10_03.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图10.3 – 接口测试](img/B18655_10_03.jpg)'
- en: Figure 10.3 – Interface testing
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图10.3 – 接口测试
- en: 'A mock class implements the same interface but has no behavior associated by
    default. Specific behavior can be set up on a per-test basis. Mocks can also be
    used to verify that certain operations or functions on a dependency are called.
    As an example, take the following C# class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一个模拟类实现相同的接口，但默认没有任何行为。可以根据每个测试设置特定的行为。模拟还可以用于验证是否调用了依赖项上的某些操作或函数。举个例子，以下是一个C#类：
- en: '[PRE0]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To instantiate this class in an automated test, an implementation of the `IMessageSender`
    interface is needed. To work around this dependency, a mocking framework such
    as Moq can be used to test `WorkDivider`, as follows. In these examples, **NUnit**
    is used as the testing framework:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要在自动化测试中实例化此类，需要实现`IMessageSender`接口。为了绕过这个依赖，可以使用像Moq这样的模拟框架来测试`WorkDivider`，如下所示。在这些示例中，**NUnit**作为测试框架：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This means that it is not possible to write unit tests for classes that interact
    with other systems, such as databases, caches, or message queues. To ensure that
    this does not make it impossible to cover large parts of the application with
    tests, it is common practice to isolate the integration with other systems in
    separate classes. These classes contain the interaction with a remote system,
    but no business logic and as little code as possible. It is then accepted that
    these classes are not covered by unit tests. The typical design patterns that
    are used to do this are the Facade, Adapter, and Repository patterns.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着无法为与其他系统（如数据库、缓存或消息队列）交互的类编写单元测试。为了确保这不会使覆盖应用程序的大部分部分变得不可能，通常的做法是将与其他系统的集成隔离在单独的类中。这些类包含与远程系统的交互，但不包含业务逻辑，并且尽可能少的代码。然后，接受这些类不包含在单元测试中的事实。通常用于实现这一点的设计模式有外观模式（Facade）、适配器模式（Adapter）和仓库模式（Repository）。
- en: Tip
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Links to a more detailed guide on writing unit tests and how to mock classes
    are included at the end of this chapter.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 本章末尾附有更详细的关于编写单元测试和如何模拟类的指南链接。
- en: Unit tests should be ready to run on the computer of every developer that clones
    the code base of an application. They should not require any special configuration
    or setup on the local computer and should be ready to go. This way, everyone who
    works with the code base can run the unit tests on their local computer. It is,
    therefore, a good practice for developers to run all unit tests on their own computers
    before pushing changes to the central repository.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试应该能够在每个开发者克隆应用程序代码库的计算机上运行。它们不应要求在本地计算机上进行任何特殊配置或设置，并且应随时可以运行。这样，所有与代码库合作的人员都可以在本地计算机上运行单元测试。因此，开发者在推送更改到中央代码库之前，应该在自己的计算机上运行所有单元测试，这是一个很好的实践。
- en: Next to this local verification step, unit tests should also be a part of the
    continuous integration build. You will learn how to do this in the *Executing
    tests in a pipeline* section later on. As long as there are failing unit tests
    in a pull request, it is better not to merge the changes to the master branch.
    This can even be made impossible using Git repo branch policies, which were discussed
    in [*Chapter 4*](B18655_04.xhtml#_idTextAnchor069), *Everything Starts with Source
    Control*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本地验证步骤，单元测试还应该成为持续集成构建的一部分。稍后你将学习如何在*管道中执行测试*的部分完成这一过程。只要拉取请求中有失败的单元测试，就最好不要将更改合并到主分支。这甚至可以通过使用Git仓库分支策略来实现，正如在[*第4章*](B18655_04.xhtml#_idTextAnchor069)中讨论的，*一切从源代码管理开始*。
- en: In the next section, the discussion of automated functional tests continues
    with integration tests.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，自动化功能测试的讨论将继续进行，重点是集成测试。
- en: Integration tests
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 集成测试
- en: 'Integration tests are used to test whether a group of components works together
    correctly. These tests are used for two purposes:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试用于验证一组组件是否能正确地协同工作。这些测试有两个目的：
- en: Increasing the test coverage for those parts of an application that are not
    covered by unit tests—for example, classes that interact with other systems
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加应用程序中未被单元测试覆盖的部分的测试覆盖率，例如与其他系统交互的类。
- en: Addressing risks that are not addressed in unit tests and mitigating risks where
    individual components are interacting with other systems to verify correct desired
    outcomes
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决单元测试未覆盖的风险，并在各个组件与其他系统交互时，减少风险以验证正确的预期结果。
- en: It can be hard to comprehend what integration risks may exist. Usually it is
    assumed that if the individual parts or components are working as per their specifications,
    the whole solution must also function properly. However, that invariably isn't
    the case, and many problems surface after the units are integrated. To understand
    this risk better, imagine that two components working together are responsible
    for climate control. One is written by measuring the temperature in degrees Celsius
    and the other is acting on that temperature, expecting its input in degrees Fahrenheit.
    It will quickly become clear that, while both components are working as intended,
    exchanging numbers and taking action based on those numbers, the combination will
    not produce the desired outcomes.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 理解可能存在的集成风险可能比较困难。通常假设如果各个部分或组件按其规格工作，那么整个解决方案也必定能正常运作。然而，事实并非总是如此，很多问题在单元集成后才显现出来。为了更好地理解这个风险，假设有两个组件共同负责气候控制。一个组件通过摄氏度来测量温度，另一个则基于温度做出反应，期待输入的是华氏度。很快就会发现，尽管这两个组件按预期工作，交换数字并根据这些数字采取行动，但它们的组合并不会产生预期的结果。
- en: Integration tests, especially those that interact with other systems, will not
    only take longer to run than unit tests but often require more setup or configuration
    to run as well. This may even include secrets such as usernames, passwords, or
    certificates. To handle configuration such as this, a settings file can be created
    next to the tests from which settings are loaded before the tests are executed.
    Every developer can then create their own copy of that file and run the tests
    using their own configuration.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试，尤其是那些与其他系统交互的测试，将不仅比单元测试运行得更慢，而且通常需要更多的设置或配置。这甚至可能包括用户名、密码或证书等机密信息。为处理此类配置，可以在测试旁边创建一个设置文件，并在执行测试之前从中加载设置。每个开发人员可以创建自己的该文件副本，并使用自己的配置运行测试。
- en: 'Continuing with the example from the previous section, let’s assume that the
    `MessageSender` class that implements the `IMessageSender` interface needs a connection
    string to do its work. A test class for `MessageSender` might then look as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 继续使用上一节的示例，假设实现了`IMessageSender`接口的`MessageSender`类需要一个连接字符串来执行工作。`MessageSender`的测试类可能如下所示：
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`connectionString,` needed for constructing the `MessageSender` class, is received
    from the `Parameters` object on `TestContext`. This is the `.runsettings` file
    available. The exact approach can vary per test framework. An example `.runsettings`
    file would look as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`connectionString`，用于构建`MessageSender`类，来自`TestContext`上的`Parameters`对象。这是可用的`.runsettings`文件。具体方法可能会因测试框架而异。一个示例的`.runsettings`文件如下所示：'
- en: '[PRE3]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Moving the settings out to a separate file ensures that secrets are not checked
    into source control. In the *Executing tests in a pipeline* section, you will
    learn how to build a `.runsettings` file for running tests in a pipeline.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 将设置移到单独的文件中，确保机密信息不会被提交到源代码控制中。在*在流水线中执行测试*一节中，你将学习如何为在流水线中运行测试构建`.runsettings`文件。
- en: 'This is because integration tests should also be part of the continuous integration
    build if possible. However, there is a risk that this will make a continuous integration
    build too slow. To counter this, one of the following solutions can be implemented:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，如果可能的话，集成测试也应该是持续集成构建的一部分。然而，这也存在一个风险，那就是可能会使持续集成构建变得过于缓慢。为了解决这个问题，可以实施以下解决方案之一：
- en: Integration tests are executed in a separate build that is triggered in parallel
    to the continuous integration build. This way, the duration of the continuous
    integration build stays low while the integration tests are still continuously
    executed, and developers get fast feedback on their work.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试在与持续集成构建并行触发的单独构建中执行。通过这种方式，持续集成构建的时长保持较低，同时集成测试仍然会被持续执行，开发人员能够快速获得反馈。
- en: Integration tests are executed later in the pipeline, closer to the release
    of the software—for example, before or after the deployment to a test environment.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成测试会在管道的后期执行，接近软件发布时执行——例如，在部署到测试环境之前或之后。
- en: The downside of the first approach is that executing integration tests this
    way will mean that the tests will no longer work as a quality gate before code
    is merged to the master. They will, of course, continue working as a quality-reporting
    mechanism. This means that while errors might be merged, they will be detected
    and reported by the build.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种方法的缺点是，以这种方式执行集成测试意味着测试将不再作为质量门控，在代码合并到主分支之前进行检查。当然，它们仍会继续作为质量报告机制工作。这意味着，虽然错误可能已经合并，但它们会被构建过程检测并报告。
- en: The second approach does not have this risk since executing the tests is still
    part of the pipeline from source control to production; however, in this approach,
    the execution of the tests might be deferred to a later moment in time if not
    every build enters at least part of the release pipeline. This means that defects
    might become visible later on, extending the time between detecting and fixing
    an issue.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法没有这种风险，因为执行测试仍然是从源代码管理到生产的管道的一部分；然而，在这种方法中，测试的执行可能会推迟到稍后的时间点，前提是并非每个构建都至少进入了部分发布管道。这意味着缺陷可能会稍后显现，从而延长了检测和修复问题之间的时间。
- en: In either approach, failing integration tests will no longer block merging changes
    and you hence have to find another way to ensure that developers will take responsibility
    for fixing the defect that caused the tests to fail.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 无论采取哪种方法，失败的集成测试将不再阻止合并更改，因此你必须找到另一种方式，确保开发人员会负责修复导致测试失败的缺陷。
- en: These trade-offs become even more evident with system tests, which often take
    so long that it is not possible to make them part of the continuous integration
    build.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这些权衡在系统测试中尤为明显，系统测试通常需要很长时间，因此无法将它们作为持续集成构建的一部分。
- en: System tests
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 系统测试
- en: 'The third and final type of automated functional test is the system test. These
    tests are meant to run against a fully assembled and running application. System
    tests come in two flavors, depending on the type of application: an API test or
    a UI test. System tests can take a long time to execute, and it is not uncommon
    for long tests with an elaborate setup of test data to take well over a minute.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第三种也是最后一种自动化功能测试类型是系统测试。这些测试是针对一个完全组装并正在运行的应用程序进行的。系统测试有两种类型，取决于应用程序的类型：API
    测试或 UI 测试。系统测试可能需要很长时间来执行，而且常常有复杂的测试数据设置，导致测试时间超过一分钟。
- en: Tip
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: You might come across something called coded UI tests. This is a now-deprecated
    Microsoft solution for writing UI tests. These tests could be executed from Azure
    Pipelines. Luckily, there are many alternatives, as referenced in Microsoft’s
    deprecation message at [https://devblogs.microsoft.com/devops/changes-to-coded-ui-test-in-visual-studio-2019](https://devblogs.microsoft.com/devops/changes-to-coded-ui-test-in-visual-studio-2019).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到一种叫做编码 UI 测试的东西。这是一个现在已经被废弃的微软解决方案，用于编写 UI 测试。这些测试可以从 Azure Pipelines
    中执行。幸运的是，有许多替代方案，详见微软在[https://devblogs.microsoft.com/devops/changes-to-coded-ui-test-in-visual-studio-2019](https://devblogs.microsoft.com/devops/changes-to-coded-ui-test-in-visual-studio-2019)中发布的弃用通知。
- en: System tests execute against a running application, which means that they will
    need configuration and setup before they can be run. The application needs to
    be running in a controlled environment and all of the integrations with data stores
    need to be fully operational. Integrations with other systems need to be either
    up and running or swapped out with a replacement mock to ensure that all operations
    that integrate with those systems will function properly.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 系统测试是在正在运行的应用程序上执行的，这意味着在运行之前需要进行配置和设置。应用程序需要在受控环境中运行，并且所有与数据存储的集成都需要完全正常运行。与其他系统的集成要么需要正常运行，要么需要用替代的模拟工具进行替换，以确保所有与这些系统集成的操作能够正常运行。
- en: These conditions make it less likely that developers will execute these tests
    on their local machines as they are making changes to the application. It is only
    when they are creating a new test or changing a test that they might do so. However,
    even then they may be executing these tests not against a locally run version
    of the application, but against a version that is already deployed to a test environment.
    This is not necessarily a good thing, but often just the reality in most teams.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些条件使得开发人员在本地机器上执行这些测试的可能性较低，特别是在他们修改应用程序时。只有在创建新测试或更改测试时，他们才可能执行这些测试。然而，即使在这种情况下，他们执行的测试可能并非针对本地运行的应用程序版本，而是针对已经部署到测试环境中的版本。这不一定是好事，但在大多数团队中往往是现实情况。
- en: Important Note
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: An introduction to creating API or UI tests is unfortunately beyond the scope
    of this book. There are many products available on the market and which one is
    the best to use will differ from project to project.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 创建API或UI测试的介绍不幸超出了本书的范围。市场上有许多产品可供选择，最佳的使用产品因项目而异。
- en: When executing system tests as part of the pipeline, they are often run after
    the code has been deployed to at least one environment. This will often be the
    test environment. This implies that the system tests are on the critical path
    from a source code change to the deployment to production. If this path becomes
    too long, they can also be taken out of the pipeline. They are then run on a schedule—for
    example, every night. Just as with integration tests, this speeds up the pipeline,
    but it removes the opportunity to use system tests as a quality gate.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在作为管道一部分执行系统测试时，它们通常是在代码至少部署到一个环境后进行的。这通常是测试环境。这意味着系统测试是从源代码更改到生产部署的关键路径的一部分。如果这个路径过长，它们也可以被移出管道。然后，它们按照计划运行——例如，每晚运行一次。就像集成测试一样，这加快了管道的速度，但也失去了将系统测试作为质量门的机会。
- en: System tests, and UI tests in particular, are often fragile and can stop working
    unexpectedly after minor changes. For this reason, it is advised that you keep
    their number as low as possible; however, keep in mind that these are the tests
    that can catch particular errors, such as misconfiguration or other runtime errors,
    database-application mismatches, or series of operations that create error states.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 系统测试，特别是UI测试，通常是脆弱的，在进行微小更改后可能会停止工作。因此，建议将这些测试的数量保持在最低限度；然而，需记住，这些测试可以捕捉到特定错误，如配置错误、其他运行时错误、数据库与应用程序的不匹配或创建错误状态的操作序列。
- en: Besides automated function tests, there are also manual functional tests, which
    have value in many DevOps projects. These are discussed in the next section, but
    first, a note on flaky tests.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 除了自动化功能测试，还有手动功能测试，这在许多DevOps项目中具有价值。将在下一节讨论，但首先介绍一下不稳定的测试。
- en: Flaky tests
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不稳定的测试
- en: Flaky tests are tests that fail with no evident change in code or configuration,
    or the code works on a local machine but fails with continuous integration. Upon
    retrying the test execution multiple times, the test eventually passes.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 不稳定的测试是指在代码或配置没有明显变化的情况下失败，或者代码在本地机器上运行正常，但在持续集成时失败。经过多次重试后，测试最终会通过。
- en: Flaky tests are unreliable and negatively impact the build quality confidence.
    One solution to eradicate the flaky test problem is to mute these tests so that
    continuous integration and release do not fail, and the unreliable test results
    are excluded from your automated test reports.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 不稳定的测试是可靠性差的，会对构建质量信心产生负面影响。解决不稳定测试问题的一种方法是将这些测试静默处理，以便持续集成和发布不失败，同时将不可靠的测试结果从自动化测试报告中排除。
- en: Types of manual functional tests
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动功能测试的类型
- en: While automated tests are a great tool for receiving feedback on development
    work quickly and often, there are still things that will be tested manually. While
    automating repetitive tests is the best way to continuously monitor quality, some
    things will require the human eye.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然自动化测试是一个快速且频繁获取开发反馈的好工具，但仍有一些内容需要手动测试。虽然自动化重复性测试是持续监控质量的最佳方式，但某些事情仍需要人工检查。
- en: Manual testing is the tipping point for shifting left. Whenever any type of
    test or validation is shifted left, this means that it is executed before manual
    tests are performed. The benefit of this is that all of these automated activities
    add to the amount of confidence that we might have in the version of the application
    that is being tested, increasing the chances that the version will also pass manual
    testing. In other words, when manual testing starts, it should be very unlikely
    that any new issues will be uncovered.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 手动测试是向左shift的临界点。每当任何类型的测试或验证被shift到左侧时，意味着它是在执行手动测试之前进行的。这样做的好处是，这些自动化活动增加了我们对被测试版本的信心，提升了该版本也能通过手动测试的可能性。换句话说，当手动测试开始时，应该很不可能再发现任何新问题。
- en: 'There are two types of manual tests:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的手动测试：
- en: Scripted tests
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本化测试
- en: Exploratory tests
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索性测试
- en: Both types of tests will be discussed in the following sections.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种测试类型将在接下来的部分中讨论。
- en: Scripted testing
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 脚本化测试
- en: 'Scripted testing is a technique that is used to minimize the amount of time
    spent on the test execution while still ensuring full coverage of all relevant
    test cases. This is done by splitting the testing into two distinct phases: test
    preparation and test execution. Test preparation is done in parallel to the development
    of the feature that is to be tested or even before development starts. During
    test preparation, the feature is analyzed and formal test cases are identified.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本化测试是一种用于在确保全面覆盖所有相关测试用例的同时，最小化测试执行时间的技术。通过将测试分为两个不同的阶段：测试准备和测试执行，来实现这一目标。测试准备与待测试功能的开发并行进行，甚至在开发开始之前就已完成。在测试准备阶段，功能被分析并识别出正式的测试用例。
- en: Once the test cases that must be executed are identified, manual test scripts
    are written that describe every step that is to be taken during the test execution
    phase later. These scripts are engineered in such a way that they are easy to
    follow and leave no room for questions or doubts. They are also written in such
    a way that the number of steps to execute is as low as possible. While this may
    take more time to prepare, all of it is done to ensure that as little time as
    possible is spent on the test execution.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦必须执行的测试用例被识别出来，就会编写手动测试脚本，描述在后续测试执行阶段每个要执行的步骤。这些脚本的编写方式使得它们易于跟随，并且没有任何疑问或困惑的空间。它们的编写方式还确保执行步骤的数量尽可能少。虽然这可能需要更多的准备时间，但所有这些都是为了确保在测试执行过程中花费的时间尽可能少。
- en: A deeper discussion of test analysis and how to identify test cases is beyond
    the scope of this book. While you are responsible for test case creation, Azure
    DevOps supports you in this. Using the Test Plans service, you can create test
    plans and record the test cases within them for quick execution later on.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 测试分析及如何识别测试用例的深入讨论超出了本书的范围。虽然你负责创建测试用例，但 Azure DevOps 会在这方面提供支持。通过使用测试计划服务，你可以创建测试计划并记录其中的测试用例，以便日后快速执行。
- en: 'To create a new test plan, perform the following steps:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建新的测试计划，请执行以下步骤：
- en: Open the Azure **Test Plans** menu.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Azure **测试计划**菜单。
- en: '![Figure 10.4 – Azure DevOps Test Plans menu ](img/B18655_10_04.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.4 – Azure DevOps 测试计划菜单](img/B18655_10_04.jpg)'
- en: Figure 10.4 – Azure DevOps Test Plans menu
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.4 – Azure DevOps 测试计划菜单
- en: In this menu, click on **Test plans**. Here, you will be presented with an overview
    of all of the test plans you currently have.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此菜单中，点击**测试计划**。这里将展示你当前所有测试计划的概览。
- en: 'Click the **New Test Plan** button to start creating a new test plan. This
    will open a new dialog, as shown in the following screenshot:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**新建测试计划**按钮开始创建新的测试计划。这将打开一个新的对话框，如下所示：
- en: '![](img/B18655_10_05.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18655_10_05.jpg)'
- en: Figure 10.5 – Azure DevOps New Test Plan
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.5 – Azure DevOps 新测试计划
- en: Give a meaningful name to the test plan, for example, a name that illustrates
    what the test plan is for.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给测试计划命名一个有意义的名字，例如，能说明测试计划目的的名称。
- en: Link the test plan to the correct product area path.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将测试计划链接到正确的产品区域路径。
- en: Select the correct iteration, or sprint, that this test relates to.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择与此测试相关的正确迭代或冲刺。
- en: 'Click **Create** to finalize creating the test plan. This will automatically
    open this test plan, as shown here:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建**以完成测试计划的创建。这将自动打开此测试计划，如下所示：
- en: '![Figure 10.6 – Azure DevOps Test Suites ](img/B18655_10_06.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.6 – Azure DevOps 测试套件](img/B18655_10_06.jpg)'
- en: Figure 10.6 – Azure DevOps Test Suites
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.6 – Azure DevOps 测试套件
- en: A test plan can be split into multiple test suites, which in turn can be split
    into test suites again. In essence, test suites are for tests what folders are
    for files. Suites can be managed by clicking the ellipsis button that appears
    when hovering over the test suite. This is shown in the preceding screenshot.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 一个测试计划可以拆分为多个测试套件，而测试套件又可以拆分为子测试套件。从本质上讲，测试套件对于测试就像文件夹对于文件一样。通过点击测试套件上悬停时出现的省略号按钮，可以管理测试套件。这在前面的截图中有展示。
- en: After creating a test plan, it is time to add one or more test cases to the
    plan. To do this, ensure that the **Define** tab is open for a test suite and
    click the **New Test Case** button. A new popup will open.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 创建测试计划后，就该添加一个或多个测试用例到计划中。为此，请确保测试套件的**定义**选项卡已打开，然后点击**新建测试用例**按钮。一个新的弹出窗口将打开。
- en: '![Figure 10.7 – Azure DevOps New Test Case ](img/B18655_10_07.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.7 – Azure DevOps 新建测试用例 ](img/B18655_10_07.jpg)'
- en: Figure 10.7 – Azure DevOps New Test Case
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.7 – Azure DevOps 新建测试用例
- en: 'Here, the test steps and expected outcomes can be defined. To define a new
    test case, perform the following steps:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，可以定义测试步骤和预期结果。要定义一个新的测试用例，请执行以下步骤：
- en: Enter a title for the test case.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为测试用例输入标题。
- en: In the dialog, enter one or more actions and expected results that describe
    the test case in detail.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对话框中，输入一个或多个操作步骤和预期结果，以详细描述测试用例。
- en: Once the test case is completely described, click the **Save & Close** button
    to save the test case and return to the previous screen where you can manage the
    test suites.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦测试用例完全描述，点击**保存并关闭**按钮以保存测试用例并返回到上一个屏幕，在那里你可以管理测试套件。
- en: Once the preparation is done and a feature is ready to be tested, all tests
    are executed. Since all tests are scripted in detail, this can be done quickly
    and effectively. There might even be developers, business analysts, or people
    from other parts of the company helping with the test execution. This means that
    the test execution itself will be really quick.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦准备工作完成，功能准备好进行测试，所有测试就会执行。由于所有测试都有详细脚本，这可以快速而高效地完成。甚至可能有开发人员、业务分析师或其他部门的人员参与测试执行。这意味着测试执行本身将非常快速。
- en: 'To start the execution of a test suite or plan, perform the following steps:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始执行测试套件或计划，请执行以下步骤：
- en: Navigate to the **Execute** tab.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**执行**选项卡。
- en: '![Figure 10.8 – Azure DevOps executing test cases ](img/B18655_10_08.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.8 – Azure DevOps 执行测试用例 ](img/B18655_10_08.jpg)'
- en: Figure 10.8 – Azure DevOps executing test cases
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.8 – Azure DevOps 执行测试用例
- en: Select one or more test cases.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个或多个测试用例。
- en: Select one of the run options at the top right.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择右上角的一个运行选项。
- en: 'When choosing to run the tests against a web application, a new browser window
    with a *test runner* will open. This test runner can be used to go through all
    of the test cases, and for every test case, through all of the steps, keep track
    of all successes and errors, as shown here:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 选择针对网页应用程序运行测试时，会打开一个带有*测试运行器*的新浏览器窗口。此测试运行器可以用来逐个执行所有测试用例，对于每个测试用例，依次执行所有步骤，跟踪所有成功和错误，如下所示：
- en: '![Figure 10.9 – Azure DevOps test case steps ](img/B18655_10_09.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.9 – Azure DevOps 测试用例步骤 ](img/B18655_10_09.jpg)'
- en: Figure 10.9 – Azure DevOps test case steps
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.9 – Azure DevOps 测试用例步骤
- en: The check mark or cross after every test step can be used to keep track of the
    outcomes for individual steps. If a step is marked as incorrect, a comment with
    the defect can be added. To mark a test case as passed or marked, the blue drop-down
    menu at the top right can be used. Once a test outcome is selected, the runner
    automatically progresses to the next test. Once all tests are performed, the results
    can be saved using the **Save and close** button at the top left.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试步骤后的勾选标记或叉号可用于跟踪每个步骤的结果。如果某个步骤标记为不正确，可以添加一个带缺陷的评论。要将测试用例标记为通过或标记，可以使用右上角的蓝色下拉菜单。选择测试结果后，运行器会自动继续执行下一个测试。一旦所有测试执行完毕，可以使用左上角的**保存并关闭**按钮保存结果。
- en: 'To view the outcome of a test run, navigate to **Test Plans** and then **Runs**
    to get the following dashboard:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看测试运行的结果，导航到**测试计划**，然后点击**运行**以获取以下仪表盘：
- en: '![Figure 10.10 – Azure DevOps test runs ](img/B18655_10_10.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.10 – Azure DevOps 测试运行 ](img/B18655_10_10.jpg)'
- en: Figure 10.10 – Azure DevOps test runs
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.10 – Azure DevOps 测试运行
- en: Here, you can select the run for which you want to see the outcomes to get a
    quick overview of the test outcomes. On the second tab, **Test results**, it is
    possible to view a list of all test cases and whether they passed or not.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以选择你想查看结果的运行，以快速概览测试结果。在第二个标签**测试结果**中，可以查看所有测试用例的列表以及它们是否通过。
- en: A major benefit of having detailed scripts is that the same tests can be performed
    more than once, reducing the cost per execution. If a test plan is executed multiple
    times, all run history is maintained and can be accessed using the view shown
    in the preceding screenshot. This is useful if manual tests are used as part of
    a regression test; however, once this becomes the case, it is often even more
    beneficial to automate the tests using system tests, if possible.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有详细脚本的一个主要好处是，可以多次执行相同的测试，从而降低每次执行的成本。如果一个测试计划执行多次，所有的运行历史记录都会被保存，并且可以通过前述截图中显示的视图访问。这对于将手动测试作为回归测试的一部分非常有用；然而，一旦情况变成这样，通常通过系统测试来自动化这些测试会更为有益，尤其是在可能的情况下。
- en: Tip
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: It is possible to execute the same test multiple times, but for different configurations.
    When developing web applications, this is often done to test using different browsers.
    For desktop applications, this might be used to test for different operating systems.
    Working with configurations is detailed in the Microsoft documentation at [https://docs.microsoft.com/en-us/azure/devops/test/mtm/test-configurations-specifying-test-platforms?view=azure-devops](https://docs.microsoft.com/en-us/azure/devops/test/mtm/test-configurations-specifying-test-platforms?view=azure-devops).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 可以多次执行相同的测试，但针对不同的配置。当开发Web应用程序时，通常会使用不同的浏览器进行测试。对于桌面应用程序，这可能会用于测试不同的操作系统。关于配置的工作，微软文档中有详细说明，参见[https://docs.microsoft.com/en-us/azure/devops/test/mtm/test-configurations-specifying-test-platforms?view=azure-devops](https://docs.microsoft.com/en-us/azure/devops/test/mtm/test-configurations-specifying-test-platforms?view=azure-devops)。
- en: The next section will discuss a final form of functional testing, namely, exploratory
    testing.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 下一部分将讨论功能测试的最终形式，即探索性测试。
- en: Exploratory testing
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 探索性测试
- en: Writing and executing detailed test scripts can take a lot of time from both
    the test engineer and test executioner, so often these tests are automated. Once
    they are automated, they will fall into the category of system tests, and automated
    UI tests in particular.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 编写和执行详细的测试脚本可能会花费大量时间，既对测试工程师，也对测试执行者，因此这些测试通常会被自动化。一旦它们被自动化，就会归类为系统测试，特别是自动化UI测试。
- en: This does not necessarily mean that manual tests provide no value or no good
    return on investment at all. There are some things that the human eye will catch
    that a computer will not, such as interfaces that are not user friendly, misaligned
    interface elements, and text lines or images that are not fully displayed but
    get hidden behind other elements.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着手动测试完全没有价值或没有好的投资回报。有些东西是人眼能发现的，而计算机不能，例如不友好的用户界面、未对齐的界面元素，以及未完全显示但被其他元素遮挡的文本行或图像。
- en: To catch these errors while not spending large amounts of time on detailed test
    scripting, exploratory testing might be a solution. In this approach, a tester
    opens the application and starts investigating those parts of the application
    that they feel contain the most risks with regard to the upcoming release. While
    exploring the application, the tester keeps track of which parts of the application
    they have visited and which test cases they have performed. Meanwhile, the tester
    also keeps track of new risks they identify or test cases they have not performed
    yet. In doing so, they are creating a list of covered and uncovered test cases
    while they are working. It also allows the tester to keep focusing on the most
    important risk and test cases all of the time. Once the exploratory test run is
    over, the tester can report on which application areas and test cases have been
    covered, which have not, and which risks are still not explored at all. This report
    can be valuable input for a product manager who must decide whether to move forward
    with a release or not.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在不花费大量时间编写详细测试脚本的情况下捕捉这些错误，探索性测试可能是一个解决方案。在这种方法中，测试人员打开应用程序并开始调查他们认为在即将发布的版本中包含最大风险的应用程序部分。在探索应用程序的过程中，测试人员会记录他们访问了哪些应用程序部分，以及执行了哪些测试用例。与此同时，测试人员还会跟踪他们发现的新的风险或尚未执行的测试用例。通过这样做，他们在工作时创建了一个已覆盖和未覆盖的测试用例列表。这也使测试人员能够始终集中关注最重要的风险和测试用例。探索性测试完成后，测试人员可以报告哪些应用程序领域和测试用例已经覆盖，哪些没有，哪些风险完全没有被探索过。这份报告对产品经理来说可能是一个宝贵的输入，帮助他们决定是否继续发布。
- en: A common misconception is that exploratory testing means that a tester is just
    clicking around to see whether the application is working okay. This is not the
    case, and the previous paragraphs have shown that exploratory testing is a highly
    structured activity that requires practice. If performed well, test preparation
    and test execution are interwoven during an exploratory testing session.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的误解是，探索性测试意味着测试人员只是随便点击，以查看应用程序是否正常工作。事实并非如此，前面的段落已经说明，探索性测试是一项高度结构化的活动，且需要实践。如果操作得当，测试准备和测试执行将在探索性测试过程中交织进行。
- en: Exploratory testing is a great tool when there is limited time or the amount
    of time available for testing is not known upfront. Exploratory testing may yield
    findings that need to be recorded as defects. How to do this is discussed next.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当时间有限或可用的测试时间无法提前确定时，探索性测试是一项很好的工具。探索性测试可能会发现需要记录为缺陷的问题。接下来将讨论如何进行记录。
- en: Reporting manual test results
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 报告手动测试结果
- en: One of the activities that is also part of testing is the reporting of any defects
    or other issues found. This is often tedious and time-consuming work. You must
    try and reproduce the issue one more time, trying to remember how the issue manifested
    itself, and write down all of these steps. Then, both the desired and undesired
    outcomes must be described, screenshots must be taken, and everything has to be
    inserted into a bug tracker or work management tool, such as Azure DevOps.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的一项活动还包括报告发现的缺陷或其他问题。这通常是繁琐且耗时的工作。你必须尝试重新现现该问题，回忆问题是如何发生的，并记录下所有这些步骤。然后，还需要描述期望的和不期望的结果，拍摄截图，并将所有内容插入到缺陷追踪或工作管理工具中，例如
    Azure DevOps。
- en: To make this easier, there is a **Test & Feedback** extension for Azure DevOps
    available. This extension simply provides buttons for recording screenshots or
    videos and annotating them with text or drawings. Once an issue is found and documented
    by a recording or screenshot, it can be automatically submitted to Azure Boards.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化这一过程，Azure DevOps 提供了一个**Test & Feedback**扩展。该扩展提供了按钮来录制截图或视频，并用文本或图形进行注释。一旦发现问题并通过录制或截图进行记录，它可以自动提交到
    Azure Boards。
- en: This extension is freely available from the Azure DevOps Marketplace and runs
    in Firefox, Chrome, and Edge Chromium. A link to the extension is included at
    the end of this chapter.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个扩展可以免费从 Azure DevOps 市场下载，并可以在 Firefox、Chrome 和 Edge Chromium 中运行。该扩展的链接将在本章末尾提供。
- en: Important Note
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 重要说明
- en: The Test & Feedback extension can be used when both executing scripted tests
    and performing exploratory tests.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**Test & Feedback** 扩展可以在执行脚本化测试和进行探索性测试时使用。'
- en: This concludes the discussion of different types of functional tests. The next
    section will help you to decide which type of test to use in your projects.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了对不同类型功能测试的讨论。接下来的部分将帮助你决定在项目中使用哪种类型的测试。
- en: Strategies for deciding which types of functional tests you need
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 决定需要哪些类型功能测试的策略
- en: 'With so many different types of tests, which type of test is the best for your
    project? Given the wide range of types of tests and their different properties,
    the answer is as you might expect: a mix of all of them, as they all have different
    properties.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 面对如此多不同类型的测试，哪种测试最适合你的项目？鉴于测试类型繁多且各自特性不同，答案正如你所料：它们的组合，因为它们各自有不同的特性。
- en: 'The following diagram shows the relation between the time the different types
    of tests take to execute and the confidence in the quality of the software they
    provide. It shows that while manual tests that complete successfully have the
    highest likelihood of identifying any defects, they also take the longest to execute.
    For automated tests, the time taken for tens of thousands of unit tests to be
    carried out can often be kept to a few minutes, while 10 to 100 system tests can
    take over 30 minutes:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了不同类型测试执行所需时间与它们提供的软件质量信心之间的关系。图表显示，尽管成功完成的手动测试最有可能识别缺陷，但它们也需要最长的执行时间。对于自动化测试，执行数万次单元测试所需的时间通常可以保持在几分钟内，而进行
    10 到 100 次系统测试可能需要超过 30 分钟：
- en: '![Figure 10.11 – Quality confidence versus test execution time ](img/B18655_10_11.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.11 – 质量信心与测试执行时间的关系](img/B18655_10_11.jpg)'
- en: Figure 10.11 – Quality confidence versus test execution time
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.11 – 质量信心与测试执行时间的关系
- en: Looking at this trade-off, it often makes sense why unit tests are preferred
    over integration tests, integration tests over system tests, and any type of manual
    test over automated unit tests.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个权衡来看，通常可以理解为什么单元测试比集成测试更受青睐，集成测试比系统测试更受青睐，任何类型的手动测试都优于自动化单元测试。
- en: Tip
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If the quality of unit and integration tests increases, then this line will
    climb even more to the top left. High-quality software architecture will also
    help reduce the need for system and integration tests and increase the chances
    of catching defects early, something that unit tests bring. Automated unit and
    integration tests run faster with consistent results that postively impact the
    overall build quality.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单元测试和集成测试的质量提高，那么这条线将进一步攀升到左上角。高质量的软件架构也有助于减少系统和集成测试的需求，并增加早期发现缺陷的机会，这正是单元测试的优势。自动化的单元测试和集成测试运行更快，结果一致，对整体构建质量产生积极影响。
- en: The understanding of this trade-off also helps with understanding two models
    that can be used in deciding on your testing strategy, that is, the testing pyramid
    and the testing trophy, which are discussed in the following two sections.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对这种权衡的理解有助于理解两种可以用于决定测试策略的模型，即测试金字塔和测试奖杯，这将在接下来的两个部分中进行讨论。
- en: The testing pyramid
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试金字塔
- en: In many older projects, there are not too many automated functional tests. Often,
    many of these tests are slow to run, have a large test scope, are hard to maintain,
    and fail regularly without a clear cause. The value that these tests provide is
    often very limited. To counter the lack of good, automated tests, there are then
    many manual tests that are used to do a full regression test of the application
    before a new version is deployed. These automated tests are very time consuming
    and rarely executed. There is no fast feedback to developers and defects are often
    detected late. It is hard to practice DevOps in such a situation since the focus
    in DevOps is on creating new versions often and at a high rate.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多旧项目中，自动化功能测试的数量并不多。通常，这些测试运行缓慢，测试范围大，难以维护，并且经常失败而没有明确的原因。这些测试所提供的价值通常非常有限。为了弥补缺乏良好的自动化测试，通常会有许多手动测试被用来在新版本部署之前进行完整的回归测试。这些自动化测试非常耗时，且很少执行。开发人员无法得到快速反馈，缺陷通常在较晚阶段被发现。在这种情况下，很难实践
    DevOps，因为 DevOps 的重点是频繁且高频率地发布新版本。
- en: Such a group of tests for an application is often called an ice-cream cone of
    tests, including many manual tests and a few automated tests, of which only a
    few are unit tests. The ice-cream cone of tests is an anti-pattern, yet often
    found in older and/or long-running projects.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这样的测试组通常被称为“冰淇淋锥形测试”，其中包括许多手动测试和少量自动化测试，而其中只有少数是单元测试。冰淇淋锥形测试是一种反模式，但在旧项目和/或长期运行的项目中经常出现。
- en: '![Figure 10.12 – Testing pyramid for manual versus automated testing ](img/B18655_10_12.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.12 – 手动与自动化测试的测试金字塔](img/B18655_10_12.jpg)'
- en: Figure 10.12 – Testing pyramid for manual versus automated testing
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.12 – 手动与自动化测试的测试金字塔
- en: 'To battle this, another, opposing, model was introduced: the test pyramid.
    This model advocates for having many unit tests that give feedback on the quality
    of the application within minutes, quickly pointing out most of the errors. On
    top of this, other types of slower tests are layered to catch only those errors
    that previous layers cannot catch. Using this approach, there is a good trade-off
    between test coverage and test duration.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这一点，引入了另一个相反的模型：测试金字塔。这个模型主张拥有许多单元测试，可以在几分钟内提供关于应用程序质量的反馈，快速指出大部分错误。在此基础上，还可以叠加其他类型的较慢测试，以捕获前面层次无法捕获的错误。使用这种方法，可以在测试覆盖率和测试持续时间之间取得良好的折衷。
- en: Important Note
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Please note that the test pyramid does *not* advocate a layered approach. Do
    not first build a layer of unit tests and only proceed to integration tests when
    all unit tests are done. Instead, it advocates proportions. You should have a
    healthy ratio between unit tests, integration tests, and system tests.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，测试金字塔并不主张分层方法。不要先构建一层单元测试，然后只有在所有单元测试完成后才进行集成测试。相反，它主张比例。你应该在单元测试、集成测试和系统测试之间保持健康的比例。
- en: General advice on the best ratio between different types of tests is very hard
    to give. But in most projects, a ratio of 1:5-15 for each step in the pyramid
    can be reasonable.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在不同类型测试之间找到最佳比例的一般建议非常困难。但在大多数项目中，金字塔中每个步骤的比例为 1:5-15 可能是合理的。
- en: The testing trophy
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试奖杯
- en: While the testing pyramid is a well-known and often-used approach for classifying
    tests and deciding on which types of tests to create, this approach has been criticized
    as well. While moving away from manual and system tests is widely accepted to
    be needed in DevOps teams, the focus on unit tests is not universally accepted.
    Some object to the fact that the testing pyramid hints at creating many more unit
    tests than integration tests.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管测试金字塔是一个广为人知且经常使用的分类测试和决定创建哪些类型测试的方法，但这种方法也受到了批评。虽然远离手动和系统测试在 DevOps 团队中被广泛接受是必要的，但并不是所有人都接受单元测试的重点。一些人反对测试金字塔暗示创建的单元测试数量比集成测试多得多。
- en: 'The reasons for this objection are as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这一反对意见的原因如下：
- en: '`WorkDivider` in the *Unit tests* section, we can see that it relies on knowing
    how the `DivideWork` method is implemented. The test verifies the actual implementation:
    the call to `SendMessage()`. Many unit tests have this characteristic and, as
    a result, adding many unit tests increases the effort needed to change the implementation
    of the class-level design of a solution.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在*单元测试*部分的 `WorkDivider` 中，我们可以看到它依赖于了解 `DivideWork` 方法的实现方式。测试验证了实际的实现：对 `SendMessage()`
    的调用。许多单元测试具有这种特点，因此增加许多单元测试会增加更改解决方案类级设计实现所需的工作量。
- en: '**Unit tests tend to have a higher rate of change than integration tests**.
    Unit test classes are closely tied to the class they test. That means that if
    the class they test is replaced, the unit tests for this class also lose all value.
    For this reason, it is argued that integration tests might have a higher return
    on investment.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试的变动率通常比集成测试高**。单元测试类与它们测试的类密切相关。这意味着如果测试的类被替换，该类的单元测试也会失去所有的价值。因此，有人认为集成测试可能会有更高的投资回报率。'
- en: '**Real value comes from integrating components, not from individual components**.
    Even when all units are working in isolation, there might not be any value delivered
    by a system. The real value of software only comes once it is integrated and ready
    to run. Since testing should confirm value delivery, it is argued that the focus
    should be on writing integration tests over unit tests.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**真正的价值来自于组件集成，而不是单个组件**。即使所有单元都在隔离状态下工作，系统可能也不会提供任何价值。软件的真正价值只有在集成并准备运行时才会体现出来。由于测试应该确认价值交付，有人认为应该专注于编写集成测试而不是单元测试。'
- en: To deal with these objections, the testing trophy was introduced by *Kent C.
    Dodds*. This model adopts the testing pyramid in the sense that it advocates as
    few manual and system tests as possible but differs in the fact that it does not
    emphasize unit tests over integration tests, but the other way around. The name
    testing trophy comes from the fact that if this were drawn, it would result in
    a figure that resembles a trophy.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这些反对意见，*Kent C. Dodds* 提出了测试奖杯模型。该模型采用了测试金字塔的理念，提倡尽可能少使用手动和系统测试，但与之不同的是，它并不强调单元测试高于集成测试，而是强调集成测试优于单元测试。测试奖杯这一名称来源于如果将其绘制出来，它将呈现出类似奖杯的形状。
- en: Unfortunately, there is no silver bullet, and the best advice is to know about
    all three models and the reasoning behind them and apply the appropriate lines
    of reasoning to your current situation. When it comes to testing, there is no
    single best solution for all.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，世上没有灵丹妙药，最好的建议是了解这三种模型及其背后的推理，并将适当的推理应用于当前的情况。在测试方面，并没有一种适用于所有情况的最佳解决方案。
- en: Types of non-functional tests
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 非功能性测试的类型
- en: 'Functional tests are mostly concerned with verifying whether the behavior displayed
    by an application is the behavior that is expected; however, there are more risks
    when it comes to application development: whether an application performs actions
    quickly enough, whether this performance degrades if more users use the system
    concurrently, and whether the system is easy for end users to use. Tests that
    verify these properties of a system under test are called non-functional tests.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 功能测试主要关注验证应用程序展示的行为是否符合预期；然而，在应用程序开发中存在更多的风险：应用程序是否能足够快速地执行操作，随着更多用户同时使用系统时性能是否会下降，系统是否易于最终用户使用。验证这些属性的测试被称为非功能性测试。
- en: 'There are many types of non-functional tests, but three of them that are important
    in DevOps scenarios are as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多类型的非功能性测试，其中在DevOps场景中重要的三种如下：
- en: Performance testing
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能测试
- en: Load testing
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载测试
- en: Usability testing
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用性测试
- en: Let’s go over them one by one.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一来看。
- en: Performance testing
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 性能测试
- en: Performance tests are executed to establish how quickly an application can perform
    an action, given a set of resources. Performance tests are often executed using
    specialized tools and run against a fully assembled system. If the tools used
    for automated API or UI tests record the duration of a test, the duration of these
    tests can be used as performance results as well.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试的执行是为了确定在给定一组资源的情况下，应用程序执行某个操作的速度。性能测试通常使用专门的工具执行，并在完全组装的系统上运行。如果用于自动化API或UI测试的工具记录了测试的持续时间，那么这些测试的持续时间也可以作为性能结果使用。
- en: To compare results over multiple test runs, it is important to ensure that all
    factors influencing performance are kept the same between tests. The setup of
    virtual machines for both test subjects and test runners should stay the same.
    The application configuration should remain constant and integration points should
    be in the same state as much as possible—for example, instead of reusing the same
    database, the same database should be restored from a backup before every performance
    test. This ensures that the results are comparable.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较多次测试的结果，确保影响性能的所有因素在测试之间保持一致是非常重要的。测试对象和测试运行者的虚拟机设置应该保持一致。应用程序配置应保持不变，集成点应该尽可能处于相同的状态——例如，不是重复使用同一个数据库，而是在每次性能测试前从备份中恢复相同的数据库。这样可以确保结果具有可比性。
- en: While performance and load tests are often mixed up, they are two different
    types of tests.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然性能测试和负载测试常常混淆，但它们是两种不同类型的测试。
- en: Load testing
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 负载测试
- en: 'Load tests are performed to measure how much load the system can take before
    it breaks. These types of tests are sometimes also called stress tests. Unlike
    in a performance test, there are many requests executed in parallel. What is measured
    is the average performance of all requests, while slowly increasing the number
    of requests to the system. In most cases, this will identify a breaking point,
    a specific number of requests per second at which the performance will suddenly
    decrease. This is the number of requests per second that the system can maximally
    serve. When executing a load test, gathering the average performance while increasing
    the maximum number of requests will often result in a graph like the following:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 负载测试的目的是测量系统在崩溃前能够承受的负载量。这类测试有时也被称为压力测试。与性能测试不同，负载测试会并行执行大量请求。测量的是所有请求的平均性能，同时逐步增加系统的请求数量。在大多数情况下，这会确定一个临界点，即每秒请求数达到某个特定值时，性能会突然下降。这是系统最大能承载的每秒请求数。执行负载测试时，随着最大请求数量的增加，通常会得到如下图所示的图表：
- en: '![Figure 10.13 – Example of a load testing graph ](img/B18655_10_13.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.13 – 负载测试图表示例](img/B18655_10_13.jpg)'
- en: Figure 10.13 – Example of a load testing graph
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.13 – 负载测试图表示例
- en: 'This graph shows why it is important to know the breaking point of an application:
    too much load might crumble a system unexpectedly because of the sudden nature
    of the change in response times. Knowing where this point is allows operators
    to act before this point is reached in a production environment.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 该图表显示了了解应用程序临界点的重要性：过多的负载可能会因为响应时间突然变化而意外地让系统崩溃。知道这个临界点在哪里可以让操作人员在生产环境中到达此点之前采取措施。
- en: At the end of this chapter is a link to an online Microsoft lab for developers
    to practice load testing.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 本章末尾提供了一个链接，指向一个在线的 Microsoft 实验室，供开发人员练习负载测试。
- en: 'Azure now offers a fully managed load testing service. The Azure Load Testing
    service is under public preview and enables you to conduct load testing of your
    application by simulating traffic for a high-scale load. It can be used by developers,
    testers, and **quality assurance** (**QA**) engineers to identify and fix any
    application performance, scalability, or capacity issues. Azure Load Testing abstracts
    the complexity and infrastructure required to execute large-scale load tests.
    You can find out more about the Azure Load Testing service here: [https://azure.microsoft.com/en-us/services/load-testing/](https://azure.microsoft.com/en-us/services/load-testing/).'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 现在提供完全托管的负载测试服务。Azure 负载测试服务目前处于公开预览阶段，允许你通过模拟高规模负载流量来进行应用程序负载测试。开发人员、测试人员和**质量保证**（**QA**）工程师可以使用该服务来识别和修复应用程序的性能、可扩展性或容量问题。Azure
    负载测试抽象了执行大规模负载测试所需的复杂性和基础设施。你可以在这里了解更多关于 Azure 负载测试服务的信息：[https://azure.microsoft.com/en-us/services/load-testing/](https://azure.microsoft.com/en-us/services/load-testing/)。
- en: Usability testing
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可用性测试
- en: Another important type of testing is usability testing. While other types of
    tests focus on verifying whether the implementation has the behavior desired by
    the product team, usability tests focus on verifying whether the expectations
    of the user are actually met. This means that the test scope is even larger, and
    these tests can identify UIs that are clumsy and help to find unclear text or
    user requests that were misinterpreted.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种重要的测试类型是可用性测试。其他类型的测试侧重于验证实现是否具备产品团队所期望的行为，而可用性测试则侧重于验证用户的期望是否真正得到满足。这意味着测试范围更大，这些测试能够识别笨拙的用户界面，并帮助找到模糊不清的文本或被误解的用户请求。
- en: Usability tests are run by letting the user work with the final application
    on one or more tasks and observing or asking about how they interacted with the
    application. Results are often much more verbose than *passed* or *not passed*,
    and results are often given back to a product owner to write new user stories
    or change requirements.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 可用性测试通过让用户在一个或多个任务上与最终应用程序进行互动，并观察或询问他们如何与应用程序互动来进行。结果通常比*通过*或*未通过*更加详细，结果通常会反馈给产品负责人，以便编写新的用户故事或更改需求。
- en: A great technique for enabling usability testing is the use of feature flags.
    Feature flags enable us to gradually expose a new feature to more users. This
    capability can also be used to at first only expose a new feature to a select,
    limited set of users that are part of a usability study. This allows researchers
    or product owners to closely observe these users using the new feature, while
    other users cannot access it yet.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 启用可用性测试的一个极好技术是使用功能标志。功能标志使我们能够逐步将新功能暴露给更多用户。这个能力还可以用于最初仅将新功能暴露给一小部分用户，这些用户是可用性研究的一部分。这允许研究人员或产品负责人密切观察这些用户使用新功能，而其他用户尚无法访问。
- en: Important Note
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Feature flags were discussed in [*Chapter 6*](B18655_06.xhtml#_idTextAnchor330),
    *Implementing Continuous Deployment and Release Management*, as a strategy for
    progressive exposure. The progressive exposure of new features is in itself a
    form of usability or user acceptance testing.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 功能标志在[*第6章*](B18655_06.xhtml#_idTextAnchor330)《实现持续部署和发布管理》中被讨论，作为渐进式曝光的策略。新功能的渐进式曝光本身就是一种可用性或用户接受度测试。
- en: This approach can be extended to execute A/B tests. In these types of tests,
    half of the users are exposed to a new feature while the other half are not. Metrics
    are then gathered about all of the users to see whether the new feature brings
    users the benefits that were predicted for it—for example, if users use the application
    for more hours per day or not. This topic will be expanded upon in [*Chapter 13*](B18655_13.xhtml#_idTextAnchor1071),
    *Gathering User Feedback*, which looks at how to gather user feedback.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可以扩展到执行A/B测试。在这类测试中，一半的用户暴露于新功能，而另一半则没有。然后收集所有用户的数据，以查看新功能是否为用户带来了预期的好处——例如，用户是否每天使用应用程序的时间增加了。这一主题将在[*第13章*](B18655_13.xhtml#_idTextAnchor1071)《收集用户反馈》中进一步探讨，内容涉及如何收集用户反馈。
- en: Doing this shifts usability testing closer to the right in the release process.
    It can also be shifted to the left by performing usability tests not with the
    final application, but with mockups.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做将可用性测试推向了发布过程的右侧。它也可以通过在最终应用程序之前，使用原型进行可用性测试，向左移动。
- en: This concludes the discussion of the different types of tests. In the next section,
    metrics and tests will be used to automatically measure quality and implement
    quality gates.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了对不同类型测试的讨论。在接下来的部分中，将使用度量和测试来自动衡量质量并实现质量门控。
- en: Executing tests in a pipeline
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在管道中执行测试
- en: 'Developers should execute tests on their local machine before opening a merge
    request for their code. That way, they can be confident that any of the changes
    they made did not break any of the previous behaviors of their code. In theory,
    this provides the guarantee that all code merged to the master branch compiles
    and has all tests passing. In practice, there are many reasons why this is not
    the case. Some can be as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 开发人员应该在为代码打开合并请求之前，在本地机器上执行测试。这样，他们可以确信所做的任何更改不会破坏代码的先前行为。从理论上讲，这可以保证所有合并到主分支的代码都能编译并且所有测试都通过。实际上，存在许多原因导致情况并非如此。以下是一些原因：
- en: Some tests might not be able to be run locally. They depend on confidential
    configuration values or are configured to run against a fully configured system.
    One or both of these are often the case for system tests. There are many situations
    where it is impossible to run system tests from the local system. Not all of these
    situations are necessarily desirable or insurmountable—but still, this is often
    the case.
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些测试可能无法在本地运行。它们依赖于机密的配置值，或者被配置为在完全配置的系统上运行。这两种情况常见于系统测试。有许多情况是无法从本地系统运行系统测试的。这些情况并不一定都是理想的或无法克服的——但这通常是事实。
- en: Developers are only human. They might forget to run the tests on their local
    machines after that one final tweak or are convinced that their changes did not
    break any existing behavior. Especially when delivering a bug fix under pressure,
    it can be tempting to skip running tests for the sake of speed.
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发人员也是人。他们可能会忘记在做最后一个调整后运行本地机器上的测试，或者确信他们的更改没有破坏任何现有行为。特别是在压力下交付错误修复时，为了加快速度，跳过测试执行可能是很有诱惑力的。
- en: To prevent these situations from allowing code that is not fully tested to propagate
    through the pipeline, it is recommended to have all tests also executed from within
    the pipeline. The following sections will show how to do this for unit and integration
    tests and for tests that are being run using other systems. First up are unit
    tests.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这些情况使未经过充分测试的代码在流水线中传播，建议在流水线内执行所有测试。接下来的部分将展示如何为单元测试、集成测试以及通过其他系统运行的测试执行此操作。首先是单元测试。
- en: Running unit tests
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行单元测试
- en: For many languages, support for running unit tests from the pipeline is built
    into Azure DevOps. Unit tests can be executed for C#, TypeScript, Python, Maven,
    C++, Go, and many more.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多语言，Azure DevOps已经内建了支持从流水线运行单元测试的功能。可以为C#、TypeScript、Python、Maven、C++、Go等语言执行单元测试。
- en: For some of these languages, a single ready-made task is available. One example
    of this is tests written in C#. During the execution of .NET tests—for example,
    in C#—test results are automatically stored in an XML format that is understood
    by the build agent.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其中一些语言，提供了一个现成的任务。例如，用C#编写的测试。在执行.NET测试时——例如在C#中——测试结果会自动以XML格式存储，构建代理可以理解该格式。
- en: 'This allows the pipeline agent to interpret the test results and visualize
    them in the build results, as shown here:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许流水线代理解释测试结果并在构建结果中可视化它们，如下所示：
- en: '![Figure 10.14 – Example for build results page showing automated test execution
    results  ](img/B18655_10_14.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.14 – 显示自动化测试执行结果的构建结果页面示例](img/B18655_10_14.jpg)'
- en: Figure 10.14 – Example for build results page showing automated test execution
    results
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.14 – 显示自动化测试执行结果的构建结果页面示例
- en: 'For some languages, more than one task has to be executed. For example, tests
    written in TypeScript are often executed via an NPM command. The following YAML
    snippet can be used to do this:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些语言，需要执行多个任务。例如，用TypeScript编写的测试通常通过NPM命令执行。以下YAML片段可以用来实现这一点：
- en: '[PRE4]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will execute a custom NPM command as specified in `package.json`. Unfortunately,
    this will not store the test results in a format that the pipeline agent understands.
    To translate the outcomes into the correct format, another task is needed. The
    following YAML snippet can be used to do this:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这将执行`package.json`中指定的自定义NPM命令。不幸的是，这不会以流水线代理理解的格式存储测试结果。为了将结果转换为正确的格式，需要另一个任务。以下YAML片段可以用来实现这一点：
- en: '[PRE5]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Whether test results are available directly or have to be translated varies
    from programming language to programming language. Besides publishing test results,
    it is also recommended to gather test coverage results.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 测试结果是否可以直接获得或需要转换，因编程语言而异。除了发布测试结果外，还建议收集测试覆盖率结果。
- en: Recording unit test code coverage
  id: totrans-254
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录单元测试代码覆盖率
- en: It is a best practice to not only run all unit tests during the build but also
    determine the percentage of the code base that was executed during any of these
    tests. This is called **unit test code coverage** and is an indication of how
    thorough the tests are. The build can also be configured to publish the code coverage
    achieved by unit tests.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是，在构建过程中不仅运行所有单元测试，还要确定在这些测试中执行的代码基础的百分比。这被称为**单元测试代码覆盖率**，它表示测试的全面程度。构建也可以配置为发布单元测试获得的代码覆盖率。
- en: 'To configure the build to publish test coverage for .NET Core unit tests, the
    following steps must be performed:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置构建以发布.NET Core单元测试的测试覆盖率，必须执行以下步骤：
- en: Install the `coverlet.msbuild` NuGet package in the unit test project.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在单元测试项目中安装`coverlet.msbuild` NuGet包。
- en: Use the .NET Core task to execute the test and add two parameters to also generate
    coverage reports, `/p:CollectCoverage=true` and `/p:CoverletOutputFormat=cobertura`.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用.NET Core任务执行测试，并添加两个参数以生成覆盖率报告，`/p:CollectCoverage=true`和`/p:CoverletOutputFormat=cobertura`。
- en: '![Figure 10.15 – Configuring unit test code coverage ](img/B18655_10_15.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.15 – 配置单元测试代码覆盖率](img/B18655_10_15.jpg)'
- en: Figure 10.15 – Configuring unit test code coverage
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.15 – 配置单元测试代码覆盖率
- en: Add the `Cobertura`.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`Cobertura`。
- en: Configure `$(System.DefaultWorkingDirectory)/**/coverage.cobertura.xml` as the
    summary file.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置`$(System.DefaultWorkingDirectory)/**/coverage.cobertura.xml`作为汇总文件。
- en: '![Figure 10.16 – Publishing unit test code coverage ](img/B18655_10_16.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.16 – 发布单元测试代码覆盖率](img/B18655_10_16.jpg)'
- en: Figure 10.16 – Publishing unit test code coverage
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.16 – 发布单元测试代码覆盖率
- en: The build’s run details will now contain code coverage reports.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建的运行详情现在将包含代码覆盖率报告。
- en: This is all of the configuration needed to generate detailed code coverage reports.
    The generated reports contain the number of covered and uncovered code blocks
    and the calculated coverage percentage. These reports are part of the build results
    page.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这是生成详细代码覆盖率报告所需的所有配置。生成的报告包含已覆盖和未覆盖的代码块数量以及计算出的覆盖率百分比。这些报告是构建结果页面的一部分。
- en: Next to unit tests, integration tests can also be run as part of the pipeline
    and they often come with the challenge of dealing with managing configuration
    settings.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 除了单元测试，集成测试也可以作为管道的一部分运行，并且它们通常面临处理配置设置管理的挑战。
- en: Running integration tests
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行集成测试
- en: Integration tests are often written in the same framework as unit tests. Still,
    they come with a unique challenge of their own. Often, they require one or more
    settings that specify how to integrate with one or more other components that
    are part of the test. Looking back at the integration test of the `MessageSender`
    class discussed before, this is an example of this problem.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试通常与单元测试使用相同的框架编写。不过，它们有自己独特的挑战。通常，它们需要一个或多个设置，指定如何与测试中涉及的一个或多个其他组件进行集成。回顾之前讨论的`MessageSender`类的集成测试，这是这个问题的一个例子。
- en: Remember how this test had a `.runsettings` file where you should specify `connectionString`
    to the queue that the `MessageSender` class will use. This `connectionString`
    setting cannot be checked into source control. Instead, a placeholder can be checked
    into source control, which is then replaced with the actual secret during pipeline
    execution.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 记得这个测试有一个`.runsettings`文件，在其中你应该指定`connectionString`，该连接字符串是`MessageSender`类将使用的队列。这个`connectionString`设置不能提交到源代码控制中。相反，可以将占位符提交到源代码控制中，并在管道执行过程中用实际的密钥替换它。
- en: 'In this case, this would mean that the following `pipeline.runsettings` file
    would be checked into source control:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这意味着以下`pipeline.runsettings`文件将提交到源代码控制中：
- en: '[PRE6]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Before starting the actual test execution, another task is run to replace the
    placeholders with the actual values. These values can be securely retrieved from
    a variable group, key vault, or pipeline variable, as discussed in [*Chapter 5*](B18655_05.xhtml#_idTextAnchor177),
    *Moving to Continuous Integration*. There are multiple extensions for Azure DevOps
    available that can be used for replacing placeholders with actual values. The
    following YAML snippet is an example of how to do this:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实际测试执行之前，另一个任务将被运行，用实际值替换占位符。正如在[*第5章*](B18655_05.xhtml#_idTextAnchor177)《迁移到持续集成》中讨论的那样，这些值可以从变量组、密钥保管库或管道变量中安全地获取。Azure
    DevOps 有多个扩展可以用于将占位符替换为实际值。以下 YAML 代码片段是如何操作的示例：
- en: '[PRE7]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After the execution of the replace tokens task, the test runner can be invoked
    just as with unit tests. This **Replace Tokens** extension is available on the
    Azure DevOps Marketplace: [https://marketplace.visualstudio.com/items?itemName=qetza.replacetokens](https://marketplace.visualstudio.com/items?itemName=qetza.replacetokens).'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在替换令牌任务执行后，可以像单元测试一样调用测试运行器。这个**Replace Tokens**扩展可以在 Azure DevOps Marketplace
    上找到：[https://marketplace.visualstudio.com/items?itemName=qetza.replacetokens](https://marketplace.visualstudio.com/items?itemName=qetza.replacetokens)。
- en: Running external tests
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行外部测试
- en: Besides unit and integration tests, you will probably want to execute tests
    using other systems. For example, Azure DevOps has no built-in support for executing
    load tests or automated UI tests. For these types of tests, it is necessary to
    invoke other systems from the pipeline. Many systems can be integrated in this
    way.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 除了单元测试和集成测试，你可能还希望使用其他系统执行测试。例如，Azure DevOps 没有内置的支持来执行负载测试或自动化 UI 测试。对于这些类型的测试，必须从管道中调用其他系统。许多系统可以通过这种方式集成。
- en: 'How to do this differs from system to system, but most of the time, the following
    steps will apply:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 如何操作因系统而异，但大多数情况下，以下步骤将适用：
- en: Configure the tests in the external system.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置外部系统中的测试。
- en: Install an extension for Azure DevOps that makes new tasks available for calling
    into that external system from the pipeline.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 Azure DevOps 安装一个扩展，使新任务能够从管道调用外部系统。
- en: Create a service connection to the external system.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建到外部系统的服务连接。
- en: Add the task to the pipeline.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将任务添加到管道中。
- en: For details on configuring integrations, a good starting point is often the
    website of the vendor of the third-party product.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解配置集成的详细信息，一个好的起点通常是第三方产品供应商的网站。
- en: Maintaining quality
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 维护质量
- en: The previous sections detailed various types of tests and metrics that can be
    used for describing the quality of an application. With these in mind, it is time
    to start thinking about the tools that can be used for maintaining high quality
    or even increasing quality.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的章节详细介绍了可以用来描述应用程序质量的各种测试和指标。有了这些考虑，接下来是时候开始思考可以用于维持高质量甚至提高质量的工具了。
- en: Code reviews
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码审查
- en: One of the most powerful tools for guarding code quality is a code review. When
    working with Git, a pull request needs to be performed to merge the changes of
    a developer back into the mainline. A pull request allows one or more other developers
    to review all changes and comment on them. The developer that opened the pull
    request can review the comments and make changes accordingly, increasing the quality
    of the changes while they keep working.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 保护代码质量的最强大工具之一就是代码审查。当使用 Git 时，必须执行拉取请求（pull request）将开发者的更改合并回主分支。拉取请求允许一个或多个开发者审查所有更改并对此进行评论。发起拉取请求的开发者可以查看评论并据此进行修改，在继续工作的同时提高更改的质量。
- en: For code reviews to work at their best, it is important not to see them as a
    gate that you must get your changes through with as little effort as possible.
    It is much more fruitful to have an open attitude based on the assumption that
    everyone is trying to create high-quality code and see the code review as the
    start of a discussion on code quality. It is important to change perspectives,
    from seeing the code review as an annoying ritual in software development where
    others will complain about your code to an opportunity for welcoming others to
    give their input about your code and help you write code of higher quality.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使代码审查发挥最大作用，重要的是不要将其视为一个必须尽量轻松通过的关卡。采取一种更为开放的态度，假设每个人都在努力编写高质量的代码，并将代码审查视为有关代码质量的讨论的开始，这样会更加有益。改变视角，把代码审查从软件开发中令人烦恼的仪式转变为一个欢迎他人对你的代码提出意见并帮助你编写更高质量代码的机会。
- en: 'Once such an attitude is in place, code reviews will become a source of learning.
    They will result in discussions between peers about the best way forward for tackling
    an issue: the best way not just for now, but for the future as well, taking no
    technical debt and having enough unit and integration tests along with the code
    that is to be merged. Code reviews are also a great tool for mentoring junior
    developers, allowing them to receive feedback on their work. It can even be more
    valuable to have junior developers review the code of senior developers. This
    way, they can ask questions about things they do not yet know, and it will often
    lead to them pointing out overly complex solutions that might become technical
    debt over time.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦有了这样的心态，代码审查将成为学习的源泉。它们将促使同行之间展开讨论，寻找解决问题的最佳方式：不仅仅是现在的最佳方法，还要考虑未来，不留下技术债务，并确保与要合并的代码一起有足够的单元测试和集成测试。代码审查也是辅导初级开发者的绝佳工具，允许他们获得对其工作的反馈。让初级开发者审查高级开发者的代码甚至更有价值。通过这种方式，他们可以提出自己尚未掌握的问题，并且通常会指出那些可能随着时间推移成为技术债务的过于复杂的解决方案。
- en: Automatically gathering quality metrics
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动收集质量指标
- en: Next to manual reviews, there are also many tools available for automatically
    determining the quality of a code base. Some are built into Azure Pipelines, but
    more elaborate functionality comes from separate code-scanning tools. There are
    different mathematical approaches to measuring technical debt and using a tool
    to do so provides great insights into not only the quality of an application but
    also the changes over time.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 除了手动审查外，还有许多工具可以自动评估代码库的质量。有些工具内置于 Azure Pipelines 中，但更复杂的功能来自于独立的代码扫描工具。通过数学方法来衡量技术债务，使用工具来进行此类衡量不仅能为应用的质量提供有价值的洞察，还能帮助了解代码随时间变化的情况。
- en: One possible tool for measuring the quality of an application is SonarCloud.
    SonarCloud is the SaaS offering based on SonarCube. This tool can automatically
    scan a code base for possible bugs, security risks, technical debt, and other
    metrics for quality. This is a paid, separate offering that integrates with Azure
    DevOps pipelines. To work with SonarCloud, you have to create an account and retrieve
    a project key to invoke a SonarCloud scan from Azure DevOps.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 衡量应用程序质量的一种可能工具是 SonarCloud。SonarCloud 是基于 SonarCube 的 SaaS 产品。此工具可以自动扫描代码库，查找潜在的漏洞、安全风险、技术债务和其他质量指标。这是一个付费的独立产品，能够与
    Azure DevOps 管道集成。要使用 SonarCloud，你必须创建一个帐户并获取项目密钥，以便从 Azure DevOps 调用 SonarCloud
    扫描。
- en: 'For invoking SonarCloud, a set of three tasks is used that are part of an extension
    for Azure DevOps. After installing the extension and configuring a SonarCloud
    service connection, three tasks are added to the pipeline to set up the analysis,
    execute it, and (optionally) fail the build if the quality degrades. The first
    task is the only one that takes configuration, which is shown in the following
    screenshot:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调用 SonarCloud，使用一组三项任务，这些任务是 Azure DevOps 扩展的一部分。在安装扩展并配置 SonarCloud 服务连接后，三个任务会被添加到管道中，以设置分析、执行分析并（可选地）在质量下降时使构建失败。第一个任务是唯一需要配置的任务，配置过程如以下截图所示：
- en: '![Figure 10.17 – Configuring SonarCloud – static code analyzer ](img/B18655_10_17.jpg)'
  id: totrans-294
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.17 – 配置 SonarCloud – 静态代码分析器](img/B18655_10_17.jpg)'
- en: Figure 10.17 – Configuring SonarCloud – static code analyzer
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.17 – 配置 SonarCloud – 静态代码分析器
- en: Every build that is now executed will automatically have its code scanned by
    SonarCloud, where extensive reports about the quality will be available. On top
    of these reports, a dashboard is generated that provides a quick overview of some
    key quality metrics.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 每次执行的构建都会自动扫描其代码，由 SonarCloud 提供关于质量的详细报告。在这些报告的基础上，还会生成一个仪表盘，快速概览一些关键的质量指标。
- en: '![Figure 10.18 – SonarCloud quality metrics overview ](img/B18655_10_18.jpg)'
  id: totrans-297
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.18 – SonarCloud 质量指标概览](img/B18655_10_18.jpg)'
- en: Figure 10.18 – SonarCloud quality metrics overview
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.18 – SonarCloud 质量指标概览
- en: 'Here is another look at the dashboard showing quality metrics:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这是仪表盘的另一个视图，展示了质量指标：
- en: '![Figure 10.19 – SonarCloud quality gate dashboard  ](img/B18655_10_19.jpg)'
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.19 – SonarCloud 质量门控仪表盘](img/B18655_10_19.jpg)'
- en: Figure 10.19 – SonarCloud quality gate dashboard
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.19 – SonarCloud 质量门控仪表盘
- en: Code-scanning tools can be used for reporting the quality of the code but can
    also act as a quality gate that will stop the merge of changes or deployment to
    a specific environment if insufficient quality is detected.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 代码扫描工具可以用于报告代码的质量，同时也可以作为质量门控，阻止合并更改或将更改部署到特定环境中，如果检测到质量不足。
- en: Visualizing quality
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可视化质量
- en: Measuring the quality of an application continuously has no value unless it
    is acted upon. Dashboards can be a powerful tool for gaining continuous insights
    into the current level of quality and how the quality has changed over time.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 持续衡量应用程序的质量是没有意义的，除非采取了相应的措施。仪表盘可以成为一个强大的工具，帮助持续洞察当前的质量水平以及质量随时间的变化。
- en: Most code quality tools have built-in reporting options, and they can be valuable
    for QA engineers. They provide detailed insight into which parts of the application
    are of higher quality and which types of issues recently occurred more frequently.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数代码质量工具都内置了报告选项，它们对 QA 工程师非常有价值。它们提供了详细的洞察，帮助了解应用程序哪些部分的质量较高，哪些类型的问题最近发生得更频繁。
- en: 'The downside of this type of dashboard is that they can often be hard to read
    and correlate as they may exist in another tool that is different from Azure DevOps
    where developers perform most of their work. For this reason, it can be beneficial
    to also create dashboards in Azure DevOps to report on quality. An example of
    such a dashboard is shown in the following screenshot:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的仪表盘的缺点是，它们通常很难阅读和关联，因为它们可能存在于与开发人员执行大部分工作所在的 Azure DevOps 不同的其他工具中。因此，创建
    Azure DevOps 中的仪表盘来报告质量可能会更有益。以下截图展示了这样的仪表盘示例：
- en: '![Figure 10.20 – Azure DevOps dashboard quality overview  ](img/B18655_10_20.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.20 – Azure DevOps 仪表盘质量概览](img/B18655_10_20.jpg)'
- en: Figure 10.20 – Azure DevOps dashboard quality overview
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.20 – Azure DevOps 仪表盘质量概览
- en: 'This dashboard shows an overview of the current quality and application code,
    as well as some recent history. Here, you can find the following information:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 该仪表盘显示了当前质量和应用程序代码的概览，以及一些最近的历史记录。在这里，你可以找到以下信息：
- en: The number of recent changes is shown at the top, along with the result of the
    most recent SonarCloud **Quality Gate** outcome, which currently reads **Passed**.
    The results of the two different builds in this project are shown in the second
    row.
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在顶部显示最近更改的数量，以及最新的 SonarCloud **质量 gate** 结果，当前显示为 **通过**。该项目中两次不同构建的结果显示在第二行。
- en: 'The third and fourth rows show aggregations of all of the builds and releases
    within the project. Symbols are used to denote the status of the builds and releases:
    successful, failed, or still running.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三行和第四行显示项目中所有构建和发布的聚合结果。使用符号表示构建和发布的状态：成功、失败或仍在运行。
- en: On the right, two widgets are used to show the percentage of failed tests and
    the corresponding number of failed tests over the last 10 builds.
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在右侧，使用两个小部件显示过去 10 个构建中的失败测试的百分比和相应的失败测试数量。
- en: The results of the latest release runs per environment are shown below this.
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个环境下最新发布运行的结果显示在下方。
- en: 'Dashboards such as these can be created per team or per project using built-in
    widgets or extensions. There are many extensions available in the Azure DevOps
    Marketplace. For example, in the preceding dashboard, the **Team Project Health**
    extension is used. This extension is available on Azure DevOps here: [https://marketplace.visualstudio.com/items?itemName=ms-devlabs.TeamProjectHealth](https://marketplace.visualstudio.com/items?itemName=ms-devlabs.TeamProjectHealth).'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用内置小部件或扩展根据团队或项目创建这样的仪表板。Azure DevOps 市场中有许多扩展。例如，在前面的仪表板中，使用了 **Team Project
    Health** 扩展。此扩展可在 Azure DevOps 上找到：[https://marketplace.visualstudio.com/items?itemName=ms-devlabs.TeamProjectHealth](https://marketplace.visualstudio.com/items?itemName=ms-devlabs.TeamProjectHealth)。
- en: Azure DevOps dashboards can be configured to automatically refresh every 5 minutes,
    making them usable as wallboards as well.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Azure DevOps 仪表板可以配置为每 5 分钟自动刷新，从而也能作为墙板使用。
- en: Quality gates
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 质量 gates
- en: Measuring, reporting, and even visualizing quality is important and valuable;
    however, if no one is acting upon all of these metrics, it has no value to the
    development team. To prevent this, automatic quality gates or checks can be introduced.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 衡量、报告甚至可视化质量是重要且有价值的；然而，如果没有人基于这些指标采取行动，那么对开发团队来说这些指标就没有价值。为了防止这种情况，可以引入自动质量
    gates 或检查。
- en: One way to implement quality gates is by failing the continuous integration
    build whenever a test fails, the test coverage falls too low, or the thresholds
    that were set for the code-scanning tool are no longer being met. These are all
    things that have been discussed before. Another option to enforce standards is
    by adding gates or checks to pipelines. This way, certain conditions have to be
    met before the pipeline can continue.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 实现质量 gates 的一种方法是，当测试失败、测试覆盖率过低或代码扫描工具设定的阈值不再满足时，使持续集成构建失败。这些都是之前讨论过的内容。另一个强制执行标准的选项是向管道中添加
    gates 或检查点。通过这种方式，必须满足某些条件，管道才能继续执行。
- en: How to do this differs between classic releases and YAML multi-stage pipelines.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如何实现这一点在经典发布和 YAML 多阶段管道之间有所不同。
- en: Classic releases
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 经典发布
- en: One other option is the use of *gates* on Azure release pipelines. Here, it
    is possible to specify one or more conditions that have to be met before a release
    is allowed to be deployed to a specific environment. Gates can also be part of
    an extension, such as the SonarCloud extension, which was discussed before.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个选项是使用 Azure 发布管道中的 *gates*。在这里，可以指定一个或多个条件，必须满足这些条件才能允许将发布部署到特定环境中。gates
    还可以是扩展的一部分，例如之前讨论过的 SonarCloud 扩展。
- en: 'Gates can be added by selecting any stage in a release pipeline and editing
    the predeployment conditions. After enabling gates, one or more gates can be added.
    The following screenshot of a release pipeline shows how to disallow the deployment
    of any build of insufficient quality to an environment:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过选择发布管道中的任何阶段并编辑预部署条件来添加 gates。启用 gates 后，可以添加一个或多个 gates。以下是发布管道的截图，展示了如何禁止将任何质量不合格的构建部署到环境中：
- en: '![Figure 10.21 – Azure DevOps configuring deployment gates ](img/B18655_10_21.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.21 – Azure DevOps 配置部署 gates](img/B18655_10_21.jpg)'
- en: Figure 10.21 – Azure DevOps configuring deployment gates
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.21 – Azure DevOps 配置部署 gates
- en: The use of deployment approvals and gates is not mutually exclusive, so a mix
    of both can be used.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 部署审批和 gates 的使用并不相互排斥，因此可以同时使用两者。
- en: Multi-stage pipelines
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多阶段管道
- en: 'Gates, as they are available for classic releases, are present in multi-stage
    YAML pipelines. In YAML pipelines, another mechanism is available: checks. Checks
    are configured to automatically validate whether one or more conditions are met
    before allowing a pipeline to continue. Checks can be added to resources that
    are used in a stage. If one or more checks are found on one or more resources
    in a stage, all of the checks have to be passed before the pipeline continues
    to that stage. Checks can be added to environments and service connections.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Gates（如在经典发布中可用）也可以在多阶段的 YAML 流水线中使用。在 YAML 流水线中，还有另一种机制：检查。检查被配置为在允许流水线继续之前自动验证一个或多个条件是否满足。检查可以添加到在某个阶段使用的资源上。如果在某个阶段的一个或多个资源上发现一个或多个检查，则所有检查必须通过，流水线才可以继续到该阶段。检查可以添加到环境和服务连接中。
- en: To add a check to an environment, navigate to that environment.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 要向环境添加检查，请导航到该环境。
- en: '![Figure 10.22 – Azure DevOps configuring environments ](img/B18655_10_22.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.22 – 配置 Azure DevOps 环境](img/B18655_10_22.jpg)'
- en: Figure 10.22 – Azure DevOps configuring environments
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.22 – 配置 Azure DevOps 环境
- en: 'Now, perform the following steps:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，执行以下步骤：
- en: At the top right, expand the menu and choose **Approvals and checks**.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右上角，展开菜单并选择**审批和检查**。
- en: In the new view that opens, click on **See all** to see all of the different
    types of checks that are available.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在打开的新视图中，点击**查看所有**以查看所有可用的检查类型。
- en: 'Choose **Invoke Azure Function**:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**调用 Azure 函数**：
- en: '![Figure 10.23 – Azure DevOps configuring environment approval and checks ](img/B18655_10_23.jpg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.23 – 配置 Azure DevOps 环境审批和检查](img/B18655_10_23.jpg)'
- en: Figure 10.23 – Azure DevOps configuring environment approval and checks
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.23 – 配置 Azure DevOps 环境审批和检查
- en: In the popup that opens, configure the Azure function to be called. At a minimum,
    the function URL and key have to be provided.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在弹出的窗口中，配置要调用的 Azure 函数。至少需要提供函数的 URL 和密钥。
- en: Click **Create**.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建**。
- en: Once the check is created, every deployment job (see [*Chapter 6*](B18655_06.xhtml#_idTextAnchor330),
    *Implementing Continuous Deployment and Release Management*) that targets the
    environment has to pass this check. The check is passed when the function that
    is called returns a successful response code.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦检查创建完成，每个目标环境的部署任务（参见[*第6章*](B18655_06.xhtml#_idTextAnchor330)，*实施持续部署和发布管理*）都必须通过此检查。当被调用的函数返回成功响应代码时，检查通过。
- en: 'The following types of checks are supported:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 支持以下类型的检查：
- en: '**Evaluate artifact**: Validate that an artifact of the container image type
    passes a custom policy. These policies are defined in a language called *Rego*.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**评估工件**：验证容器镜像类型的工件是否通过了自定义策略。这些策略是使用一种名为*Rego*的语言定义的。'
- en: '**Invoke REST API**: Post details about the pipeline to an Azure function or
    REST API to execute custom logic. If the API returns a successful HTTP status
    code, the pipeline is allowed to continue.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调用 REST API**：将流水线的详细信息发布到 Azure 函数或 REST API，以执行自定义逻辑。如果 API 返回成功的 HTTP
    状态码，则允许流水线继续。'
- en: '**Invoke Azure Function**: The same as the **Invoke REST API** check, but with
    some defaults for Azure Functions.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调用 Azure 函数**：与**调用 REST API**检查相同，但具有一些 Azure 函数的默认设置。'
- en: '**Query Azure Monitor alerts**: Only continue if the specified alerts are not
    in an active state.'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询 Azure Monitor 警报**：仅在指定的警报处于非活动状态时才继续。'
- en: '**Required template**: Only allow the pipeline to continue if the current YAML
    pipeline extends one or more configured base YAML templates.'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**必需的模板**：仅当当前的 YAML 流水线扩展了一个或多个配置的基础 YAML 模板时，才允许流水线继续。'
- en: Checks can be a powerful mechanism for guaranteeing that one or more conditions
    are met before allowing a pipeline to continue.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 检查可以是确保满足一个或多个条件后再允许流水线继续的强大机制。
- en: Summary
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you learned how to measure and assert the quality of software
    development processes. Releasing quickly and often requires the software that
    is written to be of high quality. Testing is needed to ensure that you write software
    of high quality with little technical debt. You learned about the different types
    of tests and the pros and cons of the different types of automated and manual
    tests. Finally, you learned how code reviews and tools can help to maintain high
    quality in your project, by reporting on quality and serving as a quality gate.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, you now understand the tests and test types to help you
    to decide which tests are needed for your applications, which risks you can address
    using which types of tests, and which ones you need and can omit. You are now
    also capable of setting up and configuring code-scanning tools to ensure that
    changes of insufficient quality are not merged to the mainline.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about security and compliance, two topics
    that remain equally important when practicing DevOps.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter’s material. You will find the answers in the *Assessments*
    section of the *Appendix*:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: 'True or false: A unit test verifies the working of a single unit in isolation.'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: An integration test verifies the working of a fully assembled
    system.'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following statements is correct regarding the principles of the
    testing pyramid?
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Have many integration tests, fewer unit tests, and even fewer system tests
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Have many unit tests, fewer integration tests, and even fewer system tests
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Have many system tests, fewer integration tests, and many unit tests
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is not a non-functional type of test?
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Load testing
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Usability testing
  id: totrans-361
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Applicability testing
  id: totrans-362
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Performance testing
  id: totrans-363
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Testing is about gaining insights into the quality of work. Which techniques
    can be employed to prevent work of insufficient quality from propagating through
    to production?
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Self exercise
  id: totrans-365
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open the `packtbookslibrary-api` solution that we created earlier in [*Chapter
    6*](B18655_06.xhtml#_idTextAnchor330)*, Implementing Continuous Deployment and
    Release Management, Exercises section* and add a new project (select **NUnit Test
    Project**).
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 10.24 – Self exercise – adding a new test project ](img/B18655_10_24.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
- en: Figure 10.24 – Self exercise – adding a new test project
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: Create a new test project.
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 10.25 – Self exercise – creating a new test project ](img/B18655_10_25.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
- en: Figure 10.25 – Self exercise – creating a new test project
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: Once the test project is created, add a reference to `packtbookslibrary-api`
    in **Dependencies**.
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 10.26 – Self exercise – configuring Dependencies ](img/B18655_10_26.jpg)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
- en: Figure 10.26 – Self exercise – configuring Dependencies
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: Add a `IBookService.cs` interface and the `BookService.cs` class, which implements
    the `IBookService` interface.
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 10.27 – Self exercise – adding the IBookService.cs interface ](img/B18655_10_27.jpg)'
  id: totrans-376
  prefs: []
  type: TYPE_IMG
- en: Figure 10.27 – Self exercise – adding the IBookService.cs interface
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: '`IBookService.cs` will have the following code:'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`BookService.cs` will have the following implementation:'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-381
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the following code to `BooksController.cs`:'
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add a package reference to `Moq`:'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 10.28 – Self exercise – adding a package reference ](img/B18655_10_28.jpg)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
- en: Figure 10.28 – Self exercise – adding a package reference
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: 'Add code from `BooksControllerUnitTest` and execute a unit test in the pipeline.
    You can find the file here: [https://github.com/PacktPublishing/Designing-and-Implementing-Microsoft-DevOps-Solutions-AZ-400-Exam-Guide](https://github.com/PacktPublishing/Designing-and-Implementing-Microsoft-DevOps-Solutions-AZ-400-Exam-Guide)'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will notice that all test cases have successfully passed.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.29 – Self exercise – executing BookControllerUnitTest ](img/B18655_10_29.jpg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
- en: Figure 10.29 – Self exercise – executing BookControllerUnitTest
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
- en: 'Update `nugget.config` to add the `Sources` package:'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add a test case step to the YAML pipeline to execute test cases as part of
    the build process:'
  id: totrans-393
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Execute **main-ci-pipeline** to run the pipeline and to check the **Test** tab
    for the results of the test execution.
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 10.30 – Self exercise – executing a continuous integration pipeline
    to see the test results ](img/B18655_10_30.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_IMG
- en: Figure 10.30 – Self exercise – executing a continuous integration pipeline to
    see the test results
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More information about the testing trophy model can be found at [https://testingjavascript.com/](https://testingjavascript.com/)
    and [https://kentcdodds.com/blog/write-tests/](https://kentcdodds.com/blog/write-tests/).
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about writing tests using C# can be found at [https://docs.microsoft.com/en-us/visualstudio/test/walkthrough-creating-and-running-unit-tests-for-managed-code?view=vs-2022](https://docs.microsoft.com/en-us/visualstudio/test/walkthrough-creating-and-running-unit-tests-for-managed-code?view=vs-2022)
    and [https://docs.microsoft.com/en-us/dotnet/core/testing/unit-testing-best-practices](https://docs.microsoft.com/en-us/dotnet/core/testing/unit-testing-best-practices).
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about the Test & Feedback extension can be found at [https://marketplace.visualstudio.com/items?itemName=ms.vss-exploratorytesting-web](https://marketplace.visualstudio.com/items?itemName=ms.vss-exploratorytesting-web).
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practical labs to practice load testing can be found at [https://docs.microsoft.com/en-us/learn/modules/load-test-web-app-azure-devops/](https://docs.microsoft.com/en-us/learn/modules/load-test-web-app-azure-devops/)
    and [https://docs.microsoft.com/en-us/learn/modules/run-non-functional-tests-azure-pipelines/index](https://docs.microsoft.com/en-us/learn/modules/run-non-functional-tests-azure-pipelines/index).
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practical labs to practice automating UI tests can be found at [https://docs.microsoft.com/en-us/learn/modules/run-functional-tests-azure-pipelines/index](https://docs.microsoft.com/en-us/learn/modules/run-functional-tests-azure-pipelines/index).
  id: totrans-403
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 练习自动化UI测试的实用实验可以在[https://docs.microsoft.com/en-us/learn/modules/run-functional-tests-azure-pipelines/index](https://docs.microsoft.com/en-us/learn/modules/run-functional-tests-azure-pipelines/index)找到。
- en: More information about SonarCloud can be found at [https://sonarcloud.io](https://sonarcloud.io).
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于SonarCloud的更多信息可以在[https://sonarcloud.io](https://sonarcloud.io)找到。
- en: The Team Project Health extension can be found at [https://marketplace.visualstudio.com/items?itemName=ms-devlabs.TeamProjectHealth](https://marketplace.visualstudio.com/items?itemName=ms-devlabs.TeamProjectHealth).
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 团队项目健康扩展可以在[https://marketplace.visualstudio.com/items?itemName=ms-devlabs.TeamProjectHealth](https://marketplace.visualstudio.com/items?itemName=ms-devlabs.TeamProjectHealth)找到。
- en: More information about Rego can be found at [https://www.openpolicyagent.org/docs/latest/policy-language/](https://www.openpolicyagent.org/docs/latest/policy-language/).
  id: totrans-406
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于Rego的更多信息可以在[https://www.openpolicyagent.org/docs/latest/policy-language/](https://www.openpolicyagent.org/docs/latest/policy-language/)找到。
