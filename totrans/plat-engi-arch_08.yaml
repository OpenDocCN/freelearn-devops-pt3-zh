- en: <st c="0">8</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">8</st>
- en: <st c="2">Cost Management and Best Practices</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2">成本管理和最佳实践</st>
- en: <st c="36">Cloud migration has been the top priority for many IT organizations
    in the past few years and is still a strategic, relevant direction for the coming
    years.</st> <st c="194">Running and owning one’s own data center is also still
    a valuable approach; the design and costs for one’s own data center capabilities
    are usually more thought through than with the cloud.</st> <st c="384">In this
    chapter, we are going to dig deeper into this and will reflect on the necessity
    of cloud cost management</st> <st c="497">and optimization.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36">在过去几年里，云迁移一直是许多 IT 组织的首要任务，并且在未来几年仍然是一个战略性、相关的方向。</st> <st c="194">自建数据中心仍然是一个有价值的选择；相比于云，自建数据中心的设计和成本通常经过更深思熟虑。</st>
    <st c="384">在本章中，我们将深入探讨这一问题，并反思云成本管理</st> <st c="497">和优化的必要性。</st>
- en: <st c="514">You will learn more about tagging strategies and why they are a
    viable resource for gaining visibility and transparency in your cloud spending.</st>
    <st c="659">We will also examine how to define them, best practices, and practical
    approaches to ensure they are well set.</st> <st c="770">With this as a foundation,
    we will move on to the four pillars of cost optimization:</st> *<st c="855">processes</st>*<st
    c="864">,</st> *<st c="866">pricing</st>*<st c="873">,</st> *<st c="875">usage</st>*<st
    c="880">,</st> <st c="882">and</st> *<st c="886">design</st>*<st c="892">.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="514">你将更多地了解标签策略，以及它们为何是获取云支出可见性和透明度的可行资源。</st> <st c="659">我们还将探讨如何定义标签策略、最佳实践以及实际方法，确保它们得到妥善设置。</st>
    <st c="770">以此为基础，我们将深入探讨成本优化的四大支柱：</st> *<st c="855">流程</st>*<st c="864">、</st>
    *<st c="866">定价</st>*<st c="873">、</st> *<st c="875">使用</st>*<st c="880">、</st>
    <st c="882">以及</st> *<st c="886">设计</st>*<st c="892">。</st>
- en: <st c="893">To close this chapter, we share practical tips on how to optimize
    your platform and reduce your costs in the long run, as well as enabling you to
    provide cost-saving value to</st> <st c="1069">your users.</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="893">在本章的最后，我们将分享一些实用的建议，帮助你优化平台并长期降低成本，同时为你的用户提供节省成本的价值。</st> <st c="1069">。</st>
- en: <st c="1080">Overall, we will focus on effective cost management and how, as
    a platform engineer, you realize that.</st> <st c="1184">Here’s what you can expect</st>
    <st c="1211">to learn:</st>
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1080">总体而言，我们将重点讨论有效的成本管理，以及作为平台工程师，如何实现这一目标。</st> <st c="1184">以下是你可以期望学到的内容：</st>
- en: <st c="1220">Understanding the cost landscape—is the cloud the way</st> <st
    c="1275">to go?</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1220">理解成本格局——云是否是最佳选择</st> <st c="1275">？</st>
- en: <st c="1281">Implementing a tagging strategy to uncover</st> <st c="1325">hidden
    costs</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1281">实施标签策略以揭示</st> <st c="1325">隐藏成本</st>
- en: <st c="1337">Looking at cost</st> <st c="1354">optimization strategies</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1337">审视成本</st> <st c="1354">优化策略</st>
- en: <st c="1377">Autoscaling, cold storage, and other tricks for</st> <st c="1426">cost
    optimization</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1377">自动扩展、冷存储以及其他成本优化</st> <st c="1426">技巧</st>
- en: <st c="1443">Understanding the cost landscape – is the cloud the way to go?</st>
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1443">了解成本格局——云是否是最佳选择？</st>
- en: <st c="1506">Cost management</st> <st c="1522">in platform engineering begins
    with a good understanding of cost drivers</st> <st c="1595">within your infrastructure
    and how some platform components might influence those.</st> <st c="1679">Cost
    drivers are also elements that directly impact the total cost of your operations.</st>
    <st c="1766">Understanding and later identifying these can help in making informed
    decisions to provide cost-oriented and</st> <st c="1875">optimized platforms</st><st
    c="1894">.</st>
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1506">成本管理</st> <st c="1522">在平台工程中的应用始于对成本驱动因素的深入理解</st> <st c="1595">，特别是了解基础设施中哪些平台组件可能会影响这些因素。</st>
    <st c="1679">成本驱动因素也是直接影响你运营总成本的因素。</st> <st c="1766">理解并随后识别这些因素，有助于做出明智决策，从而提供以成本为导向的</st>
    <st c="1875">优化平台</st><st c="1894">。</st>
- en: <st c="1895">To cloud or not to cloud – that’s the question</st>
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="1895">是否选择云——这是一个问题</st>
- en: <st c="1942">For the past few years, there has been almost no way around a cloud
    adoption strategy.</st> <st c="2030">During those years, the movement has faced
    counterweights from companies that have successfully de-migrated, claiming that
    their on-premise setup is cheaper, better, and all they need.</st> *<st c="2215">Repatriation</st>*
    <st c="2227">is what this is called.</st> <st c="2252">The numbers of those doing
    this are not very clear and strongly depend on what is considered part of it.</st>
    <st c="2357">It became very famous as</st> *<st c="2382">HEY/Basecamp/37signals</st>*<st
    c="2404">, and their CTO David Heinemeier Hansson stated that</st> *<st c="2457">they
    will save over $7m over the next 5 years</st>* <st c="2502">if they do not run
    on the cloud.</st> <st c="2536">A dead stupid side-by-side comparison of their
    purchased servers that cost them half a million dollars versus their insane yearly
    cloud spend of $1.9 million makes the math</st> <st c="2709">complete</st> *<st
    c="2718">[1]</st>*<st c="2721">.</st>
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1942">过去几年，几乎没有办法绕过云采纳战略。</st> <st c="2030">在这些年里，这一运动面临了来自一些成功进行“反迁移”的公司压力，这些公司声称他们的本地部署比云更便宜、更好，并且满足他们的一切需求。</st>
    *<st c="2215">反迁移</st>* <st c="2227">就是这个过程的名称。</st> <st c="2252">做这种选择的人数并不十分明确，且很大程度上取决于什么算作其中的一部分。</st>
    <st c="2357">它变得非常著名，作为</st> *<st c="2382">HEY/Basecamp/37signals</st>*<st c="2404">，他们的首席技术官David
    Heinemeier Hansson曾表示</st> *<st c="2457">如果他们不使用云计算，他们将在未来五年节省超过700万美元</st>* <st
    c="2502">。</st> <st c="2536">他们购买的服务器与每年在云上花费190万美元之间进行的愚蠢对比，显示出他们的购买服务器花费了50万美元，这让数学变得非常清晰</st>
    <st c="2709">[1]</st>*<st c="2718">。</st>
- en: <st c="2722">Sure—Basecamp or HEY is not comparable with an enterprise, is it?</st>
    <st c="2789">From my own experience, I can tell that running even larger companies’
    hardware in their own data center is cheaper than going to the cloud.</st> <st
    c="2930">A key factor is the amount of data and how dynamic and scalable the infrastructure
    has to be for it.</st> <st c="3031">Calculating data in petabytes will quickly
    turn the cloud into a money sink without an end.</st> <st c="3123">A relatively
    static workload will also drastically reduce the benefits that are included, and
    it has many other drawbacks.</st> <st c="3246">On the other hand, the cloud market
    is growing continuously every year, with no end in sight.</st> <st c="3340">So,
    to come to a decision on what is the right way to go, you have to consider many
    moving parts, from a simple cost comparison to available skills and the actual
    demand of your business.</st> <st c="3528">Doing a full assessment of whether
    the cloud makes sense for you can be a project in itself.</st> <st c="3621">But
    we wanted to give you some ideas on criteria to consider if you are at</st> <st
    c="3696">this point:</st>
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2722">当然，Basecamp 或 HEY 与企业是不具可比性的，对吧？</st> <st c="2789">根据我的经验，我可以告诉你，运行大型公司的硬件在自有数据中心比迁移到云端要便宜。</st>
    <st c="2930">一个关键因素是数据量以及基础设施需要多么动态和可扩展。</st> <st c="3031">计算以拍字节为单位的数据时，云服务会迅速变成一个无尽的金钱黑洞。</st>
    <st c="3123">相对静态的工作负载也会大大减少所包含的好处，而且还有许多其他的缺点。</st> <st c="3246">另一方面，云市场每年都在持续增长，似乎没有尽头。</st>
    <st c="3340">因此，要做出决定，选择正确的方式，你需要考虑许多不断变化的因素，从简单的成本对比到可用技能以及你业务的实际需求。</st> <st
    c="3528">对云是否适合你的全面评估本身就可能是一个项目。</st> <st c="3621">但我们想给你一些关于应该考虑的标准，以便你能在</st>
    <st c="3696">这个阶段做出决策：</st>
- en: '**<st c="3707">Cost</st>**<st c="3712">: Evaluate initial CapEx or one-time
    costs for on-premise versus OpEx or continuous, subscription-like costs for cloud
    services, considering long-term financial impact but also that you will save the
    most money on cloud computing if you pay for 1 or 3 years upfront.</st> <st c="3980">This
    is almost like buying</st> <st c="4007">the hardware.</st>'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="3707">成本</st>**<st c="3712">：评估本地部署的初始资本支出（CapEx）或一次性费用，和云服务的运营支出（OpEx）或持续性订阅费用，并考虑长期财务影响，同时还要意识到，如果你提前支付1年或3年的费用，你在云计算上将节省最多的钱。</st>
    <st c="3980">这几乎就像是在购买</st> <st c="4007">硬件。</st>'
- en: '**<st c="4020">Scalability</st>**<st c="4032">: Assess your demand to scale
    resources dynamically in response to fast changes.</st> <st c="4114">A hint here:
    if the spikes are too fast, a static server might be better for the user experience
    than waiting for minutes until new</st> <st c="4246">instances start.</st>'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="4020">可扩展性</st>**<st c="4032">：评估你在快速变化情况下动态扩展资源的需求。</st> <st c="4114">这里有个提示：如果峰值增长太快，静态服务器可能比等待几分钟直到新</st>
    <st c="4246">实例启动更适合用户体验。</st>'
- en: '**<st c="4262">Reliability</st>**<st c="4274">: Evaluate uptime guarantees,
    redundancy, and failover capabilities to maintain continuous operations.</st>
    <st c="4378">Have a look at the history of outages.</st> <st c="4417">Some cloud
    providers frequently</st> <st c="4449">have issues.</st>'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="4262">可靠性</st>**<st c="4274">：评估正常运行时间保证、冗余和故障转移能力，以保持持续运营。</st> <st
    c="4378">查看停机历史。</st> <st c="4417">一些云提供商经常</st> <st c="4449">出现问题。</st>'
- en: '**<st c="4461">Compliance</st>**<st c="4472">: Ensure adherence to legal and
    regulatory requirements, focusing on data residency and sovereignty.</st> <st
    c="4574">You have to sharpen your point of view on sovereignty before you can
    decide.</st> <st c="4651">Unfortunately, this term has more of a spectrum than
    a clear list</st> <st c="4717">of requirements.</st>'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="4461">合规性</st>**<st c="4472">：确保遵守法律和监管要求，重点关注数据驻留和主权问题。</st> <st
    c="4574">在决定之前，你必须明确对主权的观点。</st> <st c="4651">不幸的是，这个术语的涵盖面比明确的要求清单</st> <st c="4717">更广泛。</st>'
- en: '**<st c="4733">Integration</st>**<st c="4745">: Ensure compatibility with existing
    systems and software, and availability of APIs and integration tools.</st> <st
    c="4853">The provider should support</st> **<st c="4881">infrastructure as code</st>**
    <st c="4903">(</st>**<st c="4905">IaC</st>**<st c="4908">), especially</st> <st
    c="4922">to programmatically create accounts, users,</st> <st c="4967">and permissions.</st>'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="4733">集成</st>**<st c="4745">：确保与现有系统和软件的兼容性，并提供API和集成工具。</st> <st
    c="4853">提供商应支持</st> **<st c="4881">基础设施即代码</st>** <st c="4903">(</st>**<st c="4905">IaC</st>**<st
    c="4908">)，尤其是</st> <st c="4922">能够通过编程创建账户、用户</st> <st c="4967">和权限。</st>'
- en: '**<st c="4983">Support</st>**<st c="4991">: Assess the availability and</st>
    <st c="5022">quality of technical support, along with</st> **<st c="5063">service-level
    agreements</st>** <st c="5087">(</st>**<st c="5089">SLAs</st>**<st c="5093">).</st>
    <st c="5097">Conduct research on other users’ satisfaction with the given support;
    just because you have a contract that someone keeps your system up and helps you
    doesn’t mean that the service is</st> <st c="5281">also good.</st>'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="4983">支持</st>**<st c="4991">：评估技术支持的可用性和质量，以及</st> **<st c="5063">服务水平协议</st>**
    <st c="5087">(</st>**<st c="5089">SLA</st>**<st c="5093">)。</st> <st c="5097">研究其他用户对所提供支持的满意度；仅仅因为你有合同，某人负责保持系统运行并帮助你，并不意味着该服务</st>
    <st c="5281">也一定好。</st>'
- en: '**<st c="5291">Development of new services</st>**<st c="5319">: Evaluate the
    speed and number of new features the provider gives you.</st> <st c="5392">Consider
    that there can also be too many updates per month but also that there are barely
    any</st> <st c="5486">new features.</st>'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="5291">新服务的开发</st>**<st c="5319">：评估提供商向你提供的新功能的速度和数量。</st> <st c="5392">考虑到每月更新过多的情况，也要注意是否几乎没有</st>
    <st c="5486">新功能。</st>'
- en: '**<st c="5499">Geographic considerations</st>**<st c="5525">: Consider the
    proximity of data centers to end users and the regional availability of services.</st>
    <st c="5623">If your company develops globally</st> <st c="5656">available</st>
    **<st c="5667">software as a service</st>** <st c="5688">(</st>**<st c="5690">SaaS</st>**<st
    c="5694">), it might be easier to build on a public cloud than to integrate several</st>
    <st c="5770">regional providers.</st>'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="5499">地理考虑</st>**<st c="5525">：考虑数据中心与最终用户的距离以及服务的区域可用性。</st> <st
    c="5623">如果你的公司开发全球</st> <st c="5656">可用的</st> **<st c="5667">软件即服务</st>** <st
    c="5688">(</st>**<st c="5690">SaaS</st>**<st c="5694">)，那么构建在公共云上可能比集成多个</st>
    <st c="5770">区域提供商更为容易。</st>'
- en: '**<st c="5789">Skill and expertise</st>**<st c="5809">: Evaluate the availability
    of skilled personnel and training requirements for managing the infrastructure.</st>
    <st c="5918">Consider that you still require practically anyone from any IT subject
    who can do that.</st> <st c="6006">What does a short-term plan look like?</st>
    <st c="6045">What is needed in the long run?</st> <st c="6077">Forget about cloud
    computing being easy; most enterprises struggle because they don’t get their</st>
    <st c="6173">teams educated.</st>'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="5789">技能与专业知识</st>**<st c="5809">：评估管理基础设施所需的专业人员和培训要求。</st> <st c="5918">考虑到你仍然需要任何IT领域的人才来完成这项工作。</st>
    <st c="6006">短期计划是什么样的？</st> <st c="6045">长期需要什么？</st> <st c="6077">别再认为云计算很简单了；大多数企业之所以苦苦挣扎，是因为他们没有让</st>
    <st c="6173">团队接受培训。</st>'
- en: '**<st c="6188">Environmental impact and sustainability</st>**<st c="6228">:
    Consider the provider’s energy consumption, carbon footprint, and sustainability
    practices.</st> <st c="6323">How do they manage their wastewater?</st> <st c="6360">If
    they buy carbon offsets, keep in mind that you have to pay for them, as they theoretically
    increase</st> <st c="6463">electricity costs.</st>'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="6188">环境影响和可持续性</st>**<st c="6228">：考虑提供商的能源消耗、碳足迹和可持续性实践。</st> <st
    c="6323">他们如何处理废水？</st> <st c="6360">如果他们购买碳补偿，记住你需要为此付费，因为理论上这会增加</st> <st c="6463">电费。</st>'
- en: '<st c="6481">Cloud has often one very strong point: almost nothing hinders
    you from just starting right away.</st> <st c="6579">You can find tons of templates,
    blueprints, and examples.</st> <st c="6637">And within a short time, you are up
    and running, having your first environment available as</st> <st c="6729">a platf</st><st
    c="6736">orm.</st>'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6481">云通常有一个非常强大的优势：几乎没有什么能阻止你立刻开始。</st> <st c="6579">你可以找到大量的模板、蓝图和示例。</st>
    <st c="6637">在短时间内，你就能开始运行，拥有你的第一个环境作为</st> <st c="6729">平台。</st>
- en: <st c="6741">When we opt for the cloud – we have to consider its hidden costs</st>
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="6741">当我们选择云时——我们必须考虑它的隐藏成本</st>
- en: <st c="6806">As we focus primarily</st> <st c="6829">on the cloud in this book,
    we will assume for now that those who go the bare-metal way have by nature a higher
    cost awareness</st> <st c="6955">and sensitivity.</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6806">由于我们本书主要聚焦云端，我们暂时假设选择裸金属方式的用户本能上具有更高的成本意识</st> <st c="6955">和敏感度。</st>
- en: <st c="6971">Cloud providers give us services</st> <st c="7004">on hand with
    a lot of</st> *<st c="7027">batteries included</st>*<st c="7045">. They often
    come with backup solutions, scalability,</st> **<st c="7099">high availability</st>**
    <st c="7116">(</st>**<st c="7118">HA</st>**<st c="7120">), and a centrally managed
    service.</st> <st c="7157">When planning the cloud infrastructure, most of the
    time, we will find hard facts and best guesses.</st> <st c="7257">Hard facts are
    information such as how many CPUs or servers are needed, which database should
    be used, whether it is a single node or HA, and so on.</st> <st c="7406">However,
    you should be aware that almost every option you take with a public cloud provider
    will have some</st> <st c="7513">cost impacts.</st>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6971">云提供商为我们提供了很多即用的服务，</st> <st c="7004">通常带有许多</st> *<st c="7027">内置的功能</st>*<st
    c="7045">。它们通常包括备份解决方案、可扩展性、</st> **<st c="7099">高可用性</st>** <st c="7116">(</st>**<st
    c="7118">HA</st>**<st c="7120">)，以及集中管理的服务。</st> <st c="7157">在规划云基础设施时，大多数情况下，我们会发现硬性事实和最佳猜测。</st>
    <st c="7257">硬性事实是指像需要多少个 CPU 或服务器，应该使用哪种数据库，是否是单节点还是高可用等信息。</st> <st c="7406">然而，你应该意识到，几乎每一个你选择的公共云提供商选项都会对成本产生一些</st>
    <st c="7513">影响。</st>
- en: <st c="7526">Big cost drivers</st> <st c="7543">that commonly appear include</st>
    <st c="7573">the following:</st>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7526">常见的大成本驱动因素包括</st> <st c="7543">以下几点：</st>
- en: '**<st c="7587">Load balancer</st>**<st c="7601">: They are</st> <st c="7612">required
    in almost every architecture, and the same goes for you.</st> <st c="7679">As
    explained earlier, we have possibilities to extend the app services from the Kubernetes
    namespace to the cloud and even control the network – a major</st> <st c="7832">cost
    trap.</st>'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="7587">负载均衡器</st>**<st c="7601">：几乎在每个架构中都需要它们，你也不例外。</st> <st c="7612">正如前面所解释的，我们有机会将应用服务从
    Kubernetes 命名空间扩展到云端，甚至控制网络——这是一个主要的</st> <st c="7832">成本陷阱。</st>'
- en: '**<st c="7842">API gateway</st>**<st c="7854">: The even</st> <st c="7866">more
    evil twin of the load balancer, applied as best practice, becomes very costly,
    especially for chatty systems and routing</st> <st c="7992">heavy communication.</st>'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="7842">API 网关</st>**<st c="7854">：负载均衡器的更为邪恶的双胞胎，作为最佳实践时，变得非常昂贵，特别是对于频繁通信的系统和路由</st>
    <st c="7992">密集型通信。</st>'
- en: '**<st c="8012">Data</st>**<st c="8017">: In rest or in transit, data</st> <st
    c="8047">quickly becomes the biggest cost block in a cloud bill.</st> <st c="8104">While
    everything can be scaled up and down, your data has to</st> <st c="8165">live
    somewhere.</st>'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="8012">数据</st>**<st c="8017">：无论是静态还是在传输过程中，数据</st> <st c="8047">迅速成为云账单中最大的成本块。</st>
    <st c="8104">虽然一切都可以扩展，但你的数据必须</st> <st c="8165">存放在某个地方。</st>'
- en: '**<st c="8180">Backups and snapshots</st>**<st c="8202">: They are</st> <st
    c="8214">very much needed for a mature platform; you are required to have a very</st>
    <st c="8285">good backup strategy that is lean</st> <st c="8320">but reliable.</st>'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="8180">备份和快照</st>**<st c="8202">：它们对于一个成熟的平台非常必要；你需要有一个非常</st> <st
    c="8214">好的备份策略，既精简</st> <st c="8285">又可靠。</st>'
- en: '**<st c="8333">Scalable</st>** **<st c="8342">managed services</st>**<st c="8359">:
    If you’re</st> <st c="8371">using serverless, message streaming, or pre-trained
    AI models—anything that can scale infinitely—it’s crucial to set limits to avoid
    incurring</st> <st c="8515">unexpected costs.</st>'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="8333">可扩展的</st>** **<st c="8342">托管服务</st>**<st c="8359">：如果你在使用无服务器架构、消息流或预训练的
    AI 模型——任何可以无限扩展的东西——设定限制至关重要，以避免产生</st> <st c="8515">意外成本。</st>'
- en: <st c="8532">Ideal cloud projects—and we have to emphasize here that we are
    talking about things with a deadline—are strictly opinionated, following the best
    practices of the cloud provider.</st> <st c="8711">Almost every cloud project
    is not ideal, causing friction in the migration by custom implementations that
    are needed to somehow make the old world and the cloud provider able to work with
    each other.</st> <st c="8911">These hidden costs accrue through missing skills,
    because where should the required skills suddenly come from?</st> <st c="9022">Getting
    help from external skill providers would mean they have to understand you first
    before they can actually help you.</st> <st c="9145">However, most cloud projects
    would be called dead way earlier without</st> <st c="9215">external support.</st>
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8532">理想的云项目——我们必须强调的是，我们在谈论的是有截止日期的事情——是非常有明确意见的，遵循云服务提供商的最佳实践。</st>
    <st c="8711">几乎每个云项目都不理想，因定制实现的需要而导致迁移过程中的摩擦，这些实现必须以某种方式使旧世界和云服务提供商能够互相协作。</st>
    <st c="8911">这些隐性成本通过技能的缺失而积累，因为所需的技能到底从哪里来呢？</st> <st c="9022">从外部技能提供商那里获得帮助意味着他们必须先了解你，才能真正帮助你。</st>
    <st c="9145">然而，若没有</st> <st c="9215">外部支持，大多数云项目会在更早的阶段就被认为是失败的。</st>
- en: <st c="9232">In short, we can say that most services can turn against you cost-wise.</st>
    <st c="9305">As platform engineers, we have to be able to control these elements
    and create guardrails and limitations.</st> <st c="9412">To enable this, we need
    transparency</st> <st c="9448">about costs.</st>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9232">简而言之，我们可以说大多数服务在成本方面可能会反过来对你不利。</st> <st c="9305">作为平台工程师，我们必须能够控制这些元素，建立保护措施和限制。</st>
    <st c="9412">为了实现这一点，我们需要透明度</st> <st c="9448">关于成本。</st>
- en: <st c="9461">Where to find transparency</st>
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="9461">在哪里可以找到透明度</st>
- en: <st c="9488">Meanwhile, we have a zoo of possibilities for retrieving information
    about where we spend money and whether this is considered a waste based on metrics
    such as utilization.</st> <st c="9662">All cloud providers offer the possibility
    of exploring (and exploding) costs, but due to the focus on the infrastructure,
    details are missing, especially on the application layer.</st> <st c="9842">Looking
    at the following</st> <st c="9867">screenshot from AWS Cost Explorer, we get a
    consumption graph of different service types.</st> <st c="9957">We now would need
    to apply filters to gain more insights and analyze the roots of</st> <st c="10039">the
    costs:</st>
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9488">与此同时，我们有很多选择可以获取关于我们花费在哪些地方的信息，以及这些开销是否基于利用率等指标被认为是浪费。</st> <st
    c="9662">所有云服务提供商都提供了探索（甚至细分）成本的可能性，但由于重点关注基础设施，尤其是在应用层上，细节往往缺失。</st> <st c="9842">从以下</st>
    <st c="9867">AWS 成本浏览器的截图来看，我们得到的是不同服务类型的消费图表。</st> <st c="9957">现在我们需要应用过滤器来获得更多见解，并分析这些成本的根源：</st>
- en: '![Figure 8.1: AWS Cost Explorer](img/B31164_08_01.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1：AWS 成本浏览器](img/B31164_08_01.jpg)'
- en: '<st c="10896">Figure 8.1: AWS Cost Explorer</st>'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10896">图 8.1：AWS 成本浏览器</st>
- en: <st c="10925">Commercial solutions such as Apptio Cloudability</st> <st c="10974">can
    gather costs from many different accounts, cloud providers, and environments in
    a single tool.</st> <st c="11074">They apply FinOps logic on top of the given
    data and come with predefined dashboards such as the unit costs and savings dashboard
    from the</st> <st c="11213">following screenshot:</st>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10925">像 Apptio Cloudability 这样的商业解决方案</st> <st c="10974">可以从多个不同账户、云服务提供商和环境中收集成本信息，集中在一个工具中。</st>
    <st c="11074">它们在给定的数据上应用 FinOps 逻辑，并提供预定义的仪表板，比如以下截图中的单位成本和节省仪表板：</st>
- en: '![Figure 8.2: Apptio Cloudability detailed dashboard on unit costs](img/B31164_08_02.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2：Apptio Cloudability 详细的单位成本仪表板](img/B31164_08_02.jpg)'
- en: '<st c="12363">Figure 8.2: Apptio Cloudability detailed dashboard on unit costs</st>'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12363">图 8.2：Apptio Cloudability 关于单位成本的详细仪表盘</st>
- en: '<st c="12427">Microsoft defines</st> <st c="12445">unit costs as follows: “</st>*<st
    c="12470">Measuring unit costs refers to the process of calculating the cost of
    a single unit of a business that can show the business value of the cloud.</st>*<st
    c="12615">” What a unit is exactly is up to you.</st> <st c="12655">It can be
    transactions in financial systems, users for a media platform, or anything else
    you can map different parts of the</st> <st c="12780">infrastructure to.</st>'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12427">微软定义</st> <st c="12445">单位成本如下：“</st>*<st c="12470">衡量单位成本是指计算一个业务单元成本的过程，该业务单元能够展示云计算的业务价值。</st>*<st
    c="12615">” 单位的具体定义由你决定。</st> <st c="12655">它可以是金融系统中的交易、媒体平台的用户，或你能将不同部分的</st>
    <st c="12780">基础设施映射到的任何其他内容。</st>
- en: <st c="12798">Now, in our platform and open source world, we can also find solutions
    to gain more transparency, such as Kubecost (with commercial plans) and OpenCost.</st>
    <st c="12952">Both can allocate costs within a cluster and in combination with
    cloud provider resources.</st> <st c="13043">Unfortunately, both lack good analytics
    capabilities.</st> <st c="13097">That’s why we often see self-implemented solutions
    in combination</st> <st c="13163">with</st> **<st c="13168">business intelligence</st>**
    <st c="13189">(</st>**<st c="13191">BI</st>**<st c="13193">) tools, or Prometheus
    and Grafana implementations enriched with some cost data.</st> <st c="13275">How
    good those solutions are depends on the time and</st> <st c="13328">m</st><st
    c="13329">oney invested.</st>
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12798">现在，在我们的平台和开源世界中，我们也可以找到一些解决方案来获得更多的透明度，例如 Kubecost（带有商业计划）和 OpenCost。</st>
    <st c="12952">两者都可以在集群内分配成本，并与云服务提供商资源结合使用。</st> <st c="13043">不幸的是，两者都缺乏良好的分析能力。</st>
    <st c="13097">因此，我们常常看到自实施的解决方案与</st> <st c="13163">商业智能</st> **<st c="13168">（BI）</st>**
    <st c="13189">工具，或 Prometheus 和 Grafana 实现结合，加入一些成本数据。</st> <st c="13275">这些解决方案的效果取决于所投入的时间和</st>
    <st c="13328">资金。</st>
- en: <st c="13343">FinOps and cost management</st>
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="13343">FinOps 和成本管理</st>
- en: <st c="13370">In recent years, FinOps has gained some</st> <st c="13411">popularity
    and is trying to differentiate itself from classic cost management.</st> <st c="13490">Cost
    management is often outlined as a short-term, siloed, single-purpose activity
    that should yield fast cost savings.</st> <st c="13610">When you, as a platform
    team, act cost-aware and actively manage your costs, this will also be a sustainable
    and long-lasting solution.</st> <st c="13746">But where FinOps succeeds is in
    its holistic approach, which includes procurement departments,</st> **<st c="13841">business
    units</st>** <st c="13855">(</st>**<st c="13857">BUs</st>**<st c="13860">), and</st>
    <st c="13868">finance departments, clearly targeting implementing an organizational
    understanding of cloud costs and</st> <st c="13971">their dynamics.</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13370">近年来，FinOps 获得了一些</st> <st c="13411">人气，并试图将自己与传统的成本管理区分开。</st>
    <st c="13490">成本管理通常被描述为一种短期的、孤立的、单一目的的活动，旨在迅速实现成本节省。</st> <st c="13610">当你作为平台团队，具备成本意识并积极管理你的成本时，这也将是一个可持续且持久的解决方案。</st>
    <st c="13746">但 FinOps 成功之处在于它的整体方法，包括采购部门、</st> **<st c="13841">业务部门</st>** <st
    c="13855">（</st>**<st c="13857">BUs</st>**<st c="13860">），以及</st> <st c="13868">财务部门，明确目标是实施对云成本及其动态的组织理解。</st>
    <st c="13971">。</st>
- en: <st c="13986">The following</st> <st c="14001">overview of the FinOps Framework
    shows that it follows a similar approach to what a platform engineering team is
    up to.</st> <st c="14121">We can see principles that need to be aligned with your
    principles; capabilities to be integrated and enabled, which will require your
    input; and personas—roles such as the platform engineer with whom they</st> <st
    c="14327">collaborate</st> *<st c="14339">[2]</st>*<st c="14342">:</st>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13986">以下</st> <st c="14001">FinOps 框架概述表明，它采取了与平台工程团队相似的方法。</st> <st
    c="14121">我们可以看到需要与你的原则对齐的原则；需要集成和启用的能力，这将需要你的输入；以及角色——如平台工程师，他们</st> <st c="14327">合作</st>
    *<st c="14339">[2]</st>*<st c="14342">：</st>
- en: '![Figure 8.3: FinOps Framework by the FinOps Foundation](img/B31164_08_03.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3：由 FinOps 基金会提供的 FinOps 框架](img/B31164_08_03.jpg)'
- en: '<st c="15554">Figure 8.3: FinOps Framework by the FinOps Foundation</st>'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15554">图 8.3：由 FinOps 基金会提供的 FinOps 框架</st>
- en: <st c="15607">As a platform team, you should collaborate with FinOps teams and
    actively manage their influence on your platform.</st> <st c="15723">Potential
    cost savings must be balanced against your principles, user satisfaction, and
    developer experience.</st> <st c="15833">Data-based recommendations require an
    architectural qualification and considering alternative options and proposals
    to realize</st> <st c="15960">cost savings.</st>
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15607">作为平台团队，您应该与 FinOps 团队合作，并积极管理他们对您平台的影响。</st> <st c="15723">潜在的成本节省必须与您的原则、用户满意度和开发者体验相平衡。</st>
    <st c="15833">基于数据的建议需要具备架构资格，并考虑替代方案和建议以实现</st> <st c="15960">成本节省。</st>
- en: <st c="15973">In the following section, we will discuss how to implement a tagging
    strategy.</st> <st c="16053">Tags are a simple solution for providing additional
    information to cloud and Kubernetes resources and creating some sort of transparency.</st>
    <st c="16191">Also, many cost management and FinOps tools require tags to deliver</st>
    <st c="16258">better insights.</st>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15973">在接下来的部分，我们将讨论如何实施标签策略。</st> <st c="16053">标签是为云和 Kubernetes 资源提供附加信息的一种简单解决方案，并且能创建某种程度的透明度。</st>
    <st c="16191">此外，许多成本管理和 FinOps 工具需要标签才能提供</st> <st c="16258">更好的洞察。</st>
- en: <st c="16275">Implementing a tagging strategy to uncover hidden costs</st>
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="16275">实施标签策略以揭示隐藏的成本</st>
- en: <st c="16331">Tags</st> <st c="16336">and labels</st> <st c="16347">will most
    likely be nothing new to you as they are used in a wide range of tools, public
    cloud, and Kubernetes.</st> <st c="16460">We will use the word</st> *<st c="16481">tag</st>*
    <st c="16484">also to represent labels, but when using the word</st> *<st c="16535">labels</st>*<st
    c="16541">, we actually exclusively write about</st> <st c="16579">Kubernetes
    labels.</st>
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16331">标签</st> <st c="16336">和标签</st> <st c="16347">对您来说可能并不陌生，因为它们在各种工具、公有云和
    Kubernetes 中都有应用。</st> <st c="16460">我们将使用*标签*这个词来表示标签，但当使用*标签*这个词时，我们实际上是专门指
    Kubernetes 标签。</st>
- en: <st c="16597">Applying and using tags can become an art in itself.</st> <st
    c="16651">If there are too many tags, it can become unclear what information they
    should attach to the service.</st> <st c="16753">Also, having no tags is obviously
    not helpful.</st> <st c="16800">In organizations with many different BUs and departments
    involved and complex release mechanisms, tags can become overloaded or just a
    collection of abbreviations.</st> <st c="16964">The point is that we need tags
    to gain transparency on services to whom they belong, maybe indicating different
    service levels or security classes and becoming in the end an anchor to match
    those services to cost structures and resource utilizations.</st> <st c="17215">So,
    tags allow a more precise analysis of cost-related resources</st> <st c="17280">and
    the</st> <st c="17288">cost cause.</st>
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16597">应用和使用标签本身可以变成一门艺术。</st> <st c="16651">如果标签过多，可能会让它们应附加到服务的哪些信息变得不清楚。</st>
    <st c="16753">当然，没有标签显然是没有帮助的。</st> <st c="16800">在涉及多个不同业务单元和部门以及复杂发布机制的组织中，标签可能会被过载，或者只是一些缩写的集合。</st>
    <st c="16964">关键是，我们需要标签来获得服务的透明度，明确它们属于谁，可能还会指示不同的服务级别或安全等级，最终成为将这些服务与成本结构和资源使用情况匹配的锚点。</st>
    <st c="17215">因此，标签允许更精确地分析与成本相关的资源</st> <st c="17280">和</st> <st c="17288">成本原因。</st>
- en: <st c="17299">Using tags for a purpose</st>
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="17299">使用标签的目的</st>
- en: <st c="17324">Tags</st> <st c="17329">can target different target groups and
    users.</st> <st c="17376">Depending on which subdomain you are asking about, they
    should include organizational, operational, security, or even architectural information.</st>
    <st c="17521">We can also think about potentially helpful tags for us as</st>
    <st c="17580">platform engineers.</st>
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17324">标签</st> <st c="17329">可以针对不同的目标群体和用户。</st> <st c="17376">根据您询问的是哪个子域，它们应该包含组织、操作、安全甚至架构信息。</st>
    <st c="17521">我们还可以考虑一些对我们作为</st> <st c="17580">平台工程师</st> <st c="17580">可能有帮助的标签。</st>
- en: <st c="17599">Tags for organizational information can define which department,
    role, or team is responsible for the service, whether it is an internal- or external-facing
    solution, and whether there are any country, compliance, or</st> <st c="17817">governance
    restrictions.</st>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17599">组织信息的标签可以定义哪个部门、角色或团队负责该服务，是否是面向内部或外部的解决方案，以及是否存在任何国家、合规或</st>
    <st c="17817">治理限制。</st>
- en: <st c="17841">Looking into the operational space, common attributes are service
    level, scheduling times, and maintenance windows but also very technical information
    that might be introduced by third-party tools; for example, via Cloud Custodian
    that implements certain cloud</st> <st c="18103">policies</st> *<st c="18112">[3]</st>*<st
    c="18115">.</st>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17841">在操作层面，常见的属性包括服务级别、调度时间和维护窗口，但也有一些可能由第三方工具引入的非常技术性的资讯；例如，通过实现特定云</st>
    <st c="18103">策略</st> *<st c="18112">[3]</st>*<st c="18115">。</st>
- en: <st c="18116">For domain-specific areas such as security or a platform team,
    we can think of tags and labels as defining a required isolation or data protection,
    or else like a typical scaling pattern, top and bottom spikes, or identification
    for a microservice architecture and its belonging to certain components and</st>
    <st c="18422">a structure.</st>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18116">对于特定领域，如安全或平台团队，我们可以将标签和标签看作定义所需的隔离或数据保护，或者类似于典型的扩展模式、上下峰值，或识别微服务架构及其归属于某些组件和</st>
    <st c="18422">结构。</st>
- en: <st c="18434">Our focus will be on relevant cost</st> <st c="18470">tags.</st>
    <st c="18476">Those are often similar to organizational tags or related to the
    previously mentioned operational or domain-specific tags.</st> <st c="18599">Clarifying
    organizational belonging or providing insight into why something scales so drastically
    are key enablers for cost management.</st> <st c="18735">These tags help provide
    a clear view for projects and teams that have to raise</st> <st c="18814">cost
    awareness.</st>
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18434">我们的重点将放在相关的成本</st> <st c="18470">标签上。</st> <st c="18476">这些标签通常与组织标签相似，或与前面提到的操作性或领域特定的标签相关。</st>
    <st c="18599">明确组织归属或提供有关某事为何如此剧烈扩展的见解是成本管理的关键推动因素。</st> <st c="18735">这些标签有助于为需要提升</st>
    <st c="18814">成本意识的项目和团队提供清晰的视图。</st>
- en: <st c="18829">Some sources also point out the use of tags for access management.</st>
    <st c="18897">This should be handled with care for several reasons.</st> <st c="18951">If
    you have</st> **<st c="18963">attribute-based access control</st>** <st c="18993">(</st>**<st
    c="18995">ABAC</st>**<st c="18999">) and rights</st> <st c="19012">management,
    tags can be a viable and simple approach to achieve that.</st> <st c="19083">This
    comes with the downside that you turn a pure information source into a security-critical
    element that requires it to be protected and double-checked when used.</st> <st
    c="19248">Mixing this with its information character might complicate the usage
    of tags and most likely will be a blocker for proper usage.</st> <st c="19378">We
    said before that tags can be used to carry security information.</st> <st c="19446">However,
    there is a difference between providing information such as risk classifications
    or security levels and an</st> <st c="19562">access-granting capability.</st>
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18829">一些来源还指出，使用标签进行访问管理。</st> <st c="18897">出于多种原因，这需要谨慎处理。</st> <st
    c="18951">如果你有</st> **<st c="18963">基于属性的访问控制</st>** <st c="18993">(</st>**<st
    c="18995">ABAC</st>**<st c="18999">) 和权限</st> <st c="19012">管理，标签可以成为实现这一目标的可行且简单的方式。</st>
    <st c="19083">但这也带来了一个缺点，即你将一个纯粹的信息源变成了一个安全关键元素，需要在使用时进行保护和双重检查。</st> <st c="19248">将其与信息特性混合使用可能会使标签的使用变得复杂，并且很可能会成为正确使用的障碍。</st>
    <st c="19378">我们之前说过，标签可以用来传递安全信息。</st> <st c="19446">然而，在提供诸如风险分类或安全级别等信息与提供</st>
    <st c="19562">访问授权能力</st> <st c="17841">方面，存在差异。</st>
- en: <st c="19589">Therefore, it is important to, as with our platform, define the
    purpose of why we want to do tagging.</st> <st c="19692">To randomly use and set
    tags as much as you can imagine can be better than nothing but can become problematic
    in the future when it is unclear if the tag i</st><st c="19847">s now critical</st>
    <st c="19863">or not.</st>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19589">因此，像我们的平台一样，定义标签的目的至关重要。</st> <st c="19692">随意地使用并设置标签虽然总比什么都不做好，但当标签是否重要变得不清晰时，未来可能会引发问题。</st>
- en: <st c="19870">Tag and label limitations</st>
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="19870">标签和标签限制</st>
- en: <st c="19896">Unfortunately, we have two</st> <st c="19924">widely</st> <st
    c="19931">appearing issues:</st>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19896">不幸的是，我们遇到了两个</st> <st c="19924">普遍存在</st> <st c="19931">的问题：</st>
- en: <st c="19948">Tags don’t have a standard, which means there are many variations
    of their length, number of</st> <st c="20042">tags, allowed characters, or</st>
    <st c="20071">case sensitivity</st>
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="19948">标签没有标准，这意味着它们的长度、标签数量、允许的字符或</st> <st c="20042">大小写敏感性</st> <st
    c="20071">等存在很多变体。</st>
- en: <st c="20087">Organizations tend to have multiple environments across many different
    providers</st> <st c="20169">and platforms</st>
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="20087">组织往往在许多不同的提供商</st> <st c="20169">和平台上拥有多个环境</st>
- en: <st c="20182">So, to define a tagging strategy in the next steps, you have to
    know the smallest number you can reliably build on.</st> <st c="20299">A tagging
    strategy will introduce a standard, which has to be applicable on any platform.</st>
    <st c="20389">Defining multiple different approaches per platform will lead to
    confusion</st> <st c="20464">and errors.</st>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20182">所以，在接下来的步骤中，定义标记策略时，你必须了解你可以可靠构建的最小数量。</st> <st c="20299">标记策略将引入一个标准，必须适用于任何平台。</st>
    <st c="20389">为每个平台定义多种不同的方法将导致混淆</st> <st c="20464">和错误。</st>
- en: <st c="20475">As an example, we will</st> <st c="20499">compare different providers</st>
    <st c="20527">and platforms:</st>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20475">举个例子，我们将</st> <st c="20499">比较不同的提供商</st> <st c="20527">和平台：</st>
- en: '|  | **<st c="20541">AWS</st>** | **<st c="20545">GCP</st>** | **<st c="20549">Kubernetes</st>**
    | **<st c="20560">Azure</st>** |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '|  | **<st c="20541">AWS</st>** | **<st c="20545">GCP</st>** | **<st c="20549">Kubernetes</st>**
    | **<st c="20560">Azure</st>** |'
- en: '| **<st c="20566">Maximum number of tags</st>** **<st c="20590">per service</st>**
    | <st c="20601">50</st> | <st c="20604">64</st> | <st c="20607">No</st> <st c="20611">limit
    specified</st> | <st c="20626">50</st> |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| **<st c="20566">每服务的最大标签数量</st>** **<st c="20590">限制</st>** | <st c="20601">50</st>
    | <st c="20604">64</st> | <st c="20607">没有</st> <st c="20611">指定限制</st> | <st
    c="20626">50</st> |'
- en: '| **<st c="20629">Max.</st> <st c="20635">characters tag</st>** **<st c="20650">name
    length</st>** | <st c="20661">128</st> | <st c="20665">63</st> | <st c="20668">63</st>
    | <st c="20671">512</st> |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| **<st c="20629">最大</st> <st c="20635">字符标签</st>** **<st c="20650">名称长度</st>**
    | <st c="20661">128</st> | <st c="20665">63</st> | <st c="20668">63</st> | <st
    c="20671">512</st> |'
- en: '| **<st c="20675">Max.</st> <st c="20681">characters tag</st>** **<st c="20696">value
    length</st>** | <st c="20708">256</st> | <st c="20712">63</st> | <st c="20715">63</st>
    | <st c="20718">256</st> |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| **<st c="20675">最大</st> <st c="20681">字符标签</st>** **<st c="20696">值长度</st>**
    | <st c="20708">256</st> | <st c="20712">63</st> | <st c="20715">63</st> | <st
    c="20718">256</st> |'
- en: '| **<st c="20722">Special characters</st>** | <st c="20741">alphanumeric characters,
    blanks and + - = .</st> <st c="20786">_ : / @</st> | <st c="20793">alphanumeric
    characters, -</st> <st c="20821">and _</st> | <st c="20826">alphanumeric characters,
    - .</st> <st c="20856">_</st> | <st c="20857">alphanumeric characters, <, >, %,
    &, \, ?, /</st> <st c="20902">not allowed</st> |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| **<st c="20722">特殊字符</st>** | <st c="20741">字母数字字符、空格以及 + - = .</st> <st
    c="20786">_ : / @</st> | <st c="20793">字母数字字符、-</st> <st c="20821">和 _</st> |
    <st c="20826">字母数字字符、- .</st> <st c="20856">_</st> | <st c="20857">字母数字字符、<, >,
    %, &, \, ?, /</st> <st c="20902">不允许</st> |'
- en: '| **<st c="20913">Case sensitive</st>** | <st c="20928">Yes</st> | <st c="20932">Yes</st>
    | <st c="20936">Yes</st> | <st c="20940">Yes</st> |  |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| **<st c="20913">区分大小写</st>** | <st c="20928">是</st> | <st c="20932">是</st>
    | <st c="20936">是</st> | <st c="20940">是</st> |  |'
- en: '<st c="20944">Table 8.1: Tag limitations of cloud providers and Kubernetes</st>'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20944">表8.1：云提供商和Kubernetes的标签限制</st>
- en: <st c="21005">While 63 characters</st> <st c="21026">as a common direction looks
    good, we have seen in the field that for many organizations, even 256 characters
    weren’t enough.</st> <st c="21151">This is just another example of why a tagging
    strategy must be</st> <st c="21214">thought through.</st>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21005">虽然63个字符</st> <st c="21026">作为一个常见的方向看起来很好，但我们在实际应用中发现，对于许多组织来说，甚至256个字符也不足够。</st>
    <st c="21151">这只是另一个例子，说明为什么标记策略必须经过</st> <st c="21214">深思熟虑。</st>
- en: <st c="21230">Also, some structures don’t work across the different providers.</st>
    <st c="21296">Assuming our Financial One ACME company utilizes AWS and GCP, including
    its managed Kubernetes service for the platform, why does Financial One ACME go
    to the limit of the maximum allowed number of tags?</st> <st c="21500">The AWS
    team discovered this issue first and found out it can use longer tags and some
    special characters that allow a sort of nested structure.</st> <st c="21645">So,
    they started to combine different tags into one with the</st> <st c="21706">following
    outcome:</st>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21230">此外，一些结构在不同的提供商之间无法通用。</st> <st c="21296">假设我们的Financial One ACME公司使用AWS和GCP，包括其托管的Kubernetes服务作为平台，为什么Financial
    One ACME会达到允许的最大标签数量限制呢？</st> <st c="21500">AWS团队首先发现了这个问题，并发现它可以使用更长的标签和一些特殊字符，从而允许某种嵌套结构。</st>
    <st c="21645">于是，他们开始将不同的标签合并成一个，得出了</st> <st c="21706">以下结果：</st>
- en: '`<st c="21724">department-responsible=financial-one-ACME/domain-sales+marketing/stream-customer-management/squad-frontend/operations-squad-lazy-turtle</st>`'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="21724">department-responsible=financial-one-ACME/domain-sales+marketing/stream-customer-management/squad-frontend/operations-squad-lazy-turtle</st>`'
- en: <st c="21860">The value has 112 characters and contains</st> `<st c="21903">/</st>`
    <st c="21904">to represent the hierarchical steps and</st> `<st c="21945">+</st>`
    <st c="21946">to represent</st> *<st c="21960">and</st>*<st c="21963">. The team
    is happy with the result and pushes this new tag to the shared repository.</st>
    <st c="22049">Sometime</st> <st c="22058">later, the platform team receives complaints
    that in the sales and marketing IT department, there is a problem with the</st>
    <st c="22177">deployments, and the newest releases aren’t getting rolled out due
    to</st> <st c="22248">some labels.</st>
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21860">该值有112个字符，包含了</st> `<st c="21903">/</st>` <st c="21904">来表示层次步骤和</st>
    `<st c="21945">+</st>` <st c="21946">来表示</st> *<st c="21960">和</st>*<st c="21963">。团队对结果感到满意，并将这个新标签推送到共享存储库。</st>
    <st c="22049">一段时间</st> <st c="22058">后，平台团队收到投诉，在销售和营销IT部门中，由于</st> <st c="22177">一些标签的问题，最新的发布没有得到推出。</st>
- en: <st c="22260">Besides that, you will find other limitations such as the maximum
    number of tags per account</st> <st c="22354">or subscription</st><st c="22369">.</st>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22260">此外，您会发现其他限制，如每个账户</st> <st c="22354">或订阅的最大标签数</st><st c="22369">。</st>
- en: <st c="22370">Defining a tagging strategy</st>
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="22370">定义标记策略</st>
- en: <st c="22398">As</st> <st c="22402">explained earlier, tags can have many different
    purposes; primarily, we have to balance between technical tags and business tags.</st>
    <st c="22532">Business tags can be categorized into organizational and cost tags.</st>
    <st c="22600">In the end, many tags tend to have overlapping information.</st>
    <st c="22660">Therefore, to find the right approach, it often makes sense to set
    some basic rules and boundaries for the definition.</st> <st c="22779">In the
    second step, you have to coordinate between operations, platform, and development
    to find the right set of needed tags from the technical side before moving on
    to set organizational tags.</st> <st c="22974">This direction makes sense because,
    often, required tags for operation also contain information about</st> <st c="23076">the
    organization.</st>
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22398">正如</st> <st c="22402">之前所解释的，标签可以具有许多不同的用途；主要是要在技术标签和业务标签之间保持平衡。</st>
    <st c="22532">业务标签可以分为组织标签和成本标签。</st> <st c="22600">最终，许多标签往往具有重叠的信息。</st> <st
    c="22660">因此，为了找到正确的方法，通常有必要为定义设定一些基本规则和边界。</st> <st c="22779">在第二步中，您必须在操作、平台和开发之间进行协调，从技术方面找到所需的标签集，然后再设置组织标签。</st>
    <st c="22974">这个方向是有道理的，因为通常运营所需的标签也包含了关于</st> <st c="23076">组织的信息。</st>
- en: <st c="23093">Let’s start with some common</st> <st c="23123">ground rules:</st>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23093">让我们从一些共同的</st> <st c="23123">基本规则开始：</st>
- en: <st c="23136">Tag names and values</st> *<st c="23158">must</st>* <st c="23162">be
    shorter than</st> <st c="23179">63 characters.</st>
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="23136">标签名称和值</st> *<st c="23158">必须</st>* <st c="23162">要短于</st> <st
    c="23179">63个字符。</st>
- en: <st c="23193">Tags can be</st> <st c="23206">only alphanumeric.</st>
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="23193">标签只能是</st> <st c="23206">字母数字组合。</st>
- en: <st c="23224">Tags can only have</st> `<st c="23244">-</st>` <st c="23245">and</st>
    `<st c="23249">_</st>`<st c="23250">.</st>
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="23224">标签只能包含</st> `<st c="23244">-</st>` <st c="23245">和</st> `<st c="23249">_</st>`<st
    c="23250">.</st>
- en: <st c="23251">Focus on tag value and its content as you usually filter and search</st>
    <st c="23320">for this.</st>
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="23251">请关注标签值及其内容，因为您通常会对此进行筛选和搜索。</st>
- en: <st c="23329">Tag names are more relevant for sorting</st> <st c="23370">and
    grouping.</st>
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="23329">标签名称对于排序</st> <st c="23370">和分组更为相关。</st>
- en: <st c="23383">Don’t write</st> **<st c="23396">personally identifiable information</st>**
    <st c="23431">(</st>**<st c="23433">PII</st>**<st c="23436">) into</st> <st c="23443">a
    tag.</st>
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="23383">不要将</st> **<st c="23396">个人可识别信息</st>** <st c="23431">（</st>**<st
    c="23433">PII</st>**<st c="23436">）写入</st> <st c="23443">标签中。</st>
- en: <st c="23450">Establish one case style.</st> <st c="23477">Businesses might
    prefer the Pascal style, while in tech, the kebab style is</st> <st c="23553">more
    common.</st>
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="23450">建立一个大小写样式。</st> <st c="23477">企业可能更喜欢帕斯卡样式，而在技术中，烤串样式更为常见。</st>
- en: <st c="23565">It is better to use more tags than less, but try to keep 10%-20%
    of available</st> <st c="23644">tags free.</st>
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="23565">使用更多的标签比使用更少的标签更好，但尽量保持10%至20%的可用</st> <st c="23644">标签。</st>
- en: <st c="23654">Based on those rules, we can create the next relevant elements.</st>
    <st c="23719">First, we need to think about tagging categories for these to become
    more fine-grained than those we have discussed so far.</st> <st c="23843">A good
    practice is to think of the</st> <st c="23878">following categories:</st>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23654">根据这些规则，我们可以创建下一个相关的元素。</st> <st c="23719">首先，我们需要考虑为这些元素打上标签，使其比我们之前讨论的更加细化。</st>
    <st c="23843">一个好的做法是考虑以下分类：</st> <st c="23878">以下分类：</st>
- en: <st c="23899">Ownership—departments, teams,</st> <st c="23930">organizations,
    streams.</st>
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="23899">所有权——部门、团队、</st> <st c="23930">组织、流。</st>
- en: <st c="23953">Environment—whatever your staging</st> <st c="23988">environments
    are.</st>
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="23953">环境——无论你们的预发布</st> <st c="23988">环境是什么。</st>
- en: <st c="24005">Project or product—project or product cluster to identify which
    components</st> <st c="24081">belong together.</st>
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="24005">项目或产品——项目或产品集群，用于识别哪些组件</st> <st c="24081">属于同一组。</st>
- en: <st c="24097">Cost center—who is</st> <st c="24116">accountable for it?</st>
    <st c="24137">Are there any shared costs that come</st> <st c="24174">on top?</st>
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="24097">成本中心——谁是</st> <st c="24116">负责人？</st> <st c="24137">是否有任何共享成本需要</st>
    <st c="24174">额外考虑？</st>
- en: <st c="24181">Compliance—regulatory restrictions and requirements, policies,
    and</st> <st c="24249">compliance rules.</st>
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="24181">合规性——监管限制和要求、政策，及</st> <st c="24249">合规规则。</st>
- en: <st c="24266">Operational—life cycles, backups,</st> <st c="24301">maintenance
    windows.</st>
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="24266">操作——生命周期、备份、</st> <st c="24301">维护窗口。</st>
- en: <st c="24321">From here, we have to work on a naming convention.</st> <st c="24373">As
    mentioned earlier, it’s important not to overload a single tag.</st> <st c="24440">Respecting
    the given rules and limitations and including the nature of many software and
    system components, a tag convention could look</st> <st c="24576">like this:</st>
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24321">从这里开始，我们必须制定命名约定。</st> <st c="24373">如前所述，重要的是不要过度加载单个标签。</st>
    <st c="24440">遵循给定的规则和限制，并结合许多软件和系统组件的特性，标签约定可能如下：</st> <st c="24576">如下所示：</st>
- en: '`<st c="24586">department=public-relations-content-management</st>`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="24586">department=public-relations-content-management</st>`'
- en: '`<st c="24633">owner=department-public-relations</st>`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="24633">owner=department-public-relations</st>`'
- en: '`<st c="24667">data-classification=personal-identifiable-information</st>`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="24667">data-classification=personal-identifiable-information</st>`'
- en: <st c="24721">In some languages, it is preferred to follow a Pascal (</st>`<st
    c="24777">Hello-My-Name-Is-Pascal</st>`<st c="24801">) or camel style (</st>`<st
    c="24820">i-Am-A-Camel</st>`<st c="24833">).</st> <st c="24837">The style of writing
    everything in small letters is called the kebab style.</st> <st c="24913">You
    will have to define those patterns in a very clear way.</st> <st c="24973">How
    many characters should the name have and how many words?</st> <st c="25034">Is
    it more descriptive or just matching what’s been identified?</st> <st c="25098">The
    same counts for the value.</st> <st c="25129">Ensure that those conventions are
    documented, communicated, and included in the onboarding or training for</st>
    <st c="25236">your engineers.</st>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24721">在一些语言中，推荐使用 Pascal（</st>`<st c="24777">Hello-My-Name-Is-Pascal</st>`<st
    c="24801">）或驼峰命名法（</st>`<st c="24820">i-Am-A-Camel</st>`<st c="24833">）。</st>
    <st c="24837">将所有字母都写成小写的风格称为 kebab 风格。</st> <st c="24913">你需要非常明确地定义这些命名模式。</st>
    <st c="24973">名字应该有多少个字符？包含多少个单词？</st> <st c="25034">是更具描述性，还是仅仅匹配已经确定的内容？</st>
    <st c="25098">同样也适用于值。</st> <st c="25129">确保这些约定已被文档化、沟通，并且在工程师的入职或培训中被包括。</st>
- en: <st c="25251">Now, the last step is to start building up a</st> *<st c="25297">tag
    catalog with these ground rules</st>*<st c="25332">. It is recommended to create
    those catalogs so that you have a space to describe the meaning, purpose, and
    addressed group of the tag.</st> <st c="25468">This also helps you to keep tags
    short, as you will not need to add more description to the tags’ value.</st> <st
    c="25573">The following table is a simple example of a tag catalog.</st> <st c="25631">It
    can be extended by the unique demands of the organization.</st> <st c="25693">It
    is important to offload into the catalog any information that you</st> <st c="25762">might
    also need to include in the tag but that makes it artificially long</st> <st c="25836">and
    unreadable:</st>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25251">现在，最后一步是开始建立一个</st> *<st c="25297">带有这些基本规则的标签目录</st>*<st c="25332">。建议创建这些目录，以便你有空间描述标签的含义、目的以及面向的群体。</st>
    <st c="25468">这还可以帮助你保持标签简短，因为你不需要再为标签的值添加更多描述。</st> <st c="25573">下表是一个简单的标签目录示例。</st>
    <st c="25631">它可以根据组织的独特需求进行扩展。</st> <st c="25693">重要的是将任何你可能需要包含在标签中的信息转移到目录中，以免使标签显得过长</st>
    <st c="25762">并且难以阅读：</st>
- en: '| <st c="25851">#</st> | <st c="25853">Tag Name</st> | <st c="25861">Expected
    Value</st> | <st c="25876">Meaning</st> | <st c="25884">Purpose</st> | <st c="25892">Tag
    Stakeholder</st> |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| <st c="25851">#</st> | <st c="25853">标签名称</st> | <st c="25861">预期值</st> |
    <st c="25876">含义</st> | <st c="25884">目的</st> | <st c="25892">标签利益相关者</st> |'
- en: '| <st c="25908">1</st> | `<st c="25910">department</st>` | <st c="25920">Department
    handle or code; for</st> <st c="25952">example,</st> `<st c="25961">DE-22-P</st>`
    | <st c="25968">BU or the area the app</st> <st c="25992">belongs to</st> | <st
    c="26002">Clarify the owner of</st> <st c="26024">the application</st> | <st c="26039">Application</st>
    <st c="26052">owner; operations</st> |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| <st c="25908">1</st> | `<st c="25910">部门</st>` | <st c="25920">部门处理或代码；例如，</st>
    `<st c="25961">DE-22-P</st>` | <st c="25968">应用程序所属的BU或区域</st> | <st c="26002">明确应用程序的所有者</st>
    | <st c="26024">应用程序</st> | <st c="26039">所有者；运营</st> |'
- en: '| <st c="26069">2</st> | `<st c="26071">application</st>` | <st c="26082">Application
    name; for</st> <st c="26105">example,</st> `<st c="26114">internal-cms</st>` |
    <st c="26126">Name of</st> <st c="26135">the application</st> | <st c="26150">Identify</st>
    <st c="26160">the application</st> | <st c="26175">Application owner;</st> <st
    c="26195">operations; architect</st> |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| <st c="26069">2</st> | `<st c="26071">应用程序</st>` | <st c="26082">应用程序名称；例如，</st>
    `<st c="26114">internal-cms</st>` | <st c="26126">应用程序的名称</st> | <st c="26135">识别</st>
    <st c="26150">该应用程序</st> | <st c="26160">应用程序所有者；</st> <st c="26175">运营；架构师</st>
    |'
- en: '| <st c="26216">3</st> | `<st c="26218">maintenance-allowed</st>` | <st c="26237">Day
    and time when maintenance can be executed; for</st> <st c="26289">example,</st>
    `<st c="26298">sunday-0800-1230</st>` | <st c="26314">The tag identifies the day
    or days as well as a timeframe written as</st> `<st c="26384">0800</st>`<st c="26388">,
    which means</st> <st c="26402">08:00 a.m.</st> | <st c="26412">Defines when the
    application can be turned down to update/patch or release a</st> <st c="26490">new
    version</st> | <st c="26501">Operations;</st> <st c="26514">first-level support</st>
    |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| <st c="26216">3</st> | `<st c="26218">维护-允许</st>` | <st c="26237">可以执行维护的日期和时间；例如，</st>
    `<st c="26298">sunday-0800-1230</st>` | <st c="26314">该标签标识了日期或日期范围，以及以</st> `<st
    c="26384">0800</st>`<st c="26388">表示的时间段，意味着</st> <st c="26402">上午08:00</st> |
    <st c="26412">定义应用程序何时可以关闭以更新/修补或发布</st> <st c="26490">新版本</st> | <st c="26501">运营；</st>
    <st c="26514">一级支持</st> |'
- en: '<st c="26533">Table 8.2: Tag catalog example</st>'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26533">表8.2：标签目录示例</st>
- en: <st c="26564">Tagging automation</st>
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="26564">标签自动化</st>
- en: <st c="26583">It would be impossible</st> <st c="26607">to tag all resources
    manually, especially on an IDP with many moving components.</st> <st c="26688">Certain
    tools can help us tag resources automatically when they are created or even “patch”
    them afterward.</st> <st c="26796">As we have seen before, on the platform, we
    have to differentiate between the infrastructure the platform runs on and the
    user perspective of the workload they run on top or manage from</st> <st c="26982">the
    cluster.</st>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26583">这将是不可能的</st> <st c="26607">手动标记所有资源，尤其是在有许多活动组件的IDP上。</st> <st
    c="26688">某些工具可以帮助我们在资源创建时自动标记它们，甚至在事后“修补”它们。</st> <st c="26796">正如我们之前所见，在平台上，我们必须区分平台运行的基础设施和用户在其上运行或管理的工作负载</st>
    <st c="26982">集群。</st>
- en: <st c="26994">When you manage your infrastructure with tools such as Terraform/OpenTofu,
    you can tag components within your code</st> <st c="27110">as follows:</st>
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26994">当您使用 Terraform/OpenTofu 等工具管理基础设施时，您可以在代码中给组件打标签</st> <st c="27110">如下所示：</st>
- en: '[PRE0]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="27264">For a certain provider, you can even give the same tags to all
    resources.</st> <st c="27339">This should be handled with care as you don’t want
    to wrongly tag other resources, especially if those trigger third-party integrations
    or cause</st> <st c="27484">wrong billing:</st>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27264">对于某些提供商，您甚至可以给所有资源使用相同的标签。</st> <st c="27339">这需要小心处理，因为您不希望错误地标记其他资源，尤其是当这些资源触发第三方集成或导致</st>
    <st c="27484">错误计费时：</st>
- en: '[PRE1]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="27616">Practically all IaC solutions provide this approach and can be
    adapted to any kind of infrastructure, cloud</st> <st c="27725">or on-prem.</st>
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27616">几乎所有的基础设施即代码（IaC）解决方案都提供这种方法，并且可以适配任何类型的基础设施，无论是云端</st> <st c="27725">还是本地部署。</st>
- en: <st c="27736">This can be done for Kubernetes resources, too.</st> <st c="27785">We
    will skip regular deployment files here, as those will most likely be handled
    differently, as with Helm.</st> <st c="27893">The following example shows how
    Helm takes the value for the labels from the Helm chart value file.</st> <st c="27993">Template</st>
    <st c="28001">values are dynamically created by a</st> `<st c="28038">_helper.tpl</st>`
    <st c="28049">templating file, while</st>`<st c="28072">.Release</st>` <st c="28080">values
    are built-in information.</st> <st c="28114">Another option is to read the values
    from a</st> `<st c="28158">values.yaml</st>` <st c="28169">file, which is provided
    by</st> <st c="28197">the user:</st>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27736">这也可以应用于 Kubernetes 资源。</st> <st c="27785">我们在这里跳过常规部署文件，因为这些文件很可能会以不同的方式处理，例如使用
    Helm。</st> <st c="27893">以下示例展示了 Helm 如何从 Helm chart 值文件中获取标签的值。</st> <st c="27993">模板</st>
    <st c="28001">值由一个</st> `<st c="28038">_helper.tpl</st>` <st c="28049">模板文件动态创建，而</st>`<st
    c="28072">.Release</st>` <st c="28080">值则是内建信息。</st> <st c="28114">另一种选择是从用户提供的</st>
    `<st c="28158">values.yaml</st>` <st c="28169">文件中读取值：</st>
- en: '[PRE2]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="28433">One strength of Helm is that we can combine this with a simple</st>
    `<st c="28497">if</st>` <st c="28499">statement.</st> <st c="28511">Through that,
    we can hand over a predefined set of information depending on where the deployment
    is going to be or based on any</st> <st c="28639">other trigger.</st>
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28433">Helm 的一个优点是我们可以将其与简单的</st> `<st c="28497">if</st>` <st c="28499">语句结合使用。</st>
    <st c="28511">通过这种方式，我们可以根据部署的目标位置或任何</st> <st c="28639">其他触发条件传递预定义的信息。</st>
- en: <st c="28653">Note</st>
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28653">注意</st>
- en: <st c="28658">Utilize predefined labels in your Backstage templates to force
    your users to have some bare minimum of</st> <st c="28762">labels defined.</st>
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28658">在您的 Backstage 模板中使用预定义的标签，强制用户至少定义一些基本的</st> <st c="28762">标签。</st>
- en: <st c="28777">Both</st> <st c="28782">approaches are heavily declarative and
    can fail in their adoption or being overseen.</st> <st c="28868">For sure, you
    can check the correct usage of labels in the CI/CD pipelines, but this might result
    in many deployments failing.</st> <st c="28995">This leads us to policy engines.</st>
    <st c="29028">On the one side, those can be used to test the deployments for labels,
    but a tool such as Kyverno</st> <st c="29125">can also add this information when
    needed.</st> <st c="29169">The following example of a Kyverno policy adds</st>
    `<st c="29216">foo=bar</st>` <st c="29223">labels to any Pod</st> <st c="29242">or
    service:</st>
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28777">这两种方法都是高度声明式的，并且可能会因为实施或被忽视而失败。</st> <st c="28868">当然，您可以在 CI/CD
    管道中检查标签的正确使用，但这可能导致许多部署失败。</st> <st c="28995">这引出了策略引擎。</st> <st c="29028">一方面，策略引擎可以用于测试部署中的标签，但像
    Kyverno 这样的工具</st> <st c="29125">也可以在需要时添加这些信息。</st> <st c="29169">以下是一个 Kyverno
    策略示例，它为任何 Pod</st> `<st c="29216">foo=bar</st>` <st c="29223">添加标签</st> <st c="29242">或服务：</st>
- en: '[PRE3]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="29550">We can select and patch that information in a very fine-grained
    way, and it can be updated anytime later</st> <st c="29656">if neede</st><st c="29664">d.</st>
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29550">我们可以以非常精细的方式选择并修补这些信息，并且在以后需要时可以随时更新。</st> <st c="29656">如果需要</st><st
    c="29664">。</st>
- en: <st c="29667">Consolidated versus separated cost and billing reports</st>
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="29667">合并与分开的成本和计费报告</st>
- en: <st c="29722">Within many</st> <st c="29735">organizations, we see the demand
    for consolidated cost and billing reports.</st> <st c="29811">While that is, for
    the organization, on a higher level, the fastest way to understand the spending
    on infrastructure, it also requires many tags to ensure a proper split and level
    of detail.</st> <st c="30002">When organizations are growing too large, and the
    amount of business tags is larger than the technical tags, it is a clear sign
    that something went wrong.</st> <st c="30157">Being radical at this point, it
    then becomes an anti-pattern to do consolidated cost and billing reports.</st>
    <st c="30263">But what can we do, then?</st> <st c="30289">Enterprises, for example,
    often work with alphanumeric codes to identify departments.</st> <st c="30375">So,
    instead of a department being called</st> *<st c="30416">Finance and Accounting</st>*<st
    c="30438">, they may have something like</st> `<st c="30469">B-2-FA-4</st>`<st
    c="30477">. Such code is the perfect groundwork to eliminate many other organizational
    or business tags and place them into a matching table or database, in case you
    want to programmatically do this matching somewhere else.</st> <st c="30691">Other
    things to consider are, for example, the staging environments and the cluster.</st>
    <st c="30776">Most of the time, development, integration, and production systems
    are standalone.</st> <st c="30859">This means if your app is running on the</st>
    `<st c="30900">Manhattan</st>` <st c="30909">cluster, which could be translated
    to</st> `<st c="30948">prod-1234-eu</st>`<st c="30960">, then I don’t need another
    tag that says</st> `<st c="31002">stage=production</st>` <st c="31018">or</st>
    `<st c="31022">region=eu</st>`<st c="31031">. Just to be clear, you should limit
    yourself to not adding too much information into a</st> <st c="31119">single value.</st>
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29722">在许多</st> <st c="29735">组织中，我们看到有合并成本和账单报告的需求。</st> <st c="29811">虽然从组织的角度看，这是理解基础设施支出的最快方式，但它也需要许多标签来确保适当的拆分和细节级别。</st>
    <st c="30002">当组织规模过大，且业务标签数量大于技术标签时，这是一个明显的信号，表明某些事情出了问题。</st> <st c="30157">从激进的角度来看，此时做合并成本和账单报告就成了一种反模式。</st>
    <st c="30263">那么我们该怎么办呢？</st> <st c="30289">例如，企业通常使用字母数字编码来识别部门。</st> <st c="30375">因此，部门如果不是叫做</st>
    *<st c="30416">财务和会计</st>*<st c="30438">，可能会有类似</st> `<st c="30469">B-2-FA-4</st>`<st
    c="30477">的编码。这种编码是消除许多其他组织或业务标签并将其放入匹配表或数据库的完美基础，尤其是当你希望在其他地方进行编程匹配时。</st> <st
    c="30691">需要考虑的其他事项包括，例如，暂存环境和集群。</st> <st c="30776">大多数时候，开发、集成和生产系统是独立的。</st>
    <st c="30859">这意味着，如果你的应用运行在</st> `<st c="30900">曼哈顿</st>` <st c="30909">集群上，这可以被翻译为</st>
    `<st c="30948">prod-1234-eu</st>`<st c="30960">，那么我就不需要另一个标签来表示</st> `<st c="31002">stage=production</st>`
    <st c="31018">或</st> `<st c="31022">region=eu</st>`<st c="31031">。需要明确的是，你应该限制自己不要将过多信息添加到</st>
    <st c="31119">单一值中。</st>
- en: <st c="31132">However, there is a big</st> *<st c="31157">but</st>* <st c="31160">in
    this story that leads us to the beginning of the topic.</st> <st c="31220">From
    a cost management perspective, you need to have many good tags so that you are
    able to do your analytics</st> <st c="31330">and research.</st>
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31132">然而，故事中有一个很大的</st> *<st c="31157">但是</st>* <st c="31160">这让我们回到了话题的起点。</st>
    <st c="31220">从成本管理的角度来看，你需要拥有许多良好的标签，以便能够进行分析</st> <st c="31330">和研究。</st>
- en: <st c="31343">Tags themself are not enough; they are a relevant part of the
    cost optimization, but which optimizations do you take?</st> <st c="31462">In
    the next section, we will look into general approaches for optimization strategies
    that are not only rightsizing and</st> <st c="31582">reducing infrastruct</st><st
    c="31602">ure.</st>
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31343">仅有标签本身是不够的；它们是成本优化的一个重要部分，但你需要采取哪些优化措施呢？</st> <st c="31462">在接下来的部分，我们将探讨一些通用的优化策略，这些策略不仅包括调整规模和</st>
    <st c="31582">减少基础设施</st><st c="31602">。</st>
- en: <st c="31607">Looking at cost optimization strategies</st>
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="31607">查看成本优化策略</st>
- en: <st c="31647">The fastest approach to</st> <st c="31671">reduce cloud and platform
    costs is through shutting down what you don’t need.</st> <st c="31750">The biggest
    problem is that everyone involved in that process might have some reason why they
    require the infrastructure as it is.</st> <st c="31881">But I would like to turn
    your perspective on this topic from here onward:</st> *<st c="31955">Cost optimization
    is nothing that we should introduce afterward</st>*<st c="32018">. Here’s yet
    another principle you should consider:</st> *<st c="32070">Be cost-aware and effective,
    considering it in the design of</st>* *<st c="32131">the platform.</st>*
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31647">减少云和平台成本的最快方法是关闭那些你不需要的部分。</st> <st c="31671">最大的问题是，参与该过程的每个人可能都有一些理由，为什么他们需要现有的基础设施。</st>
    <st c="31750">但从现在开始，我想要转换你对这个话题的视角：</st> *<st c="31955">成本优化不是我们应该事后引入的东西</st>*<st
    c="32018">。以下是你应该考虑的另一个原则：</st> *<st c="32070">在平台设计时要具备成本意识和高效性</st>* *<st c="32131">。</st>*
- en: <st c="32144">Note</st>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32144">注意</st>
- en: <st c="32149">The more cost optimization potential can be found in a platform,
    the worse we have done in our job as platform engineers</st> <st c="32271">and
    architects.</st>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32149">平台中发现的成本优化潜力越大，说明我们作为平台工程师</st> <st c="32271">和架构师做得越差。</st>
- en: <st c="32286">We can leverage potential on any part of our platform.</st> <st
    c="32342">However, this could be a book in itself to cover all aspects of it.</st>
    <st c="32410">Therefore, we will cover principles that are applicable to any component
    within</st> <st c="32490">the plat</st><st c="32498">form.</st>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32286">我们可以在平台的任何部分发挥潜力。</st> <st c="32342">然而，这本身就可以写成一本书来覆盖所有相关方面。</st>
    <st c="32410">因此，我们将讨论适用于平台内任何组件的原则。</st>
- en: <st c="32504">Streamlining processes</st>
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="32504">精简流程</st>
- en: <st c="32527">Processes, business and technical, can</st> <st c="32566">cause
    higher costs.</st> <st c="32587">I will give you an example of a pattern/anti-pattern
    that leads to unnecessary costs.</st> <st c="32673">The Kubernetes release is
    divided into three major releases, and every few weeks in between, you will get
    patches, bug fixes, and security patches.</st> <st c="32821">The Kubernetes release
    team automated a huge part of the release process, having nightly builds and running</st>
    *<st c="32929">all the time</st>* <st c="32941">several thousand tests on the
    Kubernetes infrastructure.</st> <st c="32999">When this approach was introduced,
    the community took it as the holy grail of the top tech companies.</st> <st c="33101">Suddenly
    everyone wanted to have nightly builds of their containers, often skipping the
    test part, which would be too</st> <st c="33219">much effort.</st>
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32527">流程、业务和技术方面，都会</st> <st c="32566">导致更高的成本。</st> <st c="32587">我将给你举一个导致不必要成本的模式/反模式的例子。</st>
    <st c="32673">Kubernetes的发布分为三个主要版本，在其中的几周里，你会获得补丁、bug修复和安全补丁。</st> <st c="32821">Kubernetes发布团队自动化了发布过程中的大部分工作，包括夜间构建，并且持续不断地</st>
    *<st c="32929">进行所有的测试</st>* <st c="32941">在Kubernetes基础设施上运行几千个测试。</st> <st c="32999">当这种方法被引入时，社区将其视为顶级科技公司的圣杯。</st>
    <st c="33101">突然间，每个人都想要他们容器的夜间构建，常常跳过测试部分，认为测试过程</st> <st c="33219">太过繁琐。</st>
- en: <st c="33231">The downside of this approach is that most nightly builds never
    get deployed.</st> <st c="33310">It also prevents build servers from shutting
    down at night.</st> <st c="33370">The container registry is kept busy, including
    CVE scans, and the enterprise containers are usually more on the heavy side, raising
    transfer and storage costs.</st> <st c="33530">What most organizations didn’t
    understand was that Kubernetes is a global project.</st> <st c="33613">Also, if
    for someone it is night, somewhere else, there are people up and working on new
    features and pushing them to the Kubernetes repository.</st> <st c="33758">In
    the end, Kubernetes is one of the largest open source projects, initiated by Google,
    the largest</st> <st c="33858">digital-native company.</st>
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33231">这种方法的缺点是，大多数夜间构建从未被部署。</st> <st c="33310">它还阻止了构建服务器在晚上关闭。</st>
    <st c="33370">容器注册表一直保持忙碌，包括CVE扫描，企业容器通常较为庞大，增加了传输和存储成本。</st> <st c="33530">大多数组织没有理解的是，Kubernetes是一个全球性项目。</st>
    <st c="33613">此外，如果在某个地方是夜晚，其他地方的人仍然在工作，开发新功能并推送到Kubernetes仓库。</st> <st c="33758">最终，Kubernetes是全球最大的开源项目之一，由全球最大的</st>
    <st c="33858">数字原生公司Google发起。</st>
- en: <st c="33881">Think it through!</st>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33881">好好想想！</st>
- en: <st c="33899">Just because everyone else does it, think twice as to whether
    it really</st> <st c="33972">makes sense!</st>
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33899">仅仅因为别人都在做，考虑清楚它是否真的</st> <st c="33972">有意义！</st>
- en: <st c="33984">Back to processes.</st> <st c="34004">Almost every process can
    be improved, as they are usually grown historically.</st> <st c="34082">Within
    the platform space, regular tools are introduced that replace scripts and own
    custom developed tooling.</st> <st c="34193">Better processes not only cut costs
    but can increase</st> <st c="34245">efficiency, reduce risks, minimize errors,
    and</st> <st c="34293">provide consistency.</st>
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33984">回到流程。</st> <st c="34004">几乎每个流程都可以得到改善，因为它们通常是历史上逐步积累的。</st> <st
    c="34082">在平台空间内，定期引入的工具替代了脚本和自定义开发的工具。</st> <st c="34193">更好的流程不仅可以降低成本，还可以提高</st>
    <st c="34245">效率，减少风险，最小化错误，并</st> <st c="34293">提供一致性。</st>
- en: <st c="34313">Proven approaches for process optimization can be found in the</st>
    *<st c="34377">Lean</st>* <st c="34381">and</st> *<st c="34386">Six Sigma</st>*
    <st c="34395">methodologies.</st> <st c="34411">To improve a process, they teach
    you to do</st> <st c="34454">the following:</st>
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34313">经过验证的流程优化方法可以在</st> *<st c="34377">精益</st>* <st c="34381">和</st>
    *<st c="34386">六西格玛</st>* <st c="34395">方法论中找到。</st> <st c="34411">为了改善一个流程，它们教你执行以下操作：</st>
    <st c="34454">以下内容：</st>
- en: <st c="34468">Define/identify the problem of</st> <st c="34500">the process.</st>
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="34468">定义/识别</st> <st c="34500">流程的问题。</st>
- en: <st c="34512">Measure the performance and time of</st> <st c="34549">the transaction.</st>
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="34512">衡量</st> <st c="34549">交易的性能和时间。</st>
- en: <st c="34565">Analyze the performance for inefficiencies</st> <st c="34609">and
    dependencies.</st>
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="34565">分析效率低下</st> <st c="34609">和依赖关系的表现。</st>
- en: <st c="34626">Improve the process to</st> <st c="34650">solve inefficiencies.</st>
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="34626">改进流程以</st> <st c="34650">解决效率低下问题。</st>
- en: <st c="34671">Control and review the new process by introducing</st> <st c="34722">canary
    deployments.</st>
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="34671">通过引入</st> <st c="34722">金丝雀部署</st> <st c="34671">来控制和审查新流程。</st>
- en: <st c="34741">The fun part of platforms is that most processes can be found
    within CI/CD pipelines and GitOps implementations.</st> <st c="34855">Those translate
    our target into technical steps to ensure the desired state.</st> <st c="34932">Where
    it becomes complicated is when we have process dependencies within Kubernetes
    and components on top of it.</st> <st c="35045">As an eventually consistent event-driven
    system, it is a challenge to identify which dependencies are causing which behavior.</st>
    <st c="35171">Sometimes, we cannot change this component reaction without causing</st>
    <st c="35239">further impact.</st>
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34741">平台的有趣之处在于，大多数流程可以在 CI/CD 流水线和 GitOps 实现中找到。</st> <st c="34855">这些将我们的目标转化为技术步骤，以确保实现预期状态。</st>
    <st c="34932">复杂的地方在于，当我们在 Kubernetes 内以及其上方的组件中有流程依赖关系时。</st> <st c="35045">作为一个最终一致的事件驱动系统，识别哪些依赖关系导致了哪种行为是一项挑战。</st>
    <st c="35171">有时候，在不造成</st> <st c="35239">进一步影响的情况下，我们无法改变组件的反应。</st>
- en: <st c="35254">Processes in a technical world often sound like a bunch of scripts
    playing together.</st> <st c="35340">An ideal state is a cloud-native approach
    that utilizes the Kubernetes standardized API, controller</st> <st c="35440">capabilities,
    and resource definitions.</st> <st c="35480">It decouples different capabilities,
    and with those processes, makes them easier to optimize.</st> <st c="35574">Also,
    it makes it difficult to introduce new, historically grown</st> <st c="35639">proces</st><st
    c="35645">s trash.</st>
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35254">在技术世界中，流程常常听起来像是一堆脚本一起运行。</st> <st c="35340">理想的状态是采用云原生的方法，利用
    Kubernetes 标准化的 API、控制器</st> <st c="35440">功能和资源定义。</st> <st c="35480">它解耦了不同的功能，并通过这些流程，使它们更容易优化。</st>
    <st c="35574">此外，它使得引入新的、历史上积累的</st> <st c="35639">流程垃圾</st><st c="35645">变得困难。</st>
- en: <st c="35654">Finding the best deals for the best prices</st>
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="35654">寻找最优惠价格的最佳交易</st>
- en: <st c="35697">A</st> <st c="35699">straightforward way to optimize costs is
    to compare list prices and take the cheapest option.</st> *<st c="35794">Cheap</st>*
    <st c="35799">is thereby relative because you might cut down the performance,
    the throughput, the available IP addresses, and so on.</st> <st c="35919">Costs
    and utilization are good indicators but have to be evaluated for their second-tier
    impact.</st> <st c="36016">Reducing, for example, the instance size might reduce
    the throughput and performance, which causes you to have to introduce another
    instance.</st> <st c="36158">That way, you might utilize two instances for 80%-90%
    but you still pay the same or even more than if you ran a larger instance with</st>
    <st c="36291">fewer utilizations.</st>
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35697">一种</st> <st c="35699">优化成本的直接方式是比较列表价格，并选择最便宜的选项。</st> *<st c="35794">便宜</st>*
    <st c="35799">因此是相对的，因为你可能会降低性能、吞吐量、可用的 IP 地址等。</st> <st c="35919">成本和利用率是很好的指标，但必须评估它们的二级影响。</st>
    <st c="36016">例如，减少实例大小可能会降低吞吐量和性能，这会导致你不得不引入另一个实例。</st> <st c="36158">这样，你可能会用两个实例达到
    80%-90% 的利用率，但仍然支付和使用更大实例的费用相同，甚至更多。</st> <st c="36291">即使是利用率更低。</st>
- en: <st c="36310">If you are not bound to a region, some regions are cheaper than
    others; even so, it has no large effect.</st> <st c="36416">A strong option at
    the moment is the utilization of ARM servers.</st> <st c="36481">If you are not
    able to run your own or users’ workload on it, at least introduce it for managed
    services such as databases.</st> <st c="36605">This can cut 20-30% or more</st>
    <st c="36633">of costs.</st>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36310">如果你不受地域限制，某些地区比其他地区便宜；即便如此，它的影响不大。</st> <st c="36416">目前一个强有力的选择是利用
    ARM 服务器。</st> <st c="36481">如果你无法在其上运行你自己或用户的工作负载，至少可以将其用于托管服务，例如数据库。</st> <st
    c="36605">这可以节省 20%-30% 或更多</st> <st c="36633">的成本。</st>
- en: <st c="36642">Those are very obvious steps.</st> <st c="36673">Find and identify
    the right resource that is not overprovisioned in the right region.</st> <st c="36759">And,
    as explained earlier, often you can achieve better cost performance when you keep
    things lean</st> <st c="36858">and clean.</st>
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36642">这些都是非常明显的步骤。</st> <st c="36673">找到并识别在正确区域中不被过度配置的正确资源。</st> <st
    c="36759">如前所述，当你保持资源精简时，通常能实现更好的成本效益。</st> <st c="36858">并且清晰明了。</st>
- en: <st c="36868">There are many tools, such as Cloudability or Flexera, that can
    help you identify a cheaper option, and some even recommend changing architectures
    to reduce costs.</st> <st c="37033">These tools are extremely helpful to get started,
    but they often also come with a high price, and the knowledge coded into them
    is nothing you couldn’t gain through some research by yourself or attending free
    cost</st> <st c="37247">optimization</st> <st c="37259">classes.</st>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36868">有很多工具，如 Cloudability 或 Flexera，可以帮助你找到更便宜的选项，有些工具甚至建议改变架构来降低成本。</st>
    <st c="37033">这些工具非常有助于入门，但它们通常也有很高的价格，而它们所编码的知识并不是你不能通过一些自己的研究或参加免费的成本</st> <st
    c="37247">优化</st> <st c="37259">课程获得的。</st>
- en: <st c="37268">Designing for the highest utilization and lowest demands</st>
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="37268">设计以实现最高利用率和最低需求</st>
- en: <st c="37325">As platform engineers cut</st> <st c="37351">down the infrastructure,
    it will</st> <st c="37385">most likely have an impact on the user experience.</st>
    <st c="37436">The more flexible your platform becomes, the better it can adjust
    to the given situation.</st> <st c="37526">You can introduce active components
    that declutter and reduce the size of the system where possible and educate your
    user about the possibilities to increase and decrease the workload as needed.</st>
    <st c="37721">Matching their utilization with the bill can motivate the user to
    take care of</st> <st c="37800">responsible usage.</st>
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37325">随着平台工程师减少</st> <st c="37351">基础设施，它很可能会影响用户体验。</st> <st c="37385">平台变得越灵活，它就越能适应给定的情况。</st>
    <st c="37436">你可以引入主动组件，简化系统并在可能的情况下减少系统大小，同时教育用户了解增加或减少工作负载的可能性。</st> <st c="37526">将他们的利用率与账单匹配可以激励用户负责任地使用资源。</st>
    <st c="37721">责任使用。</st>
- en: <st c="37818">Previously, you learned about the difficulties between many small
    nodes and a few larger ones.</st> <st c="37914">We also discovered that we can
    easily support different CPU architectures and allocate resources dynamically.</st>
    <st c="38024">All those elements play a role in the definition of the core of
    the platform.</st> <st c="38102">I always have in mind the picture of an ant colony.</st>
    <st c="38154">At their center, they have a lot of action going on, but the core
    is a stable construction containing the majority of ants in it.</st> <st c="38284">When
    the colony, aka our platform, grows, we will extend this part.</st> <st c="38352">But
    sometimes, we don’t know if it isn’t just temporary.</st> <st c="38409">Throughout
    the book, you have seen different ways to handle dynamic workloads, and in the
    following section, we show some best practices</st> <st c="38546">for scaling.</st>
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37818">之前，你了解了许多小节点与少数大节点之间的困难。</st> <st c="37914">我们还发现，我们可以轻松支持不同的CPU架构，并动态分配资源。</st>
    <st c="38024">所有这些因素在定义平台核心时都起着重要作用。</st> <st c="38102">我总是脑海中浮现出蚂蚁巢穴的图景。</st>
    <st c="38154">在它们的中心，有很多活动发生，但核心是一个稳定的结构，里面包含着大部分蚂蚁。</st> <st c="38284">当巢穴，也就是我们的平台，发展壮大时，我们将扩展这一部分。</st>
    <st c="38352">但有时，我们并不知道这是否只是暂时的。</st> <st c="38409">在整本书中，你已经看到不同的方法来处理动态工作负载，在接下来的章节中，我们将展示一些扩展的最佳实践。</st>
    <st c="38546">扩展。</st>
- en: <st c="38558">So, what would be an ideal picture?</st> <st c="38595">Besides
    the aspect that it depends on your demands, the platform should utilize its resources
    as much as possible while having no overhead infrastructure.</st> <st c="38750">Simply
    said, it’s not easy to do as a platform.</st> <st c="38798">The workload is not
    within your hands and can be anything from static long-running resource-intensive
    software to thousands of serverless containers being continuously on the move.</st>
    <st c="38979">What we can take from this is that you can design the platform as</st>
    <st c="39045">well as you want; in the end, it all</st> <st c="39082">comes down
    to a continuous job of analyzing, reacting, and adjusting.</st> <st c="39152">With
    time, you can build a base layer of automatic reaction into the platform that
    will cover most cases, but you still will be required to work on</st> <st c="39300">the
    optimization.</st>
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38558">那么，理想的图景是什么样的呢？</st> <st c="38595">除了取决于你的需求之外，平台应尽可能利用其资源，同时没有额外的基础设施开销。</st>
    <st c="38750">简单来说，作为一个平台，这并不容易做到。</st> <st c="38798">工作负载并不完全掌握在你手中，它可能从静态的长时间运行的资源密集型软件，到成千上万个不断变化的无服务器容器。</st>
    <st c="38979">我们可以从中得出的结论是，你可以尽情地设计平台，</st> <st c="39045">但最终，一切</st> <st c="39082">都归结为一个持续的工作过程：分析、反应和调整。</st>
    <st c="39152">随着时间的推移，你可以在平台中构建一个自动反应的基础层，覆盖大多数情况，但你仍然需要继续优化。</st>
- en: <st c="39317">In the last part of this chapter, we take a look at some concrete
    examples of scaling and optimization.</st> <st c="39422">You will learn about
    reactive and predictive scaling as well as</st> <st c="39486">cost-aware</st>
    <st c="39496">engineering.</st>
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39317">在本章的最后部分，我们将通过一些具体的例子来看一下如何进行扩展和优化。</st> <st c="39422">你将学习到反应性和预测性扩展，以及</st>
    <st c="39486">成本意识</st> <st c="39496">工程。</st>
- en: <st c="39509">Autoscaling, cold storage, and other tricks for cost optimization</st>
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="39509">自动扩展、冷存储和其他成本优化的技巧</st>
- en: <st c="39575">In</st> [*<st c="39579">Chapter 4</st>*](B31164_04.xhtml#_idTextAnchor201)<st
    c="39588">, in the</st> *<st c="39597">Autoscaling clusters and workloads</st>*
    <st c="39631">section, we already discussed a key benefit and</st> <st c="39679">core
    capability that comes with Kubernetes.</st> <st c="39724">Several different tools
    and mechanisms are built into K8s to scale, such as configuring ReplicaSets (the
    number of instances per workload we want) or using observability data to drive
    automated scaling</st> <st c="39925">decisions using</st> **<st c="39942">Horizontal
    Pod Autoscaler</st>** <st c="39967">(</st>**<st c="39969">HPA</st>**<st c="39972">),</st>
    **<st c="39976">Vertical Pod Autoscaler</st>** <st c="39999">(</st>**<st c="40001">VPA</st>**<st
    c="40004">), or</st> **<st c="40011">Kubernetes Event Driven Autoscaling</st>**
    <st c="40046">(</st>**<st c="40048">KEDA</st>**<st c="40052">).</st> <st c="40056">There
    is</st> <st c="40065">a great free tutorial that walks</st> <st c="40097">through
    all the different options to autoscale on Kubernetes provided by</st> *<st c="40171">Is
    It Observable</st>*<st c="40187">. Here is the YouTube tutorial link, which also
    contains links to the GitHub</st> <st c="40264">tutorial:</st> [<st c="40274">https://www.youtube.com/watch?v=qMP6tbKioLI</st>](https://www.youtube.com/watch?v=qMP6tbKioLI)<st
    c="40317">.</st>
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39575">在</st> [*<st c="39579">第4章</st>*](B31164_04.xhtml#_idTextAnchor201)<st
    c="39588">中，在</st> *<st c="39597">自动伸缩集群和工作负载</st>* <st c="39631">一节中，我们已经讨论了
    Kubernetes 带来的一个关键好处和</st> <st c="39679">核心功能。</st> <st c="39724">K8s 内置了多种不同的工具和机制来实现伸缩，例如配置
    ReplicaSets（我们希望每个工作负载的实例数量）或使用可观察性数据来驱动自动伸缩</st> <st c="39925">决策，利用</st> **<st
    c="39942">水平 Pod 自动伸缩器</st>** <st c="39967">（</st>**<st c="39969">HPA</st>**<st
    c="39972">），</st> **<st c="39976">垂直 Pod 自动伸缩器</st>** <st c="39999">（</st>**<st
    c="40001">VPA</st>**<st c="40004">），或</st> **<st c="40011">Kubernetes 事件驱动自动伸缩</st>**
    <st c="40046">（</st>**<st c="40048">KEDA</st>**<st c="40052">）。</st> <st c="40056">有</st>
    <st c="40065">一个很棒的免费教程，详细介绍了所有 Kubernetes 提供的自动伸缩选项，</st> *<st c="40171">Is It
    Observable</st>*<st c="40187"> 提供的。这里是 YouTube 教程链接，里面还包含了 GitHub</st> <st c="40264">教程的链接：</st>
    [<st c="40274">https://www.youtube.com/watch?v=qMP6tbKioLI</st>](https://www.youtube.com/watch?v=qMP6tbKioLI)<st
    c="40317">。</st>
- en: <st c="40318">The primary use case of autoscaling</st> <st c="40354">is to ensure
    that workloads have enough compute, memory, and storage to achieve certain availability
    goals.</st> <st c="40463">For our Financial One ACME company, this could mean
    that they use autoscaling to ensure that their financial transaction backend can
    handle 1,000 concurrent transactions to be processed within a 100 ms response
    time.</st> <st c="40680">While autoscaling can help us reach our availability
    objectives, it also comes with a price tag as scaling resources means somebody
    needs to pay for that extra compute (CPU) or memory.</st> <st c="40865">Improper
    autoscaling—scaling too much, never scaling down, or scaling at the wrong times—can
    also lead to unplanned cost explosions while not meeting the real objective</st>
    <st c="41034">of autoscaling!</st>
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40318">自动伸缩的主要用例</st> <st c="40354">是确保工作负载拥有足够的计算、内存和存储，以实现特定的可用性目标。</st>
    <st c="40463">以我们的金融公司 ACME 为例，这可能意味着他们使用自动伸缩来确保其金融交易后台能够在 100 毫秒的响应时间内处理 1000
    个并发交易。</st> <st c="40680">尽管自动伸缩可以帮助我们实现可用性目标，但它也有成本，因为伸缩资源意味着需要为额外的计算（CPU）或内存付费。</st>
    <st c="40865">不当的自动伸缩——伸缩过多、从不缩减，或在错误的时间伸缩——也会导致计划外的成本激增，同时无法实现自动伸缩的真正目标！</st>
- en: '*<st c="41049">Autoscaling done right</st>* <st c="41072">is what we want.</st>
    <st c="41090">Doing it right not only allows us to achieve our business and technical
    objectives but also allows us to leverage autoscaling to keep costs under control.</st>
    <st c="41245">Let’s have a look into several autoscaling topics platform engineers
    should be aware of and what else we can do to optimize costs.</st> <st c="41376">Be
    reminded that some of the practices we will discuss in the following sections
    are also applicable to any type of workl</st><st c="41497">oad: cloud</st> <st
    c="41509">or not.</st>'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="41049">正确的自动伸缩</st>* <st c="41072">是我们所期望的。</st> <st c="41090">正确地做自动伸缩不仅可以帮助我们实现业务和技术目标，还能让我们利用自动伸缩来控制成本。</st>
    <st c="41245">让我们来看看平台工程师应该了解的几个自动伸缩话题，以及我们还能做些什么来优化成本。</st> <st c="41376">请记住，接下来我们讨论的一些实践也适用于任何类型的工作负载：无论是云工作负载</st><st
    c="41497">还是其他。</st>'
- en: <st c="41516">Many shades of autoscaling</st>
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="41516">自动伸缩的多种形式</st>
- en: <st c="41543">The scalable nature of the cloud and Kubernetes as a core platform
    is a great capability to have at hand as platform engineers.</st> <st c="41672">There
    are, however, many different ways to scale.</st> <st c="41722">There are different
    trigger points that can cause a system to scale, plus, scaling must not just go
    in one direction (typically up) but we also have to consider scaling systems down—even
    all the way to zero to avoid wasting reso</st><st c="41950">urces</st> <st c="41957">for
    nothing!</st>
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41543">云计算和 Kubernetes 作为核心平台的可扩展性是平台工程师手中非常强大的能力。</st> <st c="41672">然而，扩展的方法有很多种。</st>
    <st c="41722">有不同的触发点可能导致系统进行扩展，而且，扩展不仅仅是一个方向（通常是向上），我们还必须考虑将系统缩小——甚至缩小到零，以避免浪费资源</st><st
    c="41950">！</st> <st c="41957">以至于毫无意义！</st>
- en: <st c="41969">Scaling up – not only on CPU and memory</st>
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="41969">向上扩展——不仅仅是基于 CPU 和内存</st>
- en: <st c="42009">Most</st> <st c="42015">engineers are familiar with scaling based
    on CPU and memory.</st> <st c="42076">Most examples you will find for HPA typically
    scale the replicas of Pods based on a certain average CPU utilization of that
    Pod.</st> <st c="42205">That’s the most common way of what we also refer to as
    reactive scaling as we scale based on reacting to a</st> <st c="42312">reached
    threshold.</st>
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42009">大多数</st> <st c="42015">工程师都熟悉基于 CPU 和内存进行扩展。</st> <st c="42076">你会发现的多数
    HPA 示例通常是根据该 Pod 的某个平均 CPU 利用率来扩展 Pod 的副本。</st> <st c="42205">这就是我们通常所说的响应性扩展，因为我们是基于达到某个阈值来进行扩展的</st>
    <st c="42312">响应。</st>
- en: <st c="42330">However, scaling based on CPU or memory is not always the best
    option.</st> <st c="42402">It’s also not the only one we have, even though most
    scaling frameworks initially started with just scaling based on CPU and memory
    as those are the two key limits one can set on Pods</st> <st c="42586">or namespaces.</st>
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42330">然而，基于 CPU 或内存进行扩展并不总是最佳选择。</st> <st c="42402">这也不是我们唯一的选择，尽管大多数扩展框架最初都是基于
    CPU 和内存进行扩展的，因为这两个是可以在 Pods</st> <st c="42586">或命名空间中设置的关键限制。</st>
- en: <st c="42600">For services that are optimized for a certain throughput, it would,
    for instance, make more sense to scale on concurrent incoming requests.</st> <st
    c="42741">Also, for the CPU, instead of scaling based on average CPU utilization,
    it could be better to scale your system when K8s starts to throttle the CPU for
    a Pod.</st> <st c="42900">In our previous chapter, we mentioned tools such as</st>
    <st c="42951">KEDA as well as the</st> **<st c="42972">Cloud Native Computing
    Foundation</st>** <st c="43005">(</st>**<st c="43007">CNCF</st>**<st c="43011">)
    Keptn project, which can provide any type of metric from various observability
    sources (Prometheus, Dynatrace, Datadog, New Relic) to be used for event-driven
    autoscaling.</st> <st c="43186">To see how this works, check out a full example
    in the Keptn</st> <st c="43246">documentation:</st> [<st c="43262">https://keptn.sh/stable/docs/use-cases/keda</st>](https://keptn.sh/stable/docs/use-cases/keda)<st
    c="43305">.</st>
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42600">对于针对特定吞吐量优化的服务来说，例如，基于并发请求来进行扩展会更有意义。</st> <st c="42741">同样，对于
    CPU，除了根据平均 CPU 利用率进行扩展，还可以在 Kubernetes 开始限制 Pod 的 CPU 时进行扩展，这可能会更好。</st> <st c="42900">在前面的章节中，我们提到了像</st>
    <st c="42951">KEDA 以及</st> **<st c="42972">云原生计算基金会</st>** <st c="43005">(</st>**<st
    c="43007">CNCF</st>**<st c="43011">) Keptn 项目，它们可以提供来自各种可观测性源（如 Prometheus、Dynatrace、Datadog、New
    Relic）的任何类型的度量，用于事件驱动的自动扩展。</st> <st c="43186">要查看这个如何工作，请查阅 Keptn</st> <st c="43246">文档中的完整示例：</st>
    [<st c="43262">https://keptn.sh/stable/docs/use-cases/keda</st>](https://keptn.sh/stable/docs/use-cases/keda)<st
    c="43305">。</st>
- en: <st c="43306">The key takeaway is that not every workload is CPU- or memory-bound,
    and Kubernetes is not limiting you to just defining your scaling rules based on
    those two key attributes.</st> <st c="43482">Defining scaling rules based on what
    is really allowing your workload to execute more efficiently will also lead to
    more efficient resource utilization, which leads to a system that is also</st>
    <st c="43671">optimized</st> <st c="43682">for costs!</st>
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43306">关键要点是，并不是每个工作负载都受限于 CPU 或内存，并且 Kubernetes 不仅仅限制你根据这两个关键属性来定义扩展规则。</st>
    <st c="43482">根据真正使工作负载更高效地执行的因素来定义扩展规则，还会导致更高效的资源利用，从而带来一个在成本上也得到了</st> <st c="43671">优化</st>
    <st c="43682">的系统！</st>
- en: <st c="43692">Predictive versus reactive scaling</st>
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="43692">预测性扩展与响应性扩展</st>
- en: <st c="43727">It is often assumed that</st> <st c="43753">autoscaling works
    instantly.</st> <st c="43782">But that’s not true!</st> <st c="43803">Think about
    Financial One ACME.</st> <st c="43835">If on paycheck day everyone wants to check
    their new account balance, this might mean a 10x spike in regular traffic within
    the first couple of hours of that day.</st> <st c="43998">The cloud vendor, however,
    cannot guarantee that all those resources are instantly available as you are competing
    with many other organizations that are also trying to request cloud resources
    at the same time.</st> <st c="44208">On top of that, the workload itself will
    not be able to process incoming requests instantly as many of those Pods have
    a certain startup time until they</st> <st c="44361">are ready.</st>
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43727">通常认为</st> <st c="43753">自动扩展是瞬时工作的。</st> <st c="43782">但事实并非如此！</st>
    <st c="43803">想想金融公司ACME。</st> <st c="43835">如果在发薪日，每个人都想查看他们的新账户余额，这可能意味着当天前几个小时内流量会激增10倍。</st>
    <st c="43998">然而，云服务提供商不能保证所有这些资源能够立即提供，因为你正在与许多其他组织竞争，这些组织也在尝试同时请求云资源。</st> <st
    c="44208">此外，工作负载本身也不能立即处理传入的请求，因为许多Pod在准备好之前都有一定的启动时间。</st>
- en: <st c="44371">This problem can be solved through predictive scaling.</st> <st
    c="44427">Compared to reactive scaling – which is scaling when we reach a certain
    threshold, as explained in the previous section – predictive scaling looks into
    a potential future situation and reacts to it before reaching a threshold.</st>
    <st c="44654">Predictive doesn’t mean we need a magic glass bowl to tell us the
    future.</st> <st c="44728">It can be as simple as starting the scaling a couple
    of hours before we anticipate a spike in traffic; for example, just ahead of paycheck
    day or ahead of a marketing campaign that starts at a</st> <st c="44921">specific
    time.</st>
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44371">这个问题可以通过预测性扩展来解决。</st> <st c="44427">与反应性扩展——即在达到某个阈值时进行扩展，如前一节所述——相比，预测性扩展是基于潜在的未来情境并在达到阈值之前进行反应。</st>
    <st c="44654">预测性并不意味着我们需要一个魔法玻璃球来告诉我们未来。</st> <st c="44728">它可以像在我们预期流量激增前几小时启动扩展那样简单；例如，在发薪日之前或在某个特定时间开始的营销活动前。</st>
    <st c="44921">具体时间。</st>
- en: <st c="44935">Other predictions can be</st> <st c="44961">more dynamic:</st>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44935">其他预测可能更为动态：</st>
- en: '**<st c="44974">Seasonality</st>**<st c="44986">: One could be based on seasonality
    by looking at historical data.</st> <st c="45054">E-commerce is a good example
    where, throughout the year, you have certain dates that see a spike in load, such
    as Black Friday or Cyber Monday.</st> <st c="45198">It’s easy to</st> *<st c="45211">predict</st>*
    <st c="45218">those spikes!</st>'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="44974">季节性</st>**<st c="44986">：可以通过查看历史数据来基于季节性做出预测。</st> <st c="45054">电子商务是一个很好的例子，一年四季中总会有一些日期流量激增，例如黑色星期五或网络星期一。</st>
    <st c="45198">这些激增很容易</st> *<st c="45211">预测</st>* <st c="45218">到！</st>'
- en: '**<st c="45232">Related data sources</st>**<st c="45253">: Another one could
    be to look into other data sources.</st> <st c="45310">Insurance organizations
    often look into severe weather data.</st> <st c="45371">When storms are predicted
    and there is a certain chance that those storms will cause damage, it makes sense
    to predictively scale services that those clients will use to submit insurance
    claims.</st> <st c="45566">For this particular scenario, you can even scale in
    specific regions that are closest to</st> <st c="45655">the storm.</st>'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="45232">相关数据源</st>**<st c="45253">：另一个预测方式是查看其他数据源。</st> <st c="45310">保险公司通常会查看恶劣天气数据。</st>
    <st c="45371">当预报有暴风雨并且这些暴风雨有可能造成损害时，预测性扩展是合理的，特别是对于客户提交保险索赔时所使用的服务。</st> <st
    c="45566">在这种特定情景下，您甚至可以在接近</st> <st c="45655">暴风雨的特定区域进行扩展。</st>'
- en: '**<st c="45665">System dependencies</st>**<st c="45685">: In complex systems,
    it is also an option to scale dependent</st> <st c="45747">components based on
    the load behavior of other parts of the system.</st> <st c="45816">Take hospitality
    as an example.</st> <st c="45848">If we see more people searching for flights
    as they want to get away on a long weekend, we may also predictively scale backend
    services that provide recommendations for hotels, cars, or additional events to
    book in</st> <st c="46063">the</st> <st c="46067">travel destination.</st>'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="45665">系统依赖</st>**<st c="45685">：在复杂系统中，基于系统其他部分的负载行为来扩展依赖组件也是一个可选方案。</st>
    <st c="45747">以酒店行业为例。</st> <st c="45816">如果我们看到更多人搜索航班，因为他们想在长周末出游，我们也可以预测性地扩展提供酒店、租车或其他可预订活动推荐的后端服务。</st>
    <st c="46063">前往</st> <st c="46067">旅游目的地的推荐。</st>'
- en: <st c="46086">Use case – predictive storage scaling to optimize cost and availability</st>
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="46086">用例 – 预测性存储扩展以优化成本和可用性</st>
- en: '<st c="46158">Now</st> <st c="46163">that we have learned about different approaches
    to predictive scaling, let’s apply this to a very costly</st> <st c="46268">example:
    storage!</st>'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46158">现在</st> <st c="46163">我们已经了解了不同的预测性扩展方法，接下来让我们将其应用于一个非常高成本的</st>
    <st c="46268">例子：存储！</st>
- en: <st c="46285">Our digital systems are generating more data than ever, and it’s
    predicted that this trend will continue.</st> <st c="46392">Storage – while seemingly
    available in abundance – is a big cost factor for many organizations.</st> <st
    c="46488">The same is true for our Financial One ACME company, assuming we have
    to store all the details about every financial transaction our systems handle.</st>
    <st c="46637">As an organization, we need to make sure we can always persist all
    records, but we also want to make sure that we are not paying for storage space
    we currently don’t need.</st> <st c="46809">So, we want to keep our free disk
    space as small as possible to avoid having to pay for disks we don’t need.</st>
    <st c="46918">On the other hand, we also need to make sure we have enough disk
    free space in case a spike in transactions comes in as we cannot afford to be
    able to lose transactions.</st> <st c="47088">Considering that scaling disks at
    a large scale can’t happen instantly but may take a couple of hours, we can apply
    predictive storage scaling to fulfill all</st> <st c="47246">our requirements!</st>
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46285">我们的数字系统生成的数据比以往任何时候都要多，而且预计这一趋势将持续下去。</st> <st c="46392">存储 ——
    尽管看似有充足的空间 —— 对许多组织来说仍然是一个重要的成本因素。</st> <st c="46488">对我们金融一号 ACME 公司来说也是如此，假设我们需要存储系统处理的每一笔财务交易的所有细节。</st>
    <st c="46637">作为一个组织，我们需要确保可以始终保存所有记录，但同时我们也希望确保不为目前不需要的存储空间支付费用。</st> <st c="46809">因此，我们希望将空闲磁盘空间保持尽可能小，以避免为不需要的磁盘付费。</st>
    <st c="46918">另一方面，我们还需要确保有足够的空闲磁盘空间，以防交易量激增，因为我们无法承受交易丢失的风险。</st> <st c="47088">考虑到大规模扩展磁盘不能瞬间完成，可能需要几个小时，我们可以应用预测性存储扩展来满足所有</st>
    <st c="47246">我们的需求！</st>
- en: <st c="47263">The following screenshot helps us understand how this works.</st>
    <st c="47325">It shows the disk free space % metric over time.</st> <st c="47374">The
    more data we write, the less disk free space is available.</st> <st c="47437">Instead
    of scaling our cloud storage on a certain fixed threshold, we can use a predictive
    model and scale when we predict that we will reach a certain low threshold within
    the timeframe it takes to scale – hence ensuring that we always have enough free
    disk space without paying for</st> <st c="47721">too much:</st>
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47263">以下截图帮助我们理解这一过程是如何工作的。</st> <st c="47325">它展示了随时间变化的磁盘空闲空间百分比。</st>
    <st c="47374">我们写入的数据越多，空闲磁盘空间就越少。</st> <st c="47437">与其在某个固定阈值上扩展我们的云存储，我们可以使用预测模型，在预计会在扩展所需的时间内达到某个低阈值时进行扩展——从而确保我们始终拥有足够的空闲磁盘空间，而不会为</st>
    <st c="47721">过多的空间支付费用：</st>
- en: '![Figure 8.4: Predictive scaling of cloud storage to optimize for cost and
    availability](img/B31164_08_04.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4：云存储的预测性扩展，以优化成本和可用性](img/B31164_08_04.jpg)'
- en: '<st c="47827">Figure 8.4: Predictive scaling of cloud storage to optimize for
    cost and availability</st>'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47827">图 8.4：云存储的预测性扩展，以优化成本和可用性</st>
- en: <st c="47912">The</st> <st c="47917">preceding example is taken from a real
    use case that resulted in great cost savings by continuously rightsizing storage
    using a pred</st><st c="48049">ictive</st> <st c="48057">scaling approach!</st>
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47912">前面这个例子来自一个真实的使用案例，通过持续根据预测性扩展方法调整存储大小，实现了显著的成本节约！</st>
- en: <st c="48074">Scaling to zero – shutting things down when not needed</st>
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="48074">缩放到零——在不需要时关闭系统</st>
- en: <st c="48129">While many systems we</st> <st c="48151">operate need to be available
    24/7, some systems don’t have that requirement.</st> <st c="48229">These might
    be systems that are only used by employees during regular business hours or systems
    that are only needed to fulfill certain jobs during special times of the day,
    month, or year.</st> <st c="48419">I am sure we can all think about systems that
    are often sitting idle yet consuming precious resources and therefore causing
    costs even though they are currently</st> <st c="48580">not needed.</st>
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48129">虽然我们运营的许多系统需要 24/7 全天候可用，但有些系统并没有这个要求。</st> <st c="48151">这些可能是仅在正常工作时间由员工使用的系统，或是仅在一天、一个月或一年中特定时间需要执行某些任务的系统。</st>
    <st c="48229">我敢肯定，我们都能想到一些经常处于空闲状态但仍消耗宝贵资源的系统，尽管它们当前并不</st> <st c="48580">被需要。</st>
- en: '**<st c="48591">Virtual machines</st>** <st c="48608">(</st>**<st c="48610">VMs</st>**<st
    c="48613">) are great</st> <st c="48626">examples of scaling to zero.</st> <st
    c="48655">We have been doing this for many years to take snapshots, shut VMs down
    when not needed, and bring them up again when the work had to be continued.</st>
    <st c="48803">Many organizations fully automated this by automatically shutting
    down VMs that were used for daily business tasks at the end of the business day
    and bringing them up again the next morning.</st> <st c="48994">This alone is
    a great cost-saving opportunity as many VMs can be shut down during nights</st>
    <st c="49083">and weekends!</st>'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="48591">虚拟机</st>** <st c="48608">(</st>**<st c="48610">VM</st>**<st
    c="48613">) 是缩放到零的一个很好的例子。</st> <st c="48626">多年来，我们一直在做这件事：在不需要时关闭虚拟机，并在需要继续工作时将其重新启动。</st>
    <st c="48803">许多组织通过自动化的方式实现这一点：在工作日结束时自动关闭用于日常业务任务的虚拟机，并在第二天早上再次启动它们。</st> <st
    c="48994">单单这一点就带来了巨大的成本节省机会，因为许多虚拟机可以在晚上</st> <st c="49083">和周末关闭！</st>'
- en: <st c="49096">In Kubernetes, we also have the opportunity to scale workloads
    to zero.</st> <st c="49169">We could use the already discussed KEDA but also look
    into tools such as Knative (which can run serverless workloads) or</st> `<st c="49290">kube-green</st>`<st
    c="49300">. The latter was created to reduce the CO2 footprint of K8s workloads
    and clusters and is able to put workloads, nodes, or clusters to sleep when not
    needed.</st> <st c="49458">To learn more about</st> `<st c="49478">kube-green</st>`<st
    c="49488">, check out the following</st> <st c="49514">website:</st> [<st c="49523">https://kube-green.dev/</st>](https://kube-green.dev/)<st
    c="49546">.</st>
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49096">在 Kubernetes 中，我们也有机会将工作负载缩放到零。</st> <st c="49169">我们可以使用前面讨论过的
    KEDA，也可以考虑像 Knative（可以运行无服务器工作负载）或</st> `<st c="49290">kube-green</st>`<st c="49300">
    这样的工具。后者旨在减少 K8s 工作负载和集群的 CO2 足迹，并且能够在不需要时将工作负载、节点或集群置于休眠状态。</st> <st c="49458">想了解更多关于</st>
    `<st c="49478">kube-green</st>`<st c="49488">的信息，请访问以下</st> <st c="49514">网站：</st>
    [<st c="49523">https://kube-green.dev/</st>](https://kube-green.dev/)<st c="49546">。</st>
- en: '<st c="49547">A question we still need to answer is: Which workloads can be
    scaled to zero and for how long?</st> <st c="49643">We get this data from the
    owners of those workloads by specifying when and how long they need them.</st>
    <st c="49743">Another approach to this is simply using observability data to see
    which workloads are used at which times during the day and, based on that, create
    a</st> `<st c="49894">kube-green</st>` <st c="49904">sleep configuration to scale
    workloads to zero.</st> <st c="49953">An example of this implementation can be
    found in</st> *<st c="50003">The Sustainability workshop</st>* <st c="50030">from
    Henrik</st> <st c="50043">Rexed:</st> [<st c="50050">https://github.com/henrikrex</st><st
    c="50078">ed/Sustainability-workshop</st>](https://github.com/henrikrexed/Sustainability-workshop)<st
    c="50105">.</st>'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49547">我们仍然需要回答一个问题：哪些工作负载可以缩放到零，以及可以缩放多久？</st> <st c="49643">我们从这些工作负载的所有者那里获得这些数据，明确它们何时以及需要多长时间。</st>
    <st c="49743">另一种方法是直接利用可观察性数据，查看一天中的哪些时段使用了哪些工作负载，并基于此创建一个</st> `<st c="49894">kube-green</st>`
    <st c="49904">休眠配置来将工作负载缩放到零。</st> <st c="49953">这种实现的一个示例可以在</st> *<st c="50003">可持续性研讨会</st>*
    <st c="50030">Henrik Rexed</st> <st c="50043">的讲座中找到：</st> [<st c="50050">https://github.com/henrikrex</st><st
    c="50078">ed/Sustainability-workshop</st>](https://github.com/henrikrexed/Sustainability-workshop)<st
    c="50105">。</st>
- en: <st c="50106">From scaling workloads to clusters</st>
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="50106">从工作负载扩展到集群</st>
- en: <st c="50141">So far, we talked a lot about rightsizing or scaling workloads
    to ensure we have enough resources to meet our business objectives but also to
    not overprovision so that we can optimize</st> <st c="50326">on cost.</st>
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50141">到目前为止，我们讨论了很多关于调整规模或扩展工作负载的内容，以确保我们拥有足够的资源来满足业务目标，同时也避免过度配置，以便我们可以优化</st>
    <st c="50326">成本。</st>
- en: <st c="50334">As we scale our workloads up and</st> <st c="50368">down, the
    underlying Kubernetes cluster also needs to be sized accordingly.</st> <st c="50444">This
    is where cluster autoscaling comes in, which will scale up a cluster’s nodes to
    ensure that enough resources are available to run all workloads, but which will
    also scale down nodes in case nodes are underutilized and workloads can be distributed
    across the remaining set of nodes.</st> <st c="50731">This ensures that the underlying
    cluster node machines are optimized, which in the end</st> <st c="50818">saves
    costs.</st>
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50334">随着我们扩展工作负载的规模，</st> <st c="50368">底层 Kubernetes 集群也需要相应地调整大小。</st>
    <st c="50444">这时，集群自动扩展功能就派上用场，它会扩大集群的节点数量，确保有足够的资源来运行所有工作负载，同时还会在节点未被充分利用且工作负载能够分配到剩余节点时，缩减节点。</st>
    <st c="50731">这确保了底层集群节点机器的优化，从而最终</st> <st c="50818">节省了成本。</st>
- en: <st c="50830">There is a lot of existing documentation on the Kubernetes documentation</st>
    <st c="50904">website:</st> [<st c="50913">https://kubernetes.io/docs/concepts/cluster-administration/cluster-autoscaling/</st>](https://kubernetes.io/docs/concepts/cluster-administration/cluster-autoscaling/)<st
    c="50992">.</st>
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50830">Kubernetes 文档网站上已有大量现有文档：</st> [<st c="50913">https://kubernetes.io/docs/concepts/cluster-administration/cluster-autoscaling/</st>](https://kubernetes.io/docs/concepts/cluster-administration/cluster-autoscaling/)<st
    c="50992">。</st>
- en: <st c="50993">There are specific autoscalers such as Karpenter – initially developed
    by AWS – that help right-scale a Kubernetes cluster but also keep costs in check.</st>
    <st c="51147">Karpenter integrates with the APIs of your cloud vendor and is able
    to provision the right size of nodes that are needed to handle a certain workload.</st>
    <st c="51298">It will also scale down nodes if no</st> <st c="51334">longer needed.</st>
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50993">有一些特定的自动扩展工具，比如 Karpenter——最初由 AWS 开发——它帮助调整 Kubernetes 集群的规模，同时控制成本。</st>
    <st c="51147">Karpenter 与你的云服务提供商的 API 集成，能够配置处理特定工作负载所需的适当节点大小。</st> <st c="51298">如果不再需要，它还会缩减节点。</st>
- en: <st c="51348">In addition to tools such as</st> `<st c="51378">kube-green</st>`
    <st c="51388">(mentioned earlier), Karpenter</st> <st c="51419">is a great option
    to scale your clusters while keeping costs in mind.</st> <st c="51490">To learn
    more about Karpenter, check</st> <st c="51527">out</st> [<st c="51531">https://karpenter.sh/</st>](https://karpenter.sh/)<st
    c="51552">.</st>
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51348">除了像</st> `<st c="51378">kube-green</st>` <st c="51388">（之前提到过）这样的工具外，Karpenter</st>
    <st c="51419">是一个很好的选项，可以在考虑成本的同时扩展你的集群。</st> <st c="51490">要了解更多关于 Karpenter
    的信息，请访问</st> [<st c="51531">https://karpenter.sh/</st>](https://karpenter.sh/)<st
    c="51552">。</st>
- en: <st c="51553">As platform engineers, it’s</st> <st c="51582">important to be
    aware of all the different scaling options.</st> <st c="51642">Many of those can
    be set up to rightsize workloads and clusters.</st> <st c="51707">For some, it’s
    important to work closely with the engineering teams and workload owners to define
    scaling strategies that make sense for those specific workloads.</st> <st c="51870">Overall,
    autoscaling – whether it is compute, memory, or storage – is one of the key enablers
    of cost-e</st><st c="51973">fficient</st> <st c="51983">platform engineering!</st>
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51553">作为平台工程师，</st> <st c="51582">了解所有不同的扩展选项非常重要。</st> <st c="51642">其中许多可以配置来调整工作负载和集群的规模。</st>
    <st c="51707">对于一些情况，与工程团队和工作负载所有者密切合作，定义适合特定工作负载的扩展策略也非常重要。</st> <st c="51870">总体而言，自动扩展——无论是计算、内存还是存储——是成本效益</st><st
    c="51973">优化</st> <st c="51983">平台工程的关键推动力之一！</st>
- en: <st c="52004">Cost-aware engineering</st>
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="52004">成本感知工程</st>
- en: <st c="52027">Now that we have learned what we</st> <st c="52061">can build
    into our platforms to rightsize and autoscale to save costs, we also need to talk
    about what we can do to enable engineering teams to become more cost-aware from
    the start.</st> <st c="52244">The best cost optimization starts when anyone in
    an organization is aware of the cost impact their actions have and therefore starts
    building and designing systems that are more cost-efficient by default.</st> <st
    c="52449">Reporting on costs based on tagging is one way of making teams aware
    of their</st> <st c="52527">costs.</st> <st c="52534">This strategy has been discussed
    earlier in</st> <st c="52578">this chapter.</st>
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52027">现在我们已经了解了如何在平台中构建内容，以实现适当规模和自动扩展来节省成本，我们还需要讨论如何让工程团队从一开始就更具成本意识。</st>
    <st c="52061">最好的成本优化从组织中的每个人意识到他们的行为对成本的影响开始，因此他们会默认地构建和设计更具成本效益的系统。</st> <st
    c="52244">基于标签的成本报告是一种让团队意识到他们的成本的方法。</st> <st c="52449">这种策略在本章前面已经讨论过。</st>
- en: <st c="52591">Let’s look into some additional options we think everyone should
    consider as they have the power to</st> <st c="52691">lead to</st> <st c="52700">cost-aware
    engineering!</st>
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52591">让我们来看看一些我们认为每个人都应该考虑的额外选项，因为它们有可能</st> <st c="52691">带来</st> <st
    c="52700">成本意识的工程实践！</st>
- en: <st c="52723">The only request what you need approach</st>
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="52723">只需要你所需的请求方式</st>
- en: '<st c="52763">In the early days of the cloud, many organizations gave their
    engineering teams full access to cloud portals.</st> <st c="52874">This easy “self-service”
    boosted productivity as everyone could easily stand up new VMs, create new storage
    services, or even create Kubernetes clusters.</st> <st c="53028">This “wild wild
    west” approach, however, led to cost explosions for many organizations as users
    were just creating new services but not thinking about the basics, such as: How
    large a virtual environment do I really need and for how long do I</st> <st c="53271">need
    it?</st>'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52763">在云计算初期，许多组织给予其工程团队完全访问云门户的权限。</st> <st c="52874">这种便捷的“自助服务”提升了生产力，因为每个人都可以轻松地创建新的虚拟机、存储服务，甚至是
    Kubernetes 集群。</st> <st c="53028">然而，这种“西部荒野”式的做法导致了许多组织的成本爆炸，因为用户只是创建新服务，却没有考虑基本问题，例如：我究竟需要多大的虚拟环境，且需要多长时间？</st>
    <st c="53271">我需要它多久？</st>
- en: <st c="53279">One of the organizations that the authors have worked with is
    a financial organization.</st> <st c="53368">Instead of giving everyone full access
    to their cloud portals, they built their own self-service portal allowing engineering
    teams to create new VMs, databases, clusters, and so on.</st> <st c="53550">As
    part of that self-service portal, the team had to define for</st> *<st c="53614">which
    application</st>* <st c="53631">they needed the resource and for</st> *<st c="53665">which
    environment</st>*<st c="53682">, as well as</st> *<st c="53695">how long</st>*
    <st c="53703">this machine was needed; for example, only during business hours.</st>
    <st c="53770">The result was a 60% cost reduction as the provisioned services
    were automatically shut down when no longer needed.</st> <st c="53886">The following
    screenshot shows how engineers request resources for the time they need them.</st>
    <st c="53978">On the right, you also see the detailed reporting and overall optimization
    goal this organization</st> <st c="54076">is achieving:</st>
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="53279">作者曾与之合作的一个组织是一家金融机构。</st> <st c="53368">他们没有给每个人完全访问云门户的权限，而是构建了自己的自助服务门户，允许工程团队创建新的虚拟机、数据库、集群等。</st>
    <st c="53550">作为自助服务门户的一部分，团队必须定义他们需要资源的*应用程序*和*环境*，以及*需要多长时间*使用这些机器；例如，仅在工作时间内。</st>
    <st c="53614">该结果是，通过自动关闭不再需要的服务，成本减少了 60%。</st> <st c="53703">下图显示了工程师如何请求他们所需的资源。</st>
    <st c="53886">右侧还可以看到详细的报告以及该组织正在实现的整体优化目标：</st>
- en: '![Figure 8.5: A self-service platform that reports and reduces costs](img/B31164_08_05.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.5：一款报告并降低成本的自助平台](img/B31164_08_05.jpg)'
- en: '<st c="54320">Figure 8.5: A self-service platform that reports and reduces
    costs</st>'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54320">图 8.5：一款报告并降低成本的自助平台</st>
- en: <st c="54386">The reporting in this use case was not only done on costs but
    also on carbon impact, which is a big topic for most organizations these days.</st>
    <st c="54528">Providing this self-service through a central platform made it easy
    for this organization to make their engineers more cost-aware from the start and
    also show them the posi</st><st c="54700">tive impact their</st> <st c="54719">actions
    have.</st>
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54386">在这个用例中，报告不仅关注成本，还包括碳足迹，这对大多数组织来说是一个重要话题。</st> <st c="54528">通过中央平台提供这一自助服务，使得该组织可以从一开始就让工程师更加关注成本，同时也展示了他们的行动所带来的正面影响。</st>
    <st c="54700">tive impact their</st> <st c="54719">actions have。</st>
- en: <st c="54732">Lease versus flat-rate resource</st>
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="54732">租赁模式与固定费用资源</st>
- en: <st c="54764">The previous example</st> <st c="54785">is great but requires
    teams to think upfront about exactly how long and when they need certain resources.</st>
    <st c="54892">A different approach to this would be to use a</st> **<st c="54939">lease
    model</st>**<st c="54950">. What does</st> <st c="54962">this mean?</st>
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54764">前面的例子</st> <st c="54785">非常好，但要求团队在一开始就考虑清楚他们确切需要哪些资源、需要多长时间。</st>
    <st c="54892">另一种做法是采用</st> **<st c="54939">租赁模式</st>**<st c="54950">。这意味着什么呢？</st>
- en: <st c="54972">When dev team A requests a resource – let’s say a Kubernetes cluster
    that they need for some development work – they can simply request it for a default
    time period; for example, 1 week.</st> <st c="55160">That 1-week timeframe becomes
    their “initial lease” of that resource.</st> <st c="55230">Both timeframe and
    team ownership will be managed through tags on that created resource.</st> <st
    c="55319">Through automation, 1 day prior to the end of the lease, emails or chat
    messages can be sent to teams reminding them that their lease is about to expire.</st>
    <st c="55473">The message can also give them the option to</st> *<st c="55518">extend
    the lease</st>* <st c="55534">for another day or week but also remind them about
    the cost that this extra time</st> <st c="55616">would incur.</st>
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54972">当A开发团队请求一个资源——比如他们需要用来做开发工作的Kubernetes集群——他们可以简单地请求一个默认的时间段；例如，1周。</st>
    <st c="55160">这个1周的时间段就成为了他们对该资源的“初始租期”。</st> <st c="55230">时间段和团队所有权将通过创建的资源标签进行管理。</st>
    <st c="55319">通过自动化，在租期结束前1天，可以通过电子邮件或聊天消息提醒团队他们的租期即将到期。</st> <st c="55473">消息还可以提供给他们一个选项，</st>
    *<st c="55518">延长租期</st>* <st c="55534">一天或一周，并提醒他们这段额外时间会带来的费用。</st> <st c="55616">
- en: <st c="55628">This approach has been implemented in several organizations and
    ensures that any team can still get the resources they need via self-service.</st>
    <st c="55771">It also ensures that resources that are forgotten about or no longer
    needed will be shut down without having to specify</st> <st c="55890">upfront
    exactly how long a resource will</st> <st c="55932">be needed.</st>
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="55628">这种方法已在多个组织中实施，并确保任何团队仍然可以通过自助服务获得他们需要的资源。</st> <st c="55771">它还确保那些被遗忘或不再需要的资源会被关闭，而无需事先指定资源需要的确切时间。</st>
    <st c="55890">exactly how long a resource will</st> <st c="55932">be needed.</st>
- en: <st c="55942">Now that we’ve talked about how to have resources running only
    when they are really needed to save on costs, let’s talk about how engineers can
    also optimize</st> <st c="56101">their code to make a</st> <st c="56122">cost
    impact!</st>
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="55942">现在我们已经讨论了如何仅在资源真正需要时运行它们以节省成本，接下来让我们讨论一下工程师如何优化</st> <st c="56101">他们的代码以带来</st>
    <st c="56122">成本影响！</st>
- en: <st c="56134">Green engineering – optimizing your code</st>
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="56134">绿色工程 – 优化你的代码</st>
- en: <st c="56175">Efficient</st> <st c="56185">code typically not only executes
    faster; it typically also needs less CPU, memory, and potentially less disk storage
    or network bandwidth.</st> <st c="56325">Less of everything also means less costs.</st>
    <st c="56367">So, why doesn’t everyone just produce efficient code from</st> <st
    c="56425">the start?</st>
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="56175">高效</st> <st c="56185">的代码通常不仅执行更快；它通常还需要更少的CPU、内存，甚至可能需要更少的磁盘存储或网络带宽。</st>
    <st c="56325">一切资源的减少也意味着成本的降低。</st> <st c="56367">那么，为什么不是每个人一开始就编写高效的代码呢？</st>
    <st c="56425">
- en: <st c="56435">Too often, engineers are under time pressure to deliver new features,
    or organizations haven’t invested in tools that test for and provide optimization
    recommendations as part of the software delivery life cycle.</st> <st c="56649">The
    authors have worked with many software organizations in the past and have identified
    a handful of very common patterns that result in inefficient and, therefore, costly
    code.</st> <st c="56828">Here are</st> <st c="56837">some examples:</st>
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="56435">工程师们往往面临着时间压力，需要交付新功能，或者组织没有投资能够测试并提供优化建议的工具，作为软件交付生命周期的一部分。</st>
    <st c="56649">作者们过去曾与许多软件组织合作，识别出一些非常常见的模式，这些模式导致了低效的、因此成本高昂的代码。</st> <st c="56828">以下是</st>
    <st c="56837">一些例子：</st>
- en: '**<st c="56851">Requesting too much data</st>**<st c="56876">: Instead of leveraging
    query languages to only request data needed for a certain operation, more data
    is retrieved and then filtered and processed in memory.</st> <st c="57036">This
    leads to more network traffic to transfer the data, more memory usage to store
    the data, and more CPU to iterate and filter in the</st> <st c="57172">client
    code.</st>'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="56851">请求过多数据</st>**<st c="56876">：开发人员不是利用查询语言只请求特定操作所需的数据，而是检索更多数据，然后在内存中进行过滤和处理。</st>
    <st c="57036">这导致了更多的网络流量来传输数据，更多的内存用于存储数据，以及更多的 CPU 用于在</st> <st c="57172">客户端代码中进行迭代和过滤。</st>'
- en: '**<st c="57184">Inefficient use of libraries or algorithms</st>**<st c="57227">:
    Many software libraries exist to get certain jobs done; for example,</st> **<st
    c="57299">Object Relational Mappers</st>** <st c="57324">(</st>**<st c="57326">ORMs</st>**<st
    c="57330">) to map data in databases to</st> <st c="57360">objects in a development
    language.</st> <st c="57396">Development teams unfortunately don’t always have
    the time to properly test or configure those libraries to optimize them for their
    specific use case.</st> <st c="57547">This, therefore, results in inefficient
    use, which leads to higher CPU, memory, network, and</st> <st c="57640">disk access.</st>'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="57184">低效使用库或算法</st>**<st c="57227">：许多软件库存在是为了完成某些任务；例如，</st> **<st
    c="57299">对象关系映射器</st>** <st c="57324">(</st>**<st c="57326">ORMs</st>**<st c="57330">)
    用于将数据库中的数据映射到</st> <st c="57360">开发语言中的对象。</st> <st c="57396">然而，开发团队并不总是有时间来正确测试或配置这些库，以便为特定的使用案例进行优化。</st>
    <st c="57547">因此，导致了低效的使用，进而导致更高的 CPU、内存、网络和</st> <st c="57640">磁盘访问。</st>'
- en: '**<st c="57652">Excessive logging</st>**<st c="57670">: Software engineers
    use logging frameworks to log information as their code executes.</st> <st c="57758">Logs
    are typically needed for analytics, diagnostics, and troubleshooting of failed
    or problematic code executions.</st> <st c="57874">Too often, though, logs are
    created excessively or duplicated without proper formatting or enough contextual
    information; for example, no log levels are set.</st> <st c="58032">This leads
    to overhead when logs are created but also overhead when those logs are ingested,
    transformed, and analyzed by</st> <st c="58154">observability platforms.</st>'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="57652">过度日志记录</st>**<st c="57670">：软件工程师使用日志框架来记录代码执行过程中的信息。</st>
    <st c="57758">日志通常用于分析、诊断和故障排除失败或有问题的代码执行。</st> <st c="57874">然而，日志经常被过度创建或重复记录，且没有适当的格式或足够的上下文信息；例如，未设置日志级别。</st>
    <st c="58032">这导致了在创建日志时的开销，同时也导致了当这些日志被摄取、转换和由</st> <st c="58154">可观察性平台分析时的开销。</st>'
- en: <st c="58178">There are many more</st> <st c="58199">patterns in software engineering
    that lead to performance or scalability issues.</st> <st c="58280">Apart from
    detecting patterns, architectural reviews for applications can also lead to cost
    reduction through more efficient architectures or rewritten code.</st> <st c="58438">A
    prominent example is Amazon Prime Video, which dumped its AWS distributed serverless
    architecture and moved to what is described as a</st> *<st c="58574">monolith</st>*
    <st c="58582">for its video quality analysis, which reduced infrastructure costs
    by 90%</st> *<st c="58657">[4]</st>*<st c="58660">. Ultimately, those patterns
    also mean inefficient code execution, which results in higher costs.</st> <st
    c="58758">As platform engineering teams, we have the opportunity to analyze those
    patterns using modern observability tools and bring this information back to the
    engineers to remind them not only about the costs they incur with their code but
    also where they can start optimizing, as shown in the next screenshot.</st> <st
    c="59063">These two charts show how many logs are created per service and also
    highlight which logs do not have proper configurations; for example, no log</st>
    <st c="59208">levels set:</st>
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="58178">在软件工程中，还有许多</st> <st c="58199">模式会导致性能或可扩展性问题。</st> <st c="58280">除了检测这些模式外，应用程序的架构评审还可以通过更高效的架构或重写代码来实现成本降低。</st>
    <st c="58438">一个显著的例子是亚马逊 Prime Video，它放弃了基于 AWS 的分布式无服务器架构，转而使用被描述为</st> *<st
    c="58574">单体架构</st>* <st c="58582">的视频质量分析，这样做将基础设施成本降低了 90%</st> *<st c="58657">[4]</st>*<st
    c="58660">。最终，这些模式也意味着低效的代码执行，从而导致更高的成本。</st> <st c="58758">作为平台工程团队，我们有机会利用现代可观测性工具分析这些模式，并将这些信息反馈给工程师，提醒他们不仅要关注代码带来的成本，还要告诉他们在哪里可以开始进行优化，正如下一张截图所示。</st>
    <st c="59063">这两张图表展示了每个服务创建了多少日志，并突出了哪些日志没有正确配置；例如，没有设置日志</st> <st c="59208">级别：</st>
- en: '![Figure 8.6: Providing teams with easy insights into patterns such as excessive
    logging](img/B31164_08_06.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.6：为团队提供关于过度日志等模式的简单洞察](img/B31164_08_06.jpg)'
- en: '<st c="59585">Figure 8.6: Providing teams with easy insights into patterns
    such as excessive logging</st>'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="59585">图 8.6：为团队提供关于过度日志等模式的简单洞察</st>
- en: <st c="59671">This brings me to the last part of this section, which is the
    opportunity to educate engineers and make them cost-aware from</st> <st c="59796">the
    first line of code</st> <st c="59820">they write!</st>
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="59671">这将引导我进入本节的最后部分，即为工程师提供教育机会，让他们从</st> <st c="59796">编写的第一行代码</st>
    <st c="59820">开始就意识到成本！</st>
- en: <st c="59831">The education opportunity</st>
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="59831">教育机会</st>
- en: <st c="59857">While this may not</st> <st c="59876">stand out as a top role
    of a platform engineering team, as engineering teams use our platforms to deploy
    their applications as self-service , we can use that platform to also educate
    everyone about the cost impact they have when using the platform to get their
    software</st> <st c="60147">services deployed.</st>
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="59857">尽管这可能不会</st> <st c="59876">成为平台工程团队的主要职责，但由于工程团队使用我们的平台作为自助服务来部署他们的应用程序，我们可以利用这个平台来教育每个人，提醒他们在使用平台部署软件</st>
    <st c="60147">服务时所产生的成本影响。</st>
- en: <st c="60165">In the previous sections, we already highlighted use cases such
    as sending cost and usage reports to engineering teams or identifying and highlighting
    inefficient code patterns.</st> <st c="60344">The key enabler to this is proper
    tagging (for example, who owns which part of the infrastructure and applications),
    as well as good observability (for example, which systems use how much CPU, memory,
    network, etc.).</st> <st c="60561">Having this information allows platform engineering
    teams to push this data to teams proactively and, with this, show them continuously
    what cost impact their applications have.</st> <st c="60739">Doing this continuously
    will also result in an educational effect that will lead to engineers having a
    better upfront understanding of</st> <st c="60874">the cost impact their</st>
    <st c="60896">actions have.</st>
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="60165">在之前的部分中，我们已经强调了使用案例，比如向工程团队发送成本和使用报告，或识别和突出低效的代码模式。</st> <st c="60344">实现这一目标的关键是正确的标签（例如，谁拥有基础设施和应用程序的哪一部分），以及良好的可观测性（例如，哪些系统使用了多少
    CPU、内存、网络等）。</st> <st c="60561">拥有这些信息，平台工程团队可以主动将这些数据推送给各团队，并借此持续展示他们的应用程序带来的成本影响。</st>
    <st c="60739">持续进行这一过程还将产生教育效果，使工程师能够更清楚地了解</st> <st c="60874">他们行为的成本影响。</st>
    <st c="60896">行为的成本影响。</st>
- en: <st c="60909">Summary</st>
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="60909">总结</st>
- en: <st c="60917">In this chapter, you should have developed a sense of costs and
    had ideas on how you can address this topic on your platform.</st> <st c="61044">Good
    platforms provide transparency for their user and enable the use of flexible options
    to adjust their workload for different triggers.</st> <st c="61183">At this point,
    you should be able to combine the learned approaches from previous chapters, such
    as dynamic resource allocation with GPUs, to create high utilization and optimal</st>
    <st c="61361">cost allocation.</st>
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="60917">在本章中，你应该已经培养了对成本的敏感度，并且有了如何在你的平台上处理这个话题的想法。</st> <st c="61044">优秀的平台为用户提供透明度，并提供灵活的选项以根据不同触发条件调整工作负载。</st>
    <st c="61183">此时，你应该能够结合前几章学到的方法，如动态资源分配与 GPU 配合使用，以实现高利用率和最佳</st> <st c="61361">成本分配。</st>
- en: <st c="61377">Remember that the cost perspective alone isn’t enough to reduce
    overall platform costs, as some reductions in server sizes might increase the
    demand on multiple small ones due to other limitations that cloud providers have.</st>
    <st c="61602">A tagging strategy builds the core for control and transparency.</st>
    <st c="61667">What sounds easy can end in many organizational discussions.</st>
    <st c="61728">To optimize your costs, you can also leverage other elements such
    as processes, and agree on long-term commitments to get better</st> <st c="61857">pricing
    deals.</st>
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="61377">记住，仅仅从成本角度来看并不足以降低整体平台成本，因为一些服务器尺寸的减少可能会因为云提供商的其他限制而增加对多个小型服务器的需求。</st>
    <st c="61602">标签策略为控制和透明度奠定了基础。</st> <st c="61667">看似简单的事情可能最终会导致许多组织讨论。</st>
    <st c="61728">为了优化成本，你还可以利用其他元素，如流程，并达成长期承诺，以获得更好的</st> <st c="61857">定价优惠。</st>
- en: <st c="61871">Finally, we gave you some practical examples and best practices
    for your platform to include.</st> <st c="61966">We caught up on the different
    approaches of scaling and the difference between predictive and reactive scaling,
    and shone a light on other scaling factors besides CPU, such as memory</st> <st
    c="62149">and storage.</st>
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="61871">最后，我们为你的平台提供了一些实际的示例和最佳实践。</st> <st c="61966">我们回顾了不同的扩展方法，以及预测性扩展与反应性扩展之间的区别，并重点讨论了除
    CPU 之外的其他扩展因素，如内存</st> <st c="62149">和存储。</st>
- en: <st c="62161">To summarize, when you think rationally and treat the money you
    spend on the platform like it is your own, then you can become very cost-efficient.</st>
    <st c="62310">As a platform engineering team, you could also develop a metric
    to define how efficient the platform is to be able to agree with your management
    on using this free budget for further investments and optimizations.</st> <st
    c="62524">Remember that even though the cloud gives us an</st> *<st c="62572">unlimited</st>*
    <st c="62581">amount of resources, we don’t have to take all of them just because
    they</st> <st c="62655">are there.</st>
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="62161">总结一下，当你理性思考并将你在平台上花费的钱视为自己的钱时，你就能变得非常具有成本效益。</st> <st c="62310">作为一个平台工程团队，你还可以制定一个度量标准，定义平台的效率，以便与你的管理层达成一致，使用这部分免费预算进行进一步的投资和优化。</st>
    <st c="62524">记住，尽管云给我们提供了一个</st> *<st c="62572">无限的</st>* <st c="62581">资源量，我们不必仅仅因为这些资源</st>
    <st c="62655">存在就全部使用它们。</st>
- en: <st c="62665">Let us head straight to our final chapter.</st> <st c="62709">As
    we already said earlier, the only consistency is inconstancy.</st> <st c="62774">In
    our last chapter, we will therefore talk about continuous change and how to survive
    it, considering lightweight architectures motivated by sustainable ideas and the
    golden path for changes.</st> <st c="62967">To close the chapter, we dare to take
    a look into the crystal ball and cover some technological trends that may or may
    not be</st><st c="63092">come relevant within the</st> <st c="63118">next years.</st>
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="62665">让我们直接进入最后一章。</st> <st c="62709">正如我们之前所说，唯一的不变就是不变。</st> <st c="62774">在我们最后一章中，我们将讨论持续变化以及如何在轻量架构和可持续理念的推动下生存，并探索变革的黄金路径。</st>
    <st c="62967">为了结束本章，我们敢于展望未来，讨论一些可能或可能不会在</st> <st c="63092">未来几年内变得相关的</st>
    <st c="63118">技术趋势。</st>
- en: <st c="63129">Further reading</st>
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="63129">进一步阅读</st>
- en: <st c="63145">[1] Why we left the cloud – David</st> <st c="63180">Heinemeier
    Hansson:</st>
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="63145">[1] 我们为何离开云端 – 大卫</st> <st c="63180">海内梅尔·汉森：</st>
- en: '[<st c="63199">https://world.hey.com/dhh/we-have-left-the-cloud-251760fb</st>](https://world.hey.com/dhh/we-have-left-the-cloud-251760fb)'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[<st c="63199">https://world.hey.com/dhh/we-have-left-the-cloud-251760fb</st>](https://world.hey.com/dhh/we-have-left-the-cloud-251760fb)'
- en: '[<st c="63257">https://world.hey.com/dhh/the-hardware-we-need-for-our-cloud-exit-has-arrived-99d66966</st>](https://world.hey.com/dhh/the-hardware-we-need-for-our-cloud-exit-has-arrived-99d66966)'
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[<st c="63257">https://world.hey.com/dhh/the-hardware-we-need-for-our-cloud-exit-has-arrived-99d66966</st>](https://world.hey.com/dhh/the-hardware-we-need-for-our-cloud-exit-has-arrived-99d66966)'
- en: <st c="63344">[2] FinOps Framework high-resolution</st> <st c="63382">poster:</st>
    [<st c="63390">https://www.finops.org/wp-content/uploads/2024/03/FinOps-Framework-Poster-v4.pdf</st>](https://www.finops.org/wp-content/uploads/2024/03/FinOps-Framework-Poster-v4.pdf)
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="63344">[2] FinOps 框架高清</st> <st c="63382">海报：</st> [<st c="63390">https://www.finops.org/wp-content/uploads/2024/03/FinOps-Framework-Poster-v4.pdf</st>](https://www.finops.org/wp-content/uploads/2024/03/FinOps-Framework-Poster-v4.pdf)
- en: <st c="63470">[3] Cloud</st> <st c="63481">Custodian:</st> [<st c="63492">https://cloudcustodian.io/</st>](https://cloudcustodian.io/)
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="63470">[3] 云端</st> <st c="63481">托管人：</st> [<st c="63492">https://cloudcustodian.io/</st>](https://cloudcustodian.io/)
- en: <st c="63518">[4] Prime Video cost</st> <st c="63540">optimization:</st> [<st
    c="63554">https://www.thestack.technology/amazon-prime-video-microservices-monolith/</st>](https://www.thestack.technology/amazon-prime-video-microservices-monolith/)
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="63518">[4] Prime Video 成本</st> <st c="63540">优化：</st> [<st c="63554">https://www.thestack.technology/amazon-prime-video-microservices-monolith/</st>](https://www.thestack.technology/amazon-prime-video-microservices-monolith/)
