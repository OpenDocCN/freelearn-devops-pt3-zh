- en: 'Chapter 4: Filesystem Interactions'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：文件系统交互
- en: A fundamental part of any developer's life is interacting with **files**. They
    represent data that must be processed and configured for our systems, cached items
    can be served, and many other uses.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 每个开发者生活中的一个基本部分就是与**文件**的交互。文件代表了必须处理和配置的系统数据，缓存项可以被提供，还有许多其他用途。
- en: One of Go's strongest features is its abstraction of **file interfaces**, which
    allows a common set of tools to interact with streams of data from disks and networks.
    These interfaces set a common standard that all major packages use to export their
    data streams. Moving from one to another just becomes an exercise in accessing
    the **filesystem** with the necessary credentials.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Go 最强大的特点之一就是它对**文件接口**的抽象，使得一套通用工具能够与来自磁盘和网络的数据流交互。这些接口设定了一个共同标准，所有主要包都使用它们来导出数据流。不同接口间的转换变成了一个简单的任务，只需用必要的凭证访问**文件系统**即可。
- en: Packages related to specific data formats, such as CSV, JSON, YAML, TOML, and
    XML, build on these common file interfaces. These packages use the interfaces
    defined by the standard library to read these types of files from disk or HTTP
    streams.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 与特定数据格式相关的包，如 CSV、JSON、YAML、TOML 和 XML，基于这些通用的文件接口构建。这些包使用标准库定义的接口从磁盘或 HTTP
    流中读取这些类型的文件。
- en: Because Go is multiplatform, you may want to write software that can work on
    different OSs. Go provides packages that allow you to detect the OS and its packages
    to handle differences in OS pathing.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Go 是跨平台的，你可能希望编写能够在不同操作系统上运行的软件。Go 提供了可以检测操作系统并处理操作系统路径差异的包。
- en: 'In this chapter, we are going to cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将覆盖以下主题：
- en: All I/O in Go are files
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Go 中的所有 I/O 都是文件
- en: Reading and writing to files
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取和写入文件
- en: Streaming file content
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流式文件内容
- en: OS-agnostic pathing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨操作系统路径
- en: OS-agnostic filesystems
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨操作系统文件系统
- en: After completing this chapter, you should have a set of skills for interacting
    with data that's stored in a wide variety of mediums, which will be useful in
    your everyday life as a DevOps engineer.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章内容后，你应当掌握一套与各种介质中存储的数据交互的技能，这对你作为 DevOps 工程师的日常工作非常有帮助。
- en: All I/O in Go are files
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go 中的所有 I/O 都是文件
- en: Go provides an **input-output** (**I/O**) system based on files. This should
    come as no surprise since Go is the brainchild of two prominent engineers, Rob
    Pike and Ken Thompson, who, while at *Bell Labs*, designed the UNIX and Plan 9
    operating systems – both of which treat (almost) everything as a file.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Go 提供了一个基于文件的**输入输出**（**I/O**）系统。这一点并不令人惊讶，因为 Go 是两位杰出工程师 Rob Pike 和 Ken Thompson
    的心血结晶，他们在 *贝尔实验室* 时设计了 UNIX 和 Plan 9 操作系统——这两个系统几乎把所有事物都视作文件。
- en: Go provides the `io` package, which contains interfaces to interact with I/O
    primitives such as disk files, remote files, and network services.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: Go 提供了 `io` 包，其中包含与 I/O 基本操作进行交互的接口，如磁盘文件、远程文件和网络服务。
- en: I/O interfaces
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: I/O 接口
- en: The basic block of I/O is `byte`, an 8-bit value. I/O uses streams of bytes
    to allow you to read and write. With some I/Os, you can only read from beginning
    to end as you process the stream (such as network I/O). Some I/Os, such as disks,
    allow you to *seek* something in the file.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: I/O 的基本单元是 `byte`，一个 8 位值。I/O 使用字节流来实现读写操作。对于某些 I/O，你只能按顺序从头到尾读取流（如网络 I/O）。一些
    I/O，如磁盘，允许你在文件中进行*定位*。
- en: Some common operations that we perform when we interact with a byte stream include
    reading, writing, seeking a location in a byte stream, and closing a stream when
    we have finished our work.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在与字节流交互时进行的一些常见操作包括读取、写入、在字节流中定位某个位置，以及在完成工作后关闭流。
- en: 'Go provides the following interfaces for these basic operations:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Go 为这些基本操作提供了以下接口：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `io` package also contains composite interfaces such as `ReadWriter` and
    `ReadWriteCloser`. These interfaces are common in packages that allow you to interact
    with files or networks. These interfaces allow you to use common tooling that
    uses these interfaces, regardless of what is underneath (such as a local filesystem,
    remote filesystem, or an HTTP connection).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`io` 包还包含复合接口，如 `ReadWriter` 和 `ReadWriteCloser`。这些接口在允许与文件或网络交互的包中很常见。通过这些接口，你可以使用常见的工具，无论底层是什么（例如本地文件系统、远程文件系统或
    HTTP 连接）。'
- en: In this section, we have learned that Go file interaction is based on the `[]byte`
    type and introduced the basic interfaces for I/O. Next, we will learn about reading
    and writing files using methods that utilize these interfaces.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经了解到Go文件交互是基于`[]byte`类型的，并介绍了基本的I/O接口。接下来，我们将学习如何利用这些接口的方法来读取和写入文件。
- en: Reading and writing to files
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取和写入文件
- en: 'The most common scenario in DevOps tooling is the need to manipulate files:
    *reading*, *writing*, *reformatting*, or *analyzing* the data in those files.
    These files could be in many formats – JSON, YAML, XML, CSV, and others that are
    probably familiar to you. They are used to configure both local services and to
    interact with your cloud network provider.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在DevOps工具中最常见的场景是需要操作文件：*读取*、*写入*、*重新格式化*或*分析*这些文件中的数据。这些文件可以有多种格式——JSON、YAML、XML、CSV等格式，应该都对你来说并不陌生。它们用于配置本地服务以及与云网络提供商进行交互。
- en: In this section, we will cover the basics of reading and writing entire files.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍读取和写入整个文件的基础知识。
- en: Reading local files
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取本地文件
- en: 'Let''s start by reading a configuration file on a local disk by using the `os.Readfile()`
    function:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始使用`os.Readfile()`函数读取本地磁盘上的配置文件：
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `ReadFile()` method reads the location from its function parameter and returns
    that file's content. That return value is then stored in the data variable. An
    error is returned if the file cannot be read. For a refresher on errors, see the
    *Handling errors in Go* section in [*Chapter 2*](B17626_02.xhtml#_idTextAnchor166),
    *Go Language Essentials*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadFile()`方法从其函数参数中读取文件位置并返回该文件的内容。返回值会存储在data变量中。如果文件无法读取，则会返回一个错误。有关错误处理的更多信息，请参阅[*第2章*](B17626_02.xhtml#_idTextAnchor166)中关于*Go中的错误处理*部分，*Go语言基础*。'
- en: '`ReadFile()` is a helper function that calls `os.Open()` and retrieves an `io.Reader`.
    The `io.ReadAll()` function is used to read the entire content of `io.Reader`.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`ReadFile()`是一个辅助函数，它调用`os.Open()`并获取一个`io.Reader`。`io.ReadAll()`函数用于读取`io.Reader`的全部内容。'
- en: '`data` is of the `[]byte` type, so if you would like to use it as a `string`,
    you can simply convert it into one by using `s := string(data)`. This is called
    *type conversion*, where we convert from one type into another. In Go, you can
    only convert certain types from one into another. The full list of conversion
    rules can be found at [https://golang.org/ref/spec#Conversions.strings](https://golang.org/ref/spec#Conversions.strings)
    can be converted back into bytes with `b := []byte(s)`. Most other types require
    a package called `strconv` to be converted into strings ([https://pkg.go.dev/strconv](https://pkg.go.dev/strconv)).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`data`是`[]byte`类型，因此如果你想将其作为`string`使用，可以通过` s := string(data)`简单地将其转换成字符串。这被称为*类型转换*，即我们将一种类型转换为另一种类型。在Go中，只有某些类型可以进行转换。关于转换规则的完整列表，可以在[https://golang.org/ref/spec#Conversions.strings](https://golang.org/ref/spec#Conversions.strings)中找到。可以使用`b
    := []byte(s)`将其转换回字节数组。其他大多数类型则需要使用一个叫做`strconv`的包来进行字符串转换（[https://pkg.go.dev/strconv](https://pkg.go.dev/strconv)）。'
- en: If the data that's represented in the file is of a common format such as JSON
    or YAML, then we can retrieve and write that data efficiently.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果文件中表示的数据是JSON、YAML等常见格式，那么我们可以高效地检索和写入这些数据。
- en: Writing local files
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写入本地文件
- en: 'The most common way to write to local disk is by using `os.Writefile()`. This
    writes a complete file to disk. `WriteFile` will create the file if necessary
    and truncate the file if it exists:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 写入本地磁盘最常见的方式是使用`os.Writefile()`。这个方法会将整个文件写入磁盘。如果必要，`WriteFile`会创建文件，并且如果文件已存在，会将其截断：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code writes data to `path/to/fi` with Unix-like permissions, `0644`.
    If you have not seen Unix-like permissions before, a quick internet search will
    help you with these.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码以Unix风格的权限`0644`将数据写入`path/to/fi`。如果你之前没接触过Unix风格的权限，快速查阅一下网络资料就能帮助你理解。
- en: If your data is stored in a `string`, you can simply convert it into`[]byte`
    by doing`[]byte(data)`. `WriteFile()` is a wrapper around `os.OpenFile()` that
    handles file flags and modes for you while closing the file after the write is
    complete.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的数据存储在`string`中，可以通过`[]byte(data)`轻松地将其转换为`[]byte`。`WriteFile()`是一个封装了`os.OpenFile()`的函数，它处理文件标志和模式，并在写入完成后关闭文件。
- en: Reading remote files
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取远程文件
- en: The way the remote file is read is going to be implementation-dependent. However,
    these concepts will still be built on the `io` interfaces we discussed earlier.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 远程文件的读取方式将取决于具体的实现。不过，这些概念仍然会基于我们之前讨论的`io`接口。
- en: 'For example, let''s say that we want to connect to a text file that is stored
    on an HTTP server, to collect common text-formatted information such as application
    metrics. We can connect to that server and retrieve the file in a way that''s
    very similar to what was shown in the preceding example:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们想连接到一个存储在HTTP服务器上的文本文件，以收集常见的文本格式信息，比如应用程序的指标数据。我们可以连接到该服务器，并以一种与前面示例非常相似的方式检索该文件：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As you can see, the setup to get our `io.ReadCloser` depends on our I/O target,
    but what it returns is just an interface from the `io` package that we can use
    with any function that supports those interfaces.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，获取`io.ReadCloser`的设置依赖于我们的I/O目标，但它返回的只是`io`包中的接口，我们可以在任何支持这些接口的函数中使用。
- en: Because it uses `io` interfaces, we can do slick things such as stream the content
    directly to a local file instead of copying the entire file into memory and writing
    it to disk. This is faster and more memory efficient as each chunk that is read
    is then immediately written to disk.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因为它使用了`io`接口，我们可以做一些非常巧妙的操作，比如将内容直接流式传输到本地文件，而不是将整个文件复制到内存中再写入磁盘。这种方式更快且更加节省内存，因为每次读取的内容都会立即写入磁盘。
- en: 'Let''s use `os.OpenFile()` to open a file for writing and stream the content
    from the web server into the file:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用`os.OpenFile()`打开一个文件进行写入，并将内容从网页服务器流式传输到文件中：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`OpenFile()` is the more complex method of opening a file when you need to
    either write to a file or be more specific with how you interact with it. You
    should use `os.Open()` when you just want to read from a local file. Our flags
    here are the standard Unix-like bitmasks that do the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`OpenFile()`是一个更复杂的文件打开方法，适用于你需要写入文件或更精确地控制文件操作的情况。如果你只需要从本地文件读取数据，应该使用`os.Open()`。这里的标志是标准的类Unix位掩码，其作用如下：'
- en: 'Create the file if it doesn''t exist: `os.O_CREATE`.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文件不存在，则创建该文件：`os.O_CREATE`。
- en: 'Write to a file: `os.O_WRONLY`.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向文件写入数据：`os.O_WRONLY`。
- en: 'If the file exists, truncate it versus append to it: `os.O_TRUNC`.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果文件已存在，则截断文件而不是追加：`os.O_TRUNC`。
- en: 'A list of flags can be found here: [https://pkg.go.dev/os#pkg-constants](https://pkg.go.dev/os#pkg-constants).'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 标志列表可以在这里找到：[https://pkg.go.dev/os#pkg-constants](https://pkg.go.dev/os#pkg-constants)。
- en: '`io.Copy()` reads from `io.Reader` and writes to `io.Writer` until `Reader`
    is empty. This copies the file from the HTTP server to the local disk.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`io.Copy()`从`io.Reader`读取并写入`io.Writer`，直到`Reader`为空。这将文件从HTTP服务器复制到本地磁盘。'
- en: In this section, you learned how to read an entire file using `os.ReadFile()`,
    how to type convert a `[]byte` into a `string`, and how to write an entire file
    to disk using `os.WriteFile()`. We also learned about the differences between
    `os.Open()` and `os.OpenFile()` and showed you how to use utility functions such
    as `io.Copy()` and `io.ReadAll()`. Finally, we learned how HTTP clients expose
    their data streams as `io` interfaces that can be read using these same tools.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你学习了如何使用`os.ReadFile()`读取整个文件，如何将`[]byte`类型转换为`string`，以及如何使用`os.WriteFile()`将整个文件写入磁盘。我们还了解了`os.Open()`与`os.OpenFile()`之间的区别，并展示了如何使用像`io.Copy()`和`io.ReadAll()`这样的实用函数。最后，我们学习了HTTP客户端如何将数据流暴露为`io`接口，并通过这些相同的工具读取数据。
- en: Next, we will look at interacting with these file interfaces as streams instead
    of reading and writing entire files.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看如何将这些文件接口作为流来操作，而不是一次性读取和写入整个文件。
- en: Streaming file content
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流式传输文件内容
- en: In the previous sections, we learned how to read and write in large blocks using
    `os.ReadFile()` and `os.WriteFile()`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们学习了如何使用`os.ReadFile()`和`os.WriteFile()`以大块数据进行读取和写入。
- en: This works well when the files are small, which is usually the case when you're
    doing DevOps automation. However, sometimes, the files we want to read are very
    large – in most cases, you wouldn't want to read a 2 GiB file into memory. In
    those cases, we want to stream the contents of the file in manageable chunks that
    we can operate on while keeping memory usage low.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当文件较小时，这种方式效果很好，通常在进行DevOps自动化时会遇到这种情况。然而，有时我们想读取的文件非常大——在大多数情况下，你不会希望将一个2 GiB的文件全部读入内存。在这种情况下，我们希望以可管理的块流式传输文件内容，这样我们可以在保持较低内存使用的同时进行操作。
- en: 'The most basic version of this was shown in the previous section. There, we
    used two streams to copy a file: `io.ReadCloser` from the HTTP client and `io.WriteCloser`
    for writing to local disk. We used the `io.Copy()` function to copy from the network
    file to the disk file.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这种最基本的版本在上一节中已经展示过。在那里，我们使用了两个流来复制文件：`io.ReadCloser`来自HTTP客户端，`io.WriteCloser`用于写入本地磁盘。我们使用了`io.Copy()`函数来将网络文件复制到磁盘文件。
- en: Go's `io` interfaces also allow us to stream files to copy content, search for
    content, manipulate input to output, and more.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Go的`io`接口还允许我们流式处理文件，复制内容，搜索内容，操作输入输出等。
- en: Stdin/Stdout/Stderr are just files
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Stdin/Stdout/Stderr 只是文件
- en: Throughout this book, you will see us writing to the console using `fmt.Println()`
    or `fmt.Printf()`, two functions from the `fmt` package. Those functions are reading
    and writing to files that represent the terminal.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，你会看到我们使用`fmt.Println()`或`fmt.Printf()`这两个来自`fmt`包的函数来向控制台写入数据。这些函数实际上是向表示终端的文件读写数据。
- en: Those functions use an `io.Writer` called `os.Stdout`. When we use the same
    functions in the `log` package, we are usually writing to `os.Stderr`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数使用一个名为`os.Stdout`的`io.Writer`。当我们在`log`包中使用相同的函数时，通常是向`os.Stderr`写入数据。
- en: 'You can use the same interfaces we''ve been using to read/write to other files
    to also read/write to these files. When we want to copy a file and output its
    content to the terminal, we can do the following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用我们一直在使用的相同接口来读写其他文件，也来读写这些文件。当我们想要复制一个文件并将其内容输出到终端时，我们可以这样做：
- en: '[PRE5]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: While we won't go into the details, `os.Stdin` is simply an `io.Reader`. You
    can read from it using the `io` and `bufio` packages.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们不会详细探讨，`os.Stdin`只是一个`io.Reader`。你可以使用`io`和`bufio`包从中读取数据。
- en: Reading data out of a stream
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从流中读取数据
- en: What if we wanted to read a stream that represented user records and return
    them on a channel?
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想读取一个表示用户记录的流，并通过通道返回它们，该怎么办呢？
- en: Let's say the records are simple `<user>:<id>` text and each record was delimited
    by the new line character (`\n`). These records might be stored on an HTTP server
    or a local disk. This doesn't matter to us because it is simply a stream behind
    an interface. Let's assume that we receive this as an `io.Reader`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 假设记录是简单的`<user>:<id>`文本，每条记录由换行符（`\n`）分隔。这些记录可能存储在HTTP服务器或本地磁盘上。这对我们来说并不重要，因为它只是一个接口背后的流。假设我们接收到这个流作为一个`io.Reader`。
- en: 'First, we will define a `User` struct:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将定义一个`User`结构体：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, let’s define a function that can split a line we receive:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们定义一个函数，来拆分我们接收到的每一行：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`getUser()` takes a string and returns a `User`. We use the `strings` package''s
    `Split()` function to split the string into a `[]string` while using `:` as the
    divider.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`getUser()`接收一个字符串并返回一个`User`。我们使用`strings`包的`Split()`函数将字符串按`:`作为分隔符拆分成`[]string`。'
- en: '`Split()` should return two values; if not, then we return an error.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Split()`应该返回两个值；如果不是，我们将返回一个错误。'
- en: Since we are splitting a string, our user ID is stored as a `string`. But we
    want to use the integer value in our `User` record. Here, we can use the `strconv`
    package's `Atoi()` method to convert the string version of the number into an
    integer. If it is not an integer, then the entry is bad, and we return an error.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在拆分字符串，用户 ID 被存储为`string`类型。但我们希望在`User`记录中使用整数值。在这里，我们可以使用`strconv`包的`Atoi()`方法，将字符串形式的数字转换为整数。如果它不是整数，则说明输入无效，我们将返回一个错误。
- en: 'Now, let''s create a function that reads in the stream and writes the `User`
    records to a channel:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个函数，读取流并将`User`记录写入通道：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we are using the `bufio` package's `Scanner` type. `Scanner` allows us
    to take an `io.Reader` and scan it until we find a delimiter. By default, this
    is `\n`, though you can change this using the `.Split()` method. `Scan()` will
    return `true` until we reach the end of the Reader's output. Note that `io.Reader`
    returns an error, `io.EOF`, when it reaches the end of the stream.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用的是`bufio`包的`Scanner`类型。`Scanner`允许我们获取一个`io.Reader`并扫描它，直到找到分隔符。默认情况下，分隔符是`\n`，但你可以使用`.Split()`方法来更改它。`Scan()`将在读取器输出结束前一直返回`true`。请注意，当`io.Reader`到达流的末尾时，会返回一个错误`io.EOF`。
- en: After each `Scan()` call, the scanner stores the bytes read, which you can retrieve
    as a `string` using `.Text()`. The content in `.Text()` changes each time `.Scan()`
    is called. Also, note that we check our `Context` object and stop its execution
    if it's canceled.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`Scan()`后，扫描器会存储读取的字节，你可以通过`.Text()`方法将其作为`string`提取出来。`.Text()`中的内容会在每次调用`.Scan()`时发生变化。同时，请注意，我们会检查`Context`对象，如果它被取消，则停止执行。
- en: We pass the content of that `string` to our previously defined `getUser()`.
    If we receive an `error`, we return it in the `User` record to inform the caller
    of the error. Otherwise, we return our `User` record with all the information.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将该`string`的内容传递给我们之前定义的`getUser()`。如果我们收到一个`error`，我们将把它返回给`User`记录，以通知调用者错误。否则，我们返回包含所有信息的`User`记录。
- en: 'Now, let''s invoke this against a file:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们对一个文件进行调用：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we open our file on disk and pass it to `decodeUsers()`. We receive a
    `User`record from the *output channel* and we print the user to the screen concurrently
    while reading the file stream.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们打开磁盘上的文件并将其传递给`decodeUsers()`。我们从*输出通道*接收一个`User`记录，并在读取文件流的同时并发地将用户打印到屏幕上。
- en: 'Instead of using `os.Open()`, we could have opened the file via `http.Client`
    and passed it to `decodeUsers()`. The complete code can be found here: [https://play.golang.org/p/OxehTsHT6Qj](https://play.golang.org/p/OxehTsHT6Qj).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以通过`http.Client`打开文件并将其传递给`decodeUsers()`，而不是使用`os.Open()`。完整的代码可以在这里找到：[https://play.golang.org/p/OxehTsHT6Qj](https://play.golang.org/p/OxehTsHT6Qj)。
- en: Writing data into a stream
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向流写入数据
- en: 'Writing to a stream is even simpler – we just convert our `User` into a `string`
    and write it to an `io.Writer`. This looks as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 向流写入数据更加简单——我们只需将`User`转换为`string`并将其写入`io.Writer`。如下所示：
- en: '[PRE10]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here, we have taken in an `io.Writer` that represents the place to write to
    and a `User` record that we want to write into that output. We can use this to
    write to a file on disk:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们接受一个`io.Writer`，它代表了写入的目标位置，以及一个我们想写入该输出的`User`记录。我们可以使用它将数据写入磁盘上的文件：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here, we opened a file on our local disk. When our containing function (not
    shown) returns, the file will be closed. Then, we wrote the `User` records stored
    in variable users (`[]Users`) one at a time to the file. Finally, we wrote a carriage
    return, `("\n")`, before every record except the first one.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们打开了本地磁盘上的一个文件。当我们包含的函数（未显示）返回时，文件将被关闭。然后，我们将存储在变量users（`[]Users`）中的`User`记录逐个写入文件。最后，我们在每条记录之前（除了第一条记录）写入了一个回车符`("\n")`。
- en: 'You can see this in action here: [https://play.golang.org/p/bxuFyPT5nSk](https://play.golang.org/p/bxuFyPT5nSk).
    We have provided a streaming version of this using channels that you can find
    here: [https://play.golang.org/p/njuE1n7dyOM](https://play.golang.org/p/njuE1n7dyOM).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在这里查看实际演示：[https://play.golang.org/p/bxuFyPT5nSk](https://play.golang.org/p/bxuFyPT5nSk)。我们提供了一个使用通道的流式版本，您可以在这里找到：[https://play.golang.org/p/njuE1n7dyOM](https://play.golang.org/p/njuE1n7dyOM)。
- en: In the next section, we'll learn how to use the `path/filepath` package to write
    software that works on multiple OSs that use different path delimiters.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将学习如何使用`path/filepath`包编写适用于多个操作系统的软件，这些操作系统使用不同的路径分隔符。
- en: OS-agnostic pathing
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作系统无关的路径处理
- en: One of Go's greatest strengths lies in its multiplatform support. A developer
    can develop on a Linux workstation and run the same Go program, recompiled into
    native code, on a Windows server.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言的一个最大优势是其多平台支持。开发人员可以在Linux工作站上开发，并将相同的Go程序重新编译为本地代码后，在Windows服务器上运行。
- en: 'One of the areas of difficulty when developing software that runs on multiple
    OSs is *accessing files*. Path formats are slightly different for each operating
    system. The most obvious example is the different file separators for OSs: `\`
    on Windows and `/` on Unix-like systems. Less obvious would be how to escape special
    characters on a particular OS, which can differ even between Unix-based OSs.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 开发跨多个操作系统运行的软件时，*访问文件*是一个难点。每个操作系统的路径格式稍有不同。最明显的例子是不同操作系统的文件分隔符：Windows上是`\`，而类Unix系统上是`/`。更不明显的是如何在特定操作系统上转义特殊字符，甚至在Unix类操作系统之间也可能有所不同。
- en: The `path/filepath` package provides access to functions that will allow you
    to handle pathing for the native OS. This should not be confused with the root
    `path` package, which looks similar but handles a more general URL-style pathing.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`path/filepath`包提供了访问函数的功能，允许您处理本地操作系统的路径。这不应与根`path`包混淆，后者看起来类似，但处理的是更通用的URL样式路径。'
- en: What OS/platform am I running?
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我正在运行哪个操作系统/平台？
- en: While we will discuss how to gain file access and perform pathing using agnostic
    functions, it is still important to understand what OS you are running on. You
    may use different locations for files based on the OS you are running.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们将讨论如何使用无关操作系统的函数获取文件访问权限并执行路径处理，但了解您运行的操作系统仍然非常重要。您可能会根据运行的操作系统使用不同的文件位置。
- en: 'Using the `runtime` package, you can detect the OS and platform you are running
    on:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`runtime`包，您可以检测到您运行的操作系统和平台：
- en: '[PRE12]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This gives you the running OS. We can print out the current list of OS types
    and hardware architecture that's supported by Go with **go tool dist list**.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为您提供正在运行的操作系统。我们可以使用**go tool dist list**命令打印出Go支持的当前操作系统类型和硬件架构列表。
- en: Using filepath
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用filepath
- en: 'With **filepath**, you can be ignorant of the pathing rules for the OS you
    are running on when manipulating a path. Paths are divided into the following
    areas:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**filepath**，在处理路径时可以忽略所在操作系统的路径规则。路径被分为以下几个部分：
- en: The **directories** in the path
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径中的**目录**
- en: The **file** in the path
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径中的**文件**
- en: A file path's final directory or file is called the **base**. The path your
    binary is running in is called the **working directory**.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 文件路径的最终目录或文件称为**基础路径**。你的二进制文件运行所在的路径称为**工作目录**。
- en: Joining a file path
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接文件路径
- en: 'Let''s say we want to access a configuration file, `config.json`, that is stored
    in the `config/` directory, which is in the same directory as our binary. Let''s
    use `os` and `path/filepath` to read that file in a way that works on all OSs:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '假设我们想访问一个名为`config.json`的配置文件，它存储在与我们的二进制文件相同目录下的`config/`目录中。让我们使用`os`和`path/filepath`以一种适用于所有操作系统的方式来读取该文件： '
- en: '[PRE13]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, the first thing we do is get the working directory. This allows
    us to make calls relative to where our binary is running.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们首先获取工作目录。这允许我们相对于我们的二进制文件所在位置进行调用。
- en: '`filepath.Join()` allows us to join the components of our path into a single
    path. This fills in the OS-specific directory separators for you and uses the
    native pathing rules. On a Unix-like system, this might be `/home/jdoak/bin/config/config.json`,
    while on Windows, this might be `C:\Documents and Settings\jdoak\go\bin\config\config.json`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`filepath.Join()` 允许我们将路径的各个组成部分连接成一个单一的路径。它会为你填充操作系统特定的目录分隔符，并使用本地的路径规则。在类
    Unix 系统上，可能是 `/home/jdoak/bin/config/config.json`，而在 Windows 上，则可能是 `C:\Documents
    and Settings\jdoak\go\bin\config\config.json`。'
- en: Splitting a file path
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 拆分文件路径
- en: 'In some circumstances, it is important to split filepaths along their path
    separators in different ways. `filepath` provides the following:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，根据路径分隔符将文件路径拆分开来是很重要的。`filepath` 提供了以下功能：
- en: '`Base()`: Returns the last element of the path'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Base()`: 返回路径的最后一个元素'
- en: '`Ext()`: Returns the file extension, if it has one'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ext()`: 返回文件扩展名（如果有）'
- en: '`Split()`: Returns the split directory and file'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Split()`: 返回分割后的目录和文件'
- en: We can use these to get various parts of a path. This can be useful when we
    wish to copy a file into another directory while retaining the file's name.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些来获取路径的各个部分。当我们希望将文件复制到另一个目录并保留文件名时，这可能会很有用。
- en: 'Let''s copy a file from its location to our OS''s **TMPDIR**:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将一个文件从其位置复制到我们操作系统的**TMPDIR**：
- en: '[PRE14]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, it's time to look at the different pathing options you can use to reference
    files and how the `filepath` package can help.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候看一下可以用来引用文件的不同路径选项，以及`filepath`包如何帮助你了。
- en: Relative and absolute pathing
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相对和绝对路径处理
- en: 'There are two types of pathing when it comes to accessing a filesystem:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 访问文件系统时有两种类型的路径处理方式：
- en: '**Absolute pathing**: Pathing from the root directory to the file'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绝对路径**: 从根目录到文件的路径处理'
- en: '**Relative pathing**: Pathing from your current location in the filesystem'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相对路径**: 在文件系统中从当前位置进行路径处理'
- en: During development, it is often handy to convert a relative path into an absolute
    path and vice versa.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，将相对路径转换为绝对路径及其反向转换通常很方便。
- en: '`filepath` provides a few functions to help with this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`filepath` 提供了几个函数来帮助处理这些问题：'
- en: '`Abs()`: Returns the absolute path. If it''s not an absolute path, return the
    working directory, as well as the path.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Abs()`: 返回绝对路径。如果它不是绝对路径，则返回工作目录以及路径。'
- en: '`Rel()`: Returns the relative path of a path to a base.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rel()`: 返回路径相对于基本路径的相对路径。'
- en: We will leave it as an exercise for you to experiment with using these.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将让你自己尝试使用这些功能。
- en: In this section, we learned how to use the `path/filepath` and `runtime` packages
    to handle file pathing for different OSs. We introduced `runtime.GOOS` to help
    you detect the OS your user is using and `os.Getwd()` to determine where in the
    filesystem your program is. `os.TempDir()` was introduced to locate your OS's
    location for temporary files. Finally, we learned about the functions in `path/filepath`
    that allow you to combine and split file paths agnostically to you but with an
    output specific to the OS.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们学习了如何使用`path/filepath`和`runtime`包处理不同操作系统的文件路径。我们介绍了`runtime.GOOS`来帮助您检测用户正在使用的操作系统，`os.Getwd()`来确定程序在文件系统中的位置。我们还介绍了`os.TempDir()`来定位您的操作系统中用于临时文件的位置。最后，我们学习了`path/filepath`中的函数，这些函数允许您在不考虑操作系统的情况下组合和拆分文件路径，并输出特定于操作系统的结果。
- en: Next, we will look at Go's new `io/fs` package, which was introduced in version
    1.16\. It introduces new interfaces to abstract filesystems in the same way `io`
    does for files.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看 Go 的新 `io/fs` 包，它是在版本 1.16 中引入的。它通过类似于 `io` 对文件的处理方式，引入了新的接口来抽象文件系统。
- en: OS-agnostic filesystems
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作系统无关的文件系统
- en: One of the newest and more exciting developments in the latest Go releases is
    the new `io/fs` and `embed` packages, which were introduced in **Go 1.16**.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在最新的 Go 版本中，最令人兴奋的两项新功能是新的 `io/fs` 和 `embed` 包，它们是在 **Go 1.16** 中引入的。
- en: While we have shown agnostic access to our local filesystem via the `os` package,
    as well as agnostic file pathing manipulation through `filepath`, we haven't seen
    an agnostic way of accessing an entire filesystem.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经展示了通过 `os` 包访问本地文件系统的通用方式，并通过 `filepath` 进行通用的文件路径操作，但我们还没有看到访问整个文件系统的通用方法。
- en: In the cloud era, files are just as likely to be in filesystems that exist in
    remote data centers such as Microsoft Azure's Blob Storage, Google Cloud's Filestore,
    or Amazon AWS's EFS as they are on local disk.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在云计算时代，文件也很可能存储在远程数据中心的文件系统中，比如 Microsoft Azure 的 Blob 存储、Google Cloud 的 Filestore
    或 Amazon AWS 的 EFS，就像它们存储在本地磁盘上一样。
- en: Each of these filesystems comes with a client for accessing the files in Go,
    but they are specific to that network service. We can't treat each of these in
    the same way as I treat my local filesystem. `io/fs` is meant to provide a foundation
    to help solve this problem.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件系统每个都有一个用于在 Go 中访问文件的客户端，但它们是特定于该网络服务的。我们不能像处理本地文件系统一样处理这些文件。`io/fs` 旨在提供一个基础，帮助解决这个问题。
- en: Another problem is that many files must be packaged with that binary, often
    in a container definition. Those files do not change during the lifetime of the
    program. It would be easier to include them in the binary and access them with
    a filesystem interface. A simple web application that needs image, HTML, and CSS
    files is a good example of this use case. The new `embed` package aims to fix
    this issue.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个问题是许多文件必须与二进制文件一起打包，通常是在容器定义中。这些文件在程序的生命周期内不会改变。将它们包含在二进制文件中并通过文件系统接口访问会更方便。一个需要图像、HTML
    和 CSS 文件的简单 Web 应用程序就是这种用例的一个典型示例。新的 `embed` 包旨在解决这个问题。
- en: io.fs filesystems
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: io.fs 文件系统
- en: 'Our new `io/fs` filesystem exports interfaces that can be implemented by filesystem
    providers. The root interface, `FS`, has the simplest definition:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新的 `io/fs` 文件系统导出了可以由文件系统提供者实现的接口。根接口 `FS` 的定义最简单：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This lets you open any file, where `File` is defined as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这让你可以打开任何文件，其中 `File` 被定义如下：
- en: '[PRE16]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This provides the simplest of filesystems. You can open a file at a path and
    either get information about the file or read it. As filesystems tend to differ
    in functionality, this is the only shared functionality between all the given
    filesystems.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了最简单的文件系统。你可以打开路径中的文件，并获得文件的信息或读取文件。由于文件系统在功能上有差异，这是所有给定文件系统之间唯一共享的功能。
- en: A `FS` (such as `ReadDirFS` and `StatFS`) to allow for file walking and to provide
    directory information. There is a noticeable lack of writability for FS objects.
    You must provide your own since the Go authors haven't defined one as part of
    the standard library.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `FS`（如 `ReadDirFS` 和 `StatFS`），它允许进行文件遍历并提供目录信息。注意，FS 对象缺少可写性。你必须自己提供一个，因为
    Go 作者没有将其定义为标准库的一部分。
- en: embed
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: embed
- en: The `embed` package allows you to embed files directly into the binary using
    a `//go:embed` directive.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`embed` 包允许你使用 `//go:embed` 指令将文件直接嵌入到二进制文件中。'
- en: '`embed` can embed files in three ways, as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`embed` 可以通过三种方式嵌入文件，如下所示：'
- en: As bytes
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为字节
- en: As a string
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为一个字符串
- en: Into an `embed.FS` (which implements `fs.FS`)
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换为 `embed.FS`（它实现了 `fs.FS`）
- en: 'The first two are done by putting a directive over the specific variable type:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个功能通过将指令放置在特定的变量类型上完成：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`//go:embed hello.txt` represents a Go directive instructing the compiler to
    take a file called `hello.txt` and store it in variables.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`//go:embed hello.txt` 表示 Go 指令，指示编译器获取名为 `hello.txt` 的文件并将其存储在变量中。'
- en: '`_` on the `import` line instructs the compiler to ignore the fact that we
    don''t directly use `embed`. This is called an *anonymous import*, where we need
    a package to be loaded but don''t use its functionality directly. Without `_`,
    we would receive a compile error for not using the imported package.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在`import`行上的`_`指示编译器忽略我们没有直接使用`embed`的事实。这称为*匿名导入*，即我们需要加载一个包但不直接使用其功能。没有`_`时，如果未使用导入的包，我们将收到编译错误。
- en: 'The final method of using `embed.FS` is useful when you wish to embed several
    files in the filesystem:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `embed.FS` 的最终方法在你希望将多个文件嵌入文件系统时非常有用：
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We now have an `fs.FS` that's storing all the files in our `image` directory
    and our `index.html` file. These files no longer need to be included in a container
    filesystem when we ship our binary.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个 `fs.FS`，它存储了我们 `image` 目录中的所有文件和 `index.html` 文件。这些文件在我们发布二进制文件时不再需要包含在容器文件系统中。
- en: Walking our filesystem
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 遍历我们的文件系统
- en: 'The `io/fs` package offers a filesystem-agnostic method of walking a filesystem
    *if the filesystem supports that capability*. In the previous example, we had
    a directory in our embedded filesystem holding image files. We can print out any
    `.jpg` files using a directory walker:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`io/fs` 包提供了一种与文件系统无关的遍历方法，*前提是文件系统支持该功能*。在前面的示例中，我们有一个嵌入式文件系统中的目录，里面存放着图像文件。我们可以使用目录遍历器打印出所有
    `.jpg` 文件：'
- en: '[PRE19]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding function walks the directory structure of our embedded filesystem
    (content) from the root (`"."`) and calls the function that was defined, passing
    it the path of the file, its directory entry, and an error, if there was one.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 上述函数遍历了我们嵌入式文件系统（content）的目录结构（从根目录 `"."` 开始），并调用了已定义的函数，将文件路径、目录条目和错误（如果有）传递给它。
- en: In our function, we simply print the path of the file if the file is not a directory
    and has the`.jpg` extension.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的函数中，如果文件不是目录且具有 `.jpg` 扩展名，我们只是打印文件的路径。
- en: But what about packages that are using `io/fs` to access other types of filesystems?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，使用 `io/fs` 访问其他类型文件系统的包怎么办呢？
- en: The io/fs future
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: io/fs 的未来
- en: At the time of writing, the major user of `io/fs` is `embed`. However, we are
    starting to see third-party packages implementing this interface.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在写作时，`io/fs` 的主要用户是 `embed`。然而，我们开始看到第三方包实现了这个接口。
- en: '`absfs` provides an `io.FS` hook for their `boltfs/memfs/os` filesystem packages
    ([https://github.com/absfs](https://github.com/absfs)). Several of these packages
    have wrappers around the popular `afero` filesystem package ([https://github.com/spf13/afero](https://github.com/spf13/afero)).
    Azure has a non-official package that supports Blob storage ([https://github.com/element-of-surprise/azfs](https://github.com/element-of-surprise/azfs)).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`absfs` 为他们的 `boltfs/memfs/os` 文件系统包提供了一个 `io.FS` 钩子（[https://github.com/absfs](https://github.com/absfs)）。这些包中的几个封装了流行的
    `afero` 文件系统包（[https://github.com/spf13/afero](https://github.com/spf13/afero)）。Azure
    有一个非官方的包，支持 Blob 存储（[https://github.com/element-of-surprise/azfs](https://github.com/element-of-surprise/azfs)）。'
- en: There are also packages for accessing **Redis**, **GroupCache**, **memfs**,
    local filesystems, and tooling support at [https://github.com/gopherfs/fs](https://github.com/gopherfs/fs).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些包可以访问**Redis**、**GroupCache**、**memfs**、本地文件系统以及 [https://github.com/gopherfs/fs](https://github.com/gopherfs/fs)
    上的工具支持。
- en: Note
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`github.com/element-of-surprise` and [https://github.com/gopherfs](https://github.com/gopherfs)
    are owned by the author.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`github.com/element-of-surprise` 和 [https://github.com/gopherfs](https://github.com/gopherfs)
    由作者拥有。'
- en: In this section, you learned about Go's `io/fs` package and how it is becoming
    a standard for interacting with filesystems. You also learned how to use the `embed`
    package to embed files into a binary and access them via the `io/fs` interfaces.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，你了解了 Go 的 `io/fs` 包，以及它如何成为与文件系统交互的标准。你还学会了如何使用 `embed` 包将文件嵌入到二进制文件中，并通过
    `io/fs` 接口访问它们。
- en: We've only scratched the surface
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我们只是触及了表面
- en: 'I highly encourage you to read the standard library''s **GoDoc** pages to become
    familiar with its capabilities. The following are the GoDocs that were covered
    in this chapter. Here, you can find many useful utilities for dealing with files:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议你阅读标准库的 **GoDoc** 页面，以便熟悉其功能。以下是本章涉及的 GoDocs。在这里，你可以找到许多处理文件的有用工具：
- en: 'File interfaces and basic I/O functions: https://pkg.go.dev/io'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件接口和基本 I/O 函数：[https://pkg.go.dev/io](https://pkg.go.dev/io)
- en: 'Buffered I/O package: [https://pkg.go.dev/bufio](https://pkg.go.dev/bufio)'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓冲 I/O 包：[https://pkg.go.dev/bufio](https://pkg.go.dev/bufio)
- en: 'Converting to/from strings into other types: https://pkg.go.dev/strconv'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将字符串转换为/从其他类型转换： [https://pkg.go.dev/strconv](https://pkg.go.dev/strconv)
- en: 'Package for manipulating strings: https://pkg.go.dev/strings'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作字符串的包：[https://pkg.go.dev/strings](https://pkg.go.dev/strings)
- en: 'Package for manipulating bytes: https://pkg.go.dev/bytes'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作字节的包： [https://pkg.go.dev/bytes](https://pkg.go.dev/bytes)
- en: 'Package for OS interaction: [https://pkg.go.dev/os](https://pkg.go.dev/os)'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作操作系统交互的包：[https://pkg.go.dev/os](https://pkg.go.dev/os)
- en: 'Package for forward slash paths, like URLs: [https://pkg.go.dev/path](https://pkg.go.dev/path)'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于正斜杠路径（如 URL）的包： [https://pkg.go.dev/path](https://pkg.go.dev/path)
- en: 'Package for file paths: [https://pkg.go.dev/path/filepath](https://pkg.go.dev/path/filepath)'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件路径包：[https://pkg.go.dev/path/filepath](https://pkg.go.dev/path/filepath)
- en: 'Filesystem interfaces: https://pkg.go.dev/io/fs'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文件系统接口：https://pkg.go.dev/io/fs
- en: 'Embedded filesystem: https://pkg.go.dev/embed'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌入式文件系统：https://pkg.go.dev/embed
- en: In this section, we learned how to use `io` interfaces to stream data in and
    out of files, as well as about the `os` package's `Stdin/Stdout/Stderr` implementations
    for reading and writing to a program's input/output. We also learned how to read
    data by delimiter using the `bufio` package and how to split string content up
    using the `strings` package.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们学习了如何使用`io`接口将数据流进流出文件，以及`os`包的`Stdin/Stdout/Stderr`实现，用于读取和写入程序的输入/输出。我们还学习了如何使用`bufio`包按分隔符读取数据，以及如何使用`strings`包拆分字符串内容。
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter has provided you with a foundation for working with file I/O in
    the Go language. You learned about the `io` package and its file abstractions
    and how to read and write files to disk. Then, you learned how to stream file
    content so that you can work with the network and be more efficient with memory.
    After that, you learned about the `path/filepath` package, which can help you
    deal with multiple OSs. Finally, you learned about Go's filesystem-agnostic interfaces
    for interacting with any filesystem, starting with the new `embed` filesystem.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为你提供了Go语言中处理文件I/O的基础。你学习了`io`包及其文件抽象，并了解了如何将文件读写到磁盘。接着，你学习了如何流式传输文件内容，以便与网络合作并提高内存效率。然后，你了解了`path/filepath`包，它可以帮助你处理多种操作系统。最后，你了解了Go的文件系统无关接口，用于与任何文件系统进行交互，从新的`embed`文件系统开始。
- en: In the next chapter, you will learn how to interact with common data types and
    storage using popular Go packages. There, you will need to rely on the file and
    filesystem packages from this chapter to interact with data types.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，你将学习如何使用流行的Go包与常见数据类型和存储交互。在那里，你将需要依赖本章中的文件和文件系统包来与数据类型进行交互。
- en: Interacting with data and storage systems is critical to DevOps work. It allows
    us to read and change software configurations, store data and make it searchable,
    ask systems to do work on our behalf, and generate reporting.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与数据和存储系统的交互对于DevOps工作至关重要。它使我们能够读取和更改软件配置，存储数据并使其可搜索，要求系统代我们执行工作，并生成报告。
- en: So, let's dive in!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧！
