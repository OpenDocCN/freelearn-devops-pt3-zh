- en: 'Chapter 4: Filesystem Interactions'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A fundamental part of any developer's life is interacting with **files**. They
    represent data that must be processed and configured for our systems, cached items
    can be served, and many other uses.
  prefs: []
  type: TYPE_NORMAL
- en: One of Go's strongest features is its abstraction of **file interfaces**, which
    allows a common set of tools to interact with streams of data from disks and networks.
    These interfaces set a common standard that all major packages use to export their
    data streams. Moving from one to another just becomes an exercise in accessing
    the **filesystem** with the necessary credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Packages related to specific data formats, such as CSV, JSON, YAML, TOML, and
    XML, build on these common file interfaces. These packages use the interfaces
    defined by the standard library to read these types of files from disk or HTTP
    streams.
  prefs: []
  type: TYPE_NORMAL
- en: Because Go is multiplatform, you may want to write software that can work on
    different OSs. Go provides packages that allow you to detect the OS and its packages
    to handle differences in OS pathing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: All I/O in Go are files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reading and writing to files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streaming file content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OS-agnostic pathing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OS-agnostic filesystems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After completing this chapter, you should have a set of skills for interacting
    with data that's stored in a wide variety of mediums, which will be useful in
    your everyday life as a DevOps engineer.
  prefs: []
  type: TYPE_NORMAL
- en: All I/O in Go are files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Go provides an **input-output** (**I/O**) system based on files. This should
    come as no surprise since Go is the brainchild of two prominent engineers, Rob
    Pike and Ken Thompson, who, while at *Bell Labs*, designed the UNIX and Plan 9
    operating systems – both of which treat (almost) everything as a file.
  prefs: []
  type: TYPE_NORMAL
- en: Go provides the `io` package, which contains interfaces to interact with I/O
    primitives such as disk files, remote files, and network services.
  prefs: []
  type: TYPE_NORMAL
- en: I/O interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The basic block of I/O is `byte`, an 8-bit value. I/O uses streams of bytes
    to allow you to read and write. With some I/Os, you can only read from beginning
    to end as you process the stream (such as network I/O). Some I/Os, such as disks,
    allow you to *seek* something in the file.
  prefs: []
  type: TYPE_NORMAL
- en: Some common operations that we perform when we interact with a byte stream include
    reading, writing, seeking a location in a byte stream, and closing a stream when
    we have finished our work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go provides the following interfaces for these basic operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `io` package also contains composite interfaces such as `ReadWriter` and
    `ReadWriteCloser`. These interfaces are common in packages that allow you to interact
    with files or networks. These interfaces allow you to use common tooling that
    uses these interfaces, regardless of what is underneath (such as a local filesystem,
    remote filesystem, or an HTTP connection).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned that Go file interaction is based on the `[]byte`
    type and introduced the basic interfaces for I/O. Next, we will learn about reading
    and writing files using methods that utilize these interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing to files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most common scenario in DevOps tooling is the need to manipulate files:
    *reading*, *writing*, *reformatting*, or *analyzing* the data in those files.
    These files could be in many formats – JSON, YAML, XML, CSV, and others that are
    probably familiar to you. They are used to configure both local services and to
    interact with your cloud network provider.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will cover the basics of reading and writing entire files.
  prefs: []
  type: TYPE_NORMAL
- en: Reading local files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start by reading a configuration file on a local disk by using the `os.Readfile()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `ReadFile()` method reads the location from its function parameter and returns
    that file's content. That return value is then stored in the data variable. An
    error is returned if the file cannot be read. For a refresher on errors, see the
    *Handling errors in Go* section in [*Chapter 2*](B17626_02.xhtml#_idTextAnchor166),
    *Go Language Essentials*.
  prefs: []
  type: TYPE_NORMAL
- en: '`ReadFile()` is a helper function that calls `os.Open()` and retrieves an `io.Reader`.
    The `io.ReadAll()` function is used to read the entire content of `io.Reader`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`data` is of the `[]byte` type, so if you would like to use it as a `string`,
    you can simply convert it into one by using `s := string(data)`. This is called
    *type conversion*, where we convert from one type into another. In Go, you can
    only convert certain types from one into another. The full list of conversion
    rules can be found at [https://golang.org/ref/spec#Conversions.strings](https://golang.org/ref/spec#Conversions.strings)
    can be converted back into bytes with `b := []byte(s)`. Most other types require
    a package called `strconv` to be converted into strings ([https://pkg.go.dev/strconv](https://pkg.go.dev/strconv)).'
  prefs: []
  type: TYPE_NORMAL
- en: If the data that's represented in the file is of a common format such as JSON
    or YAML, then we can retrieve and write that data efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Writing local files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most common way to write to local disk is by using `os.Writefile()`. This
    writes a complete file to disk. `WriteFile` will create the file if necessary
    and truncate the file if it exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code writes data to `path/to/fi` with Unix-like permissions, `0644`.
    If you have not seen Unix-like permissions before, a quick internet search will
    help you with these.
  prefs: []
  type: TYPE_NORMAL
- en: If your data is stored in a `string`, you can simply convert it into`[]byte`
    by doing`[]byte(data)`. `WriteFile()` is a wrapper around `os.OpenFile()` that
    handles file flags and modes for you while closing the file after the write is
    complete.
  prefs: []
  type: TYPE_NORMAL
- en: Reading remote files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The way the remote file is read is going to be implementation-dependent. However,
    these concepts will still be built on the `io` interfaces we discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s say that we want to connect to a text file that is stored
    on an HTTP server, to collect common text-formatted information such as application
    metrics. We can connect to that server and retrieve the file in a way that''s
    very similar to what was shown in the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the setup to get our `io.ReadCloser` depends on our I/O target,
    but what it returns is just an interface from the `io` package that we can use
    with any function that supports those interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Because it uses `io` interfaces, we can do slick things such as stream the content
    directly to a local file instead of copying the entire file into memory and writing
    it to disk. This is faster and more memory efficient as each chunk that is read
    is then immediately written to disk.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use `os.OpenFile()` to open a file for writing and stream the content
    from the web server into the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`OpenFile()` is the more complex method of opening a file when you need to
    either write to a file or be more specific with how you interact with it. You
    should use `os.Open()` when you just want to read from a local file. Our flags
    here are the standard Unix-like bitmasks that do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the file if it doesn''t exist: `os.O_CREATE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Write to a file: `os.O_WRONLY`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the file exists, truncate it versus append to it: `os.O_TRUNC`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A list of flags can be found here: [https://pkg.go.dev/os#pkg-constants](https://pkg.go.dev/os#pkg-constants).'
  prefs: []
  type: TYPE_NORMAL
- en: '`io.Copy()` reads from `io.Reader` and writes to `io.Writer` until `Reader`
    is empty. This copies the file from the HTTP server to the local disk.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to read an entire file using `os.ReadFile()`,
    how to type convert a `[]byte` into a `string`, and how to write an entire file
    to disk using `os.WriteFile()`. We also learned about the differences between
    `os.Open()` and `os.OpenFile()` and showed you how to use utility functions such
    as `io.Copy()` and `io.ReadAll()`. Finally, we learned how HTTP clients expose
    their data streams as `io` interfaces that can be read using these same tools.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at interacting with these file interfaces as streams instead
    of reading and writing entire files.
  prefs: []
  type: TYPE_NORMAL
- en: Streaming file content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we learned how to read and write in large blocks using
    `os.ReadFile()` and `os.WriteFile()`.
  prefs: []
  type: TYPE_NORMAL
- en: This works well when the files are small, which is usually the case when you're
    doing DevOps automation. However, sometimes, the files we want to read are very
    large – in most cases, you wouldn't want to read a 2 GiB file into memory. In
    those cases, we want to stream the contents of the file in manageable chunks that
    we can operate on while keeping memory usage low.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most basic version of this was shown in the previous section. There, we
    used two streams to copy a file: `io.ReadCloser` from the HTTP client and `io.WriteCloser`
    for writing to local disk. We used the `io.Copy()` function to copy from the network
    file to the disk file.'
  prefs: []
  type: TYPE_NORMAL
- en: Go's `io` interfaces also allow us to stream files to copy content, search for
    content, manipulate input to output, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Stdin/Stdout/Stderr are just files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout this book, you will see us writing to the console using `fmt.Println()`
    or `fmt.Printf()`, two functions from the `fmt` package. Those functions are reading
    and writing to files that represent the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: Those functions use an `io.Writer` called `os.Stdout`. When we use the same
    functions in the `log` package, we are usually writing to `os.Stderr`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the same interfaces we''ve been using to read/write to other files
    to also read/write to these files. When we want to copy a file and output its
    content to the terminal, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: While we won't go into the details, `os.Stdin` is simply an `io.Reader`. You
    can read from it using the `io` and `bufio` packages.
  prefs: []
  type: TYPE_NORMAL
- en: Reading data out of a stream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What if we wanted to read a stream that represented user records and return
    them on a channel?
  prefs: []
  type: TYPE_NORMAL
- en: Let's say the records are simple `<user>:<id>` text and each record was delimited
    by the new line character (`\n`). These records might be stored on an HTTP server
    or a local disk. This doesn't matter to us because it is simply a stream behind
    an interface. Let's assume that we receive this as an `io.Reader`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will define a `User` struct:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s define a function that can split a line we receive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`getUser()` takes a string and returns a `User`. We use the `strings` package''s
    `Split()` function to split the string into a `[]string` while using `:` as the
    divider.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Split()` should return two values; if not, then we return an error.'
  prefs: []
  type: TYPE_NORMAL
- en: Since we are splitting a string, our user ID is stored as a `string`. But we
    want to use the integer value in our `User` record. Here, we can use the `strconv`
    package's `Atoi()` method to convert the string version of the number into an
    integer. If it is not an integer, then the entry is bad, and we return an error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a function that reads in the stream and writes the `User`
    records to a channel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using the `bufio` package's `Scanner` type. `Scanner` allows us
    to take an `io.Reader` and scan it until we find a delimiter. By default, this
    is `\n`, though you can change this using the `.Split()` method. `Scan()` will
    return `true` until we reach the end of the Reader's output. Note that `io.Reader`
    returns an error, `io.EOF`, when it reaches the end of the stream.
  prefs: []
  type: TYPE_NORMAL
- en: After each `Scan()` call, the scanner stores the bytes read, which you can retrieve
    as a `string` using `.Text()`. The content in `.Text()` changes each time `.Scan()`
    is called. Also, note that we check our `Context` object and stop its execution
    if it's canceled.
  prefs: []
  type: TYPE_NORMAL
- en: We pass the content of that `string` to our previously defined `getUser()`.
    If we receive an `error`, we return it in the `User` record to inform the caller
    of the error. Otherwise, we return our `User` record with all the information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s invoke this against a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we open our file on disk and pass it to `decodeUsers()`. We receive a
    `User`record from the *output channel* and we print the user to the screen concurrently
    while reading the file stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using `os.Open()`, we could have opened the file via `http.Client`
    and passed it to `decodeUsers()`. The complete code can be found here: [https://play.golang.org/p/OxehTsHT6Qj](https://play.golang.org/p/OxehTsHT6Qj).'
  prefs: []
  type: TYPE_NORMAL
- en: Writing data into a stream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Writing to a stream is even simpler – we just convert our `User` into a `string`
    and write it to an `io.Writer`. This looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have taken in an `io.Writer` that represents the place to write to
    and a `User` record that we want to write into that output. We can use this to
    write to a file on disk:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we opened a file on our local disk. When our containing function (not
    shown) returns, the file will be closed. Then, we wrote the `User` records stored
    in variable users (`[]Users`) one at a time to the file. Finally, we wrote a carriage
    return, `("\n")`, before every record except the first one.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see this in action here: [https://play.golang.org/p/bxuFyPT5nSk](https://play.golang.org/p/bxuFyPT5nSk).
    We have provided a streaming version of this using channels that you can find
    here: [https://play.golang.org/p/njuE1n7dyOM](https://play.golang.org/p/njuE1n7dyOM).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we'll learn how to use the `path/filepath` package to write
    software that works on multiple OSs that use different path delimiters.
  prefs: []
  type: TYPE_NORMAL
- en: OS-agnostic pathing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of Go's greatest strengths lies in its multiplatform support. A developer
    can develop on a Linux workstation and run the same Go program, recompiled into
    native code, on a Windows server.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the areas of difficulty when developing software that runs on multiple
    OSs is *accessing files*. Path formats are slightly different for each operating
    system. The most obvious example is the different file separators for OSs: `\`
    on Windows and `/` on Unix-like systems. Less obvious would be how to escape special
    characters on a particular OS, which can differ even between Unix-based OSs.'
  prefs: []
  type: TYPE_NORMAL
- en: The `path/filepath` package provides access to functions that will allow you
    to handle pathing for the native OS. This should not be confused with the root
    `path` package, which looks similar but handles a more general URL-style pathing.
  prefs: []
  type: TYPE_NORMAL
- en: What OS/platform am I running?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While we will discuss how to gain file access and perform pathing using agnostic
    functions, it is still important to understand what OS you are running on. You
    may use different locations for files based on the OS you are running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `runtime` package, you can detect the OS and platform you are running
    on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This gives you the running OS. We can print out the current list of OS types
    and hardware architecture that's supported by Go with **go tool dist list**.
  prefs: []
  type: TYPE_NORMAL
- en: Using filepath
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With **filepath**, you can be ignorant of the pathing rules for the OS you
    are running on when manipulating a path. Paths are divided into the following
    areas:'
  prefs: []
  type: TYPE_NORMAL
- en: The **directories** in the path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **file** in the path
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A file path's final directory or file is called the **base**. The path your
    binary is running in is called the **working directory**.
  prefs: []
  type: TYPE_NORMAL
- en: Joining a file path
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s say we want to access a configuration file, `config.json`, that is stored
    in the `config/` directory, which is in the same directory as our binary. Let''s
    use `os` and `path/filepath` to read that file in a way that works on all OSs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the first thing we do is get the working directory. This allows
    us to make calls relative to where our binary is running.
  prefs: []
  type: TYPE_NORMAL
- en: '`filepath.Join()` allows us to join the components of our path into a single
    path. This fills in the OS-specific directory separators for you and uses the
    native pathing rules. On a Unix-like system, this might be `/home/jdoak/bin/config/config.json`,
    while on Windows, this might be `C:\Documents and Settings\jdoak\go\bin\config\config.json`.'
  prefs: []
  type: TYPE_NORMAL
- en: Splitting a file path
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In some circumstances, it is important to split filepaths along their path
    separators in different ways. `filepath` provides the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Base()`: Returns the last element of the path'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ext()`: Returns the file extension, if it has one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Split()`: Returns the split directory and file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use these to get various parts of a path. This can be useful when we
    wish to copy a file into another directory while retaining the file's name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s copy a file from its location to our OS''s **TMPDIR**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now, it's time to look at the different pathing options you can use to reference
    files and how the `filepath` package can help.
  prefs: []
  type: TYPE_NORMAL
- en: Relative and absolute pathing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two types of pathing when it comes to accessing a filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Absolute pathing**: Pathing from the root directory to the file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Relative pathing**: Pathing from your current location in the filesystem'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During development, it is often handy to convert a relative path into an absolute
    path and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: '`filepath` provides a few functions to help with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Abs()`: Returns the absolute path. If it''s not an absolute path, return the
    working directory, as well as the path.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Rel()`: Returns the relative path of a path to a base.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will leave it as an exercise for you to experiment with using these.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to use the `path/filepath` and `runtime` packages
    to handle file pathing for different OSs. We introduced `runtime.GOOS` to help
    you detect the OS your user is using and `os.Getwd()` to determine where in the
    filesystem your program is. `os.TempDir()` was introduced to locate your OS's
    location for temporary files. Finally, we learned about the functions in `path/filepath`
    that allow you to combine and split file paths agnostically to you but with an
    output specific to the OS.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will look at Go's new `io/fs` package, which was introduced in version
    1.16\. It introduces new interfaces to abstract filesystems in the same way `io`
    does for files.
  prefs: []
  type: TYPE_NORMAL
- en: OS-agnostic filesystems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the newest and more exciting developments in the latest Go releases is
    the new `io/fs` and `embed` packages, which were introduced in **Go 1.16**.
  prefs: []
  type: TYPE_NORMAL
- en: While we have shown agnostic access to our local filesystem via the `os` package,
    as well as agnostic file pathing manipulation through `filepath`, we haven't seen
    an agnostic way of accessing an entire filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: In the cloud era, files are just as likely to be in filesystems that exist in
    remote data centers such as Microsoft Azure's Blob Storage, Google Cloud's Filestore,
    or Amazon AWS's EFS as they are on local disk.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these filesystems comes with a client for accessing the files in Go,
    but they are specific to that network service. We can't treat each of these in
    the same way as I treat my local filesystem. `io/fs` is meant to provide a foundation
    to help solve this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Another problem is that many files must be packaged with that binary, often
    in a container definition. Those files do not change during the lifetime of the
    program. It would be easier to include them in the binary and access them with
    a filesystem interface. A simple web application that needs image, HTML, and CSS
    files is a good example of this use case. The new `embed` package aims to fix
    this issue.
  prefs: []
  type: TYPE_NORMAL
- en: io.fs filesystems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our new `io/fs` filesystem exports interfaces that can be implemented by filesystem
    providers. The root interface, `FS`, has the simplest definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This lets you open any file, where `File` is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This provides the simplest of filesystems. You can open a file at a path and
    either get information about the file or read it. As filesystems tend to differ
    in functionality, this is the only shared functionality between all the given
    filesystems.
  prefs: []
  type: TYPE_NORMAL
- en: A `FS` (such as `ReadDirFS` and `StatFS`) to allow for file walking and to provide
    directory information. There is a noticeable lack of writability for FS objects.
    You must provide your own since the Go authors haven't defined one as part of
    the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: embed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `embed` package allows you to embed files directly into the binary using
    a `//go:embed` directive.
  prefs: []
  type: TYPE_NORMAL
- en: '`embed` can embed files in three ways, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: As bytes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a string
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Into an `embed.FS` (which implements `fs.FS`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first two are done by putting a directive over the specific variable type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`//go:embed hello.txt` represents a Go directive instructing the compiler to
    take a file called `hello.txt` and store it in variables.'
  prefs: []
  type: TYPE_NORMAL
- en: '`_` on the `import` line instructs the compiler to ignore the fact that we
    don''t directly use `embed`. This is called an *anonymous import*, where we need
    a package to be loaded but don''t use its functionality directly. Without `_`,
    we would receive a compile error for not using the imported package.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The final method of using `embed.FS` is useful when you wish to embed several
    files in the filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We now have an `fs.FS` that's storing all the files in our `image` directory
    and our `index.html` file. These files no longer need to be included in a container
    filesystem when we ship our binary.
  prefs: []
  type: TYPE_NORMAL
- en: Walking our filesystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `io/fs` package offers a filesystem-agnostic method of walking a filesystem
    *if the filesystem supports that capability*. In the previous example, we had
    a directory in our embedded filesystem holding image files. We can print out any
    `.jpg` files using a directory walker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function walks the directory structure of our embedded filesystem
    (content) from the root (`"."`) and calls the function that was defined, passing
    it the path of the file, its directory entry, and an error, if there was one.
  prefs: []
  type: TYPE_NORMAL
- en: In our function, we simply print the path of the file if the file is not a directory
    and has the`.jpg` extension.
  prefs: []
  type: TYPE_NORMAL
- en: But what about packages that are using `io/fs` to access other types of filesystems?
  prefs: []
  type: TYPE_NORMAL
- en: The io/fs future
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the time of writing, the major user of `io/fs` is `embed`. However, we are
    starting to see third-party packages implementing this interface.
  prefs: []
  type: TYPE_NORMAL
- en: '`absfs` provides an `io.FS` hook for their `boltfs/memfs/os` filesystem packages
    ([https://github.com/absfs](https://github.com/absfs)). Several of these packages
    have wrappers around the popular `afero` filesystem package ([https://github.com/spf13/afero](https://github.com/spf13/afero)).
    Azure has a non-official package that supports Blob storage ([https://github.com/element-of-surprise/azfs](https://github.com/element-of-surprise/azfs)).'
  prefs: []
  type: TYPE_NORMAL
- en: There are also packages for accessing **Redis**, **GroupCache**, **memfs**,
    local filesystems, and tooling support at [https://github.com/gopherfs/fs](https://github.com/gopherfs/fs).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '`github.com/element-of-surprise` and [https://github.com/gopherfs](https://github.com/gopherfs)
    are owned by the author.'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned about Go's `io/fs` package and how it is becoming
    a standard for interacting with filesystems. You also learned how to use the `embed`
    package to embed files into a binary and access them via the `io/fs` interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: We've only scratched the surface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I highly encourage you to read the standard library''s **GoDoc** pages to become
    familiar with its capabilities. The following are the GoDocs that were covered
    in this chapter. Here, you can find many useful utilities for dealing with files:'
  prefs: []
  type: TYPE_NORMAL
- en: 'File interfaces and basic I/O functions: https://pkg.go.dev/io'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Buffered I/O package: [https://pkg.go.dev/bufio](https://pkg.go.dev/bufio)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Converting to/from strings into other types: https://pkg.go.dev/strconv'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Package for manipulating strings: https://pkg.go.dev/strings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Package for manipulating bytes: https://pkg.go.dev/bytes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Package for OS interaction: [https://pkg.go.dev/os](https://pkg.go.dev/os)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Package for forward slash paths, like URLs: [https://pkg.go.dev/path](https://pkg.go.dev/path)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Package for file paths: [https://pkg.go.dev/path/filepath](https://pkg.go.dev/path/filepath)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Filesystem interfaces: https://pkg.go.dev/io/fs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Embedded filesystem: https://pkg.go.dev/embed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we learned how to use `io` interfaces to stream data in and
    out of files, as well as about the `os` package's `Stdin/Stdout/Stderr` implementations
    for reading and writing to a program's input/output. We also learned how to read
    data by delimiter using the `bufio` package and how to split string content up
    using the `strings` package.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has provided you with a foundation for working with file I/O in
    the Go language. You learned about the `io` package and its file abstractions
    and how to read and write files to disk. Then, you learned how to stream file
    content so that you can work with the network and be more efficient with memory.
    After that, you learned about the `path/filepath` package, which can help you
    deal with multiple OSs. Finally, you learned about Go's filesystem-agnostic interfaces
    for interacting with any filesystem, starting with the new `embed` filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to interact with common data types and
    storage using popular Go packages. There, you will need to rely on the file and
    filesystem packages from this chapter to interact with data types.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with data and storage systems is critical to DevOps work. It allows
    us to read and change software configurations, store data and make it searchable,
    ask systems to do work on our behalf, and generate reporting.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's dive in!
  prefs: []
  type: TYPE_NORMAL
