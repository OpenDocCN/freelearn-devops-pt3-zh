- en: <st c="0">5</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">5</st>
- en: <st c="2">Streamlining Power Platform Development with DevOps Tooling</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2">通过 DevOps 工具简化 Power Platform 开发</st>
- en: <st c="61">In the previous chapter, we created our first Power Platform pipeline
    using a service principal to deploy our solution from one environment to another.</st>
    <st c="214">This chapter covers the pro-dev DevOps tools that can help us streamline
    our development process in Power Platform.</st> <st c="330">The first tool is</st>
    `<st c="505">clone</st>`<st c="510">,</st> `<st c="512">push</st>`<st c="516">,</st>
    `<st c="518">pull</st>`<st c="522">,</st> `<st c="524">checkout</st>`<st c="532">,
    and more.</st> <st c="544">We will also explore how we can manage Power Platform
    solution plain files and folders in a Git repository and how pull requests and
    merges are performed even from command lines.</st> <st c="723">We then learn about
    how Power Platform pipelines can be connected to these Git repos.</st> <st c="809">We
    will spend some time on</st> **<st c="836">Power Platform CLI</st>** <st c="854">(</st>**<st
    c="856">PAC CLI</st>**<st c="863">), which</st> <st c="872">allows us to interact
    with Power Platform solutions in any script language.</st> <st c="949">We will
    also learn how to create Azure DevOps Services pipelines in</st> **<st c="1017">YAML</st>**
    <st c="1021">(short for</st> **<st c="1033">Yet Another Markup Language</st>**<st
    c="1060">) format, and</st> <st c="1075">understand the YAML specification itself
    and relevant methods, such as variables, parameters, and tasks.</st> <st c="1180">We
    will also understand the build tasks provided by Microsoft for Power Platform
    solutions.</st> <st c="1272">Finally, we will learn</st> <st c="1294">how to use</st>
    **<st c="1306">GitHub Copilot</st>**<st c="1320">, an AI-powered code completion
    tool that can help us write code</st> <st c="1385">more efficiently.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="61">在上一章中，我们使用服务主体创建了第一个 Power Platform 管道，将我们的解决方案从一个环境部署到另一个环境。</st>
    <st c="214">本章介绍了可以帮助我们简化 Power Platform 开发过程的专业开发 DevOps 工具。</st> <st c="330">第一个工具是</st>
    `<st c="505">clone</st>`<st c="510">，</st> `<st c="512">push</st>`<st c="516">，</st>
    `<st c="518">pull</st>`<st c="522">，</st> `<st c="524">checkout</st>`<st c="532">等。</st>
    <st c="544">我们还将探索如何在 Git 仓库中管理 Power Platform 解决方案的纯文件和文件夹，以及如何通过命令行进行拉取请求和合并。</st>
    <st c="723">然后，我们将学习如何将 Power Platform 管道连接到这些 Git 仓库。</st> <st c="809">我们将花时间介绍</st>
    **<st c="836">Power Platform CLI</st>** <st c="854">(</st>**<st c="856">PAC CLI</st>**<st
    c="863">)，它</st> <st c="872">允许我们在任何脚本语言中与 Power Platform 解决方案进行交互。</st> <st c="949">我们还将学习如何在</st>
    **<st c="1017">YAML</st>** <st c="1021">(即</st> **<st c="1033">Yet Another Markup
    Language</st>**<st c="1060">) 格式中创建 Azure DevOps 服务管道，并</st> <st c="1075">理解 YAML
    规范及相关方法，如变量、参数和任务。</st> <st c="1180">我们还将了解 Microsoft 为 Power Platform 解决方案提供的构建任务。</st>
    <st c="1272">最后，我们将学习</st> <st c="1294">如何使用</st> **<st c="1306">GitHub Copilot</st>**<st
    c="1320">，一个 AI 驱动的代码补全工具，可以帮助我们更高效地编写代码</st> <st c="1385">。</st>
- en: <st c="1402">By the end of this chapter, we will have a solid understanding
    of, and hands-on skills in, how to set up end-to-end CI/CD pipelines with the
    help of pro-dev DevOps tools such as Azure DevOps pipelines and GitHub Actions,
    which deliver our solutions to different Power</st> <st c="1671">Platform environments.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1402">本章结束时，我们将深入理解并掌握如何通过专业开发的 DevOps 工具（如 Azure DevOps pipelines 和
    GitHub Actions）来设置端到端的 CI/CD 管道，这些工具将我们的解决方案交付到不同的 Power</st> <st c="1671">Platform
    环境中。</st>
- en: <st c="1693">In this chapter, we’re going to cover the following</st> <st c="1746">main
    topics:</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1693">在本章中，我们将涵盖以下</st> <st c="1746">主要内容：</st>
- en: <st c="1758">Git – the single source</st> <st c="1783">of truth</st>
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1758">Git – 单一的真实来源</st> <st c="1783">真理之源</st>
- en: <st c="1791">Power</st> <st c="1798">Platform CLI</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1791">Power</st> <st c="1798">Platform CLI</st>
- en: <st c="1810">Power Platform build tools for</st> <st c="1842">Azure DevOps</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1810">Power Platform 构建工具用于</st> <st c="1842">Azure DevOps</st>
- en: <st c="1854">GitHub Actions for</st> <st c="1874">Power Platform</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1854">GitHub Actions for</st> <st c="1874">Power Platform</st>
- en: <st c="1888">Managed pipelines – source</st> <st c="1916">control integration</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1888">托管管道 – 源</st> <st c="1916">控制集成</st>
- en: <st c="1935">Copilots in Power Platform</st> <st c="1963">pipeline development</st>
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1935">Power Platform 中的 Copilot</st> <st c="1963">管道开发</st>
- en: <st c="1983">Technical requirements</st>
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1983">技术要求</st>
- en: <st c="2006">To create our first CI/CD pipelines by using pro-dev DevOps tools,
    we need to have</st> <st c="2090">the following:</st>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2006">要使用专业开发的 DevOps 工具创建我们的第一个 CI/CD 管道，我们需要具备</st> <st c="2090">以下条件：</st>
- en: <st c="2104">A Power Platform subscription.</st> <st c="2136">We can sign up
    for a Power Apps Developer Plan (</st>[<st c="2184">https://www.microsoft.com/en-us/power-platform/products/power-apps/free</st>](https://www.microsoft.com/en-us/power-platform/products/power-apps/free)<st
    c="2256">) if we already have a Microsoft Entra ID work account.</st> <st c="2313">Or,
    we can join the Microsoft 365 Developer</st> <st c="2357">Program (</st>[<st c="2366">https://developer.microsoft.com/en-us/microsoft-365/dev-program</st>](https://developer.microsoft.com/en-us/microsoft-365/dev-program)<st
    c="2430">)</st><st c="2432">.</st>
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="2104">一个 Power Platform 订阅。</st> <st c="2136">如果我们已经拥有 Microsoft Entra
    ID 工作帐户，我们可以注册 Power Apps 开发者计划（</st>[<st c="2184">https://www.microsoft.com/en-us/power-platform/products/power-apps/free</st>](https://www.microsoft.com/en-us/power-platform/products/power-apps/free)<st
    c="2256">）。</st> <st c="2313">或者，我们可以加入 Microsoft 365 开发者</st> <st c="2357">计划（</st>[<st
    c="2366">https://developer.microsoft.com/en-us/microsoft-365/dev-program</st>](https://developer.microsoft.com/en-us/microsoft-365/dev-program)<st
    c="2430">）。</st><st c="2432">。</st>
- en: '<st c="2433">An Azure DevOps Services organization: we can create a DevOps
    organization any time</st> *<st c="2518">for free</st>* <st c="2526">(</st>[<st
    c="2528">https://learn.microsoft.com/en-us/azure/devops/user-guide/sign-up-invite-teammates</st>](https://learn.microsoft.com/en-us/azure/devops/user-guide/sign-up-invite-teammates)<st
    c="2610">).</st> <st c="2614">If we create a public project in Azure DevOps, we
    get multiple free pipelines and free access to every feature of the service –
    see the</st> **<st c="2750">Azure DevOps for Open</st>** **<st c="2772">Source</st>**
    <st c="2778">offering.</st>'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="2433">一个 Azure DevOps Services 组织：我们可以随时创建一个 DevOps 组织</st> *<st c="2518">免费</st>*
    <st c="2526">（</st>[<st c="2528">https://learn.microsoft.com/en-us/azure/devops/user-guide/sign-up-invite-teammates</st>](https://learn.microsoft.com/en-us/azure/devops/user-guide/sign-up-invite-teammates)<st
    c="2610">）。</st> <st c="2614">如果我们在 Azure DevOps 中创建一个公共项目，我们将获得多个免费管道并免费访问该服务的所有功能
    – 请参见</st> **<st c="2750">Azure DevOps for Open</st>** **<st c="2772">Source</st>**
    <st c="2778">优惠。</st>
- en: <st c="2788">A GitHub handle and public repository (</st>[<st c="2828">https://github.com/signup</st>](https://github.com/signup)<st
    c="2854">), which is also</st> *<st c="2872">free</st>* <st c="2876">for</st>
    <st c="2881">public repositories.</st>
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="2788">GitHub 用户名和公共仓库（</st>[<st c="2828">https://github.com/signup</st>](https://github.com/signup)<st
    c="2854">），该仓库也</st> *<st c="2872">免费</st>* <st c="2876">提供给</st> <st c="2881">公共仓库。</st>
- en: <st c="2901">A GitHub Copilot free trial (</st>[<st c="2931">https://github.com/login?return_to=%2Fgithub-copilot%2Fsignup</st>](https://github.com/login?return_to=%2Fgithub-copilot%2Fsignup)<st
    c="2993">) or access to Microsoft</st> <st c="3019">Copilot (</st>[<st c="3028">https://copilot.microsoft.com</st>](https://copilot.microsoft.com)<st
    c="3058">).</st>
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="2901">GitHub Copilot 免费试用（</st>[<st c="2931">https://github.com/login?return_to=%2Fgithub-copilot%2Fsignup</st>](https://github.com/login?return_to=%2Fgithub-copilot%2Fsignup)<st
    c="2993">）或访问 Microsoft</st> <st c="3019">Copilot（</st>[<st c="3028">https://copilot.microsoft.com</st>](https://copilot.microsoft.com)<st
    c="3058">）。</st>
- en: <st c="3061">Visual Studio Code – it is highly recommended to use this free
    code editor to create, edit, and update the YAML files in this chapter.</st> <st
    c="3197">We can download Visual Studio Code on any platform via</st> [<st c="3252">https://code.visualstudio.com/download</st>](https://code.visualstudio.com/download)<st
    c="3290">, and with the help of the VS Code extensions for Power Platform, Git,
    Azure DevOps pipelines, and GitHub workflows, we can carry out a syntax highlight
    and a semantic check on our changes.</st> <st c="3480">With the Git extension,
    we can manage our Git repository, too.</st> <st c="3543">See the</st> *<st c="3551">Further
    reading</st>* <st c="3566">section to learn more about Visual Studio Code.</st>
    <st c="3615">As an alternative, we can directly visit</st> [<st c="3656">https://vscode.dev</st>](https://vscode.dev)
    <st c="3674">to use the Visual Studio Code editor online in our favorite browser
    to edit any files and to open a</st> <st c="3775">remote repository.</st>
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="3061">Visual Studio Code – 强烈建议使用这个免费的代码编辑器来创建、编辑和更新本章节中的 YAML 文件。</st>
    <st c="3197">我们可以通过</st> [<st c="3252">https://code.visualstudio.com/download</st>](https://code.visualstudio.com/download)<st
    c="3290">在任何平台上下载 Visual Studio Code，并借助 Power Platform、Git、Azure DevOps 管道和 GitHub
    工作流的 VS Code 插件，我们可以对更改进行语法高亮和语义检查。</st> <st c="3480">通过 Git 插件，我们还可以管理 Git 仓库。</st>
    <st c="3543">有关更多信息，请参见</st> *<st c="3551">进一步阅读</st>* <st c="3566">部分，了解 Visual
    Studio Code 的更多内容。</st> <st c="3615">另外，我们可以直接访问</st> [<st c="3656">https://vscode.dev</st>](https://vscode.dev)
    <st c="3674">在我们喜欢的浏览器中在线使用 Visual Studio Code 编辑器，编辑任何文件并打开一个</st> <st c="3775">远程仓库。</st>
- en: <st c="3793">The code files for this chapter can be downloaded from our GitHub
    repo</st> <st c="3865">at</st> [<st c="3868">https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/tree/main/Chapter05</st>](https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/tree/main/Chapter05)<st
    c="3967">.</st>
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="3793">本章节的代码文件可以从我们的 GitHub 仓库下载</st> <st c="3865">，链接为</st> [<st c="3868">https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/tree/main/Chapter05</st>](https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/tree/main/Chapter05)<st
    c="3967">。</st>
- en: <st c="3968">Git – the single source of truth</st>
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="3968">Git——单一的真理来源</st>
- en: <st c="4001">In custom development projects, the source code is maintained in</st>
    **<st c="4067">version control systems</st>**<st c="4090">. These</st> <st c="4097">systems
    let developers work together on the same code base so that they can constantly
    introduce new features and/or fix bugs without conflicting with the changes of
    others.</st> <st c="4272">One of the reasons we use such code repositories (version
    control systems) is to provide end-to-end forward and backward traceability between
    code in production (the running application) and source code changes that have
    been made before pushing a version to production.</st> <st c="4543">In modern
    DevOps tools, in the project management part, the work items that need to be developed
    are directly linked to code changes that are made by developers.</st> <st c="4705">Version
    control systems provide a history of items and support transaction-like changes
    that span over multiple files and folders in repositories.</st> <st c="4852">These
    are very</st> <st c="4866">often represented</st> <st c="4884">as</st> **<st c="4888">version
    or</st>** **<st c="4899">history trees</st>**<st c="4912">.</st>
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4001">在定制开发项目中，源代码保存在</st> **<st c="4067">版本控制系统</st>**<st c="4090">中。这些</st>
    <st c="4097">系统允许开发人员在同一个代码库上协作工作，以便他们可以不断引入新功能和/或修复 bug，而不会与他人的更改冲突。</st> <st
    c="4272">我们使用此类代码库（版本控制系统）的原因之一是提供生产环境中的代码（运行中的应用程序）与在推送版本到生产环境之前所做的源代码更改之间的端到端前后追溯性。</st>
    <st c="4543">在现代的 DevOps 工具中，项目管理部分，开发工作项直接与开发人员所做的代码更改相链接。</st> <st c="4705">版本控制系统提供了项的历史，并支持跨多个文件和文件夹的事务性更改，这些更改存在于代码库中。</st>
    <st c="4852">这些更改</st> <st c="4866">通常以</st> <st c="4884">作为</st> **<st c="4888">版本或</st>**
    **<st c="4899">历史树</st>**<st c="4912">的形式表示。</st>
- en: <st c="4913">For developers to work in the most effective and efficient way</st>
    *<st c="4977">in parallel</st>*<st c="4988">, version control systems provide
    branching capabilities.</st> <st c="5046">A</st> **<st c="5048">branch</st>**<st
    c="5054">, as its name suggests, is a snapshot of a line of code – a fork that
    then</st> <st c="5128">manages its own history.</st> <st c="5154">Changes that
    we commit (play back) to this branch are not visible from the branch from which
    our branch was created.</st> <st c="5271">The mainline or root – the main branch
    itself – is presented as a branch in this approach as well.</st> <st c="5370">After
    completing our backlog item in the child branch, we</st> **<st c="5428">merge</st>**
    <st c="5433">back the changes to the parent branch.</st> <st c="5473">Branches
    can be created at any depth, but, in general, we recommend keeping the depth of
    the branch hierarchy as flat as possible to avoid integration debt later.</st>
    <st c="5636">Branches separate the work in progress from stable and</st> <st c="5691">tested
    code.</st>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4913">为了让开发人员以最有效和高效的方式工作</st> *<st c="4977">并行</st>*<st c="4988">，版本控制系统提供了分支功能。</st>
    <st c="5046">一个</st> **<st c="5048">分支</st>**<st c="5054">，顾名思义，是代码行的快照——一个分支，它随后</st>
    <st c="5128">管理自己的历史。</st> <st c="5154">我们提交（回放）到此分支的更改在我们创建分支时的原始分支中不可见。</st>
    <st c="5271">主线或根——主分支本身——在这种方法中也被表示为一个分支。</st> <st c="5370">在子分支中完成待办事项后，我们</st>
    **<st c="5428">合并</st>** <st c="5433">这些更改回父分支。</st> <st c="5473">分支可以在任何深度上创建，但一般来说，我们建议保持分支层次结构的深度尽可能平坦，以避免后续的集成债务。</st>
    <st c="5636">分支将进行中的工作与稳定且</st> <st c="5691">已测试的代码分开。</st>
- en: <st c="5703">To maintain and control a healthy development environment, we need
    to define our branch strategy.</st> <st c="5802">A</st> **<st c="5804">branch
    strategy</st>** <st c="5819">is a set of guidelines and best practices for managing
    branches in a version control system.</st> <st c="5913">It helps teams to organize
    their code base, streamline their development process, and minimize conflicts
    when merging code.</st> <st c="6037">There are several popular branch strategies.</st>
    <st c="6082">It is important for teams to choose a branch strategy that fits their
    development process and to follow it consistently to ensure smooth collaboration
    and efficient code management.</st> <st c="6264">Let us have a look at the two
    most popular</st> <st c="6307">branch strategies:</st>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5703">为了维护和控制一个健康的开发环境，我们需要定义我们的分支策略。</st> <st c="5802">一个</st> **<st
    c="5804">分支策略</st>** <st c="5819">是管理版本控制系统中分支的一组指南和最佳实践。</st> <st c="5913">它帮助团队组织代码库、简化开发流程，并在合并代码时尽量减少冲突。</st>
    <st c="6037">有几种流行的分支策略。</st> <st c="6082">团队需要选择适合他们开发流程的分支策略，并且要始终如一地遵循它，以确保顺畅的协作和高效的代码管理。</st>
    <st c="6264">让我们来看一下最流行的两种</st> <st c="6307">分支策略：</st>
- en: '**<st c="6325">Trunk-based development</st>** <st c="6349">is a</st> <st c="6354">version
    control management practice where developers merge small, frequent updates to
    a core branch</st> <st c="6455">called</st> **<st c="6462">trunk</st>** <st c="6467">or</st>
    **<st c="6471">main</st>**<st c="6475">. The main characteristic of this approach
    is that the only long-lived branch is the main branch, which is always deployable.</st>
    <st c="6601">Developers can’t commit changes directly to the main branch, but
    instead, they work on short-lived branches and merge their changes to the main</st>
    <st c="6745">branch frequently.</st>'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="6325">基于主干的开发</st>** <st c="6349">是一种</st> <st c="6354">版本控制管理实践，开发人员将小的、频繁的更新合并到一个核心分支</st>
    <st c="6455">叫做</st> **<st c="6462">主干</st>** <st c="6467">或</st> **<st c="6471">主分支</st>**<st
    c="6475">。这种方法的主要特点是，唯一长期存在的分支是主分支，且始终可部署。</st> <st c="6601">开发人员不能直接将更改提交到主分支，而是他们在短期分支上工作，并将更改频繁地合并到主分支。</st>'
- en: '**<st c="6763">Git Flow / GitHub flow</st>** <st c="6786">was originally</st>
    **<st c="6802">Git Flow</st>** <st c="6810">that</st> <st c="6816">defined several
    long-living branches, like</st> <st c="6859">release-, hotfix- and patch branches
    next to the main branch.</st> <st c="6921">In the last decade, the software industry
    has evolved a lot and software development teams usually maintain only one version
    of software – the latest version.</st> <st c="7080">This means that there is no
    need to maintain such a complex branch hierarchy and this was the reason to move
    from Git Flow to GitHub flow.</st> **<st c="7219">GitHub flow</st>** <st c="7230">is
    a</st> <st c="7236">lightweight, branch-based workflow that supports teams and
    projects where deployments are made regularly.</st> <st c="7342">This workflow
    is very popular among developers because it allows them to work on new features,
    bug fixes, or experiments without affecting the main code base.</st> <st c="7501">Once
    the work on a branch is complete, it can be merged back into the main code base
    through a pull request.</st> <st c="7610">GitHub flow is very similar to trunk-based
    development but contains GitHub-specific capabilities, like</st> <st c="7713">pull
    requests.</st>'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="6763">Git Flow / GitHub flow</st>** <st c="6786">最初是</st> **<st c="6802">Git
    Flow</st>** <st c="6810">定义了几个长期存在的分支，比如</st> <st c="6816">发布、热修复和补丁分支，旁边还有主分支。</st>
    <st c="6921">在过去十年里，软件行业发生了很大的变化，软件开发团队通常只维护一个版本的软件——即最新版本。</st> <st c="7080">这意味着不再需要维护这么复杂的分支层次结构，这也是从
    Git Flow 转向 GitHub flow 的原因。</st> **<st c="7219">GitHub flow</st>** <st c="7230">是一种</st>
    <st c="7236">轻量级、基于分支的工作流，支持定期进行部署的团队和项目。</st> <st c="7342">这个工作流在开发人员中非常受欢迎，因为它允许他们在不影响主代码库的情况下，进行新特性的开发、修复
    bug 或进行实验。</st> <st c="7501">一旦某个分支上的工作完成，就可以通过拉取请求将其合并回主代码库。</st> <st c="7610">GitHub
    flow 与基于主干的开发非常相似，但它包含了 GitHub 特有的功能，如</st> <st c="7713">拉取请求。</st>'
- en: '**<st c="7727">Git</st>** <st c="7731">is</st> <st c="7735">the most widely
    used version control system.</st> <st c="7780">It is a</st> **<st c="7788">distributed
    version control system</st>**<st c="7822">, which</st> <st c="7829">means we can
    download a repository to our own development machines and, without internet connectivity,
    we can work on the repo by branching and making changes.</st> <st c="7990">Of
    course, if we would like to propagate our changes back to the team, we need to
    get connected and then</st> *<st c="8095">upload</st>* <st c="8101">our changes.</st>
    <st c="8115">There are</st> <st c="8124">also</st> **<st c="8130">centralized
    version control systems</st>** <st c="8165">on the market.</st> <st c="8181">These
    require continuous internet connectivity, which slows down the interaction with
    such repositories</st> <st c="8285">in general.</st>'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="7727">Git</st>** <st c="7731">是</st> <st c="7735">最广泛使用的版本控制系统。</st>
    <st c="7780">它是一个</st> **<st c="7788">分布式版本控制系统</st>**<st c="7822">，这意味着我们可以将一个代码库下载到自己的开发机器上，并且在没有互联网连接的情况下，我们可以通过分支和修改来工作。</st>
    <st c="7990">当然，如果我们想要将我们的更改传播回团队，我们需要连接互联网并</st> *<st c="8095">上传</st>* <st c="8101">我们的更改。</st>
    <st c="8115">市场上也有</st> <st c="8124">**<st c="8130">集中式版本控制系统</st>**<st c="8165">。</st>
    <st c="8181">这些系统需要持续的互联网连接，这通常会减慢与此类代码库的交互速度。</st> <st c="8285">一般来说。</st>'
- en: <st c="8296">Git, a</st> <st c="8304">fast, scalable, distributed revision control
    system is open source.</st> <st c="8372">There are many DevOps tools in which
    the open source Git engine is available, such as GitHub Enterprise, Azure DevOps
    Services, and GitLab.</st> <st c="8512">Of course, these engines are customized
    in a way that service providers can realize</st> <st c="8595">their own operational
    approaches and offer Git as a</st> **<st c="8648">Software-as-a-Service</st>**
    <st c="8669">(</st>**<st c="8671">SaaS</st>**<st c="8675">) offering, but the
    client APIs are compatible with any of</st> <st c="8735">these distributions.</st>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8296">Git 是一个</st> <st c="8304">快速、可扩展、分布式的版本控制系统，并且是开源的。</st> <st c="8372">有很多
    DevOps 工具提供了开源 Git 引擎，比如 GitHub Enterprise、Azure DevOps Services 和 GitLab。</st>
    <st c="8512">当然，这些引擎是经过定制的，服务提供商可以实现</st> <st c="8595">他们自己的操作方式，并将 Git 提供为</st>
    **<st c="8648">软件即服务</st>** <st c="8669">（</st>**<st c="8671">SaaS</st>**<st c="8675">）产品，但客户端
    API 与任何这些分发版本兼容。</st> <st c="8735">这些分发版。</st>
- en: <st c="8755">In general, version control systems</st> <st c="8791">manage plain
    text files because these are the files that can be merged by developers in case
    of conflict resolution (conflicts are readable).</st> <st c="8934">Over the course
    of software history, more and more binary files, such as images, videos, sound
    files, 3D objects, and media files have become part of software solutions.</st>
    <st c="9104">In the early days of software development, these files were maintained
    parallel with the code base, although they were also part of the version that
    was modified/branched by developers.</st> <st c="9290">Git already supports large
    binary</st> <st c="9323">files (</st>**<st c="9331">Git Large File Storage</st>**<st
    c="9354">) and large monolith repositories to ease the migration from other version</st>
    <st c="9430">control systems.</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8755">通常，版本控制系统</st> <st c="8791">管理纯文本文件，因为这些文件在发生冲突时可以被开发者合并（冲突是可读的）。</st>
    <st c="8934">随着软件历史的发展，越来越多的二进制文件，如图像、视频、音频文件、3D对象和媒体文件，已成为软件解决方案的一部分。</st> <st
    c="9104">在软件开发的早期，这些文件与代码库并行维护，尽管它们也是由开发者修改/分支的版本的一部分。</st> <st c="9290">Git 已经支持大文件</st>
    <st c="9323">（</st>**<st c="9331">Git 大文件存储</st>**<st c="9354">）和大规模单体代码库，简化了从其他版本控制系统的迁移。</st>
    <st c="9430">控制系统的迁移。</st>
- en: <st c="9446">Monolith large repositories</st>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9446">单体大规模代码库</st>
- en: <st c="9474">Among others, the code base of Microsoft Windows, with its 250
    GB, is maintained in one large monolith Git repository in an Azure DevOps</st>
    <st c="9612">Services project.</st>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9474">例如，Microsoft Windows 的代码库，大小为 250 GB，维护在一个大型的 Git 单体代码库中，并托管在 Azure
    DevOps</st> <st c="9612">服务项目中。</st>
- en: <st c="9629">The</st> **<st c="9634">Git command-line interface</st>** <st c="9660">(</st>**<st
    c="9662">CLI</st>**<st c="9665">) is a</st> <st c="9672">powerful tool that allows
    developers to interact with Git repositories using a command-line terminal.</st>
    <st c="9775">The Git CLI is available on all major operating systems, including
    Windows, macOS, and Linux.</st> <st c="9869">Some very often used Git commands
    are</st> <st c="9907">the following:</st>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9629">**<st c="9634">Git 命令行界面</st>** <st c="9660">(</st>**<st c="9662">CLI</st>**<st
    c="9665">) 是一个</st> <st c="9672">强大的工具，允许开发人员使用命令行终端与 Git 仓库进行交互。</st> <st c="9775">Git
    CLI 可在所有主要操作系统上使用，包括 Windows、macOS 和 Linux。</st> <st c="9869">一些常用的 Git 命令有：</st>
    <st c="9907">以下是一些：</st>
- en: '`<st c="9921">git clone</st>`<st c="9931">: This</st> <st c="9939">command</st>
    <st c="9947">is used to create a copy of a remote repository on your</st> <st
    c="10003">local machine.</st>'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="9921">git clone</st>`<st c="9931">: 这个</st> <st c="9939">命令</st> <st
    c="9947">用于在你的</st> <st c="10003">本地机器上创建远程仓库的副本。</st>'
- en: '`<st c="10017">git pull</st>`<st c="10026">: This</st> <st c="10033">command
    is used to fetch and merge changes from the remote repository into your</st> <st
    c="10114">local repository.</st>'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="10017">git pull</st>`<st c="10026">: 这个</st> <st c="10033">命令用于从远程仓库获取并合并更改到你的</st>
    <st c="10114">本地仓库。</st>'
- en: '`<st c="10131">git push</st>`<st c="10140">: This</st> <st c="10148">command
    is used to upload your local repository changes (commits and branches) to the</st>
    <st c="10234">remote repository.</st>'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="10131">git push</st>`<st c="10140">: 这个</st> <st c="10148">命令用于将本地仓库的更改（提交和分支）上传到</st>
    <st c="10234">远程仓库。</st>'
- en: '`<st c="10252">git commit</st>`<st c="10263">: This</st> <st c="10271">command
    is used to save changes to your local repository.</st> <st c="10329">It creates
    a new</st> `<st c="10346">commit</st>` <st c="10352">object in the repository
    history with the current state of</st> <st c="10412">the repository.</st>'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="10252">git commit</st>`<st c="10263">: 这个</st> <st c="10271">命令用于将更改保存到本地仓库。</st>
    <st c="10329">它会在仓库历史中创建一个新的</st> `<st c="10346">提交</st>` <st c="10352">对象，记录仓库的当前状态。</st>'
- en: '`<st c="10427">git branch</st>`<st c="10438">: This</st> <st c="10446">command
    is used to manage branches in a Git repository.</st> <st c="10502">It can be used
    to list, create, delete, and</st> <st c="10546">rename branches.</st>'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="10427">git branch</st>`<st c="10438">: 这个</st> <st c="10446">命令用于管理
    Git 仓库中的分支。</st> <st c="10502">它可以用于列出、创建、删除以及</st> <st c="10546">重命名分支。</st>'
- en: '`<st c="10562">git checkout</st>`<st c="10575">: This</st> <st c="10583">command
    is used to switch between branches or to restore files in your working directory
    from</st> <st c="10677">the repository.</st>'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="10562">git checkout</st>`<st c="10575">: 这个</st> <st c="10583">命令用于在分支之间切换，或者从</st>
    <st c="10677">版本库中恢复工作目录中的文件。</st>'
- en: '`<st c="10692">git merge</st>`<st c="10702">: This</st> <st c="10709">command
    is used to merge changes from one branch into another.</st> <st c="10773">It integrates
    changes from the named commits into the</st> <st c="10826">current branch.</st>'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="10692">git merge</st>`<st c="10702">: 这个</st> <st c="10709">命令用于将一个分支的更改合并到另一个分支。</st>
    <st c="10773">它将指定提交的更改集成到</st> <st c="10826">当前分支。</st>'
- en: <st c="10842">Normally, we clone a repo, create a local branch, commit our changes,
    push our branch back to the remote origin, and finally, merge the changes back
    to the parent branch.</st> <st c="11014">This last operation is a special one
    that is sometimes referred to as a pull request depending on the Git distro, like
    GitHub or GitLab.</st> <st c="11151">We can merge branches without pull</st> <st
    c="11186">requests, too.</st>
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10842">通常，我们克隆一个仓库，创建一个本地分支，提交更改，将分支推送回远程源，最后将更改合并回主分支。</st> <st c="11014">这个最后的操作是一个特殊操作，根据不同的
    Git 发行版，可能被称为拉取请求，如 GitHub 或 GitLab。</st> <st c="11151">我们也可以在没有拉取请求的情况下合并分支。</st>
- en: <st c="11200">The</st> **<st c="11205">pull request</st>** <st c="11217">is
    a</st> <st c="11223">mechanism for developers to notify team members that they
    have completed a feature.</st> <st c="11307">Once their feature branch is ready,
    the developer files a pull request via their online repository.</st> <st c="11407">The
    rest of the team then reviews the code and can make comments and suggestions.</st>
    <st c="11489">Once the team agrees that the code is ready, it can be merged into
    the main code base.</st> <st c="11576">Pull requests are a way to</st> *<st c="11603">foster
    code reviews</st>* <st c="11622">and collaboration within a</st> <st c="11650">development
    team.</st>
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11200">**拉取请求**</st> <st c="11205">是一个</st> <st c="11217">开发人员通知团队成员他们已完成一个功能的机制。</st>
    <st c="11307">一旦他们的功能分支准备好，开发人员就会通过在线代码库提交拉取请求。</st> <st c="11407">然后，其他团队成员会审查代码并提出意见和建议。</st>
    <st c="11489">一旦团队达成一致，认为代码已经准备好，就可以将其合并到主代码库中。</st> <st c="11576">拉取请求是一个*促进代码审查*
    </st> <st c="11603">和团队协作的方式</st> <st c="11622">在</st> <st c="11650">开发团队中。</st>
- en: <st c="11667">Pull requests</st>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11667">拉取请求</st>
- en: <st c="11681">Pull requests are</st> <st c="11699">more than just a</st> `<st
    c="11717">git merge</st>` <st c="11726">operation.</st> <st c="11738">DevOps tools
    such as GitHub or Azure DevOps Services provide web UI support and their own CLI
    tools to initiate pull requests</st> <st c="11864">on branches.</st>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11681">拉取请求</st> <st c="11699">不仅仅是一个</st> `<st c="11717">git merge</st>`
    <st c="11726">操作。</st> <st c="11738">像 GitHub 或 Azure DevOps 服务这样的 DevOps 工具提供了网页
    UI 支持以及自己的 CLI 工具来发起拉取请求</st> <st c="11864">在分支上。</st>
- en: <st c="11876">Having understood the key concepts of Git, let us see how it fits
    with our Power Platform solutions.</st> <st c="11978">As we discussed earlier,
    in</st> [*<st c="12006">Chapter 4</st>*](B22208_04.xhtml#_idTextAnchor074)<st
    c="12015">, Power Platform solutions</st> <st c="12041">are available in managed
    and unmanaged formats.</st> <st c="12090">Depending on a solution’s content, the
    difference between managed and unmanaged solutions can vary significantly.</st>
    <st c="12204">For instance, if a solution contains PowerApps application, then
    a managed one will contain a few files and one of them will be the</st> `<st c="12336">msapp</st>`
    <st c="12341">document, which includes every asset of the PowerApps canvas app
    in compressed format.</st> <st c="12429">On the other hand, an unmanaged solution
    will consist of XML and JSON files in a well-defined folder structure describing
    the solution with all its assets, such as apps, flows, bots, connection references,
    and so on, in plain</st> <st c="12655">text format.</st>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11876">理解了 Git 的关键概念后，我们来看一下它是如何与我们的 Power Platform 解决方案结合的。</st> <st
    c="11978">正如我们之前讨论过的，在</st> [*<st c="12006">第 4 章</st>*](B22208_04.xhtml#_idTextAnchor074)<st
    c="12015">中，Power Platform 解决方案</st> <st c="12041">有托管和非托管两种格式。</st> <st c="12090">根据解决方案的内容，托管和非托管解决方案之间的区别可能会有很大差异。</st>
    <st c="12204">例如，如果一个解决方案包含 PowerApps 应用程序，那么托管的解决方案会包含几个文件，其中一个是</st> `<st c="12336">msapp</st>`
    <st c="12341">文档，其中包括 PowerApps 画布应用的所有资产，以压缩格式保存。</st> <st c="12429">另一方面，非托管解决方案将由
    XML 和 JSON 文件组成，按照一个定义明确的文件夹结构来描述解决方案及其所有资产，如应用程序、流程、机器人、连接引用等，以纯文本</st> <st c="12655">格式表示。</st>
- en: <st c="12667">And this is the exact place where version control systems a play
    significant role, as the following</st> <st c="12768">figure illustrates:</st>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12667">而这正是版本控制系统发挥重要作用的地方，正如下图所示：</st>
- en: '![Figure 5.1 – Developer environments with corresponding child branches](img/B22208_05_1.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – 开发者环境及其相应的子分支](img/B22208_05_1.jpg)'
- en: <st c="12871">Figure 5.1 – Developer environments with corresponding child branches</st>
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12871">图 5.1 – 开发者环境及其相应的子分支</st>
- en: <st c="12940">App makers and developers (</st>**<st c="12968">DevA</st>** <st
    c="12973">and</st> **<st c="12978">DevB</st>** <st c="12982">in our case) use
    dedicated developer environments to craft a solution(s).</st> <st c="13057">When
    the first version of their application is created, they commit both the managed
    and unmanaged</st> <st c="13156">Power Platform solutions – the latter one as
    unpacked – to their own child branches, created from the main branch.</st> <st
    c="13271">After that, they work on these branches, and respectively in the corresponding
    environments, by constantly synchronizing the changes between environment and
    branch.</st> <st c="13436">When they are ready, they submit a pull request to
    merge back the changes from the child branch to the main branch.</st> <st c="13552">In
    an ideal case, there is no merge conflict and the changes are integrated into
    the main branch smoothly.</st> **<st c="13659">Merge conflicts</st>** <st c="13674">are</st>
    <st c="13679">conflicting changes – that is, when the same file in the same position
    is changed on both parent and child branches.</st> <st c="13796">If a merge conflict
    occurs, then the pull request is refused, and the developer needs to merge the
    changes back from the main branch to the developer branch and resolve the conflicts
    there.</st> <st c="13986">In the case of Power Platform, it doesn’t mean just
    resolving conflicts at the code level, but also loading the unmanaged solution
    back to the developer environment to check everything works as expected and then
    publishing the changes.</st> <st c="14222">After that, we need to export the solution
    back to the developer branch and resubmit the</st> <st c="14311">pull request.</st>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14324">Overall, branching and child branches allow developers to work
    parallelly even on the same Power Platform solution, but we need to pay careful
    attention and let developers work on different assets</st> <st c="14522">in solutions.</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14535">After getting to know the Git features, let us learn about the
    tool that we can use to export and import solutions in</st> <st c="14654">Power
    Platform.</st>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14669">Power Platform CLI</st>
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="14688">We have already seen some of the</st> <st c="14721">PAC CLI commands
    in the previous chapters, such as signing in to the different environments or
    installing the Power Platform pipeline as a Dynamics 365 application in our environment.</st>
    <st c="14906">Besides these commands, PAC CLI supports many more commands and
    features that we can authenticate on behalf of service principals and manage our
    solutions, environments, deployments, pipelines, and more.</st> <st c="15110">One
    of the biggest advantages of PAC CLI is that it runs on any platform, and can
    be integrated into any</st> <st c="15215">DevOps tool.</st>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15227">Some of the most often-used commands of PAC CLI are</st> <st c="15280">the
    following:</st>
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15294">The</st> `<st c="15299">pac admin</st>` <st c="15308">command</st>
    <st c="15316">group provides a set of commands to work with your Power Platform
    admin account, such as creating an environment, creating service</st> <st c="15448">principals,
    assigning Microsoft Entra ID groups to environments, and</st> <st c="15517">so
    on.</st>
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="15294">The</st>` `<st c="15299">pac admin</st>` `<st c="15308">命令</st>`
    `<st c="15316">组提供一组命令，用于与您的 Power Platform 管理员帐户一起工作，例如创建环境、创建服务</st>` `<st c="15448">主体、将
    Microsoft Entra ID 组分配给环境等。</st>`'
- en: <st c="15523">The</st> `<st c="15528">pac application</st>` <st c="15543">command</st>
    <st c="15551">group is for listing and installing available Dataverse applications
    from AppSource.</st> <st c="15637">We used</st> `<st c="15645">pac application
    install</st>` <st c="15668">to deploy Power Platform pipelines as a Dynamics 365
    application in our production environment in</st> [*<st c="15767">Chapter 4</st>*](B22208_04.xhtml#_idTextAnchor074)<st
    c="15776">.</st>
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="15523">The</st>` `<st c="15528">pac application</st>` `<st c="15543">命令</st>`
    `<st c="15551">组用于列出并安装来自 AppSource 的可用 Dataverse 应用程序。</st>` `<st c="15637">我们使用了</st>`
    `<st c="15645">pac application install</st>` `<st c="15668">将 Power Platform 管道作为
    Dynamics 365 应用程序部署到我们的生产环境中，</st>` [*<st c="15767">第 4 章</st>*](B22208_04.xhtml#_idTextAnchor074)<st
    c="15776">。</st>'
- en: <st c="15777">The</st> `<st c="15782">pac auth</st>` <st c="15790">command</st>
    <st c="15798">group provides a set of commands to authenticate in different services,
    such as environments or whole tenants.</st> <st c="15910">We can use service accounts
    as well as service principals.</st> <st c="15969">Our credentials are stored locally</st>
    <st c="16004">if needed.</st>
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="15777">The</st>` `<st c="15782">pac auth</st>` `<st c="15790">命令</st>`
    `<st c="15798">组提供一组命令，用于在不同的服务中进行身份验证，例如环境或整个租户。</st>` `<st c="15910">我们可以使用服务帐户以及服务主体。</st>`
    `<st c="15969">我们的凭证会被本地存储</st>` `<st c="16004">（如有需要）</st>`。'
- en: <st c="16014">The</st> `<st c="16019">pac canvas</st>` <st c="16029">commands</st>
    <st c="16039">work with Power Apps</st> `<st c="16060">.msapp</st>` <st c="16066">files.</st>
    <st c="16074">These files are created when we export canvas apps from Power Apps
    Studio directly or as part of our Power</st> <st c="16181">Platform solutions.</st>
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="16014">The</st>` `<st c="16019">pac canvas</st>` `<st c="16029">命令</st>`
    `<st c="16039">与 Power Apps</st>` `<st c="16060">.msapp</st>` `<st c="16066">文件</st>`
    `<st c="16074">一起使用。这些文件是在我们直接从 Power Apps Studio 导出画布应用程序时创建的，或者作为我们 Power</st>`
    `<st c="16181">平台解决方案</st>`。'
- en: <st c="16200">The</st> `<st c="16205">pac catalog</st>` <st c="16216">command</st>
    <st c="16224">group provides commands for managing the</st> `<st c="16395">pac
    catalog</st>` <st c="16406">command group include</st> `<st c="16429">pac catalog
    install</st>`<st c="16448">, which installs a catalog item in the target environment,
    and</st> `<st c="16511">pac catalog list</st>`<st c="16527">, which lists all
    published catalog items from the current</st> <st c="16586">Dataverse organization.</st>
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="16200">The</st>` `<st c="16205">pac catalog</st>` `<st c="16216">命令</st>`
    `<st c="16224">组提供用于管理</st>` `<st c="16395">pac catalog</st>` `<st c="16406">命令组的命令，包括</st>`
    `<st c="16429">pac catalog install</st>` `<st c="16448">，它将在目标环境中安装目录项，以及</st>`
    `<st c="16511">pac catalog list</st>` `<st c="16527">，它列出当前</st>` `<st c="16586">Dataverse
    组织中的所有已发布目录项。</st>`'
- en: <st c="16609">The</st> `<st c="16614">pac copilot</st>` <st c="16625">command</st>
    <st c="16633">group provides commands for managing chatbots and AI Builder models
    (among others, new large language models).</st> <st c="16745">Some of the commands
    available include</st> `<st c="16784">pac copilot predict</st>`<st c="16803">,
    which sends text or prompts to an AI model,</st> `<st c="16849">pac copilot create</st>`
    <st c="16867">for creating a new bot using an existing template file as the reference,
    and</st> `<st c="16945">pac copilot list</st>` <st c="16961">for listing virtual
    agents in the current or target</st> <st c="17014">Dataverse environment.</st>
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="16609">The</st>` `<st c="16614">pac copilot</st>` `<st c="16625">命令</st>`
    `<st c="16633">组提供用于管理聊天机器人和 AI Builder 模型的命令（包括新型大语言模型等）。</st>` `<st c="16745">一些可用的命令包括</st>`
    `<st c="16784">pac copilot predict</st>` `<st c="16803">，该命令将文本或提示发送到 AI 模型，</st>`
    `<st c="16849">pac copilot create</st>` `<st c="16867">用于使用现有模板文件作为参考创建新机器人，</st>`
    `<st c="16945">pac copilot list</st>` `<st c="16961">用于列出当前或目标 Dataverse 环境中的虚拟代理。</st>`'
- en: <st c="17036">The</st> `<st c="17041">pac package</st>` <st c="17052">command</st>
    <st c="17060">group is a set of tools and utilities for</st> <st c="17103">managing
    packages.</st> <st c="17122">It includes commands such as</st> `<st c="17151">pac
    package add-external-package</st>` <st c="17183">for adding a package that is
    external to the Dataverse solution system to</st> <st c="17257">a</st> `<st c="17286">pac
    package add-reference</st>` <st c="17311">for adding a reference to a Dataverse
    solution project, and</st> `<st c="17372">pac package add-solution</st>` <st c="17396">for
    adding a prebuilt Dataverse solution file to a Package Deployer project.</st>
    <st c="17474">Please note that, in</st> [*<st c="17495">Chapter 4</st>*](B22208_04.xhtml#_idTextAnchor074)<st
    c="17504">, we discussed the Package Deployer in the context of Power Platform
    Enterprise</st> <st c="17584">templates, too.</st>
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="17036">The</st>` `<st c="17041">pac package</st>` 命令组是一组用于管理包的工具和实用程序。它包括一些命令，比如`<st
    c="17151">pac package add-external-package</st>`用于将一个外部的包添加到Dataverse解决方案系统中，`<st
    c="17286">pac package add-reference</st>`用于向Dataverse解决方案项目中添加引用，以及`<st c="17372">pac
    package add-solution</st>`用于将一个预构建的Dataverse解决方案文件添加到Package Deployer项目中。请注意，我们在[*<st
    c="17495">第4章</st>*](B22208_04.xhtml#_idTextAnchor074)中也讨论了Power Platform企业模板中的Package
    Deployer。'
- en: <st c="17599">The</st> `<st c="17604">pac pcf</st>` <st c="17611">command group</st>
    <st c="17625">is used for</st> <st c="17638">managing and working with</st> `<st
    c="17741">pac pcf init</st>` <st c="17753">for initializing a new Power Apps component
    framework project in the current directory, and</st> `<st c="17846">pac pcf push</st>`
    <st c="17858">for pushing the component to the Power Apps component framework</st>
    <st c="17923">developer environment.</st>
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="17599">The</st>` `<st c="17604">pac pcf</st>` 命令组用于与`<st c="17741">pac
    pcf init</st>`一起初始化当前目录中的新Power Apps组件框架项目，并且与`<st c="17846">pac pcf push</st>`一起将组件推送到Power
    Apps组件框架开发环境中。'
- en: <st c="17945">The</st> `<st c="17950">pac pipeline</st>` <st c="17962">command</st>
    <st c="17970">group is used to work with Power Platform pipelines.</st> <st c="18024">For
    example,</st> `<st c="18037">pac pipeline deploy</st>` <st c="18056">is used to
    start pipeline deployment, while</st> `<st c="18101">pac pipeline list</st>` <st
    c="18118">is used to list pipelines in the given environment.</st> <st c="18171">This
    command group provides the option for administrators and ops teams to start deployments
    in a fully automated way, as we discussed in</st> [*<st c="18309">Chapter 4</st>*](B22208_04.xhtml#_idTextAnchor074)<st
    c="18318">.</st>
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="17945">The</st>` `<st c="17950">pac pipeline</st>` 命令组用于与Power Platform管道一起工作。举例来说，`<st
    c="18037">pac pipeline deploy</st>` 用于启动管道部署，而`<st c="18101">pac pipeline list</st>`
    用于列出给定环境中的管道。此命令组为管理员和操作团队提供了以完全自动化的方式启动部署的选项，正如我们在[*<st c="18309">第4章</st>*](B22208_04.xhtml#_idTextAnchor074)中讨论的那样。'
- en: <st c="18319">The</st> `<st c="18324">pac plugin</st>` <st c="18334">command</st>
    <st c="18342">group is used to work with</st> `<st c="18446">pac plugin init</st>`
    <st c="18461">is used to initialize a directory with a new Dataverse plugin class
    library, while</st> `<st c="18545">pac plugin push</st>` <st c="18560">is used
    to import a plugin into Dataverse.</st> <st c="18604">We can use .NET Framework-based
    plugins to react to Dataverse events on the server side running in the context
    of the</st> <st c="18722">Dataverse engine.</st>
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="18319">The</st>` `<st c="18324">pac plugin</st>` 命令组用于与`<st c="18446">pac
    plugin init</st>`一起初始化一个新的Dataverse插件类库目录，而`<st c="18545">pac plugin push</st>`则用于将插件导入到Dataverse中。我们可以使用基于.NET
    Framework的插件，在Dataverse引擎的上下文中响应服务器端的Dataverse事件。'
- en: <st c="18739">The</st> `<st c="18744">pac powerpages</st>` <st c="18758">command
    group</st> <st c="18772">is for</st> <st c="18780">managing</st> `<st c="18853">pac
    powerpages list</st>` <st c="18872">is used to list all</st> <st c="18893">Power
    Pages websites from the current Dataverse environment, while</st> `<st c="18960">pac
    powerpages download</st>` <st c="18983">is used to download Power Pages website
    content from the current Dataverse environment to move it to another environment
    with</st> `<st c="19110">pac</st>` `<st c="19114">powerpages upload</st>`<st c="19131">.</st>
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="18739">`<st c="18744">pac powerpages</st>` <st c="18758">命令组</st> <st
    c="18772">用于</st> <st c="18780">管理</st> `<st c="18853">pac powerpages list</st>`
    <st c="18872">用于列出当前 Dataverse 环境中的所有 Power Pages 网站，而</st> `<st c="18960">pac
    powerpages download</st>` <st c="18983">用于从当前 Dataverse 环境下载 Power Pages 网站内容，以便将其迁移到另一个环境，配合</st>
    `<st c="19110">pac</st>` `<st c="19114">powerpages upload</st>`<st c="19131">。</st>
- en: <st c="19132">The</st> `<st c="19137">pac solution</st>` <st c="19149">command
    group</st> <st c="19163">is used to work</st> <st c="19179">with</st> `<st c="19249">pac
    solution</st>` <st c="19261">command group include</st> `<st c="19284">pac solution
    init</st>`<st c="19301">, which initializes an MSBuild-based</st> `<st c="19338">cdsproj</st>`
    <st c="19345">file for component framework components;</st> `<st c="19387">pac
    solution add-reference</st>`<st c="19413">, which adds a reference from the project
    in the current directory to the project at the specified path; and</st> `<st c="19522">pac
    solution add-solution-component</st>`<st c="19557">, which adds one or more solution
    components to the target unmanaged solution in Dataverse.</st> <st c="19649">Imports
    and exports of solutions are also supported by the equivalent</st> `<st c="19719">pac</st>`
    `<st c="19723">solution</st>` <st c="19731">commands.</st>
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="19132">`<st c="19137">pac solution</st>` <st c="19149">命令组</st> <st c="19163">用于操作</st>
    <st c="19179">与</st> `<st c="19249">pac solution</st>` <st c="19261">命令组包括</st>
    `<st c="19284">pac solution init</st>`<st c="19301">，用于初始化一个基于 MSBuild 的</st>
    `<st c="19338">cdsproj</st>` <st c="19345">文件，适用于组件框架组件；</st> `<st c="19387">pac
    solution add-reference</st>`<st c="19413">，用于将当前目录中的项目引用添加到指定路径下的项目；以及</st> `<st
    c="19522">pac solution add-solution-component</st>`<st c="19557">，用于将一个或多个解决方案组件添加到
    Dataverse 中的目标非托管解决方案。</st> <st c="19649">解决方案的导入和导出也通过相应的</st> `<st c="19719">pac</st>`
    `<st c="19723">solution</st>` <st c="19731">命令进行支持。</st>
- en: <st c="19741">PAC CLI and Power Platform PowerShell modules</st>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19741">PAC CLI 和 Power Platform PowerShell 模块</st>
- en: <st c="19787">PAC CLI is the next-generation command-line tool for Power Platform,
    which runs on any OS platform.</st> <st c="19888">PowerShell admin capabilities
    are continuously migrated to PAC CLI to reach feature parity in the future.</st>
    <st c="19994">PAC CLI and PowerShell modules are wrappers around the underlying
    REST API endpoints of</st> <st c="20082">Power Platform.</st>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19787">PAC CLI 是 Power Platform 的下一代命令行工具，能够在任何操作系统平台上运行。</st> <st c="19888">PowerShell
    管理功能正在不断迁移到 PAC CLI，以便在未来达到功能上的一致性。</st> <st c="19994">PAC CLI 和 PowerShell 模块是对</st>
    <st c="20082">Power Platform</st> 的底层 REST API 端点的封装。</st>
- en: <st c="20097">To install PAC CLI, we need to have .NET Core 3.1 or later (.NET
    6 is recommended) already deployed to our machine.</st> <st c="20214">After that,
    we can execute the following command in our favorite terminal (CMD on Windows,
    Bash on Linux, or Terminal</st> <st c="20332">on macOS):</st>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20097">要安装 PAC CLI，我们需要先确保机器上已部署 .NET Core 3.1 或更高版本（推荐使用 .NET 6）。</st>
    <st c="20214">然后，我们可以在喜爱的终端（Windows 上使用 CMD，Linux 上使用 Bash，macOS 上使用 Terminal）中执行以下命令：</st>
- en: '[PRE0]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="20400">Now that we have learned about the breadth and depth of the commands
    available in PAC CLI, in the next sections, we will understand how this CLI tool
    is utilized by Azure DevOps Services and</st> <st c="20592">GitHub Enterprise.</st>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20400">现在我们已经了解了 PAC CLI 中命令的广度和深度，在接下来的章节中，我们将了解该 CLI 工具如何被 Azure DevOps
    Services 和</st> <st c="20592">GitHub Enterprise</st> 使用。</st>
- en: <st c="20610">Power Platform build tools for Azure DevOps</st>
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="20610">Power Platform 构建工具用于 Azure DevOps</st>
- en: '**<st c="20654">Azure Pipelines</st>** <st c="20670">stands</st> <st c="20678">out
    as a robust feature within Azure DevOps Services, offering a</st> <st c="20742">comprehensive</st>
    **<st c="20757">continuous integration</st>** <st c="20779">(</st>**<st c="20781">CI</st>**<st
    c="20783">) and</st> **<st c="20790">continuous delivery</st>** <st c="20809">(</st>**<st
    c="20811">CD</st>**<st c="20813">) service.</st> <st c="20825">Compatible with
    your Git provider of choice (GitHub or</st> <st c="20879">Azure DevOps), it enables
    deployments across various major cloud providers, including Microsoft Azure.</st>
    <st c="20983">This service streamlines the process of building, testing, and deploying
    your code base.</st> <st c="21072">It supports an</st> <st c="21086">extensive
    array of programming</st> <st c="21118">languages and platforms, such as .NET,
    Java, Node.js, Android, Xcode, and C++, and allows for a variety of testing frameworks
    and services to be utilized.</st> <st c="21273">Additionally, Azure Pipelines
    enables the execution of scripts in the command line, PowerShell, Bash, or Shell
    within your</st> <st c="21396">automation workflows.</st>'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="20654">Azure Pipelines</st>** <st c="20670">作为 Azure DevOps Services
    中的一个强大功能脱颖而出，提供</st> <st c="20742">全面的</st> **<st c="20757">持续集成</st>** <st c="20779">（</st>**<st
    c="20781">CI</st>**<st c="20783">）和</st> **<st c="20790">持续交付</st>** <st c="20809">（</st>**<st
    c="20811">CD</st>**<st c="20813">）服务。</st> <st c="20825">它兼容您选择的 Git 提供商（GitHub
    或</st> <st c="20879">Azure DevOps），并支持跨多个主要云提供商进行部署，包括微软 Azure。</st> <st c="20983">此服务简化了构建、测试和部署代码库的过程。</st>
    <st c="21072">它支持广泛的编程</st> <st c="21086">语言和平台，例如 .NET、Java、Node.js、Android、Xcode
    和 C++，并支持使用各种测试框架和服务。</st> <st c="21273">此外，Azure Pipelines 还支持在命令行、PowerShell、Bash
    或 Shell 中执行脚本，作为自动化工作流的一部分。</st>'
- en: <st c="21417">Azure Pipelines also provides the infrastructure in which our
    scripts and pipeline tasks can run.</st> **<st c="21516">Azure Pipelines agents</st>**
    <st c="21538">are</st> <st c="21542">containers (virtual machines in a virtual
    machine scale set) that execute our jobs (pipeline tasks).</st> <st c="21644">Agents
    are installed in these machines, and they use HTTP outbound connectivity to Azure
    DevOps endpoints to pull the activities they need</st> <st c="21783">to run.</st>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21417">Azure Pipelines 还提供了运行脚本和流水线任务所需的基础设施。</st> **<st c="21516">Azure
    Pipelines 代理</st>** <st c="21538">是</st> <st c="21542">容器（虚拟机规模集中的虚拟机），执行我们的作业（流水线任务）。</st>
    <st c="21644">代理被安装在这些机器中，并通过 HTTP 出站连接到 Azure DevOps 端点，拉取它们需要执行的活动。</st>
- en: <st c="21790">There are different types of agents, including Microsoft-hosted
    agents, self-hosted agents, and Azure Virtual Machine Scale</st> <st c="21915">Set
    agents:</st>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21790">代理有不同类型，包括微软托管代理、自托管代理和 Azure 虚拟机规模集</st> <st c="21915">代理：</st>
- en: '**<st c="21926">Microsoft-hosted agents</st>** <st c="21950">provide a</st>
    <st c="21960">hassle-free solution for executing your jobs.</st> <st c="22007">These
    agents are fully managed by Microsoft, ensuring that they are always up to date
    with the latest virtual machine image specified in your YAML pipeline, without
    requiring any maintenance or upgrades on</st> <st c="22213">our part.</st>'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="21926">微软托管代理</st>** <st c="21950">提供了一个</st> <st c="21960">无忧的解决方案，用于执行您的作业。</st>
    <st c="22007">这些代理由微软全面管理，确保始终使用您 YAML 流水线中指定的最新虚拟机映像，而无需我们进行任何维护或升级。</st>'
- en: '**<st c="22222">Self-hosted agents</st>** <st c="22241">are those</st> <st
    c="22251">that we set up and maintain on our own virtual machines.</st> <st c="22309">This
    option provides us with greater control over the machine specifications and the
    operating system images utilized by</st> <st c="22430">the agents.</st>'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="22222">自托管代理</st>** <st c="22241">是</st> <st c="22251">我们在自己的虚拟机上设置并维护的代理。</st>
    <st c="22309">此选项使我们能够更好地控制代理使用的机器规格和操作系统映像。</st>'
- en: '**<st c="22441">Azure Virtual Machine Scale Set agents</st>** <st c="22480">are</st>
    <st c="22485">a kind of self-hosted agent that embraces the Virtual Machine Sale
    Set’s autoscaling features heavily.</st> <st c="22588">Azure DevOps scales out
    and scales in VMs based on the size of</st> <st c="22651">pipeline queues.</st>'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="22441">Azure 虚拟机规模集代理</st>** <st c="22480">是</st> <st c="22485">一种自托管代理，充分利用虚拟机规模集的自动扩展功能。</st>
    <st c="22588">Azure DevOps 根据</st> <st c="22651">流水线队列的大小扩展或缩减虚拟机。</st>'
- en: <st c="22667">In Azure Pipelines, a</st> **<st c="22690">job</st>** <st c="22693">is</st>
    <st c="22697">a series of steps that run sequentially as a unit.</st> <st c="22748">Every
    pipeline has at least one job, and a job is the smallest unit of work that can
    be scheduled to run.</st> <st c="22854">Jobs can be organized into stages, and
    you can specify conditions and dependencies to control when jobs run.</st> <st
    c="22963">Jobs can run on Microsoft-hosted agents, self-hosted agents, or Azure
    Virtual Machine Scale Set agents, and can be run directly on the host machine
    of the agent or in a container.</st> <st c="23143">Azure Pipelines supports running
    jobs in parallel on Linux, macOS, and Windows.</st> <st c="23223">You can create
    and configure pipelines in the Azure DevOps web portal with the classic user interface
    editor as well as with the latest YAML-based script editor.</st> <st c="23385">We
    prefer the latter because the version control management of these YAML files is
    also available in</st> <st c="23486">that case.</st>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22667">在 Azure Pipelines 中，</st> **<st c="22690">作业</st>** <st c="22693">是一系列按顺序运行的步骤，作为一个单元执行。</st>
    <st c="22748">每个管道至少有一个作业，作业是可以调度运行的最小工作单元。</st> <st c="22854">作业可以组织成阶段，并且你可以指定条件和依赖关系来控制作业的运行时机。</st>
    <st c="22963">作业可以在 Microsoft 托管的代理、自托管的代理或 Azure 虚拟机规模集代理上运行，并且可以直接在代理的主机机器上或在容器中运行。</st>
    <st c="23143">Azure Pipelines 支持在 Linux、macOS 和 Windows 上并行运行作业。</st> <st c="23223">你可以在
    Azure DevOps Web 门户中创建和配置管道，使用经典的用户界面编辑器，也可以使用最新的基于 YAML 的脚本编辑器。</st> <st c="23385">我们更倾向于后者，因为这种情况下，YAML
    文件的版本控制管理也是可用的。</st>
- en: <st c="23496">The advanced capabilities of</st> <st c="23526">Azure Pipelines,
    like the infrastructure and</st> <st c="23571">topology of Microsoft-hosted and
    self-hosted build agents, are beyond this book, but you can find further information
    and learning modules in the</st> *<st c="23717">Further</st>* *<st c="23725">reading</st>*
    <st c="23732">section.</st>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23496">Azure Pipelines 的高级功能，如 Microsoft 托管和自托管构建代理的基础设施和</st> <st c="23526">拓扑，超出了本书的范围，但你可以在</st>
    *<st c="23717">进一步</st>* *<st c="23725">阅读</st>* <st c="23732">部分找到更多信息和学习模块。</st>
- en: <st c="23741">On top of Azure</st> <st c="23758">Pipelines,</st> **<st c="23769">Microsoft
    Build Tools for Power Platform (Microsoft Power Platform Build Tools for Azure
    DevOps)</st>** <st c="23865">provides additional tasks in Azure DevOps that can
    be used to automate common build and deployment tasks related to solutions built
    on Microsoft Power Platform.</st> <st c="24027">Some of the available tasks include
    the</st> **<st c="24067">Power Platform Tool Installer</st>**<st c="24096">, which
    installs</st> <st c="24113">Power Platform tools (among others, the PAC CLI in
    the agent).</st> <st c="24176">This build task is a mandatory step at the beginning
    of every build and release pipeline in which we would like to use other Power
    Platform build tasks.</st> <st c="24329">The build tools work for canvas- and
    model-driven apps, Microsoft Copilot Studio, cloud and desktop flows, Power Pages
    websites, AI Builder models, custom connectors, and dataflows, for everything
    that can be added to</st> <st c="24547">a solution.</st>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23741">在 Azure</st> <st c="23758">Pipelines 之上，</st> **<st c="23769">Microsoft
    Power Platform Build Tools（Microsoft Power Platform Build Tools for Azure DevOps）</st>**
    <st c="23865">提供了 Azure DevOps 中的附加任务，可用于自动化与 Microsoft Power Platform 上构建的解决方案相关的常见构建和部署任务。</st>
    <st c="24027">其中一些可用任务包括</st> **<st c="24067">Power Platform 工具安装程序</st>**<st
    c="24096">，该程序安装</st> <st c="24113">Power Platform 工具（包括 PAC CLI 在代理中的安装）。</st>
    <st c="24176">这是每个构建和发布管道开始时的必选步骤，尤其是当我们希望使用其他 Power Platform 构建任务时。</st> <st
    c="24329">这些构建工具适用于画布应用、模型驱动应用、Microsoft Copilot Studio、云端和桌面流程、Power Pages 网站、AI
    Builder 模型、自定义连接器以及数据流，适用于所有可以添加到</st> <st c="24547">解决方案中的内容。</st>
- en: <st c="24558">Every build task uses PAC CLI under the hood and the Power Platform
    wrapper provides a common interface for Azure DevOps Pipelines and</st> <st c="24694">GitHub
    Actions:</st>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24558">每个构建任务都在后台使用 PAC CLI，Power Platform 包装器为 Azure DevOps Pipelines
    和</st> <st c="24694">GitHub Actions 提供了一个通用接口：</st>
- en: '![Figure 5.2 – Power Platform build tools and GitHub Actions architecture](img/B22208_05_2.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – Power Platform 构建工具和 GitHub Actions 架构](img/B22208_05_2.jpg)'
- en: <st c="24793">Figure 5.2 – Power Platform build tools and GitHub Actions architecture</st>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24793">图 5.2 – Power Platform 构建工具和 GitHub Actions 架构</st>
- en: <st c="24864">This means that when we</st> <st c="24889">use a task such as</st>
    `<st c="24908">PowerPlatformExportSolution@2</st>`<st c="24937">, then this pipeline
    task executes the corresponding PAC CLI</st> <st c="24997">command through the
    wrapper with the appropriate parameters.</st> <st c="25059">Let us have a look
    at a pipeline that exports a managed solution, unpacks it, and publishes it to
    the build artifacts (see</st> `<st c="25182">.pipelines/powerlatform-exportsolution.yml</st>`
    <st c="25224">in the</st> `<st c="25232">Chapter05</st>` <st c="25241">folder
    of the</st> <st c="25256">GitHub repo):</st>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="24864">这意味着，当我们</st>` `<st c="24889">使用类似</st>` `<st c="24908">PowerPlatformExportSolution@2</st>`
    `<st c="24937">的任务时，</st>` `<st c="24997">该管道任务会通过包装器执行相应的 PAC CLI 命令，</st>` `<st
    c="25059">并使用适当的参数。</st>` `<st c="25256">让我们来看一个导出受管解决方案的管道，它解压并发布到构建工件中（请参见</st>`
    `<st c="25182">.pipelines/powerlatform-exportsolution.yml</st>` `<st c="25224">文件，位于</st>`
    `<st c="25232">Chapter05</st>` `<st c="25241">文件夹中，</st>` `<st c="25256">GitHub
    仓库中）：</st>`'
- en: '[PRE1]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<st c="26290">The</st> `<st c="26295">PowerPlatformExportSolution@2</st>` <st
    c="26324">uses a service connection (</st>`<st c="26352">PowerPlatformSPN: ''PowerPlatformE5-Default''</st>`<st
    c="26396">) to connect to the Dataverse.</st> **<st c="26428">Service connections</st>**
    <st c="26447">allow</st> <st c="26454">you to connect to external and remote services
    to execute tasks in</st> <st c="26520">your pipelines.</st> <st c="26537">They
    provide a way to authenticate and authorize Azure DevOps with external services</st>
    <st c="26621">so that Azure DevOps can access resources and perform operations
    on your behalf, or on behalf of service principals.</st> <st c="26739">There is
    a dedicated service connection for</st> <st c="26783">Power Platform.</st>'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="26290">The</st>` `<st c="26295">PowerPlatformExportSolution@2</st>`
    `<st c="26324">使用服务连接（</st>` `<st c="26352">PowerPlatformSPN: ''PowerPlatformE5-Default''</st>`
    `<st c="26396">）连接到 Dataverse。</st>` **<st c="26428">服务连接</st>** `<st c="26447">允许</st>`
    `<st c="26454">您连接到外部和远程服务，以在</st>` `<st c="26520">您的管道中执行任务。</st>` `<st c="26537">它们提供了一种方法，能够使用外部服务对
    Azure DevOps 进行身份验证和授权，</st>` `<st c="26621">使 Azure DevOps 能够代表您或代表服务主体访问资源并执行操作。</st>`
    `<st c="26739">为</st>` `<st c="26783">Power Platform 提供了专用的服务连接。</st>`'
- en: <st c="26798">We have just discovered how to use the familiar Azure Pipelines
    YAML-based approach for Power Platform CI/CD, just as we do for other custom</st>
    <st c="26940">development projects.</st>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="26798">我们刚刚发现，如何使用熟悉的 Azure Pipelines 基于 YAML 的方法来进行 Power Platform
    CI/CD，</st>` `<st c="26940">就像我们为其他自定义开发项目所做的那样。</st>`'
- en: <st c="26961">GitHub Actions for Power Platform</st>
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`<st c="26961">GitHub Actions for Power Platform</st>`'
- en: '**<st c="26995">GitHub Actions</st>** <st c="27010">were</st> <st c="27015">originally
    designed and developed by the same engineering teams that created the Azure Pipelines
    after Microsoft had acquired GitHub.</st> <st c="27150">At the time of acquisition,
    GitHub did not even support any of the automation that Azure Pipelines</st> <st
    c="27249">offered developers.</st>'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="26995">GitHub Actions</st>** `<st c="27010">最初由与创建 Azure Pipelines
    相同的工程团队设计和开发，</st>` `<st c="27015">这是在微软收购 GitHub 后的事情。</st>` `<st c="27150">在收购时，GitHub
    甚至没有支持 Azure Pipelines 提供的任何自动化功能。</st>`'
- en: <st c="27268">That’s why it is not surprising that the GitHub Actions engine,
    the infrastructure, the agents (runners in GitHub), and the concept are more or
    less the same as in Azure DevOps.</st> <st c="27447">And in some cases, GitHub
    Actions is even better.</st> <st c="27497">It can provide much more trigger conditions
    than Azure Pipelines.</st> <st c="27563">For instance GitHub Actions can react
    to changes in GitHub issues – in pull request comments, in Wiki pages, and in
    general to changes to any asset surrounding a GitHub project.</st> <st c="27741">These
    actions are lightweight functions, and the trigger framework can easily be extended</st>
    <st c="27831">with webhooks.</st>
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="27268">因此，GitHub Actions 引擎、基础设施、代理（在 GitHub 中是 runners）和概念与 Azure
    DevOps 的几乎相同，也不奇怪。</st>` `<st c="27447">在某些情况下，GitHub Actions 甚至更好。</st>` `<st
    c="27497">它可以提供比 Azure Pipelines 更多的触发条件。</st>` `<st c="27563">例如，GitHub Actions
    可以响应 GitHub 问题中的变化——包括拉取请求评论、Wiki 页面上的变化，以及 GitHub 项目相关资产的其他变化。</st>` `<st c="27741">这些操作是轻量级函数，触发框架可以通过
    webhook 轻松扩展。</st>`'
- en: <st c="27845">GitHub has its own build agents, which are</st> <st c="27889">called</st>
    **<st c="27896">GitHub runners</st>**<st c="27910">.</st>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="27845">GitHub 有自己的构建代理，这些代理被称为</st>` **<st c="27896">GitHub runners</st>**`<st
    c="27910">。</st>`'
- en: <st c="27911">Behind the scenes, the agent runtime, the Windows service, and
    the Linux/macOS daemon that host GitHub Actions are nearly identical to the runtime
    used in Azure DevOps Services.</st> <st c="28090">GitHub runners are virtual machines
    that run your GitHub Actions workflows.</st> <st c="28166">They are available
    in two</st> <st c="28191">types:</st> **<st c="28199">GitHub-hosted</st>** <st
    c="28212">and</st> **<st c="28217">self-hosted</st>**<st c="28228">. For</st>
    <st c="28234">professionals, GitHub offers a range of managed virtual machines
    with more RAM, CPU, and disk space for customers on GitHub Team and GitHub Enterprise
    Cloud plans.</st> <st c="28398">These larger runners are hosted by GitHub and
    have the runner application and other preinstalled tools.</st> <st c="28502">GitHub-hosted
    runners make it easy for GitHub Enterprise plan customers to securely connect
    their CI/CD machines to other DevOps services in the cloud or on-prem, such</st>
    <st c="28669">as</st> **<st c="28673">Artifactory</st>**<st c="28684">,</st> **<st
    c="28686">Nexus</st>**<st c="28691">, or any</st> <st c="28699">other service,
    with the help of reserved static IP ranges or by using Azure Virtual Networks.</st>
    <st c="28794">In the case of public GitHub repositories, every month, the first
    2,000 minutes of GitHub-hosted runners’ executions are free</st> <st c="28920">of
    charge.</st>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，托管 GitHub Actions 的代理运行时、Windows 服务和 Linux/macOS 守护进程与 Azure DevOps 服务中使用的运行时几乎相同。GitHub
    运行器是运行 GitHub Actions 工作流的虚拟机。它们有两种类型：**GitHub 托管**和**自托管**。对于专业人员，GitHub 提供了一系列托管虚拟机，这些虚拟机具有更多的内存、CPU
    和磁盘空间，供 GitHub Team 和 GitHub Enterprise Cloud 计划的客户使用。这些较大的运行器由 GitHub 托管，预装了运行器应用程序和其他工具。GitHub
    托管的运行器使 GitHub Enterprise 计划的客户能够轻松、安全地将其 CI/CD 机器连接到云端或本地的其他 DevOps 服务，例如**Artifactory**、**Nexus**或任何其他服务，利用保留的静态
    IP 范围或通过使用 Azure 虚拟网络来实现。在公共 GitHub 仓库的情况下，每个月前 2,000 分钟的 GitHub 托管运行器执行是免费的。
- en: <st c="28930">For more</st> <st c="28939">granular control, you can also combine
    runner groups with labels.</st> **<st c="29006">Runner groups</st>** <st c="29019">can
    only have large</st> <st c="29040">runners or self-hosted runners as members.</st>
    <st c="29083">This provides professionals with the flexibility to choose the best
    runner for their specific needs.</st> <st c="29184">GitHub runners can also run
    inside Docker containers.</st> <st c="29238">By doing so, we can even easily spin
    up Kubernetes-based</st> <st c="29295">build/deployment farms.</st>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得更细粒度的控制，您还可以将运行器组与标签结合使用。**运行器组**只能包含大型运行器或自托管运行器作为成员。这样，专业人员可以灵活选择最适合其特定需求的运行器。GitHub
    运行器也可以在 Docker 容器中运行。通过这样做，我们甚至可以轻松地构建基于 Kubernetes 的构建/部署集群。
- en: <st c="29318">Both GitHub runners and Azure DevOps agents are open source projects
    and welcome contributors from all around the world (see the GitHub repository
    links under</st> *<st c="29478">Further reading</st>*<st c="29493">).</st>
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 运行器和 Azure DevOps 代理都是开源项目，欢迎来自世界各地的贡献者（请参阅“*进一步阅读*”下的 GitHub 仓库链接）。
- en: '<st c="29496">Regarding the workflow definitions: there are also some differences
    in YAML tags and keywords, but the main design principles are</st> <st c="29627">the
    same.</st>'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 关于工作流定义：YAML 标签和关键字也存在一些差异，但主要设计原则是相同的。
- en: <st c="29636">Azure DevOps Services versus GitHub</st>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Azure DevOps 服务与 GitHub
- en: <st c="29672">A frequently asked question in the</st> <st c="29708">industry
    is whether Azure DevOps Services or</st> <st c="29753">GitHub is the future.</st>
    <st c="29775">The Microsoft strategy at the time of writing is to recommend GitHub
    for greenfield organizations – organizations who are just starting their DevOps
    journeys.</st> <st c="29934">If an organization already uses Azure DevOps, then
    Microsoft recommends introducing GitHub only in areas in which it brings a compelling
    advantage.</st> *<st c="30082">This compelling advantage is now GitHub Copilot</st>*<st
    c="30129">. In the last few years, we have seen that the investment in GitHub
    features has been 5-10 times greater than in Azure</st> <st c="30248">DevOps Services.</st>
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29672">在行业中，一个常见的问题是 Azure DevOps Services 还是</st> <st c="29708">GitHub
    是未来的趋势。</st> <st c="29753">在撰写本文时，微软的策略是建议绿色场景组织（即刚开始 DevOps 之旅的组织）使用 GitHub。</st>
    <st c="29934">如果一个组织已经使用了 Azure DevOps，那么微软建议只在能带来显著优势的领域引入 GitHub。</st> *<st
    c="30082">这种显著优势现在体现在 GitHub Copilot</st>*<st c="30129">。在过去几年中，我们看到对 GitHub 功能的投资比
    Azure DevOps Services 大了 5-10 倍。</st>
- en: <st c="30264">In the next section, we will look closely at GitHub workflows
    and actions</st> <st c="30339">at work.</st>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30264">在下一节中，我们将仔细研究 GitHub 工作流和操作</st> <st c="30339">的实际应用。</st>
- en: <st c="30347">Managed pipelines – source control integration with Git</st>
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="30347">管理管道 – 与 Git 的源代码控制集成</st>
- en: <st c="30403">In</st> [*<st c="30407">Chapter 4</st>*](B22208_04.xhtml#_idTextAnchor074)<st
    c="30416">, we created our</st> <st c="30432">first Power Platform managed pipeline,
    which deployed our</st> `<st c="30491">mpa_ITBase</st>` <st c="30501">solution
    from the developer environment to the production environment using a service principal.</st>
    <st c="30599">In this section, we continue our journey and, based on the lessons
    learned about PAC CLI, build tools for Azure DevOps Services, and GitHub Actions
    for Power Platform, we will commit our solution artifacts to a GitHub repository
    with the help of GitHub Actions for Power Platform and the Dataverse trigger events
    available in the context of Power</st> <st c="30946">Platform pipelines.</st>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30403">在</st> [*<st c="30407">第4章</st>*](B22208_04.xhtml#_idTextAnchor074)<st
    c="30416">中，我们创建了第一个 Power Platform 管理的管道，该管道通过服务主体将我们的</st> `<st c="30491">mpa_ITBase</st>`
    <st c="30501">解决方案从开发环境部署到生产环境。</st> <st c="30599">在本节中，我们将继续我们的旅程，并基于关于 PAC CLI
    的经验，构建针对 Azure DevOps Services 和 GitHub Actions 的工具，为 Power Platform 提供支持，我们将借助
    GitHub Actions for Power Platform 和 Power Platform 管道上下文中的 Dataverse 触发事件，将我们的解决方案构件提交到
    GitHub 仓库。</st>
- en: <st c="30965">Let us have a look at the events that we can use in our Power
    Automate cloud flows in the</st> `<st c="31056">Pipelinehost</st>` <st c="31068">environment
    to react to certain changes in</st> <st c="31112">deployment pipelines:</st>
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30965">让我们来看看在我们的 Power Automate 云流中，可以在</st> `<st c="31056">Pipelinehost</st>`
    <st c="31068">环境中使用的事件，以响应部署管道中的某些变化：</st>
- en: '`<st c="31133">OnApprovalStarted</st>` <st c="31151">–</st> `<st c="31154">OnApprovalCompleted</st>`<st
    c="31173">: These events are triggered when there is approval configured in the
    deployment stage prior to deploying the solution to that stage.</st> <st c="31308">We
    usually use this step to notify release managers or environment owners about the</st>
    <st c="31392">planned deployment.</st>'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="31133">OnApprovalStarted</st>` <st c="31151">–</st> `<st c="31154">OnApprovalCompleted</st>`<st
    c="31173">：当部署阶段配置了审批流程时，这些事件会在部署解决方案之前触发。</st> <st c="31308">我们通常使用这一步骤通知发布经理或环境拥有者关于</st>
    <st c="31392">计划部署的情况。</st>'
- en: '`<st c="31411">OnPredeploymentStarted</st>` <st c="31434">–</st> `<st c="31437">OnPredeploymentCompleted</st>`<st
    c="31461">: These events occur prior to releasing our solution to the deployment
    stage.</st> <st c="31540">We can use these events to do some configuration in
    the target environment, such as updating environment variables and importing (static)
    data before</st> <st c="31690">solution deployment.</st>'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="31411">OnPredeploymentStarted</st>` <st c="31434">–</st> `<st c="31437">OnPredeploymentCompleted</st>`<st
    c="31461">：这些事件在将我们的解决方案发布到部署阶段之前发生。</st> <st c="31540">我们可以利用这些事件在目标环境中做一些配置，比如在解决方案部署前更新环境变量和导入（静态）数据。</st>'
- en: '`<st c="31710">OnDeploymentRequested</st>` <st c="31732">–</st> `<st c="31735">OnDeploymentStarted</st>`
    <st c="31754">–</st> `<st c="31757">OnDeploymentCompleted</st>`<st c="31778">:
    These events occur over the course of deploying the solution to the</st> <st c="31849">deployment
    stage.</st>'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="31710">OnDeploymentRequested</st>` <st c="31732">–</st> `<st c="31735">OnDeploymentStarted</st>`
    <st c="31754">–</st> `<st c="31757">OnDeploymentCompleted</st>`<st c="31778">：这些事件发生在将解决方案部署到</st>
    <st c="31849">部署阶段的过程中。</st>'
- en: <st c="31866">Dataverse pipeline events</st>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31866">Dataverse 管道事件</st>
- en: <st c="31892">Dataverse Power Platform pipeline-related events are triggered
    in every deployment stage regardless of the number of stages and pipelines.</st>
    <st c="32032">Pipeline triggers provide additional attributes to filter down to
    the pipeline and to the stage that we are</st> <st c="32140">interested in.</st>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="31892">Dataverse Power Platform 管道相关事件在每个部署阶段触发，无论阶段和管道的数量如何。</st> <st
    c="32032">管道触发器提供额外的属性来过滤出我们感兴趣的管道和阶段。</st>
- en: <st c="32154">With the help of these</st> <st c="32178">building blocks, we
    can create different strategies for how we are going to manage our pipelines and
    how we are going to maintain our solutions outside of Power Platform environments.</st>
    <st c="32362">We should decide</st> <st c="32379">the following:</st>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="32154">借助这些</st> <st c="32178">构建模块，我们可以制定不同的策略，来管理我们的管道以及如何在 Power Platform
    环境之外维护我们的解决方案。</st> <st c="32362">我们应该决定</st> <st c="32379">以下事项：</st>
- en: <st c="32393">Shall we use a separate Git repository per solution?</st> <st
    c="32447">Or, shall we plan to store multiple solutions per Git repository?</st>
    <st c="32513">Do we plan to introduce pipeline templating for</st> <st c="32561">reusability
    purposes?</st>
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="32393">我们是否为每个解决方案使用单独的 Git 仓库？</st> <st c="32447">或者，我们是否计划将多个解决方案存储在同一个
    Git 仓库中？</st> <st c="32513">我们是否计划引入管道模板化以便于</st> <st c="32561">重用？</st>
- en: <st c="32582">Shall we introduce one Git repository</st> <st c="32621">per environment?</st>
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="32582">我们是否为每个环境引入一个 Git 仓库？</st> <st c="32621"> </st>
- en: <st c="32637">Do we plan to store the solution artifacts deployed to deployment
    stages in different</st> <st c="32724">child branches?</st>
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="32637">我们是否计划将部署到不同部署阶段的解决方案工件存储在不同的</st> <st c="32724">子分支中？</st>
- en: <st c="32739">Shall we use pull requests to merge back the latest changes from
    child branches to the main branch?</st> <st c="32840">Shall we use pull request
    triggers in our pipelines to finish the deployments in production environments?</st>
    <st c="32946">This would also mean that the managed pipelines would not reach
    the production environment, just the</st> <st c="33047">pre-prod/test environments.</st>
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="32739">我们是否使用拉取请求将子分支中的最新更改合并回主分支？</st> <st c="32840">我们是否在管道中使用拉取请求触发器以完成生产环境中的部署？</st>
    <st c="32946">这也意味着受管管道不会到达生产环境，仅到达</st> <st c="33047">预生产/测试环境。</st>
- en: <st c="33074">Do we plan to store only the deployment artifacts that have been
    successfully deployed to production environments on the main branch?</st> <st
    c="33209">Shall we consider a branching strategy</st> <st c="33248">at all?</st>
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="33074">我们是否计划只存储已经成功部署到生产环境的部署工件在主分支上？</st> <st c="33209">我们是否应该考虑分支策略</st>
    <st c="33248">呢？</st>
- en: <st c="33255">There is no silver bullet to answer these questions since the
    selected strategy really depends on the maturity level of the organization, the
    complexity of the project, and the overall DevOps processes</st> <st c="33458">defined
    internally.</st>
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33255">没有万灵药来回答这些问题，因为所选的策略真正取决于组织的成熟度、项目的复杂性以及内部定义的整体 DevOps 流程。</st>
    <st c="33458">。</st>
- en: <st c="33477">The following figure illustrates a possible approach to commit
    the solution to the main branch after deploying to production with the help of
    a Power</st> <st c="33628">Platform pipeline:</st>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="33477">下图展示了一种可能的方法，通过 Power</st> <st c="33628">Platform 管道在部署到生产环境后将解决方案提交到主分支：</st>
- en: '![Figure 5.3 – Git integration with Power Platform pipelines](img/B22208_05_3.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – Git 与 Power Platform 管道的集成](img/B22208_05_3.jpg)'
- en: <st c="34167">Figure 5.3 – Git integration with Power Platform pipelines</st>
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34167">图 5.3 – Git 与 Power Platform 管道的集成</st>
- en: <st c="34225">The managed and</st> <st c="34242">unmanaged solutions are generated
    at the beginning of the deployment that we initiated through the Power Platform
    pipeline.</st> <st c="34366">When a managed pipeline runs, other developers cannot
    queue this pipeline, which guarantees mutual exclusion.</st> <st c="34476">The
    generated artifacts are stored in the Dataverse</st> `<st c="34528">DeploymentArtifacts</st>`
    <st c="34547">table of the</st> `<st c="34561">Pipelinehost</st>` <st c="34573">environment.</st>
    <st c="34587">As the package (managed solution) goes through the pipeline stages
    (</st>`<st c="34655">Test</st>` <st c="34660">and</st> `<st c="34665">Prod</st>`
    <st c="34669">environment, in our example) the previously mentioned events are
    triggered.</st> <st c="34746">We use the</st> `<st c="34757">OnDeploymentCompleted</st>`
    <st c="34778">event to execute our cloud flow, which will dispatch our GitHub
    workflow through</st> `<st c="34860">HTTP POST</st>`<st c="34869">, and that will
    download the deployment artifacts and unpack and commit them to the</st> <st c="34953">main
    branch.</st>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34225">我们通过 Power Platform 管道启动的部署过程中，</st> <st c="34242">生成了托管和非托管解决方案。</st>
    <st c="34366">当托管管道运行时，其他开发人员无法排队执行此管道，从而保证了互斥性。</st> <st c="34476">生成的工件存储在 Dataverse</st>
    `<st c="34528">DeploymentArtifacts</st>` <st c="34547">表格中，位于</st> `<st c="34561">Pipelinehost</st>`
    <st c="34573">环境中。</st> <st c="34587">随着包（托管解决方案）通过管道阶段（</st>`<st c="34655">测试</st>`
    <st c="34660">和</st> `<st c="34665">生产</st>` <st c="34669">环境，以我们为例），前述事件会被触发。</st>
    <st c="34746">我们使用</st> `<st c="34757">OnDeploymentCompleted</st>` <st c="34778">事件来执行我们的云流，它将通过</st>
    `<st c="34860">HTTP POST</st>`<st c="34869">调度我们的 GitHub 工作流，并下载部署工件，解压并提交到</st>
    <st c="34953">主分支。</st>
- en: <st c="34965">To be able to download the artifacts from Dataverse, we create
    a service principal, and we use a Bash script in our GitHub flow to directly call
    the Dataverse Web API and to download our deployment artifacts through the</st>
    <st c="35186">OData protocol.</st>
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34965">为了能够从 Dataverse 下载工件，我们创建一个服务主体，并在 GitHub 流程中使用 Bash 脚本直接调用 Dataverse
    Web API，通过</st> <st c="35186">OData 协议</st> 下载我们的部署工件。</st>
- en: <st c="35201">Let us use PAC CLI to create a service principal that we are going
    to use in</st> <st c="35279">GitHub workflows:</st>
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35201">让我们使用 PAC CLI 创建一个服务主体，供我们在</st> <st c="35279">GitHub 工作流中使用：</st>
- en: '[PRE2]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="35592">The last call</st> <st c="35607">requires administrative privileges
    not just in the Power Platform tenant, but in Microsoft Entra ID (the</st> `<st
    c="35712">Application.ReadWrite.Allpermission</st>` <st c="35747">role), too.</st>
    <st c="35760">The output of this call contains the client secret, application
    ID (client), and tenant ID of the app registration, and, respectively, the enterprise
    application.</st> <st c="35923">This command also registers this service principal
    in Dataverse by adding it as an application user to the environment.</st> <st
    c="36043">We need to save the output of the last command for later usage of the
    client ID, client secret, and tenant ID in our</st> <st c="36160">GitHub workflow:</st>
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35592">最后的调用</st> <st c="35607">不仅需要在 Power Platform 租户中具有管理员权限，还需要在
    Microsoft Entra ID 中具有管理员权限（</st> `<st c="35712">Application.ReadWrite.Allpermission</st>`
    <st c="35747">角色）。</st> <st c="35760">该调用的输出包含应用注册的客户端密钥、应用 ID（客户端）和租户 ID，以及相应的企业应用。</st>
    <st c="35923">此命令还通过将其作为应用用户添加到环境中，将该服务主体注册到 Dataverse。</st> <st c="36043">我们需要保存最后一个命令的输出，以便以后在我们的</st>
    <st c="36160">GitHub 工作流中使用客户端 ID、客户端密钥和租户 ID：</st>
- en: '[PRE3]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="36941">Having created the service principal with a client ID and client
    secret, let’s move on to the GitHub workflow that will</st> <st c="37062">use
    them.</st>
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36941">创建了带有客户端 ID 和客户端密钥的服务主体后，让我们继续进行使用它们的 GitHub 工作流。</st>
- en: <st c="37071">GitHub workflows</st>
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="37071">GitHub 工作流</st>
- en: <st c="37088">It is time to set up</st> <st c="37110">GitHub flow in one of
    our GitHub repositories.</st> <st c="37157">We will use</st> **<st c="37169">Visual
    Studio Code</st>** <st c="37187">in the</st> <st c="37194">upcoming steps to create
    our YAML file.</st> <st c="37235">Alternatively, we could use the GitHub UI to
    create</st> <st c="37287">our workflow:</st>
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37088">现在是时候在我们的一个 GitHub 仓库中设置</st> <st c="37110">GitHub 流程了。</st> <st
    c="37157">我们将在接下来的步骤中使用</st> **<st c="37169">Visual Studio Code</st>** <st c="37187">来创建我们的
    YAML 文件。</st> <st c="37235">另外，我们也可以使用 GitHub UI 来创建</st> <st c="37287">我们的工作流：</st>
- en: <st c="37300">Create repository secrets with the names</st> `<st c="37342">TENANT_ID</st>`<st
    c="37351">,</st> `<st c="37353">CLIENT_ID</st>`<st c="37362">, and</st> `<st c="37368">CLIENT_SECRET</st>`
    <st c="37381">in the selected</st> <st c="37398">GitHub repository.</st>
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选定的 GitHub 仓库中创建名称为 `TENANT_ID`、`CLIENT_ID` 和 `CLIENT_SECRET` 的仓库密钥。
- en: <st c="37416">Create a GitHub flow (with the name</st> `<st c="37453">downloadunpackcommitbash.yml</st>`<st
    c="37481">) and set its trigger condition</st> <st c="37514">to</st> `<st c="37517">workflow_dispatch</st>`<st
    c="37534">:</st>
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `downloadunpackcommitbash.yml` 的 GitHub 流并设置其触发条件为 `workflow_dispatch`：
- en: '[PRE4]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="37631">Introduce input parameters that will be called by the Power Automate</st>
    <st c="37701">cloud flow:</st>
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 引入由 Power Automate 云流调用的输入参数：
- en: '[PRE5]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="38348">Configure standard permissions and</st> <st c="38384">the GitHub-hosted
    build agent’s</st> <st c="38416">operating system:</st>
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置标准权限和 GitHub 托管构建代理的操作系统：
- en: '[PRE6]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="38513">Check out the source branch in the</st> <st c="38549">build agent:</st>
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建代理中检出源分支：
- en: '[PRE7]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="38648">Create a new branch if the target branch</st> <st c="38690">is
    specified:</st>
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果指定了目标分支，则创建新分支：
- en: '[PRE8]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <st c="38968">Execute a</st> <st c="38979">Bash script that requests an access
    token from Microsoft Entra ID with the Dataverse scope using the tenant ID, client
    ID, and client secret generated by PAC CLI.</st> <st c="39142">After getting the
    token, we reach out to the Dataverse Web API endpoint of our table (</st>`<st
    c="39228">DeploymentArtifacts</st>`<st c="39248">) and we download the artifact
    identified by its GUID</st> <st c="39303">using</st> *<st c="39309">curl</st>*<st
    c="39313">:</st>
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行一个 Bash 脚本，从 Microsoft Entra ID 请求具有 Dataverse 范围的访问令牌，使用由 PAC CLI 生成的租户 ID、客户端
    ID 和客户端密钥。获取令牌后，我们访问 Dataverse Web API 端点的表（`DeploymentArtifacts`），并使用 *curl*
    下载由 GUID 标识的工件：
- en: '[PRE9]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <st c="40558">Using the</st> <st c="40569">GitHub Power Platform action (</st>`<st
    c="40599">unpack-solution</st>`<st c="40615">), we unpack the managed and unmanaged
    versions of the solution to the repository on the</st> <st c="40705">build agent:</st>
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 GitHub Power Platform 操作（`unpack-solution`），我们将解决方案的托管版和非托管版解压到构建代理上的仓库：
- en: '[PRE10]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <st c="41053">Commit the</st> <st c="41064">changes locally in the build agent
    either into the target branch or into the</st> <st c="41142">source branch:</st>
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建代理中将更改提交到目标分支或源分支：
- en: '[PRE11]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <st c="41571">Push the changes to the</st> <st c="41596">remote origins:</st>
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将更改推送到远程源：
- en: '[PRE12]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <st c="41888">The Dataverse Web API – OData protocol</st>
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Dataverse Web API – OData 协议
- en: <st c="41927">We use the Dataverse</st> <st c="41948">Web API to query Dataverse
    tables and records using the REST API on the OData protocol.</st> <st c="42037">Our
    GitHub workflow’s input parameter,</st> `<st c="42076">artifact_url</st>`<st c="42088">,
    expects the following string to get the record identified by its unique identifier,
    and its column,</st> `<st c="42190">ArtifactFile</st>` `<st c="42202">https://[</st>`<st
    c="42212">.</st> `<st c="42214">$Value</st>`<st c="42220">, refers to the binary
    content.</st> <st c="42252">Since we’re using Bash and Bash treats the</st> `<st
    c="42295">$</st>` <st c="42296">sign as a special character, we need to use the
    escape character (backslash) to add</st> `<st c="42381">$value</st>` <st c="42387">to
    the end of the</st> <st c="42406">artifact URL.</st>
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Dataverse Web API，通过 OData 协议的 REST API 查询 Dataverse 表和记录。我们 GitHub 工作流的输入参数，`artifact_url`，期望以下字符串以获取通过其唯一标识符和列
    `ArtifactFile` 标识的记录，`https://[.$Value`，指向二进制内容。由于我们使用的是 Bash，而 Bash 将 `$` 符号视为特殊字符，因此我们需要使用转义字符（反斜杠）来将
    `$value` 添加到工件 URL 的末尾。
- en: <st c="42419">To test our GitHub flow, we can use the</st> `<st c="42460">run
    workflow</st>` <st c="42472">command in the GitHub UI by providing the</st> <st
    c="42515">inputs manually:</st>
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试我们的 GitHub 流，我们可以通过在 GitHub UI 中提供输入手动使用 `run workflow` 命令：
- en: '![Figure 5.4 – GitHub – run workflow manually](img/B22208_05_4.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – GitHub – 手动运行工作流](img/B22208_05_4.jpg)'
- en: <st c="43098">Figure 5.4 – GitHub – run workflow manually</st>
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43098">图 5.4 – GitHub – 手动运行工作流</st>
- en: <st c="43141">Now, we have a GitHub workflow</st> <st c="43172">that can download
    deployment artifacts and commit them to a child branch or the main branch, based
    on the input parameters.</st> <st c="43297">See</st> `<st c="43301">.github/downloadunpackcommitbash.yml</st>`
    <st c="43337">in the</st> `<st c="43345">Chapter05</st>` <st c="43354">folder
    of the book’s GitHub repo, which contains the entire GitHub workflow.</st> <st
    c="43432">The same workflow can be realized with PowerShell commands as well.</st>
    <st c="43500">See</st> `<st c="43504">.github/</st>` `<st c="43512">downloadunpackcommit.yml</st>`
    <st c="43537">in the</st> `<st c="43545">Chapter05</st>` <st c="43554">folder</st>
    <st c="43562">for details.</st>
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个 GitHub 工作流，<st c="43141">它可以下载部署工件并将其提交到子分支或主分支，具体取决于输入的参数。</st> <st
    c="43297">查看</st> `<st c="43301">.github/downloadunpackcommitbash.yml</st>` <st
    c="43337">文件，它位于书籍 GitHub 仓库的</st> `<st c="43345">Chapter05</st>` <st c="43354">文件夹中，包含整个
    GitHub 工作流。</st> <st c="43432">同样的工作流也可以通过 PowerShell 命令实现。</st> <st c="43500">查看</st>
    `<st c="43504">.github/</st>` `<st c="43512">downloadunpackcommit.yml</st>` <st
    c="43537">文件，它位于</st> `<st c="43545">Chapter05</st>` <st c="43554">文件夹中，了解更多细节。</st>
- en: <st c="43574">It is good practice to commit changes first to the feature branch
    and then to submit a pull request because we never work directly on the main branch.</st>
    <st c="43726">There are normally also branch policies in place that block developers
    from working directly on the main branch.</st> <st c="43839">On the other hand,
    GitHub workflows can initiate a pull request immediately after creating and committing
    changes to a</st> <st c="43958">feature branch.</st>
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43574">良好的做法是先将更改提交到功能分支，然后再提交拉取请求，因为我们从不直接在主分支上工作。</st> <st c="43726">通常还会有分支策略，禁止开发人员直接在主分支上工作。</st>
    <st c="43839">另一方面，GitHub 工作流可以在创建并提交更改到</st> <st c="43958">功能分支后立即启动拉取请求。</st>
- en: <st c="43973">We can use exactly the same</st> <st c="44002">approach in conjunction
    with the integration of</st> **<st c="44050">Azure DevOps Services</st>** <st
    c="44071">repositories, pipelines, and</st> **<st c="44101">Power Platform managed
    pipelines</st>** <st c="44133">while</st> <st c="44139">keeping the following
    considerations</st> <st c="44177">in mind:</st>
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用完全相同的<st c="43973">方法，结合</st> **<st c="44050">Azure DevOps 服务</st>** <st
    c="44071">的仓库、管道以及</st> **<st c="44101">Power Platform 管理管道</st>** <st c="44133">同时</st>
    <st c="44139">考虑以下几点</st> <st c="44177">：</st>
- en: <st c="44185">Secrets are stored as variables or within variable groups in</st>
    <st c="44247">YAML pipelines.</st>
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="44185">机密作为变量或在</st> <st c="44247">YAML 管道中的变量组中存储。</st>
- en: <st c="44262">GitHub inputs are mapped to Azure DevOps pipeline variables (</st><st
    c="44324">not parameters).</st>
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub 输入映射到 Azure DevOps 管道变量（<st c="44324">而不是参数</st>）。
- en: <st c="44341">We can use the same Bash scripts as in the case of our GitHub
    workflow.</st> <st c="44414">There is no need to change anything.</st> <st c="44451">Microsoft-hosted
    build agents support Ubuntu</st> <st c="44496">Linux distros.</st>
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="44341">我们可以使用与 GitHub 工作流相同的 Bash 脚本。</st> <st c="44414">无需更改任何内容。</st>
    <st c="44451">微软托管的构建代理支持 Ubuntu</st> <st c="44496">Linux 发行版。</st>
- en: <st c="44510">We need to install PowerPlatform Tools by using the Power Platform</st>
    `<st c="44578">build tool</st>` <st c="44588">task (</st>`<st c="44595">PowerPlatformToolInstaller@2</st>`<st
    c="44624">) in the</st> <st c="44634">build agent.</st>
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要通过 Power Platform<st c="44510">构建工具</st>任务（`PowerPlatformToolInstaller@2`）在<st
    c="44634">构建代理中安装 PowerPlatform 工具。</st>
- en: <st c="44646">We need to use the</st> `<st c="44666">PowerPlatformUnpackSolution@2</st>`
    <st c="44695">task to unpack</st> <st c="44711">the solution.</st>
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要使用<st c="44646">`PowerPlatformUnpackSolution@2`</st>任务来解包<st c="44711">解决方案。</st>
- en: <st c="44724">Dataverse with Power Automate cloud flows</st>
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="44724">Dataverse 与 Power Automate 云流</st>
- en: <st c="44766">Having created the DevOps part, let us introduce the</st> <st
    c="44819">Power Automate cloud flow that will react to the</st> `<st c="44869">OnDeploymentCompleted</st>`
    <st c="44890">event in</st> [<st c="44900">the appropriate deployment sta</st>](https://make.powerautomate.com)<st
    c="44930">ge.</st> <st c="44935">We’ll create this cloud flow in the</st> `<st
    c="44971">Pipelinehost</st>` <st c="44983">environment:</st>
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44996">Visit</st> [<st c="45003">https://make.powerautomate.com</st>](https://make.powerautomate.com)
    <st c="45033">and select the environment in which our Power Platform</st> <st
    c="45089">pipelines reside.</st>
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="45106">We then go to the</st> **<st c="45125">My Flows</st>** <st c="45133">blade,
    open the</st> **<st c="45150">New Flow</st>** <st c="45158">drop-down menu, and
    click on</st> **<st c="45188">Automated</st>** **<st c="45198">Cloud Flow</st>**<st
    c="45208">.</st>
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="45209">We can name the flow something like</st> `<st c="45246">ManagedPipelineOnDeploymentCompletedFlow</st>`
    <st c="45286">and need to pick</st> **<st c="45304">When an action is performed</st>**
    <st c="45331">from Dataverse as the</st> <st c="45354">trigger condition.</st>
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="45372">After creating the flow, we need to provide the following values
    as the parameters of the</st> <st c="45463">trigger action:</st>
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Dataverse – When an action is performed](img/B22208_05_5.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: <st c="45750">Figure 5.5 – Dataverse – When an action is performed</st>
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45802">Please note that, here, we’re using the service principal to connect
    to the underlying Dataverse, which is</st> *<st c="45910">not</st>* <st c="45913">the
    service principal that we used in the GitHub workflow.</st> <st c="45973">This
    is the service principal that we created in</st> [*<st c="46022">Chapter 4</st>*](B22208_04.xhtml#_idTextAnchor074)<st
    c="46031">, for the</st> *<st c="46041">on-behalf-of</st>* <st c="46053">pipeline
    deployment.</st>
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: <st c="46074">We can use the output data (</st>`<st c="46103">ActionOutputs</st>`
    `<st c="46117">ArtifactName</st>`<st c="46130">,</st> `<st c="46132">ActionOutputs</st>`
    `<st c="46145">DeploymentPipeIineName</st>`<st c="46168">,</st> `<st c="46170">ActionOutputs</st>`
    `<st c="46183">DeploymentStageName</st>`<st c="46203">) of the trigger action
    to introduce multiple conditions to react only on our pipeline (</st>`<st c="46292">PipelineToProd</st>`<st
    c="46307">) and in the final deployment</st> <st c="46338">stage (</st>`<st c="46345">Production</st>`<st
    c="46356">).</st>
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="46359">After</st> <st c="46365">introducing these conditions to limit
    our cloud flow execution only to this managed pipeline, we need to get some additional
    data from the</st> `<st c="46505">DeploymentStageRun</st>` <st c="46523">Dataverse
    table in conjunction with this run (identified by</st> `<st c="46584">StageRunId</st>`<st
    c="46594">).</st> <st c="46598">We use the</st> **<st c="46609">Get</st> <st c="46613">a
    row by ID</st>** <st c="46624">action with the</st> **<st c="46641">Row ID</st>**
    <st c="46647">parameter from the trigger activity to get</st> <st c="46691">this
    information:</st>
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="46359">在</st> <st c="46365">引入这些条件来限制我们的云流执行仅限于此受管管道后，我们需要从</st> `<st
    c="46505">DeploymentStageRun</st>` <st c="46523">Dataverse 表中获取一些额外的数据，这些数据与本次运行相关（通过</st>
    `<st c="46584">StageRunId</st>`<st c="46594">来标识）。</st> <st c="46598">我们使用</st>
    **<st c="46609">按 ID 获取一行数据</st>** <st c="46624">操作，并结合触发器活动中的</st> **<st c="46641">行
    ID</st>** <st c="46647">参数来获取</st> <st c="46691">这些信息：</st>
- en: '![Figure 5.6 – Get a row by ID action](img/B22208_05_6.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 按 ID 获取一行数据操作](img/B22208_05_6.jpg)'
- en: <st c="46949">Figure 5.6 – Get a row by ID action</st>
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46949">图 5.6 – 按 ID 获取一行数据操作</st>
- en: <st c="46984">Finally, we need to call the REST API endpoint of our GitHub workflow.</st>
    <st c="47056">Since these endpoints are</st> <st c="47081">protected, we need
    to create a</st> `<st c="47373">https://api.github.com/repos/[org-name]/[repository]/actions/workflows/downloadunpackcommitbash.yml/dispatches</st>`
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="46984">最后，我们需要调用 GitHub 工作流的 REST API 端点。</st> <st c="47056">由于这些端点是</st>
    <st c="47081">受保护的，我们需要创建一个</st> `<st c="47373">https://api.github.com/repos/[org-name]/[repository]/actions/workflows/downloadunpackcommitbash.yml/dispatches</st>`
- en: '<st c="47483">HTTP</st> <st c="47489">method: POST</st>'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="47483">HTTP</st> <st c="47489">方法：POST</st>
- en: <st c="47501">Headers</st>
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="47501">头部</st>
- en: <st c="47509">We only</st> <st c="47517">define the</st> **<st c="47529">Authorization</st>**
    <st c="47542">header with a bearer token that is exactly the same as our GitHub
    personal access token, as the following</st> <st c="47649">figure shows:</st>
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47509">我们仅</st> <st c="47517">定义</st> **<st c="47529">Authorization</st>**
    <st c="47542">头部，使用与我们的 GitHub 个人访问令牌完全相同的承载令牌，如下图所示：</st> <st c="47649">图所示：</st>
- en: '![Figure 5.7 – Authorization header with GitHub access token](img/B22208_05_7.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7 – 带 GitHub 访问令牌的授权头](img/B22208_05_7.jpg)'
- en: <st c="47708">Figure 5.7 – Authorization header with GitHub access token</st>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47708">图 5.7 – 带 GitHub 访问令牌的授权头</st>
- en: <st c="47766">Please note that we should store the bearer token in an environment
    variable that is backed by the Azure Key</st> <st c="47876">Vault service.</st>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47766">请注意，我们应该将承载令牌存储在一个由 Azure Key</st> <st c="47876">Vault 服务支持的环境变量中。</st>
- en: <st c="47890">The HTTP payload (body) contains the GitHub workflow’s</st> <st
    c="47946">input parameters:</st>
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="47890">HTTP 负载（正文）包含 GitHub 工作流的</st> <st c="47946">输入参数：</st>
- en: '[PRE13]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <st c="48331">The following</st> <st c="48345">figure shows how we apply these
    parameters within the</st> <st c="48400">HTTP action:</st>
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48331">下图显示了我们如何在</st> <st c="48345">HTTP 操作中应用这些参数：</st>
- en: '![Figure 5.8 – HTTP action to dispatch a GitHub workflow](img/B22208_05_8.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8 – 用于调度 GitHub 工作流的 HTTP 操作](img/B22208_05_8.jpg)'
- en: <st c="49054">Figure 5.8 – HTTP action to dispatch a GitHub workflow</st>
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49054">图 5.8 – 用于调度 GitHub 工作流的 HTTP 操作</st>
- en: <st c="49108">When everything</st> <st c="49125">comes together, our Power Automate
    cloud flow should contain the following actions and</st> <st c="49212">conditional
    cases:</st>
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49108">当一切</st> <st c="49125">整合在一起时，我们的 Power Automate 云流应该包含以下操作和</st>
    <st c="49212">条件情况：</st>
- en: '![Figure 5.9 – End-to-end cloud flow](img/B22208_05_9.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9 – 端到端云流](img/B22208_05_9.jpg)'
- en: <st c="49340">Figure 5.9 – End-to-end cloud flow</st>
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49340">图 5.9 – 端到端云流</st>
- en: <st c="49374">With this final step, we have accomplished our original plan to
    save the deployment artifacts of our Power Platform pipeline to a</st> <st c="49505">GitHub
    repository.</st>
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49374">通过最后一步，我们已经完成了最初的计划，将我们的 Power Platform 管道的部署工件保存到</st> <st c="49505">GitHub
    仓库。</st>
- en: <st c="49523">To close the loop, we can introduce another Power Automate cloud
    flow that is triggered by the</st> *<st c="49619">committed to main</st>* <st
    c="49636">or</st> *<st c="49640">pull request is submitted</st>* <st c="49665">GitHub
    event via webhooks to track the result of the GitHub workflow dispatch REST API
    call back to our Power Platform</st> *<st c="49785">Pipelinehost</st>* <st c="49797">environment.</st>
    **<st c="49811">Webhooks</st>** <st c="49819">provide a mechanism to register
    HTTP endpoints as event handlers on</st> <st c="49887">other services.</st> <st
    c="49904">In our case, we can register the Power Automate cloud flow as a webhook
    on the GitHub side.</st> <st c="49996">If a well-defined event happens in GitHub,
    GitHub will execute all registered webhooks.</st> <st c="50084">There are already
    GitHub</st> <st c="50109">connectors available for these types of triggers, such
    as the</st> *<st c="50171">When a pull request is created or modified</st>* <st
    c="50213">webhook in the Power Automate</st> <st c="50244">cloud flow.</st>
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49523">为了完成循环，我们可以引入另一个Power Automate云流程，该流程由</st> *<st c="49619">提交到主分支</st>*
    <st c="49636">或</st> *<st c="49640">拉取请求提交</st>* <st c="49665">的GitHub事件触发，通过webhooks跟踪GitHub工作流调度REST
    API的结果，回传到我们的Power Platform</st> *<st c="49785">Pipelinehost</st>* <st c="49797">环境。</st>
    **<st c="49811">Webhooks</st>** <st c="49819">提供了一种机制，用于在</st> <st c="49887">其他服务上注册HTTP端点作为事件处理程序。</st>
    <st c="49904">在我们的案例中，我们可以在GitHub侧将Power Automate云流程注册为webhook。</st> <st c="49996">如果GitHub中发生了一个定义良好的事件，GitHub将执行所有已注册的webhook。</st>
    <st c="50084">已经有可用的GitHub</st> <st c="50109">连接器，用于这些类型的触发器，比如Power Automate中的</st>
    *<st c="50171">当拉取请求被创建或修改时</st>* <st c="50213">webhook。</st>
- en: <st c="50255">Last but not least, it is worth having a look at the differences
    when we use Azure DevOps Services instead of GitHub in our Dataverse-triggered</st>
    <st c="50400">cloud flow:</st>
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50255">最后但同样重要的是，值得看一下当我们在Dataverse触发的</st> <st c="50400">云流程中使用Azure
    DevOps Services而非GitHub时的差异：</st>
- en: <st c="50411">We need to enable the</st> `<st c="50434">Third-party application
    access via OAuth</st>` <st c="50474">checkbox at the organization level under</st>
    **<st c="50516">Organization Settings</st>** <st c="50537">|</st> **<st c="50540">Security</st>**
    <st c="50548">|</st> **<st c="50551">Policies</st>** <st c="50559">|</st> **<st
    c="50562">Application access policies</st>** <st c="50589">in Azure DevOps Services
    to be able to use the available Azure DevOps Services actions in our Power Automate</st>
    <st c="50699">cloud flow</st>
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="50411">我们需要启用</st> `<st c="50434">通过OAuth的第三方应用程序访问</st>` <st c="50474">复选框，位于组织级别的</st>
    **<st c="50516">组织设置</st>** <st c="50537">|</st> **<st c="50540">安全</st>** <st
    c="50548">|</st> **<st c="50551">策略</st>** <st c="50559">|</st> **<st c="50562">应用程序访问策略</st>**
    <st c="50589">在Azure DevOps Services中，以便能够在我们的Power Automate</st> <st c="50699">云流程</st>中使用可用的Azure
    DevOps Services操作。</st>
- en: <st c="50709">We then use the</st> **<st c="50726">Queue a new Build</st>**
    <st c="50743">action under the Azure DevOps connector to execute</st> <st c="50795">the
    pipeline</st>
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="50709">然后，我们使用</st> **<st c="50726">排队一个新的构建</st>** <st c="50743">操作，通过Azure
    DevOps连接器执行</st> <st c="50795">该管道</st>
- en: <st c="50807">As mentioned earlier, our Azure DevOps pipeline expects the input
    parameters as variables defined in the</st> **<st c="50913">Variable</st>** <st
    c="50921">pane</st>
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="50807">如前所述，我们的Azure DevOps管道期望输入参数作为在</st> **<st c="50913">变量</st>**
    <st c="50921">面板中定义的变量</st>
- en: <st c="50926">The</st> **<st c="50931">Queue a new build</st>** <st c="50948">action
    passes over the parameters in the</st> <st c="50990">following format:</st>
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="50931">排队一个新的构建</st>** <st c="50948">操作将参数传递为以下格式：</st>'
- en: '[PRE14]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: <st c="51346">Awesome job!</st> <st c="51360">We have just learned how we can
    get the two workflow engines to collaborate in order to use the same DevOps principles
    that we apply every day during custom software</st> <st c="51526">development
    projects.</st>
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51346">做得好！</st> <st c="51360">我们刚刚学会了如何让两个工作流引擎协作，以便使用我们在自定义软件</st>
    <st c="51526">开发项目中每天应用的相同DevOps原则。</st>
- en: <st c="51547">Copilots in Power Platform pipeline development</st>
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="51547">Power Platform管道开发中的协同工作者</st>
- en: <st c="51595">To significantly reduce the pipeline development effort in GitHub
    or Azure DevOps Services, we can leverage the capabilities</st> <st c="51721">of</st>
    **<st c="51724">Large Language Models</st>** <st c="51745">(</st>**<st c="51747">LLMs</st>**<st
    c="51751">) such as GPT-4 and the products built upon those models to support
    developers and DevOps engineers.</st> <st c="51853">One of these products is</st>
    **<st c="51878">GitHub Copilot</st>**<st c="51892">, which</st> <st c="51899">acts
    as a pair programmer, – an assistant that can synthesize code based on natural
    language prompts.</st> <st c="52002">GitHub Copilot integrates into Visual Studio
    Code, Visual Studio, Neovim, and the JetBrains IDE (even in Azure Data Studio)
    and it is also available directly on the</st> <st c="52167">GitHub website.</st>
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: <st c="52182">Using the GitHub Copilot inline editor or</st> <st c="52224">the</st>
    **<st c="52229">GitHub Copilot Chat window</st>**<st c="52255">, we can prompt
    the foundation model to create pipelines that use the build tools to interact
    with our Power Platform environments.</st> <st c="52387">The more precise our
    prompts are, the more accurate GitHub Copilot can synthesize the YAML files.</st>
    <st c="52485">This concept is also referred to</st> <st c="52517">as</st> **<st
    c="52521">prompt engineering</st>**<st c="52539">. Here are some real-world prompts
    for the activities we have carried out in</st> <st c="52616">this chapter:</st>
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="52629">“By using the Microsoft Power Platform build tool, tasks create
    an Azure DevOps pipeline that exports a solution from the Power Platform environment,
    unpacks it, and commits the changes in a new branch</st>* *<st c="52832">under
    main.”</st>*'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="52844">“Create a Bash script that gets an access token from Dataverse
    using AAD app registration and query a Dataverse table</st>* `<st c="52963">DeploymentArtifacts</st>`
    *<st c="52982">row by providing its GUID.” The column with the name “artifactfile”
    shall be</st>* *<st c="53060">downloaded afterward.”</st>*'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="53082">“By using Power Platform GitHub actions, create a GitHub workflow
    with a trigger condition dispatch that exports a solution from the Power Platform
    environment, unpacks it, and commits the changes in a new branch</st>* *<st c="53296">under
    main.”</st>*'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="53308">If we don’t have access to GitHub Copilot, we can</st> <st c="53359">use</st>
    **<st c="53363">Microsoft Copilot</st>** <st c="53380">(</st>[<st c="53382">https://copilot.microsoft.com</st>](https://copilot.microsoft.com)<st
    c="53411">) with our personal account or other LLMs to get some templates and
    step-by-step instructions on how YAML pipelines should</st> <st c="53535">be constructed.</st>
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: <st c="53550">Copilot is also available in Power Platform to help us in creating
    apps, flows, websites, chatbots, and reports more intuitively by using natural
    language.</st> <st c="53707">In the previous example of a Dataverse-triggered
    workflow, we could use the following prompt in the Power Automate UI</st> <st
    c="53825">in</st> **<st c="53828">Copilot for</st>** **<st c="53840">Power Automate</st>**<st
    c="53854">:</st>
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: <st c="53856">“Create a workflow that is triggered by the “When an action is
    performed” Dataverse action on Power Platform pipelines with the OnDeploymentCompleted
    event.</st> <st c="54013">If the pipeline is “PipelineToProd” and the deployment
    stage is Production, call an HTTP action.”</st>
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: <st c="54110">Copilots will soon become an integral part of our daily work.</st>
    <st c="54173">It’s essential for us to develop these skills and acquire new competencies
    to remain at the forefront</st> <st c="54275">of technology.</st>
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: <st c="54289">Summary</st>
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="54297">In this chapter, we explored the world of Git, the distributed
    version control system, and discovered how to use PAC CLI to export/import and
    unpack Power Platform solutions in Git repositories.</st> <st c="54493">We also
    delved into the inner workings of professional DevOps pipelines and saw how build
    tools such as Azure DevOps tasks and GitHub actions use the underlying PAC CLI
    to perform actions within provider-hosted or</st> <st c="54707">self-hosted agents.</st>
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: <st c="54726">In the second half of the chapter, we combined the Power Platform
    managed pipeline results from</st> [*<st c="54823">Chapter 4</st>*](B22208_04.xhtml#_idTextAnchor074)
    <st c="54832">with professional DevOps tools and achieved a version control integration
    directly from managed pipelines.</st> <st c="54940">To top it all off, we used
    GitHub Copilot and Copilot for Power Automate to generate YAML pipelines and Power
    Automate cloud flows that we had previously</st> <st c="55094">created manually.</st>
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: <st c="55111">But hold on to your hats, because in the next chapter, we will
    go even further and delve into YAML techniques to do some real magic with pipeline
    templates</st>[<st c="55267">, GitHub workflow templates, and AL</st>](https://code.visualstudio.com/learn)<st
    c="55302">M Accelerator for</st> <st c="55321">Power Platform.</st>
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: <st c="55336">Further reading</st>
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[<st c="55352">Learn about Visual Studio</st>](https://github.com/git/git)
    <st c="55379">Code:</st> [<st c="55385">https://code.visualstudio.com/learn</st>](https://code.visualstudio.com/learn)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="55420">Git open source project – the code base of</st> <st c="55464">Git:</st>
    [<st c="55469">https://github.com/git/git</st>](https://github.com/git/git)
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="55495">GitHub</st> <st c="55503">flow:</st> [<st c="55509">https://docs.github.com/en/get-started/using-github/github-flow</st>](https://docs.github.com/en/get-started/using-github/github-flow)
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="55572">PAC CLI</st> <st c="55581">reference:</st> [<st c="55592">https://learn.microsoft.com/en-us/power-platform/developer/cli/reference/</st>](https://learn.microsoft.com/en-us/power-platform/developer/cli/reference/)
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="55665">Azure Pipelines learning</st> <st c="55691">module:</st> [<st
    c="55699">https://learn.microsoft.com/en-us/training/modules/explore-azure-pipelines/</st>](https://learn.microsoft.com/en-us/training/modules/explore-azure-pipelines/)
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="55774">Integrate Azure</st> <st c="55791">pipelines:</st> [<st c="55802">https://learn.microsoft.com/en-us/training/modules/integrate-azure-pipelines/</st>](https://learn.microsoft.com/en-us/training/modules/integrate-azure-pipelines/)
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="55879">Azure DevOps Demo</st> <st c="55898">Generator:</st> [<st c="55909">https://azuredevopsdemogenerator.azurewebsites.net</st>](https://azuredevopsdemogenerator.azurewebsites.net)
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="55959">GitHub Actions learning</st> <st c="55984">module:</st> [<st c="55992">https://learn.microsoft.com/en-us/training/modules/introduction-to-github-actions/</st>](https://learn.microsoft.com/en-us/training/modules/introduction-to-github-actions/)
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="56074">Implement CI pipelines with Azure DevOps and GitHub</st> <st c="56127">Actions:</st>
    [<st c="56136">https://learn.microsoft.com/en-us/training/paths/az-400-implement-ci-azure-pipelines-github-actions/</st>](https://learn.microsoft.com/en-us/training/paths/az-400-implement-ci-azure-pipelines-github-actions/)
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="56236">Build continuous integration (CI) workflows by using GitHub</st>
    <st c="56297">Actions:</st> [<st c="56306">https://learn.microsoft.com/en-us/training/modules/github-actions-ci/</st>](https://learn.microsoft.com/en-us/training/modules/github-actions-ci/)
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="56375">Microsoft Power Platform Build Tools for Azure DevOps</st> <st
    c="56430">Services:</st> [<st c="56440">https://learn.microsoft.com/en-us/power-platform/alm/devops-build-tools</st>](https://learn.microsoft.com/en-us/power-platform/alm/devops-build-tools)
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="56511">GitHub Actions for Microsoft Power</st> <st c="56547">Platform:</st>
    [<st c="56557">https://learn.microsoft.com/en-us/power-platform/alm/devops-github-actions</st>](https://learn.microsoft.com/en-us/power-platform/alm/devops-github-actions)
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="56631">GitHub repository for Power Platform build</st> <st c="56675">tools:</st>
    [<st c="56682">https://github.com/microsoft/powerplatform-build-tools</st>](https://github.com/microsoft/powerplatform-build-tools)
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="56736">Azure Pipelines agent source</st> <st c="56766">code:</st> [<st
    c="56772">https://github.com/microsoft/azure-pipelines-agent</st>](https://github.com/microsoft/azure-pipelines-agent)
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="56822">GitHub runner source</st> <st c="56844">code:</st> [<st c="56850">https://github.com/actions/runner/tree/main/src</st>](https://github.com/actions/runner/tree/main/src)
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="56897">Pipeline Integration with</st> <st c="56924">GitHub:</st> [<st
    c="56932">https://learn.microsoft.com/en-us/power-platform/alm/extend-pipelines-github-export</st>](https://learn.microsoft.com/en-us/power-platform/alm/extend-pipelines-github-export)
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="57015">Dataverse Web</st> <st c="57030">API:</st> `<st c="57035">https://learn.microsoft.com/en-us/power-apps/developer/data-platform/webapi/overview</st>`
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="57119">GitHub Invoke REST</st> <st c="57139">API:</st> [<st c="57144">https://docs.github.com/en/rest/actions/workflows?apiVersion=2022-11-28#create-a-workflow-dispatch-event</st>](https://docs.github.com/en/rest/actions/workflows?apiVersion=2022-11-28#create-a-workflow-dispatch-event)
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="57248">GitHub Secret</st> <st c="57263">Management:</st> [<st c="57275">https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions</st>](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions)
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="57357">GitHub Personal Access</st> <st c="57381">Tokens:</st> [<st c="57389">https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens</st>](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens)
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="57504">Power Platform GitHub</st> <st c="57527">Connectors:</st> [<st
    c="57539">https://learn.microsoft.com/en-us/connectors/github/</st>](https://learn.microsoft.com/en-us/connectors/github/)
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="57591">Application Connection Policies in Azure DevOps</st> <st c="57640">Services:</st>
    [<st c="57650">https://learn.microsoft.com/en-us/azure/devops/organizations/accounts/change-application-access-policies?view=azure-devops</st>](https://learn.microsoft.com/en-us/azure/devops/organizations/accounts/change-application-access-policies?view=azure-devops)
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="57772">Prompt engineering with GitHub</st> <st c="57804">Copilot:</st>
    [<st c="57813">https://learn.microsoft.com/en-us/training/modules/introduction-prompt-engineering-with-github-copilot/</st>](https://learn.microsoft.com/en-us/training/modules/introduction-prompt-engineering-with-github-copilot/)
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="57916">OpenAI Prompt</st> <st c="57931">Engineering:</st> [<st c="57944">https://platform.openai.com/docs/guides/prompt-engineering</st>](https://platform.openai.com/docs/guides/prompt-engineering)
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
