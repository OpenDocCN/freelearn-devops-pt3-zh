- en: <st c="0">5</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2">Streamlining Power Platform Development with DevOps Tooling</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="61">In the previous chapter, we created our first Power Platform pipeline
    using a service principal to deploy our solution from one environment to another.</st>
    <st c="214">This chapter covers the pro-dev DevOps tools that can help us streamline
    our development process in Power Platform.</st> <st c="330">The first tool is</st>
    `<st c="505">clone</st>`<st c="510">,</st> `<st c="512">push</st>`<st c="516">,</st>
    `<st c="518">pull</st>`<st c="522">,</st> `<st c="524">checkout</st>`<st c="532">,
    and more.</st> <st c="544">We will also explore how we can manage Power Platform
    solution plain files and folders in a Git repository and how pull requests and
    merges are performed even from command lines.</st> <st c="723">We then learn about
    how Power Platform pipelines can be connected to these Git repos.</st> <st c="809">We
    will spend some time on</st> **<st c="836">Power Platform CLI</st>** <st c="854">(</st>**<st
    c="856">PAC CLI</st>**<st c="863">), which</st> <st c="872">allows us to interact
    with Power Platform solutions in any script language.</st> <st c="949">We will
    also learn how to create Azure DevOps Services pipelines in</st> **<st c="1017">YAML</st>**
    <st c="1021">(short for</st> **<st c="1033">Yet Another Markup Language</st>**<st
    c="1060">) format, and</st> <st c="1075">understand the YAML specification itself
    and relevant methods, such as variables, parameters, and tasks.</st> <st c="1180">We
    will also understand the build tasks provided by Microsoft for Power Platform
    solutions.</st> <st c="1272">Finally, we will learn</st> <st c="1294">how to use</st>
    **<st c="1306">GitHub Copilot</st>**<st c="1320">, an AI-powered code completion
    tool that can help us write code</st> <st c="1385">more efficiently.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1402">By the end of this chapter, we will have a solid understanding
    of, and hands-on skills in, how to set up end-to-end CI/CD pipelines with the
    help of pro-dev DevOps tools such as Azure DevOps pipelines and GitHub Actions,
    which deliver our solutions to different Power</st> <st c="1671">Platform environments.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1693">In this chapter, we’re going to cover the following</st> <st c="1746">main
    topics:</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1758">Git – the single source</st> <st c="1783">of truth</st>
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1791">Power</st> <st c="1798">Platform CLI</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1810">Power Platform build tools for</st> <st c="1842">Azure DevOps</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1854">GitHub Actions for</st> <st c="1874">Power Platform</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1888">Managed pipelines – source</st> <st c="1916">control integration</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1935">Copilots in Power Platform</st> <st c="1963">pipeline development</st>
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1983">Technical requirements</st>
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2006">To create our first CI/CD pipelines by using pro-dev DevOps tools,
    we need to have</st> <st c="2090">the following:</st>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2104">A Power Platform subscription.</st> <st c="2136">We can sign up
    for a Power Apps Developer Plan (</st>[<st c="2184">https://www.microsoft.com/en-us/power-platform/products/power-apps/free</st>](https://www.microsoft.com/en-us/power-platform/products/power-apps/free)<st
    c="2256">) if we already have a Microsoft Entra ID work account.</st> <st c="2313">Or,
    we can join the Microsoft 365 Developer</st> <st c="2357">Program (</st>[<st c="2366">https://developer.microsoft.com/en-us/microsoft-365/dev-program</st>](https://developer.microsoft.com/en-us/microsoft-365/dev-program)<st
    c="2430">)</st><st c="2432">.</st>
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '<st c="2433">An Azure DevOps Services organization: we can create a DevOps
    organization any time</st> *<st c="2518">for free</st>* <st c="2526">(</st>[<st
    c="2528">https://learn.microsoft.com/en-us/azure/devops/user-guide/sign-up-invite-teammates</st>](https://learn.microsoft.com/en-us/azure/devops/user-guide/sign-up-invite-teammates)<st
    c="2610">).</st> <st c="2614">If we create a public project in Azure DevOps, we
    get multiple free pipelines and free access to every feature of the service –
    see the</st> **<st c="2750">Azure DevOps for Open</st>** **<st c="2772">Source</st>**
    <st c="2778">offering.</st>'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="2788">A GitHub handle and public repository (</st>[<st c="2828">https://github.com/signup</st>](https://github.com/signup)<st
    c="2854">), which is also</st> *<st c="2872">free</st>* <st c="2876">for</st>
    <st c="2881">public repositories.</st>
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="2901">A GitHub Copilot free trial (</st>[<st c="2931">https://github.com/login?return_to=%2Fgithub-copilot%2Fsignup</st>](https://github.com/login?return_to=%2Fgithub-copilot%2Fsignup)<st
    c="2993">) or access to Microsoft</st> <st c="3019">Copilot (</st>[<st c="3028">https://copilot.microsoft.com</st>](https://copilot.microsoft.com)<st
    c="3058">).</st>
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="3061">Visual Studio Code – it is highly recommended to use this free
    code editor to create, edit, and update the YAML files in this chapter.</st> <st
    c="3197">We can download Visual Studio Code on any platform via</st> [<st c="3252">https://code.visualstudio.com/download</st>](https://code.visualstudio.com/download)<st
    c="3290">, and with the help of the VS Code extensions for Power Platform, Git,
    Azure DevOps pipelines, and GitHub workflows, we can carry out a syntax highlight
    and a semantic check on our changes.</st> <st c="3480">With the Git extension,
    we can manage our Git repository, too.</st> <st c="3543">See the</st> *<st c="3551">Further
    reading</st>* <st c="3566">section to learn more about Visual Studio Code.</st>
    <st c="3615">As an alternative, we can directly visit</st> [<st c="3656">https://vscode.dev</st>](https://vscode.dev)
    <st c="3674">to use the Visual Studio Code editor online in our favorite browser
    to edit any files and to open a</st> <st c="3775">remote repository.</st>
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="3793">The code files for this chapter can be downloaded from our GitHub
    repo</st> <st c="3865">at</st> [<st c="3868">https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/tree/main/Chapter05</st>](https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/tree/main/Chapter05)<st
    c="3967">.</st>
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="3968">Git – the single source of truth</st>
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="4001">In custom development projects, the source code is maintained in</st>
    **<st c="4067">version control systems</st>**<st c="4090">. These</st> <st c="4097">systems
    let developers work together on the same code base so that they can constantly
    introduce new features and/or fix bugs without conflicting with the changes of
    others.</st> <st c="4272">One of the reasons we use such code repositories (version
    control systems) is to provide end-to-end forward and backward traceability between
    code in production (the running application) and source code changes that have
    been made before pushing a version to production.</st> <st c="4543">In modern
    DevOps tools, in the project management part, the work items that need to be developed
    are directly linked to code changes that are made by developers.</st> <st c="4705">Version
    control systems provide a history of items and support transaction-like changes
    that span over multiple files and folders in repositories.</st> <st c="4852">These
    are very</st> <st c="4866">often represented</st> <st c="4884">as</st> **<st c="4888">version
    or</st>** **<st c="4899">history trees</st>**<st c="4912">.</st>
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4913">For developers to work in the most effective and efficient way</st>
    *<st c="4977">in parallel</st>*<st c="4988">, version control systems provide
    branching capabilities.</st> <st c="5046">A</st> **<st c="5048">branch</st>**<st
    c="5054">, as its name suggests, is a snapshot of a line of code – a fork that
    then</st> <st c="5128">manages its own history.</st> <st c="5154">Changes that
    we commit (play back) to this branch are not visible from the branch from which
    our branch was created.</st> <st c="5271">The mainline or root – the main branch
    itself – is presented as a branch in this approach as well.</st> <st c="5370">After
    completing our backlog item in the child branch, we</st> **<st c="5428">merge</st>**
    <st c="5433">back the changes to the parent branch.</st> <st c="5473">Branches
    can be created at any depth, but, in general, we recommend keeping the depth of
    the branch hierarchy as flat as possible to avoid integration debt later.</st>
    <st c="5636">Branches separate the work in progress from stable and</st> <st c="5691">tested
    code.</st>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5703">To maintain and control a healthy development environment, we need
    to define our branch strategy.</st> <st c="5802">A</st> **<st c="5804">branch
    strategy</st>** <st c="5819">is a set of guidelines and best practices for managing
    branches in a version control system.</st> <st c="5913">It helps teams to organize
    their code base, streamline their development process, and minimize conflicts
    when merging code.</st> <st c="6037">There are several popular branch strategies.</st>
    <st c="6082">It is important for teams to choose a branch strategy that fits their
    development process and to follow it consistently to ensure smooth collaboration
    and efficient code management.</st> <st c="6264">Let us have a look at the two
    most popular</st> <st c="6307">branch strategies:</st>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5703">为了维护和控制一个健康的开发环境，我们需要定义我们的分支策略。</st> <st c="5802">一个</st> **<st
    c="5804">分支策略</st>** <st c="5819">是管理版本控制系统中分支的一组指南和最佳实践。</st> <st c="5913">它帮助团队组织代码库、简化开发流程，并在合并代码时尽量减少冲突。</st>
    <st c="6037">有几种流行的分支策略。</st> <st c="6082">团队需要选择适合他们开发流程的分支策略，并且要始终如一地遵循它，以确保顺畅的协作和高效的代码管理。</st>
    <st c="6264">让我们来看一下最流行的两种</st> <st c="6307">分支策略：</st>
- en: '**<st c="6325">Trunk-based development</st>** <st c="6349">is a</st> <st c="6354">version
    control management practice where developers merge small, frequent updates to
    a core branch</st> <st c="6455">called</st> **<st c="6462">trunk</st>** <st c="6467">or</st>
    **<st c="6471">main</st>**<st c="6475">. The main characteristic of this approach
    is that the only long-lived branch is the main branch, which is always deployable.</st>
    <st c="6601">Developers can’t commit changes directly to the main branch, but
    instead, they work on short-lived branches and merge their changes to the main</st>
    <st c="6745">branch frequently.</st>'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="6325">基于主干的开发</st>** <st c="6349">是一种</st> <st c="6354">版本控制管理实践，开发人员将小的、频繁的更新合并到一个核心分支</st>
    <st c="6455">叫做</st> **<st c="6462">主干</st>** <st c="6467">或</st> **<st c="6471">主分支</st>**<st
    c="6475">。这种方法的主要特点是，唯一长期存在的分支是主分支，且始终可部署。</st> <st c="6601">开发人员不能直接将更改提交到主分支，而是他们在短期分支上工作，并将更改频繁地合并到主分支。</st>'
- en: '**<st c="6763">Git Flow / GitHub flow</st>** <st c="6786">was originally</st>
    **<st c="6802">Git Flow</st>** <st c="6810">that</st> <st c="6816">defined several
    long-living branches, like</st> <st c="6859">release-, hotfix- and patch branches
    next to the main branch.</st> <st c="6921">In the last decade, the software industry
    has evolved a lot and software development teams usually maintain only one version
    of software – the latest version.</st> <st c="7080">This means that there is no
    need to maintain such a complex branch hierarchy and this was the reason to move
    from Git Flow to GitHub flow.</st> **<st c="7219">GitHub flow</st>** <st c="7230">is
    a</st> <st c="7236">lightweight, branch-based workflow that supports teams and
    projects where deployments are made regularly.</st> <st c="7342">This workflow
    is very popular among developers because it allows them to work on new features,
    bug fixes, or experiments without affecting the main code base.</st> <st c="7501">Once
    the work on a branch is complete, it can be merged back into the main code base
    through a pull request.</st> <st c="7610">GitHub flow is very similar to trunk-based
    development but contains GitHub-specific capabilities, like</st> <st c="7713">pull
    requests.</st>'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="6763">Git Flow / GitHub flow</st>** <st c="6786">最初是</st> **<st c="6802">Git
    Flow</st>** <st c="6810">定义了几个长期存在的分支，比如</st> <st c="6816">发布、热修复和补丁分支，旁边还有主分支。</st>
    <st c="6921">在过去十年里，软件行业发生了很大的变化，软件开发团队通常只维护一个版本的软件——即最新版本。</st> <st c="7080">这意味着不再需要维护这么复杂的分支层次结构，这也是从
    Git Flow 转向 GitHub flow 的原因。</st> **<st c="7219">GitHub flow</st>** <st c="7230">是一种</st>
    <st c="7236">轻量级、基于分支的工作流，支持定期进行部署的团队和项目。</st> <st c="7342">这个工作流在开发人员中非常受欢迎，因为它允许他们在不影响主代码库的情况下，进行新特性的开发、修复
    bug 或进行实验。</st> <st c="7501">一旦某个分支上的工作完成，就可以通过拉取请求将其合并回主代码库。</st> <st c="7610">GitHub
    flow 与基于主干的开发非常相似，但它包含了 GitHub 特有的功能，如</st> <st c="7713">拉取请求。</st>'
- en: '**<st c="7727">Git</st>** <st c="7731">is</st> <st c="7735">the most widely
    used version control system.</st> <st c="7780">It is a</st> **<st c="7788">distributed
    version control system</st>**<st c="7822">, which</st> <st c="7829">means we can
    download a repository to our own development machines and, without internet connectivity,
    we can work on the repo by branching and making changes.</st> <st c="7990">Of
    course, if we would like to propagate our changes back to the team, we need to
    get connected and then</st> *<st c="8095">upload</st>* <st c="8101">our changes.</st>
    <st c="8115">There are</st> <st c="8124">also</st> **<st c="8130">centralized
    version control systems</st>** <st c="8165">on the market.</st> <st c="8181">These
    require continuous internet connectivity, which slows down the interaction with
    such repositories</st> <st c="8285">in general.</st>'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8296">Git, a</st> <st c="8304">fast, scalable, distributed revision control
    system is open source.</st> <st c="8372">There are many DevOps tools in which
    the open source Git engine is available, such as GitHub Enterprise, Azure DevOps
    Services, and GitLab.</st> <st c="8512">Of course, these engines are customized
    in a way that service providers can realize</st> <st c="8595">their own operational
    approaches and offer Git as a</st> **<st c="8648">Software-as-a-Service</st>**
    <st c="8669">(</st>**<st c="8671">SaaS</st>**<st c="8675">) offering, but the
    client APIs are compatible with any of</st> <st c="8735">these distributions.</st>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8755">In general, version control systems</st> <st c="8791">manage plain
    text files because these are the files that can be merged by developers in case
    of conflict resolution (conflicts are readable).</st> <st c="8934">Over the course
    of software history, more and more binary files, such as images, videos, sound
    files, 3D objects, and media files have become part of software solutions.</st>
    <st c="9104">In the early days of software development, these files were maintained
    parallel with the code base, although they were also part of the version that
    was modified/branched by developers.</st> <st c="9290">Git already supports large
    binary</st> <st c="9323">files (</st>**<st c="9331">Git Large File Storage</st>**<st
    c="9354">) and large monolith repositories to ease the migration from other version</st>
    <st c="9430">control systems.</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9446">Monolith large repositories</st>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9474">Among others, the code base of Microsoft Windows, with its 250
    GB, is maintained in one large monolith Git repository in an Azure DevOps</st>
    <st c="9612">Services project.</st>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9629">The</st> **<st c="9634">Git command-line interface</st>** <st c="9660">(</st>**<st
    c="9662">CLI</st>**<st c="9665">) is a</st> <st c="9672">powerful tool that allows
    developers to interact with Git repositories using a command-line terminal.</st>
    <st c="9775">The Git CLI is available on all major operating systems, including
    Windows, macOS, and Linux.</st> <st c="9869">Some very often used Git commands
    are</st> <st c="9907">the following:</st>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="9921">git clone</st>`<st c="9931">: This</st> <st c="9939">command</st>
    <st c="9947">is used to create a copy of a remote repository on your</st> <st
    c="10003">local machine.</st>'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="10017">git pull</st>`<st c="10026">: This</st> <st c="10033">command
    is used to fetch and merge changes from the remote repository into your</st> <st
    c="10114">local repository.</st>'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="10131">git push</st>`<st c="10140">: This</st> <st c="10148">command
    is used to upload your local repository changes (commits and branches) to the</st>
    <st c="10234">remote repository.</st>'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="10252">git commit</st>`<st c="10263">: This</st> <st c="10271">command
    is used to save changes to your local repository.</st> <st c="10329">It creates
    a new</st> `<st c="10346">commit</st>` <st c="10352">object in the repository
    history with the current state of</st> <st c="10412">the repository.</st>'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="10427">git branch</st>`<st c="10438">: This</st> <st c="10446">command
    is used to manage branches in a Git repository.</st> <st c="10502">It can be used
    to list, create, delete, and</st> <st c="10546">rename branches.</st>'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="10562">git checkout</st>`<st c="10575">: This</st> <st c="10583">command
    is used to switch between branches or to restore files in your working directory
    from</st> <st c="10677">the repository.</st>'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="10692">git merge</st>`<st c="10702">: This</st> <st c="10709">command
    is used to merge changes from one branch into another.</st> <st c="10773">It integrates
    changes from the named commits into the</st> <st c="10826">current branch.</st>'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="10842">Normally, we clone a repo, create a local branch, commit our changes,
    push our branch back to the remote origin, and finally, merge the changes back
    to the parent branch.</st> <st c="11014">This last operation is a special one
    that is sometimes referred to as a pull request depending on the Git distro, like
    GitHub or GitLab.</st> <st c="11151">We can merge branches without pull</st> <st
    c="11186">requests, too.</st>
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11200">The</st> **<st c="11205">pull request</st>** <st c="11217">is
    a</st> <st c="11223">mechanism for developers to notify team members that they
    have completed a feature.</st> <st c="11307">Once their feature branch is ready,
    the developer files a pull request via their online repository.</st> <st c="11407">The
    rest of the team then reviews the code and can make comments and suggestions.</st>
    <st c="11489">Once the team agrees that the code is ready, it can be merged into
    the main code base.</st> <st c="11576">Pull requests are a way to</st> *<st c="11603">foster
    code reviews</st>* <st c="11622">and collaboration within a</st> <st c="11650">development
    team.</st>
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11667">Pull requests</st>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11681">Pull requests are</st> <st c="11699">more than just a</st> `<st
    c="11717">git merge</st>` <st c="11726">operation.</st> <st c="11738">DevOps tools
    such as GitHub or Azure DevOps Services provide web UI support and their own CLI
    tools to initiate pull requests</st> <st c="11864">on branches.</st>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11876">Having understood the key concepts of Git, let us see how it fits
    with our Power Platform solutions.</st> <st c="11978">As we discussed earlier,
    in</st> [*<st c="12006">Chapter 4</st>*](B22208_04.xhtml#_idTextAnchor074)<st
    c="12015">, Power Platform solutions</st> <st c="12041">are available in managed
    and unmanaged formats.</st> <st c="12090">Depending on a solution’s content, the
    difference between managed and unmanaged solutions can vary significantly.</st>
    <st c="12204">For instance, if a solution contains PowerApps application, then
    a managed one will contain a few files and one of them will be the</st> `<st c="12336">msapp</st>`
    <st c="12341">document, which includes every asset of the PowerApps canvas app
    in compressed format.</st> <st c="12429">On the other hand, an unmanaged solution
    will consist of XML and JSON files in a well-defined folder structure describing
    the solution with all its assets, such as apps, flows, bots, connection references,
    and so on, in plain</st> <st c="12655">text format.</st>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12667">And this is the exact place where version control systems a play
    significant role, as the following</st> <st c="12768">figure illustrates:</st>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Developer environments with corresponding child branches](img/B22208_05_1.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
- en: <st c="12871">Figure 5.1 – Developer environments with corresponding child branches</st>
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12940">App makers and developers (</st>**<st c="12968">DevA</st>** <st
    c="12973">and</st> **<st c="12978">DevB</st>** <st c="12982">in our case) use
    dedicated developer environments to craft a solution(s).</st> <st c="13057">When
    the first version of their application is created, they commit both the managed
    and unmanaged</st> <st c="13156">Power Platform solutions – the latter one as
    unpacked – to their own child branches, created from the main branch.</st> <st
    c="13271">After that, they work on these branches, and respectively in the corresponding
    environments, by constantly synchronizing the changes between environment and
    branch.</st> <st c="13436">When they are ready, they submit a pull request to
    merge back the changes from the child branch to the main branch.</st> <st c="13552">In
    an ideal case, there is no merge conflict and the changes are integrated into
    the main branch smoothly.</st> **<st c="13659">Merge conflicts</st>** <st c="13674">are</st>
    <st c="13679">conflicting changes – that is, when the same file in the same position
    is changed on both parent and child branches.</st> <st c="13796">If a merge conflict
    occurs, then the pull request is refused, and the developer needs to merge the
    changes back from the main branch to the developer branch and resolve the conflicts
    there.</st> <st c="13986">In the case of Power Platform, it doesn’t mean just
    resolving conflicts at the code level, but also loading the unmanaged solution
    back to the developer environment to check everything works as expected and then
    publishing the changes.</st> <st c="14222">After that, we need to export the solution
    back to the developer branch and resubmit the</st> <st c="14311">pull request.</st>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14324">Overall, branching and child branches allow developers to work
    parallelly even on the same Power Platform solution, but we need to pay careful
    attention and let developers work on different assets</st> <st c="14522">in solutions.</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14535">After getting to know the Git features, let us learn about the
    tool that we can use to export and import solutions in</st> <st c="14654">Power
    Platform.</st>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14669">Power Platform CLI</st>
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="14688">We have already seen some of the</st> <st c="14721">PAC CLI commands
    in the previous chapters, such as signing in to the different environments or
    installing the Power Platform pipeline as a Dynamics 365 application in our environment.</st>
    <st c="14906">Besides these commands, PAC CLI supports many more commands and
    features that we can authenticate on behalf of service principals and manage our
    solutions, environments, deployments, pipelines, and more.</st> <st c="15110">One
    of the biggest advantages of PAC CLI is that it runs on any platform, and can
    be integrated into any</st> <st c="15215">DevOps tool.</st>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15227">Some of the most often-used commands of PAC CLI are</st> <st c="15280">the
    following:</st>
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15294">The</st> `<st c="15299">pac admin</st>` <st c="15308">command</st>
    <st c="15316">group provides a set of commands to work with your Power Platform
    admin account, such as creating an environment, creating service</st> <st c="15448">principals,
    assigning Microsoft Entra ID groups to environments, and</st> <st c="15517">so
    on.</st>
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="15523">The</st> `<st c="15528">pac application</st>` <st c="15543">command</st>
    <st c="15551">group is for listing and installing available Dataverse applications
    from AppSource.</st> <st c="15637">We used</st> `<st c="15645">pac application
    install</st>` <st c="15668">to deploy Power Platform pipelines as a Dynamics 365
    application in our production environment in</st> [*<st c="15767">Chapter 4</st>*](B22208_04.xhtml#_idTextAnchor074)<st
    c="15776">.</st>
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="15777">The</st> `<st c="15782">pac auth</st>` <st c="15790">command</st>
    <st c="15798">group provides a set of commands to authenticate in different services,
    such as environments or whole tenants.</st> <st c="15910">We can use service accounts
    as well as service principals.</st> <st c="15969">Our credentials are stored locally</st>
    <st c="16004">if needed.</st>
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="16014">The</st> `<st c="16019">pac canvas</st>` <st c="16029">commands</st>
    <st c="16039">work with Power Apps</st> `<st c="16060">.msapp</st>` <st c="16066">files.</st>
    <st c="16074">These files are created when we export canvas apps from Power Apps
    Studio directly or as part of our Power</st> <st c="16181">Platform solutions.</st>
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="16200">The</st> `<st c="16205">pac catalog</st>` <st c="16216">command</st>
    <st c="16224">group provides commands for managing the</st> `<st c="16395">pac
    catalog</st>` <st c="16406">command group include</st> `<st c="16429">pac catalog
    install</st>`<st c="16448">, which installs a catalog item in the target environment,
    and</st> `<st c="16511">pac catalog list</st>`<st c="16527">, which lists all
    published catalog items from the current</st> <st c="16586">Dataverse organization.</st>
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="16609">The</st> `<st c="16614">pac copilot</st>` <st c="16625">command</st>
    <st c="16633">group provides commands for managing chatbots and AI Builder models
    (among others, new large language models).</st> <st c="16745">Some of the commands
    available include</st> `<st c="16784">pac copilot predict</st>`<st c="16803">,
    which sends text or prompts to an AI model,</st> `<st c="16849">pac copilot create</st>`
    <st c="16867">for creating a new bot using an existing template file as the reference,
    and</st> `<st c="16945">pac copilot list</st>` <st c="16961">for listing virtual
    agents in the current or target</st> <st c="17014">Dataverse environment.</st>
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="17036">The</st> `<st c="17041">pac package</st>` <st c="17052">command</st>
    <st c="17060">group is a set of tools and utilities for</st> <st c="17103">managing
    packages.</st> <st c="17122">It includes commands such as</st> `<st c="17151">pac
    package add-external-package</st>` <st c="17183">for adding a package that is
    external to the Dataverse solution system to</st> <st c="17257">a</st> `<st c="17286">pac
    package add-reference</st>` <st c="17311">for adding a reference to a Dataverse
    solution project, and</st> `<st c="17372">pac package add-solution</st>` <st c="17396">for
    adding a prebuilt Dataverse solution file to a Package Deployer project.</st>
    <st c="17474">Please note that, in</st> [*<st c="17495">Chapter 4</st>*](B22208_04.xhtml#_idTextAnchor074)<st
    c="17504">, we discussed the Package Deployer in the context of Power Platform
    Enterprise</st> <st c="17584">templates, too.</st>
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="17599">The</st> `<st c="17604">pac pcf</st>` <st c="17611">command group</st>
    <st c="17625">is used for</st> <st c="17638">managing and working with</st> `<st
    c="17741">pac pcf init</st>` <st c="17753">for initializing a new Power Apps component
    framework project in the current directory, and</st> `<st c="17846">pac pcf push</st>`
    <st c="17858">for pushing the component to the Power Apps component framework</st>
    <st c="17923">developer environment.</st>
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="17945">The</st> `<st c="17950">pac pipeline</st>` <st c="17962">command</st>
    <st c="17970">group is used to work with Power Platform pipelines.</st> <st c="18024">For
    example,</st> `<st c="18037">pac pipeline deploy</st>` <st c="18056">is used to
    start pipeline deployment, while</st> `<st c="18101">pac pipeline list</st>` <st
    c="18118">is used to list pipelines in the given environment.</st> <st c="18171">This
    command group provides the option for administrators and ops teams to start deployments
    in a fully automated way, as we discussed in</st> [*<st c="18309">Chapter 4</st>*](B22208_04.xhtml#_idTextAnchor074)<st
    c="18318">.</st>
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="18319">The</st> `<st c="18324">pac plugin</st>` <st c="18334">command</st>
    <st c="18342">group is used to work with</st> `<st c="18446">pac plugin init</st>`
    <st c="18461">is used to initialize a directory with a new Dataverse plugin class
    library, while</st> `<st c="18545">pac plugin push</st>` <st c="18560">is used
    to import a plugin into Dataverse.</st> <st c="18604">We can use .NET Framework-based
    plugins to react to Dataverse events on the server side running in the context
    of the</st> <st c="18722">Dataverse engine.</st>
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="18739">The</st> `<st c="18744">pac powerpages</st>` <st c="18758">command
    group</st> <st c="18772">is for</st> <st c="18780">managing</st> `<st c="18853">pac
    powerpages list</st>` <st c="18872">is used to list all</st> <st c="18893">Power
    Pages websites from the current Dataverse environment, while</st> `<st c="18960">pac
    powerpages download</st>` <st c="18983">is used to download Power Pages website
    content from the current Dataverse environment to move it to another environment
    with</st> `<st c="19110">pac</st>` `<st c="19114">powerpages upload</st>`<st c="19131">.</st>
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="19132">The</st> `<st c="19137">pac solution</st>` <st c="19149">command
    group</st> <st c="19163">is used to work</st> <st c="19179">with</st> `<st c="19249">pac
    solution</st>` <st c="19261">command group include</st> `<st c="19284">pac solution
    init</st>`<st c="19301">, which initializes an MSBuild-based</st> `<st c="19338">cdsproj</st>`
    <st c="19345">file for component framework components;</st> `<st c="19387">pac
    solution add-reference</st>`<st c="19413">, which adds a reference from the project
    in the current directory to the project at the specified path; and</st> `<st c="19522">pac
    solution add-solution-component</st>`<st c="19557">, which adds one or more solution
    components to the target unmanaged solution in Dataverse.</st> <st c="19649">Imports
    and exports of solutions are also supported by the equivalent</st> `<st c="19719">pac</st>`
    `<st c="19723">solution</st>` <st c="19731">commands.</st>
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="19741">PAC CLI and Power Platform PowerShell modules</st>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19787">PAC CLI is the next-generation command-line tool for Power Platform,
    which runs on any OS platform.</st> <st c="19888">PowerShell admin capabilities
    are continuously migrated to PAC CLI to reach feature parity in the future.</st>
    <st c="19994">PAC CLI and PowerShell modules are wrappers around the underlying
    REST API endpoints of</st> <st c="20082">Power Platform.</st>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20097">To install PAC CLI, we need to have .NET Core 3.1 or later (.NET
    6 is recommended) already deployed to our machine.</st> <st c="20214">After that,
    we can execute the following command in our favorite terminal (CMD on Windows,
    Bash on Linux, or Terminal</st> <st c="20332">on macOS):</st>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="20400">Now that we have learned about the breadth and depth of the commands
    available in PAC CLI, in the next sections, we will understand how this CLI tool
    is utilized by Azure DevOps Services and</st> <st c="20592">GitHub Enterprise.</st>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20610">Power Platform build tools for Azure DevOps</st>
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**<st c="20654">Azure Pipelines</st>** <st c="20670">stands</st> <st c="20678">out
    as a robust feature within Azure DevOps Services, offering a</st> <st c="20742">comprehensive</st>
    **<st c="20757">continuous integration</st>** <st c="20779">(</st>**<st c="20781">CI</st>**<st
    c="20783">) and</st> **<st c="20790">continuous delivery</st>** <st c="20809">(</st>**<st
    c="20811">CD</st>**<st c="20813">) service.</st> <st c="20825">Compatible with
    your Git provider of choice (GitHub or</st> <st c="20879">Azure DevOps), it enables
    deployments across various major cloud providers, including Microsoft Azure.</st>
    <st c="20983">This service streamlines the process of building, testing, and deploying
    your code base.</st> <st c="21072">It supports an</st> <st c="21086">extensive
    array of programming</st> <st c="21118">languages and platforms, such as .NET,
    Java, Node.js, Android, Xcode, and C++, and allows for a variety of testing frameworks
    and services to be utilized.</st> <st c="21273">Additionally, Azure Pipelines
    enables the execution of scripts in the command line, PowerShell, Bash, or Shell
    within your</st> <st c="21396">automation workflows.</st>'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21417">Azure Pipelines also provides the infrastructure in which our
    scripts and pipeline tasks can run.</st> **<st c="21516">Azure Pipelines agents</st>**
    <st c="21538">are</st> <st c="21542">containers (virtual machines in a virtual
    machine scale set) that execute our jobs (pipeline tasks).</st> <st c="21644">Agents
    are installed in these machines, and they use HTTP outbound connectivity to Azure
    DevOps endpoints to pull the activities they need</st> <st c="21783">to run.</st>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21790">There are different types of agents, including Microsoft-hosted
    agents, self-hosted agents, and Azure Virtual Machine Scale</st> <st c="21915">Set
    agents:</st>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="21926">Microsoft-hosted agents</st>** <st c="21950">provide a</st>
    <st c="21960">hassle-free solution for executing your jobs.</st> <st c="22007">These
    agents are fully managed by Microsoft, ensuring that they are always up to date
    with the latest virtual machine image specified in your YAML pipeline, without
    requiring any maintenance or upgrades on</st> <st c="22213">our part.</st>'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="22222">Self-hosted agents</st>** <st c="22241">are those</st> <st
    c="22251">that we set up and maintain on our own virtual machines.</st> <st c="22309">This
    option provides us with greater control over the machine specifications and the
    operating system images utilized by</st> <st c="22430">the agents.</st>'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="22441">Azure Virtual Machine Scale Set agents</st>** <st c="22480">are</st>
    <st c="22485">a kind of self-hosted agent that embraces the Virtual Machine Sale
    Set’s autoscaling features heavily.</st> <st c="22588">Azure DevOps scales out
    and scales in VMs based on the size of</st> <st c="22651">pipeline queues.</st>'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="22667">In Azure Pipelines, a</st> **<st c="22690">job</st>** <st c="22693">is</st>
    <st c="22697">a series of steps that run sequentially as a unit.</st> <st c="22748">Every
    pipeline has at least one job, and a job is the smallest unit of work that can
    be scheduled to run.</st> <st c="22854">Jobs can be organized into stages, and
    you can specify conditions and dependencies to control when jobs run.</st> <st
    c="22963">Jobs can run on Microsoft-hosted agents, self-hosted agents, or Azure
    Virtual Machine Scale Set agents, and can be run directly on the host machine
    of the agent or in a container.</st> <st c="23143">Azure Pipelines supports running
    jobs in parallel on Linux, macOS, and Windows.</st> <st c="23223">You can create
    and configure pipelines in the Azure DevOps web portal with the classic user interface
    editor as well as with the latest YAML-based script editor.</st> <st c="23385">We
    prefer the latter because the version control management of these YAML files is
    also available in</st> <st c="23486">that case.</st>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23496">The advanced capabilities of</st> <st c="23526">Azure Pipelines,
    like the infrastructure and</st> <st c="23571">topology of Microsoft-hosted and
    self-hosted build agents, are beyond this book, but you can find further information
    and learning modules in the</st> *<st c="23717">Further</st>* *<st c="23725">reading</st>*
    <st c="23732">section.</st>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23741">On top of Azure</st> <st c="23758">Pipelines,</st> **<st c="23769">Microsoft
    Build Tools for Power Platform (Microsoft Power Platform Build Tools for Azure
    DevOps)</st>** <st c="23865">provides additional tasks in Azure DevOps that can
    be used to automate common build and deployment tasks related to solutions built
    on Microsoft Power Platform.</st> <st c="24027">Some of the available tasks include
    the</st> **<st c="24067">Power Platform Tool Installer</st>**<st c="24096">, which
    installs</st> <st c="24113">Power Platform tools (among others, the PAC CLI in
    the agent).</st> <st c="24176">This build task is a mandatory step at the beginning
    of every build and release pipeline in which we would like to use other Power
    Platform build tasks.</st> <st c="24329">The build tools work for canvas- and
    model-driven apps, Microsoft Copilot Studio, cloud and desktop flows, Power Pages
    websites, AI Builder models, custom connectors, and dataflows, for everything
    that can be added to</st> <st c="24547">a solution.</st>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24558">Every build task uses PAC CLI under the hood and the Power Platform
    wrapper provides a common interface for Azure DevOps Pipelines and</st> <st c="24694">GitHub
    Actions:</st>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Power Platform build tools and GitHub Actions architecture](img/B22208_05_2.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
- en: <st c="24793">Figure 5.2 – Power Platform build tools and GitHub Actions architecture</st>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24864">This means that when we</st> <st c="24889">use a task such as</st>
    `<st c="24908">PowerPlatformExportSolution@2</st>`<st c="24937">, then this pipeline
    task executes the corresponding PAC CLI</st> <st c="24997">command through the
    wrapper with the appropriate parameters.</st> <st c="25059">Let us have a look
    at a pipeline that exports a managed solution, unpacks it, and publishes it to
    the build artifacts (see</st> `<st c="25182">.pipelines/powerlatform-exportsolution.yml</st>`
    <st c="25224">in the</st> `<st c="25232">Chapter05</st>` <st c="25241">folder
    of the</st> <st c="25256">GitHub repo):</st>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '<st c="26290">The</st> `<st c="26295">PowerPlatformExportSolution@2</st>` <st
    c="26324">uses a service connection (</st>`<st c="26352">PowerPlatformSPN: ''PowerPlatformE5-Default''</st>`<st
    c="26396">) to connect to the Dataverse.</st> **<st c="26428">Service connections</st>**
    <st c="26447">allow</st> <st c="26454">you to connect to external and remote services
    to execute tasks in</st> <st c="26520">your pipelines.</st> <st c="26537">They
    provide a way to authenticate and authorize Azure DevOps with external services</st>
    <st c="26621">so that Azure DevOps can access resources and perform operations
    on your behalf, or on behalf of service principals.</st> <st c="26739">There is
    a dedicated service connection for</st> <st c="26783">Power Platform.</st>'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26798">We have just discovered how to use the familiar Azure Pipelines
    YAML-based approach for Power Platform CI/CD, just as we do for other custom</st>
    <st c="26940">development projects.</st>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26961">GitHub Actions for Power Platform</st>
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**<st c="26995">GitHub Actions</st>** <st c="27010">were</st> <st c="27015">originally
    designed and developed by the same engineering teams that created the Azure Pipelines
    after Microsoft had acquired GitHub.</st> <st c="27150">At the time of acquisition,
    GitHub did not even support any of the automation that Azure Pipelines</st> <st
    c="27249">offered developers.</st>'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27268">That’s why it is not surprising that the GitHub Actions engine,
    the infrastructure, the agents (runners in GitHub), and the concept are more or
    less the same as in Azure DevOps.</st> <st c="27447">And in some cases, GitHub
    Actions is even better.</st> <st c="27497">It can provide much more trigger conditions
    than Azure Pipelines.</st> <st c="27563">For instance GitHub Actions can react
    to changes in GitHub issues – in pull request comments, in Wiki pages, and in
    general to changes to any asset surrounding a GitHub project.</st> <st c="27741">These
    actions are lightweight functions, and the trigger framework can easily be extended</st>
    <st c="27831">with webhooks.</st>
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27845">GitHub has its own build agents, which are</st> <st c="27889">called</st>
    **<st c="27896">GitHub runners</st>**<st c="27910">.</st>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27911">Behind the scenes, the agent runtime, the Windows service, and
    the Linux/macOS daemon that host GitHub Actions are nearly identical to the runtime
    used in Azure DevOps Services.</st> <st c="28090">GitHub runners are virtual machines
    that run your GitHub Actions workflows.</st> <st c="28166">They are available
    in two</st> <st c="28191">types:</st> **<st c="28199">GitHub-hosted</st>** <st
    c="28212">and</st> **<st c="28217">self-hosted</st>**<st c="28228">. For</st>
    <st c="28234">professionals, GitHub offers a range of managed virtual machines
    with more RAM, CPU, and disk space for customers on GitHub Team and GitHub Enterprise
    Cloud plans.</st> <st c="28398">These larger runners are hosted by GitHub and
    have the runner application and other preinstalled tools.</st> <st c="28502">GitHub-hosted
    runners make it easy for GitHub Enterprise plan customers to securely connect
    their CI/CD machines to other DevOps services in the cloud or on-prem, such</st>
    <st c="28669">as</st> **<st c="28673">Artifactory</st>**<st c="28684">,</st> **<st
    c="28686">Nexus</st>**<st c="28691">, or any</st> <st c="28699">other service,
    with the help of reserved static IP ranges or by using Azure Virtual Networks.</st>
    <st c="28794">In the case of public GitHub repositories, every month, the first
    2,000 minutes of GitHub-hosted runners’ executions are free</st> <st c="28920">of
    charge.</st>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: <st c="28930">For more</st> <st c="28939">granular control, you can also combine
    runner groups with labels.</st> **<st c="29006">Runner groups</st>** <st c="29019">can
    only have large</st> <st c="29040">runners or self-hosted runners as members.</st>
    <st c="29083">This provides professionals with the flexibility to choose the best
    runner for their specific needs.</st> <st c="29184">GitHub runners can also run
    inside Docker containers.</st> <st c="29238">By doing so, we can even easily spin
    up Kubernetes-based</st> <st c="29295">build/deployment farms.</st>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29318">Both GitHub runners and Azure DevOps agents are open source projects
    and welcome contributors from all around the world (see the GitHub repository
    links under</st> *<st c="29478">Further reading</st>*<st c="29493">).</st>
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="29496">Regarding the workflow definitions: there are also some differences
    in YAML tags and keywords, but the main design principles are</st> <st c="29627">the
    same.</st>'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29636">Azure DevOps Services versus GitHub</st>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29672">A frequently asked question in the</st> <st c="29708">industry
    is whether Azure DevOps Services or</st> <st c="29753">GitHub is the future.</st>
    <st c="29775">The Microsoft strategy at the time of writing is to recommend GitHub
    for greenfield organizations – organizations who are just starting their DevOps
    journeys.</st> <st c="29934">If an organization already uses Azure DevOps, then
    Microsoft recommends introducing GitHub only in areas in which it brings a compelling
    advantage.</st> *<st c="30082">This compelling advantage is now GitHub Copilot</st>*<st
    c="30129">. In the last few years, we have seen that the investment in GitHub
    features has been 5-10 times greater than in Azure</st> <st c="30248">DevOps Services.</st>
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30264">In the next section, we will look closely at GitHub workflows
    and actions</st> <st c="30339">at work.</st>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30347">Managed pipelines – source control integration with Git</st>
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="30403">In</st> [*<st c="30407">Chapter 4</st>*](B22208_04.xhtml#_idTextAnchor074)<st
    c="30416">, we created our</st> <st c="30432">first Power Platform managed pipeline,
    which deployed our</st> `<st c="30491">mpa_ITBase</st>` <st c="30501">solution
    from the developer environment to the production environment using a service principal.</st>
    <st c="30599">In this section, we continue our journey and, based on the lessons
    learned about PAC CLI, build tools for Azure DevOps Services, and GitHub Actions
    for Power Platform, we will commit our solution artifacts to a GitHub repository
    with the help of GitHub Actions for Power Platform and the Dataverse trigger events
    available in the context of Power</st> <st c="30946">Platform pipelines.</st>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30965">Let us have a look at the events that we can use in our Power
    Automate cloud flows in the</st> `<st c="31056">Pipelinehost</st>` <st c="31068">environment
    to react to certain changes in</st> <st c="31112">deployment pipelines:</st>
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="31133">OnApprovalStarted</st>` <st c="31151">–</st> `<st c="31154">OnApprovalCompleted</st>`<st
    c="31173">: These events are triggered when there is approval configured in the
    deployment stage prior to deploying the solution to that stage.</st> <st c="31308">We
    usually use this step to notify release managers or environment owners about the</st>
    <st c="31392">planned deployment.</st>'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="31411">OnPredeploymentStarted</st>` <st c="31434">–</st> `<st c="31437">OnPredeploymentCompleted</st>`<st
    c="31461">: These events occur prior to releasing our solution to the deployment
    stage.</st> <st c="31540">We can use these events to do some configuration in
    the target environment, such as updating environment variables and importing (static)
    data before</st> <st c="31690">solution deployment.</st>'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="31710">OnDeploymentRequested</st>` <st c="31732">–</st> `<st c="31735">OnDeploymentStarted</st>`
    <st c="31754">–</st> `<st c="31757">OnDeploymentCompleted</st>`<st c="31778">:
    These events occur over the course of deploying the solution to the</st> <st c="31849">deployment
    stage.</st>'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="31866">Dataverse pipeline events</st>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31892">Dataverse Power Platform pipeline-related events are triggered
    in every deployment stage regardless of the number of stages and pipelines.</st>
    <st c="32032">Pipeline triggers provide additional attributes to filter down to
    the pipeline and to the stage that we are</st> <st c="32140">interested in.</st>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32154">With the help of these</st> <st c="32178">building blocks, we
    can create different strategies for how we are going to manage our pipelines and
    how we are going to maintain our solutions outside of Power Platform environments.</st>
    <st c="32362">We should decide</st> <st c="32379">the following:</st>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: <st c="32393">Shall we use a separate Git repository per solution?</st> <st
    c="32447">Or, shall we plan to store multiple solutions per Git repository?</st>
    <st c="32513">Do we plan to introduce pipeline templating for</st> <st c="32561">reusability
    purposes?</st>
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="32582">Shall we introduce one Git repository</st> <st c="32621">per environment?</st>
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="32637">Do we plan to store the solution artifacts deployed to deployment
    stages in different</st> <st c="32724">child branches?</st>
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="32739">Shall we use pull requests to merge back the latest changes from
    child branches to the main branch?</st> <st c="32840">Shall we use pull request
    triggers in our pipelines to finish the deployments in production environments?</st>
    <st c="32946">This would also mean that the managed pipelines would not reach
    the production environment, just the</st> <st c="33047">pre-prod/test environments.</st>
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="33074">Do we plan to store only the deployment artifacts that have been
    successfully deployed to production environments on the main branch?</st> <st
    c="33209">Shall we consider a branching strategy</st> <st c="33248">at all?</st>
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="33255">There is no silver bullet to answer these questions since the
    selected strategy really depends on the maturity level of the organization, the
    complexity of the project, and the overall DevOps processes</st> <st c="33458">defined
    internally.</st>
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: <st c="33477">The following figure illustrates a possible approach to commit
    the solution to the main branch after deploying to production with the help of
    a Power</st> <st c="33628">Platform pipeline:</st>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Git integration with Power Platform pipelines](img/B22208_05_3.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
- en: <st c="34167">Figure 5.3 – Git integration with Power Platform pipelines</st>
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: <st c="34225">The managed and</st> <st c="34242">unmanaged solutions are generated
    at the beginning of the deployment that we initiated through the Power Platform
    pipeline.</st> <st c="34366">When a managed pipeline runs, other developers cannot
    queue this pipeline, which guarantees mutual exclusion.</st> <st c="34476">The
    generated artifacts are stored in the Dataverse</st> `<st c="34528">DeploymentArtifacts</st>`
    <st c="34547">table of the</st> `<st c="34561">Pipelinehost</st>` <st c="34573">environment.</st>
    <st c="34587">As the package (managed solution) goes through the pipeline stages
    (</st>`<st c="34655">Test</st>` <st c="34660">and</st> `<st c="34665">Prod</st>`
    <st c="34669">environment, in our example) the previously mentioned events are
    triggered.</st> <st c="34746">We use the</st> `<st c="34757">OnDeploymentCompleted</st>`
    <st c="34778">event to execute our cloud flow, which will dispatch our GitHub
    workflow through</st> `<st c="34860">HTTP POST</st>`<st c="34869">, and that will
    download the deployment artifacts and unpack and commit them to the</st> <st c="34953">main
    branch.</st>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: <st c="34965">To be able to download the artifacts from Dataverse, we create
    a service principal, and we use a Bash script in our GitHub flow to directly call
    the Dataverse Web API and to download our deployment artifacts through the</st>
    <st c="35186">OData protocol.</st>
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: <st c="35201">Let us use PAC CLI to create a service principal that we are going
    to use in</st> <st c="35279">GitHub workflows:</st>
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="35592">The last call</st> <st c="35607">requires administrative privileges
    not just in the Power Platform tenant, but in Microsoft Entra ID (the</st> `<st
    c="35712">Application.ReadWrite.Allpermission</st>` <st c="35747">role), too.</st>
    <st c="35760">The output of this call contains the client secret, application
    ID (client), and tenant ID of the app registration, and, respectively, the enterprise
    application.</st> <st c="35923">This command also registers this service principal
    in Dataverse by adding it as an application user to the environment.</st> <st
    c="36043">We need to save the output of the last command for later usage of the
    client ID, client secret, and tenant ID in our</st> <st c="36160">GitHub workflow:</st>
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="36941">Having created the service principal with a client ID and client
    secret, let’s move on to the GitHub workflow that will</st> <st c="37062">use
    them.</st>
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: <st c="37071">GitHub workflows</st>
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="37088">It is time to set up</st> <st c="37110">GitHub flow in one of
    our GitHub repositories.</st> <st c="37157">We will use</st> **<st c="37169">Visual
    Studio Code</st>** <st c="37187">in the</st> <st c="37194">upcoming steps to create
    our YAML file.</st> <st c="37235">Alternatively, we could use the GitHub UI to
    create</st> <st c="37287">our workflow:</st>
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: <st c="37300">Create repository secrets with the names</st> `<st c="37342">TENANT_ID</st>`<st
    c="37351">,</st> `<st c="37353">CLIENT_ID</st>`<st c="37362">, and</st> `<st c="37368">CLIENT_SECRET</st>`
    <st c="37381">in the selected</st> <st c="37398">GitHub repository.</st>
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="37416">Create a GitHub flow (with the name</st> `<st c="37453">downloadunpackcommitbash.yml</st>`<st
    c="37481">) and set its trigger condition</st> <st c="37514">to</st> `<st c="37517">workflow_dispatch</st>`<st
    c="37534">:</st>
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="37631">Introduce input parameters that will be called by the Power Automate</st>
    <st c="37701">cloud flow:</st>
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="38348">Configure standard permissions and</st> <st c="38384">the GitHub-hosted
    build agent’s</st> <st c="38416">operating system:</st>
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="38513">Check out the source branch in the</st> <st c="38549">build agent:</st>
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="38648">Create a new branch if the target branch</st> <st c="38690">is
    specified:</st>
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <st c="38968">Execute a</st> <st c="38979">Bash script that requests an access
    token from Microsoft Entra ID with the Dataverse scope using the tenant ID, client
    ID, and client secret generated by PAC CLI.</st> <st c="39142">After getting the
    token, we reach out to the Dataverse Web API endpoint of our table (</st>`<st
    c="39228">DeploymentArtifacts</st>`<st c="39248">) and we download the artifact
    identified by its GUID</st> <st c="39303">using</st> *<st c="39309">curl</st>*<st
    c="39313">:</st>
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <st c="40558">Using the</st> <st c="40569">GitHub Power Platform action (</st>`<st
    c="40599">unpack-solution</st>`<st c="40615">), we unpack the managed and unmanaged
    versions of the solution to the repository on the</st> <st c="40705">build agent:</st>
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <st c="41053">Commit the</st> <st c="41064">changes locally in the build agent
    either into the target branch or into the</st> <st c="41142">source branch:</st>
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <st c="41571">Push the changes to the</st> <st c="41596">remote origins:</st>
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <st c="41888">The Dataverse Web API – OData protocol</st>
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41927">We use the Dataverse</st> <st c="41948">Web API to query Dataverse
    tables and records using the REST API on the OData protocol.</st> <st c="42037">Our
    GitHub workflow’s input parameter,</st> `<st c="42076">artifact_url</st>`<st c="42088">,
    expects the following string to get the record identified by its unique identifier,
    and its column,</st> `<st c="42190">ArtifactFile</st>` `<st c="42202">https://[</st>`<st
    c="42212">.</st> `<st c="42214">$Value</st>`<st c="42220">, refers to the binary
    content.</st> <st c="42252">Since we’re using Bash and Bash treats the</st> `<st
    c="42295">$</st>` <st c="42296">sign as a special character, we need to use the
    escape character (backslash) to add</st> `<st c="42381">$value</st>` <st c="42387">to
    the end of the</st> <st c="42406">artifact URL.</st>
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: <st c="42419">To test our GitHub flow, we can use the</st> `<st c="42460">run
    workflow</st>` <st c="42472">command in the GitHub UI by providing the</st> <st
    c="42515">inputs manually:</st>
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – GitHub – run workflow manually](img/B22208_05_4.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
- en: <st c="43098">Figure 5.4 – GitHub – run workflow manually</st>
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43141">Now, we have a GitHub workflow</st> <st c="43172">that can download
    deployment artifacts and commit them to a child branch or the main branch, based
    on the input parameters.</st> <st c="43297">See</st> `<st c="43301">.github/downloadunpackcommitbash.yml</st>`
    <st c="43337">in the</st> `<st c="43345">Chapter05</st>` <st c="43354">folder
    of the book’s GitHub repo, which contains the entire GitHub workflow.</st> <st
    c="43432">The same workflow can be realized with PowerShell commands as well.</st>
    <st c="43500">See</st> `<st c="43504">.github/</st>` `<st c="43512">downloadunpackcommit.yml</st>`
    <st c="43537">in the</st> `<st c="43545">Chapter05</st>` <st c="43554">folder</st>
    <st c="43562">for details.</st>
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43574">It is good practice to commit changes first to the feature branch
    and then to submit a pull request because we never work directly on the main branch.</st>
    <st c="43726">There are normally also branch policies in place that block developers
    from working directly on the main branch.</st> <st c="43839">On the other hand,
    GitHub workflows can initiate a pull request immediately after creating and committing
    changes to a</st> <st c="43958">feature branch.</st>
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: <st c="43973">We can use exactly the same</st> <st c="44002">approach in conjunction
    with the integration of</st> **<st c="44050">Azure DevOps Services</st>** <st
    c="44071">repositories, pipelines, and</st> **<st c="44101">Power Platform managed
    pipelines</st>** <st c="44133">while</st> <st c="44139">keeping the following
    considerations</st> <st c="44177">in mind:</st>
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44185">Secrets are stored as variables or within variable groups in</st>
    <st c="44247">YAML pipelines.</st>
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="44262">GitHub inputs are mapped to Azure DevOps pipeline variables (</st><st
    c="44324">not parameters).</st>
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="44341">We can use the same Bash scripts as in the case of our GitHub
    workflow.</st> <st c="44414">There is no need to change anything.</st> <st c="44451">Microsoft-hosted
    build agents support Ubuntu</st> <st c="44496">Linux distros.</st>
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="44510">We need to install PowerPlatform Tools by using the Power Platform</st>
    `<st c="44578">build tool</st>` <st c="44588">task (</st>`<st c="44595">PowerPlatformToolInstaller@2</st>`<st
    c="44624">) in the</st> <st c="44634">build agent.</st>
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="44646">We need to use the</st> `<st c="44666">PowerPlatformUnpackSolution@2</st>`
    <st c="44695">task to unpack</st> <st c="44711">the solution.</st>
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="44724">Dataverse with Power Automate cloud flows</st>
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="44766">Having created the DevOps part, let us introduce the</st> <st
    c="44819">Power Automate cloud flow that will react to the</st> `<st c="44869">OnDeploymentCompleted</st>`
    <st c="44890">event in</st> [<st c="44900">the appropriate deployment sta</st>](https://make.powerautomate.com)<st
    c="44930">ge.</st> <st c="44935">We’ll create this cloud flow in the</st> `<st
    c="44971">Pipelinehost</st>` <st c="44983">environment:</st>
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: <st c="44996">Visit</st> [<st c="45003">https://make.powerautomate.com</st>](https://make.powerautomate.com)
    <st c="45033">and select the environment in which our Power Platform</st> <st
    c="45089">pipelines reside.</st>
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="45106">We then go to the</st> **<st c="45125">My Flows</st>** <st c="45133">blade,
    open the</st> **<st c="45150">New Flow</st>** <st c="45158">drop-down menu, and
    click on</st> **<st c="45188">Automated</st>** **<st c="45198">Cloud Flow</st>**<st
    c="45208">.</st>
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="45209">We can name the flow something like</st> `<st c="45246">ManagedPipelineOnDeploymentCompletedFlow</st>`
    <st c="45286">and need to pick</st> **<st c="45304">When an action is performed</st>**
    <st c="45331">from Dataverse as the</st> <st c="45354">trigger condition.</st>
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="45372">After creating the flow, we need to provide the following values
    as the parameters of the</st> <st c="45463">trigger action:</st>
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Dataverse – When an action is performed](img/B22208_05_5.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
- en: <st c="45750">Figure 5.5 – Dataverse – When an action is performed</st>
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45802">Please note that, here, we’re using the service principal to connect
    to the underlying Dataverse, which is</st> *<st c="45910">not</st>* <st c="45913">the
    service principal that we used in the GitHub workflow.</st> <st c="45973">This
    is the service principal that we created in</st> [*<st c="46022">Chapter 4</st>*](B22208_04.xhtml#_idTextAnchor074)<st
    c="46031">, for the</st> *<st c="46041">on-behalf-of</st>* <st c="46053">pipeline
    deployment.</st>
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: <st c="46074">We can use the output data (</st>`<st c="46103">ActionOutputs</st>`
    `<st c="46117">ArtifactName</st>`<st c="46130">,</st> `<st c="46132">ActionOutputs</st>`
    `<st c="46145">DeploymentPipeIineName</st>`<st c="46168">,</st> `<st c="46170">ActionOutputs</st>`
    `<st c="46183">DeploymentStageName</st>`<st c="46203">) of the trigger action
    to introduce multiple conditions to react only on our pipeline (</st>`<st c="46292">PipelineToProd</st>`<st
    c="46307">) and in the final deployment</st> <st c="46338">stage (</st>`<st c="46345">Production</st>`<st
    c="46356">).</st>
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="46359">After</st> <st c="46365">introducing these conditions to limit
    our cloud flow execution only to this managed pipeline, we need to get some additional
    data from the</st> `<st c="46505">DeploymentStageRun</st>` <st c="46523">Dataverse
    table in conjunction with this run (identified by</st> `<st c="46584">StageRunId</st>`<st
    c="46594">).</st> <st c="46598">We use the</st> **<st c="46609">Get</st> <st c="46613">a
    row by ID</st>** <st c="46624">action with the</st> **<st c="46641">Row ID</st>**
    <st c="46647">parameter from the trigger activity to get</st> <st c="46691">this
    information:</st>
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Get a row by ID action](img/B22208_05_6.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: <st c="46949">Figure 5.6 – Get a row by ID action</st>
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: <st c="46984">Finally, we need to call the REST API endpoint of our GitHub workflow.</st>
    <st c="47056">Since these endpoints are</st> <st c="47081">protected, we need
    to create a</st> `<st c="47373">https://api.github.com/repos/[org-name]/[repository]/actions/workflows/downloadunpackcommitbash.yml/dispatches</st>`
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '<st c="47483">HTTP</st> <st c="47489">method: POST</st>'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="47501">Headers</st>
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="47509">We only</st> <st c="47517">define the</st> **<st c="47529">Authorization</st>**
    <st c="47542">header with a bearer token that is exactly the same as our GitHub
    personal access token, as the following</st> <st c="47649">figure shows:</st>
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Authorization header with GitHub access token](img/B22208_05_7.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: <st c="47708">Figure 5.7 – Authorization header with GitHub access token</st>
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: <st c="47766">Please note that we should store the bearer token in an environment
    variable that is backed by the Azure Key</st> <st c="47876">Vault service.</st>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: <st c="47890">The HTTP payload (body) contains the GitHub workflow’s</st> <st
    c="47946">input parameters:</st>
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <st c="48331">The following</st> <st c="48345">figure shows how we apply these
    parameters within the</st> <st c="48400">HTTP action:</st>
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – HTTP action to dispatch a GitHub workflow](img/B22208_05_8.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
- en: <st c="49054">Figure 5.8 – HTTP action to dispatch a GitHub workflow</st>
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: <st c="49108">When everything</st> <st c="49125">comes together, our Power Automate
    cloud flow should contain the following actions and</st> <st c="49212">conditional
    cases:</st>
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – End-to-end cloud flow](img/B22208_05_9.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: <st c="49340">Figure 5.9 – End-to-end cloud flow</st>
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: <st c="49374">With this final step, we have accomplished our original plan to
    save the deployment artifacts of our Power Platform pipeline to a</st> <st c="49505">GitHub
    repository.</st>
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: <st c="49523">To close the loop, we can introduce another Power Automate cloud
    flow that is triggered by the</st> *<st c="49619">committed to main</st>* <st
    c="49636">or</st> *<st c="49640">pull request is submitted</st>* <st c="49665">GitHub
    event via webhooks to track the result of the GitHub workflow dispatch REST API
    call back to our Power Platform</st> *<st c="49785">Pipelinehost</st>* <st c="49797">environment.</st>
    **<st c="49811">Webhooks</st>** <st c="49819">provide a mechanism to register
    HTTP endpoints as event handlers on</st> <st c="49887">other services.</st> <st
    c="49904">In our case, we can register the Power Automate cloud flow as a webhook
    on the GitHub side.</st> <st c="49996">If a well-defined event happens in GitHub,
    GitHub will execute all registered webhooks.</st> <st c="50084">There are already
    GitHub</st> <st c="50109">connectors available for these types of triggers, such
    as the</st> *<st c="50171">When a pull request is created or modified</st>* <st
    c="50213">webhook in the Power Automate</st> <st c="50244">cloud flow.</st>
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: <st c="50255">Last but not least, it is worth having a look at the differences
    when we use Azure DevOps Services instead of GitHub in our Dataverse-triggered</st>
    <st c="50400">cloud flow:</st>
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: <st c="50411">We need to enable the</st> `<st c="50434">Third-party application
    access via OAuth</st>` <st c="50474">checkbox at the organization level under</st>
    **<st c="50516">Organization Settings</st>** <st c="50537">|</st> **<st c="50540">Security</st>**
    <st c="50548">|</st> **<st c="50551">Policies</st>** <st c="50559">|</st> **<st
    c="50562">Application access policies</st>** <st c="50589">in Azure DevOps Services
    to be able to use the available Azure DevOps Services actions in our Power Automate</st>
    <st c="50699">cloud flow</st>
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="50709">We then use the</st> **<st c="50726">Queue a new Build</st>**
    <st c="50743">action under the Azure DevOps connector to execute</st> <st c="50795">the
    pipeline</st>
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="50807">As mentioned earlier, our Azure DevOps pipeline expects the input
    parameters as variables defined in the</st> **<st c="50913">Variable</st>** <st
    c="50921">pane</st>
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="50926">The</st> **<st c="50931">Queue a new build</st>** <st c="50948">action
    passes over the parameters in the</st> <st c="50990">following format:</st>
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: <st c="51346">Awesome job!</st> <st c="51360">We have just learned how we can
    get the two workflow engines to collaborate in order to use the same DevOps principles
    that we apply every day during custom software</st> <st c="51526">development
    projects.</st>
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: <st c="51547">Copilots in Power Platform pipeline development</st>
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="51595">To significantly reduce the pipeline development effort in GitHub
    or Azure DevOps Services, we can leverage the capabilities</st> <st c="51721">of</st>
    **<st c="51724">Large Language Models</st>** <st c="51745">(</st>**<st c="51747">LLMs</st>**<st
    c="51751">) such as GPT-4 and the products built upon those models to support
    developers and DevOps engineers.</st> <st c="51853">One of these products is</st>
    **<st c="51878">GitHub Copilot</st>**<st c="51892">, which</st> <st c="51899">acts
    as a pair programmer, – an assistant that can synthesize code based on natural
    language prompts.</st> <st c="52002">GitHub Copilot integrates into Visual Studio
    Code, Visual Studio, Neovim, and the JetBrains IDE (even in Azure Data Studio)
    and it is also available directly on the</st> <st c="52167">GitHub website.</st>
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: <st c="52182">Using the GitHub Copilot inline editor or</st> <st c="52224">the</st>
    **<st c="52229">GitHub Copilot Chat window</st>**<st c="52255">, we can prompt
    the foundation model to create pipelines that use the build tools to interact
    with our Power Platform environments.</st> <st c="52387">The more precise our
    prompts are, the more accurate GitHub Copilot can synthesize the YAML files.</st>
    <st c="52485">This concept is also referred to</st> <st c="52517">as</st> **<st
    c="52521">prompt engineering</st>**<st c="52539">. Here are some real-world prompts
    for the activities we have carried out in</st> <st c="52616">this chapter:</st>
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="52629">“By using the Microsoft Power Platform build tool, tasks create
    an Azure DevOps pipeline that exports a solution from the Power Platform environment,
    unpacks it, and commits the changes in a new branch</st>* *<st c="52832">under
    main.”</st>*'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="52844">“Create a Bash script that gets an access token from Dataverse
    using AAD app registration and query a Dataverse table</st>* `<st c="52963">DeploymentArtifacts</st>`
    *<st c="52982">row by providing its GUID.” The column with the name “artifactfile”
    shall be</st>* *<st c="53060">downloaded afterward.”</st>*'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*<st c="53082">“By using Power Platform GitHub actions, create a GitHub workflow
    with a trigger condition dispatch that exports a solution from the Power Platform
    environment, unpacks it, and commits the changes in a new branch</st>* *<st c="53296">under
    main.”</st>*'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="53308">If we don’t have access to GitHub Copilot, we can</st> <st c="53359">use</st>
    **<st c="53363">Microsoft Copilot</st>** <st c="53380">(</st>[<st c="53382">https://copilot.microsoft.com</st>](https://copilot.microsoft.com)<st
    c="53411">) with our personal account or other LLMs to get some templates and
    step-by-step instructions on how YAML pipelines should</st> <st c="53535">be constructed.</st>
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: <st c="53550">Copilot is also available in Power Platform to help us in creating
    apps, flows, websites, chatbots, and reports more intuitively by using natural
    language.</st> <st c="53707">In the previous example of a Dataverse-triggered
    workflow, we could use the following prompt in the Power Automate UI</st> <st
    c="53825">in</st> **<st c="53828">Copilot for</st>** **<st c="53840">Power Automate</st>**<st
    c="53854">:</st>
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: <st c="53856">“Create a workflow that is triggered by the “When an action is
    performed” Dataverse action on Power Platform pipelines with the OnDeploymentCompleted
    event.</st> <st c="54013">If the pipeline is “PipelineToProd” and the deployment
    stage is Production, call an HTTP action.”</st>
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: <st c="54110">Copilots will soon become an integral part of our daily work.</st>
    <st c="54173">It’s essential for us to develop these skills and acquire new competencies
    to remain at the forefront</st> <st c="54275">of technology.</st>
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: <st c="54289">Summary</st>
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="54297">In this chapter, we explored the world of Git, the distributed
    version control system, and discovered how to use PAC CLI to export/import and
    unpack Power Platform solutions in Git repositories.</st> <st c="54493">We also
    delved into the inner workings of professional DevOps pipelines and saw how build
    tools such as Azure DevOps tasks and GitHub actions use the underlying PAC CLI
    to perform actions within provider-hosted or</st> <st c="54707">self-hosted agents.</st>
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: <st c="54726">In the second half of the chapter, we combined the Power Platform
    managed pipeline results from</st> [*<st c="54823">Chapter 4</st>*](B22208_04.xhtml#_idTextAnchor074)
    <st c="54832">with professional DevOps tools and achieved a version control integration
    directly from managed pipelines.</st> <st c="54940">To top it all off, we used
    GitHub Copilot and Copilot for Power Automate to generate YAML pipelines and Power
    Automate cloud flows that we had previously</st> <st c="55094">created manually.</st>
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: <st c="55111">But hold on to your hats, because in the next chapter, we will
    go even further and delve into YAML techniques to do some real magic with pipeline
    templates</st>[<st c="55267">, GitHub workflow templates, and AL</st>](https://code.visualstudio.com/learn)<st
    c="55302">M Accelerator for</st> <st c="55321">Power Platform.</st>
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: <st c="55336">Further reading</st>
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[<st c="55352">Learn about Visual Studio</st>](https://github.com/git/git)
    <st c="55379">Code:</st> [<st c="55385">https://code.visualstudio.com/learn</st>](https://code.visualstudio.com/learn)'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="55420">Git open source project – the code base of</st> <st c="55464">Git:</st>
    [<st c="55469">https://github.com/git/git</st>](https://github.com/git/git)
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="55495">GitHub</st> <st c="55503">flow:</st> [<st c="55509">https://docs.github.com/en/get-started/using-github/github-flow</st>](https://docs.github.com/en/get-started/using-github/github-flow)
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="55572">PAC CLI</st> <st c="55581">reference:</st> [<st c="55592">https://learn.microsoft.com/en-us/power-platform/developer/cli/reference/</st>](https://learn.microsoft.com/en-us/power-platform/developer/cli/reference/)
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="55665">Azure Pipelines learning</st> <st c="55691">module:</st> [<st
    c="55699">https://learn.microsoft.com/en-us/training/modules/explore-azure-pipelines/</st>](https://learn.microsoft.com/en-us/training/modules/explore-azure-pipelines/)
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="55774">Integrate Azure</st> <st c="55791">pipelines:</st> [<st c="55802">https://learn.microsoft.com/en-us/training/modules/integrate-azure-pipelines/</st>](https://learn.microsoft.com/en-us/training/modules/integrate-azure-pipelines/)
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="55879">Azure DevOps Demo</st> <st c="55898">Generator:</st> [<st c="55909">https://azuredevopsdemogenerator.azurewebsites.net</st>](https://azuredevopsdemogenerator.azurewebsites.net)
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="55959">GitHub Actions learning</st> <st c="55984">module:</st> [<st c="55992">https://learn.microsoft.com/en-us/training/modules/introduction-to-github-actions/</st>](https://learn.microsoft.com/en-us/training/modules/introduction-to-github-actions/)
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="56074">Implement CI pipelines with Azure DevOps and GitHub</st> <st c="56127">Actions:</st>
    [<st c="56136">https://learn.microsoft.com/en-us/training/paths/az-400-implement-ci-azure-pipelines-github-actions/</st>](https://learn.microsoft.com/en-us/training/paths/az-400-implement-ci-azure-pipelines-github-actions/)
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="56236">Build continuous integration (CI) workflows by using GitHub</st>
    <st c="56297">Actions:</st> [<st c="56306">https://learn.microsoft.com/en-us/training/modules/github-actions-ci/</st>](https://learn.microsoft.com/en-us/training/modules/github-actions-ci/)
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="56375">Microsoft Power Platform Build Tools for Azure DevOps</st> <st
    c="56430">Services:</st> [<st c="56440">https://learn.microsoft.com/en-us/power-platform/alm/devops-build-tools</st>](https://learn.microsoft.com/en-us/power-platform/alm/devops-build-tools)
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="56511">GitHub Actions for Microsoft Power</st> <st c="56547">Platform:</st>
    [<st c="56557">https://learn.microsoft.com/en-us/power-platform/alm/devops-github-actions</st>](https://learn.microsoft.com/en-us/power-platform/alm/devops-github-actions)
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="56631">GitHub repository for Power Platform build</st> <st c="56675">tools:</st>
    [<st c="56682">https://github.com/microsoft/powerplatform-build-tools</st>](https://github.com/microsoft/powerplatform-build-tools)
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="56736">Azure Pipelines agent source</st> <st c="56766">code:</st> [<st
    c="56772">https://github.com/microsoft/azure-pipelines-agent</st>](https://github.com/microsoft/azure-pipelines-agent)
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="56822">GitHub runner source</st> <st c="56844">code:</st> [<st c="56850">https://github.com/actions/runner/tree/main/src</st>](https://github.com/actions/runner/tree/main/src)
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="56897">Pipeline Integration with</st> <st c="56924">GitHub:</st> [<st
    c="56932">https://learn.microsoft.com/en-us/power-platform/alm/extend-pipelines-github-export</st>](https://learn.microsoft.com/en-us/power-platform/alm/extend-pipelines-github-export)
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="57015">Dataverse Web</st> <st c="57030">API:</st> `<st c="57035">https://learn.microsoft.com/en-us/power-apps/developer/data-platform/webapi/overview</st>`
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="57119">GitHub Invoke REST</st> <st c="57139">API:</st> [<st c="57144">https://docs.github.com/en/rest/actions/workflows?apiVersion=2022-11-28#create-a-workflow-dispatch-event</st>](https://docs.github.com/en/rest/actions/workflows?apiVersion=2022-11-28#create-a-workflow-dispatch-event)
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="57248">GitHub Secret</st> <st c="57263">Management:</st> [<st c="57275">https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions</st>](https://docs.github.com/en/actions/security-guides/using-secrets-in-github-actions)
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="57357">GitHub Personal Access</st> <st c="57381">Tokens:</st> [<st c="57389">https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens</st>](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens)
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="57504">Power Platform GitHub</st> <st c="57527">Connectors:</st> [<st
    c="57539">https://learn.microsoft.com/en-us/connectors/github/</st>](https://learn.microsoft.com/en-us/connectors/github/)
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="57591">Application Connection Policies in Azure DevOps</st> <st c="57640">Services:</st>
    [<st c="57650">https://learn.microsoft.com/en-us/azure/devops/organizations/accounts/change-application-access-policies?view=azure-devops</st>](https://learn.microsoft.com/en-us/azure/devops/organizations/accounts/change-application-access-policies?view=azure-devops)
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="57772">Prompt engineering with GitHub</st> <st c="57804">Copilot:</st>
    [<st c="57813">https://learn.microsoft.com/en-us/training/modules/introduction-prompt-engineering-with-github-copilot/</st>](https://learn.microsoft.com/en-us/training/modules/introduction-prompt-engineering-with-github-copilot/)
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="57916">OpenAI Prompt</st> <st c="57931">Engineering:</st> [<st c="57944">https://platform.openai.com/docs/guides/prompt-engineering</st>](https://platform.openai.com/docs/guides/prompt-engineering)
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
