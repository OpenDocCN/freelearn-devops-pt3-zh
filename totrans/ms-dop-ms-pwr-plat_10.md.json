["```\n     pac solution create-settings --solution-zip <solution-file.zip> --solution-folder <unpacked-solution-folder> --settings-file <JSON-file-name>\n    <st c=\"18445\">deploymentSettings.json</st> file in the current folder.\n    ```", "```\n     pac solution import --path <path_to_zip_file> --settings-file .\\deploymentSettings.json\n    ```", "```\n - task: PowerPlatformToolInstaller@2\n  inputs:\n    DefaultVersion: true\n    AddToolsToPath: true\n```", "```\n - task: CmdLine@2\n  inputs:\n    script: |\n      echo 'Create Deployment Settings File'\n      pac solution create-settings --solution-zip '$(Build.ArtifactStagingDirectory)/$(SolutionName).zip' --settings-file '$(SolutionName).json'\n```", "```\n - task: PowerPlatformImportSolution@2\n  inputs:\n    authenticationType: 'PowerPlatformSPN'\n    PowerPlatformSPN: '<PP-SPN>'\n    SolutionInputFile: '$(Build.ArtifactStagingDirectory)/$(SolutionName).zip'\n    UseDeploymentSettingsFile: true\n    DeploymentSettingsFile: '$(SolutionName).json'\n    AsyncOperation: true\n    MaxAsyncWaitTime: '60'\n```", "```\n pac pcf init --name <COMPONENT_NAME> --namespace <COMPONENT_NAMESPACE> --template <COMPONENT_TYPE> --framework <RENDERING_FRAMEWORK> -npm\n```", "```\n pac pcf init --name SimpleReactPCF --namespace SimpleReactNS --template field --framework react -npm\n```", "```\n <control namespace=\"SimpleReactNS\" constructor=\"SimpleReactPCF\" version=\"0.0.1\" display-name-key=\"SimpleReactPCF\" description-key=\"SimpleReactPCF description\" <st c=\"46461\">property</st> node, where we can have multiple properties for our code components.\n\t\t\t<st c=\"46538\">We will change the property from</st> `<st c=\"46572\">SingleLine.Text</st>` <st c=\"46587\">to a number (</st>`<st c=\"46601\">Whole.None</st>`<st c=\"46612\">) by changing the</st> <st c=\"46631\">highlighted property:</st>\n\n```", "```\n\n\t\t\t<st c=\"46814\">During this step, extensive coding may be done to develop the PCF component.</st> <st c=\"46892\">Making changes to the code of the component requires knowledge of TypeScript</st> <st c=\"46969\">and React.</st>\n\t\t\t<st c=\"46979\">Debugging a developed code component</st>\n\t\t\t<st c=\"47016\">With a simple</st> `<st c=\"47031\">npm start watch</st>` <st c=\"47046\">command, we can run the project in debugging mode, which opens</st> <st c=\"47110\">a browser with our local PCF</st> <st c=\"47139\">test environment.</st> <st c=\"47157\">On the right side of the test application, we can see all the configured data properties that are specified in the manifest file, as shown in</st> *<st c=\"47299\">Figure 10</st>**<st c=\"47308\">.11</st>*<st c=\"47311\">. Here we can adjust the values of the properties and check whether the state of the code component reflects the</st> <st c=\"47424\">desired behavior.</st>\n\t\t\t<st c=\"47441\">Additionally, we</st> <st c=\"47458\">can use the test environment</st> <st c=\"47487\">to understand how our code component adjusts to different screen sizes.</st> <st c=\"47560\">We can use the</st> **<st c=\"47575\">Form Factor</st>** <st c=\"47586\">settings as well as</st> **<st c=\"47607\">Component Container Width</st>** <st c=\"47632\">and</st> **<st c=\"47637\">Co</st><st c=\"47639\">mponent Container Height</st>** <st c=\"47664\">to adjust the</st> <st c=\"47679\">screen size:</st>\n\t\t\t![Figure 10.11 – The PCF test environment](img/B22208_10_11.jpg)\n\n\t\t\t<st c=\"47867\">Figure 10.11 – The PCF test environment</st>\n\t\t\t<st c=\"47906\">Packaging the code component</st>\n\t\t\t<st c=\"47935\">Code components can</st> <st c=\"47956\">be added to solutions to enable reusability across environments.</st> <st c=\"48021\">If we already have solutions available, we can simply upload the code component to the solution using the</st> `<st c=\"48127\">pac pcf push</st>` <st c=\"48139\">command, as shown in the next section.</st> <st c=\"48179\">In other cases, we can utilize a set of commands to first create a solution and then add a reference to</st> <st c=\"48283\">that solution.</st>\n\t\t\t<st c=\"48297\">We will be adding a reference for our code component project to a newly created solution project.</st> <st c=\"48396\">The solution project (</st>`<st c=\"48418\">cdsproj</st>`<st c=\"48426\">) can contain multiple code component references, while the code component project can only contain a single code component.</st> <st c=\"48552\">Adding references to multiple code components within a single solution project allows us to reference all the code components required for a particular business solution.</st> <st c=\"48723\">They can also be packaged together with other solution objects</st> <st c=\"48786\">if needed.</st>\n\t\t\t<st c=\"48796\">First, we will initialize a solution using the</st> <st c=\"48844\">following command:</st>\n\n```", "```\n\n\t\t\t<st c=\"48880\">Then we will add a reference to the code</st> <st c=\"48922\">component project:</st>\n\n```", "```\n\n\t\t\t<st c=\"49001\">This will create a reference inside the</st> `<st c=\"49042\">.cdsproj</st>` <st c=\"49050\">file,</st> <st c=\"49057\">like this:</st>\n\n```", "```\n\n\t\t\t<st c=\"49148\">When we are ready to generate a ZIP file from the solution project, we can use</st> <st c=\"49228\">the following:</st>\n\n```", "```\n\n\t\t\t<st c=\"49273\">This will restore all code component projects that are referenced in the solution project and build the project.</st> <st c=\"49387\">The final outcome of the process is a ZIP package artifact that can be imported with the code components solutions.</st> <st c=\"49503\">Such a solution can now be imported into the</st> <st c=\"49548\">downstream environment.</st>\n\t\t\t<st c=\"49571\">If we have a</st> <st c=\"49585\">business application in another solution that is referencing our code components, we need to make sure that the solution with the code components is deployed to the environment first, before importing the business application that</st> <st c=\"49816\">references them.</st>\n\t\t\t<st c=\"49832\">Importing the solution into Power Platform</st>\n\t\t\t<st c=\"49875\">Importing the solution into</st> <st c=\"49903\">Power Platform (Dataverse) can be done manually using the Power Platform web portal or the</st> `<st c=\"49995\">pac pcf push</st>` <st c=\"50007\">command.</st> <st c=\"50017\">It can also be done automatically using Power Platform Build Tools and the DevOps tool of choice.</st> <st c=\"50115\">In the next section, we will take a look at how this can be done automatically.</st> <st c=\"50195\">In this section, we will complete the</st> <st c=\"50233\">process manually.</st>\n\t\t\t<st c=\"50250\">First, we should make sure that we are in the right Dataverse environment.</st> <st c=\"50326\">To select the right environment, we can proceed with</st> `<st c=\"50379\">pac env list</st>` <st c=\"50391\">and</st> `<st c=\"50396\">pac env select -env <ENVIRONMENT_ID></st>`<st c=\"50432\">. After confirming the environment, we can proceed with the</st> `<st c=\"50492\">push</st>` <st c=\"50496\">command.</st>\n\t\t\t<st c=\"50505\">It is worth noting that the</st> `<st c=\"50534\">pac pcf push</st>` <st c=\"50546\">command also has a</st> `<st c=\"50566\">-env</st>` <st c=\"50570\">setting, which allows us to push to a selected environment if we are operating across</st> <st c=\"50657\">multiple environments.</st>\n\t\t\t<st c=\"50679\">As we are</st> <st c=\"50689\">still in the folder of our code component, we can run the command, in which we can either use a publisher prefix from our environment or the unique name of our solution.</st> <st c=\"50860\">In both cases, the PAC CLI will check whether the publisher or solution already exists.</st> <st c=\"50948\">If it does, it will use it to push the component – here is</st> <st c=\"51007\">one option:</st>\n\n```", "```\n\n\t\t\t<st c=\"51069\">Here is</st> <st c=\"51078\">the other:</st>\n\n```", "```\n\n\t\t\t<st c=\"51124\">Without the name of the solution, this code component will be imported to a temporary</st> `<st c=\"51211\">PowerAppsTools_<prefix></st>` <st c=\"51234\">solution.</st>\n\t\t\t<st c=\"51244\">Preparing the component for release</st>\n\t\t\t<st c=\"51280\">When preparing our</st> <st c=\"51299\">code component for release to the production environment, we should add the</st> `<st c=\"51376\"><PcfBuildMode>production</PcfBuildMode></st>` <st c=\"51415\">property inside the</st> `<st c=\"51436\">pcfproj</st>` <st c=\"51443\">file underneath</st> `<st c=\"51460\">OutputPath</st>`<st c=\"51470\">, as in the</st> <st c=\"51482\">following example:</st>\n\n```", "```\n\n\t\t\t<st c=\"51719\">Development mode produces a larger bundle that holds debugging information, which might impact performance in production.</st> <st c=\"51842\">This is why the change should be made to the</st> `<st c=\"51887\">pcfproj</st>` <st c=\"51894\">file before building and deploying</st> <st c=\"51930\">to production.</st>\n\t\t\t<st c=\"51944\">Additionally, when</st> <st c=\"51964\">preparing the solution project,</st> `<st c=\"51996\">SolutionPackagerType</st>`<st c=\"52016\">, which is part of</st> `<st c=\"52035\">PropertyGroup</st>` <st c=\"52048\">in the</st> `<st c=\"52056\">cdsproj</st>` <st c=\"52063\">file, defines the solution type, stating whether we would like to go for managed, unmanaged, or both</st> <st c=\"52165\">solution types:</st>\n\n```", "```\n\n\t\t\t<st c=\"52264\">When running the</st> `<st c=\"52282\">dotnet build</st>` <st c=\"52294\">command, this information will be taken to generate a ZIP file of the defined solution type.</st> <st c=\"52388\">When we are preparing for release to production, we can use</st> `<st c=\"52448\">dotnet build /p:configuration=Release</st>` <st c=\"52485\">to create a release build for the selected</st> <st c=\"52529\">solution type.</st>\n\t\t\t<st c=\"52543\">Adding code components to applications</st>\n\t\t\t<st c=\"52582\">Code components can be used across canvas applications, model-driven apps, and websites.</st> <st c=\"52672\">The following are some examples of adding components</st> <st c=\"52725\">to apps.</st>\n\t\t\t<st c=\"52733\">Model-driven apps</st>\n\t\t\t<st c=\"52751\">Adding components to</st> <st c=\"52773\">model-driven apps</st> <st c=\"52790\">is</st> <st c=\"52794\">very easy:</st>\n\n\t\t\t\t1.  <st c=\"52804\">When editing the form, click on</st> **<st c=\"52837\">Components</st>** <st c=\"52847\">in the left navigation bar and click</st> **<st c=\"52885\">Get</st>** **<st c=\"52889\">more components</st>**<st c=\"52904\">.</st>\n\t\t\t\t2.  <st c=\"52905\">This will</st> <st c=\"52915\">open a</st> **<st c=\"52923\">Get more components</st>** <st c=\"52942\">sidebar, where newly created code components will appear.</st> <st c=\"53001\">Select the</st> <st c=\"53012\">necessary components and click</st> **<st c=\"53043\">Add</st>**<st c=\"53046\">, as can be seen in</st> *<st c=\"53066\">Figure 10</st>**<st c=\"53075\">.12</st>*<st c=\"53078\">:</st>\n\n\t\t\t![Figure 10.12 – Adding code component to a form in a model-driven app](img/B22208_10_12.jpg)\n\n\t\t\t<st c=\"53866\">Figure 10.12 – Adding code component to a form in a model-driven app</st>\n\n\t\t\t\t1.  <st c=\"53934\">After adding the code components to the list of components, they appear under the</st> **<st c=\"54017\">More components</st>** <st c=\"54032\">group inside the</st> **<st c=\"54050\">Components</st>** <st c=\"54060\">option.</st> <st c=\"54069\">Simply drag and drop the components to the right places in the form and connect the component values with the</st> <st c=\"54179\">correct values.</st>\n\n\t\t\t<st c=\"54194\">Canvas apps</st>\n\t\t\t<st c=\"54206\">Adding code</st> <st c=\"54219\">components to</st> <st c=\"54233\">canvas applications has to be enabled before it’s possible.</st> <st c=\"54293\">The setting for enabling it is currently available in the Power Platform</st> <st c=\"54366\">admin center:</st>\n\n\t\t\t\t1.  <st c=\"54379\">Go to</st> **<st c=\"54386\">Environments</st>**<st c=\"54398\">, select the environment, and then click</st> **<st c=\"54439\">Settings</st>** <st c=\"54447\">|</st> **<st c=\"54450\">Product</st>** <st c=\"54457\">|</st> **<st c=\"54460\">Features</st>**<st c=\"54468\">.</st>\n\t\t\t\t2.  <st c=\"54469\">Here we will find the</st> **<st c=\"54492\">Power Apps component framework for canvas apps</st>** <st c=\"54538\">setting, which is turned off by default.</st> <st c=\"54580\">If needed,</st> <st c=\"54591\">enable it.</st>\n\t\t\t\t3.  <st c=\"54601\">Once done, we can</st> <st c=\"54619\">go to our canvas application and click</st> **<st c=\"54659\">Insert</st>** <st c=\"54665\">to see a list of all controls.</st> <st c=\"54697\">Then we can proceed to the</st> **<st c=\"54724\">Code</st>** <st c=\"54728\">tab, sele</st><st c=\"54738\">ct</st> <st c=\"54742\">the components, and click</st> **<st c=\"54768\">Import</st>**<st c=\"54774\">, as shown in</st> *<st c=\"54788\">Figure 10</st>**<st c=\"54797\">.13</st>*<st c=\"54800\">.</st>\n\n\t\t\t![Figure 10.13 – Adding a code component to the canvas app](img/B22208_10_13.jpg)\n\n\t\t\t<st c=\"55336\">Figure 10.13 – Adding a code component to the canvas app</st>\n\t\t\t<st c=\"55392\">Power Pages</st>\n\t\t\t<st c=\"55404\">Adding code components to</st> <st c=\"55431\">Power Pages</st> <st c=\"55442\">is similar to the process of doing so for</st> <st c=\"55485\">model-driven apps:</st>\n\n\t\t\t\t1.  <st c=\"55503\">Your components can be found by going to</st> **<st c=\"55545\">Data</st>** <st c=\"55549\">in the left</st> <st c=\"55562\">navigation bar.</st>\n\t\t\t\t2.  <st c=\"55577\">Select the table of choice, click</st> **<st c=\"55612\">Forms</st>** <st c=\"55617\">(or</st> **<st c=\"55622\">V</st><st c=\"55623\">iews</st>**<st c=\"55627\">, depending on the use case), and click</st> **<st c=\"55667\">Get</st>** **<st c=\"55671\">more components</st>**<st c=\"55686\">.</st>\n\n\t\t\t![Figure 10.14 – Adding code components in Power Pages](img/B22208_10_14.jpg)\n\n\t\t\t<st c=\"56268\">Figure 10.14 – Adding code components in Power Pages</st>\n\n\t\t\t\t1.  <st c=\"56320\">This will open a</st> <st c=\"56337\">sidebar to help you find a custom</st> <st c=\"56372\">code component.</st> <st c=\"56388\">Select the one you require and click</st> **<st c=\"56425\">Add</st>**<st c=\"56428\">, as can be seen in</st> *<st c=\"56448\">Figure 10</st>**<st c=\"56457\">.14.</st>*\n\n\t\t\t<st c=\"56461\">Now that we have learned how code components are created and added to an application, let’s understand how the application life cycle is managed for</st> <st c=\"56611\">these components.</st>\n\t\t\t<st c=\"56628\">ALM for code components</st>\n\t\t\t<st c=\"56652\">As we saw in the</st> <st c=\"56670\">previous section, the development life cycle of a code component consists of the</st> <st c=\"56751\">following steps:</st>\n\n\t\t\t\t1.  <st c=\"56767\">The initialization of the</st> <st c=\"56794\">PCF project</st>\n\t\t\t\t2.  <st c=\"56805\">Working on the code</st> <st c=\"56826\">component’s implementation</st>\n\t\t\t\t3.  <st c=\"56852\">Testing/local debugging of the developed code component and pushing it to the Power Platform</st> <st c=\"56946\">development environment</st>\n\t\t\t\t4.  <st c=\"56969\">Adding the component project reference to the solution in the</st> <st c=\"57032\">development environment</st>\n\t\t\t\t5.  <st c=\"57055\">Testing the business solution with the included</st> <st c=\"57104\">code components</st>\n\t\t\t\t6.  <st c=\"57119\">Preparing the code component</st> <st c=\"57149\">for release</st>\n\t\t\t\t7.  <st c=\"57160\">Importing the solution to other environments</st> <st c=\"57206\">and testing</st>\n\n\t\t\t<st c=\"57217\">We recommend building automated pipelines by leveraging Power Platform Build Tools in Azure DevOps or GitHub, together with the PAC CLI, to perform these</st> <st c=\"57372\">tasks automatically.</st>\n\t\t\t<st c=\"57392\">As with any other development project, when developing code components, it is also recommended that developers use a source code repository, such as GitHub or Azure DevOps, from the beginning, in which to collaborate.</st> <st c=\"57611\">Using</st> `<st c=\"57617\">pac pcf init</st>` <st c=\"57629\">also creates a</st> `<st c=\"57645\">.gitignore</st>` <st c=\"57655\">file, which instructs the version control system as to which files and folders should be left out since they will be either created or restored during the</st> <st c=\"57811\">build process.</st>\n\t\t\t<st c=\"57825\">It is worth noting that when we have a code component in a solution, we can export the solution together with the code component using Power Platform Build Tools or</st> `<st c=\"57991\">SolutionPackager /action: Extract</st>`<st c=\"58024\">, which incrementally exports changes to the solution metadata.</st> <st c=\"58088\">When a code component is extracted from a solution package, a</st> `<st c=\"58150\">Controls</st>` <st c=\"58158\">subfolder will be created for each code component that is included in</st> <st c=\"58229\">the solution.</st>\n\t\t\t<st c=\"58242\">Using</st> `<st c=\"58249\">pac pcf push</st>` <st c=\"58261\">to push a</st> <st c=\"58271\">code component to an environment, and then using commands such as</st> `<st c=\"58338\">msbuild</st>` <st c=\"58345\">and</st> `<st c=\"58350\">SolutionPackage /action: Pack</st>` <st c=\"58379\">to build a solution, allows us to build and repack the solution and make it ready</st> <st c=\"58462\">for import.</st>\n\t\t\t<st c=\"58473\">Solution strategy for code components</st>\n\t\t\t<st c=\"58511\">Another consideration</st> <st c=\"58533\">with code components is the solution strategy.</st> <st c=\"58581\">As we have learned, our business applications can have dependencies on various solution components.</st> <st c=\"58681\">Power Platform allows us to deploy components together, as part of</st> <st c=\"58747\">a</st> **<st c=\"58750\">single solution</st>**<st c=\"58765\">, or separately, in</st> **<st c=\"58785\">segmented solutions</st>**<st c=\"58804\">, where</st> <st c=\"58811\">functionalities of our business applications are split between</st> <st c=\"58875\">multiple solutions.</st>\n\t\t\t<st c=\"58894\">The segmented approach allows us to be more agile with the development approach of our business solution.</st> <st c=\"59001\">Teams can each focus on their own parts of the business solution and can develop and test independently of the final solution.</st> <st c=\"59128\">Such an approach allows us to decouple and share code components between multiple applications and across environments.</st> <st c=\"59248\">Single solutions have everything in one solution, which means that it is important to follow a good branching strategy if you want to have control over updates to the</st> <st c=\"59415\">complete solution.</st>\n\t\t\t<st c=\"59433\">Versioning and updates to code components</st>\n\t\t\t<st c=\"59475\">Whenever we</st> <st c=\"59487\">deliver changes to our code components that should be</st> <st c=\"59542\">pushed to our business applications, we should make sure that we follow the standard versioning strategy (</st>`<st c=\"59648\">MAJOR.MINOR.PATCH</st>`<st c=\"59666\">), which will ensure that Power Apps applications detect and update dependencies to the</st> <st c=\"59755\">latest version.</st>\n\t\t\t<st c=\"59770\">Inside the manifest file (</st>`<st c=\"59797\">ControlManifest.Input.Xml</st>`<st c=\"59823\">), under the</st> `<st c=\"59837\">control</st>` <st c=\"59844\">element, there is a</st> `<st c=\"59865\">version</st>` <st c=\"59872\">property that should get at least a</st> `<st c=\"59909\">PATCH</st>` <st c=\"59914\">version increase whenever an update to a code component is deployed.</st> <st c=\"59984\">This will ensure that the change can be detected and that both canvas and model-driven apps will receive the latest version of</st> <st c=\"60111\">the component:</st>\n\n```", "```\n\n\t\t\t<st c=\"60309\">An increase of the version can be done manually by changing the number in the manifest file, or it can be done automatically with the</st> <st c=\"60444\">following command:</st>\n\n```", "```\n\n\t\t\t<st c=\"60498\">There are also other strategies, such as</st> `<st c=\"60540\">gittags</st>`<st c=\"60547\">; however, the manifest strategy is by far the simplest, since it does</st> <st c=\"60619\">everything automatically.</st>\n\t\t\t<st c=\"60644\">If we would like to specify the exact value of a version, we can do</st> <st c=\"60713\">the following:</st>\n\n```", "```\n\n\t\t\t`<st c=\"60774\">MAJOR</st>` <st c=\"60780\">and</st> `<st c=\"60785\">MINOR</st>` <st c=\"60790\">versions</st> <st c=\"60799\">should be aligned with the version of our</st> <st c=\"60841\">Dataverse solution.</st> <st c=\"60862\">If a significant change is made to a solution, then the</st> `<st c=\"60918\">MAJOR</st>` <st c=\"60923\">and/or</st> `<st c=\"60931\">MINOR</st>` <st c=\"60936\">version of the Dataverse solution should be incremented, which should lead also to incrementing the</st> `<st c=\"61037\">MAJOR</st>` <st c=\"61042\">and/or</st> `<st c=\"61050\">MINOR</st>` <st c=\"61055\">version of the</st> <st c=\"61071\">code component.</st>\n\t\t\t<st c=\"61086\">Code component updates for canvas apps</st>\n\t\t\t<st c=\"61125\">In order to update a code component to a newer version inside canvas applications, app makers must open the canvas app in Power Apps Studio and click</st> **<st c=\"61276\">Update</st>** <st c=\"61282\">on the</st> **<st c=\"61290\">Update code components</st>** <st c=\"61312\">popup.</st> <st c=\"61320\">If the update is not done, then the canvas app will continue to use the old version of the</st> <st c=\"61411\">code component.</st>\n\t\t\t<st c=\"61426\">Automated build pipelines for segmented solutions</st>\n\t\t\t<st c=\"61476\">To create a code</st> <st c=\"61493\">component from scratch and keep control over it, we start by creating the code component locally and committing the changes to the</st> <st c=\"61625\">Git repository:</st>\n\n\t\t\t\t1.  <st c=\"61640\">Using the</st> `<st c=\"61651\">pac pcf init</st>` <st c=\"61663\">command, we will create a</st> `<st c=\"61690\">pcfproj</st>` <st c=\"61697\">folder.</st> <st c=\"61706\">Once the project is created, we will be committing the changes to the Git repository.</st> <st c=\"61792\">Using</st> `<st c=\"61798\">pac pcf push</st>`<st c=\"61810\">, we will deploy our code component to</st> <st c=\"61849\">the environment.</st>\n\t\t\t\t2.  <st c=\"61865\">Separately, we will be creating a solution project using</st> `<st c=\"61923\">pac solution init</st>`<st c=\"61940\">, to create a new blank solution, or</st> `<st c=\"61977\">pac solution clone</st>`<st c=\"61995\">, if we already have a solution that we would like to reuse.</st> <st c=\"62056\">The solution is also version-controlled in the</st> <st c=\"62103\">Git repository.</st>\n\t\t\t\t3.  <st c=\"62118\">Next, we need to add a reference to the solution using the</st> `<st c=\"62178\">pac solution add-reference</st>` <st c=\"62204\">command with the path to our PCF</st> <st c=\"62238\">component project.</st>\n\t\t\t\t4.  <st c=\"62256\">Now we need to update the solution version in</st> `<st c=\"62303\">Solution.xml</st>` <st c=\"62315\">to reflect the version of the current build.</st> <st c=\"62361\">This can be done by formulating the</st> `<st c=\"62397\">MAJOR.MINOR.BUILD.REVISION</st>` <st c=\"62423\">version with the variables in Azure DevOps/GitHub.</st> <st c=\"62475\">For</st> `<st c=\"62479\">MAJOR</st>`<st c=\"62484\">, we can create</st> `<st c=\"62500\">$(majorVersion)</st>` <st c=\"62515\">variables; for</st> `<st c=\"62531\">MINOR</st>`<st c=\"62536\">, we can create</st> `<st c=\"62552\">$(minorVersion)</st>` <st c=\"62567\">variables; for</st> `<st c=\"62583\">BUILD</st>`<st c=\"62588\">, we can use the predefined</st> `<st c=\"62616\">$(Build.BuildId)</st>`<st c=\"62632\">; and for</st> `<st c=\"62643\">REVISION</st>`<st c=\"62651\">, we can</st> <st c=\"62660\">use</st> `<st c=\"62664\">$(Rev:r)</st>`<st c=\"62672\">.</st>\n\t\t\t\t5.  <st c=\"62673\">We will also need to change the version value</st> <st c=\"62720\">inside</st> `<st c=\"62727\">ControlManifest.Input.xml</st>`<st c=\"62752\">.</st>\n\t\t\t\t6.  <st c=\"62753\">Once the version numbers are updated, we can run a task, as part of our build pipeline, using the</st> `<st c=\"62852\">dotnet build /restore /p:configuration=Release</st>` <st c=\"62898\">command (or</st> `<st c=\"62911\">msbuild</st>`<st c=\"62918\">, depending on what tools are we using).</st> <st c=\"62959\">We</st> <st c=\"62962\">configure the task in a way that means it builds only the</st> `<st c=\"63020\">cdsproj</st>` <st c=\"63027\">project.</st> <st c=\"63037\">We can achieve this by setting the</st> `<st c=\"63072\">*.</st>``<st c=\"63074\">cdsproj</st>` <st c=\"63082\">wildcard.</st>\n\n\t\t\t<st c=\"63092\">Once the build has been completed, we will store the produced ZIP file in the pipeline release artifact using a</st> **<st c=\"63205\">Copy file</st>** <st c=\"63214\">task, which can be used for deployment.</st> <st c=\"63255\">The deployment process is the same as with other solution</st> <st c=\"63313\">import processes.</st>\n\t\t\t<st c=\"63330\">Automated build pipelines for single mixed solutions</st>\n\t\t\t<st c=\"63383\">The single</st> <st c=\"63395\">mixed solutions approach needs to be configured in the solution object explorer, where all the required solution components are added.</st> <st c=\"63530\">Then, we utilize</st> `<st c=\"63547\">SolutionPackager /action: Extract</st>` <st c=\"63580\">to extract the components into the source control system.</st> <st c=\"63639\">Just as earlier, we need to update the solution version in</st> `<st c=\"63698\">Solution.xml</st>` <st c=\"63710\">to reflect the version of the current build.</st> <st c=\"63756\">We also need to change the version value</st> <st c=\"63797\">inside</st> `<st c=\"63804\">ControlManifest.Input.xml</st>`<st c=\"63829\">.</st>\n\t\t\t<st c=\"63830\">We will add a task to the pipeline called</st> **<st c=\"63873\">Power Platform</st>** **<st c=\"63888\">Tool Installer</st>**<st c=\"63902\">.</st>\n\t\t\t<st c=\"63903\">Next, we will restore</st> `<st c=\"63926\">node_modules</st>` <st c=\"63938\">using</st> `<st c=\"63945\">npm task</st>` <st c=\"63953\">with the</st> `<st c=\"63963\">npm ci</st>` <st c=\"63969\">command.</st> <st c=\"63979\">For the production release mode, we will use</st> `<st c=\"64024\">npm task</st>` <st c=\"64032\">with a custom command parameter:</st> `<st c=\"64066\">npm run build -- --buildMode release</st>`<st c=\"64102\">. The output of the build needs to be stored separately in a folder.</st> <st c=\"64171\">Then we will use a</st> `<st c=\"64227\">SolutionPackager /action: Pack</st>` <st c=\"64257\">to package the files and collect the</st> <st c=\"64294\">built solution ZIP in the</st> <st c=\"64321\">pipeline artifact.</st>\n\t\t\t<st c=\"64339\">More information on ALM for PCF components</st>\n\t\t\t<st c=\"64382\">To support this section, we recommend visiting the documentation on ALM for PCF components</st> <st c=\"64473\">here:</st> [<st c=\"64480\">https://learn.microsoft.com/en-us/power-apps/developer/component-framework/code-components-alm</st>](https://learn.microsoft.com/en-us/power-apps/developer/component-framework/code-components-alm)<st c=\"64574\">.</st>\n\t\t\t<st c=\"64575\">We have mentioned many times that code components can also be used with Power Pages.</st> <st c=\"64661\">Since Power Pages allows developers to extend websites greatly with custom code, it is important to take a look at how we can apply ALM to</st> <st c=\"64800\">Power Pages.</st>\n\t\t\t<st c=\"64812\">ALM for Power Pages</st>\n\t\t\t<st c=\"64832\">Power Pages allows</st> <st c=\"64852\">app makers and professional developers to build engaging, scalable, and secure websites.</st> <st c=\"64941\">Since Power Pages websites are built using the HTML, CSS, JavaScript, and Liquid templating languages, developers can follow common web development practices and use known tools, such as Visual Studio Code.</st> <st c=\"65148\">Once changes are made to their websites, developers should follow a process of committing those changes to the repository and applying them to different environments.</st> <st c=\"65315\">This section focuses on describing how ALM is applied to Power Pages websites.</st> <st c=\"65394\">We will take a look at how Power Platform pipelines enable easier and faster configuration of deployment pipelines and how to use Power Platform Build Tools in Azure DevOps to create the pipelines necessary for exporting and importing solutions into</st> <st c=\"65644\">different environments.</st>\n\t\t\t<st c=\"65667\">Power Pages was previously known as Power Apps Portals.</st> <st c=\"65724\">The older data model, known also as the standard data model, used custom tables to store the configurations of Power Apps Portals websites.</st> <st c=\"65864\">As configurations were stored separately, this prevented us from using solutions as was possible with other Power Platform services.</st> <st c=\"65997\">However, in the second half of 2023, Microsoft introduced a new and enhanced data model that was built on system tables, non-config tables, and virtual tables.</st> <st c=\"66157\">This new approach allows us to contain website configurations in solutions, which simplifies the</st> <st c=\"66254\">ALM approach.</st>\n\t\t\t<st c=\"66267\">Information about each site, including whether it uses the enhanced or standard data model, can be found inside the</st> **<st c=\"66384\">Site details</st>** <st c=\"66396\">|</st> **<st c=\"66399\">Data model</st>** <st c=\"66409\">setting for each website in Power Pages.</st> <st c=\"66451\">The same website information can also be found on</st> **<st c=\"66501\">Power Platform Admin center</st>** <st c=\"66528\">|</st> **<st c=\"66531\">Resources</st>** <st c=\"66540\">|</st> **<st c=\"66543\">Power Pages sites</st>**<st c=\"66560\">, where you can select a site and then click</st> **<st c=\"66605\">Manage</st>**<st c=\"66611\">. The information about the data model is found under</st> **<st c=\"66665\">Site Details</st>**<st c=\"66677\">.</st>\n\t\t\t<st c=\"66678\">Migrating from the standard model to the enhanced data model</st>\n\t\t\t<st c=\"66739\">Although all newly created sites in Power Pages use the enhanced data model by default, you might still come across legacy Power Pages websites that are built on the standard data model.</st> <st c=\"66927\">Customers who have websites that use the previous data model should consider migrating their websites to the new model.</st> <st c=\"67047\">The enhanced data model provides benefits over the standard one, such as faster website provisioning, solution support,</st> <st c=\"67167\">and ALM.</st>\n\t\t\t<st c=\"67175\">Microsoft has introduced a migration guide that helps customers to migrate from one data model to the</st> <st c=\"67278\">other:</st> [<st c=\"67285\">https://learn.microsoft.com/en-us/power-pages/admin/migrate-enhanced-data-model</st>](https://learn.microsoft.com/en-us/power-pages/admin/migrate-enhanced-data-model)<st c=\"67364\">.</st>\n\t\t\t<st c=\"67365\">Now that we’ve had a short introduction to Power Pages, we can take a look at how the PAC CLI can support website life</st> <st c=\"67485\">cycle management.</st>\n\t\t\t<st c=\"67502\">Use of the PAC CLI for Power Pages</st>\n\t\t\t<st c=\"67537\">The PAC CLI offers tools for</st> <st c=\"67566\">managing the configuration of Power Pages websites, which includes downloading and uploading website content from and to</st> <st c=\"67688\">Power Pages.</st>\n\t\t\t<st c=\"67700\">There are two specific commands that we will be using in this section.</st> <st c=\"67772\">The first one is the</st> `<st c=\"67793\">pac pages download</st>` <st c=\"67811\">command, which is able to download website content from Dataverse.</st> <st c=\"67879\">The other one is the</st> `<st c=\"67900\">pac pages upload</st>` <st c=\"67916\">command, which can upload website content together with all the manifest files and the deployment profile that is appropriate for the</st> <st c=\"68051\">target environment.</st>\n\t\t\t<st c=\"68070\">These two commands support ALM for Power Pages and can be used together in our CI/CD pipelines, wherever we are not using Power Platform</st> <st c=\"68208\">Build Tools.</st>\n\t\t\t<st c=\"68220\">Deployment profiles</st>\n\t\t\t<st c=\"68240\">A deployment profile</st> <st c=\"68261\">is a file in YAML format that holds a set of values and settings</st> <st c=\"68326\">that are relevant to the target environment.</st> <st c=\"68372\">Deployment profiles are used in a similar way as deployment settings files are in Power Apps.</st> <st c=\"68466\">It is possible to have a deployment profile file for each target environment that we are deploying a website to.</st> <st c=\"68579\">Each of these files contains values that match the configuration settings of the</st> <st c=\"68660\">target environment.</st>\n\t\t\t<st c=\"68679\">Deployment profiles should be added in the</st> `<st c=\"68723\">deployment-profiles</st>` <st c=\"68742\">folder, in the root of the downloaded website folder.</st> <st c=\"68797\">A new folder will need to be created if it has not been created yet.</st> <st c=\"68866\">There we can add the</st> `<st c=\"68887\"><</st>``<st c=\"68888\">profileTag>.deployment.yml</st>` <st c=\"68914\">files.</st>\n\t\t\t<st c=\"68921\">These files will then be used later on, during the upload process, with a</st> `<st c=\"68996\">--deploymentProfile</st>` `<st c=\"69016\">test</st>` <st c=\"69020\">argument:</st>\n\t\t\t![Figure 10.15 – Deployment profiles and manifest files in Power Pages](img/B22208_10_15.jpg)\n\n\t\t\t<st c=\"69446\">Figure 10.15 – Deployment profiles and manifest files in Power Pages</st>\n\t\t\t<st c=\"69514\">Manifest files</st>\n\t\t\t<st c=\"69529\">When downloading a website from Power Pages, the PAC CLI creates two additional manifest files: an environment</st> <st c=\"69641\">manifest file (</st>`<st c=\"69656\">org-url-manifest.yml</st>`<st c=\"69677\">) and a delete-tracking manifest file (</st>`<st c=\"69717\">manifest.yml</st>`<st c=\"69730\">).</st> <st c=\"69734\">Both files are in YAML format and stored with the</st> `<st c=\"69784\">.portalconfig</st>` <st c=\"69797\">root folder structure of the</st> <st c=\"69827\">downloaded website.</st>\n\t\t\t<st c=\"69846\">The environment manifest file is created with the purpose of optimizing the upload process.</st> <st c=\"69939\">After each download method is run with the PAC CLI, the download method creates a new manifest file, in case one doesn’t exist yet.</st> <st c=\"70071\">If the manifest file exists, it reads the existing manifest file and updates the changes, such as any entries that were removed.</st> <st c=\"70200\">When uploading content, only the updated and new entries are uploaded to</st> <st c=\"70273\">Power Pages.</st>\n\t\t\t<st c=\"70285\">The environment manifest file is environment-specific, intended mainly for development environments, and it should be added to the</st> `<st c=\"70417\">git</st>` `<st c=\"70421\">ignore</st>` <st c=\"70427\">list.</st>\n\t\t\t<st c=\"70433\">The</st> <st c=\"70438\">delete-tracking manifest file is used to keep track of entries removed from the environment.</st> <st c=\"70531\">Whenever a download method is called, all the deleted entries are added to the delete-tracking manifest file.</st> <st c=\"70641\">Once an upload method is called, the method removes the unnecessary entries from Power Pages.</st> <st c=\"70735\">This file is important and should be added to the source control system and transferred to the</st> <st c=\"70830\">target environment.</st>\n\t\t\t<st c=\"70849\">Example of using the PAC CLI for Power Pages</st>\n\t\t\t<st c=\"70894\">We will take a look at the example</st> <st c=\"70929\">of using the PAC CLI for the download and upload of Power</st> <st c=\"70988\">Pages content:</st>\n\n```", "```\n\n\t\t\t<st c=\"71400\">Using Power Platform Build Tools with Power Pages</st>\n\t\t\t<st c=\"71450\">Power Platform Build Tools</st> <st c=\"71477\">offers two tasks that we have not yet explored:</st> **<st c=\"71526\">Power Platform Download PAPortal</st>** <st c=\"71558\">and</st> **<st c=\"71563\">Power Platform Upload PAPortal</st>**<st c=\"71593\">. Both tasks are intended to operate with</st> <st c=\"71635\">Power Pages.</st>\n\t\t\t<st c=\"71647\">We will first</st> <st c=\"71662\">create an export pipeline that will download the website content and commit everything to the main branch.</st> <st c=\"71769\">The following is a snippet of steps with the tasks needed to enable such</st> <st c=\"71842\">a pipeline:</st>\n\n```", "```\n\n\t\t\t<st c=\"72437\">After</st> <st c=\"72444\">running the export pipeline, we now have the source code in</st> <st c=\"72504\">Azure Repos.</st>\n\t\t\t<st c=\"72516\">As a next step, we should create deployment profiles with the necessary configuration values, as mentioned in the previous section (on creating a</st> `<st c=\"72663\">deployment-profiles</st>` <st c=\"72682\">folder with corresponding deployment YAML files).</st> <st c=\"72733\">The deployment profile files might not change that often, as they might be environment-specific, but it is worth setting them up and updating them when necessary; it is a good practice to use them from the beginning in order to keep the configuration settings separate</st> <st c=\"73002\">between environments.</st>\n\t\t\t![Figure 10.16 – Deployment profiles in Azure Repos](img/B22208_10_16.jpg)\n\n\t\t\t<st c=\"73602\">Figure 10.16 – Deployment profiles in Azure Repos</st>\n\t\t\t<st c=\"73651\">Whenever developers have to work on their website, we recommend using a branching strategy and pull request mechanism, in order to keep the main branch protected and always in a</st> <st c=\"73830\">deployable state.</st>\n\t\t\t<st c=\"73847\">After the pull request is validated and approved, branches can be merged to the</st> <st c=\"73928\">main branch.</st>\n\t\t\t<st c=\"73940\">Merging branches can automatically trigger the deployment pipeline.</st> <st c=\"74009\">The following is a snippet of tasks from the</st> <st c=\"74054\">deployment pipeline:</st>\n\n```", "```\n\n\t\t\t<st c=\"74336\">Here we have two variables,</st> `<st c=\"74365\">WebsiteName</st>` <st c=\"74376\">and</st> `<st c=\"74381\">profileTag</st>`<st c=\"74391\">. The first is the name of our Power Pages instance as it appears in our Azure Repos;</st> `<st c=\"74477\">profileTag</st>` <st c=\"74487\">should match the tag of the</st> <st c=\"74516\">deployment profile.</st>\n\t\t\t<st c=\"74535\">We should</st> <st c=\"74546\">not forget to perform proper testing of our Power Pages websites in order to validate our work and confirm the rollout to our</st> <st c=\"74672\">target environment.</st>\n\t\t\t<st c=\"74691\">We familiarized ourselves with Power Platform pipelines in</st> [*<st c=\"74751\">Chapter 5</st>*](B22208_05.xhtml#_idTextAnchor089)<st c=\"74760\">, where we talked about managed pipelines.</st> <st c=\"74803\">Let’s take a look at how we can utilize Power Platform pipelines to deploy our Power</st> <st c=\"74888\">Pages websites.</st>\n\t\t\t<st c=\"74903\">Using Power Platform pipelines with Power Pages</st>\n\t\t\t**<st c=\"74951\">Power Platform pipelines</st>** <st c=\"74976\">allow</st> <st c=\"74983\">the quick and easy configuration of deployment pipelines that enable organizations to automate the release of a build from the development environment to other environments, such as test</st> <st c=\"75170\">and production.</st>\n\t\t\t<st c=\"75185\">In order to</st> <st c=\"75197\">utilize Power Platform pipelines, all target environments must be enabled as</st> **<st c=\"75275\">Managed Environments</st>**<st c=\"75295\">, and all environments that are used in pipelines must be Dataverse-enabled.</st> <st c=\"75372\">All websites have to be created using the enhanced</st> <st c=\"75423\">data model.</st>\n\t\t\t<st c=\"75434\">Once the prerequisites are met, we are able to proceed with deploying our websites to</st> <st c=\"75521\">target environments.</st>\n\t\t\t<st c=\"75541\">First, we need to prepare the solution.</st> <st c=\"75582\">In Power Apps, we open</st> **<st c=\"75605\">Solutions</st>**<st c=\"75614\">, where we either create a new solution or open an existing one.</st> <st c=\"75679\">Then, we open the solution and add our existing website to the solution by selecting</st> **<st c=\"75764\">Add existing</st>** <st c=\"75776\">|</st> **<st c=\"75779\">Site</st>**<st c=\"75783\">. In the sidebar that opens, we select the website that we would like to add to the solution.</st> <st c=\"75877\">Once the solution objects are added to the solution, we can proceed with setting up the pipeline.</st> <st c=\"75975\">While still in the newly created solution, we click</st> **<st c=\"76027\">Pipelines</st>**<st c=\"76036\">, which can be found in the left navigation bar.</st> <st c=\"76085\">In</st> **<st c=\"76088\">Pipelines</st>**<st c=\"76097\">, we can select existing pipelines that the DevOps or IT operations team has created for us in advance, or we can click</st> **<st c=\"76217\">Create new pipeline</st>**<st c=\"76236\">. The new popup screen allows us to define the deployment pipeline, which will take our solutions from the source to the</st> <st c=\"76357\">target environment:</st>\n\t\t\t![Figure 10.17 – Power Platform pipelines](img/B22208_10_17.jpg)\n\n\t\t\t<st c=\"77208\">Figure 10.17 – Power Platform pipelines</st>\n\t\t\t<st c=\"77247\">Once the</st> <st c=\"77256\">pipeline is configured, we can press the</st> **<st c=\"77298\">Deploy here</st>** <st c=\"77309\">button and the deployment process</st> <st c=\"77344\">will start.</st>\n\t\t\t<st c=\"77355\">This is a more simplified kind of deployment process.</st> <st c=\"77410\">Still, it is suitable for many scenarios.</st> <st c=\"77452\">It opens the door for app makers who might not be skilled in DevOps processes and CI/CD pipelines but are still aware of the importance of the automated approach of deploying business solutions and keeping</st> <st c=\"77658\">environments separate.</st>\n\t\t\t<st c=\"77680\">Summary</st>\n\t\t\t<st c=\"77688\">This chapter continued building on the possibilities that Microsoft Power Platform provides to pro-developers.</st> <st c=\"77800\">The platform definitely shouldn’t be taken lightly, even though it is a part of the low-code development toolset.</st> <st c=\"77914\">As we have seen, it offers many opportunities for pro-developers to extend the user experience and integrate solutions with complex backend and legacy systems.</st> <st c=\"78074\">Now we can see how important it is to form agile fusion teams where pro-developers have the ability to customize solutions using different custom components, in order to deliver on</st> <st c=\"78255\">project requirements.</st>\n\t\t\t<st c=\"78276\">We looked at examples of how connection references and environment variables can be used together with the DevOps approach.</st> <st c=\"78401\">We continued with a look at canvas components and component libraries.</st> <st c=\"78472\">We then covered the Power Apps component framework and code components.</st> <st c=\"78544\">All these components can be added to solutions as solution objects, and DevOps pipelines can be used to deploy them securely to other environments as development progresses.</st> <st c=\"78718\">We closed this chapter by taking a look at Power Pages ALM.</st> <st c=\"78778\">We have investigated how we can use Power Platform Build Tools to support ALM process for our websites, as well as checked a simpler approach using managed pipelines in</st> <st c=\"78947\">Power Platform.</st>\n\t\t\t<st c=\"78962\">The next chapter will focus on best practices for managing environments in a governed and secure way and how the IT operations team can describe environments using code.</st> <st c=\"79133\">This is a very important part of the DevOps life cycle that we have to address, even though it is not</st> <st c=\"79235\">very pro-dev-oriented.</st>\n\t\t\t<st c=\"79257\">Further reading</st>\n\n\t\t\t\t*   <st c=\"79273\">Connectors</st> <st c=\"79285\">architecture:</st> [<st c=\"79299\">https://learn.microsoft.com/en-us/connectors/connector-architecture</st>](https://learn.microsoft.com/en-us/connectors/connector-architecture)\n\t\t\t\t*   <st c=\"79366\">Connection</st> <st c=\"79378\">references:</st> [<st c=\"79390\">https://learn.microsoft.com/en-us/power-apps/maker/data-platform/create-connection-reference</st>](https://learn.microsoft.com/en-us/power-apps/maker/data-platform/create-connection-reference)\n\t\t\t\t*   <st c=\"79482\">Environmental</st> <st c=\"79497\">variables:</st> [<st c=\"79508\">https://learn.microsoft.com/en-us/power-apps/maker/data-platform/environmentvariables</st>](https://learn.microsoft.com/en-us/power-apps/maker/data-platform/environmentvariables)\n\t\t\t\t*   <st c=\"79593\">Component</st> <st c=\"79604\">library:</st> [<st c=\"79613\">https://learn.microsoft.com/en-us/power-apps/maker/canvas-apps/component-library</st>](https://learn.microsoft.com/en-us/power-apps/maker/canvas-apps/component-library)\n\t\t\t\t*   <st c=\"79693\">Power Apps component</st> <st c=\"79715\">framework:</st> [<st c=\"79726\">https://learn.microsoft.com/en-us/power-apps/developer/component-framework/overview</st>](https://learn.microsoft.com/en-us/power-apps/developer/component-framework/overview)\n\t\t\t\t*   <st c=\"79809\">Power Pages</st> <st c=\"79822\">ALM:</st> [<st c=\"79827\">https://learn.microsoft.com/en-us/power-pages/configure/portals-alm</st>](https://learn.microsoft.com/en-us/power-pages/configure/portals-alm)\n\n```"]