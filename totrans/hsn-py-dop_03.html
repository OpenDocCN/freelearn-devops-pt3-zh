<html><head></head><body>
		<div id="_idContainer046">
			<h1 id="_idParaDest-56" class="hapter-number"><a id="_idTextAnchor061"/>3</h1>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor062"/>The Simplest Ways to Start Using DevOps in Python Immediately</h1>
			<p class="author-quote">Things don’t just happen. They are made to happen.</p>
			<p class="author-quote">– John F. Kennedy</p>
			<p>Over the past couple of chapters, you’ve probably been thinking, all these principles and philosophies are fine, but I want to get my hands dirty! If that’s what you want, then this is the chapter for you. In this chapter, you will learn how to use Python and its libraries to serve the purposes of <span class="No-Break">your workloads.</span></p>
			<p>Now, I’m not suggesting that you switch to Python-based alternatives from what you are currently using. In fact, most of the tools and techniques that we are about to discuss are meant to be in support of existing infrastructure and methods as opposed to a replacement <span class="No-Break">for them.</span></p>
			<p>This chapter is meant to give you a good grasp of the possibilities that the Python programming language provides DevOps as well as the ways that you can integrate it into your pre-existing systems <span class="No-Break">and infrastructure.</span></p>
			<p>In this chapter, we are going to learn about a few simple implementations of Python in different aspects of <span class="No-Break">API calls:</span></p>
			<ul>
				<li>Making API calls and the different ways that API calls <span class="No-Break">are made</span></li>
				<li>How Python can help analyze, construct, and optimize your workload’s <span class="No-Break">networking resources</span></li>
			</ul>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor063"/>Technical requirements</h1>
			<p>There are a few technical requirements that may need to be fulfilled if you want to get the most out of <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>A <span class="No-Break">GitHub account</span></li>
				<li>A Replit account (which has a single sign-on <span class="No-Break">with GitHub)</span></li>
				<li>A Hugging <span class="No-Break">Face account</span></li>
				<li>A <span class="No-Break">Google account</span></li>
				<li>Any computing device with an internet connection and a command <span class="No-Break">line interface</span></li>
				<li>The ability to tolerate my <span class="No-Break">writing style</span></li>
			</ul>
			<p>Well, if you can get those in hand, then you are ready to start your journey in this chapter. Let’s <span class="No-Break">get going.</span></p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor064"/>Introducing API calls</h1>
			<p>To define <a id="_idIndexMarker092"/>API calls, let’s start with what an <strong class="bold">Application Programming Interface<a id="_idTextAnchor065"/></strong> (<strong class="bold">API</strong>) is. An API is a software interface that offers your <a id="_idIndexMarker093"/>application access to functions and processes from other applications. Think of it like this: when a user tries to get information from an application, they do <a id="_idIndexMarker094"/>so through the <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>). The API has a similar function for software, so you could call API the UI <span class="No-Break">of software.</span></p>
			<p>Now, API calls are made f<a id="_idTextAnchor066"/>or a number <span class="No-Break">of reasons:</span></p>
			<ul>
				<li>You don’t want to write the underlying logic for a big feature yourself (trust me, a lot of the time, <span class="No-Break">you don’t.</span></li>
				<li>The API gives access to resources that you ordinarily would not have (i.e., creating a Virtual Machine using the API of a <span class="No-Break">cloud provider)</span></li>
				<li>You just want to get some information into your application (public APIs are very good <span class="No-Break">for this)</span></li>
			</ul>
			<p>Any coding library that you use for code is technically an API. You pull the libra<a id="_idTextAnchor067"/>ry in and you call it to perform a function for your application. So, you can see why the definition of APIs can be <a id="_idIndexMarker095"/>confusing sometimes. But the point is this: more things are APIs than are not APIs. Everything you see in<a id="_idTextAnchor068"/> an app or a website comes <span class="No-Break">from APIs.</span></p>
			<p>So, let’s dive into a couple of examples of how to use APIs to our benefit <span class="No-Break">in DevOps.</span></p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor069"/>Exercise 1 – calling a Hugging Face Transformer API</h2>
			<p>I chose this exercise because it is free, it will introduce you to a lot of integral tools and concepts behind APIs, and <strong class="bold">Hugging Face APIs</strong> are quite popular, so you will get hands-on experience <a id="_idIndexMarker096"/>with those. The API that we will be using specifically is a transformer that turns a written prompt into an image. It’s a great API to learn and find <a id="_idIndexMarker097"/>out how APIs in general work. For this lesson, I am using a Google Colab notebook, which is a Jupyter Notebook hosted by Google.<a id="_idTextAnchor070"/> It’s pretty useful when you want to recreate runtimes for certain sections of code. It’s like having your own little test section that you can divide into even smaller sections if you want to. Let’s make a notebook to further explore our Hugging <span class="No-Break">Face API:</span></p>
			<ol>
				<li>To open a Colab notebook, you can go to <a href="http://colab.research.google.com">colab.research.google.com</a> and create a new notebook. The end result should be something <span class="No-Break">like this:</span></li>
			</ol>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/B21320_03_1.jpg" alt="Figure 3.1 – Initial notebook created with Google Colab"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Initial notebook created with Google Colab</p>
			<ol>
				<li value="2">The first thing we need to do is install the correct libraries. These libraries contain the functions and modules with which we call our APIs. You can install them directly in the notebook if you’d like. We are going to install the <strong class="sour e-inline">huggingface_hub</strong> and <strong class="sour e-inline">transformers[agents]</strong> libraries. Here is the command <span class="No-Break">for this:</span><pre class="sour e- ode"><strong class="bold">!pip install huggingface_hub transformers[agents]</strong></pre><p class="list-inset">When you put this command in the cell and press play, it will install the libraries in <span class="No-Break">your runtime:</span></p></li>
			</ol>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/B21320_03_2.jpg" alt="Figure 3.2 – Installing required libraries"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Installing required libraries</p>
			<ol>
				<li value="3">The next thing <a id="_idIndexMarker098"/>that you need to do is log in to <strong class="sour e-inline">huggingface_hub</strong> using an <span class="No-Break">API key.</span><p class="list-inset">This is where the concept of the API key comes from. An API key is like a login but for your software. Most companies only allow full access to their APIs through the purchase of an API key. A lot of open source projects such as Hugging Face have API keys to promote and track user interaction and sometimes upgrade their users to a premium version if <span class="No-Break">they want.</span></p></li>
				<li>To get a Hugging Face API key, you must first go to the <a href="http://huggingface.co">huggingface.co</a> web page and sign up or log in if you’ve already signed up. After doing that, go to your profile and then to the <strong class="bold">Settings</strong> tab and into the <strong class="bold">Access Tokens</strong> tab from there. You can generate an access token for <span class="No-Break">use there:</span></li>
			</ol>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/B21320_03_3.jpg" alt="Figure 3.3 – Generating an access token for the ﻿Hugging Face API"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Generating an access token for the Hugging Face API</p>
			<ol>
				<li value="5">You can copy <a id="_idIndexMarker099"/>this token for use in your next section of code. Here, you import the Hugging Face login module for the login API, and you input your key to use <span class="No-Break">the API:</span><pre class="sour e- ode">from huggingface_hub import login
login("&lt;your_key_here&gt;")</pre><p class="list-inset">You’ll get this message if you’ve loaded it correctly. If so, congratulations, you successfully called the <span class="No-Break">login API:</span></p></li>
			</ol>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/B21320_03_4.jpg" alt="Figure 3.4 – Successful login and initialization"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Successful login and initialization</p>
			<p class="list-inset">Now comes the fun part. We are going to use the Hugging Face Transformer API to take a line of text and turn it into an image. But first, we must import a Hugging Face agent using the <strong class="sour e-inline">HfAgent</strong> API (see <span class="No-Break">the pattern?):</span></p>
			<pre class="sour e- ode">from transformers import HfAgentagent = HfAgent("https://api-inference.huggingface.co/models/ bigcode/starcoderbase")</pre>
			<p class="list-inset">We are using the <strong class="sour e-inline">starcoderbase</strong> model for this. Once you run this and get the agent, you can simply type in a prompt to generate <span class="No-Break">an image:</span></p>
			<pre class="sour e- ode">agent.run("Draw me a picture of `prompt`", prompt="rainbow butterflies")</pre>
			<p class="list-inset">But remember, if you <a id="_idIndexMarker100"/>don’t want to wait half an hour for your image, use the GPU runtime by going to the <strong class="bold">runtime</strong> tab and <span class="No-Break">selecting it:</span></p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/B21320_03_5.jpg" alt="Figure 3.5 – Choosing a GPU for faster image processing"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Choosing a GPU for faster image processing</p>
			<ol>
				<li value="6">The end product will leave you shocked and satisfied. You’ll get something <span class="No-Break">like this:</span></li>
			</ol>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="image/B21320_03_6.jpg" alt="Figure 3.6 – Your final result (beautiful, isn’t it?)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – Your final result (beautiful, isn’t it?)</p>
			<p>So, we have <a id="_idIndexMarker101"/>completed this exercise and successfully called an API that has given us a visibly satisfying conclusion. What more could one ask for? Now, if only other people could witness the fruits of <span class="No-Break">your labor!</span></p>
			<p>Well, that’s what calling APIs is all about. APIs are meant to be consumed by your target audience and so now, we are going to see how we can distribute <span class="No-Break">our APIs.</span></p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor071"/>Exercise 2 – creating and releasing an API for consumption</h2>
			<p>Deploying applications is one of the most frequent tasks that a DevOps engineer might encounter. It is important to have a good, fast deployment, but before that, it is important to <a id="_idIndexMarker102"/>have a deployment in the first place. Deploying smaller and larger applications are alike in a lot of ways. One major way in which they <a id="_idIndexMarker103"/>differ is the lengths you must go through to maintain availability on larger applications. We won’t be discussing that in this section. We will instead just try to get an API up for adding two numbers. Like I said, let’s keep it simple and <a id="_idIndexMarker104"/>begin creating a new <strong class="bold">Replit Repl</strong> and start coding <span class="No-Break">in it.</span></p>
			<ol>
				<li>Sign up for an account at <a href="http://replit.com">replit.com</a>. You can create small virtual environments for practically every application framework and code base there. Once you have signed up, you can create a <strong class="bold">Repl</strong>, which is a small virtual server, by clicking the <strong class="bold">Create </strong><span class="No-Break"><strong class="bold">Repl</strong></span><span class="No-Break"> button:</span></li>
			</ol>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="image/B21320_03_7.jpg" alt="Figure 3.7 – Button to create a Repl"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – Button to create a Repl</p>
			<ol>
				<li value="2">Once you have done that, search for and create a Repl with the <strong class="bold">Flask</strong> template. The name is <span class="No-Break">not relevant:</span></li>
			</ol>
			<div>
				<div id="_idContainer035" class="IMG---Figure">
					<img src="image/B21320_03_8.jpg" alt="Figure 3.8 – Initializing a Flask Repl"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – Initializing a Flask Repl</p>
			<p class="list-inset">This will <a id="_idIndexMarker105"/>give you an IDE that contains boilerplate <a id="_idIndexMarker106"/>Flask code that is pre-initialized and installed with the basic <span class="No-Break">Flask libraries:</span></p>
			<div>
				<div id="_idContainer036" class="IMG---Figure">
					<img src="image/B21320_03_9.jpg" alt="Figure 3.9 – Initial Flask framework"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9 – Initial Flask framework</p>
			<ol>
				<li value="3">Concerning the preceding figure, when you click the <strong class="bold">Run</strong> button shown on top, you’ll launch a Flask server, a URL that will return some sort of answer when it is called. The server’s default route of <strong class="sour e-inline">"/"</strong> has already been defined. So, if you open the URL in a new tab, you’ll get something <span class="No-Break">like this:</span></li>
			</ol>
			<div>
				<div id="_idContainer037" class="IMG---Figure">
					<img src="image/B21320_03_10.jpg" alt="Figure 3.10 – Initial Flask web page"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10 – Initial Flask web page</p>
			<p class="list-inset">This function <a id="_idIndexMarker107"/>just returns a string on a webpage. Typically, APIs are written in a JSON format. So, let’s turn this into JSON. In Flask, that is <a id="_idIndexMarker108"/>pretty easy. You can just pass a variable that is a dictionary in the <span class="No-Break">return type:</span></p>
			<div>
				<div id="_idContainer038" class="IMG---Figure">
					<img src="image/B21320_03_11.jpg" alt="Figure 3.11 – Writing a simple JSON API in Flask"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.11 – Writing a simple JSON API in Flask</p>
			<p class="list-inset">Once that’s done, you’ll get a return value <span class="No-Break">in JSON:</span></p>
			<div>
				<div id="_idContainer039" class="IMG---Figure">
					<img src="image/B21320_03_12.jpg" alt="Figure 3.12 – JSON API result"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.12 – JSON API result</p>
			<ol>
				<li value="4">This API, as it is, only returns static values. To have it take user input, simply add <strong class="sour e-inline">request</strong> parameters in the URL itself. Let’s modify our application to take two parameters, <strong class="sour e-inline">num1</strong> and <strong class="sour e-inline">num2</strong>, which will be added, and their sums shown in the JSON <span class="No-Break">return value:</span></li>
			</ol>
			<div>
				<div id="_idContainer040" class="IMG---Figure">
					<img src="image/B21320_03_13.jpg" alt="Figure 3.13 – Flask API code to add two numbers"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.13 – Flask API code to add two numbers</p>
			<p class="list-inset">The end <a id="_idIndexMarker109"/>result requires a URL in the form of <strong class="sour e-inline">&lt;your_url_here&gt;/?num1=&lt;number&gt;&amp;num2=&lt;number&gt;</strong>. The result would <a id="_idIndexMarker110"/>look something <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer041" class="IMG---Figure">
					<img src="image/B21320_03_14.jpg" alt="Figure 3.14 – Flask API call to add two numbers"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.14 – Flask API call to add two numbers</p>
			<p>So, now you have learned how to make an API in Python that adds two numbers and deploys the API. That’s a really big step. The only thing that gets exponentially more complex in the programming world is business logic. Security and networking are important too, but they usually follow a set formula. As long as you can deploy your logic to your end user, <span class="No-Break">you’re good.</span></p>
			<p>Now, that you have learned the art of the API, we are going to dive into what delivers APIs to their end users. We are diving into networking. Networking is such an integral part of DevOps <a id="_idIndexMarker111"/>and application development in general that <a id="_idIndexMarker112"/>sometimes it’s not mentioned at all. So, let’s look at a few useful ways that we can use Python on the <span class="No-Break">networking side.</span></p>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor072"/>Networking</h1>
			<p>No, this is not about growing your LinkedIn connections, although that’s something I’d recommend doing too. Computer networks are essential to the functioning of every application these <a id="_idIndexMarker113"/>days because they are the only way to deliver constant value to the user while keeping them connected to your environment. Almost every device these days is connected to a network, which is why understanding the network of devices and the network of networks (it’s something called the internet, ever heard of it?) is <span class="No-Break">very important.</span></p>
			<p>I am now going to demonstrate two examples of how to use Python for networking insights and <span class="No-Break">data collection.</span></p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor073"/>Exercise 1 – using Scapy to sniff packets and visualize packet size over time</h2>
			<p><strong class="bold">Scapy</strong> is a Python <a id="_idIndexMarker114"/>library that can be used <a id="_idIndexMarker115"/>to replicate, simulate, and manipulate the data packets that are sent over a computer network. Scapy is a very useful tool in the belt of any developer or <span class="No-Break">DevOps professional.</span></p>
			<p>In this exercise, we are going to use Scapy to collect a list of packets and get their timestamps and packet sizes. We are then going to map these onto a chart that we make using <a id="_idIndexMarker116"/>the <strong class="bold">matplotlib library</strong>. You can use the previously mentioned Google Colab for this exercise. So, let’s initialize the notebook and start writing <span class="No-Break">our code:</span></p>
			<ol>
				<li>First, we need to install the <strong class="sour e-inline">matplotlib</strong> and <span class="No-Break"><strong class="sour e-inline">scapy</strong></span><span class="No-Break"> libraries:</span><pre class="sour e- ode">!pip install scapy matplotlib</pre></li>
				<li>Now, let’s <a id="_idIndexMarker117"/>write the code to use Scapy’s <strong class="sour e-inline">sniff</strong> module to get a list of packet sizes <span class="No-Break">over timestamps:</span><pre class="sour e- ode">from scapy.all import sniff
# Lists to store packet sizes and timestamps
packet_sizes = []
timestamps = []
#Handle packets and get the necessary data
def packet_handler(packet):
print(packet)
packet_sizes.append(len(packet))
timestamps.append(packet.time)
# Start packet sniffing on the default network interface
sniff(prn=packet_handler, count=100)</pre><p class="list-inset">You will <a id="_idIndexMarker118"/>get a list of the length of the last <strong class="sour e-inline">100</strong> packets that went through your network along with the timestamp and the type of traffic. If you refer to the following diagram, the packet sizes are stored in the <strong class="sour e-inline">packet_sizes</strong> array and the timestamps of the packet are s<a id="_idTextAnchor074"/>tored in the <span class="No-Break"><strong class="sour e-inline">timestamps</strong></span><span class="No-Break"> variable:</span></p></li>
			</ol>
			<div>
				<div id="_idContainer042" class="IMG---Figure">
					<img src="image/B21320_03_15.jpg" alt="Figure 3.15 – Sniffing packets in your computing device"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.15 – Sniffing packets in your computing device</p>
			<ol>
				<li value="3">Let’s <a id="_idIndexMarker119"/>now write the code to plot the <a id="_idIndexMarker120"/>packet size over time <span class="No-Break">using </span><span class="No-Break"><strong class="sour e-inline">matplotlib</strong></span><span class="No-Break">:</span><pre class="sour e- ode"># Create a plot
plt.figure(figsize=(16, 8))
plt.plot(timestamps, packet_sizes, marker='o')
plt.xlabel("Time")
plt.ylabel("Packet Size")
plt.title("Packet Size over Time")
plt.grid(True)
plt.show()</pre><p class="list-inset">This will give us a chart with time on the <em class="itali">x</em>-axis and packet size on <span class="No-Break">the </span><span class="No-Break"><em class="itali">y</em></span><span class="No-Break">-axis:</span></p></li>
			</ol>
			<div>
				<div id="_idContainer043" class="IMG---Figure">
					<img src="image/B21320_03_16.jpg" alt="Figure 3.16 – Chart of packet size over time"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.16 – Chart of packet size over time</p>
			<p>The preceding <a id="_idIndexMarker121"/>chart shows a pattern of network activity <a id="_idIndexMarker122"/>that seems to involve several correlated packets. So, you can see the network analysis library coming in <span class="No-Break">handy already.</span></p>
			<p>So, we have now tracked our network activity and generated data insights from it using Python. Let’s look at one more network implementation, this time focusing on the routing rules that your device (or the device you are running your workload <span class="No-Break">on) has.</span></p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor075"/>Exercise 2 – generating a routing table for your device</h2>
			<p>Routing tables define the routes that certain web traffic takes within your devices. These tables <a id="_idIndexMarker123"/>exist in practically every device, and they define the routes by which those devices access computer networks. You can <a id="_idIndexMarker124"/>use the <strong class="bold">netifaces Python library</strong> to generate a routing table showing all the available routes and destinations that your device contains. The netifaces library in this case is used to collect the network interfaces (hence the name <em class="itali">netifaces</em>) of your operating system. You will then parse this information and display it in a tabular form. You can once again use Google Colab for this, though for more interesting results, you could try running the <span class="No-Break">code locally.</span></p>
			<ol>
				<li>Let’s begin the steps to generate a routing table for your device. If you’ve been following along so far, you know the first step is installing <span class="No-Break">the library:</span><pre class="sour e- ode">!pip install netifaces</pre></li>
				<li>Next, write <a id="_idIndexMarker125"/>code to generate the <span class="No-Break">routing table:</span><pre class="sour e- ode">#import library
import netifaces
#begin function
def generate_routing_table():
routing_table = []
#Loop through network interfaces
for interface in netifaces.interfaces():
     #initialize current address of interface
Interface_addresses =netifaces.ifaddresses(interface)
#Check for, then loop through the addresses
if netifaces.AF_INET in addresses:
for entry in  	interface_addresses[netifaces.AF_INET]:
	#Create routing entry wherefound
if 'netmask' in entry and 'addr' in 	entry:
routing_entry = {
'interface': interface,
'destination': entry['addr'],
'netmask': entry['netmask']
}
#Append route to routing table
routing_table.append(routing_entry)
return routing_table
#Call function
routing_table = generate_routing_table()
#Display routing table
for entry in routing_table:
print(f"Interface: {entry['interface']}")
print(f"Destination: {entry['destination']}")
print(f"Netmask: {entry['netmask']}")
print("-" * 30)</pre><p class="list-inset">It’s a lot of code, but fairly easy to make sense of. It also provides you with detailed <a id="_idIndexMarker126"/>information about where the network traffic goes from your network interfaces. If you tried it on Colab as I suggested, you’d get something <span class="No-Break">like this:</span></p></li>
			</ol>
			<div>
				<div id="_idContainer044" class="IMG---Figure">
					<img src="image/B21320_03_17.jpg" alt="Figure 3.17 – Route table on Colab"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.17 – Route table on Colab</p>
			<p class="list-inset">And if you’ve done it on your personal computer, you might get something <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer045" class="IMG---Figure">
					<img src="image/B21320_03_18.jpg" alt="Figure 3.18 – Route table on a personal computer"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.18 – Route table on a personal computer</p>
			<p class="list-inset">A bit more baggage was <span class="No-Break">added there.</span></p>
			<p>But that <a id="_idIndexMarker127"/>is the gist of it, and these are just a couple of ways you can use Python to facilitate the networking aspect <span class="No-Break">of DevOps.</span></p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor076"/>Summary</h1>
			<p>In this chapter, you learned a thing or two about the hands-on part of this book. You’ve learned about APIs and computer networks, which practically means you’re halfway there as far as the Python DevOps <span class="No-Break">implementation goes.</span></p>
			<p>In this chapter, not only did you learn about these important DevOps concepts, but you also learned how you can implement them in your DevOps process. You can take this code and implement it directly in your DevOps workload right now if that <span class="No-Break">benefits you.</span></p>
			<p>These fundamentals that you have learned will help you enhance, monitor, and diagnose problems on practically any DevOps workload that you may encounter. In the next chapter, we will discuss the creation of resources in a DevOps workload and how and where Python can be of assistance in <span class="No-Break">the process.</span></p>
		</div>
	</body></html>