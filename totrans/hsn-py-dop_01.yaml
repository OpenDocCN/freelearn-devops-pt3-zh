- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introducing DevOps Principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Obey the principles without being bound by them.
  prefs: []
  type: TYPE_NORMAL
- en: – Bruce Lee
  prefs: []
  type: TYPE_NORMAL
- en: '**DevOps** has numerous definitions, most of which are focused on culture and
    procedure. If you’ve gotten to the point where you have purchased this book as
    a part of your journey in the DevOps field, you have probably heard at least about
    100 of these definitions. Since this is a book that focuses more on the hands-on,
    on-the-ground aspect of DevOps, we’ll keep those abstractions and definitions
    to a minimum, or rather, explain them through actions rather than words whenever
    possible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, since this is a DevOps book, I am obliged to take a shot at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*DevOps is a series of principles and practices that aims to set a culture
    that supports the automation of repetitive work and continuous delivery of a product
    while integrating the software development and IT operation aspects of* *product
    delivery.*'
  prefs: []
  type: TYPE_NORMAL
- en: Not bad. It’s probably incomplete, but that’s the nature of the beast, and that
    is perhaps what makes this definition somewhat appropriate. Any DevOps engineer
    would tell you that the work is never complete. Its principles are similar in
    many ways to the Japanese philosophy of **Ikigai**. It gives the engineers a purpose;
    an avenue for improvement on their systems which gives them the same thrill as
    a swordsman honing their skills or an artist painting their masterpiece. Satisfied,
    yet unsatisfied at the same time. Zen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Philosophical musings aside, I believe DevOps principles are critical to any
    modern software team. To work on such teams, it is better to start with the principles
    as they help explain a lot of how the tools used in DevOps were shaped, how and
    why software teams are constructed the way they are, and to facilitate DevOps
    principles. If I had to sum it up in one word: time.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn about the basic principles that define DevOps
    as a philosophy and a mindset. It is important to think of this just as much as
    an exercise in ideology as it is in technology. This chapter will give you the
    context you need to understand why DevOps principles and tools exist and the underlying
    philosophies behind them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding logging and monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incident and event response
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding high availability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delving into infrastructure as a code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’re going to start with why **automation** is needed in life in general and
    then we’ll move toward a more specific definition that relates to DevOps and other
    tech team activities. Automation is for the lazy, but many do not realize how
    hard you must work and how much you must study to truly be lazy. To achieve automation,
    it requires a mindset, an attitude, a frustration with present circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: Automation and how it relates to the world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Tim Ferris’s book *The 4-Hour Workweek*, he has an entire section dedicated
    to automating the workflow which emphasizes the fact that the principle of automation
    helps you clean up your life and remove or automate any unnecessary tasks or distractions.
    DevOps hopes to do something similar but in your professional life. Automation
    is the primary basis that frees up our time to do other things we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the things mankind has always tried to automate even further is transportation.
    We have evolved from walking to horses to cars to planes to self-driving versions
    of those things. The reason for that is the same reason DevOps became a prominent
    culture: to save time.'
  prefs: []
  type: TYPE_NORMAL
- en: How automation evolves from the perspective of an operations engineer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may have heard the famous story of the build engineer who automated his
    entire job down to the second (if you haven’t looked it up, it’s a great read).
    What he did was he automated any task within the server environment that required
    his attention for more than 90 seconds (solid DevOps principles from this guy
    if you ask me). This included automatically texting his wife if he was late, automated
    rollback of database servers based on a specific e-mail sent by a client’s database
    administrator, and Secure Shelling into the coffee machine to automatically serve
    him coffee, further proving my point that most things can be automated.
  prefs: []
  type: TYPE_NORMAL
- en: 'You don’t need to automate your workspace or your life to this extent if you
    don’t want to, but here’s the lesson you should take away from this: use automation
    to save time and prevent yourself from being hassled, because a) your time is
    precious and b) an automated task does the job perfectly every time if you set
    it correctly just once.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take ourselves through the life of a young software engineer named John.
    Let’s say John is a Flask developer. John has just joined his first big-boy software
    team and they are producing something already in production with a development
    and testing environment. John has only worked on `localhost:5000` his entire programming
    journey and knows nothing past that (a lot of entry-level coders don’t). John
    knows you use Git for version control and that the source code you push up there
    goes… somewhere. Then it shows up in the application. Here’s John’s journey figuring
    it out (and then being bored by it):'
  prefs: []
  type: TYPE_NORMAL
- en: John gets access to the repository and sets up the code locally. While it’s
    nothing he’s never done before, he starts contributing code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A month later, an Operations guy who was managing the deployment of the specific
    service John was working on leaves. John is asked if he can take over the deployments
    while they hire a replacement. John, being young and naïve, agrees.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two months later, with no replacement yet, John has figured out how deployment
    servers such as Nginx or Apache work and how to copy his code onto a server environment
    and deploy it in a way that it can reach the public internet (it turns out it
    was essentially just `localhost` in disguise. Who knew?). He may have even been
    allowed to modify the DNS records all by himself.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Four months later, John is tired, he spends half his time pulling code into
    the server, solving merge conflicts, restarting the server, and debugging the
    server. The server is a herd of goats, and he is but one hand with many mouths
    to feed. It becomes difficult for him to push new features and finish his pre-assigned
    tasks. This is when he starts wondering if there is a better way.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: He learns about bash scripting and runbooks. He learns that you can add triggers
    to both the repository and the server to perform certain tasks when the code has
    been updated. He also learns about playbooks that can be run when a common error
    starts popping up.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Six months later, John has automated practically every part of the deployment
    and maintenance procedures for the application. It runs itself. The process has
    made John a better coder as well as he now writes his code with the challenges
    of deployment and automation in mind.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Eight months later, John has nothing to do. He’s automated all relevant tasks,
    and he doesn’t need that Ops guy that HR never got back to him about. He is now
    a DevOps engineer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: His manager asks him why his worklog seems empty. John tells him that DevOps
    tasks are measured by difficulty and complexity and not work hours. The manager
    is confused.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, at this point, one of two things happens: either the manager listens and
    John pushes his enterprise toward a DevOps philosophy that will transform it into
    a modern IT company (there are antiquated IT companies, weird as that may seem),
    or he leaves for a place that appreciates his talents, which would be pretty easy
    to do if he markets them correctly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This may seem like a fantasy, but it’s how many DevOps engineers are forged:
    in the fires of incompetence. This tale is, however, meant to be more analogous
    to companies as a whole and whether they transform to use DevOps principles or
    not. The ones that do become more agile and capable of delivering new features
    and using resources toward something as opposed to using them just to maintain
    something.'
  prefs: []
  type: TYPE_NORMAL
- en: Automation is born out of a desire to not do the same things differently (usually
    for the worse) over and over again. This concept is at the heart of DevOps, since
    the people who automate realize how important it is to have consistency in repetitive
    tasks and why it is a time and potentially a lifesaver.
  prefs: []
  type: TYPE_NORMAL
- en: But for a task to be reliably done in the same way over and over again, it must
    be observed so that it can be kept on the correct path. That is where logging
    and monitoring come in.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding logging and monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Switching to a more grounded topic, one of the driving principles of DevOps
    is logging and monitoring instances, endpoints, services, and whatever else you
    can track and trace. This is necessary because regardless of whatever you do,
    how clean your code is, or how good your server configuration is, something will
    fail, go wrong, or just inexplicably stop working altogether. This will happen.
    It’s a fact of life. It is in fact, Murphy’s law:'
  prefs: []
  type: TYPE_NORMAL
- en: Anything that can go wrong will go wrong at the worst possible time.
  prefs: []
  type: TYPE_NORMAL
- en: Familiarizing yourself with this truth is important for a DevOps engineer. Once
    you have acknowledged it, then you can deal with it. Logging and monitoring come
    in because when something *does* go wrong, you need the appropriate data to respond
    to that event, sometimes automatically.
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this section has been laid out in terms of logging, monitoring,
    and alerts. Each one of these aspects plays an important role in keeping the DevOps
    train (workload) on the right track.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are not from a technical background or are new to logging principles,
    think of logging in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Every day after school, a schoolboy would go to an old woman selling matches
    and give her money for one matchbox. However, he’d take no matchboxes in return.
    Then one day, as the boy went about his usual routine, he saw the woman about
    to speak up and he said, “I know you’re probably wondering why I give you money
    for the matchbox but don’t take one in return. Would you like me to tell you?”
    The woman replied, “No, I just wanted to tell you that the price of matches has*
    *gone up.”*'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the woman is the logger, and the boy is the person viewing the
    log. The woman doesn’t care about the reason. She’s just collecting the data,
    and when the data changes, she collects the changed data. The boy checks in every
    day and goes about his routine uninterrupted until something changes in the log.
    Once the log changes, the boy decides whether to react or not depending on what
    he would consider to be an appropriate response.
  prefs: []
  type: TYPE_NORMAL
- en: In subsequent chapters, you’ll learn about logs, how to analyze them (usually
    with Python), and appropriate responses to logs. But at present, all you need
    to know is that good bookkeeping/logging has built empires because history and
    the lessons that we learn from it are important. They give us perspective and
    the appropriate lessons that we need to respond to future events.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you look at the title of this section, *Understanding logging and monitoring*,
    some of you might wonder, what’s the difference? Well, that’s valid. It took me
    a while to figure that out as well. And I believe that it comes down to a couple
    of things:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Monitoring** looks at a specific metric (usually generated by logs) and whether
    or not that metric has passed a certain threshold. However, **logging** is simply
    collecting the data without generating any insight or information from it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Monitoring is active and focuses on the current state of an instance or object
    that is being monitored, whereas logging is passive and focuses more on the collection
    of largely historical data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In many ways, it is like the differences between a transactional database and
    a data warehouse. One functions on current data while the other is about storing
    historical data to find trends. Both are intertwined with each other nearly inexorably
    and thus are usually spoken of together. Now that you have logged and monitored
    all the data, you might ask yourself, what is it for? The next section will help
    with that.
  prefs: []
  type: TYPE_NORMAL
- en: Alerts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You cannot have a conversation about logging and monitoring without bringing
    up the concept of alerts. A **logged metric** is monitored by a monitoring service.
    This service looks at the data produced from the logs and measures it against
    a threshold that is set for that metric. If the threshold is crossed for a sustained,
    defined period of time, an **alert** or alarm is raised.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, these alerts or alarms are either connected to a notification
    system that can inform the necessary personnel regarding the heightened alarm
    state, or a response system that can automatically trigger a response to the event.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned about the powers of observation and insight that you
    gain from logging and monitoring, it is time to learn how to wield that power.
    Let’s find out the actions we should take when we find significant and concerning
    insights through logging and monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: Incident and event response
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I’m going to put Murphy’s Law here again because I cannot state this enough:'
  prefs: []
  type: TYPE_NORMAL
- en: Anything that can go wrong will go wrong at the worst possible time.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with **incident and event response** involves either a lot of work or
    zero work. It depends on how prepared you are and how unique the incident or event
    is. Incident and event response covers a lot of ground from automation and cost
    control, to cybersecurity.
  prefs: []
  type: TYPE_NORMAL
- en: How a DevOps engineer responds to an event depends on a great number of things.
    In terms of dealing with clients and customers, a **Service Level Objective**
    (**SLO**) is used when a response is necessary. However, this is largely on production
    environments and requires the definition of a **Service Level Indicator** (**SLI**).
    It also involves the creation of an error budget to determine the right time to
    add new features and what the right time is to work on the maintenance of a system.
    Lower-priority development environments are used to stress test potential production
    cases and the effectiveness of incident response strategies. These objectives
    will be further explored in the *Understanding high* *availability* section.
  prefs: []
  type: TYPE_NORMAL
- en: If you work on the **Site Reliability Engineering** (**SRE**) side of DevOps,
    then incidents are going to be your bread and butter. A large part of the job
    description for that role involves having the correct metrics set up so that you
    can respond to a situation. Many SRE teams are set up these days to have active
    personnel around the globe who can monitor sites according to their active time
    zones. The response to the incident itself is done by an **incident response team**
    which I will cover in detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Another part of incident response is the understanding of what caused the incident,
    how long it took to recover, and what could have been done better in the future.
    This is covered by **post-mortems**, which usually assist in the creation of a
    clear, unbiased report that can help with future incidents. The incident response
    team is responsible for the creation of this document.
  prefs: []
  type: TYPE_NORMAL
- en: How to respond to an incident (in life and DevOps)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Incidents happen, and the people who are responsible for dealing with these
    incidents need to handle them. Firefighters have to battle fires, doctors have
    to treat the sick, and DevOps engineers have to contend with a number of incidents
    that can occur when running the sites that they manage and deploy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in life, how would you deal with an incident or something that affects
    your life or your work that you need to deal with? There’s one approach that I
    read in a book called *Mental Strength* by Iain Stuart Abernathy that I subsequently
    found everywhere among the DevOps courses and experts that I met: **Specific,
    Measurable, Achievable, Realistic, and Time-bound** (**SMART**). If a solution
    to a problem has to follow all of these principles, it will have a good chance
    of working. You can apply this to your own life along with your DevOps journey.
    It’s all problem-solving, after all.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To define the SMART principle in brief, let’s go over each of the components
    one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Specific: Know exactly what is happening'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Measurable: Measure its impact'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Achievable: Think of what your goal is for mitigation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Realistic: Be realistic with your expectations and what you can do'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Time-bound: Time is of the essence, so don’t waste it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some common incidents DevOps engineers may have to deal with:'
  prefs: []
  type: TYPE_NORMAL
- en: The production website or application goes down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a mass spike in traffic suggesting a distributed denial-of-service
    attack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a mass spike in traffic suggesting an influx of new users that will
    require an upscale in resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is an error in building the latest code in the code pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Someone deleted the production database (seriously, this can happen)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dealing with incidents involves first dividing the incident based on the type
    of response that can be provided and whether this type of incident has been anticipated
    and prepared for. If the response is manual, then time isn’t a factor. Usually,
    this occurs if an incident doesn’t affect the workload but must be addressed,
    such as a potential anomaly or a data breach. The stakeholders need to be told
    so that they can make an informed decision on the matter. Automatic responses
    are for common errors or incidents that you know occur from time to time and have
    the appropriate response for. For example, if you need to add more computing power
    or more servers in response to increased traffic or if you have to restart an
    instance if a certain metric goes awry (this happens quite a bit with Kubernetes).
  prefs: []
  type: TYPE_NORMAL
- en: We deal with these incidents in order to provide the maximum availability possible
    for any application or site that we manage. This practice of aiming for maximum
    availability will be covered in the next section on site reliability engineering.
  prefs: []
  type: TYPE_NORMAL
- en: Site reliability engineering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, **site reliability engineering** (**SRE**) is considered a form of DevOps
    by many and is considered to be separate from DevOps by others. I’m putting this
    section in here because, regardless of your opinion on the subject, you as a DevOps
    Engineer will have to deal with the concepts of site reliability, how to maintain
    it, and how to retain customer trust.
  prefs: []
  type: TYPE_NORMAL
- en: 'SRE as a concept is more rigid and inflexible than the DevOps philosophy as
    a whole. It is the evolution of the data center technicians of the past who practically
    lived in data centers for the course of their careers, maintaining server racks
    and configurations to ensure whatever product that was being delivered by their
    servers would continue to be delivered. That was their job: not creating anything
    new, but finding solutions to maintain their old infrastructure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'SRE is similar, but the engineer has been taken out of the data center and
    placed inside a remote work desk at an office or their own home. They still live
    fairly close to their data center or the cloud region containing the resources
    that they manage, but they differ from their predecessors in a couple of ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Their teams are likely scattered across their regions as opposed to being in
    a singular place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Their emphasis is now on what we call *predictive maintenance*, i.e. they do
    not wait for something to go wrong to respond.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Incident response teams
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This new trend of SRE also helped produce incident response teams, which can
    be quickly created from within the ranks of the DevOps team to monitor and deal
    with an incident. They can do so while communicating with stakeholders to keep
    them informed about the situation and finding the root cause of the incident.
    These teams also produce reports that can help the DevOps team deal with and mitigate
    such potential situations in the future. In a world where an outage of a few minutes
    can sometimes cause millions of dollars of loss and damage, incident response
    teams have become a prominent part of any DevOps engineer’s world.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usually, an incident response team is made up of the following members:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Incident commander** (**IC**): An incident commander leads the response to
    the incident and is responsible for a post-incident response plan'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Communications leader** (**CL**): A communications leader is the public-facing
    member of the team who is responsible for communicating the incident and the progress
    made to mitigate the incident to the stakeholders'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operations leader** (**OL**): Sometimes synonymous with the incident commander,
    the OL leads the technical resolution of the incident by looking at logs, errors,
    and metrics and figures out a way to bring the site or application back online'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Team members**: Team members under the CL and OL who are coordinated by their
    respective leaders for whatever purpose they may require'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 1.1 – A typical incident response team structure](img/B21320_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – A typical incident response team structure
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in *Figure 1**.1*, the structure of the incident response team
    is fairly simple and is usually quite effective in mitigating an incident when
    such a case arises. But what happens after the incident? Another incident? That’s
    a possibility and the fact that it’s a possibility is the exact reason we need
    to gain insight from the current incident. We do this with post-mortems.
  prefs: []
  type: TYPE_NORMAL
- en: Post-mortems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An incident happens. It affects business value and the users of the application,
    and then it goes away or is solved. But what’s to say it doesn’t happen again?
    What could be done to mitigate it before it even has the chance to happen again?
    Post-mortems are the answer to all of that. Any good DevOps team will perform
    a post-mortem after an incident has occurred. This post-mortem will be led by
    the incident response team that handled the situation.
  prefs: []
  type: TYPE_NORMAL
- en: Post-mortems sound macabre, but they are an essential part of the healing process
    and improvement of a workload and a DevOps team. They let the DevOps team understand
    the incident that occurred and how it happened, and they dissect the response
    made by the response team. Exercises such as these create a solid foundation for
    faster response times in the future as well as for learning experiences and team
    growth.
  prefs: []
  type: TYPE_NORMAL
- en: One of the aspects of post-mortems that is constantly emphasized is that they
    must be blameless, i.e., there mustn’t be any placing of responsibility for the
    cause of the incident upon an individual. If an incident has occurred, it is the
    process that must be modified, not the person. This approach creates an environment
    of openness and makes sure that the results of the post-mortem are factual, objective,
    and unbiased.
  prefs: []
  type: TYPE_NORMAL
- en: So, you may ask yourself, why go through all of this? The reason is often contractual
    and obligatory. In a modern technological landscape, things such as these are
    necessary and expected to deliver value and availability to the end user. So let’s
    understand exactly what that availability means.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding high availability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I’m not going to state Murphy’s Law a third time, but understand that it applies
    here as well. Things will go wrong and they will fall apart. Never forget that.
    One of the reasons DevOps as a concept and culture became so popular was that
    its techniques delivered a highly available product with very little downtime,
    maintenance time, and vulnerability to app-breaking errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the reasons DevOps succeeds in its mission for high availability is
    the ability to understand failure, react to failure, and recover from failure.
    Here’s a famous quote from Werner Vogel, the CTO of Amazon:'
  prefs: []
  type: TYPE_NORMAL
- en: Everything fails, all the time.
  prefs: []
  type: TYPE_NORMAL
- en: This is, in fact, the foundation of the best practice guides, tutorials, and
    documentation that AWS makes for DevOps operations, and it’s true. Sometimes,
    things fail because of a mistake that has been made. Sometimes, they fail because
    of circumstances that are completely out of our control, and sometimes, things
    fail for no reason. But the point is that things fail, and when they do, DevOps
    engineers need to deal with those failures. Additionally, they need to figure
    out how to deal with them as fast as possible with as little disturbance to the
    customer as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'A little advice for people who may have never worked on a solid project before,
    or at least been the guy facing the guy giving orders: *ask for specifics*. It’s
    one of the tenets of DevOps, Agile, and any other functional strategy and is vital
    to any sort of working relationship between all the stakeholders and participants
    of a project. If you tell people exactly what you want, and if you give them metrics
    that define that thing, it becomes easier to produce it. So, in DevOps, there
    are metrics and measurements that help define the requirements for the availability
    of services as well as agreements to maintain those services.'
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of acronyms, metrics, and indicators that are associated
    with high availability. These are going to be explored in this section and they
    will help define exactly what high availability means in a workload.
  prefs: []
  type: TYPE_NORMAL
- en: SLIs, SLOs, and SLAs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Agreements of service, terms of services, contracts, and many other types of
    agreements are designed so that two parties in agreement with one another can
    draw out that agreement and are then beholden to it. You need a contract when
    one party pays another for a service, when two parties exchange services, when
    one party agrees to a user agreement drawn up by the other party (ever read one
    of those?), and for a lot of other reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s break down what each of these are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Service level indicators** (**SLIs**): These are metrics that can be used
    to numerically define the level of service that is being provided by a product.
    For instance, if you were to run a website, you could use the uptime (the amount
    of time the website is available for service) as an SLI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service level objectives** (**SLOs**): These provide a specific number to
    the aforementioned SLIs. That number is an objective that the DevOps team must
    meet for their client. Going back to the previous example in the SLI definition:
    if uptime is the SLI, then having an uptime of 99% a month is the SLO. Typically,
    a month has 30 days, which is 720 hours, so the website should have a minimum
    uptime of 712.8 hours in that month with a tolerable downtime of 7.2 hours.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service level agreements** (**SLAs**): These are contracts that enforce an
    SLO. In an SLA, there is a defined SLO (hope you’re keeping up now) for an SLI
    which must be achieved by the DevOps team. If this SLA is not fulfilled, the party
    that contracted the DevOps team is entitled to some compensation. Concluding that
    example, if there is an SLA for that website with an SLO of 99% uptime, then that
    is defined in the agreement and that is the metric that needs to be fulfilled
    by the DevOps team. However, most SLAs have more than one SLO.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To put it simply, SLIs (are measured for) -> SLOs (are defined in) -> SLAs.
  prefs: []
  type: TYPE_NORMAL
- en: One of the more prominent examples of an SLA that the AWS team likes to show
    off is the 11 9s (99.999999999%) of durability for Amazon’s **Secure Storage Service**
    (**S3**) (other cloud object storage services do the same as well). This means
    that any S3 bucket loses one object every 10,000 years. It also has a 99.9% availability
    for its standard-tierSLA. This is equivalent to being down for 44 minutes out
    of a calendar month of 30 days.
  prefs: []
  type: TYPE_NORMAL
- en: Now, these three abbreviations are related to availability, but in an ancillary
    way. The next two abbreviations will be much more focused on what availability
    actually entails contractually and goal-wise.
  prefs: []
  type: TYPE_NORMAL
- en: RTOs and RPOs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These two abbreviations are much more availability-focused than the other three.
    **Recovery Time Objectives** (**RTOs**) and **Recovery Point Objectives** (**RPOs**)
    are used as measuring sticks to measure the borders of availability. If an application
    fails to fall within its RTO or RPO then it hasn’t fulfilled its guarantee of
    availability. RTOs and RPOs are largely concerned with recovering operations after
    a disaster. There are financial, medical, and other critical systems in this world
    that wouldn’t be able to function if their underlying systems went down for even
    a few minutes. And given the *everything fails all the time* motto, that disaster
    or failure is not unrealistic.
  prefs: []
  type: TYPE_NORMAL
- en: An RTO is placed on a service when there is a need for a service to constantly
    be up and the time used in RTO is the amount of time that a service can afford
    to be offline before it recovers and comes online again. The fulfillment of an
    RTO is defined in the SLA as the maximum time that a system will be down before
    it is available again. To be compliant with the SLA that the DevOps has, they
    must recover the system within that time frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you may think this is easy: just turn the thing on and off again, right?
    Well, in many cases that’ll do the job, but remember that this is not about just
    doing the job, it’s about doing the job within a set amount of time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In most cases, when a server goes down, restarting the server will do the trick.
    But how long does that trick take? If your RTO is five minutes and you take six
    minutes to restart your server, you have violated your RTO (and in a lot of critical
    enterprise systems, the RTO is lower than that). This is why, whenever you define
    RTOs initially, you should do two things: propose for more time than you have
    and think with automation.'
  prefs: []
  type: TYPE_NORMAL
- en: Modern SLAs of 99% (seven hours a month) or even 99.9% (44 minutes a month)
    are achieved through the removal of human interaction (specifically, hesitation)
    from the process of recovery. Services automatically recover through constant
    monitoring of their health so when an instance shows signs of unhealthiness, it
    can either be corrected or replaced. This concept is what gave rise to the popularity
    of Kubernetes which in its production form has the best recovery and health check
    concepts on the market.
  prefs: []
  type: TYPE_NORMAL
- en: RPOs are different in that they are largely related to data and define a specific
    date or time (point) which the data in a database or instance can be restored
    from. The RPO is the maximum tolerable difference of time between the present
    and the date of the backup or recovery point. For example, a database of users
    on a smaller internal application can have an RPO of one day. But a business-critical
    application may have an RPO of only a few minutes (if that).
  prefs: []
  type: TYPE_NORMAL
- en: RPOs are maintained through constant backups and replicas of databases. The
    database in most applications that you use isn’t the primary database but a **read
    replica** that is often placed in a different geographical region. This alleviates
    the load from the primary database, leaving it open for exclusive use for writing
    operations. If the database does go down, it can usually be recovered very quickly
    by promoting one of the read replicas into the new primary. The read will have
    all of the necessary data, so consistency is usually not a problem. In the event
    of a disaster in a data center, such backup and recovery options become very important
    for restoring system functions.
  prefs: []
  type: TYPE_NORMAL
- en: Based on these objectives and agreements, we can come up with metrics that can
    affect team behavior, like our next topic.
  prefs: []
  type: TYPE_NORMAL
- en: Error budgets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a team following DevOps principles, error budgets become a very important
    part of the direction that the team takes in the future. An error budget is calculated
    with this formula: *Error budget = 1-SLA (**in decimal)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'What this basically means is that *an error budget is the percentage left over
    from the SLA*. So, if there is an SLA of 99%, then the error budget would be 1%.
    It is the downtime to our uptime. In this case, the error budget per month would
    be around 7.2 hours. According to this budget, we can define how our team can
    progress based on team goals:'
  prefs: []
  type: TYPE_NORMAL
- en: If the team’s goal is reliability, then the objective should be to tighten the
    error budget. Doing this will help the team deliver a higher SLO and gain more
    trust from their customers. If you tighten an SLO from 99% to 99.9%, you are reducing
    the tolerable downtime from 7.2 hours to 44 minutes, so you need to ensure that
    you can deliver on such a promise. Inversely, if you cannot deliver on such an
    SLO, then you shouldn’t promise it in any sort of agreement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the team’s goal is developing new features, then it mustn’t come at the cost
    of a decreased SLO. If a large amount of the error budget is being consumed every
    month, then the team should pivot from working on new features to making the system
    more reliable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these statistics exist to help us have metrics that can be used to maintain
    high availability. But we aren’t the ones who will use them, we will simply configure
    them to be used automatically.
  prefs: []
  type: TYPE_NORMAL
- en: How to automate for high availability?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you know the rules of the game, you need to figure out how to work
    within the rules and deliver on the promises that you have given your customers.
    To accomplish this, you simply have to accomplish the things that have been set
    in your SLAs. Not particularly difficult on a small scale, but we’re not here
    to think small.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some essentials that every DevOps engineer needs to know to accomplish
    high availability:'
  prefs: []
  type: TYPE_NORMAL
- en: Using desired state configurations on virtual machines to prevent state drift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to properly backup data and recover it quickly in the event of a disaster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to automate recovery of servers and instances with minimal downtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to properly monitor workloads for signs of errors or disruptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to succeed, even when you fail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sounds easy, doesn’t it? Well, in a way it is. All these things are interconnected
    and woven into the fabric of DevOps and depend upon each other. To recover success
    from failure is one of the most important skills to learn in life, not just in
    DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: This concept of failure and recovering back to a successful state has been taken
    even further by the DevOps community through the development of tools that maintain
    the necessary state of the workload through code.
  prefs: []
  type: TYPE_NORMAL
- en: Delving into infrastructure as a code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, in a book about Python, we get to a section about code. So far, I’ve
    given you a lot of information about what needs to be accomplished but to accomplish
    the things we want especially in this book, we must have a method, a tool, a weapon,
    i.e., code.
  prefs: []
  type: TYPE_NORMAL
- en: Now the word “code” scares a lot of people in the tech industry, even developers.
    It’s weird being afraid of the thing that is under everything you work with. But
    that’s the reality sometimes. If you, dear reader, are such a person, first off,
    it’s a brave thing to purchase this book, and secondly, all you are doing is denying
    yourself the opportunity to solve all the problems you have in the world. Seriously.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the reason is that code is the weapon of choice in almost every situation.
    It is the solution to all your automation problems, monitoring problems, response
    problems, contract problems, and maybe other problems that you may have that I
    don’t know about. And a lot of it requires a minimal amount of code.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember this: the amateur writes no code, the novice writes a lot of code
    and the expert writes code in a way that it seems like they’ve written nothing
    at all, so expect a lot of code in this book.'
  prefs: []
  type: TYPE_NORMAL
- en: Let me explain further. To maintain the consistency of service required by DevOps,
    you need something constant; something that your resources can fall back on that
    they can use to maintain themselves to a standard. You can write code for that.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to that, you need to be able to automate repetitive tasks and tasks
    that require reactions faster than what a human being can provide. You need to
    free up your own time while also not wasting your client’s time. You can write
    code for that.
  prefs: []
  type: TYPE_NORMAL
- en: You also need to be flexible and capable of dynamically creating resources regardless
    of the change in environment as well as the ability to switch over to backups,
    failovers, and alternates seamlessly. You can write code for that.
  prefs: []
  type: TYPE_NORMAL
- en: '**Infrastructure as code** (**IaC**) is particularly useful for that last part.
    In fact, you can use it to encapsulate and formulate the other two as well. IaC
    is the orchestrator. It gives the cloud services a proverbial *shopping list*
    of things it wants and the configuration it wants them in and in exchange for
    that, and it gets the exact configuration that was coded on it.'
  prefs: []
  type: TYPE_NORMAL
- en: The fact that IaC is a *get-exactly-what-you-want* system is a word of caution
    because as with everything involving computers, it will do *exactly* what you
    want, which means you need to be very specific and precise when using these frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at a little sample that we will use to demonstrate the concept behind
    IaC using some simple pseudocode (without any of that pesky syntax).
  prefs: []
  type: TYPE_NORMAL
- en: Pseudocode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I’m not going to write any actual code for IaC in this chapter (you can find
    that in the chapter dedicated to IaC), I’m just going to give a quick overview
    of the concept behind IaC using some pseudocode definitions. These will help you
    understand how singular IaC definitions work in securing resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example pseudocode – to create a virtual machine - broken down into the
    simplest pieces would be something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Module Name` (Usually descriptive of the service being deployed)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VM Name` (say `VM1`)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Resources allocated` (Specifications, or class of VM) (say 1 GB RAM)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Internal networking and IP addresses (in `VPC1`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tags (say `"``Department": "Accounting"`)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: This example will create a VM named `VM1`, with 1 GB of RAM in a VPC or equivalent
    network named `VPC1` with a tag of key `Department` with an `Accounting` value.
    Once launched, that is exactly what will happen. Oops, I needed 2 GB of RAM. What
    do I do now?
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s easy, just change your code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Module Name` (Usually descriptive of the service being deployed)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VM Name` (say `VM1`)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Resources allocated` (Specifications, or class of VM) (now its 2GB RAM)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Internal networking and IP addresses (in `VPC1`)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tags (say `"``Department": "Accounting"`)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And that’s how easy that is. You can see why it’s popular. It is stable enough
    to be reliable, but flexible enough to be reusable. Now, here are a couple of
    other pointers that will help you understand how most IaC templates work:'
  prefs: []
  type: TYPE_NORMAL
- en: If you had renamed the VM, it would have been redeployed with the new name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you had renamed the module, most templates would by default tear down and
    decommission the old VM in the old module and create a new one from scratch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the network or VPC would logically move the VM to the other network
    whose network rules it would now follow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most templates would allow you to loop or iterate over multiple VMs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IaC, man what a concept. It’s a very interesting – and very popular – solution
    to a common problem. It can solve a lot of DevOps headaches and should be in the
    arsenal of every DevOps engineer.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of DevOps is exciting, vast, and has room to get creative. It is
    a discipline where the world is essentially at your command. Effective DevOps
    requires effective structure and adaptation of that structure to a challenge as
    we learned in our *Exploring* *automation* section.
  prefs: []
  type: TYPE_NORMAL
- en: But remember, *anything that can go wrong will go wrong*, so plan for success
    but prepare for the fact that failure is a common occurrence. In such cases of
    failure – as we learned in the sections about monitoring and event response –
    the ability to recover is what matters, and the speed of that recovery also matters
    quite often. If an incident to be recovered from is new, it must be reported and
    understood so that such incidents can be mitigated in the future.
  prefs: []
  type: TYPE_NORMAL
- en: And lastly, as we covered in *Delving into infrastructure as a code*, code is
    your friend. Be nice to your friends and play with them. You’ll learn how to in
    this book.
  prefs: []
  type: TYPE_NORMAL
