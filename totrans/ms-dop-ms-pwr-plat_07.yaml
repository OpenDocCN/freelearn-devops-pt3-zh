- en: <st c="0">7</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2">An Overview of DevSecOps in Power Platform</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="44">DevSecOps is a software development methodology that integrates security
    practices into the</st> <st c="137">whole</st> **<st c="143">software development
    life cycle</st>** <st c="174">(</st>**<st c="176">SDLC</st>**<st c="180">) from</st>
    <st c="187">requirement analysis, planning and design, development, and testing
    and quality assurance through deployment and maintenance.</st> <st c="314">The
    Power Platform is a modern application runtime platform that enables developers
    to build custom applications, automate workflows, create chatbots, design and
    publish websites, and more.</st> <st c="504">The platform has a robust security
    model that ensures data protection and compliance with industry standards (</st>*<st
    c="614">more than 90+ compliance certificates</st>*<st c="652">); application
    life cycle management and the DevOps processes established by Azure DevOps or
    GitHub partially consider by default this security infusion when they deal with
    any kind of</st> <st c="838">development projects.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="859">This chapter will cover the steps and actions that are essential
    for us to set up a secure DevOps development project with multiple environments
    and</st> **<st c="1009">Microsoft Entra ID</st>**<st c="1027">-backed identity
    and access management.</st> <st c="1068">We will also learn how we can use DevOps
    tools to spin up Power Platform-based development projects at scale, allowing
    developers and contributors to quickly build and deploy applications while maintaining
    security and compliance standards.</st> <st c="1309">The platform also provides
    static analysis tools and reports to monitor certain types of security threats.</st>
    <st c="1416">This helps us enable frictionless productivity while minimizing cyber
    risk.</st> <st c="1492">We will also cover the security implications regarding
    custom code with open source libraries and we will investigate our DevOps tools
    from a</st> <st c="1634">security perspective.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1655">In this chapter, we are going to cover the following</st> <st c="1709">main
    topics:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1721">What</st> <st c="1727">is DevSecOps?</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1740">Security model of</st> <st c="1759">Power Platform</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1773">Secret scanning and static code</st> <st c="1806">analysis tools</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1820">Solution checker</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1837">Spinning up DevSecOps projects</st> <st c="1869">at scale</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1877">Security of</st> <st c="1890">DevOps processes</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1906">Technical requirements</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1929">To delve into the details of DevSecOps approaches and tools, we
    need to have</st> <st c="2007">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="2021">A Power Platform subscription</st>**<st c="2051">: We can sign
    up for a Power Apps Developer Plan (</st>[<st c="2102">https://www.microsoft.com/en-us/power-platform/products/power-apps/free</st>](https://www.microsoft.com/en-us/power-platform/products/power-apps/free)<st
    c="2174">), if we already have a Microsoft Entra ID work account, or we can join
    the Microsoft 365 Developer</st> <st c="2275">Program (</st>[<st c="2284">https://developer.microsoft.com/en-us/microsoft-365/dev-program</st>](https://developer.microsoft.com/en-us/microsoft-365/dev-program)<st
    c="2348">)</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="2350">An Azure DevOps services organization</st>**<st c="2387">: We
    can create a DevOps organization any time for</st> <st c="2439">free (</st>[<st
    c="2445">https://learn.microsoft.com/en-us/azure/devops/user-guide/sign-up-invite-teammates</st>](https://learn.microsoft.com/en-us/azure/devops/user-guide/sign-up-invite-teammates)<st
    c="2528">).</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="2531">A GitHub handle and a public</st>** **<st c="2561">repository</st>**<st
    c="2571">:</st> [<st c="2574">https://github.com/signup</st>](https://github.com/signup)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="2599">GitHub Advanced Security</st>**<st c="2624">: This is available
    free for public repositories;</st> <st c="2675">see</st> [<st c="2679">https://docs.github.com/en/get-started/learning-about-github/about-github-advanced-security#about-advanced-security-features</st>](https://docs.github.com/en/get-started/learning-about-github/about-github-advanced-security#about-advanced-security-features)<st
    c="2803">.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="2804">Samples and walk-throughs</st>** <st c="2830">discussed in this
    chapter are located</st> <st c="2869">under</st> [<st c="2875">https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/tree/main/Chapter07</st>](https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/tree/main/Chapter07)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="2974">What is DevSecOps?</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**<st c="2993">DevSecOps</st>** <st c="3003">stands</st> <st c="3010">for</st>
    **<st c="3015">development, security, and operations</st>** <st c="3052">and the
    collaboration of these areas to deliver secure applications.</st> <st c="3122">Its
    principles were established shortly after defining the DevOps process and methodology.</st>
    <st c="3213">The idea is the same, applying the</st> **<st c="3248">shift-left</st>**
    <st c="3258">mindset in</st> <st c="3270">security in an analogous way to how
    we have applied the shift-left mindset in quality assurance and later in operations.</st>
    <st c="3391">It is a framework that integrates security into all phases of the
    SDLC and, in that sense, it is an evolution in the way software development organizations
    approach security by introducing a security-first mindset culture and automating
    security into every phase of the software development life cycle from design to
    delivery.</st> <st c="3718">Organizations</st> <st c="3732">widely adopt this
    approach to reduce the risk of releasing code with security vulnerabilities to
    avoid not just reputation loss but also the high financial impacts of</st> <st
    c="3899">such failures.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="3913">If we look back at the main phases of the SDLC that we learned
    about in</st> [*<st c="3986">Chapter 1</st>*](B22208_01.xhtml#_idTextAnchor014)
    <st c="3995">(requirement analysis, planning and design, development, testing
    and quality assurance, deployment, and maintenance), then we can map the security
    activities and automations to those phases, as the following</st> <st c="4204">figure
    shows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Security in SDLC](img/B22208_07_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="4873">Figure 7.1 – Security in SDLC</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4902">These steps and activities</st> <st c="4930">and their continuous
    improvements build up the</st> **<st c="4977">security development life cycle</st>**
    <st c="5008">(</st>**<st c="5010">SDL</st>**<st c="5013">).</st> <st c="5017">The
    SDL is a</st> <st c="5030">software development process that helps developers
    build and design more secure software that addresses security compliance requirements
    while reducing development costs.</st> <st c="5201">It standardizes security best
    practices across services and results in delivering more</st> <st c="5288">secure
    products.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5304">Let us have a look at these activities in detail going through
    the SDLC and, respectively, the</st> <st c="5400">security scopes.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5416">Setup</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="5422">During the</st> <st c="5433">initial phase of the project, we focus
    on two major</st> <st c="5486">security topics:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="5502">Inventory Management</st>** <st c="5523">is one</st> <st c="5531">of
    the key elements of security because this catalogizes the applications and services
    we provide for our customers.</st> <st c="5648">It is our</st> **<st c="5658">app
    catalog</st>** <st c="5669">that</st> <st c="5674">contains</st> <st c="5684">our
    applications (</st>**<st c="5702">products</st>**<st c="5711">) and</st> <st c="5718">services
    (</st>**<st c="5728">service trees</st>**<st c="5742">) in production and their
    assets (source code location, released binaries, version numbers, Azure DevOps
    projects, Azure pipelines, GitHub projects, GitHub workflows, etc.) within our
    organization.</st> <st c="5941">With the help of Inventory Management, we can
    easily find the application owners of the impacted components in the case of security
    breaches.</st> <st c="6083">Inventory Management is fully automated in organizations
    with mature DevSecOps processes, which means every time a new project is kicked
    off, a new catalog item is created that triggers workflows to spin up Azure DevOps
    or GitHub projects, Git repositories, Microsoft Entra ID groups, service principals,
    self-hosted agents, pipelines, and</st> <st c="6423">so on.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="6429">Access control management</st>** <st c="6455">refers</st> <st
    c="6462">to the access to the application artifacts and, respectively, the underlying
    DevOps tools from an engineering perspective.</st> <st c="6586">We need to define
    the framework</st> <st c="6617">and the</st> **<st c="6626">identity and access
    management</st>** <st c="6656">(</st>**<st c="6658">IAM</st>**<st c="6661">) solution
    that we will use to give access to product owners, engineers, testers, architects,
    release managers, and ops teams while they interact with development projects.</st>
    <st c="6835">We also need to define how we are going to deal with conditional
    access policies, such as</st> <st c="6924">enforcing</st> **<st c="6935">multi-factor
    authentication</st>** <st c="6962">(</st>**<st c="6964">MFA</st>**<st c="6967">)
    when accessing production environments, and to which extent we are going to work
    with privileged identities</st> <st c="7077">in</st> **<st c="7081">privileged
    identity management</st>** <st c="7111">(</st>**<st c="7113">PIM</st>**<st c="7116">),
    for instance, to provide just-in-time privileged access to Microsoft Entra ID
    and Azure resources for high privileged users or global administrators.</st> <st
    c="7270">When PIM is enabled, these highly privileged activities are monitored
    and</st> <st c="7344">audited, too.</st> <st c="7358">It is worth noting that
    this access control is not the one that our application or service to be developed
    will use for authentication</st> <st c="7493">and authorization.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="7511">Plan and Design</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="7527">After</st> <st c="7533">setting up the project with the appropriate
    access rights and Inventory Management in place, we delve into the</st> *<st c="7645">Plan
    and Design</st>* <st c="7660">phase from a</st> <st c="7674">security perspective:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="7695">Threat modeling</st>** <st c="7711">is</st> <st c="7715">used
    to identify threats to our systems through the view of potential attackers and
    their probabilities and impacts on our applications before implementing any mitigation.</st>
    <st c="7887">It is a typical risk management process focusing on security.</st>
    <st c="7949">There are several tools available on the market to model threats,
    such as</st> <st c="8022">the</st> **<st c="8027">Microsoft Threat Modeling Tool</st>**
    <st c="8057">(see the</st> *<st c="8067">Further reading</st>* <st c="8082">section).</st>
    <st c="8093">As part of the sprint planning process, we can conduct threat modeling
    exercises, and, based on the risk analysis, we can decide whether we should mitigate
    certain threats and introduce those activities as product backlog items marked
    with the</st> <st c="8337">security category.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="8730">SecureString</st>` <st c="8742">type to handle credentials in</st>
    <st c="8773">our code.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="8782">The peer review guide</st>** <st c="8804">is</st> <st c="8808">used
    to lay down the peer review process: when and how often they will be executed
    and whether we will involve security experts in the process or not.</st> <st c="8959">Nowadays,
    DevOps processes already prescribe code reviews in case of any pull requests,
    and DevOps tools support and document the findings</st> <st c="9098">in detail.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="9108">Pre-commit hooks</st>** <st c="9125">define</st> <st c="9132">what
    kind of security checks we perform before committing code changes to repositories,
    for instance, checking commits for secrets before they reach our repositories.</st>
    <st c="9300">Pre-commit hooks can execute only a small subset of static code analysis
    rulesets because of time constraints, but they are</st> <st c="9424">essential
    parts to immediately block commits to prevent security breaches.</st> <st c="9499">We
    can</st> <st c="9505">use</st> **<st c="9510">IDE security plugins</st>** <st
    c="9530">to execute lightweight security</st> <st c="9563">analysis locally.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="9580">Commit (CI)</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="9592">After passing the</st> <st c="9610">pre-commit hooks and code review
    results, the next phase is to execute the CI build and the related security activities
    as part of the pull request</st> <st c="9759">validation process:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="9778">Dependency management</st>**<st c="9800">: Nowadays, custom-developed
    applications heavily rely on</st> <st c="9859">open source packages.</st> <st
    c="9881">On average, 90% of the code in current applications contains components
    based on external packages or</st> <st c="9982">libraries.</st> <st c="9994">The
    term</st> **<st c="10003">software supply chain management</st>** <st c="10035">is
    very often used, since those packages that we use in our applications also use
    other third-party components that also use other packages, and the chain goes
    on in that way.</st> <st c="10212">Identifying and exposing vulnerabilities in
    those third-party packages makes our applications vulnerable unless we refresh
    our supply chain.</st> <st c="10353">Tools such as</st> **<st c="10367">GitHub
    Dependabot</st>** <st c="10384">can</st> <st c="10388">identify the vulnerabilities
    in our supply chain (</st>*<st c="10439">inherited vulnerabilities</st>*<st c="10465">)
    and automatically create Dependabot alerts with pull requests to submit the changes
    back to our main branches.</st> <st c="10579">Dependabot checks can be executed
    during</st> <st c="10620">CI builds.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="10630">Static application security testing</st>** <st c="10666">(</st>**<st
    c="10668">SAST</st>**<st c="10672">): This is static code analysis and code scanning</st>
    <st c="10723">for security.</st> <st c="10737">There are several tools available
    on the market that we can use to perform such analyses on our code base, such
    as SonarCloud, Fortify, or GitHub Advanced Security with CodeQL.</st> <st c="10914">These
    tools can be integrated into our CI pipelines for further customization.</st>
    <st c="10993">The output of static code analysis results are</st> **<st c="11040">Static
    Analysis Results Interchange Format</st>** <st c="11082">(</st>**<st c="11084">SARIF</st>**<st
    c="11089">) open standard data.</st> <st c="11112">Code scanning alerts</st> <st
    c="11132">are automatically created based on SARIF results and they can be tracked
    as backlog items.</st> <st c="11224">In the case of the GitHub Enterprise version
    with Advanced Security, we have also the possibility to use GitHub Copilot to
    fix our security issues</st> <st c="11371">fully automated.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="11387">Security unit and functional testing</st>**<st c="11424">:
    These are other ways to maintain the high quality of our code base and to avoid
    implementing</st> <st c="11520">security vulnerabilities.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="11545">Secure pipelines</st>**<st c="11562">: We need to cautiously
    care about our automated pipelines from a security point of view: who can access
    which pipeline, where the pipeline secrets are stored (Azure Key Vault), and whether
    we can use managed identities to execute workflows because insecure CI/CD pipelines
    can lead to credential leakage or even to execute malicious code in production
    environments.</st> <st c="11930">During</st> <st c="11936">CI builds, so-called</st>
    **<st c="11958">software bills of materials</st>** <st c="11985">(</st>**<st c="11987">SBOMs</st>**<st
    c="11992">) are created to track the components used in the build pipeline.</st>
    <st c="12059">An SBOM is a list of software components with their hierarchical
    relationships, version numbers, dependencies, and license requirements, usually
    in JSON format, that</st> <st c="12225">build up the application.</st> <st c="12251">SBOMs
    help with the transparency and provenance claims for our supply chain and help
    with conformance enablement.</st> <st c="12365">Hosted pools can be used to build
    and sign the code, ensuring build integrity and component governance.</st> <st
    c="12469">After a successful build, the code is stored in a secure</st> <st c="12526">artifact
    storage.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="12543">Credential scanning</st>**<st c="12563">: We</st> <st c="12568">can
    use tools to scan our code base for plain text credentials to lower the risk of</st>
    <st c="12653">credential stealing.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="12673">Deploy (CD)</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="12685">In this stage, we</st> <st c="12703">look at the overall health
    of the code base, in addition to the items checked in the Commit stage (which
    can be repeated in the deploy stage as well).</st> <st c="12855">We introduce
    additional security checks during the</st> <st c="12906">release process:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="12922">Dynamic application security testing</st>** <st c="12959">(</st>**<st
    c="12961">DAST</st>**<st c="12965">) is a technique used to evaluate</st> <st
    c="12999">the security of a software application in its running state.</st> <st
    c="13061">It involves the use of DAST tools to conduct simulated cyber-attacks
    on web applications while they are operational, identifying vulnerabilities such
    as SQL injection, cross-site scripting, and insecure configurations.</st> <st
    c="13280">This form of security testing emulates the actions of a malicious attacker
    to uncover security weaknesses within the live application, enabling developers
    to address these issues prior to the application’s release to</st> <st c="13497">the
    public.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="13508">Cloud configuration validation</st>** <st c="13539">is the
    process of verifying that the configuration</st> <st c="13590">of cloud resources
    is correct, secure, and compliant with best practices and policies.</st> <st c="13678">This
    can be done through automated tools that scan the configuration files and settings
    of cloud resources and report any issues or violations (such as configuration
    changes in production, and discrepancies between</st> <st c="13893">the IaC scripts
    and the running configuration).</st> <st c="13941">Validation can help prevent
    misconfigurations, security vulnerabilities, and compliance issues, and ensure
    that cloud resources are set up and</st> <st c="14084">managed correctly.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="14102">Infrastructure-as-code</st>** <st c="14125">(</st>**<st c="14127">IaC</st>**<st
    c="14130">)</st> **<st c="14133">scanning</st>** <st c="14141">is the process
    of analyzing IaC files for</st> <st c="14183">security vulnerabilities, misconfigurations,
    and compliance with best practices and policies.</st> <st c="14278">IaC scanning
    tools can detect policy violations and suggest fixes for any violations detected.</st>
    <st c="14373">Even LLM-based tools can be used to prompt a GPT-4 model to detect
    policy violations in IaC files and suggest fixes for any violation detections.</st>
    <st c="14519">The violations and fixes are reported in a</st> <st c="14562">SARIF
    file.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="14573">Security acceptance testing</st>** <st c="14601">is the process
    of verifying that a system meets the defined</st> <st c="14661">security requirements
    and standards before it is released or deployed.</st> <st c="14733">This type
    of testing is typically performed on new systems, upgrades, or deployments and
    includes the testing of information security requirements and adherence to secure
    system development practices.</st> <st c="14934">Acceptance testing activities
    may be performed on individual components or integrated systems, and validation
    activities may be performed using test environments to ensure that the system
    will not introduce vulnerabilities.</st> <st c="15158">Care must be taken when
    selecting test data or data from information systems that are operational to ensure
    that no personally identifiable information, secret data such as passwords, or
    hashes are captured in</st> <st c="15368">that dataset.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="15381">After successful deployments to test and later to production environments,
    the SBOM and evidence storage are used to track</st> <st c="15505">the releases.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15518">Operate and Monitor</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="15538">In this stage, after</st> <st c="15560">successfully releasing
    our application to production, we need to focus on the following</st> <st c="15648">security-infused
    activities:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="15676">Continuous monitoring</st>** <st c="15698">is</st> <st c="15702">the
    process of continuously tracking, assessing, and reviewing the security controls
    and risks of an information system.</st> <st c="15823">This process helps to ensure
    that the security controls remain effective over time and that any changes to
    the system or its environment do not introduce new vulnerabilities.</st> <st c="15998">Continuous
    monitoring can be achieved by automated tools and processes that collect and analyze
    data from various sources, such as logs, network traffic, and system configurations.</st>
    <st c="16179">This data is then used to identify potential security issues and
    to generate alerts or reports that can be used to improve the security of</st>
    <st c="16318">the system.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="16329">Audit logs</st>** <st c="16340">are</st> <st c="16345">monitored
    for security detections.</st> <st c="16380">Admin monitoring and scanning are
    performed to ensure the security of the system.</st> <st c="16462">We can consider
    the audit logs of our solutions, as our DevOps tools as well.</st> <st c="16540">Audit
    logs are essential to understand and detect changes that might come from</st>
    <st c="16619">suspicious sources.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="16638">Threat intelligence</st>** <st c="16658">is the</st> <st c="16665">practice
    of collecting, analyzing, and disseminating information about current and potential
    cybersecurity threats.</st> <st c="16782">It assists organizations in proactively
    detecting and addressing security threats.</st> <st c="16865">Microsoft Threat
    Intelligence is a cloud service that uses machine learning algorithms on the collected
    signals globally to detect and mitigate security risks.</st> <st c="17025">This
    infrastructure is used to support Azure services, traditional products, endpoints
    (devices), and other corporate assets.</st> <st c="17151">It is designed to protect
    the global infrastructure that powers services such as Microsoft Azure and Power
    Platform.</st> **<st c="17268">Security incident and event management</st>** <st
    c="17306">(</st>**<st c="17308">SIEM</st>**<st c="17312">) tools, such</st> <st
    c="17327">as Microsoft Sentinel or Microsoft Defender for Cloud, use audit logs
    to detect anomalies and unusual patterns by leveraging different machine</st>
    <st c="17470">learning algorithms.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="17490">Blameless post-mortems</st>** <st c="17513">are the process
    of analyzing incidents or failures in a non-punitive</st> <st c="17582">manner,
    with the goal of identifying the root causes and improving systems and processes
    to prevent similar incidents from happening again.</st> <st c="17723">The focus
    is on learning and improving, rather than assigning blame or punishment.</st>
    <st c="17806">Blameless post-mortems encourage open and honest communication,
    allowing team members to share their mistakes and learn from them</st> <st c="17935">without
    fear of retribution.</st> <st c="17965">This approach fosters a culture of continuous
    improvement and helps teams to build more</st> <st c="18053">resilient systems.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="18071">We will see in the upcoming sections which of these activities
    we can apply for Power Platform solutions and which of these tasks are provided
    by the ops teams of the Power Platform</st> <st c="18254">SaaS offering.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18268">Let’s now move on to the security model of Power Platform and
    learn about its security design</st> <st c="18363">and principles.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18378">Security model of Power Platform</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="18411">Microsoft Power Platform runs on</st> <st c="18445">Microsoft
    Azure, and it benefits from all the security PaaS services available in the hyperscaler,
    such as Microsoft Sentinel, Microsoft Defender for Cloud, the comprehensive audit
    logs of Microsoft Entra, and</st> <st c="18655">much more.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18665">The</st> <st c="18670">security model of Microsoft Power Platform
    is built on the principle of</st> **<st c="18742">least privileged access</st>**
    <st c="18765">(</st>**<st c="18767">LPA</st>**<st c="18770">), which</st> <st
    c="18779">facilitates the creation of applications with finer access control levels.</st>
    <st c="18855">Power Platform leverages the Microsoft Identity Platform for the
    authorization of all API requests, utilizing the widely recognized OAuth 2.0 protocol.</st>
    <st c="19007">Additionally, Dataverse, which serves as the foundational data layer
    for Power Platform, boasts a comprehensive security model that encompasses security
    at the environmental level, role-based, and record- and field-level security,
    security roles, and business units and teams through security groups and application
    users, as we learned about in</st> [*<st c="19353">Chapter 4</st>*](B22208_04.xhtml#_idTextAnchor074)<st
    c="19362">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19363">Additionally, Power Platform is built in distinct environments,
    which are containers of our apps, flows, connections, and other components along
    with security and data access management capabilities in geographic locations
    defined at the creation of</st> <st c="19614">those environments.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19633">The architecture of Power Platform is based on the zero-trust
    security principle, the</st> *<st c="19720">never trust, always verify</st>* <st
    c="19746">philosophy.</st> <st c="19759">A</st> **<st c="19761">zero-trust strategy</st>**
    <st c="19780">prescribes strict identity verification for every user and</st>
    <st c="19840">device regardless of their location (corporate or external perimeter),
    and this check happens every time corporate resources are to be accessed.</st>
    <st c="19985">This approach is realized with the help of Microsoft Identity Platform
    and the capabilities of Microsoft Entra ID.</st> <st c="20100">Every call going
    to Power Platform service endpoints requires a valid access token (bearer token)
    to get that endpoint executed.</st> <st c="20229">On the server side, the access
    token is sent to the identity provider (to Microsoft Entra ID to check its validity)
    every time a request hits the endpoints.</st> <st c="20386">These digitally signed
    access tokens contain claims about the caller that are used for authentication
    and authorization purposes.</st> <st c="20516">After identifying our caller, Power
    Platform will determine its authorization level in conjunction with that endpoint.</st>
    <st c="20635">Here, custom and built-in security roles, the business unit hierarchy,
    and team assignments are considered</st> <st c="20742">application-level authorizations.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20775">The following figure</st> <st c="20797">shows the architecture
    of Power Platform within one Microsoft</st> <st c="20859">Azure region:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Power Platform architecture](img/B22208_07_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="21283">Figure 7.2 – Power Platform architecture</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="21323">A cluster of web</st> <st c="21341">frontend servers contains
    ASP.NET sites hosted within the Azure App Service Environment.</st> <st c="21430">An
    App Service Environment</st> <st c="21456">provides the underlying, dedicated
    compute units on which App Service Plans are deployed.</st> <st c="21547">App
    Service Plans can host one or more applications (websites).</st> <st c="21611">These
    are part of Azure App Service.</st> <st c="21648">When accessing a Power Platform
    service or app, the client’s DNS is used to direct the request to the closest
    data center, as determined by Azure Traffic Manager.</st> <st c="21811">Azure
    Traffic Manager provides several options for routing and load-balancing at layer
    4 in the OSI model, such as performance routing (closest endpoint by latency),
    weighted round-robin, and geography-based routing (closest endpoint by</st> <st
    c="22048">geographical location).</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22071">The frontend cluster is responsible for handling the sign-in and
    authentication process.</st> <st c="22161">Once a user is verified, they receive
    a Microsoft Entra ID access token (OAuth2 token).</st> <st c="22249">The ASP.NET
    system examines the token to identify the user’s organization (Azure App Registrations
    are used internally with the account type</st> *<st c="22390">Multitenant</st>*
    <st c="22401">behind the scene).</st> <st c="22421">It then communicates with
    the Power Platform global backend service to inform the browser of the specific
    backend cluster where the organization’s tenant resides.</st> <st c="22584">All
    further interactions between the client and the backend cluster happen directly,
    bypassing the</st> <st c="22683">web frontend.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22696">For static resources such as JavaScript, CSS, and image files,
    the browser typically retrieves them</st> <st c="22797">from</st> **<st c="22802">Azure
    Content Delivery</st>** **<st c="22825">Network</st>** <st c="22832">(</st>**<st
    c="22834">CDN</st>**<st c="22837">).</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="22840">The backbone of</st> <st c="22857">Power Platform services is
    running</st> <st c="22891">in the</st> **<st c="22899">backend clusters</st>**<st
    c="22915">, which provide service endpoints, background services, databases, caches,
    and various other elements.</st> <st c="23018">The backend clusters span numerous
    Azure regions.</st> <st c="23068">A single region may accommodate multiple clusters
    (represented as</st> **<st c="23134">Scale Group</st>** <st c="23145">in the previous
    figure), enabling the Power Platform services to scale horizontally beyond the
    vertical and horizontal scaling capacities of an</st> <st c="23290">individual
    cluster.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="23309">These backend clusters are designed to be</st> *<st c="23352">stateful</st>*<st
    c="23360">, hosting the complete dataset for all the tenants they serve.</st>
    <st c="23423">The specific cluster storing a tenant’s data is known as that tenant’s
    primary cluster.</st> <st c="23511">The Power Platform global backend service
    provides details about a user’s primary cluster to the web frontend cluster, which
    then directs requests to the appropriate home backend cluster.</st> *<st c="23699">Every
    environment resides within a scale group</st>*<st c="23745">, which is a collective
    infrastructure designed to offer a scalable and maintainable set of resources.</st>
    <st c="23848">A scale group accommodates numerous customer organizations, each
    possessing its own database while sharing the service infrastructure.</st> <st
    c="23983">This setup leverages a variety of Azure services, such as Azure SQL,
    Azure Virtual Machines, and Azure Cache for Redis.</st> <st c="24103">These scale
    groups are established in pairs corresponding to the region chosen by the customer.</st>
    <st c="24199">For instance, opting for the United States as the region results
    in the formation of scale groups in both the West US and East US regions.</st>
    <st c="24338">While tenant metadata and data typically reside within the cluster,
    there is an exception for data replication to a secondary backend cluster located
    in a paired region within the same Azure geography.</st> <st c="24540">This secondary
    cluster acts as a contingency during regional disruptions, remaining inactive
    otherwise.</st> <st c="24644">Additionally, microservices dispersed across various
    machines within the cluster’s virtual network contribute to the</st> <st c="24761">backend’s
    functionality.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="24785">DevSecOps processes and activities are realized and operated by
    the Power Platform product teams, and we embrace those as part</st> <st c="24913">of
    this</st> **<st c="24921">Software-as-a-Service</st>** <st c="24942">(</st>**<st
    c="24944">SaaS</st>**<st c="24948">) offering.</st> <st c="24961">This means that
    the product engineering teams have established controls and guardrails starting
    with Inventory Management, access control, pre-commit hooks, peer review, SAST
    and DAST analysis, secure pipelines, IaC scanning, and dependency analysis through
    threat intelligence on their development processes.</st> <st c="25271">This approach
    is audited and certified by third-party independent auditors on a regular basis.</st>
    <st c="25366">During the development process, these teams use Microsoft SDL for
    coding best practices and threat modeling, too.</st> <st c="25480">This leads
    to the conclusion that we need to focus on only the customization and extensibility
    points of the platform since these are the</st> <st c="25617">places where we
    can introduce</st> <st c="25648">vulnerabilities in our solutions.</st> <st c="25682">These
    include but not limited to</st> <st c="25715">the following:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="25729">Environment</st> <st c="25742">access management</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="25759">Custom-developed</st> **<st c="25777">Power Apps Component Framework</st>**
    <st c="25807">(</st>**<st c="25809">PCF</st>**<st c="25812">) components</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="25825">Dataverse custom workflow activities and Dataverse web resources
    (HTML</st> <st c="25897">and JavaScript)</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="25912">Dataverse configurations and Dataverse</st> <st c="25952">custom-developed
    plugins</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="25976">Power</st> <st c="25983">Fx expressions</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="25997">Power Pages custom code (HTML, JavaScript,</st> <st c="26041">and
    Liquid)</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="26052">Our own DevOps processes with automation scripts</st> <st c="26102">for
    CI/CD</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="26111">Solution and</st> <st c="26125">Inventory Management</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="26145">Fusion architecture components in</st> <st c="26180">Microsoft
    Azure</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="26195">After understanding the security model of Power Platform and the
    benefits of this SaaS product from a security perspective, let us learn more about
    the tools we can use for static code analysis, dependency checks, and</st> <st
    c="26414">secret scanning.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="26430">Secret scanning and static code analysis tools</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="26477">Although there are many other SAST tools on the market,</st> **<st
    c="26534">GitHub Advanced Security</st>** <st c="26558">(</st>**<st c="26560">GHAS</st>**<st
    c="26564">) provides</st> <st c="26576">the most comprehensive feature set for
    static security code analysis together with Copilot security support.</st> <st
    c="26685">GHAS features</st> <st c="26699">are the following for private</st>
    <st c="26729">GitHub repositories:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="26749">Code scanning</st>** <st c="26763">uses</st> **<st c="26769">CodeQL</st>**
    <st c="26775">or other</st> <st c="26785">tools of your flavor to find vulnerabilities</st>
    <st c="26830">and coding errors.</st> <st c="26849">Results are stored in SARIF
    format, and they are managed at a repository level</st> <st c="26928">in GitHub.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="26938">CodeQL CLI</st>** <st c="26949">is a standalone</st> <st c="26965">tool
    that we can use to scan our code base for vulnerabilities and coding errors.</st>
    <st c="27048">The</st> **<st c="27052">CodeQL CLI</st>** <st c="27062">is used
    in conjunction with the previous point (code scanning), or we can use it in other
    DevOps tools, such as GitLab</st> <st c="27182">or Jenkins.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="27193">Secret scanning</st>** <st c="27209">looks</st> <st c="27216">for
    secrets, keys, and sensitive tokens in your code base.</st> **<st c="27275">Pre-commit
    hooks</st>** <st c="27291">are also available to block local commits</st> <st
    c="27334">before reaching the repository and creating a new</st> <st c="27384">history
    record.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="27399">Custom auto-triage rules</st>** <st c="27424">assist</st> <st
    c="27431">in orchestrating</st> <st c="27448">your</st> **<st c="27454">Dependabot
    alerts</st>** <st c="27471">on a large scale.</st> <st c="27490">With custom auto-triage
    rules, you can determine which alerts to disregard, postpone, or initiate a Dependabot
    security</st> <st c="27610">update for.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="27621">Dependency review</st>** <st c="27639">helps us</st> <st c="27649">to
    catch insecure dependencies before we introduce them</st> <st c="27704">in our
    repositories, and provides information on licenses, dependents, and age</st> <st
    c="27784">of dependencies.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="27800">These advanced security features are available in every public
    GitHub repository without any</st> <st c="27894">additional fee.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="27909">GHAS for Azure DevOps became generally available in September
    2023\.</st> <st c="27978">The same code scanning, secret scanning, and dependency
    scanning features are available in this product as in GitHub Enterprise.</st>
    <st c="28107">The GitHub engineering team has shared this feature set with Azure
    DevOps teams in the same way as, a few years ago, the Azure DevOps team provided
    the build agent (hosted runners) functionality to the GitHub</st> <st c="28316">product
    group.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="28330">Which tool, when?</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="28348">We can use GHAS for Azure DevOps only for Azure Git repositories.</st>
    <st c="28415">If we have a GitHub repository attached to Azure DevOps pipelines,
    we need to use GHAS on the GitHub side.</st> <st c="28522">Build tasks for GHAS
    for Azure DevOps will</st> <st c="28565">not work.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="28574">GHAS is based on</st> <st c="28592">the</st> **<st c="28596">Code
    Query Language</st>** <st c="28615">(</st>**<st c="28617">CodeQL</st>**<st c="28623">),
    which can be used to build up code analysis databases on different programming
    languages.</st> <st c="28717">CodeQL supports C, C++, C#, Java, Go, Kotlin, JavaScript,
    Python, Ruby, Swift and TypeScript.</st> <st c="28811">CodeQL approaches code
    as data, enabling the discovery of potential security flaws with more assurance
    than conventional static analysis tools.</st> <st c="28955">By creating a CodeQL
    database that mirrors your code base, you can execute CodeQL queries against this
    database to pinpoint issues within your code.</st> <st c="29104">The query results
    are shown as</st> *<st c="29135">code scanning alerts</st>* <st c="29155">in GitHub
    and Azure DevOps when you use CodeQL with</st> <st c="29208">code scanning.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="29222">CodeQL creates a relational database under the hood.</st> <st
    c="29276">Every language has its own schema and CodeQL</st> <st c="29321">uses</st>
    **<st c="29326">extractors</st>** <st c="29336">(unique for every language) to
    read the code files and compiled binaries (except for script languages) and builds
    up a hierarchical representation of code expressions, abstract syntax tree, data
    flow graph, and control flow graph.</st> <st c="29568">These building blocks are
    stored in the database and security queries are executed against these tables
    to find language-specific vulnerabilities and coding errors.</st> <st c="29733">CodeQL’s
    databases are snapshots taken from the time when we executed the analysis.</st>
    <st c="29817">GitHub provides query packs for any supported languages.</st> **<st
    c="29874">Query packs</st>** <st c="29885">consist</st> <st c="29893">of</st>
    **<st c="29897">CodeQL suites</st>** <st c="29910">(</st>**<st c="29912">qls</st>**<st
    c="29915">) that</st> <st c="29922">are sets of query language files (</st>**<st
    c="29957">ql files</st>**<st c="29966">).</st> <st c="29970">These query suites
    help us to immediately benefit from the security knowledge and expertise of GitHub
    and to get these code scanning rules executed on our code base.</st> <st c="30136">We
    can also write our own queries using Visual Studio Code and the CodeQL extension
    and we can derive from existing query suites to introduce our additional checks
    (the Windows Driver Validation Team did this to introduce their own custom</st>
    <st c="30375">rules:</st> [<st c="30381">https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/static-tools-and-codeql</st>](https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/static-tools-and-codeql)<st
    c="30471">).</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30474">The CodeQL CLI is part of the GHAS offering, and it is free of
    charge for students and academics.</st> <st c="30573">CodeQL CLI as a standalone
    tool supports macOS, Linux, and Windows operating systems and we can download
    it as binaries (see the link in</st> *<st c="30710">Further reading</st>*<st c="30725">).</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30728">We can use the CodeQL CLI to execute code analysis even locally,
    on our Azure DevOps build agents, or on our</st> <st c="30838">GitHub runners.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="30853">Both Azure DevOps and GitHub offer build tasks and actions around
    the CodeQL CLI to easily integrate code scanning capabilities in our existing
    pipelines</st> <st c="31008">and workflows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – CodeQL CLI wrappers in DevOps tools](img/B22208_07_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="31065">Figure 7.3 – CodeQL CLI wrappers in DevOps tools</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31113">Since</st> <st c="31120">there are numerous places in Power Platform
    where we can introduce custom code, it is recommended to have firsthand knowledge
    of how to use the CodeQL CLI and how to set up pipelines and workflows to execute
    the different query packs.</st> <st c="31355">The best place to</st> [<st c="31373">fin</st><st
    c="31376">d custom code for Power Platform is the</st> `<st c="31417">Pow</st>`](https://github.com/microsoft/PowerApps-Samples)`<st
    c="31420">erApps-Samples</st>` <st c="31435">repository at</st> [<st c="31450">https://github.com/microsoft/PowerApps-Samples</st>](https://github.com/microsoft/PowerApps-Samples)<st
    c="31496">. Let us check the custom</st> `<st c="31629">runcodeql_javascript.ps1</st>`
    <st c="31654">in the GitHub repo of</st> <st c="31677">this chapter):</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="31691">We can download the CodeQL CLI binaries (see</st> *<st c="31737">Further
    reading</st>* <st c="31752">|</st> *<st c="31755">CodeQL CLI Binaries</st>*<st
    c="31774">) and add the unpacked folder location to our</st> <st c="31821">environment
    path.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="31838">We then clone the repo and navigate to the</st> <st c="31882">target
    folder:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="31953">Let us download the query pack for JavaScript</st> <st c="32000">and
    TypeScript:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="32097">Let us create our CodeQL database for JavaScript/TypeScript (there
    is only one extractor for JS/TS</st> <st c="32197">in place):</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: codeql.exe database analyze .\codeql-database-js .\codeql-pack\javascript\codeql\javascript-queries\0.8.12\codeql-suites\<st
    c="32527">javascript-code-scanning.qls</st> --format=csv --output=results.csv
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="32590">Of course, we can analyze the code and get the results in</st>
    <st c="32649">SARIF format:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '# Upload results to GitHub repository'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: $env:GH_PAT = "ghp_PAT TOKEN"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: $env:GH_PAT | & codeql.exe github upload-results `
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: --repository=ourrepo/test `
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: --ref=refs/heads/main `
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: --commit 18cd21585b94dd16c48dc13bc1365269696a75a4 `
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: --sarif=javascript.sarif --github-auth-stdin
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="33504">In the case of C# projects and solutions, the CodeQL commands
    are a little bit different.</st> <st c="33595">For instance, when</st> <st c="33614">we
    need to implement Dataverse plugins, we can use the C# query pack but, in this
    case, we need also to build our Visual Studio projects during the analysis (see</st>
    `<st c="33776">runcodeql_dotnet.ps1</st>` <st c="33796">in the</st> `<st c="33804">Chapter07</st>`
    <st c="33813">folder of the</st> <st c="33828">GitHub repo):</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: <st c="34255">We use the</st> `<st c="34267">--command</st>` <st c="34276">argument
    to create a database for one or more compiled languages.</st> <st c="34343">It
    expects the</st> `<st c="34358">build</st>` <st c="34363">command that builds
    our solution, such as</st> `<st c="34406">dotnet build <<path to the sln file>></st>`<st
    c="34443">. We do not need this option if we are working with Python</st> <st
    c="34502">or TS/JS.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="34511">In the case of</st> <st c="34527">large code bases, we can use
    the following tricks to optimize CodeQL</st> <st c="34596">run durations:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="34610">Query packs</st>**<st c="34622">: We</st> <st c="34627">can
    create our own query packs derived from the publicly available ones and we can
    create our own query suites to focus on different code scanning and security scanning
    analyses depending on the time we have in our pipelines.</st> <st c="34854">For
    example, during the pull request validation build, we would like to minimize the
    execution time of the analysis by focusing on the most critical security vulnerabilities,
    whereas building the main branch would execute every available</st> <st c="35092">query
    suite.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="35135">codeql database analyze</st>`<st c="35158">: We can use the</st>
    `<st c="35176">--thread</st>` <st c="35184">parameter</st> <st c="35195">if we
    want to use more than one thread to run queries.</st> <st c="35250">The default
    value is</st> `<st c="35271">1</st>`<st c="35272">, which means the analysis runs
    only in one thread.</st> <st c="35324">We can specify more threads to speed up
    query execution.</st> <st c="35381">To set the number of threads to the number
    of logical processors, we specify</st> `<st c="35458">0</st>` <st c="35459">to</st>
    <st c="35463">this argument.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="35477">CodeQL execution targeting only part of our code base</st>**<st
    c="35531">: Ideally, we can have pull request pipelines/workflows that contain
    not just the trigger condition of whether the pull request happens but</st> <st
    c="35672">also</st> **<st c="35677">path filters</st>** <st c="35689">for the
    changes in the source</st> <st c="35719">code.</st> <st c="35726">With that, CodeQL
    can be executed for only the portion of the code, namely, the area in the source
    hierarchy that has</st> <st c="35844">been changed.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="35857">Finally, we delve into the Azure pipeline build tasks available</st>
    <st c="35921">in</st> `<st c="35952">.pipelines/codeql.yml</st>` <st c="35973">in
    the</st> `<st c="35981">Chapter07</st>` <st c="35990">folder of the</st> <st c="36005">GitHub
    repo):</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36018">Let us</st> <st c="36025">import</st> [<st c="36033">https://github.com/microsoft/PowerApps-Samples</st>](https://github.com/microsoft/PowerApps-Samples)
    <st c="36079">into one of our Azure DevOps projects.</st> <st c="36119">We need
    to go to</st> **<st c="36136">Repos</st>** <st c="36141">and click the drop-down
    list containing all repositories in the project where we will find the</st> **<st
    c="36237">Import repository</st>** <st c="36254">action item:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Import a Git repository](img/B22208_07_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="36429">Figure 7.4 – Import a Git repository</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36465">Here, we can add the URL to the GitHub public repo and</st> <st
    c="36521">import</st> `<st c="36528">PowerApps-Samples</st>`<st c="36545">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="36546">Enable the</st> **<st c="36558">Advanced Security</st>** <st c="36575">feature
    by opening the project settings (project administrator rights are required) and
    then selecting the recently imported repository.</st> <st c="36713">We</st> <st
    c="36716">need to enable</st> **<st c="36731">Advanced Security</st>** <st c="36748">by
    toggling</st> <st c="36761">the button:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Turning on the Advanced Security feature in Azure DevOps](img/B22208_07_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="37430">Figure 7.5 – Turning on the Advanced Security feature in Azure
    DevOps</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="37499">After enabling this security feature, we can navigate to</st>
    **<st c="37557">Pipelines</st>**<st c="37566">, and we can create a new pipeline
    YAML file that will be stored in the new</st> <st c="37642">Git repository.</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="37657">The YAML file should look</st> <st c="37684">as follows:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="37986">This</st> <st c="37991">YAML file will execute the same CodeQL
    analysis that we have seen previously with PowerShell for JavaScript via the</st>
    <st c="38108">CodeQL CLI.</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="38119">The code scanning and secret scanning alerts are listed under</st>
    **<st c="38182">Repos</st>** <st c="38187">in the</st> **<st c="38195">Advanced
    Security</st>** <st c="38212">tab of</st> <st c="38220">Azure DevOps:</st>
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Code and secret scanning results in Azure DevOps](img/B22208_07_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: <st c="39290">Figure 7.6 – Code and secret scanning results in Azure DevOps</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="39351">In the case of GitHub, we can apply the same steps by forking</st>
    `<st c="39414">PowerApps-Samples</st>` <st c="39431">and creating</st> <st c="39445">the
    code analysis-related actions (see</st> `<st c="39484">.github/workflows/codeql.yml</st>`
    <st c="39512">in the</st> `<st c="39520">Chapter07</st>` <st c="39529">folder
    of the</st> <st c="39544">GitHub repo):</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: <st c="40125">Using the</st> <st c="40135">Azure DevOps pipeline templates and
    the reusable GitHub workflows, we can easily introduce these additional code scanning
    and security analysis steps in every project of ours.</st> <st c="40312">Fortunately,
    there is another way to infuse security validation and code scanning checks in
    Power Platform solutions, which is the</st> **<st c="40443">solution checker</st>**<st
    c="40459">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="40460">Solution checker</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="40477">The solution checker</st> <st c="40498">embraces the Power Apps
    checker service to execute code analysis in solutions by submitting jobs for the
    Power Platform backend.</st> <st c="40628">There are</st> <st c="40638">predefined</st>
    **<st c="40649">rulesets</st>** <st c="40657">with</st> **<st c="40663">rules</st>**
    <st c="40668">to cover certain security recommendations and coding best practices
    of our solutions.</st> <st c="40755">The solution checker can report the found
    issues in SARIF format, which we can easily upload to our DevOps tools, such as
    GitHub with GHAS or GHAS for Azure DevOps.</st> <st c="40920">The solution checker
    reviews the following Power Platform assets in</st> <st c="40988">unmanaged solutions:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41008">Dataverse custom</st> <st c="41026">workflow activities</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="41045">Dataverse web resources (HTML</st> <st c="41076">and JavaScript)</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="41091">Dataverse configurations, such as SDK</st> <st c="41130">message
    steps</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="41143">Power Automate flows (via Power Automate</st> <st c="41185">Flow
    Checker)</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="41198">Power Fx expressions (via App Checker – part of the Power Apps</st>
    <st c="41262">checker service)</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '<st c="41278">The rulesets and their rules are predefined and categorized to
    cover the previously listed components: plug-in or workflow activity, web resources,
    and canvas app.</st> <st c="41443">We can execute the</st> <st c="41461">solution
    checker in multiple ways for</st> <st c="41500">unmanaged solutions:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="41520">In the Power Apps maker portal under the</st> **<st c="41562">Solutions</st>**
    <st c="41571">blade.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="41578">Using the</st> `<st c="41589">pac solution check</st>` <st c="41607">command
    with the proper parameters, such as</st> <st c="41652">the following:</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '<st c="42256">Using</st> <st c="42263">the</st> **<st c="42267">Power Apps
    checker web API</st>**<st c="42293">: The Power App maker portal, the PAC CLI,
    and the PowerShell module rely on these REST API endpoints under the hood.</st>
    <st c="42412">We can directly call these endpoints having the appropr</st>[<st
    c="42467">iate access token in place; for instance, the</st>](https://unitedstates.api.advisor.powerapps.com)
    <st c="42514">US endpoint is reachable under the following</st> <st c="42559">URL:</st>
    [<st c="42564">https://unitedstates.api.advisor.powerapps.com</st>](https://unitedstates.api.advisor.powerapps.com)<st
    c="42610">.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="42611">Using</st> **<st c="42618">managed environments</st>** <st c="42638">to
    enforce solution checker runs before importing solutions to target environments.</st>
    <st c="42723">Here, we can block the import of solutions if violations against
    these rules</st> <st c="42800">are encountered.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="42816">Leveraging the</st> `<st c="43186">PowerPlatformChecker@2</st>`<st
    c="43209">) during the import process of solutions from Git repositories.</st>
    <st c="43274">This task uses the PAC CLI behind</st> <st c="43308">the scenes.</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="43319">Let us have a look at the build task in Azure pipelines that executes
    such a static code analysis on our</st> <st c="43425">solution (see</st> `<st
    c="43439">.pipelines/solution-checker.yml</st>` <st c="43470">in the</st> `<st
    c="43478">Chapter07</st>` <st c="43487">folder of the</st> <st c="43502">GitHub
    repo):</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'name: Solution-Checker'
  prefs: []
  type: TYPE_NORMAL
- en: 'on:'
  prefs: []
  type: TYPE_NORMAL
- en: 'workflow_dispatch:'
  prefs: []
  type: TYPE_NORMAL
- en: 'jobs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'solutioncheck:'
  prefs: []
  type: TYPE_NORMAL
- en: 'runs-on: ubuntu-latest'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'env:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Solution: mpa_ITBase'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'steps:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- uses: actions/checkout@v3'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- name: Install Power Platform Tools'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'uses: microsoft/powerplatform-actions/actions-install@v1 <st c="45422">- name:
    Pack unmanaged solution</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '<st c="45453">uses: microsoft/powerplatform-actions/pack-solution@v1</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45508">with:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="45514">solution-folder: ${{ env.Solution }}</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="45551">solution-file: ${{ env.Solution }}_unmanaged.zip</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="45600">solution-type: Unmanaged</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="45625">- name: Check-solution</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="45648">uses: microsoft/powerplatform-actions/check-solution@v1</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45704">with:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="45710">environment-url: https://yourorg.crm.dynamics.com</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="45760">app-id: 862e5a17-d38b-BBBB-FFFF-88a77f59623f</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="45805">client-secret: "${{ secrets.CLIENTSECRET_DEV }}"</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="45854">tenant-id: 4ae51f31-033a-XXXX-YYYY-5ece14d2c081</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="45962">microsoft/powerplatform-actions/pack-solution@v1</st>, also uploads
    the SARIF result to the artifacts of the GitHub workflow run.
  prefs: []
  type: TYPE_NORMAL
- en: <st c="46086">Managing the findings</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="46108">Whether the solution checker with SARIF results, GHAS, or other
    code and dependency scanning tools are used to execute SAST, after gathering the
    results, we also need to manage those findings.</st> <st c="46302">We can mitigate
    these risks by accepting them, such as a security alert in the test code will
    not be corrected, or we can introduce new issues or work items to update the code
    according to the finding and respectively the vulnerability described</st> <st
    c="46547">in the</st> **<st c="46555">Common Weakness Enumeration</st>** <st c="46582">(</st>**<st
    c="46584">CWE</st>**<st c="46587">) database.</st> <st c="46600">Modern DevOps
    tools support linking the code scanning, dependency scanning, and secret scanning
    alerts to work items or issues and introduce the demand for fixes in the development</st>
    <st c="46781">life cycle.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="46792">Now we are familiar with the solution checker, the GHAS features,
    and the tasks in the DevSecOps process related to the SDLC methodology, we now
    combine this knowledge with the automated DevOps processes from</st> [*<st c="47002">Chapter
    6</st>*](B22208_06.xhtml#_idTextAnchor103)<st c="47011">.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="47012">Spinning up DevSecOps projects at scale</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="47052">In</st> [*<st c="47056">Chapter 6</st>*](B22208_06.xhtml#_idTextAnchor103)<st
    c="47065">, we</st> <st c="47070">learned how to spin up Power Platform environments
    with solutions assigned to our Git repositories and, respectively, the underlying
    branches.</st> <st c="47213">We created pipeline templates and reusable workflows
    in GitHub to provide automations for</st> <st c="47303">the following:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="47317">Spinning up new Power Platform</st> <st c="47349">developer environments</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="47371">Creating service connections to those Power</st> <st c="47416">Platform
    environments</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="47437">Exporting solutions from developer environments to</st> <st c="47489">Git
    branches</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="47501">Importing solutions from Git repositories and branches to target
    environments via pull requests or directly to our</st> <st c="47617">developer
    branch</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '<st c="47633">We can take one step forward in this journey and automate the
    entire development process of Power Platform solutions.</st> <st c="47752">First,
    let us introduce a new term: workload.</st> **<st c="47798">Workloads</st>** <st
    c="47807">consist</st> <st c="47816">of one or more solutions that contribute
    to each other to implement complex business requirements.</st> <st c="47915">We
    can consider them as the input solutions for package deployer packages, such as
    the</st> **<st c="48002">Enterprise templates</st>** <st c="48022">we learned
    about in</st> [*<st c="48043">Chapter 4</st>*](B22208_04.xhtml#_idTextAnchor074)<st
    c="48052">. To set up an enterprise-grade DevSecOps project for workloads or for
    separate solutions, we need to accomplish the following additional</st> <st c="48190">automation
    tasks:</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="48207">Create AAD groups (Microsoft Entra ID groups) for owners and contributors.</st>
    <st c="48283">There must be at least two owners in the</st> `<st c="48324">Owners</st>`
    <st c="48330">group.</st> <st c="48338">In most cases, we recommend having a budget
    owner and a technical owner assigned to</st> <st c="48422">a project</st><st c="48431">.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="48432">Create environments for testing and production per each workload
    or use existing shared environments hosting more solutions for the</st> <st c="48565">new
    one.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="48573">Create</st> <st c="48581">service principals for these environments
    using</st> `<st c="48629">pac admin create-service-principal</st>` <st c="48663">and
    the</st> `<st c="48938">Owners</st>` <st c="48944">AAD group</st> <st c="48955">created
    earlier.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="48971">Create an Azure DevOps project and assign the</st> `<st c="49018">Owners</st>`
    <st c="49024">AAD group to</st> `<st c="49081">Contributors</st>` <st c="49093">group
    to the</st> **<st c="49107">Contributors</st>** <st c="49119">group of</st> <st
    c="49129">Azure DevOps.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="49142">Create a Git repository for the workload or solution in the Azure
    DevOps project with branch policies</st> <st c="49245">in place.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="49254">Create service connections for these environments using the service
    principals that we have created.</st> <st c="49356">This is what we did in</st>
    [*<st c="49379">Chapter 6</st>*](B22208_06.xhtml#_idTextAnchor103)<st c="49388">.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="49389">Create CI/CD pipelines that use pipeline templates available in
    a separate, dedicated repository and configure them to use those new service connections</st>
    <st c="49543">as parameters.</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="49557">In the end, we can achieve the following</st> <st c="49599">project
    setup:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.7 – DevSecOps Power Platform project](img/B22208_07_7.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: <st c="49942">Figure 7.7 – DevSecOps Power Platform project</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="49987">We can see</st> <st c="49998">here the</st> `<st c="50320">Owners</st>`
    <st c="50327">and</st> `<st c="50332">Contributors</st>`<st c="50344">) can work
    on the project.</st> <st c="50372">Membership changes are logged into</st> **<st
    c="50407">Azure Log Analytics workspaces</st>** <st c="50437">and</st> <st c="50442">monitored
    by SIEM solutions, such as Microsoft Sentinel (</st><st c="50499">Threat Intelligence).</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="50521">We can automate all the previous steps with the help</st> <st
    c="50574">of</st> **<st c="50578">Azure pipelines</st>** <st c="50593">located
    in a separate Azure DevOps project.</st> <st c="50638">Let us see those steps</st>
    <st c="50661">in detail:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="50671">Create</st> <st c="50679">AAD groups:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="50690">To create an AAD group, we can use the following script (see</st>
    `<st c="50752">create-aad-group.sh</st>` <st c="50771">in the</st> `<st c="50779">Chapter07</st>`
    <st c="50788">folder of the</st> <st c="50803">GitHub repo):</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '#!/bin/bash'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: set -e
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Define environment variables
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: SERVICE_PRINCIPAL_APP_ID="<your-service-principal-app-id>"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: SERVICE_PRINCIPAL_SECRET="<your-service-principal-password>"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: TENANT_ID="<your-tenant-id>"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: ENV_NAME="YOUR_ENV_NAME"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: REGION="YOUR_REGION"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: CURRENCY="YOUR_CURRENCY"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: LANGUAGE="YOUR_LANGUAGE"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Login to Power Apps using service principal <st c="52302">pac auth create --applicationId
    $SERVICE_PRINCIPAL_APP_ID --clientSecret $SERVICE_PRINCIPAL_SECRET \</st>
  prefs:
  - PREF_IND
  - PREF_H1
  type: TYPE_NORMAL
- en: '<st c="52402">--tenant $TENANT_ID</st> # Create a new environment <st c="52450">pac
    admin create --name $ENV_NAME --region $REGION \</st>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="52502">--currency $CURRENCY --language $LANGUAGE \</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="52546">--type Production</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="52564">rawOutput=$(pac admin list --name $ENV_NAME | tail -n 2)</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '<st c="52621">environmentId=$(echo $rawOutput | cut -d '' '' -f 2)</st> #Enable
    Managed Environment <st c="52701">pac admin set-governance-config \</st>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="52734">--environment $environmentId \</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="52848">pac admin set-governance-config</st> command to enable managed
    environment features.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="52927">Create</st> <st c="52934">service principals</st> <st c="52954">for
    environments:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="52971">As we did in</st> [*<st c="52985">Chapter 5</st>*](B22208_05.xhtml#_idTextAnchor089)<st
    c="52994">, we can use the following PAC CLI command to create a service principal
    assigned to the newly</st> <st c="53089">created environments:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="53451">Create an Azure</st> <st c="53468">DevOps project:</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="53483">Here, we need to use</st> <st c="53504">a</st> `<st c="54040">System.AccessToken</st>`
    <st c="54058">and we can refer to this token to perform administrative or organization-wide
    actions.</st> <st c="54146">With this approach, we can eliminate the</st> <st
    c="54187">use of personal access tokens and we can grant access rights and privileges
    for the build service account at the collection level.</st> <st c="54318">For
    this, we need to disable the</st> **<st c="54351">Limit job authorization scope
    to current project for non-release pipelines</st>** <st c="54425">and</st> **<st
    c="54430">Limit job authorization scope to current project for release pipelines</st>**
    <st c="54500">options under</st> **<st c="54515">Project Settings</st>** <st c="54531">in
    the pipeline’s</st> **<st c="54550">Settings</st>** <st c="54558">blade in the
    project that will host our management pipelines, as the following</st> <st c="54638">figure
    shows:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.8 – System.AccessToken: project versus organization scope](img/B22208_07_8.jpg)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
- en: '<st c="55598">Figure 7.8 – System.AccessToken: project versus organization
    scope</st>'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="55664">If these toggle buttons are disabled, then we need to turn them
    off at the organization level.</st> <st c="55760">Finally, we need to grant permission
    to the</st> `<st c="55966">$(System.AccessToken)</st>` <st c="55987">system variable
    in our pipelines to execute the following script (see</st> `<st c="56058">.pipelines/setup-azure-devops-project.yml</st>`
    <st c="56099">in the</st> `<st c="56107">Chapter07</st>` <st c="56116">folder
    of the</st> <st c="56131">GitHub repo):</st>
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '# Variables'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: organizationURL="<Your-Azure-DevOps-Organization-URL>"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: project="<Your-Azure-DevOps-Project>"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: repository="<Your-New-Repository-Name>"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: pat="<Your-Personal-Access-Token>"
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '<st c="58230">main</st> branch:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: organizationName=$(basename $organizationURL) <st c="58289">git clone https://$organizationName@dev.azure.com/$organizationName/$project/_git/$repository</st>
    cd $repository <st c="58398">git checkout -b main</st> echo "# $repository" >>
    README.md <st c="58453">git add .</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="58462">git commit -m "Initial commit"</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '<st c="58573">main</st> branch from direct commits by introducing the check
    for linked work items on pull requests (see <st c="58674">create-gitrepo-and-branch-policy.sh</st>
    in the <st c="58717">Chapter07</st> folder of the GitHub repo):'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <st c="59553">resources:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="59564">repositories:</st>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '<st c="59578">- repository: templates</st>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '<st c="59602">type: git</st>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '<st c="59612">name: OtherProject/TemplateRepo</st>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '<st c="59644">ref: refs/heads/main</st>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '<st c="59665">endpoint: MyServiceConnection</st> steps: #or stages:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- template: .pipelines\ include-paccli-steps.yml@templates'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <st c="61119">--yml-path</st> option. To create these YAML files, we can use
    the previously discussed Git commands to commit the baseline pipelines that already
    refer to the pipeline templates that are enriched with secret scanning and static
    code analysis.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
