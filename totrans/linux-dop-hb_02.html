<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer012">
<h1 class="chapter-number" id="_idParaDest-29"><a id="_idTextAnchor025"/>2</h1>
<h1 id="_idParaDest-30"><a id="_idTextAnchor026"/>Command-Line Basics</h1>
<p>In this chapter, we’re going to dive right into the Linux command line. We will explain what makes it so powerful and, by extension, important to every system administrator and DevOps person. But more importantly, we will start teaching you the most useful commands and a way to use them efficiently. Along the way, we will be adding other core Linux concepts, as they will be required to understand <span class="No-Break">the chapter.</span></p>
<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
<ul>
<li>What a command line is and how <span class="No-Break">it works</span></li>
<li>Why it is so important to feel comfortable working with the <span class="No-Break">command line</span></li>
<li>Basic commands for Linux <span class="No-Break">system administration</span></li>
</ul>
<p>It is not possible to introduce all the commands and tools in a single chapter. What follows is our choice of the most basic tools you will need to know. Managing the Linux system is a separate book topic on its own. It so happens that Packt does have several publications <span class="No-Break">on that.</span></p>
<h1 id="_idParaDest-31"><a id="_idTextAnchor027"/>Technical requirements</h1>
<p>It is highly recommended to have a Linux system installed and ready for use. We recommend it to be a virtual machine or a laptop that you can safely reinstall from scratch in case something goes horribly wrong. It will let you follow the examples in the book and perform any kind of exercise that we <span class="No-Break">give you.</span></p>
<p>We are not going to cover an installation. Every distribution may use its own installer, either graphical or text (depending on the distribution and which variant you’ve picked). You’ll need to note down or remember the name of your user (conveniently called username or login) and password. There are ways to get into the system if you have physical access and you don’t know either the login or password, or both, but they are way outside of the scope of <span class="No-Break">this book.</span></p>
<p>Our main distribution in the book is Debian. However, you should be alright with any of the major ones we covered in the previous chapter, <em class="italic">Choosing the Right Linux Distribution</em>, as long as it <span class="No-Break">isn’t Alpine.</span></p>
<h1 id="_idParaDest-32"><a id="_idTextAnchor028"/>The Linux command line – shell</h1>
<p>The <a id="_idIndexMarker078"/>natural environment for a Linux system administrator is the command line. You’ll never hear anyone call it that, however. The correct name is the <strong class="bold">shell</strong>, and<a id="_idIndexMarker079"/> from now on, that’s how we’re going to address it in <span class="No-Break">the book.</span></p>
<p>The <strong class="bold">shell</strong> is a program that accepts input from a user (mostly keyboard strokes, but there are other ways, and you can even use a mouse pointer), interprets it, and, if it’s a valid command, executes it, providing the user with the result or with error information if they’ve made a mistake or if the commands couldn’t complete their <span class="No-Break">execution properly.</span></p>
<p>There are a few ways to access <span class="No-Break">the shell:</span></p>
<ul>
<li>Log in to the Terminal (screenshot in <span class="No-Break"><em class="italic">Figure 2</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">)</span></li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">You’ll also see the term <strong class="bold">console</strong>. There<a id="_idIndexMarker080"/> is a difference between the Terminal and a console. A <strong class="bold">console</strong> is a physical device that lets users interact with the computer. It is the physical input (nowadays, mostly keyboard) and output (nowadays, a monitor, but in <a id="_idIndexMarker081"/>the beginning, the output was printed out). <strong class="bold">Terminal</strong> is a console emulator, a program that lets users perform the <span class="No-Break">same tasks.</span></p>
<ul>
<li>Open a Terminal window in a graphical interface, if you <span class="No-Break">have one</span></li>
<li>Log in remotely over a secure connection from another device (phone, tablet, or <span class="No-Break">your computer)</span></li>
</ul>
<p>The shell is a very powerful environment. It may seem cumbersome at first to do everything by typing commands, but soon you’ll learn that the more complex the task, the more you can do with the shell, more easily than with graphical interfaces. Every Linux system administrator worth their salt will know how to do tasks in the shell and how to manage the system through it, and I wouldn’t risk much by betting that they will prefer the shell to <span class="No-Break">any G<a id="_idTextAnchor029"/>UI.</span></p>
<h2 id="_idParaDest-33"><a id="_idTextAnchor030"/>Getting to know your shell</h2>
<p>The shell is a <a id="_idIndexMarker082"/>program, and as such, there is not a single shell. Instead, there are a number of more or less popular shells that bring forth their own view on how things should <span class="No-Break">be done.</span></p>
<p>By far the most popular and default in most Linux distributions<a id="_idIndexMarker083"/> is <strong class="bold">Bash</strong> (<strong class="bold">Bourne again shell</strong>). There are other shells you may want to be <span class="No-Break">aware of:</span></p>
<ul>
<li><strong class="bold">sh</strong>: The<a id="_idIndexMarker084"/> original Steve Bourne shell. It is <em class="italic">the</em> shell, the very first one ever written that we know of. While it lacks many interactive features that users came to appreciate from other, more modern shells, <em class="italic">sh</em> is known for its speed of script execution and <span class="No-Break">small size.</span></li>
<li><strong class="bold">ksh</strong>: Developed <a id="_idIndexMarker085"/>as an evolution of the Bourne shell, it is a superset of its predecessor. Thus, all scripts written for <em class="italic">sh</em> will run <span class="No-Break">in </span><span class="No-Break"><em class="italic">ksh</em></span><span class="No-Break">.</span></li>
<li><strong class="bold">csh</strong>: The C shell. The <a id="_idIndexMarker086"/>name comes from its syntax, which closely follows the C <span class="No-Break">programming language.</span></li>
<li><strong class="bold">zsh</strong>: The <a id="_idIndexMarker087"/>Z shell. It should be well known to macOS users, as it is a default on this operating system. It is a completely modern shell, providing a lot of features that you’d expect from it: command history, arithmetic operations, command completion, and <span class="No-Break">so on.</span></li>
</ul>
<p>We won’t trouble you much with shell variants and history. If you are interested in how Bash came to be, refer to this <a id="_idIndexMarker088"/>Wikipedia <span class="No-Break">article: </span><a href="https://en.wikipedia.org/wiki/Bash_(Unix_shell)"><span class="No-Break">https://en.wikipedia.org/wiki/Bash_(Unix_shell)</span></a><span class="No-Break">.</span></p>
<p>In our book, we are working with Bash. As mentioned earlier, it is the default shell for most Linux distributions, it offers <em class="italic">sh</em> compatibility mode, it has all the features you’d expect from a modern shell, and the amount of books, articles, how-tos, and other material for extending your knowledge about it <span class="No-Break">is staggering.</span></p>
<p>The first task that we will be performing is logging in to your shell. Depending on your chosen installation method, you may need to power up the local virtual machine, your physical machine, or a <a id="_idIndexMarker089"/>cloud-based <strong class="bold">Virtual Private Server</strong> (<strong class="bold">VPS</strong>). If you have picked a server installation without a graphical user interface, you should see something similar to the <span class="No-Break">following screenshot:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer011">
<img alt="Figure 2.1 – Login screen" height="394" src="image/B18197_02_1.jpg" width="752"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Login screen</p>
<p>You are presented with a login screen, where you can provide your username and password. Once successfully logged in, you are presented with a command prompt, which confirms that you’ve just successfully started <span class="No-Break">your shell.</span></p>
<p>The way the prompt looks is configurable and may be different depending on your chosen distribution. There is, however, one thing that will stay the same, and we advise you to never change it. In the world of Linux, there are two types of users: <em class="italic">normal users</em> and the <em class="italic">superuser</em>. While the login for normal users can be anything as long as it adheres to the Linux user naming conventions, the superuser<a id="_idIndexMarker090"/> is called <strong class="bold">root</strong>. To log in to the root account, you’d type in <strong class="source-inline">root</strong> as the username/login and its <span class="No-Break">password next.</span></p>
<p>The superuser account is named that way for a reason. In most Linux distributions, it’s the omnipotent user. Once logged in as <strong class="source-inline">root</strong>, you can do anything you wish, even deleting all files, including the operating <span class="No-Break">system itself.</span></p>
<p>To help you distinguish between being a normal user and the <strong class="source-inline">root</strong> one, the prompt will present you with a clue. While logged in as <strong class="source-inline">root</strong>, your prompt will end with the <strong class="source-inline">#</strong> sign. When logged in as a normal user, it will present you <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">$</strong></span><span class="No-Break">.</span></p>
<p>While we’re at it, the <strong class="source-inline">#</strong> (hash) sign is also a so-called comment sign. If you happen to paste a command or type it from the internet, if it starts with <strong class="source-inline">#</strong> or <strong class="source-inline">$</strong>, it is your clue as to which type of user should run this command. You should omit this sign, especially as <strong class="source-inline">#</strong> in front will prevent the command <span class="No-Break">from running.</span></p>
<p>In addition to the sign that ends the prompt, many distributions will prepend the username to it, making sure you know which user you are. Given a user admin on a Linux system called <strong class="source-inline">myhome</strong>, the default prompt for Debian 11 will look <span class="No-Break">like this:</span></p>
<pre class="console">
$admin@myhome:~$</pre>
<p>For the <strong class="source-inline">root</strong> user, it would look <span class="No-Break">like this:</span></p>
<pre class="console">
root@myhome:~#</pre>
<p>For the record, there are more ways to check your identity, but we will leave that for<a id="_idTextAnchor031"/> <a href="B18197_04.xhtml#_idTextAnchor063"><span class="No-Break"><em class="italic">Chapter 4</em></span></a><span class="No-Break">.</span></p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor032"/>I call to thee</h2>
<p>So far, so good. You<a id="_idIndexMarker091"/> have logged in, you know who you are, you can type, and you can read. But how do you actually <span class="No-Break">run programs?</span></p>
<p>In the Linux lingo, running a program is executing it or <a id="_idIndexMarker092"/>calling it. Actually, <strong class="bold">calling</strong> is mostly used when referring to system commands or shell built-in commands, and <strong class="bold">executing</strong> is used when talking about something that is not a part of the distribution—so-called third-party programs <span class="No-Break">or binary.</span></p>
<p>Before I can tell you how to execute a program or call a command, I’ll have to explain a little bit about filesystem structure and a very important system variable<a id="_idTextAnchor033"/> <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">PATH</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-35"><a id="_idTextAnchor034"/>The filesystem structure</h2>
<p>Since<a id="_idIndexMarker093"/> it may be your first time, we are going to step back a little bit and explain how the filesystem is structured (in other words, how directories are organized in <span class="No-Break">typical Linux).</span></p>
<p>Linux follows the Unix philosophy that states that everything is a file. (There are exceptions, but not many.) The consequence is that almost every aspect of the operating system is reflected either as a file or a directory. Memory states, processes' (running programs) states, logs, binaries, and device drivers all live within this structure. This also means that almost every aspect of your Linux system can be edited or inspected using just normal text <span class="No-Break">editing tools.</span></p>
<p>In the <a id="_idIndexMarker094"/>directory tree, its structure always starts with a <strong class="source-inline">/</strong> folder, called the <strong class="bold">root directory</strong>. Every drive, network share, and system directory lives in a hierarchy that starts from <span class="No-Break">the root.</span></p>
<p>The process of making <a id="_idIndexMarker095"/>a network share or local drive available to the system or user is called <strong class="bold">mounting</strong> and the resource that is made available is <strong class="bold">mounted</strong>. Remember that word, as we’re going to be using it from now on. Different from Microsoft Windows, where your drives appear as a separate letter with each being its own <strong class="bold">root directory</strong>, in Linux, your hard drive will be mounted somewhere within the directories hierarchy. As an example, the user home directory can be stored on a separate hard drive, mounted under the <strong class="source-inline">/home/</strong> directory. You would never be able to tell it when browsing the filesystem structure. The only way to tell would be to inspect mounted drives and partitions using the <span class="No-Break">following commands:</span></p>
<pre class="console">
$ mount</pre>
<p><span class="No-Break">or</span></p>
<pre class="console">
$ df</pre>
<p>We are going to elaborate on them in <a href="B18197_03.xhtml#_idTextAnchor050"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, so for now, just know <span class="No-Break">they exist.</span></p>
<p>The name of the uppermost directory is <strong class="source-inline">/</strong>. We already covered that. The separator between folders nested in another folder is also <strong class="source-inline">/</strong>. So <strong class="source-inline">/usr/bin</strong> means a <strong class="source-inline">bin</strong> directory that exists in the <strong class="source-inline">usr</strong> directory, and the <strong class="source-inline">usr</strong> directory exists in the <strong class="source-inline">/</strong> <span class="No-Break">directory. Simple.</span></p>
<p>There is a very nice command that lets us inspect the directory structure, conveniently called <strong class="source-inline">tree</strong>. It may<a id="_idIndexMarker096"/> not be present in your system. If so, don’t be worried; it’s not so important that you run it rather than go through our explanation. In <a href="B18197_03.xhtml#_idTextAnchor050"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, when we introduce the installation of packages, you can revisit and play around. By default, the <strong class="source-inline">tree</strong> command will flood your screen with the full hierarchy, making it difficult to read and follow. There is an option, however, that lets us limit the depth we will <span class="No-Break">be inspecting:</span></p>
<pre class="console">
admin@myhome:~$ tree -L 1 /
/
|-- bin -&gt; usr/bin
|-- boot
|-- dev
|-- etc
|-- home
|-- lib -&gt; usr/lib
|-- lib32 -&gt; usr/lib32
|-- lib64 -&gt; usr/lib64
|-- libx32 -&gt; usr/libx32
|-- lost+found
|-- media
|-- mnt
|-- opt
|-- proc
|-- root
|-- run
|-- sbin -&gt; usr/sbin
|-- srv
|-- sys
|-- tmp
|-- usr
`-- var
22 directories, 0 files</pre>
<p>There are <a id="_idIndexMarker097"/>several important concepts to cover here; we won’t be explaining all the directories at this time, however. The first time a given folder becomes important, in <a href="B18197_03.xhtml#_idTextAnchor050"><span class="No-Break"><em class="italic">Chapter 3</em></span></a> onward, we will briefly touch <span class="No-Break">upon it.</span></p>
<p>First, the calling of <strong class="source-inline">tree</strong>. You saw my prompt, which tells me I am running as user admin, on a system <a id="_idIndexMarker098"/>named <strong class="source-inline">myhome</strong> and that I am not a <strong class="source-inline">root</strong> user (<em class="italic">the dollar sign at the end</em>). If you want to run the <strong class="source-inline">tree</strong> command, you will skip the prompt. Next is the actual call: <strong class="source-inline">tree</strong> with the <strong class="source-inline">-L</strong> option and number <strong class="source-inline">1</strong>; this instructs the program to only print one level of depth. In other words, it will not go any deeper into the directories. Finally, the <strong class="source-inline">/</strong> symbol tells the program to start printing at the very beginning of the filesystem—the <span class="No-Break"><strong class="source-inline">root</strong></span><span class="No-Break"> folder.</span></p>
<p>Next, you’ll notice<a id="_idIndexMarker099"/> that some rows have this mysterious arrow pointing from one name to another. This denotes a shortcut. There are two types of shortcuts, hard and symbolic. Directories can only have a symbolic link. In the preceding output, the <strong class="source-inline">/bin</strong> directory is a link to a <strong class="source-inline">/usr/bin</strong> directory. For all intents and purposes, they can be treated as one. There are technical and historical reasons for the existence of this link. In days past, tools living in <strong class="source-inline">/bin</strong> and <strong class="source-inline">/sbin</strong> were used to mount a <strong class="source-inline">/usr</strong> partition and then allow access to <strong class="source-inline">/usr/bin</strong> and <strong class="source-inline">/usr/sbin</strong>. Nowadays, this task is handled earlier in the boot process by other tools and the requirement is no longer necessary. The structure is kept for backward compatibility with tools that may require the existence of both <strong class="source-inline">/bin</strong> and <strong class="source-inline">/sbin</strong> directories. More details can be found at <a href="https://refspecs.linuxfoundation.org/FHS_3.0/fhs/index.xhtml">https://refspecs.linuxfoundation.org/FHS_3.0/fhs/index.xhtml</a> <span class="No-Break">or </span><a href="https://www.linuxfoundation.org/blog/blog/classic-sysadmin-the-linux-filesystem-explained"><span class="No-Break">https://www.linuxfoundation.org/blog/blog/classic-sysadmin-the-linux-filesystem-explained</span></a><span class="No-Break">.</span></p>
<p>Since we already touched on the <strong class="source-inline">/bin</strong> and <strong class="source-inline">/sbin</strong> directory, let’s explain the difference. The <strong class="source-inline">/usr/bin</strong> directory<a id="_idIndexMarker100"/> contains <strong class="bold">binaries</strong>—in other words, commands that can be of interest to every user in the system. The <strong class="source-inline">/usr/sbin</strong> directory contains<a id="_idIndexMarker101"/> so-called <strong class="bold">system binaries</strong>. Those are commands that should concern only the <strong class="source-inline">root</strong> user. It will also contain binaries for system<a id="_idIndexMarker102"/> processes (called <strong class="bold">daemons</strong>)—programs that run in the background and do important work for the <span class="No-Break">running system.</span></p>
<p>The <strong class="source-inline">/root</strong> directory is the home of the superuser. This is where all its configuration <span class="No-Break">files lay.</span></p>
<p>The interesting one is the <strong class="source-inline">/home</strong> directory. This is where all the user home directories exist. When I created my admin user for my home machine, it was placed in the <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">home/admin</strong></span><span class="No-Break"> folder.</span></p>
<p>Of importance to us at this moment will also be the <strong class="source-inline">/etc/</strong> directory. It contains all the configuration files for the whole system: the source for online package repositories, default shell configuration, system name, processes that start at the boot, system users and their passwords, and time-based commands. On a freshly installed Debian 11 system, the <strong class="source-inline">/etc/</strong> directory<a id="_idIndexMarker103"/> contains about 150 subdirectories and files, and each subdirectory may contain more <span class="No-Break">folders inside.</span></p>
<p>The <strong class="source-inline">/tmp</strong> folder <a id="_idIndexMarker104"/>contains temporary files. They only live when the system is booted and will be deleted the moment it is shut down or restarted. The nature of those files is often very volatile; they can hop into existence and disappear very fast or can be modified very often. It is not uncommon for this directory to only exist in the computer’s RAM. It’s the fastest storage device your system has and will automatically purge on restart or <span class="No-Break">power off.</span></p>
<p>As mentioned earlier, additional drives are mounted under this structure. We could have a separate hard drive for home directories. The<a id="_idIndexMarker105"/> whole <strong class="source-inline">/home</strong> folder may live on it or even on a networked hard disk array. As mentioned, the <strong class="source-inline">/tmp</strong> directory is often mounted in the RAM. Sometimes, the <strong class="source-inline">/var</strong> directory (which contains things that can change often in the system but are not supposed to be purged, such as logs) is mounted on a separate drive. One of the reasons is that the <a id="_idIndexMarker106"/>contents of <strong class="source-inline">/var</strong>, and especially of <strong class="source-inline">/var/log</strong> (where the system logs live), can grow very fast and take all the available space, making accessing the system impossible or <span class="No-Break">very tricky.</span></p>
<p>Finally, there are two important and special directories that exist everywhere <span class="No-Break">you go:</span></p>
<ul>
<li><strong class="source-inline">.</strong>: A single dot means<a id="_idIndexMarker107"/> the <strong class="bold">current directory</strong>. If you choose to go to a <strong class="source-inline">.</strong> folder, you’ll end up where you are. It’s useful, however, as you’ll see in <a href="B18197_03.xhtml#_idTextAnchor050"><span class="No-Break"><em class="italic">Chapter 3</em></span></a><span class="No-Break">.</span></li>
<li><strong class="source-inline">..</strong>: Two dots mean the directory <a id="_idIndexMarker108"/>above us—the <strong class="bold">parent directory</strong>. If you choose to go to a <strong class="source-inline">..</strong> folder, you’ll end up one level above where you started. Note that for the <strong class="source-inline">/</strong> directory, both <strong class="source-inline">.</strong> and <strong class="source-inline">..</strong> mean the same: <strong class="source-inline">/</strong>. You can’t go any higher than <span class="No-Break">the root.</span></li>
</ul>
<h2 id="_idParaDest-36"><a id="_idTextAnchor035"/>Running a program</h2>
<p>Now that we know some things about the folder hierarchy, let’s briefly touch on <span class="No-Break">executing programs.</span></p>
<p>There are three<a id="_idIndexMarker109"/> basic ways to execute a program in <span class="No-Break">a shell:</span></p>
<ul>
<li><strong class="bold">Call it by its name</strong>: This<a id="_idIndexMarker110"/> requires that it is placed in a directory that is in a <strong class="source-inline">PATH</strong> variable (explained in <a href="B18197_03.xhtml#_idTextAnchor050"><span class="No-Break"><em class="italic">Chapter 3</em></span></a><span class="No-Break">).</span></li>
<li><strong class="bold">Call it by an absolute path</strong>: The <a id="_idIndexMarker111"/>absolute path starts with <strong class="source-inline">/</strong>. When using the absolute path, you have to list all the directories that lead to the program, including the leading <strong class="source-inline">/</strong>. An example execution may look <span class="No-Break">like this:</span></li>
</ul>
<pre class="console">
/opt/somecompany/importantdir/bin/program</pre>
<ul>
<li><strong class="bold">Call it by a relative path</strong>: This<a id="_idIndexMarker112"/> will not start with a dot or two dots. This way of executing <a id="_idIndexMarker113"/>a program requires that you know where in the filesystem you are and where in the filesystem this program is. It’s useful if you are in the same directory as the binary or very close <span class="No-Break">to it:</span><ul><li>To call a program in the same directory as your user, you precede it with a dot and a slash: <strong class="source-inline">./</strong>. This shortcut means the <strong class="bold">current directory</strong>. A sample call could look like <strong class="source-inline">./myprogram</strong> or <strong class="source-inline">./bin/myprogram</strong>. The latter would mean: let’s start a program called <strong class="source-inline">myprogram</strong> that is in a <strong class="source-inline">bin</strong> directory that is in the <span class="No-Break">current directory.</span></li><li>To call a program in a directory somewhere else in the system using a relative path, we will have to use the two dots, meaning the parent folder. Let’s say you are logged in to your home directory, <strong class="source-inline">/home/admin</strong>, and want to execute a program in <strong class="source-inline">/opt/some/program/bin</strong>; you’d call <strong class="source-inline">../../opt/some/program/bin/myprogram</strong>. The two dots and slash mean <span class="No-Break">moving up.</span></li></ul></li>
</ul>
<p>If this looks arcane, it is because it is a little bit. Fortunately, everything will start comin<a id="_idTextAnchor036"/>g together as the <span class="No-Break">book progresses.</span></p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor037"/>The command to teach you all commands</h2>
<p>You should <a id="_idIndexMarker114"/>get into the habit of searching the internet whenever you have a question or problem. Most of the issues you are going to run into are already fixed or explained out there. However, there’s one command that can save your life—or at least lots of time. You should make another habit of using it often – even if you are sure you know the correct syntax, you might just discover a better way of completing your task. This command is <span class="No-Break">as follows:</span></p>
<pre class="console">
$ man</pre>
<p>The <strong class="source-inline">man</strong> command is<a id="_idIndexMarker115"/> a shorthand for <em class="italic">manual</em> and it is exactly what it says: it is a manual for whatever command you want to learn about. To learn more about the <strong class="source-inline">man</strong> command, simply call <span class="No-Break">the following:</span></p>
<pre class="console">
$ man man</pre>
<p>The output you’ll see should be similar to <span class="No-Break">the following:</span></p>
<pre class="console">
MAN(1)                                                                 
                                   Manual pager utils                                     
                                                               MAN(1)
NAME
       man - an interface to the system reference manuals
SYNOPSIS
       man [man options] [[section] page ...] ...
       man -k [apropos options] regexp ...
       man -K [man options] [section] term ...
       man -f [whatis options] page ...
       man -l [man options] file ...
       man -w|-W [man options] page ...
DESCRIPTION
       man is the system's manual pager.  Each page argument given to man is normally the name of a program, utility or function.  The manual page associated with each of these arguments is then found and displayed.  A section, if
       provided, will direct man to look only in that section of the manual.  The default action is to search in all of the available sections following a pre-defined order (see DEFAULTS), and to show only the  first  page  found,
       even if page exists in several sections.</pre>
<p>I have cut it for <a id="_idIndexMarker116"/>brevity. A well-written <strong class="source-inline">man</strong> page will have <span class="No-Break">several sections:</span></p>
<ul>
<li><strong class="source-inline">name</strong>: This is where the name of the command is stated. If the command exists under various names, they will all be <span class="No-Break">listed here.</span></li>
<li><strong class="source-inline">synopsis</strong>: This will list possible ways of calling <span class="No-Break">the command.</span></li>
<li><strong class="source-inline">description</strong>: This is the purpose of <span class="No-Break">the command.</span></li>
<li><strong class="source-inline">examples</strong>: This will show several examples of the command call, to make the syntax clearer and give <span class="No-Break">some ideas.</span></li>
<li><strong class="source-inline">options</strong>: This will show all the available options and <span class="No-Break">their meaning.</span></li>
<li><strong class="source-inline">getting help</strong>: This is how to get a shortened version of the <span class="No-Break">command synopsis.</span></li>
<li><strong class="source-inline">files</strong>: If the command has configuration files or consumes files known to exist in the filesystem, they will be listed here (for <strong class="source-inline">man</strong>, I have listed <strong class="source-inline">/etc/manpath.config</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">/usr/share/man</strong></span><span class="No-Break">).</span></li>
<li><strong class="source-inline">bugs</strong>: This is where to look for bugs and report <span class="No-Break">new ones.</span></li>
<li><strong class="source-inline">history</strong>: This will show all the current and previous authors of <span class="No-Break">the program.</span></li>
<li><strong class="source-inline">see also</strong>: These are programs that are in some way tied to the command (for <strong class="source-inline">man</strong>: <strong class="source-inline">apropos(1)</strong>, <strong class="source-inline">groff(1)</strong>, <strong class="source-inline">less(1)</strong>, <strong class="source-inline">manpath(1)</strong>, <strong class="source-inline">nroff(1)</strong>, <strong class="source-inline">troff(1)</strong>, <strong class="source-inline">whatis(1)</strong>, <strong class="source-inline">zsoelim(1)</strong>, <strong class="source-inline">manpath(5)</strong>, <strong class="source-inline">man(7)</strong>, <strong class="source-inline">catman(8)</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">mandb(8)</strong></span><span class="No-Break">).</span></li>
</ul>
<p>Many commands<a id="_idIndexMarker117"/> will contain a lot of additional sections, specific to <span class="No-Break">this program.</span></p>
<p>The <strong class="source-inline">man</strong> pages will contain a lot of knowledge, and sometimes the names will duplicate. This is where the mysterious numbers in brackets come into play. The <strong class="source-inline">man</strong> pages are broken down into sections. To quote the <strong class="source-inline">man</strong> page <span class="No-Break">about </span><span class="No-Break"><strong class="source-inline">man</strong></span><span class="No-Break">:</span></p>
<ol>
<li>Executable programs or <span class="No-Break">shell commands</span></li>
<li>System calls (functions provided by <span class="No-Break">the kernel)</span></li>
<li>Library calls (functions within <span class="No-Break">program libraries)</span></li>
<li>Special files (usually found <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">/dev</strong></span><span class="No-Break">)</span></li>
<li>File formats and conventions, for <span class="No-Break">example, </span><span class="No-Break"><strong class="source-inline">/etc/passwd</strong></span></li>
<li><span class="No-Break">Games</span></li>
<li>Miscellaneous (including macro packages and conventions), for example, <span class="No-Break"><strong class="source-inline">man(7)</strong></span><span class="No-Break">, </span><span class="No-Break"><strong class="source-inline">groff(7)</strong></span></li>
<li>System administration commands (usually only <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">root</strong></span><span class="No-Break">)</span></li>
<li>Kernel <span class="No-Break">routines [non-standard]</span></li>
</ol>
<p>Let’s take, for example, <strong class="source-inline">printf</strong>. There are several things that are called <strong class="source-inline">printf</strong>. One of them is a library function of the C programming language. Its <strong class="source-inline">man</strong> page will live in <span class="No-Break">section </span><span class="No-Break"><strong class="source-inline">3</strong></span><span class="No-Break">.</span></p>
<p>To read about that library function, you have to tell <strong class="source-inline">man</strong> to look into <span class="No-Break">section </span><span class="No-Break"><strong class="source-inline">3</strong></span><span class="No-Break">:</span></p>
<pre class="console">
admin@myhome:~$ man 3 printf
PRINTF(3)                                                              
                                Linux Programmer's Manual                                
                                                             PRINTF(3)
NAME
       printf, fprintf, dprintf, sprintf, snprintf, vprintf, vfprintf, vdprintf, vsprintf, vsnprintf - formatted output conversion
If you don't, what you'll get is a shell function for printing—totally useless in C programming:
admin@myhome:~$ man printf
PRINTF(1)                                                              
                                      User Commands                                        
                                                           PRINTF(1)
NAME
       printf - format and print data
SYNOPSIS
       printf FORMAT [ARGUMENT]...
       printf OPTION</pre>
<p>Most commands <a id="_idIndexMarker118"/>and shell programs have a shorter synopsis called <strong class="source-inline">help</strong>. Usually, it can be invoked by running binary with the <strong class="source-inline">-h</strong> or --<span class="No-Break"><strong class="source-inline">help</strong></span><span class="No-Break"> option:</span></p>
<pre class="console">
admin@myhome:/$ man --help
Usage: man [OPTION...] [SECTION] PAGE...
  -C, --config-file=FILE     use this user configuration file
  -d, --debug                emit debugging messages
  -D, --default              reset all options to their default values
      --warnings[=WARNINGS]  enable warnings from groff</pre>
<p>I have cut the <a id="_idIndexMarker119"/>output for brevity, but you get <span class="No-Break">the drift.</span></p>
<p class="callout-heading">Note</p>
<p class="callout">The short options are preceded with one dash while longer ones are preceded with two. --<strong class="source-inline">help</strong> is not one long dash but two <span class="No-Break">standard ones.</span></p>
<p>The <strong class="source-inline">man</strong> and <strong class="source-inline">–help</strong> commands should become your friends even before searching online. A lot of questions can be quickly answered just by looking at the <strong class="source-inline">help</strong> output. Even if you are a seasoned administrator, you are allowed to forget command syntax. There is an online source of endless Linux guides called <em class="italic">The Linux Documentation Project</em>: <a id="_idTextAnchor038"/><a href="https://tldp.org">https://tldp.org</a>. Make it <span class="No-Break">your bookmark.</span></p>
<h2 id="_idParaDest-38"><a id="_idTextAnchor039"/>Know your environment</h2>
<p>The way your <a id="_idIndexMarker120"/>system behaves is controlled by several factors. One of them is a set of variables called <strong class="bold">environment</strong>. They set things such as what language your system is going to use when talking to you, how entries during listing will be sorted, where the shell is going to look for executables, and many more. The exact set of variables depends on <span class="No-Break">the distribution.</span></p>
<p>The full set of all the environment variables that your shell has set can be printed using the <span class="No-Break"><strong class="source-inline">env</strong></span><span class="No-Break"> command:</span></p>
<pre class="console">
admin@myhome:/$ env
SHELL=/bin/Bash
PWD=/
LOGNAME=admin
XDG_SESSION_TYPE=tty
MOTD_SHOWN=pam
HOME=/home/admin
LANG=C.UTF-8
PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games</pre>
<p>If you know the <a id="_idIndexMarker121"/>variable you want to inspect, you can use the <span class="No-Break"><strong class="source-inline">echo</strong></span><span class="No-Break"> command:</span></p>
<pre class="console">
admin@myhome:/$ echo $PATH
/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games</pre>
<p>Notice that when you are using a variable, you have to precede<a id="_idTextAnchor040"/> its name with a dollar sign, <span class="No-Break">hence </span><span class="No-Break"><strong class="source-inline">$PATH</strong></span><span class="No-Break">.</span></p>
<h2 id="_idParaDest-39"><a id="_idTextAnchor041"/>Where in the PATH am I?</h2>
<p>Since we<a id="_idIndexMarker122"/> mentioned <strong class="source-inline">PATH</strong>, let’s talk briefly about it. <strong class="bold">Path</strong> can mean <span class="No-Break">two things:</span></p>
<ul>
<li>A place in the system that leads to something: a binary, a file, or <span class="No-Break">a device</span></li>
<li>An environment variable that lists places where the shell is going to look when trying to execute <span class="No-Break">a program</span></li>
</ul>
<p>You already know a little bit about the first kind of path. We explained the absolute path and relative path. There is a command that lets you move around, and it’s called <strong class="source-inline">cd</strong> (shortcut for <strong class="bold">change directory</strong>). If you call <strong class="source-inline">cd</strong> without an argument, it will take you to your home directory. If you call it with an argument, it will move you to the specified folder, given that it exists, you specified the path properly, and you have the right to access it. Let’s see a <span class="No-Break">few examples:</span></p>
<ul>
<li>Checking which directory we’re <span class="No-Break">currently in:</span></li>
</ul>
<pre class="console">
admin@myhome:~# pwd
/home/admin</pre>
<ul>
<li>Changing directory <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">/home/admin/documents/current</strong></span><span class="No-Break">:</span></li>
</ul>
<pre class="console">
admin@myhome:~# cd documents/current
admin@myhome:~/documents/current#</pre>
<ul>
<li>Changing one directory up from a <span class="No-Break">current level:</span></li>
</ul>
<pre class="console">
admin@myhome:~/documents/current# cd ..
admin@myhome:~/documents#</pre>
<ul>
<li>Changing the directory to the user <span class="No-Break">home directory:</span></li>
</ul>
<pre class="console">
admin@myhome:~/documents# cd
admin@myhome:~# pwd
/home/admin</pre>
<h1 id="_idParaDest-40">Know your rights</h1>
<p>The most <a id="_idIndexMarker123"/>basic security mechanism in Linux is based on defining a combination of rights for a set of entities. The rights are <span class="No-Break">as follows:</span></p>
<ul>
<li><span class="No-Break"><strong class="source-inline">read</strong></span></li>
<li><span class="No-Break"><strong class="source-inline">write</strong></span></li>
<li><strong class="source-inline">execute</strong> (read contents when talking about <span class="No-Break">a directory)</span></li>
</ul>
<p>And the entities are <span class="No-Break">as follows:</span></p>
<ul>
<li>The owner of the file <span class="No-Break">or directory</span></li>
<li>The group that owns the file <span class="No-Break">or directory</span></li>
<li>All the other users <span class="No-Break">and groups</span></li>
</ul>
<p>This is a crude security system. It’s sufficient for small servers and desktop uses but, for more complex setups, it is sometimes too restraining. There are other additional systems, such<a id="_idIndexMarker124"/> as <strong class="bold">Access Control Lists</strong> (<strong class="bold">ACLs</strong>), AppArmor, SELinux, and more. We are not going to cover them in <span class="No-Break">this book.</span></p>
<p>With the use of the previous systems, we can still achieve quite a lot regarding our <span class="No-Break">system security.</span></p>
<p>How do those rights and ownership work? We<a id="_idIndexMarker125"/> use the <strong class="source-inline">ls</strong> command (list files <span class="No-Break">and directories):</span></p>
<pre class="console">
admin@myhome:/$ ls -ahl
total 36K
drwxr-xr-x 3 admin admin 4.0K Aug 20 20:21 .
drwxr-xr-x 3 root  root  4.0K Aug 20 14:35 ..
-rw------- 1 admin admin  650 Aug 20 20:21 .Bash_history
-rw-r--r-- 1 admin admin  220 Aug  4  2021 .Bash_logout
-rw-r--r-- 1 admin admin 3.5K Aug 20 14:47 .Bashrc
-rw-r--r-- 1 admin admin    0 Aug 20 14:40 .cloud-locale-test.skip
-rw------- 1 admin admin   28 Aug 20 16:39 .lesshst
-rw-r--r-- 1 admin admin  807 Aug  4  2021 .profile
drwx------ 2 admin admin 4.0K Aug 20 14:35 .ssh
-rw------- 1 admin admin 1.5K Aug 20 14:47 .viminfo</pre>
<p>The output is presented in <span class="No-Break">nine columns.</span></p>
<p>The first column<a id="_idIndexMarker126"/> presents the type of the entry and the rights in a concise manner, but let’s jump to the third and fourth. Those columns inform us about who is the owner of the file and what user group the file belongs to. All files and directories must belong to a user and to a group. In the preceding output, most of the files belong to the user admin and to the group admin. The exception is the <strong class="source-inline">..</strong> directory, which belongs to the <strong class="source-inline">root</strong> user and <strong class="source-inline">root</strong> group. It is common to denote this pair in the <span class="No-Break">form </span><span class="No-Break"><strong class="source-inline">user:group</strong></span><span class="No-Break">.</span></p>
<p>The next columns describe the size (with a directory, it describes the size of the entry, not how much space the directory contents take), the date of the last change, the time of the last change, and the name of <span class="No-Break">the entry.</span></p>
<p>Now, let us go back to the first column. It informs us what an owner, a group, and all other users in the system are allowed to do with the given file <span class="No-Break">or directory:</span></p>
<ul>
<li>The letter <strong class="source-inline">d</strong> means that we are dealing with a directory. A dash (<strong class="source-inline">–</strong>) means it’s <span class="No-Break">a file.</span></li>
<li>Next is a group of nine one-letter symbols that denote who can do what with the <span class="No-Break">given entry:</span></li>
</ul>
<p>The first <a id="_idIndexMarker127"/>three letters denote what the file or directory owner can do with it. <strong class="source-inline">r</strong> means that they can read it, <strong class="source-inline">w</strong> means they can write to it, and <strong class="source-inline">x</strong> means they can execute it as a program. In the case of a text file with <strong class="source-inline">x</strong> set, the shell will try to run it as a script. The caveat is when we are dealing with a directory. <strong class="source-inline">x</strong> means that we can change a current working directory to it. It is possible to be able to go into a directory (<strong class="source-inline">x</strong> set) and not be able to see what is in it (<strong class="source-inline">r</strong> <span class="No-Break">not set).</span></p>
<p>The same three letters explain the group rights in the <span class="No-Break">second grouping.</span></p>
<p>The same set explains all other users’ rights in the <span class="No-Break">third grouping.</span></p>
<p>In the preceding output, <strong class="source-inline">.Bash_history</strong> is a file (it has a dash in the first field); the owner of the file (user admin) can read from it and write to it. It is possible to be able to write to a file (for example, a log file) but not be able to read from it. The file cannot be executed as a script (a dash). The next six dashes inform us that neither users assigned to the group admin nor any other user or group in the system can do anything with <span class="No-Break">this file.</span></p>
<p>There is one exception, and it is the <strong class="source-inline">root</strong> user. Without stepping up with ACLs and tools such as SELinux, you cannot limit root’s omnipotence in the system. Even for a file or directory that has no rights assigned (all dashes), <strong class="source-inline">root</strong> has full access <span class="No-Break">to it.</span></p>
<p>The administration of the ownership and the rights is done by means of <span class="No-Break">two commands:</span></p>
<ul>
<li><strong class="source-inline">chown</strong>: This <a id="_idIndexMarker128"/>command allows you to change the ownership of a file or directory. The name is a shortcut for <em class="italic">changing owners</em>. The syntax is quite simple. Let’s take this opportunity to exercise a bit with the notation in <span class="No-Break">Linux help:</span></li>
</ul>
<pre class="console">
chown [OPTION]... [OWNER][:[GROUP]] FILE...</pre>
<p class="list-inset">There is an unwritten convention that most, if not all, commands’ help <span class="No-Break">adhere to:</span></p>
<ul>
<li>Text without any brackets must be typed <span class="No-Break">as shown.</span></li>
<li>Anything inside <strong class="source-inline">[ ]</strong> brackets is optional. In the <strong class="source-inline">chown</strong> command, the user and group are optional, but you must supply at <span class="No-Break">least one.</span></li>
<li>Text in <strong class="source-inline">&lt; &gt;</strong> brackets is mandatory but is a placeholder for whatever you will have <span class="No-Break">to supply.</span></li>
<li>Brackets <strong class="source-inline">{ }</strong> denote<a id="_idIndexMarker129"/> a set of options and you’re supposed to choose one. They can be separated by a vertical <span class="No-Break">line, </span><span class="No-Break"><strong class="source-inline">|</strong></span><span class="No-Break">.</span></li>
<li>Three dots after an element means this element can be supplied multiple times. In the <strong class="source-inline">chown</strong> case, it’s the name of the file <span class="No-Break">or directory.</span></li>
</ul>
<p class="list-inset">The following is a set of ownership changes that I apply to <span class="No-Break">a file:</span></p>
<ul>
<li>I change the ownership from <strong class="source-inline">admin</strong> to <strong class="source-inline">testuser</strong>, but I leave the group unchanged. Please note that changing actually requires the use of the <strong class="source-inline">root</strong> account (via the <strong class="source-inline">sudo</strong> command, explained in <a href="B18197_03.xhtml#_idTextAnchor050"><span class="No-Break"><em class="italic">Chapter 3</em></span></a><span class="No-Break">).</span></li>
<li>I change the ownership back to <strong class="source-inline">admin</strong>, but change the group <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">testuser</strong></span><span class="No-Break">:</span></li>
</ul>
<pre class="console">
admin@myhome:~$ ls -ahl testfile
-rw-r--r-- 1 admin admin 0 Aug 22 18:32 testfile
admin@myhome:~$ sudo chown testuser testfile
admin@myhome:~$ ls -ahl testfile
-rw-r--r-- 1 testuser admin 0 Aug 22 18:32 testfile
admin@myhome:~$ sudo chown admin:testuser testfile
admin@myhome:~$ ls -ahl testfile
-rw-r--r-- 1 admin testuser 0 Aug 22 18:32 testfile</pre>
<p class="list-inset">In the preceding output, we can see that a successful call to a command produces no output (<strong class="source-inline">chown</strong>) unless the output is the purpose of the command (<strong class="source-inline">ls</strong>). This is one of the basic rules that Linux follows. In the following output, we can see what happens when the command terminates with an error—insufficient rights to change <span class="No-Break">the group:</span></p>
<pre class="console">
admin@myhome:~$ chown :testuser testfile
chown: changing group of 'testfile': Operation not permitted</pre>
<p class="list-inset">One other <a id="_idIndexMarker130"/>way to run the <strong class="source-inline">chown</strong> command is to point to a reference file, as in the <span class="No-Break">following example:</span></p>
<pre class="console">
admin@myhome:~$ sudo chown —reference=.Bash_history testfile
admin@myhome:~$ ls -ahl testfile
-rw-r—r—1 admin admin 0 Aug 22 18:32 testfile
admin@myhome:~$ ls -ahl .Bash_history
-rw------- 1 admin admin 1.1K Aug 22 18:33 .Bash_history</pre>
<p class="list-inset">Using the <strong class="source-inline">–reference</strong> option, we point to a file that will be a matrix for our changes. This will become more interesting once we move on to the <span class="No-Break">next chapter.</span></p>
<ul>
<li><strong class="source-inline">chmod</strong>: Similar<a id="_idIndexMarker131"/> to the <strong class="source-inline">chown</strong> command, <strong class="source-inline">chmod</strong> (short for <em class="italic">change mode</em>) is the<a id="_idIndexMarker132"/> one you’ll be looking for to change the rights of the assigned user <span class="No-Break">and group:</span></li>
</ul>
<pre class="console">
admin@myhome:~$ chmod --help
Usage: chmod [OPTION]... MODE[,MODE]... FILE...
  or:  chmod [OPTION]... OCTAL-MODE FILE...
  or:  chmod [OPTION]... --reference=RFILE FILE...</pre>
<p class="list-inset">The <strong class="source-inline">chmod</strong> command will accept options, mandatory mode, optionally more modes, and a list of files that the change is supposed to be applied to. As with the <strong class="source-inline">chown</strong> command, we can specify a reference file that will have its mode <span class="No-Break">copied over.</span></p>
<p class="list-inset">In the first form, you will specify the mode for either a user, a group, others, or all of them using the <span class="No-Break">following syntax:</span></p>
<pre class="console">
chmod [ugoa…] [-+=] [perms…] FILE...</pre>
<p class="list-inset">Here, the<a id="_idIndexMarker133"/> following<a id="_idIndexMarker134"/> <span class="No-Break">meanings apply:</span></p>
<ul>
<li><strong class="source-inline">u</strong>: User, in other words, the owner of <span class="No-Break">the file</span></li>
<li><strong class="source-inline">g</strong>: Group that owns <span class="No-Break">the file</span></li>
<li><strong class="source-inline">o</strong>: <span class="No-Break">Others—all others</span></li>
<li><strong class="source-inline">a</strong>: All, <span class="No-Break">meaning everyone</span></li>
<li><strong class="source-inline">-</strong>: Remove the <span class="No-Break">specified right</span></li>
<li><strong class="source-inline">+</strong>: Add the <span class="No-Break">specified right</span></li>
<li><strong class="source-inline">=</strong>: Make the rights exactly <span class="No-Break">as specified</span></li>
</ul>
<p class="list-inset">Let’s see <span class="No-Break">some examples.</span></p>
<p class="list-inset">This adds read and write permissions to the <strong class="source-inline">testfile</strong> file for the <span class="No-Break">file owner:</span></p>
<pre class="console">
chmod u+rw testfile</pre>
<p class="list-inset">This removes the execute right to the <strong class="source-inline">testfile</strong> file for everyone who is not the file owner and is not in the group that owns <span class="No-Break">the file:</span></p>
<pre class="console">
chmod o-x testfile</pre>
<p>This gives the user and the group read and execute rights to the <span class="No-Break"><strong class="source-inline">testfile</strong></span><span class="No-Break"> file:</span></p>
<pre class="console">
chmod ug=rx testfile</pre>
<p class="list-inset">In the syntax summary we have pasted, the middle row is interesting. The octal mode means that we can specify the mode by means of numbers. This is especially useful in scripts, as dealing with numbers is easier. Once you memorize the mode numbers, you may find it easier to use the <span class="No-Break">octal </span><span class="No-Break"><strong class="source-inline">chmod</strong></span><span class="No-Break">.</span></p>
<p class="list-inset">The formula for the numeric setting of file mode <span class="No-Break">is simple:</span></p>
<ul>
<li><strong class="source-inline">0</strong>: no <span class="No-Break">rights (</span><span class="No-Break"><strong class="source-inline">---</strong></span><span class="No-Break">)</span></li>
<li><strong class="source-inline">1</strong>: execute <span class="No-Break">mode (</span><span class="No-Break"><strong class="source-inline">--x</strong></span><span class="No-Break">)</span></li>
<li><strong class="source-inline">2</strong>: write <span class="No-Break">mode (</span><span class="No-Break"><strong class="source-inline">-w-</strong></span><span class="No-Break">)</span></li>
<li><strong class="source-inline">4</strong>: read <span class="No-Break">mode (</span><span class="No-Break"><strong class="source-inline">r–</strong></span><span class="No-Break">)</span></li>
</ul>
<p class="list-inset">To set<a id="_idIndexMarker135"/> the<a id="_idIndexMarker136"/> mode on a file or directory, you will use a sum of the rights you want to apply, starting with a leading <strong class="source-inline">0</strong>, which will inform <strong class="source-inline">chmod</strong> that you are setting octal mode. The syntax is <span class="No-Break">as follows:</span></p>
<pre class="console">
chmod [OPTION]... OCTAL-MODE FILE...</pre>
<p class="list-inset">There is a very important difference between this form and the letter one—you must specify the mode for all three types of entities: user, group, and others. You cannot omit any of them. This means that you also won’t be using the <strong class="source-inline">-</strong>, <strong class="source-inline">+</strong>, or <strong class="source-inline">=</strong> signs. With the octal syntax, the rights will always be exactly <span class="No-Break">as specified.</span></p>
<p class="list-inset">To combine the modes, you will add their numbers and use the sum as the final specifier. You will find that this is a very elegant solution. There are no two identical sums of those numbers (combination of rights). <span class="No-Break">Try it:</span></p>
<ul>
<li>Execute and read is 1 and 2 = 3. There is no other combination of the modes that can result <span class="No-Break">in 3.</span></li>
<li>Read and write is 2 and 4 = 6. Again, no other combination can result <span class="No-Break">in 6.</span></li>
</ul>
<p class="list-inset">Now, let’s try <span class="No-Break">some examples.</span></p>
<p class="list-inset">The owner of the file will have read and write access to the file, while the group and others will have <span class="No-Break">read access:</span></p>
<pre class="console">
chmod 0644 testfile</pre>
<p class="list-inset">The owner of the file has all the rights (read, write, and execute), while the group and others can read and <span class="No-Break">execute only:</span></p>
<pre class="console">
chmod 0755 testfile</pre>
<p class="list-inset">The leading <strong class="source-inline">0</strong> in the mode is <span class="No-Break">not obligatory.</span></p>
<p>We have covered the filesystem, directory structure, and basic file permissions related to users and groups. In the next section, we will i<a id="_idTextAnchor042"/>ntroduce basic <span class="No-Break">Linux commands.</span></p>
<h1 id="_idParaDest-41">Interacting with the system</h1>
<p>Programs and scripts <a id="_idIndexMarker137"/>lying on a hard drive are just files. The moment they get mapped to the memory and start performing their function, they become <strong class="bold">processes</strong>. At this stage, you can safely assume that anything running in the system is some kind of <span class="No-Break">a process.</span></p>
<h2 id="_idParaDest-42"><a id="_idTextAnchor043"/>Process this</h2>
<p>Processes in Linux have <a id="_idIndexMarker138"/>several characteristics that you need to be <span class="No-Break">aware of:</span></p>
<ul>
<li><strong class="bold">Process ID</strong> (<strong class="bold">PID</strong>): A <a id="_idIndexMarker139"/>system-wide unique <span class="No-Break">numerical identifier.</span></li>
<li><strong class="bold">Parent process ID</strong> (<strong class="bold">PPID</strong>): Every single process in the Linux system, except process <a id="_idIndexMarker140"/>number 1, has a parent. Process number 1 is an <em class="italic">init</em> process. It is the program responsible for starting all the system services. A program that starts another program<a id="_idIndexMarker141"/> is known as a <strong class="bold">parent</strong>. A program started by another program is known<a id="_idIndexMarker142"/> as a <strong class="bold">child</strong>. When you log in to the system, your shell is a process too, and it has its PID. When you start a program in that shell, your command-line PID will become the parent ID of that program. If a process loses its parent (i.e., the parent process terminates without terminating its child), then the child process is assigned a new parent: process <span class="No-Break">number 1.</span></li>
<li><strong class="bold">State</strong>: There<a id="_idIndexMarker143"/> are five states that a process can <span class="No-Break">be in:</span><ul><li><strong class="bold">R</strong>: Runnable or running. There is a <a id="_idIndexMarker144"/>distinction between running and runnable, but in the statistics, they are grouped together. A <strong class="bold">running</strong> process is one that actively takes CPU time and resources. It is being executed as we speak. A <strong class="bold">runnable</strong> process<a id="_idIndexMarker145"/> is one that has been put aside while another process takes its place. This is how single-core computers create the illusion of multitasking—executing many programs at once; they rotate every started program on the CPU in time slices that are so short that humans can’t notice when the program is actually being executed on the CPU and when it is waiting in <span class="No-Break">the queue.</span></li><li><strong class="bold">S</strong>: Interruptible sleep. A <a id="_idIndexMarker146"/>program may request an additional resource besides RAM and CPU time. If it needs to wait for the resource to become available, then it goes into a separate queue and <em class="italic">sleeps</em>. This program will <em class="italic">awake</em> when the required resource is available and can be interacted with using interrupts—special kinds of signals. We will cover signals in <a href="B18197_03.xhtml#_idTextAnchor050"><span class="No-Break"><em class="italic">Chapter 3</em></span></a><span class="No-Break">.</span></li><li><strong class="bold">D</strong>: Uninterruptible sleep. As with the preceding <strong class="source-inline">S</strong> state, the process went to sleep. It will not, however, accept any interrupts and signals. It will only awake when a requested resource <span class="No-Break">becomes available.</span></li><li><strong class="bold">T</strong>: We can instruct a program to stop its execution and wait. This is called a <strong class="bold">stopped state</strong>. Such a<a id="_idIndexMarker147"/> process can be brought back to execution with the use of a <span class="No-Break">special signal.</span></li><li><strong class="bold">Z</strong>: Zombie. When a process ends its execution, it informs its parent process about that. The same happens when the process is terminated. The parent is responsible for removing it from the process table. Until it happens, the process remains in a zombie state, also <a id="_idIndexMarker148"/><span class="No-Break">called </span><span class="No-Break"><strong class="bold">defunc</strong></span><span class="No-Break">.</span></li></ul></li>
<li><strong class="bold">User</strong>: The owner of the process, or rather, a user with whose system rights the process is being executed. If that user cannot do something, the process cannot do <span class="No-Break">it either.</span></li>
<li><strong class="bold">CPU</strong>: Percentage of the CPU time the process is using, presented as a floating-point number between 0.0 <span class="No-Break">and 1.0.</span></li>
<li><strong class="bold">MEM</strong>: The memory usage, again between 0.0 and 1.0, where 1.0 is 100% of <span class="No-Break">system memory.</span></li>
</ul>
<p>Each process has more characteristics than the ones we’ve just covered, but those are absolutely essential. Managing processes is a subject for a separate chapter, if not an <span class="No-Break">entire book.</span></p>
<p>The tool to inspect the processes is called <strong class="source-inline">ps</strong>. It seems like a pretty simple command at first sight, but in reality, the <strong class="source-inline">man</strong> page shows an incredible amount of options. It is important to note that <strong class="source-inline">ps</strong> itself will only print a snapshot of the system. It won’t be monitoring and updating its output. You can combine <strong class="source-inline">ps</strong> with <strong class="source-inline">watch</strong> or <strong class="source-inline">run top</strong> or <strong class="source-inline">htop</strong> commands to have continuous information about the processes and <span class="No-Break">system load.</span></p>
<p>In its simplest form, <strong class="source-inline">ps</strong> will print all processes running with the same user ID as the user that <span class="No-Break">calls it:</span></p>
<pre class="console">
admin@myhome:~$ ps
    PID TTY          TIME CMD
  24133 pts/1    00:00:00 Bash
  25616 pts/1    00:00:00 ps</pre>
<p>On my Linux machine, there are only two processes running for my user: the Bash shell and the <strong class="source-inline">ps</strong> <span class="No-Break">program itself.</span></p>
<p>The <strong class="source-inline">ps</strong> command<a id="_idIndexMarker149"/> has several interesting options that help interrogate the system about the running processes. Now, specifying options to <strong class="source-inline">ps</strong> is tricky, because it accepts two syntaxes, one with a dash and one without, and some options have different meanings depending on the dash. Let me quote the <span class="No-Break"><strong class="source-inline">man</strong></span><span class="No-Break"> page:</span></p>
<pre class="console">
       1   UNIX options, which may be grouped and must be preceded by a dash.
       2   BSD options, which may be grouped and must not be used with a dash.
       3   GNU long options, which are preceded by two dashes.
Note that ps -aux is distinct from ps aux.  The POSIX and UNIX standards require that ps -aux print all processes owned by a user named x, as well as printing all processes that would be selected by the -a option.  If the
       user named x does not exist, this ps may interpret the command as ps aux instead and print a warning.  This behavior is intended to aid in transitioning old scripts and habits.  It is fragile, subject to change, and thus
       should not be relied upon.</pre>
<p>I have cut some output for brevity. This distinction may become important once you start working with shell scripts, as they may adopt any of the three syntaxes. Whenever in doubt, use the <span class="No-Break">dash notation:</span></p>
<ul>
<li><strong class="source-inline">-f</strong>: So-called <strong class="bold">full output</strong>. It will print the ID of the user that runs the command, <strong class="source-inline">PID</strong>, <strong class="source-inline">PPID</strong>, <strong class="bold">CPU utilization</strong> (<strong class="source-inline">C</strong>), <strong class="bold">start time of the process</strong> (<strong class="source-inline">STIME</strong>), <strong class="bold">terminal</strong> (<strong class="source-inline">TTY</strong>) to which it is attached, <strong class="bold">how long it has been running</strong> (<strong class="source-inline">TIME</strong>), and the command that started <span class="No-Break">the process:</span></li>
</ul>
<pre class="console">
admin@myhome:~$ ps -f
UID          PID    PPID  C STIME TTY          TIME CMD
admin      24133   24132  0 16:05 pts/1    00:00:00 -Bash
admin      25628   24133  0 17:35 pts/1    00:00:00 ps -f</pre>
<ul>
<li><strong class="source-inline">-e</strong>: All <a id="_idIndexMarker150"/>processes of <span class="No-Break">all users:</span></li>
</ul>
<pre class="console">
admin@myhome:~$ ps -e
    PID TTY          TIME CMD
      1 ?        00:00:04 systemd
      2 ?        00:00:00 kthreadd
[...]
  25633 ?        00:00:00 kworker/u30:0-events_unbound
  25656 pts/1    00:00:00 ps</pre>
<ul>
<li><strong class="source-inline">-ef</strong>: To see all processes in the long <span class="No-Break">output format:</span></li>
</ul>
<pre class="console">
admin@myhome:~$ ps -ef
UID          PID    PPID  C STIME TTY          TIME CMD
root           1       0  0 Aug20 ?        00:00:04 /sbin/init
root           2       0  0 Aug20 ?        00:00:00 [kthreadd]</pre>
<ul>
<li><strong class="source-inline">-ejH</strong>: A nice process tree. The more indented CMDs (the last column of the output) are children of the less <span class="No-Break">indented ones:</span></li>
</ul>
<pre class="console">
admin@myhome:~$ ps -ejH
    PID    PGID     SID TTY          TIME CMD
      2       0       0 ?        00:00:00 kthreadd
      3       0       0 ?        00:00:00   rcu_gp
      4       0       0 ?        00:00:00   rcu_par_gp
      6       0       0 ?        00:00:00   kworker/0:0H-events_highpri
      9       0       0 ?        00:00:00   mm_percpu_wq</pre>
<p>There are many more options available, especially to control which fields are of interest. We will come back to them in <span class="No-Break">later chapters.</span></p>
<p>There is a <a id="_idIndexMarker151"/>command that has a name that can be very misleading, the <strong class="source-inline">kill</strong> command. It is <a id="_idIndexMarker152"/>used to send so-called signals to the running processes. Signals are a way of telling processes to perform a kind of action. One of them actually kills the program, terminating it at once, but that’s just one <span class="No-Break">of many.</span></p>
<p>To list existing<a id="_idIndexMarker153"/> signals, use the <strong class="source-inline">kill -</strong><span class="No-Break"><strong class="source-inline">l</strong></span><span class="No-Break"> command:</span></p>
<pre class="console">
admin@myhome:~$ admin@myhome:~$ kill -l
 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP
 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL 10) SIGUSR1
11) SIGSEGV 12) SIGUSR2 13) SIGPIPE 14) SIGALRM 15) SIGTERM
16) SIGSTKFLT 17) SIGCHLD 18) SIGCONT 19) SIGSTOP 20) SIGTSTP
21) SIGTTIN 22) SIGTTOU 23) SIGURG 24) SIGXCPU 25) SIGXFSZ
26) SIGVTALRM 27) SIGPROF 28) SIGWINCH 29) SIGIO 30) SIGPWR
31) SIGSYS 34) SIGRTMIN 35) SIGRTMIN+1 36) SIGRTMIN+2 37) SIGRTMIN+3
38) SIGRTMIN+4 39) SIGRTMIN+5 40) SIGRTMIN+6 41) SIGRTMIN+7 42) SIGRTMIN+8
43) SIGRTMIN+9 44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9 56) SIGRTMAX-8 57) SIGRTMAX-7
58) SIGRTMAX-6 59) SIGRTMAX-5 60) SIGRTMAX-4 61) SIGRTMAX-3 62) SIGRTMAX-2
63) SIGRTMAX-1 64) SIGRTMAX</pre>
<p>Okay, this<a id="_idIndexMarker154"/> list is cute, but it tells us nothing. How can we tell what each of those signals does? Here’s a bit of detective work. First, since we see those in the <strong class="source-inline">kill -l</strong> output, let’s invoke the <strong class="source-inline">man kill</strong> command and see whether there’s anything that can explain them <span class="No-Break">to us:</span></p>
<pre class="console">
EXAMPLES
       kill -9 -1
              Kill all processes you can kill.
       kill -l 11
              Translate number 11 into a signal name.
       kill -L
              List the available signal choices in a nice table.
       kill 123 543 2341 3453
              Send the default signal, SIGTERM, to all those processes.
SEE ALSO
       kill(2), killall(1), nice(1), pkill(1), renice(1), signal(7), sigqueue(3), skill(1)</pre>
<p>There is an <a id="_idIndexMarker155"/>examples section that shows and describes one signal, but in the <strong class="source-inline">SEE ALSO</strong> section, we can see a reference to a <strong class="source-inline">man</strong> page signal in section <strong class="source-inline">7</strong>. Let us check <span class="No-Break">it out:</span></p>
<pre class="console">
admin@myhome:~$ man 7 signal
SIGNAL(7)                                                              
                                 Linux Programmer's Manual                                     
                                                         SIGNAL(7)
NAME
       signal - overview of signals</pre>
<p>Now, there’s a nice page with a table listing all signals available to you <span class="No-Break">in Linux.</span></p>
<p>So, how do you <a id="_idIndexMarker156"/>use this <strong class="source-inline">kill</strong> command? Do you have to learn about all these signals? The answer is no. There are a handful of signals that you’ll be using. And if you forget any, don’t hesitate to <strong class="source-inline">man</strong> them or search <span class="No-Break">the web:</span></p>
<ul>
<li><strong class="source-inline">kill -9 PID</strong>: The infamous <strong class="source-inline">SIGKILL</strong>. This terminates the process whose PID we have specified abruptly, forcing it to omit any cleanup it may do normally. If it has opened file handles, it won’t free them; if it has to write any information to a file or synchronize with another program, it won’t do it. This should be used sparingly, only when we are sure that we really have to stop a program <span class="No-Break">from running.</span></li>
<li><strong class="source-inline">kill PID</strong>: If no signal is specified, then by default, <strong class="source-inline">SIGTERM</strong> is sent. This tells the program to stop running but gracefully—perform all the exit routines and cleanup it needs. If you have to use the <strong class="source-inline">kill</strong> command, this is the <span class="No-Break">preferred use.</span></li>
<li><strong class="source-inline">kill -1</strong>: The so-called <strong class="source-inline">SIGHUP</strong> signal. It was originally used for detecting loss of user connection—hangup of the phone line. Currently, it is often used to tell the process to reread <span class="No-Break">its configuration.</span></li>
</ul>
<p>Here is an example of <a id="_idIndexMarker157"/>calling <strong class="source-inline">kill</strong> to terminate a process. I have started a shell script that does nothing except wait for a keyboard input. I called <span class="No-Break">it </span><span class="No-Break"><strong class="source-inline">sleep.sh</strong></span><span class="No-Break">:</span></p>
<pre class="console">
admin@myhome:~$ ps aux | grep sleep
admin      24184  0.0  0.2   5648  2768 pts/1    S+   16:09   0:00 /bin/Bash ./sleep.sh
admin@myhome:~$ pgrep sleep.sh
24184
admin@myhome:~$ kill -9 24184
admin@myhome:~$ pgrep sleep.sh
admin@myhome:~$ ps aux | grep sleep
admin      24189  0.0  0.0   4732   732 pts/0    S+   16:09   0:00 grep sleep</pre>
<p>First, I used <strong class="source-inline">ps aux</strong> and searched in the output for the <strong class="source-inline">sleep.sh</strong> process, just to show you that it’s there. Next, I used <strong class="source-inline">pgrep</strong> to find the PID of my running script quickly. I have supplied this PID to the <strong class="source-inline">kill -9</strong> command. In effect, <strong class="source-inline">sleep.sh</strong> has been killed. This can be confirmed on another Terminal, where I was <span class="No-Break">running </span><span class="No-Break"><strong class="source-inline">sleep.sh</strong></span><span class="No-Break">:</span></p>
<pre class="console">
admin@myhome:~$ ./sleep.sh
Killed</pre>
<p>Had I simply used <strong class="source-inline">kill</strong>, the output would <span class="No-Break">be different:</span></p>
<pre class="console">
admin@myhome:~$ ./sleep.sh
Terminated</pre>
<p>There is another way of delivering two of all signals to running programs, but only if currently executing in the shell we’re logged into in the foreground; this means it has the control of the <a id="_idIndexMarker158"/>screen <span class="No-Break">and keyboard:</span></p>
<ul>
<li>Pressing the <em class="italic">Ctrl </em>+ <em class="italic">C</em> keys will send <strong class="source-inline">SIGINT</strong> to the program. <strong class="source-inline">SIGINT</strong> tells the program that the user has pressed the key combination and it should stop. It’s still up to the program how the termination <span class="No-Break">should occur.</span></li>
<li>Pressing the <em class="italic">Ctrl</em> + <em class="italic">D</em> keys will send <strong class="source-inline">SIGQUIT</strong>—it is like <strong class="source-inline">SIGINT</strong> but also produces a so-called core dump, or a file that can be used in a <span class="No-Break">debugging process.</span></li>
</ul>
<p>The common way of denoting those combinations in text is <strong class="source-inline">^c</strong> and <strong class="source-inline">^d</strong> (<strong class="source-inline">^</strong> for the <em class="italic">Ctrl</em> key), <strong class="source-inline">ctrl+c</strong> and <strong class="source-inline">ctrl+d</strong> (<strong class="source-inline">ctrl</strong> being<a id="_idTextAnchor044"/> a shortcut for the <em class="italic">Ctrl</em> key), and <strong class="source-inline">C-c</strong> and <strong class="source-inline">C-d</strong> (<strong class="source-inline">C</strong> denoting the <em class="italic">Ctrl</em> <span class="No-Break">key, again).</span></p>
<h2 id="_idParaDest-43"><a id="_idTextAnchor045"/>Looking for something?</h2>
<p>There are times<a id="_idIndexMarker159"/> when you need to look for a directory or a file on the filesystem. Linux has a set of commands that let you perform this operation. Of them all, <strong class="source-inline">find</strong> is the most powerful. To cover all of its abilities would take a lot more space than we have. You can look for a file or directory <strong class="source-inline">of both</strong> that have exactly the name you specified, that have part of the name that you specified, that have been modified at a defined point in time, that are owned by a user or a group, and many more scenarios. Additionally, on each file that has been found, an action can be performed, such as rename, compress, or search for <span class="No-Break">a word.</span></p>
<p>In the following example, we’re looking for a file, <strong class="source-inline">signals.h</strong>, in the <strong class="source-inline">/</strong><span class="No-Break"><strong class="source-inline">usr</strong></span><span class="No-Break"> directory:</span></p>
<pre class="console">
admin@myhome:/$ find / -name os-release
find: '/lost+found': Permission denied
find: '/etc/sudoers.d': Permission denied
/etc/os-release
find: '/etc/ssl/private': Permission denied
/usr/lib/os-release
[...]</pre>
<p>First, we call <strong class="source-inline">find</strong> itself, then we tell it to start looking at the beginning of the filesystem (<strong class="source-inline">/</strong>), and then we tell it to look for a file named <strong class="source-inline">os-release</strong> (<strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">name os-release</strong></span><span class="No-Break">).</span></p>
<p>You will notice that in the output, which I have cut for brevity, there are errors about files to which <strong class="source-inline">find</strong> had no <span class="No-Break">proper rights.</span></p>
<p>If you are <a id="_idIndexMarker160"/>unsure about the case of the name, that is, whether it contains lowercase or uppercase letters (remember that Linux is case -sensitive and <em class="italic">OS-Release</em> is not the same file as <em class="italic">os-release</em>), you can use the <strong class="source-inline">-iname</strong> <span class="No-Break">option instead.</span></p>
<p>If you are sure that what you are looking for is a file, then you can use the <strong class="source-inline">-type </strong><span class="No-Break"><strong class="source-inline">f</strong></span><span class="No-Break"> option:</span></p>
<pre class="console">
admin@myhome:/$ find / -type f -name os-release</pre>
<p>For a directory option, use <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">type d</strong></span><span class="No-Break">.</span></p>
<p>To look for files that match a pattern, say filenames that end with <strong class="source-inline">.sh</strong>, you’d use <span class="No-Break">a pattern:</span></p>
<pre class="console">
admin@myhome:/$ find / -type f -name "*.sh"</pre>
<p>The asterisk means any number of any characters. We enclosed it in the quotes to avoid problems with the shell interpreting the asterisk before <strong class="source-inline">find</strong> got a chance. We will explain all the special <a id="_idIndexMarker161"/>signs (called <strong class="bold">globs</strong>) and regular expressions in the next chapter, <span class="No-Break"><em class="italic">Intermediate Linux</em></span><span class="No-Break">.</span></p>
<p>To delete all found files, you can use the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">delete</strong></span><span class="No-Break"> option:</span></p>
<pre class="console">
admin@myhome:~$ find . -type f -name test -delete</pre>
<p>To perform an action on the found file, you can use the <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">exec</strong></span><span class="No-Break"> option:</span></p>
<pre class="console">
admin@myhome:/$ find / -type f -name  os-release -exec grep -i debian {} \;
PRETTY_NAME="Debian GNU/Linux 11 (bullseye)"
NAME="Debian GNU/Linux"
ID=debian
HOME_URL="https://www.debian.org/"
SUPPORT_URL="https://www.debian.org/support"
BUG_REPORT_URL="https://bugs.debian.org/"</pre>
<p>In the preceding example, we have used the command called <strong class="source-inline">grep</strong> to look for any line that contains the word <strong class="source-inline">debian</strong>, no matter whether uppercase <span class="No-Break">or lowercase.</span></p>
<p>This leads us to the <span class="No-Break"><strong class="source-inline">grep</strong></span><span class="No-Break"> command.</span></p>
<p>The <strong class="source-inline">grep</strong> command <a id="_idIndexMarker162"/>is used to look for an occurrence of a pattern inside a file. Upon finding this pattern-matching line, it prints it. The <strong class="source-inline">grep</strong> command is similar to the <strong class="source-inline">find</strong> command, except its purpose is to search inside the files, while <strong class="source-inline">find</strong> only cares for the characteristics of files and <span class="No-Break">directories themselves.</span></p>
<p>Assume a text file called <strong class="source-inline">red_fox.txt</strong> with the <span class="No-Break">following content:</span></p>
<pre class="console">
admin@myhome:~$ cat red_fox.txt
The red fox
jumps over
the lazy
brown dog.</pre>
<p>As a side note, <strong class="source-inline">cat</strong> is a command that prints the contents of a specified file to <span class="No-Break">the Terminal.</span></p>
<p>Let’s say we want to find all lines that contain the <span class="No-Break">word </span><span class="No-Break"><strong class="source-inline">the</strong></span><span class="No-Break">:</span></p>
<pre class="console">
admin@myhome:~$ grep -i The red_fox.txt
The red fox
the lazy</pre>
<p>You have probably guessed that the <strong class="source-inline">-i</strong> option means that we don’t care about <span class="No-Break">the case.</span></p>
<p>But wait. We can search for alternatives. Let’s say we care for lines that contain either <strong class="source-inline">fox</strong> or <strong class="source-inline">dog</strong>. You would use the <strong class="source-inline">-e</strong> option for each word you search for or the <strong class="source-inline">-E</strong> option with all the words in single quotes and separated by the <strong class="source-inline">|</strong> <span class="No-Break">character:</span></p>
<pre class="console">
admin@myhome:~$ grep -e fox -e dog red_fox.txt
The red fox
brown dog.
admin@myhome:~$ grep -E 'fox|dog' red_fox.txt
The red fox
brown dog.</pre>
<p>By adding the <strong class="source-inline">-n</strong> option, you’ll get information on which line the match was <span class="No-Break">found in:</span></p>
<pre class="console">
admin@myhome:~$ grep -n -E 'fox|dog' red_fox.txt
1:The red fox
4:brown dog.</pre>
<p>You can look for lines that start with a given word or have the specified pattern at the end of <span class="No-Break">the line.</span></p>
<p>You can even <strong class="source-inline">grep</strong> all <a id="_idIndexMarker163"/>files in a directory hierarchy. The syntax is a bit different then: the pattern comes first, and the directory comes at the end. Also, you get the name of the file where the match <span class="No-Break">was found:</span></p>
<pre class="console">
admin@myhome:~$ grep -r "fox" .
./red_fox.txt:The red fox</pre>
<p>The most power for both <strong class="source-inline">find</strong> and <strong class="source-inline">grep</strong> comes from a concept called <strong class="bold">regular expressions</strong> (<strong class="bold">regex</strong> or <strong class="bold">regexp</strong> for short), which have a book of their own and can be confusing for <a id="_idIndexMarker164"/>new users. We are going to explain them in <em class="italic">Chapters 3</em> and <em class="italic">4</em>. We will, however, be only introducing the most everyday uses <span class="No-Break">of them.</span></p>
<p>If you are looking for a program and want to know its full path, there is a command for that, and it is <a id="_idIndexMarker165"/>called <strong class="source-inline">whereis</strong>. Here is <span class="No-Break">an example:</span></p>
<pre class="console">
admin@myhome:~$ whereis ping
ping: /usr/bin/ping /usr/share/man/man8/ping.8.gz</pre>
<p>The <strong class="source-inline">whereis</strong> command will not only print the whole path to the binary but also a corresponding <strong class="source-inline">man</strong> page, if it has <span class="No-Break">one installed.</span></p>
<h2 id="_idParaDest-44"><a id="_idTextAnchor046"/>Let’s be manipulative</h2>
<p>There are four basic operations <a id="_idIndexMarker166"/>that can be performed on files <span class="No-Break">and directories:</span></p>
<ul>
<li><span class="No-Break">Create</span></li>
<li>Rename <span class="No-Break">or move</span></li>
<li><span class="No-Break">Remove</span></li>
<li><span class="No-Break">Copy</span></li>
</ul>
<p>Each of these <a id="_idIndexMarker167"/>operations has a <span class="No-Break">special tool:</span></p>
<ul>
<li><strong class="source-inline">mkdir</strong>: This command<a id="_idIndexMarker168"/> has very simple and limited syntax. Basically, you are telling it to create a directory with a given name. If you are creating nested directories, that is, one folder contains another, all the directories in the path must exist. If they don’t, you can create them using the special <strong class="source-inline">-</strong><span class="No-Break"><strong class="source-inline">p</strong></span><span class="No-Break"> option:</span></li>
</ul>
<pre class="console">
admin@myhome:~$ mkdir test
admin@myhome:~$ ls -l
total 4
drwxr-xr-x 2 admin admin 4096 Aug 24 15:17 test
admin@myhome:~$ mkdir something/new
mkdir: cannot create directory 'something/new': No such file or directory
admin@myhome:~$ mkdir -p something/new
admin@myhome:~$ ls -l
total 8
drwxr-xr-x 3 admin admin 4096 Aug 24 15:18 something
drwxr-xr-x 2 admin admin 4096 Aug 24 15:17 test</pre>
<p class="list-inset">In the preceding example, you can see that I create a directory test directly in my home folder. Next, I try to create a folder, <strong class="source-inline">new</strong>, inside the <strong class="source-inline">something</strong> folder. However, the latter doesn’t exist and <strong class="source-inline">mkdir</strong> tells me so and refuses to create the new directory. I use the special <strong class="source-inline">-p</strong> option to create a whole path to the <span class="No-Break">new directory.</span></p>
<ul>
<li><strong class="source-inline">mv</strong>: This is a<a id="_idIndexMarker169"/> command that is used to move and rename files and directories. Again, the syntax is pretty simple, although this command offers a little more functionality, such as creating a backup of <span class="No-Break">moved files.</span><p class="list-inset">To rename a file or directory, we move it from the current name to the <span class="No-Break">new one:</span></p></li>
</ul>
<pre class="console">
admin@myhome:~$ mv test no-test
admin@myhome:~$ ls -l
total 8
drwxr-xr-x 2 admin admin 4096 Aug 24 15:17 no-test</pre>
<p class="list-inset">Check out its <strong class="source-inline">man</strong> page or <strong class="source-inline">help</strong> message to find <span class="No-Break">out more.</span></p>
<ul>
<li><strong class="source-inline">rm</strong>: This <a id="_idIndexMarker170"/>command is more interesting, mainly because it offers safety features. With the special <strong class="source-inline">-i</strong> option, you can tell it to always ask you before removing the file or directory. Normally, <strong class="source-inline">rm</strong> bails at directories, as in the <span class="No-Break">following example:</span></li>
</ul>
<pre class="console">
admin@myhome:~$ admin@myhome:~$ ls -l no-test/
total 0
-rw-r--r-- 1 admin admin 0 Aug 24 15:26 test
admin@myhome:~$ rm no-test/
rm: cannot remove 'no-test/': Is a directory
admin@myhome:~$ rm -d no-test/
rm: cannot remove 'no-test/': Directory not empty
admin@myhome:~$ rm no-test/test
admin@myhome:~$ rm -d no-test/</pre>
<p class="list-inset">I created a file test inside the <strong class="source-inline">no-test</strong> directory. <strong class="source-inline">rm</strong> refuses to remove the folder. I used the <strong class="source-inline">-d</strong> option, which instructs the command to remove empty directories. However, it still contains a file. Next, I removed the file and then <strong class="source-inline">rm -d</strong> cleanly deleted the <strong class="source-inline">no-test</strong> folder. I could have used the <strong class="source-inline">-r</strong> option, which makes the command remove all directories, even if they are <span class="No-Break">not empty.</span></p>
<ul>
<li><strong class="source-inline">cp</strong>: This <a id="_idIndexMarker171"/>command is used for copying files and directories. Note that, as with <strong class="source-inline">rm</strong>, <strong class="source-inline">cp</strong> will refuse to copy directories unless instructed with the <strong class="source-inline">-r</strong> option. <strong class="source-inline">cp</strong> arguably is the most complex and feature-rich command of all, including the ability to back up files, create links (shortcuts) instead of real copies, and more. Check out its <strong class="source-inline">man</strong> page. In the following example, I copy a <strong class="source-inline">something</strong> directory to a <strong class="source-inline">new</strong> directory. Obviously, I have to use the <strong class="source-inline">-r</strong> option. Next, I create an empty file called <strong class="source-inline">file</strong> and copy it to <strong class="source-inline">newfile</strong>. For those, I don’t require <span class="No-Break">any options:</span></li>
</ul>
<pre class="console">
admin@myhome:~$ ls -l
total 4
drwxr-xr-x 3 admin admin 4096 Aug 24 15:18 something
admin@myhome:~$ cp something/ new
cp: -r not specified; omitting directory 'something/'
admin@myhome:~$ cp -r something new
admin@myhome:~$ ls -l
total 8
drwxr-xr-x 3 admin admin 4096 Aug 24 15:33 new
drwxr-xr-x 3 admin admin 4096 Aug 24 15:18 something
admin@myhome:~$ touch file
admin@myhome:~$ cp file newfile
admin@myhome:~$ ls -l
total 8
-rw-r--r-- 1 admin admin    0 Aug 24 15:33 file
drwxr-xr-x 3 admin admin 4096 Aug 24 15:33 new
-rw-r--r-- 1 admin admin    0 Aug 24 15:34 newfile
drwxr-xr-x 3 admin admin 4096 Aug 24 15:18 something</pre>
<p>You should<a id="_idIndexMarker172"/> now understand and be able to use basic command-line commands in Linux or a similar system, such as create, copy, and delete files; you can also find content inside text files or find files or directories by name. You also have an understandi<a id="_idTextAnchor047"/>ng of processes in the system you work on. In the next chapter, we will deepen <span class="No-Break">this knowledge.</span></p>
<h1 id="_idParaDest-45">Summary</h1>
<p>We have presented but a fraction of the hundreds of commands that Linux admins may use in their work. As mentioned at the beginning of this chapter, the complete reference is beyond the scope of this book. What we have learned, however, is enough to do basic system u<a id="_idTextAnchor048"/>se and it builds the base for our next chapter: the more advanced Linux <span class="No-Break">administration topics.</span></p>
<h1 id="_idParaDest-46">Exercises</h1>
<ul>
<li>Find out how to apply <strong class="source-inline">chown</strong> recursively—it means that our <strong class="source-inline">chown</strong> call should step inside a directory and apply the change to all the <span class="No-Break">items within.</span></li>
<li>Find out what the <strong class="source-inline">watch</strong> command does. Use it with a <span class="No-Break"><strong class="source-inline">ps</strong></span><span class="No-Break"> command.</span></li>
<li>Find out how to remove <span class="No-Break">a directory.</span></li>
<li>For all the commands you have learned here, <a id="_idTextAnchor049"/>read their <strong class="source-inline">–help</strong> output. Open a <strong class="source-inline">man</strong> page and look through it, especially the <span class="No-Break">examples section.</span></li>
</ul>
<h1 id="_idParaDest-47">Resources</h1>
<ul>
<li>You can read more about SELinux <span class="No-Break">here: </span><a href="https://www.packtpub.com/product/selinux-system-administration-second-edition/9781787126954"><span class="No-Break">https://www.packtpub.com/product/selinux-system-administration-second-edition/9781787126954</span></a></li>
<li>This is a very good publication on Linux systems <span class="No-Break">administration: </span><a href="https://www.packtpub.com/product/mastering-linux-administration/9781789954272"><span class="No-Break">https://www.packtpub.com/product/mastering-linux-administration/9781789954272</span></a></li>
</ul>
</div>
</div></body></html>