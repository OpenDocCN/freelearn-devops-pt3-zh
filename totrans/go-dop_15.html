<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer059">
			<h1 id="_idParaDest-274"><a id="_idTextAnchor598"/>Chapter <a id="_idTextAnchor599"/><a id="_idTextAnchor600"/>12: Creating Immutable Infrastructure Using Packer</h1>
			<p>Managing compute infrastructure, even in the era of the cloud, is still a challenge. With the innovations in containerization, <strong class="bold">virtual machines</strong> (<strong class="bold">VMs</strong>), and serverless computing, developers might believe that compute infrastructure is a solved problem.</p>
			<p>Nothing could be farther from the truth. For cloud providers or others running their own data centers, bare metal machines (the machine's OS not running in virtualization) must be managed. This has become more complicated in the era of cloud computing. Not only does your provider need to manage their OS rollouts and patches, but so do cloud customers who want to run fleets of VMs and containers. Container orchestration systems such as Kubernetes must still provide container images that contain an OS image.</p>
			<p>In the cloud, just like a physical data center, it is important to force OS compliance for all containers and VMs. Allowing anyone to run whatever OS they want is the gateway to a security breach. To provide a secure platform for developers, you must provide a minimal OS standardized across all deployments.</p>
			<p>Standardization of an OS across a fleet comes with nothing but upsides and very few downsides. Standardizing on an OS image is easiest when your company is small. Large companies, including cloud providers that have not done this in the early days, have suffered through massive projects to standardize OS images at later stages.</p>
			<p>In this section, we are going to talk about how we can use Packer, a software package written in Go by HashiCorp, to manage the creation and patching of VM and container images. HashiCorp is the leader in the trend of <strong class="bold">Infrastructure as Code</strong> (<strong class="bold">IaC</strong>) that is moving through the industry.</p>
			<p>Packer lets us use YAML and Go to provide a consistent way to build images across a multitude of platforms. Be it in VM images, Docker images, or bare metal images, Packer can create consistent environments for your workloads to run on.</p>
			<p>As we write Packer configuration files and use the Packer binary, you will begin to see how Packer was written. Many of the interactions Packer defines were written using libraries such as <strong class="source-inline">os</strong>/<strong class="source-inline">exec</strong> that we have talked about earlier. Maybe you will be writing the next Packer that will sweep through the DevOps community!     </p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>Building an Amazon Machine Image</li>
				<li>Validating images with Goss</li>
				<li>Customizing Packer with plugins</li>
			</ul>
			<h1 id="_idParaDest-275"><a id="_idTextAnchor601"/><a id="_idTextAnchor602"/>Technical requirements</h1>
			<p>The prerequisites for this chapter are as follows:</p>
			<ul>
				<li>An AWS account</li>
				<li>An AWS Linux VM running on the AMD64 platform</li>
				<li>An AWS user account with administrator access and access to its secret</li>
				<li>Installation of Packer on the AWS Linux VM</li>
				<li>Installation of Goss on the AWS Linux VM</li>
				<li>Access to the book's GitHub repository</li>
			</ul>
			<p>To do the exercises in this chapter requires an AWS account. This will use compute time and storage on AWS, which will cost money, though you may be able to use an AWS Free Tier account (<a href="https://aws.amazon.com/free/">https://aws.amazon.com/free/</a>). None of the authors at the time of writing are currently affiliated with Amazon. There is no financial incentive for us. If anything, it costs us money to develop this chapter on AWS.</p>
			<p>When running Packer, we recommend running on Linux, both for cloud images and Docker images. Windows is a special niche for cloud computing and Microsoft provides its own sets of tools for handling Windows images. We don't recommend using a Mac for running these, as the move to Apple silicon and the interaction with multiple tools with varying support can lead to a long debug time. While macOS is POSIX-compliant, it still isn't Linux, the main target of these tools.</p>
			<p>Getting an AWS account set up with a Linux VM and setting up user accounts is beyond what we can cover in the book. See the AWS documentation for help with that. For this exercise, please choose either an Amazon Linux or Ubuntu distribution. </p>
			<p>User setup is done using AWS IAM tools, and the user name can be whatever you choose. You will also need to obtain an access key and secret for this user. Do not store these in a repository or any place that is publicly accessible, as they are equivalent to username/password. The user will need to do the following:</p>
			<ul>
				<li>Belong to a group with <strong class="source-inline">AdministratorAccess</strong> permissions set. </li>
				<li>Attach the existing policy, <strong class="source-inline">AmazonSSMAutomationRole</strong>.</li>
			</ul>
			<p>We recommend a personal account for this exercise, as this access is quite extensive. You can also set up a specific set of permissions or use another method that isn't as permissible. Instructions on those methods can be found here: <a href="https://www.packer.io/docs/builders/amazon">https://www.packer.io/docs/builders/amazon</a>.</p>
			<p>Once you have logged into your VM, you need to install Packer. This is going to depend on what Linux version you have.</p>
			<p>The following is for Amazon Linux:</p>
			<p class="source-code"><a id="_idTextAnchor603"/>sudo yum install -y yum-utils</p>
			<p class="source-code">sudo yum-config-manager --add-repo https://rpm.releases.hashicorp.com/AmazonLinux/hashicorp.repo</p>
			<p class="source-code">sudo yum -y install packer</p>
			<p>The following is for Ubuntu:</p>
			<p class="source-code">curl -fsSL https://apt.releases.hashicorp.com/gpg | sudo apt-key add -</p>
			<p class="source-code">sudo apt-add-repository "deb [arch=amd64] https://apt.releases.hashicorp.com $(lsb_release -cs) main"</p>
			<p class="source-code">sudo apt-get update &amp;&amp; sudo apt-get install packer</p>
			<p>For other Linux versions, see the following:</p>
			<p><a href="https://learn.hashicorp.com/tutorials/packer/get-started-install-cli">https://learn.hashicorp.com/tutorials/packer/get-started-install-cli</a>.</p>
			<p>To test Packer is installed, run the following:</p>
			<p class="source-code">packer version</p>
			<p>This should output the version of Packer you have.</p>
			<p>Once Packer is installed, issue the following commands:</p>
			<p class="source-code">mkdir packer</p>
			<p class="source-code">cd packer</p>
			<p class="source-code">touch amazon.pkr.hcl</p>
			<p class="source-code">mkdir files</p>
			<p class="source-code">cd files</p>
			<p class="source-code">ssh-keygen -t rsa -N "" -C "agent.pem" -f agent</p>
			<p class="source-code">mv agent ~/.ssh/agent.pem</p>
			<p class="source-code">wget https://raw.githubusercontent.com/PacktPublishing/Go-for-DevOps/rev0/chapter/8/agent/bin/linux_amd64/agent</p>
			<p class="source-code">wget https://raw.githubusercontent.com/PacktPublishing/Go-for-DevOps/rev0/chapter/12/agent.service</p>
			<p class="source-code">cd ..</p>
			<p>These commands do the following:</p>
			<ul>
				<li>Set up a directory called <strong class="source-inline">packer</strong> in your user's home directory</li>
				<li>Create an <strong class="source-inline">amazon.pkr.hcl</strong> file to store our Packer configuration</li>
				<li>Create a <strong class="source-inline">packer/files</strong> directory</li>
				<li>Generate an SSH key pair for a user, <strong class="source-inline">agent</strong>, which we will add to the image</li>
				<li>Move the <strong class="source-inline">agent.pem</strong> private key into our <strong class="source-inline">.ssh</strong> directory</li>
				<li>Copy our system agent from the Git repository</li>
				<li>Copy a <strong class="source-inline">systemd</strong> service configuration for the system agent from the Git repository</li>
			</ul>
			<p>Now that we have the prerequisites out of the way, let's have a look at building custom <strong class="bold">Ubuntu</strong> images for AWS.</p>
			<p>The code files for this chapter can be downloaded from <a href="https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/12">https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/12</a></p>
			<h1 id="_idParaDest-276"><a id="_idTextAnchor604"/><a id="_idTextAnchor605"/>Building an Amazon Machine Image</h1>
			<p>Packer supports a wide variety<a id="_idIndexMarker1161"/> of plugins that are used by the program to target a specific image format. For our example, we are going to target the <strong class="bold">Amazon Machine Image</strong> (<strong class="bold">AMI</strong>) format.</p>
			<p>There are other build targets for Docker, Azure, Google Cloud, and others. You may find a list of other build targets here: <a href="https://www.packer.io/docs/builders/">https://www.packer.io/docs/builders/</a>.</p>
			<p>For images that are used in cloud environments, Packer plugins generally take an existing image that lives on the cloud provider and lets you repackage and upload the image to the service.</p>
			<p>And, if you need to build multiple images for multiple cloud providers, containers, Packer can do simultaneous builds.</p>
			<p>For Amazon, there are currently four methods for building an AMI:</p>
			<ul>
				<li>Amazon <strong class="bold">Elastic Block Store</strong> (<strong class="bold">EBS</strong>) launches a source AMI, provisions<a id="_idIndexMarker1162"/> it, and then repackages it.</li>
				<li>Amazon instance virtual server, which launches an instance VM, rebundles it, and then uploads it to S3 (an Amazon object storage service).</li>
			</ul>
			<p>The two other methods are for advanced use cases. As this is an introduction to Packer using AWS, we are going to avoid these. However, you can<a id="_idIndexMarker1163"/> read about all these methods here: <a href="https://www.packer.io/docs/builders/amazon">https://www.packer.io/docs/builders/amazon</a>.</p>
			<p>There are two configuration<a id="_idIndexMarker1164"/> file formats used<a id="_idIndexMarker1165"/> by Packer:</p>
			<ul>
				<li><strong class="bold">JavaScript Object Notation</strong> (<strong class="bold">JSON</strong>) </li>
				<li><strong class="bold">HashiCorp Configuration Language 2</strong> (<strong class="bold">HCL 2</strong>)</li>
			</ul>
			<p>As JSON is deprecated, we will be using <strong class="source-inline">HCL2</strong>. This format was created by HashiCorp and you can find their Go parser here: <a href="https://github.com/hashicorp/hcl2">https://github.com/hashicorp/hcl2</a>. The parser can be useful if you wish to write your own tools around Packer or want to support your own configurations in <strong class="source-inline">HCL2</strong>.</p>
			<p>Now, let's create a Packer configuration file that we can use to access the Amazon plugin. </p>
			<p>Open the file<a id="_idIndexMarker1166"/> called <strong class="source-inline">amazon.pkr.hcl</strong> in the <strong class="source-inline">packer/</strong> directory we created.</p>
			<p>Add the follo<a id="_idTextAnchor606"/>wing:</p>
			<p class="source-code">packer {</p>
			<p class="source-code">  required_plugins {</p>
			<p class="source-code">    amazon = {</p>
			<p class="source-code">      version = "&gt;= 0.0.1"</p>
			<p class="source-code">      source = "github.com/hashicorp/amazon"</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>This tells Packer the following:</p>
			<ul>
				<li>We require the <strong class="source-inline">amazon</strong> plugin.</li>
				<li>The version of the plugin we want, which is the latest plugin that must be newer than version <strong class="source-inline">0.0.1</strong>.</li>
				<li>The <strong class="source-inline">source</strong> location in which to retrieve the plugin.</li>
			</ul>
			<p>As we are using a cloud provider, we need to set up the AWS source informa<a id="_idTextAnchor607"/>tion.</p>
			<h2 id="_idParaDest-277"><a id="_idTextAnchor608"/>Setting up an AWS source</h2>
			<p>We are going<a id="_idIndexMarker1167"/> to use the <strong class="bold">Amazon EBS</strong> build method, as this is the easiest<a id="_idIndexMarker1168"/> method to deploy<a id="_idIndexMarker1169"/> on AWS. Add the following to t<a id="_idTextAnchor609"/>he file:</p>
			<p class="source-code">source "amazon-ebs" "ubuntu" {</p>
			<p class="source-code">  access_key = "your key"</p>
			<p class="source-code">  secret_key = "your secret"</p>
			<p class="source-code">  ami_name      = "ubuntu-amd64"</p>
			<p class="source-code">  instance_type = "t2.micro"</p>
			<p class="source-code">  region        = "us-east-2"</p>
			<p class="source-code">  source_ami_filter {</p>
			<p class="source-code">    filters = {</p>
			<p class="source-code">      name                = "ubuntu/images/*ubuntu-xenial-16.04-amd64-server-*"</p>
			<p class="source-code">      root-device-type    = "ebs"</p>
			<p class="source-code">      virtualization-type = "hvm"</p>
			<p class="source-code">    }</p>
			<p class="source-code">    most_recent = true</p>
			<p class="source-code">    owners      = ["099720109477"]</p>
			<p class="source-code">  }</p>
			<p class="source-code">  ssh_username = "ubuntu"</p>
			<p class="source-code">}</p>
			<p>There is some key information here, so we are going to take it one step at a time:</p>
			<p class="source-code">source "amazon-ebs" "ubuntu" {</p>
			<p>This sets up the source<a id="_idIndexMarker1170"/> for our base image. As we are using the <strong class="source-inline">amazon</strong> plugin, the source<a id="_idIndexMarker1171"/> will have fields related to that plugin. You can find a complete list of fields here: <a href="https://www.packer.io/docs/builders/amazon/ebs">https://www.packer.io/docs/builders/amazon/ebs</a>.</p>
			<p>This line names our source as having two parts, <strong class="source-inline">amazon-ebs</strong> and <strong class="source-inline">ubuntu</strong>. When we refer to this source in our <strong class="source-inline">build</strong> stanza, it will be referred to as <strong class="source-inline">source.amazon-ebs.ubuntu</strong>. </p>
			<p>Now, we have a few field values:</p>
			<ul>
				<li><strong class="source-inline">access_key</strong> is the IAM user key to use.</li>
				<li><strong class="source-inline">secret_key</strong> is the IAM user's secret to use.</li>
				<li><strong class="source-inline">ami_name</strong> is the name of the resulting AMI in the AWS console.</li>
				<li><strong class="source-inline">instance_type</strong> is the AWS instance type to use to build the AMI.</li>
				<li><strong class="source-inline">region</strong> is the AWS<a id="_idIndexMarker1172"/> region for the build<a id="_idIndexMarker1173"/> instance to spawn in.</li>
				<li><strong class="source-inline">source_ami_filter</strong> filters the AMI image to find the image to apply.</li>
				<li><strong class="source-inline">filters</strong> contain a way to filter our base AMI image.</li>
				<li><strong class="source-inline">name</strong> gives the name of the AMI image. This can be any matching name returned by this API: <a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImages.html">https://docs.aws.amazon.com/AWSEC2/latest/APIReference/API_DescribeImages.html</a>.</li>
				<li><strong class="source-inline">root-device-type</strong> specifies we are using <strong class="source-inline">ebs</strong> as our source.</li>
				<li><strong class="source-inline">virtualization-type</strong> indicates which of two AMI virtualization technologies to use, <strong class="source-inline">hvm</strong> or <strong class="source-inline">pv</strong>. Due to enhancements to <strong class="source-inline">hvm</strong>, is it now the choice to use.</li>
				<li><strong class="source-inline">most_recent</strong> indicates to use the most recent image found.</li>
				<li><strong class="source-inline">owners</strong> must list an ID of an owner of the base image AMI we are using. <strong class="source-inline">"099720109477"</strong> is a reference to Canonical, the maker of Ubuntu.</li>
				<li><strong class="source-inline">ssh_username</strong> is the user name to SSH into the image with. <strong class="source-inline">ubuntu</strong> is the default user.</li>
			</ul>
			<p>As alternates to the authentication method here, you can use IAM roles, shared credentials, or other methods. However, each of the others is too complicated for this book to cover. See the link in the <em class="italic">Technical requirements</em> section if you wish to use another method.</p>
			<p><strong class="source-inline">secret_key</strong> needs to be secured like any password. In production, you will want to use IAM roles to avoid using <strong class="source-inline">secret_key</strong> or fetch this from a secure password service (AWS Secrets Manager, Azure Key Vault, or GCP Secret Manager) and use the environmental variable method to allow Packer to use the key.</p>
			<p>Next, we need to define a <strong class="source-inline">build</strong> block to allow us to change the image from the base to one custom<a id="_idTextAnchor610"/>ized for us.</p>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor611"/>Defining a build block and adding some provisioners</h2>
			<p>Packer defines a <strong class="source-inline">build</strong> block that references <a id="_idIndexMarker1174"/>the source we defined in the previous<a id="_idIndexMarker1175"/> section and makes the changes we want to that image.</p>
			<p>To do this, Packer uses <strong class="source-inline">provisioner</strong> configurations inside <strong class="source-inline">build</strong>. Provisioners let you make changes to an image by using the shell, Ansible, Chef, Puppet, files, or other methods.</p>
			<p>A full list of provisioners<a id="_idIndexMarker1176"/> can be found here:</p>
			<p><a href="https://www.packer.io/docs/provisioners">https://www.packer.io/docs/provisioners</a>.</p>
			<p>For long-term maintenance of your running infrastructure, Chef or Puppet have been the choice for many installations. This allows you to update the fleet without having to wait for an instance to be rebooted with the latest image.</p>
			<p>By integrating it with Packer, you can make sure to apply the latest patches to your image during the build process.</p>
			<p>While this is certainly helpful, we cannot explore these during this chapter. Setting up Chef or Puppet is simply beyond what we can do here. But for long-term maintenance, it is worth exploring these provisioners.</p>
			<p>For our example, we are going to do the following:</p>
			<ul>
				<li>Install the Go 1.17.5 environment.</li>
				<li>Add a user, <strong class="source-inline">agent</strong>, to the system.</li>
				<li>Copy SSH keys to the system for that user.</li>
				<li>Add our system agent from a previous chapter.</li>
				<li>Set systemd to run the agent from the <strong class="source-inline">agent</strong> user.</li>
			</ul>
			<p>Let's start by using the <strong class="source-inline">shell</strong> provisioner to install Go's 1.17.5 version using <strong class="source-inline">wget</strong>.</p>
			<p>Let's add<a id="_idIndexMarker1177"/> the<a id="_idIndexMarker1178"/> following:</p>
			<p class="source-code">build {</p>
			<p class="source-code">  name    = "goBook"</p>
			<p class="source-code">  sources = [</p>
			<p class="source-code">    "source.amazon-ebs.ubuntu"</p>
			<p class="source-code">  ]</p>
			<p class="source-code">  provisioner "shell" {</p>
			<p class="source-code">    inline = [</p>
			<p class="source-code">      "cd ~",</p>
			<p class="source-code">      "mkdir tmp",</p>
			<p class="source-code">      "cd tmp",</p>
			<p class="source-code">      "wget https://golang.org/dl/go1.17.5.linux-amd64.tar.gz",</p>
			<p class="source-code">      "sudo tar -C /usr/local -xzf go1.17.5.linux-amd64.tar.gz",</p>
			<p class="source-code">      "echo 'export PATH=$PATH:/usr/local/go/bin' &gt;&gt; ~/.profile",</p>
			<p class="source-code">      ". ~/.profile",</p>
			<p class="source-code">      "go version",</p>
			<p class="source-code">      "cd ~/",</p>
			<p class="source-code">      "rm -rf tmp/*",</p>
			<p class="source-code">      "rmdir tmp",</p>
			<p class="source-code">    ]</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>Our <strong class="source-inline">build</strong> block contains the following:</p>
			<ul>
				<li><strong class="source-inline">name</strong>, which names this block.</li>
				<li><strong class="source-inline">sources</strong>, which is a list of source blocks to include. This includes the source we just defined.</li>
				<li><strong class="source-inline">provisioner "shell"</strong> says we are going to use the <strong class="source-inline">shell</strong> provisioner, which logs in via the shell to do work. You may have multiple provisioner blocks of this type or of other types.</li>
				<li><strong class="source-inline">inline</strong> sets up commands to be run, one after another, in a shell script. This set of shell commands downloads Go version 1.17.5, installs it, tests it, and removes the install files.</li>
			</ul>
			<p>It should be noted that<a id="_idIndexMarker1179"/> you could also use <strong class="source-inline">file provisioner</strong>, which we will show<a id="_idIndexMarker1180"/> later, to take a local copy of the file instead of retrieving it with <strong class="source-inline">wget</strong>. But, we wanted to show how you can also just use standard Linux tools to pull from a trusted repository.</p>
			<p>Next, we will add another provision <em class="italic">inside</em> the <strong class="source-inline">build</strong> that adds a user to the system:</p>
			<p class="source-code">// Setup user "agent" with SSH key file</p>
			<p class="source-code">provisioner "shell" {</p>
			<p class="source-code">  inline = [</p>
			<p class="source-code">    "sudo adduser --disabled-password --gecos '' agent",</p>
			<p class="source-code">  ]</p>
			<p class="source-code">}</p>
			<p class="source-code">provisioner "file" {</p>
			<p class="source-code">  source = "./files/agent.pub"</p>
			<p class="source-code">  destination = "/tmp/agent.pub"</p>
			<p class="source-code">}</p>
			<p class="source-code">provisioner "shell" {</p>
			<p class="source-code">  inline = [</p>
			<p class="source-code">    "sudo mkdir /home/agent/.ssh",</p>
			<p class="source-code">    "sudo mv /tmp/agent.pub /home/agent/.ssh/authorized_keys",</p>
			<p class="source-code">    "sudo chown agent:agent /home/agent/.ssh",</p>
			<p class="source-code">    "sudo chown agent:agent /home/agent/.ssh/authorized_keys",</p>
			<p class="source-code">    "sudo chmod 400 .ssh/authorized_keys",</p>
			<p class="source-code">  ]</p>
			<p class="source-code">}</p>
			<p>The preceding code<a id="_idIndexMarker1181"/> block is structured<a id="_idIndexMarker1182"/> as follows:</p>
			<ul>
				<li>The first <strong class="source-inline">shell</strong> block: Adds a user, <strong class="source-inline">agent</strong>, with a disabled password.</li>
				<li>The second <strong class="source-inline">file</strong> block: Copies a local file, <strong class="source-inline">./files/agent.pub</strong>, to <strong class="source-inline">/tmp</strong>, as we can't copy directly to a user other than <strong class="source-inline">ubuntu</strong> using <strong class="source-inline">file provisioner</strong>.</li>
				<li>The third shell block:<ul><li>Makes our new user's <strong class="source-inline">.ssh</strong> directory.</li><li>Moves the <strong class="source-inline">agent.pub</strong> file out of <strong class="source-inline">/tmp</strong> to <strong class="source-inline">.ssh/authorized_keys</strong>.</li><li>Modifies all directories and files to have the right owners and permissions.</li></ul></li>
			</ul>
			<p>Now, let's add provisioners that install our system agent and sets up <strong class="source-inline">systemd</strong> to manage it. The following section uses the shell provisioner to install <strong class="source-inline">dbus</strong>, which is used to communicate with <strong class="source-inline">systemd</strong>. We set an environmental variable that prevents some pesky Debian interactive questions when we install using <strong class="source-inline">apt-get</strong>:</p>
			<p class="source-code">// Setup agent binary running with systemd file.</p>
			<p class="source-code">provisioner "shell" { // This installs dbus-launch</p>
			<p class="source-code">     environment_vars = [</p>
			<p class="source-code">       "DEBIAN_FRONTEND=noninteractive",</p>
			<p class="source-code">     ]</p>
			<p class="source-code">     inline = [</p>
			<p class="source-code">       "sudo apt-get install -y dbus",</p>
			<p class="source-code">       "sudo apt-get install -y dbus-x11",</p>
			<p class="source-code">     ]</p>
			<p class="source-code">}</p>
			<p>This uses the file provisioner<a id="_idIndexMarker1183"/> to copy the agent we want to run<a id="_idIndexMarker1184"/> from our source files onto the image at the <strong class="source-inline">/tmp/agent</strong> location:</p>
			<p class="source-code">provisioner "file" {</p>
			<p class="source-code">  source = "./files/agent"</p>
			<p class="source-code">  destination = "/tmp/agent"</p>
			<p class="source-code">}</p>
			<p>The following section creates a directory in the user agent's home directory called <strong class="source-inline">bin</strong> and moves the agent we copied over in the previous section into it. The rest is some necessary permissions and ownership changes:</p>
			<p class="source-code">provisioner "shell" {</p>
			<p class="source-code">  inline = [</p>
			<p class="source-code">    "sudo mkdir /home/agent/bin",</p>
			<p class="source-code">    "sudo chown agent:agent /home/agent/bin",</p>
			<p class="source-code">    "sudo chmod ug+rwx /home/agent/bin",</p>
			<p class="source-code">    "sudo mv /tmp/agent /home/agent/bin/agent",</p>
			<p class="source-code">    "sudo chown agent:agent /home/agent/bin/agent",</p>
			<p class="source-code">    "sudo chmod 0770 /home/agent/bin/agent",</p>
			<p class="source-code">  ]</p>
			<p class="source-code">}</p>
			<p>This copies over the <strong class="source-inline">systemd</strong> file from our source directory to our image:</p>
			<p class="source-code">provisioner "file" {</p>
			<p class="source-code">  source = "./files/agent.service"</p>
			<p class="source-code">  destination = "/tmp/agent.service"</p>
			<p class="source-code">}</p>
			<p>This last section<a id="_idIndexMarker1185"/> moves the <strong class="source-inline">agent.service</strong> file to its final location, tells <strong class="source-inline">systemd</strong> to enable the service<a id="_idIndexMarker1186"/> described in <strong class="source-inline">agent.service</strong>, and validates that it is active. The <strong class="source-inline">sleep</strong> parameter is used to simply allow the daemon to start before it is checked:</p>
			<p class="source-code">provisioner "shell" {</p>
			<p class="source-code">  inline = [</p>
			<p class="source-code">    "sudo mv /tmp/agent.service /etc/systemd/system/agent.service",</p>
			<p class="source-code">    "sudo systemctl enable agent.service",</p>
			<p class="source-code">    "sudo systemctl daemon-reload",</p>
			<p class="source-code">    "sudo systemctl start agent.service",</p>
			<p class="source-code">    "sleep 10",</p>
			<p class="source-code">    "sudo systemctl is-enabled agent.service",</p>
			<p class="source-code">    "sudo systemctl is-active agent.service",</p>
			<p class="source-code">  ]</p>
			<p class="source-code">}</p>
			<p>Finally, let's add the Goss tool, which we will be using in the next section:</p>
			<p class="source-code">provisioner "shell" { </p>
			<p class="source-code">    inline = [ </p>
			<p class="source-code">        "cd ~", </p>
			<p class="source-code">        "sudo curl -L https://github.com/aelsabbahy/goss/ releases/latest/download/goss-linux-amd64 -o /usr/local/bin/ goss", </p>
			<p class="source-code">        "sudo chmod +rx /usr/local/bin/goss", </p>
			<p class="source-code">        "goss -v", </p>
			<p class="source-code">    ] </p>
			<p class="source-code">} </p>
			<p>This downloads<a id="_idIndexMarker1187"/> the latest Goss<a id="_idIndexMarker1188"/> tool, sets it to be executable, and tests that it works.</p>
			<p>Now, let's look at how we could execute a Packe<a id="_idTextAnchor612"/><a id="_idTextAnchor613"/>r build to create an image.</p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor614"/>Executing a Packer build</h2>
			<p>There are four stages<a id="_idIndexMarker1189"/> to doing a Packer<a id="_idIndexMarker1190"/> build:</p>
			<ul>
				<li>Initializing Packer to download the plugins</li>
				<li>Validating the build</li>
				<li>Formatting the Packer configuration file</li>
				<li>Building the image</li>
			</ul>
			<p>The first thing to do is initialize our plugins. To do this, simply type the following:</p>
			<p class="source-code">packer init .</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you see a message such as <strong class="source-inline">Error: Unsupported block type</strong>, it is likely you put the <strong class="source-inline">provisioner</strong> blocks outside the <strong class="source-inline">build</strong> block.</p>
			<p>Once the plugins are installed, we need to validate our build:</p>
			<p class="source-code">packer validate .</p>
			<p>This should yield <strong class="source-inline">The configuration is valid</strong>. If it doesn't, you will need to edit the file to fix the errors.</p>
			<p>At this time, let's format the Packer template files. This is a concept I'm sure HashiCorp borrowed from Go's <strong class="source-inline">go fmt</strong> command and works in the same way. Let's give it a try with the following:</p>
			<p class="source-code">packer fmt .</p>
			<p>Finally, it's time to do our build:</p>
			<p class="source-code">packer build .</p>
			<p>There will be quite a bit of output<a id="_idIndexMarker1191"/> here. But if everything <a id="_idIndexMarker1192"/>is successful, you will see something like the following:</p>
			<p class="source-code">Build 'goBook.amazon-ebs.ubuntu' finished after 5 minutes 11 seconds.</p>
			<p class="source-code">==&gt; Wait completed after 5 minutes 11 seconds</p>
			<p class="source-code">==&gt; Builds finished. The artifacts of successful builds are:</p>
			<p class="source-code">--&gt; goBook.amazon-ebs.ubuntu: AMIs were created:</p>
			<p class="source-code">us-east-2: ami-0f481c1107e74d987</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you see errors about permissions, this will be related to your user account setup. See the necessary permissions listed in the earlier part of the chapter.</p>
			<p>You now have an AMI image available on AWS. You can launch AWS VMs that use this image and they will be running our system agent. Feel free to launch a VM set to your new AMI and play with the agent. You can access the agent from your Linux device using <strong class="source-inline">ssh agent@[host]</strong>, where <strong class="source-inline">[host]</strong> is the IP or DNS entry of the host on AWS.</p>
			<p>Now that we can use Packer to package our images, let's look at<a id="_idTextAnchor615"/><a id="_idTextAnchor616"/> Goss for validating our image.</p>
			<h1 id="_idParaDest-280"><a id="_idTextAnchor617"/>Validating images with Goss</h1>
			<p>Goss is a tool for checking server configurations <a id="_idIndexMarker1193"/>using a spec file written in YAML. This way<a id="_idIndexMarker1194"/> you can test that the server is working as expected. This can be from testing access to the server over SSH using expected keys to validating that various processes are running.</p>
			<p>Not only can Goss test your server for compliance, but it can be integrated with Packer. That way, we can test that our server<a id="_idIndexMarker1195"/> is running as expected during the provisioning<a id="_idIndexMarker1196"/> step and before deployment.</p>
			<p>Let's have<a id="_idTextAnchor618"/><a id="_idTextAnchor619"/> a look at making a Goss spec file.</p>
			<h2 id="_idParaDest-281"><a id="_idTextAnchor620"/>Creating a spec file</h2>
			<p>A spec file is a set of instructions<a id="_idIndexMarker1197"/> that tells Goss what to test for.</p>
			<p>There are a couple of ways to make a spec file for Goss. The spec file is used by Goss to understand what it needs to test.</p>
			<p>While you could write it by hand, the most efficient way is to use one of two Goss commands:</p>
			<ul>
				<li><strong class="source-inline">goss add</strong></li>
				<li><strong class="source-inline">goss autoadd</strong></li>
			</ul>
			<p>The most efficient way to use Goss is to launch a machine with your custom AMI, log in using the <strong class="source-inline">ubuntu</strong> user, and use <strong class="source-inline">autoadd</strong> to generate the YAML file.</p>
			<p>Once logged onto your AMI instance, let's run the following:</p>
			<p class="source-code">goss -g process.yaml autoadd sshd</p>
			<p>This will generate a <strong class="source-inline">process.yaml</strong> file with the following content:</p>
			<p class="source-code">service:</p>
			<p class="source-code">  sshd:</p>
			<p class="source-code">    enabled: true</p>
			<p class="source-code">    running: true</p>
			<p class="source-code">user:</p>
			<p class="source-code">  sshd:</p>
			<p class="source-code">    exists: true</p>
			<p class="source-code">    uid: 110</p>
			<p class="source-code">    gid: 65534</p>
			<p class="source-code">    groups:</p>
			<p class="source-code">    - nogroup</p>
			<p class="source-code">    home: /var/run/sshd</p>
			<p class="source-code">    shell: /usr/sbin/nologin</p>
			<p class="source-code">process:</p>
			<p class="source-code">  sshd:</p>
			<p class="source-code">    running: true</p>
			<p>This states that we expect<a id="_idIndexMarker1198"/> the following:</p>
			<ul>
				<li>A system service called <strong class="source-inline">sshd</strong> should be enabled and running via systemd.</li>
				<li>The service should be running with user <strong class="source-inline">sshd</strong>:<ul><li>With user ID <strong class="source-inline">110</strong>.</li><li>With group ID <strong class="source-inline">65534</strong>.</li><li>Belonging to no other groups.</li><li>The user's home directory should be <strong class="source-inline">/var/run/sshd</strong>.</li><li>The user should have no login shell.</li></ul></li>
				<li>A process called <strong class="source-inline">sshd</strong> should be running.</li>
			</ul>
			<p>Let's add the agent service we deployed:</p>
			<p class="source-code">goss -g process.yaml autoadd agent</p>
			<p>This will add similar lines inside the YAML file.</p>
			<p>Now, let's validate the agent location:</p>
			<p class="source-code">goss -g files.yaml autoadd /home/agent/bin/agent</p>
			<p>This will add a section such as the following:</p>
			<p class="source-code">file:</p>
			<p class="source-code">  /home/agent/bin/agent:</p>
			<p class="source-code">    exists: true</p>
			<p class="source-code">    mode: "0700"</p>
			<p class="source-code">    size: 14429561</p>
			<p class="source-code">    owner: agent</p>
			<p class="source-code">    group: agent</p>
			<p class="source-code">    filetype: file</p>
			<p class="source-code">    contains: []</p>
			<p>This states the following:</p>
			<ul>
				<li>The <strong class="source-inline">/home/agent/bin/agent</strong> file must<a id="_idIndexMarker1199"/> exist.</li>
				<li>Must be in mode <strong class="source-inline">0700</strong>.</li>
				<li>Must have a size of <strong class="source-inline">14429561</strong> bytes.</li>
				<li>Must be owned by <strong class="source-inline">agent:agent</strong>.</li>
				<li>Is a file, versus a directory or <strong class="source-inline">symlink</strong>.</li>
			</ul>
			<p>Let's add another, but being more specific, using <strong class="source-inline">goss add</strong>:</p>
			<p class="source-code">goss -g files.yaml add file /home/agent/.ssh/authorized_keys </p>
			<p>Instead of making a guess at what an argument is as <strong class="source-inline">autoadd</strong> does, we had to specify it was a file. This renders us the same entry as <strong class="source-inline">autoadd</strong> would. For this file, let's validate the contents of the <strong class="source-inline">authorized_keys</strong> file. To do this, we will use a <strong class="source-inline">SHA256</strong> hash. First, we can get the hash by running the following:</p>
			<p class="source-code">sha256sum /home/agent/.ssh/authorized_keys</p>
			<p>This will return the hash of the file. In the <strong class="source-inline">file</strong> entry for <strong class="source-inline">authorized_keys</strong> in our YAML file, add the following:</p>
			<p class="source-code">sha256: theFileHashJustGenerated</p>
			<p>Unfortunately, Goss does not have a way to simply add entire directories of files or automatically add <strong class="source-inline">SHA256</strong> to the entry. An example of that might be to validate that all of Go's 1.17.5 files were present as expected on our image. </p>
			<p>You might be tempted to do something<a id="_idIndexMarker1200"/> like the following: </p>
			<p class="source-code">find /usr/local/go -print0 | xargs -0 -I{} goss -g golang.yaml add file {}</p>
			<p>However, this is quite slow because <strong class="source-inline">goss</strong> reads in the YAML file on each run. You might be tempted to try to use <strong class="source-inline">xargs -P 0</strong> to speed things up, but it will cause other problems.</p>
			<p>If you have a need to include lots of files and SHA256 hashes, you will need to write a custom script/program to handle this. Fortunately, we have Go, so it's easy to write something that can do this. And, because Goss is written in Go, we can reuse the data structures from the program. You can see an example of a tool to do this here: <a href="https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/12/goss/allfiles">https://github.com/PacktPublishing/Go-for-DevOps/tree/rev0/chapter/12/goss/allfiles</a>.</p>
			<p>You simply can run it against a directory structure (after compiling it) like so:</p>
			<p class="source-code">allfiles /usr/local/go &gt; goinstall_files.yaml</p>
			<p>This would output a <strong class="source-inline">goinstall_files.yaml</strong> file that provides a Goss configuration to check these files and their SHA256 hashes.</p>
			<p>Remember when we installed <strong class="source-inline">dbus</strong>? Let's validate that our <strong class="source-inline">dbus</strong> packages are installed:</p>
			<p class="source-code">goss -g dbus.yaml add package dbus</p>
			<p class="source-code">goss -g dbus.yaml add package dbus-x11</p>
			<p>This now makes sure that our <strong class="source-inline">dbus</strong> and <strong class="source-inline">dbus-x11</strong> packages are installed. The <strong class="source-inline">-g dbus.yaml</strong> file writes this to another file called <strong class="source-inline">dbus.yaml</strong> instead of the default <strong class="source-inline">goss.yaml</strong>.</p>
			<p>We now need to create our <strong class="source-inline">goss.yaml</strong> file that references the other files we created. We could have run <strong class="source-inline">goss</strong> without the <strong class="source-inline">-g</strong> option, but this keeps things a little more organized. Let's create our root file:</p>
			<p class="source-code">goss add goss process.yaml</p>
			<p class="source-code">goss add goss files.yaml</p>
			<p class="source-code">goss add goss dbus.yaml</p>
			<p>This creates a <strong class="source-inline">goss.yaml</strong> file that references all our other files.</p>
			<p>Let's use it to validate<a id="_idIndexMarker1201"/> everything:</p>
			<p class="source-code">goss validate</p>
			<p>This will output text similar to the following:</p>
			<p class="source-code">..........................</p>
			<p class="source-code">Total Duration: 0.031s</p>
			<p class="source-code">Count: 26, Failed: 0, Skipped: 0</p>
			<p>Note, yes<a id="_idTextAnchor621"/><a id="_idTextAnchor622"/>, it did run in less than a second!</p>
			<h2 id="_idParaDest-282"><a id="_idTextAnchor623"/>Adding a Packer provisioner</h2>
			<p>It's great that we can verify<a id="_idIndexMarker1202"/> what we already had, but what we really want is to validate every image build. To do this, we can use a custom Packer provisioner that Yale University developed.</p>
			<p>To do that, we need to get the YAML files off the image and onto our build machine.</p>
			<p>From the build machine, issue the following commands (replacing things in <strong class="source-inline">[]</strong>):</p>
			<p class="source-code">cd /home/[user]/packer/files</p>
			<p class="source-code">mkdir goss</p>
			<p class="source-code">cd goss</p>
			<p class="source-code">scp ubuntu@[ip of AMI machine]:/home/ubuntu/*.yaml ./</p>
			<p>You need to replace <strong class="source-inline">[user]</strong> with the username on the build machine and <strong class="source-inline">[ip of AMI machine]</strong> with the IP address or DNS entry for the AMI machine you launched. You may also need to supply a <strong class="source-inline">-i [location of pem file]</strong> after <strong class="source-inline">scp</strong>.</p>
			<p>As the Goss provisioner is not built in, we need to download the release from Yale's GitHub repository and install it:</p>
			<p class="source-code">mkdir ~/tmp</p>
			<p class="source-code">cd ~/tmp</p>
			<p class="source-code">wget https://github.com/YaleUniversity/packer-provisioner-goss/releases/download/v3.1.2/packer-provisioner-goss-v3.1.2-linux-amd64.tar.gz</p>
			<p class="source-code">sudo tar -xzf packer-provisioner-goss-v3.1.2-linux-amd64.tar.gz</p>
			<p class="source-code">cp sudo packer-provisioner-goss /usr/bin/packer-provisioner-goss</p>
			<p class="source-code">rm -rf ~/tmp</p>
			<p>With the provisioner installed, we can add<a id="_idIndexMarker1203"/> the configuration to the <strong class="source-inline">amazon.pkr.hcl</strong> file:</p>
			<p class="source-code">// Setup Goss for validating an image.</p>
			<p class="source-code">provisioner "file" {</p>
			<p class="source-code">  source = "./files/goss/*"</p>
			<p class="source-code">  destination = "/home/ubuntu/"</p>
			<p class="source-code">}</p>
			<p class="source-code">provisioner "goss" {</p>
			<p class="source-code">     retry_timeout = "30s"</p>
			<p class="source-code">     tests = [</p>
			<p class="source-code">      "files/goss/goss.yaml", </p>
			<p class="source-code">      "files/goss/files.yaml", </p>
			<p class="source-code">      "files/goss/dbus.yaml", </p>
			<p class="source-code">      "files/goss/process.yaml", </p>
			<p class="source-code">     ]</p>
			<p class="source-code">}</p>
			<p>You can find other <strong class="source-inline">provisioner</strong> settings for Goss at <a href="https://github.com/YaleUniversity/packer-provisioner-goss">https://github.com/YaleUniversity/packer-provisioner-goss</a>.</p>
			<p>Let's reformat our Packer file:</p>
			<p class="source-code">packer fmt .</p>
			<p>We cannot build the <strong class="source-inline">packer</strong> image yet, because it would have the same name as the image we already have uploaded<a id="_idIndexMarker1204"/> to AWS. We have two choices: remove the AMI image we built earlier from AWS or change the name held in our Packer file to the following:</p>
			<p class="source-code">ami_name      = "ubuntu-amd64"</p>
			<p>Either choice is fine.</p>
			<p>Now, let's build our AMI image:</p>
			<p class="source-code">packer build .</p>
			<p>When you run it this time, you should see something similar to the following in the output:</p>
			<p class="source-code">==&gt; goBook.amazon-ebs.ubuntu: Running goss tests...</p>
			<p class="source-code">==&gt; goBook.amazon-ebs.ubuntu: Running GOSS render command: cd /tmp/goss &amp;&amp;  /tmp/goss-0.3.9-linux-amd64    render &gt; /tmp/goss-spec.yaml</p>
			<p class="source-code">==&gt; goBook.amazon-ebs.ubuntu: Goss render ran successfully</p>
			<p class="source-code">==&gt; goBook.amazon-ebs.ubuntu: Running GOSS render debug command: cd /tmp/goss &amp;&amp;  /tmp/goss-0.3.9-linux-amd64    render -d &gt; /tmp/debug-goss-spec.yaml</p>
			<p class="source-code">==&gt; goBook.amazon-ebs.ubuntu: Goss render debug ran successfully</p>
			<p class="source-code">==&gt; goBook.amazon-ebs.ubuntu: Running GOSS validate command: cd /tmp/goss &amp;&amp;   /tmp/goss-0.3.9-linux-amd64    validate --retry-timeout 30s --sleep 1s</p>
			<p class="source-code">    goBook.amazon-ebs.ubuntu: ..........................</p>
			<p class="source-code">    goBook.amazon-ebs.ubuntu:</p>
			<p class="source-code">    goBook.amazon-ebs.ubuntu: Total Duration: 0.029s</p>
			<p class="source-code">    goBook.amazon-ebs.ubuntu: Count: 26, Failed: 0, Skipped: 0</p>
			<p class="source-code">==&gt; goBook.amazon-ebs.ubuntu: Goss validate ran successfully</p>
			<p>This indicates that the Goss tests<a id="_idIndexMarker1205"/> ran successfully. If Goss fails, a debug output will be downloaded to the local directory.</p>
			<p>You can find the final version of the Packer file here:</p>
			<p><a href="https://github.com/PacktPublishing/Go-for-DevOps/blob/rev0/chapter/12/packer/amazon.final.pkr.hcl">https://github.com/PacktPublishing/Go-for-DevOps/blob/rev0/chapter/12/packer/amazon.final.pkr.hcl</a>.</p>
			<p>You have now seen how to use the Goss tool to build validations for your images and integrate them into Packer. There are more features to explore and you can read about them here: <a href="https://github.com/aelsabbahy/goss">https://github.com/aelsabbahy/goss</a>.</p>
			<p>Now that we have used Goss a<a id="_idTextAnchor624"/><a id="_idTextAnchor625"/>s a provisioner, what about writing our own?</p>
			<h1 id="_idParaDest-283"><a id="_idTextAnchor626"/>Customizing Packer with plugins</h1>
			<p>The built-in provisioners<a id="_idIndexMarker1206"/> that we used are pretty powerful. By providing shell access<a id="_idIndexMarker1207"/> and file uploads, it is possible to do almost everything inside a Packer provisioner.</p>
			<p>For large builds, this can be quite tedious. And, if the case is something common, you might want to simply have your own Go application do the work for you.</p>
			<p>Packer allows for building plugins that can be used as the following:</p>
			<ul>
				<li>A Packer builder</li>
				<li>A Packer provisioner</li>
				<li>A Packer post-processor</li>
			</ul>
			<p>Builders are used when you need to interact with the system that will use your image: Docker, AWS, GCP, Azure, or others. As this isn't a common use outside cloud providers or companies such as VMware adding support, we will not cover this.</p>
			<p>Post-processors are normally used to push an image to upload the artifacts generated earlier. As this isn't common, we will not cover this.</p>
			<p>Provisioners are the most common, as they are part of the build process to output an image. </p>
			<p>Packer has two ways of writing these plugins:</p>
			<ul>
				<li>Single-plugins</li>
				<li>Multi-plugins</li>
			</ul>
			<p>Single plugins<a id="_idIndexMarker1208"/> are an older style<a id="_idIndexMarker1209"/> of writing plugins. The Goss provisioner<a id="_idIndexMarker1210"/> is written in the older style, which is why we installed it manually.</p>
			<p>With the newer style, <strong class="source-inline">packer init</strong> can be used to download the plugin. In addition, a plugin can register multiple builders, provisioners, or post-processors in a single plugin. This is the recommended way of writing a plugin.</p>
			<p>Unfortunately, the official documentation for multi-plugins and doing releases that support <strong class="source-inline">packer init</strong> is incomplete at the time of this writing. Following the directions will not yield a plugin that can be released using their suggested process.</p>
			<p>The instructions included here will fill in the gaps to allow building a multi-plugin that users can install using <strong class="source-inline">packer init</strong>.<a id="_idTextAnchor627"/><a id="_idTextAnchor628"/></p>
			<p>Let's get into how we can write a custom plugin.</p>
			<h2 id="_idParaDest-284"><a id="_idTextAnchor629"/>Writing your own plugin</h2>
			<p>Provisioners are powerful extensions<a id="_idIndexMarker1211"/> to the Packer application. They allow us to customize the application to do whatever we need.</p>
			<p>We have already seen how a provisioner can execute Goss to validate our builds. This allowed us to make sure future builds follow a specification for the image.</p>
			<p>To write a custom <strong class="source-inline">provisioner</strong>, we must implement the following interface:</p>
			<p class="source-code">type Provisioner interface { </p>
			<p class="source-code">    ConfigSpec() hcldec.ObjectSpec </p>
			<p class="source-code">    Prepare(...interface{}) error </p>
			<p class="source-code">    Provision(context.Context, Ui, Communicator, </p>
			<p class="source-code">        map[string] interface{}) error </p>
			<p class="source-code">}</p>
			<p>The preceding code is described as follows:</p>
			<ul>
				<li><strong class="source-inline">ConfigSpec()</strong> returns an object that represents your provisioner's HCL2 spec. This will be used by Packer to translate a user's config to a structured object in Go.</li>
				<li><strong class="source-inline">Prepare()</strong> prepares your plugin<a id="_idIndexMarker1212"/> to run and receives a slice of <strong class="source-inline">interface{}</strong> that represents the configuration. Generally, the configuration is passed as a single <strong class="source-inline">map[string]interface{}</strong>. <strong class="source-inline">Prepare()</strong> should do preparation operations such as pulling information from sources or validating the configuration, things that should cause a failure before even attempting to run. This should have no side effects, that is, it should not change any state by creating files, instantiating VMs, or any other changes to the system.</li>
				<li><strong class="source-inline">Provision()</strong> does the bulk of the work. It receives a <strong class="source-inline">Ui</strong> object that is used to communicate to the user and <strong class="source-inline">Communicator</strong> that is used to communicate with the running machine. There is a provided <strong class="source-inline">map</strong> that holds values set by the builder. However, relying on values there can tie you to a <strong class="source-inline">builder</strong> type. </li>
			</ul>
			<p>For our example provisioner, we are going to pack the Go environment and install it on the machine. While Linux distributions will often package the Go environment, they are often several releases behind. Earlier, we were able to do this by using <strong class="source-inline">file</strong> and <strong class="source-inline">shell</strong> (which can honestly do almost anything), but if you are an application provider and you want to make something repeatable for other Packer users across multipl<a id="_idTextAnchor630"/>e platforms, a custom provisioner is the way to go.</p>
			<h3>Adding our provisioner configuration</h3>
			<p>To allow the user to configure<a id="_idIndexMarker1213"/> our plugin, we need to define a configuration. Here is the config option we want to support: <strong class="source-inline">Version (string)[optional]</strong>, the specific version to download defaults to <strong class="source-inline">latest</strong>.</p>
			<p>We will define this in a subpackage: <strong class="source-inline">internal/config/config.go</strong>.</p>
			<p>In that file, we will add the following:</p>
			<p class="source-code">package config</p>
			<p class="source-code">//go:generate packer-sdc mapstructure-to-hcl2 -type Provisioner</p>
			<p class="source-code">// Provisioner is our provisioner configuration.</p>
			<p class="source-code">type Provisioner struct {</p>
			<p class="source-code">	Version string</p>
			<p class="source-code">}</p>
			<p class="source-code">// Default inputs default values.</p>
			<p class="source-code">func (p *Provisioner) Defaults() {</p>
			<p class="source-code">	if p.Version == "" {</p>
			<p class="source-code">		p.Version = "latest"</p>
			<p class="source-code">	}</p>
			<p class="source-code">}</p>
			<p>Unfortunately, we now need to be able to read<a id="_idIndexMarker1214"/> this from an <strong class="source-inline">hcldec.ObjectSpec</strong> file. This is complicated, so HashiCorp has created a code generator to do this for us. To use this, you must install their <strong class="source-inline">packer-sdc</strong> tool:</p>
			<p class="source-code">go install github.com/hashicorp/packer-plugin-sdk/cmd/packer-sdc@latest</p>
			<p>To generate the file, we can execute the following from inside <strong class="source-inline">internal/config</strong>:</p>
			<p class="source-code">go generate ./</p>
			<p>This will output a <strong class="source-inline">config.hcl2spec.go</strong> file that has the code we require. <a id="_idTextAnchor631"/>This uses the <strong class="source-inline">//go:generate</strong> line defined in the file.</p>
			<h3>Defining the plugin's configuration specification</h3>
			<p>At the root of our plugin<a id="_idIndexMarker1215"/> location, let's create a file called <strong class="source-inline">goenv.go</strong>.</p>
			<p>So, let's start by defining the configuration the user will input:</p>
			<p class="source-code">package main </p>
			<p class="source-code">import ( </p>
			<p class="source-code">    ... </p>
			<p class="source-code">    "[repo location]/packer/goenv/internal/config" </p>
			<p class="source-code">    "github.com/hashicorp/packer-plugin-sdk/packer" </p>
			<p class="source-code">    "github.com/hashicorp/packer-plugin-sdk/plugin" </p>
			<p class="source-code">    "github.com/hashicorp/packer-plugin-sdk/version" </p>
			<p class="source-code">    packerConfig "github.com/hashicorp/packer-plugin-sdk/ template/config" </p>
			<p class="source-code">    ... </p>
			<p class="source-code">)</p>
			<p>This imports<a id="_idIndexMarker1216"/> the following:</p>
			<ul>
				<li>The <strong class="source-inline">config</strong> package we just defined</li>
				<li>Three packages required to build our plugin:<ul><li><strong class="source-inline">packer</strong></li><li><strong class="source-inline">plugin</strong></li><li><strong class="source-inline">version</strong></li></ul></li>
				<li>A <strong class="source-inline">packerConfig</strong> package for dealing with HCL2 configs <p class="callout-heading">Note</p><p class="callout">The <strong class="source-inline">...</strong> is a stand-in for standard library packages and a few others for brevity. You can see them all in the repository version.</p></li>
			</ul>
			<p>Now, we need to define our provisioner:</p>
			<p class="source-code">// Provisioner implements packer.Provisioner. </p>
			<p class="source-code">type Provisioner struct{</p>
			<p class="source-code">     packer.Provisioner // Embed the interface.</p>
			<p class="source-code">     conf *config.Provisioner</p>
			<p class="source-code">     content []byte</p>
			<p class="source-code">     fileName string</p>
			<p class="source-code">}</p>
			<p>This is going to hold our configuration, some file<a id="_idIndexMarker1217"/> content, and the Go tarball filename. We will implement our <strong class="source-inline">Provisioner</strong> interface on <a id="_idTextAnchor632"/>this struct.</p>
			<p>Now, it's time to add the required methods.</p>
			<h3>Defining the ConfigSpec() function</h3>
			<p><strong class="source-inline">ConfigSpec()</strong> is defined for internal<a id="_idIndexMarker1218"/> use by Packer. We simply need to provide the spec so that Packer can read in the configuration.</p>
			<p>Let's use <strong class="source-inline">config.hcl2spec.go</strong> we generated a second ago to implement <strong class="source-inline">ConfigSpec()</strong>:</p>
			<p class="source-code">func (p *Provisioner) ConfigSpec() hcldec.ObjectSpec {</p>
			<p class="source-code">     return new(config.FlatProvisioner).HCL2Spec()</p>
			<p class="source-code">}</p>
			<p>This returns <strong class="source-inline">ObjectSpec</strong> that handles reading in our HCL2 config.</p>
			<p>Now that we have that <a id="_idTextAnchor633"/>out of the way, we need to prepare our plugin to be used.</p>
			<h3>Defining Prepare()</h3>
			<p>Remember that <strong class="source-inline">Prepare()</strong> simply needs<a id="_idIndexMarker1219"/> to interpret the intermediate representation of the HCL2 config and validate the entries. It should not change the state of anything. </p>
			<p>Here's what that would look like:</p>
			<p class="source-code">func (p *Provisioner) Prepare(raws ...interface{}) error { </p>
			<p class="source-code">    c := config.Provisioner{} </p>
			<p class="source-code">    if err := packerConfig.Decode(&amp;c, nil, raws...); err != nil {</p>
			<p class="source-code">            return err</p>
			<p class="source-code">    }</p>
			<p class="source-code">    c.Defaults()</p>
			<p class="source-code">    p.conf = &amp;c</p>
			<p class="source-code">    return nil</p>
			<p class="source-code">}</p>
			<p>This code does the following:</p>
			<ul>
				<li>Creates our empty config</li>
				<li>Decodes the raw config entries into our internal representation</li>
				<li>Puts defaults into our config if values weren't set</li>
				<li>Validates our config</li>
			</ul>
			<p>We could also use<a id="_idIndexMarker1220"/> this time to connect to services or any other preparation items that are needed. The main thing is not to change any state.</p>
			<p>With all th<a id="_idTextAnchor634"/>e preparation out of the way, it's time for the big finale.</p>
			<h3>Defining Provision()</h3>
			<p><strong class="source-inline">Provision()</strong> is where all the magic <a id="_idIndexMarker1221"/>happens. Let's divide this into some logical sections:</p>
			<ul>
				<li>Fetch our version</li>
				<li>Push a tarball to the image</li>
				<li>Unpack the tarball</li>
				<li>Test our Go tools installation</li>
			</ul>
			<p>The following code wraps other methods that execute the logical sections in the same order:</p>
			<p class="source-code">func (p *Provisioner) Provision(ctx context.Context, u packer. Ui, c packer.Communicator, m map[string]interface{}) error { </p>
			<p class="source-code">    u.Message("Begin Go environment install") </p>
			<p class="source-code">    if err := p.fetch(ctx, u, c); err != nil { </p>
			<p class="source-code">            u.Error(fmt.Sprintf("Error: %s", err))</p>
			<p class="source-code">            return err</p>
			<p class="source-code">    }</p>
			<p class="source-code">    if err := p.push(ctx, u, c); err != nil {</p>
			<p class="source-code">            u.Error(fmt.Sprintf("Error: %s", err))</p>
			<p class="source-code">            return err</p>
			<p class="source-code">    }</p>
			<p class="source-code">    if err := p.unpack(ctx, u, c); err != nil {</p>
			<p class="source-code">            u.Error(fmt.Sprintf("Error: %s", err))</p>
			<p class="source-code">            return err</p>
			<p class="source-code">    }</p>
			<p class="source-code">    if err := p.test(ctx, u, c); err != nil {</p>
			<p class="source-code">            u.Error(fmt.Sprintf("Error: %s", err))</p>
			<p class="source-code">            return err</p>
			<p class="source-code">    }</p>
			<p class="source-code">    u.Message("Go environment install finished")</p>
			<p class="source-code">    return nil</p>
			<p class="source-code">}</p>
			<p>This code calls<a id="_idIndexMarker1222"/> all our stages (which we will define momentarily) and outputs some messages to the UI. The <strong class="source-inline">Ui</strong> interface is defined as follows:</p>
			<p class="source-code">type Ui interface {</p>
			<p class="source-code">     Ask(string) (string, error)</p>
			<p class="source-code">     Say(string)</p>
			<p class="source-code">     Message(string)</p>
			<p class="source-code">     Error(string)</p>
			<p class="source-code">     Machine(string, ...string)</p>
			<p class="source-code">     getter.ProgressTracker</p>
			<p class="source-code">}</p>
			<p>Unfortunately, the UI is not well documented in the code<a id="_idIndexMarker1223"/> or in the documentation. Here is a breakdown:</p>
			<ul>
				<li>You can use <strong class="source-inline">Ask()</strong> to ask a question of the user and get a response. As a general rule, you should avoid this, as it removes automation. Better to make them put it in the configuration.</li>
				<li><strong class="source-inline">Say()</strong> and <strong class="source-inline">Message()</strong> both print a string to the screen.</li>
				<li><strong class="source-inline">Error()</strong> outputs an error message.</li>
				<li><strong class="source-inline">Machine()</strong> simply outputs a statement into the log generated on the machine using <strong class="source-inline">fmt.Printf()</strong> that is prepended by <strong class="source-inline">machine readable:</strong>.</li>
				<li><strong class="source-inline">getter.ProgressTracker()</strong> is used by <strong class="source-inline">Communicator</strong> to track download progress. You don't need to worry about it.</li>
			</ul>
			<p>Now that we have covered the UI, let's cover <strong class="source-inline">Communicator</strong>:</p>
			<p class="source-code">type Communicator interface {</p>
			<p class="source-code">  Start(context.Context, *RemoteCmd) error</p>
			<p class="source-code">  Upload(string, io.Reader, *os.FileInfo) error</p>
			<p class="source-code">  UploadDir(dst string, src string, exclude []string) error</p>
			<p class="source-code">  Download(string, io.Writer) error</p>
			<p class="source-code">  DownloadDir(src string, dst string, exclude []string) error</p>
			<p class="source-code">}</p>
			<p>Methods in the preceding code block are described as follows:</p>
			<ul>
				<li><strong class="source-inline">Start()</strong> runs a command on the image. You pass <strong class="source-inline">*RemoteCmd</strong>, which is similar to the <strong class="source-inline">Cmd</strong>  type we used from <strong class="source-inline">os/exec</strong> in previous chapters.</li>
				<li><strong class="source-inline">Upload()</strong> uploads a file to the machine image.</li>
				<li><strong class="source-inline">UploadDir()</strong> uploads a local directory recursively to the machine image.</li>
				<li><strong class="source-inline">Download()</strong> downloads a file from the machine image. This allows you to capture debugs logs, for example.</li>
				<li><strong class="source-inline">DownloadDir()</strong> downloads a directory recursively from the machine to a local destination. You can exclude files.</li>
			</ul>
			<p>You can see the full interface comments here: <a href="https://pkg.go.dev/github.com/hashicorp/packer-plugin-sdk/packer?utm_source=godoc#Communicator">https://pkg.go.dev/github.com/hashicorp/packer-plugin-sdk/packer?utm_source=godoc#Communicator</a>.</p>
			<p>Let's look at building our first helper, <strong class="source-inline">p.fetch()</strong>. The following code determines what URL to use to download the Go<a id="_idIndexMarker1224"/> tools. Our tool is targeted at Linux, but we support installing versions for multiple platforms. We use Go's runtime package to determine the architecture (386, ARM, or AMD 64) we are currently running on to determine which package to download. The users can specify a particular version or <strong class="source-inline">latest</strong>. In the case of <strong class="source-inline">latest</strong>, we query a URL provided by Google that returns the latest version of Go. We then use that to construct the URL for download:</p>
			<p class="source-code">func (p *Provisioner) fetch(ctx context.Context, u Ui, </p>
			<p class="source-code">c Communicator) error {</p>
			<p class="source-code">     const (</p>
			<p class="source-code">          goURL = `https://golang.org/dl/go%s.linux-%s.tar.gz`</p>
			<p class="source-code">          name  = `go%s.linux-%s.tar.gz`</p>
			<p class="source-code">    )</p>
			<p class="source-code">    platform := runtime.GOARCH</p>
			<p class="source-code">    if p.conf.Version == "latest" {</p>
			<p class="source-code">          u.Message("Determining latest Go version")</p>
			<p class="source-code">          resp, err := http.Get("https://golang.org/VERSION?m=text")</p>
			<p class="source-code">          if err != nil {</p>
			<p class="source-code">                  u.Error("http get problem: " + err.Error())</p>
			<p class="source-code">                  return fmt.Errorf("problem asking Google for latest Go version: %s", err)</p>
			<p class="source-code">          }</p>
			<p class="source-code">          ver, err := io.ReadAll(resp.Body)</p>
			<p class="source-code">          if err != nil {</p>
			<p class="source-code">                  u.Error("io read problem: " + err.Error())</p>
			<p class="source-code">                  return fmt.Errorf("problem reading latest Go version: %s", err)</p>
			<p class="source-code">          }</p>
			<p class="source-code">          p.conf.Version = strings.TrimPrefix(string(ver), "go")</p>
			<p class="source-code">          u.Message("Latest Go version: " + p.conf.Version)</p>
			<p class="source-code">    } else {</p>
			<p class="source-code">          u.Message("Go version to use is: " + p.conf.Version)</p>
			<p class="source-code">    }</p>
			<p>This code makes the HTTP request<a id="_idIndexMarker1225"/> for the Go tarball and then stores that in <strong class="source-inline">.content</strong>:</p>
			<p class="source-code">    url := fmt.Sprintf(goURL, p.conf.Version, platform)</p>
			<p class="source-code">    u.Message("Downloading Go version: " + url)</p>
			<p class="source-code">    resp, err := http.Get(url)</p>
			<p class="source-code">    if err != nil {</p>
			<p class="source-code">        return fmt.Errorf("problem reaching golang.org for version(%s): %s)", p.conf.Version, err)</p>
			<p class="source-code">    }</p>
			<p class="source-code">    defer resp.Body.Close()</p>
			<p class="source-code">    p.content, err = io.ReadAll(resp.Body)</p>
			<p class="source-code">    if err != nil {</p>
			<p class="source-code">        return fmt.Errorf("problem downloading file: %s", err)</p>
			<p class="source-code">    }</p>
			<p class="source-code">    p.fileName = fmt.Sprintf(name, p.conf.Version, platform)</p>
			<p class="source-code">    u.Message("Downloading complete")</p>
			<p class="source-code">    return nil</p>
			<p class="source-code">}</p>
			<p>Now that we have fetched<a id="_idIndexMarker1226"/> our Go <strong class="source-inline">tarball</strong> content, let's push it to the machine:</p>
			<p class="source-code">func (p *Provisioner) push(ctx context.Context, u Ui, </p>
			<p class="source-code">c Communicator) error {</p>
			<p class="source-code">     u.Message("Pushing Go tarball")</p>
			<p class="source-code">     fs := simple.New()</p>
			<p class="source-code">     fs.WriteFile("/tarball", p.content, 0700)</p>
			<p class="source-code">     fi, _ := fs.Stat("/tarball")</p>
			<p class="source-code">     err := c.Upload(</p>
			<p class="source-code">             "/tmp/"+p.fileName,</p>
			<p class="source-code">             bytes.NewReader(p.content),</p>
			<p class="source-code">             &amp;fi,</p>
			<p class="source-code">     )</p>
			<p class="source-code">     if err != nil {</p>
			<p class="source-code">             return err</p>
			<p class="source-code">     }</p>
			<p class="source-code">     u.Message("Go tarball delivered to: /tmp/" + p.fileName)</p>
			<p class="source-code">     return nil</p>
			<p class="source-code">}</p>
			<p>The preceding code uploads our content<a id="_idIndexMarker1227"/> to the image. <strong class="source-inline">Upload()</strong> requires that we provide <strong class="source-inline">*os.FileInfo</strong>, but we don't have one because our file does not exist on disk. So, we use a trick where we write the content to a file in an in-memory filesystem and then retrieve <strong class="source-inline">*os.FileInfo</strong>. This prevents us from writing unnecessary files to disk.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">One of the odd things about <strong class="source-inline">Communicator.Upload()</strong> is that it takes a pointer to an <strong class="source-inline">interface (*os.FileInfo)</strong>. This is almost always a mistake by an author. Don't do this in your code.</p>
			<p>The next thing needed is to unpack this on the image:</p>
			<p class="source-code">func (p *Provisioner) unpack(ctx context.Context, u Ui, </p>
			<p class="source-code">c Communicator) error {</p>
			<p class="source-code">     const cmd = `sudo tar -C /usr/local -xzf /tmp/%s`</p>
			<p class="source-code">     u.Message("Unpacking Go tarball to /usr/local")</p>
			<p class="source-code">     b := bytes.Buffer{}</p>
			<p class="source-code">     rc := &amp;packer.RemoteCmd{</p>
			<p class="source-code">          Command: fmt.Sprintf(cmd, p.fileName),</p>
			<p class="source-code">          Stdout: &amp;b,</p>
			<p class="source-code">          Stderr: &amp;b,</p>
			<p class="source-code">     }</p>
			<p class="source-code">     if err := c.Start(rc); err != nil {</p>
			<p class="source-code">          return fmt.Errorf("problem unpacking tarball(%s):\n%s", err, b.String())</p>
			<p class="source-code">     }</p>
			<p class="source-code">     u.Message("Unpacked Go tarball")</p>
			<p class="source-code">     return nil</p>
			<p class="source-code">}</p>
			<p>This code does the following:</p>
			<ul>
				<li>Defines a command <a id="_idIndexMarker1228"/>that unwraps our tarball and installs to <strong class="source-inline">/usr/local</strong></li>
				<li>Wraps that command in <strong class="source-inline">*packerRemoteCmd</strong> and captures <strong class="source-inline">STDOUT</strong> and <strong class="source-inline">STDERR</strong></li>
				<li>Runs the command with <strong class="source-inline">Communicator</strong>: If it fails, returns the error and <strong class="source-inline">STDOUT</strong>/<strong class="source-inline">STDERR</strong> for debug</li>
			</ul>
			<p>The last step for <strong class="source-inline">Provisioner</strong> is to test that it installed:</p>
			<p class="source-code">func (p *Provisioner) test(ctx context.Context, u Ui, </p>
			<p class="source-code">c Communicator) error {</p>
			<p class="source-code">     u.Message("Testing Go install")</p>
			<p class="source-code">     b := bytes.Buffer{}</p>
			<p class="source-code">     rc := &amp;packer.RemoteCmd{</p>
			<p class="source-code">          Command: `/usr/local/go/bin/go version`,</p>
			<p class="source-code">          Stdout: &amp;b,</p>
			<p class="source-code">          Stderr: &amp;b,</p>
			<p class="source-code">     }</p>
			<p class="source-code">     if err := c.Start(rc); err != nil {</p>
			<p class="source-code">          return fmt.Errorf("problem testing Go install(%s):\n%s", err, b.String())</p>
			<p class="source-code">     }</p>
			<p class="source-code">     u.Message("Go installed successfully")</p>
			<p class="source-code">     return nil</p>
			<p class="source-code">}</p>
			<p>This code<a id="_idIndexMarker1229"/> does the following:</p>
			<ul>
				<li>Runs <strong class="source-inline">/usr/local/go/bin/go version</strong> to get the output</li>
				<li>If it fails, returns the error and <strong class="source-inline">STDOUT</strong>/<strong class="source-inline">STDERR</strong> for debug</li>
			</ul>
			<p>Now, the final part of the plugin to write is <strong class="source-inline">main()</strong>:</p>
			<p class="source-code">const (</p>
			<p class="source-code">        ver     = "0.0.1"</p>
			<p class="source-code">        release = "dev"</p>
			<p class="source-code">)</p>
			<p class="source-code">var pv *version.PluginVersion</p>
			<p class="source-code">func init() {</p>
			<p class="source-code">     pv = version.InitializePluginVersion(ver, release)</p>
			<p class="source-code">}</p>
			<p class="source-code">func main() { </p>
			<p class="source-code">    set := plugin.NewSet() </p>
			<p class="source-code">    set.SetVersion(pv) </p>
			<p class="source-code">    set.RegisterProvisioner("goenv", &amp;Provisioner{}) </p>
			<p class="source-code">    err := set.Run() </p>
			<p class="source-code">    if err != nil { </p>
			<p class="source-code">        fmt.Fprintln(os.Stderr, err.Error()) </p>
			<p class="source-code">        os.Exit(1) </p>
			<p class="source-code">    } </p>
			<p class="source-code">} </p>
			<p>This code does the following:</p>
			<ul>
				<li>Defines <a id="_idIndexMarker1230"/>our release version as <strong class="source-inline">"0.0.1"</strong>.</li>
				<li>Defines the release as a <strong class="source-inline">"dev"</strong> version, but you can use anything here. The production version should use <strong class="source-inline">""</strong>.</li>
				<li>Initializes <strong class="source-inline">pv</strong>, which holds the plugin version information. This is done in <strong class="source-inline">init()</strong> simply because the package comments indicate it should be done this way instead of in <strong class="source-inline">main()</strong> to cause a panic at the earliest time if a problem exists.</li>
				<li>Makes a new Packer <strong class="source-inline">plugin.Set</strong>:<ul><li>Sets the version information. If not set, all GitHub releases will fail.</li><li>Registers our provisioner with the <strong class="source-inline">"goenv"</strong> plugin name:<ul><li>Can be used to register other provisioners</li><li>Can be used to register a builder, <strong class="source-inline">set.RegisterBuilder()</strong>, and a post processor, <strong class="source-inline">set.RegisterPostProcessor()</strong></li></ul></li></ul></li>
				<li>Runs <strong class="source-inline">Set</strong> we created and exits on any error.</li>
			</ul>
			<p>We can register with a regular name, which would get appended to the name of the plugin. If using <strong class="source-inline">plugin.DEFAULT_NAME</strong>, our provisioner<a id="_idIndexMarker1231"/> can be referred to simply by the plugin's name.</p>
			<p>So, if our plugin is named <strong class="source-inline">packer-plugin-goenv</strong>, our plugin can be referred to as <strong class="source-inline">goenv</strong>. If we use something other than <strong class="source-inline">plugin.DEFAULT_NAME</strong>, such as <strong class="source-inline">example</strong>, our plugin would be referred to as <strong class="source-inline">goenv-example</strong>.</p>
			<p>We now have a plugin, but to make it useful we must allow people to initialize it. Let's look at how we can release our plugins using GitHub.</p>
			<p class="callout-heading">Testing Plugins</p>
			<p class="callout">In this exercise, we don't go into testing<a id="_idIndexMarker1232"/> Packer plugins. As of the time of publishing, there is no documentation on testing. However, Packer's GoDoc page has public types that can mock various types in Packer to help test your plugin.</p>
			<p class="callout">This includes mocking the <strong class="source-inline">Provisioner</strong>, <strong class="source-inline">Ui</strong>, and <strong class="source-inline">Communicator</strong> types to allow you to test. You can find these<a id="_idTextAnchor635"/> here: <a href="https://pkg.go.dev/github.com/hashicorp/packer-plugin-sdk/packer">https://pkg.go.dev/github.com/hashicorp/packer-plugin-sdk/packer</a>.</p>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor636"/>Releasing a plugin</h2>
			<p>Packer has strict release<a id="_idIndexMarker1233"/> requirements for allowing the <strong class="source-inline">packer</strong> binary to find and use a plugin. To have the plugin downloadable, the following requirements must be met:</p>
			<ul>
				<li>Must be released on GitHub; no other source is allowed.</li>
				<li>Have a repository named <strong class="source-inline">packer-plugin-*</strong>, where <strong class="source-inline">*</strong> is the name of your plugin. </li>
				<li>Only use dashes not underscores.</li>
				<li>Must have a plugin release that includes certain assets we will describe.</li>
			</ul>
			<p>The official release document can be found here: <a href="https://www.packer.io/docs/plugins/creation#creating-a-github-release">https://www.packer.io/docs/plugins/creation#creating-a-github-release</a>.</p>
			<p>HashiCorp also has a 30-minute video showing how to publish release documents to Packer's website here: <a href="https://www.hashicorp.com/resources/publishing-packer-plugins-to-the-masses">https://www.hashicorp.com/resources/publishing-packer-plugins-to-the-masses</a>.</p>
			<p>The first step for generating<a id="_idIndexMarker1234"/> a release is to create a <strong class="bold">GNU Privacy Guard</strong> (<strong class="bold">GPG</strong>) key to sign releases. The GitHub<a id="_idIndexMarker1235"/> instructions can be found here (but see notes directly underneath first): <a href="https://docs.github.com/en/authentication/managing-commit-signature-verification/generating-a-new-gpg-key">https://docs.github.com/en/authentication/managing-commit-signature-verification/generating-a-new-gpg-key</a>.</p>
			<p>Before you follow that document, remember these things while following the instructions:</p>
			<ul>
				<li>Make sure you add the public key to your GitHub profile.</li>
				<li>Do not use <strong class="source-inline">$</strong> or any other symbol in your passphrase, as it will cause issues.</li>
			</ul>
			<p>Once that is completed, you need to add the private key to your reposit<a id="_idTextAnchor637"/>ory so that the GitHub actions we define will be able to sign the releases. You will need to go to your GitHub repository's <strong class="bold">Settings</strong> <strong class="source-inline">|</strong> <strong class="bold">Secrets</strong>. Click the provided <strong class="bold">New Repository Secret</strong> button.</p>
			<p>Choose the name <strong class="source-inline">GPG_PRIVATE_KEY</strong>. </p>
			<p>In the value section, you will need to paste in your GPG private key that you can export with:</p>
			<p class="source-code">gpg --armor --export-secret-keys [key ID or email]</p>
			<p><strong class="source-inline">[key ID or email]</strong> is the identity you gave for the key, typically your email address.</p>
			<p>Now, we need to add the passphrase for your GPG key. You can add this as a secret with the name <strong class="source-inline">GPG_PASSPHRASE</strong>. The value should be the passphrase for the GPG key.</p>
			<p>Once that is completed, you will need to download the GoReleaser scaffolding HashiCorp provides. You can do that with the following:</p>
			<p class="source-code">curl -L -o ".goreleaser.yml" \</p>
			<p class="source-code">https://raw.githubusercontent.com/hashicorp/packer-plugin-scaffolding/main/.goreleaser.yml</p>
			<p>Now, we need the GitHub Actions workflow provided by HashiCorp set up in your repository. This can be done with the following:</p>
			<p class="source-code">mkdir -p .github/workflows &amp;&amp;</p>
			<p class="source-code"> curl -L -o ".github/workflows/release.yml" \</p>
			<p class="source-code"> https://raw.githubusercontent.com/hashicorp/packer-plugin-scaffolding/main/.github/workflows/release.yml</p>
			<p>Finally, we need to download <strong class="source-inline">GNUmakefile</strong>, which is used by the scaffolding. Let's grab it:</p>
			<p class="source-code">curl -L -o "GNUmakefile" \</p>
			<p class="source-code">https://raw.githubusercontent.com/hashicorp/packer-plugin-scaffolding/main/GNUmakefile</p>
			<p>Our plugin only works<a id="_idIndexMarker1236"/> for Linux systems. The <strong class="source-inline">.goreleaser.yml</strong> file defines releases for multiple platforms. You can restrict this by modifying the <strong class="source-inline">builds</strong> section of <strong class="source-inline">.goreleaser.yml</strong> to be more restrictive. You can see an example of that here: <a href="https://github.com/johnsiilver/packer-plugin-goenv/blob/main/.goreleaser.yml">https://github.com/johnsiilver/packer-plugin-goenv/blob/main/.goreleaser.yml</a>.</p>
			<p>With your code buildable and these files included, you need to commit these files to your repository.</p>
			<p>The next step will be to create a release. This needs to be tagged with a semantic version, similar to what you set the <strong class="source-inline">ver</strong> variable to in your plugin's <strong class="source-inline">main</strong> file. The slight difference is that while it will be strictly numbers and dots in <strong class="source-inline">ver string</strong>, it is prepended with <strong class="source-inline">v</strong> when tagging on GitHub. So <strong class="source-inline">ver = "0.0.1</strong> will be a GitHub release with <strong class="source-inline">v0.0.1</strong>. The GitHub documentation on releases can be found here: <a href="https://docs.github.com/en/repositories/releasing-projects-on-github/managing-releases-in-a-repository">https://docs.github.com/en/repositories/releasing-projects-on-github/managing-releases-in-a-repository</a>.</p>
			<p>Once you have created a release, you can view the actions being run by viewing the <strong class="bold">Actions</strong> tab. Th<a id="_idTextAnchor638"/><a id="_idTextAnchor639"/>is will show the results and detail any problems encountered by the actions.</p>
			<h2 id="_idParaDest-286"><a id="_idTextAnchor640"/>Using our plugin in a build</h2>
			<p>To use our plugin<a id="_idIndexMarker1237"/> in the build, we need to modify the HCL2 configuration. First, we need to modify <strong class="source-inline">packer.required_plugins</strong> to require our plugin: </p>
			<p class="source-code">packer {</p>
			<p class="source-code">  required_plugins {</p>
			<p class="source-code">    amazon = {</p>
			<p class="source-code">      version = "&gt;= 0.0.1"</p>
			<p class="source-code">      source = "github.com/hashicorp/amazon"</p>
			<p class="source-code">    }</p>
			<p class="source-code">    installGo = {</p>
			<p class="source-code">      version = "&gt;= 0.0.1"</p>
			<p class="source-code">      source = "github.com/johnsiilver/goenv"</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>This does a few things:</p>
			<ul>
				<li>Creates a new variable, <strong class="source-inline">installGo</strong>, that gives access to all plugins defined in our multi-plugin. There is only one: <strong class="source-inline">goenv</strong>.</li>
				<li>Sets the version<a id="_idIndexMarker1238"/> to use to be greater or equal to version <strong class="source-inline">0.0.1</strong>.</li>
				<li>Gives the source of the plugin. You will notice that the path is missing <strong class="source-inline">packer-plugin-</strong>. As that is standard for every plugin, they remove the need to type it.<p class="callout-heading">Note</p><p class="callout">You will see that the source is different than our location for the code. This is because we wanted to have a copy of the code in our normal location, but Packer requires a plugin to have its own repository. The code is located at both locations. You may view this copy of the code at: <a href="https://github.com/johnsiilver/packer-plugin-goenv">https://github.com/johnsiilver/packer-plugin-goenv</a>.</p></li>
			</ul>
			<p>Now, we need to remove the <strong class="source-inline">shell</strong> section under <strong class="source-inline">build.provisioner</strong> that installs Go. Replace it with the following:</p>
			<p class="source-code">provisioner "goenv-goenv" {</p>
			<p class="source-code">  version = "1.17.5"</p>
			<p class="source-code">}</p>
			<p>Finally, you will need to update <a id="_idIndexMarker1239"/>the AMI name to something new to store this under.</p>
			<p>As an alternative, you may also download the modified HCL2 file here: <a href="https://github.com/PacktPublishing/Go-for-DevOps/blob/rev0/chapter/12/packer/amazon.goenv.pkr.hcl">https://github.com/PacktPublishing/Go-for-DevOps/blob/rev0/chapter/12/packer/amazon.goenv.pkr.hcl</a>.</p>
			<p>In the terminal, format the file and download our plugin with the following:</p>
			<p class="source-code">packer fmt .</p>
			<p class="source-code">packer init .</p>
			<p>This should cause our plugin to download with output text similar to this:</p>
			<p class="source-code">Installed plugin github.com/johnsiilver/goenv v0.0.1 in "/home/ec2-user/.config/packer/plugins/github.com/johnsiilver/goenv/packer-plugin-goenv_v0.0.1_x5.0_linux_amd64"</p>
			<p>We can finally build our image with the following:</p>
			<p class="source-code">packer build .</p>
			<p>If successful, you should see the following in the Packer output:</p>
			<p class="source-code">goBook.amazon-ebs.ubuntu: Begin Go environment install</p>
			<p class="source-code">goBook.amazon-ebs.ubuntu: Go version to use is: 1.17.5</p>
			<p class="source-code">goBook.amazon-ebs.ubuntu: Downloading Go version: https://golang.org/dl/go1.17.5.linux-amd64.tar.gz</p>
			<p class="source-code">goBook.amazon-ebs.ubuntu: Downloading complete</p>
			<p class="source-code">goBook.amazon-ebs.ubuntu: Pushing Go tarball</p>
			<p class="source-code">goBook.amazon-ebs.ubuntu: Go tarball delivered to: /tmp/go1.17.5.linux-amd64.tar.gz</p>
			<p class="source-code">goBook.amazon-ebs.ubuntu: Unpacking Go tarball to /usr/local</p>
			<p class="source-code">goBook.amazon-ebs.ubuntu: Unpacked Go tarball</p>
			<p class="source-code">goBook.amazon-ebs.ubuntu: Testing Go install</p>
			<p class="source-code">goBook.amazon-ebs.ubuntu: Go installed successfully</p>
			<p class="source-code">goBook.amazon-ebs.ubuntu: Go environment install finished</p>
			<p>This plugin<a id="_idTextAnchor641"/><a id="_idTextAnchor642"/><a id="_idIndexMarker1240"/> has been pre-tested. Let's have a look at what you can do if the plugin fails.</p>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor643"/>Debugging a Packer plugin</h2>
			<p>When <strong class="source-inline">packer build .</strong> fails, you may or may not receive<a id="_idIndexMarker1241"/> relevant information in the UI output. This will depend on whether the problem was a panic or an error. </p>
			<p>Panics return an <strong class="source-inline">Unexpected EOF</strong> message because the plugin crashed and the Packer application only knows that it didn't receive an RPC message on the Unix socket.</p>
			<p>We can get Packer to help us out by providing this option when we run:</p>
			<p class="source-code">packer build -debug</p>
			<p>This will output a <strong class="source-inline">crash.log</strong> file if the build crashes. It also uses <strong class="source-inline">press enter</strong> between each step before continuing and allows only a single <strong class="source-inline">packer</strong> build to run at a time.</p>
			<p>You may see other files show up, as some plugins (such as Goss) detect the <strong class="source-inline">debug</strong> option and output debug configuration files and logs.</p>
			<p>You may also want to turn on logging for any log messages you or other plugins write. This can be done by setting a few environmental variables:</p>
			<p class="source-code">PACKER_LOG=1 PACKER_LOG_PATH="./packerlog.txt" packer build .</p>
			<p>This takes care of most debugging needs. However, sometimes the debug information required is part of the system logs and not the plugin itself. In those cases, you may want to use the communicator's <strong class="source-inline">Download()</strong> or <strong class="source-inline">DownloadDir()</strong> methods to retrieve files when you detect an error.</p>
			<p>For more debugging<a id="_idIndexMarker1242"/> information, the official debugging documentation is here: <a href="https://www.packer.io/docs/debugging">https://www.packer.io/docs/debugging</a>.</p>
			<p>In this section, we have detailed the building of a Packer multi-plugin, shown how to set up the plugin in GitHub to be used with <strong class="source-inline">packer init</strong>, and updated our Packer configuration<a id="_idIndexMarker1243"/> to use the plugin. In addition, we have discussed the basics of debugging Packer plugins.</p>
			<h1 id="_idParaDest-288"><a id="_idTextAnchor644"/>Summary</h1>
			<p>This chapter has taught you the basics of using Packer to build a machine image, using Amazon AWS as the target. We have covered the most important plugins Packer offers to customize an AMI. We then built a custom image that installed multiple packages with the <strong class="source-inline">apt</strong> tool, downloaded and installed other tools, set up directories and users, and finally, set up a system agent to run with systemd.</p>
			<p>We have covered how to use the Goss tool to validate your images and how to integrate Goss into Packer using a plugin developed at Yale.</p>
			<p>Finally, we have shown you how to create your own plugins to extend the capabilities of Packer.</p>
			<p>Now, it is time to talk about IaC and how another of HashiCorp's tools has taken the DevOps world by storm. Let's talk about Terraform. </p>
		</div>
	</div></body></html>