- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Enhancing the Speed and Maintainability of CI/CD Pipelines
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升CI/CD管道的速度和可维护性
- en: In this chapter, we’re going to cover the different tools and methods you can
    leverage to enhance the speed and maintainability of your CI/CD pipelines. Our
    goal in this chapter is to cover three main methods for how to speed up your pipelines.
    We don’t plan on covering every method to speed up a CI pipeline in GitLab, but
    rather the most impactful methods on pipeline speed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍你可以利用的不同工具和方法，来提升CI/CD管道的速度和可维护性。本章的目标是介绍三种主要的方法来加速你的管道。我们不会涵盖GitLab中加速CI管道的所有方法，而是专注于对管道速度影响最大的几种方法。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论以下内容：
- en: Accelerating pipelines with directed acyclic graphs and parent-child architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用有向无环图（DAG）和父子架构加速管道
- en: Building code for multiple architectures
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为多种架构构建代码
- en: When and how to leverage caching or artifacts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时以及如何利用缓存或工件
- en: Reducing repeated configuration code with anchors and extensions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用锚点和扩展减少重复的配置代码
- en: Improving maintainability by combining multiple pipelines and leveraging parent-child
    pipelines
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过结合多个管道并利用父子管道提升可维护性
- en: Securing and accelerating jobs with purpose-built containers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用专用容器保障和加速任务
- en: Accelerating pipelines with directed acyclic graphs and parent-child architecture
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用有向无环图（DAG）和父子架构加速管道
- en: GitLab supports the usage of the **directed acyclic graph** (**DAG**) pattern
    for building CI pipelines. Under normal usage with GitLab, each stage represents
    a series of jobs that need to be completed. Each stage is comprised of multiple
    jobs that are executed in parallel. Once a stage completes, then the next stage
    begins, until the pipeline completes. This is the typical processing loop that
    GitLab utilizes to complete a CI pipeline.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab支持使用**有向无环图**（**DAG**）模式构建CI管道。在GitLab的正常使用中，每个阶段代表一系列需要完成的任务。每个阶段由多个并行执行的任务组成。当一个阶段完成后，下一个阶段开始，直到整个管道完成。这是GitLab用于完成CI管道的典型处理循环。
- en: However, it is possible to create an internal loop of CI jobs that are directed
    to execute in a specific order that does not loop. This pattern is called a **DAG**
    or directed acyclic graph. *Directed* refers to the ordering of operations, *acyclic*
    refers to the fact it only happens once, and *graph* indicates the ordering of
    steps.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，完全可以创建一个内部循环的CI任务，这些任务按特定顺序执行，但不会形成循环。这个模式叫做**DAG**，即有向无环图。*有向*指的是操作的顺序，*无环*指的是这个过程只会发生一次，*图*则表示步骤的顺序。
- en: When leveraged properly, the DAG pattern can dramatically decrease the time
    it takes a pipeline to complete. This occurs because you are creating processing
    loops inside of the CI pipeline and are explicitly defining the order of operations
    for CI jobs outside of stages. A good example of this is if one job’s execution
    is dependent on another job’s execution, you can leverage the `needs:` keyword
    to ensure they’re run one after another outside of a Stage ordering. This creates
    a simple DAG process.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正确使用，DAG模式可以显著减少管道完成所需的时间。这是因为你在CI管道中创建了处理循环，并且明确地定义了CI任务的执行顺序，而这些任务位于阶段之外。一个好的例子是，如果一个任务的执行依赖于另一个任务的执行，你可以使用`needs:`关键字来确保它们一个接一个地执行，而不受阶段顺序的影响。这样就创建了一个简单的DAG过程。
- en: How to create a DAG in GitLab CI
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何在GitLab CI中创建DAG
- en: 'The following is an example of a normal GitLab CI pipeline. The following is
    a YAML implementation of the example we described in the introduction:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个正常GitLab CI管道的示例。以下是我们在介绍中描述的示例的YAML实现：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In a traditional pipeline, as shown here, jobs defined in `stage: B` will only
    begin execution after all jobs in `stage: A` have finished. The following is an
    example of this same pipeline set up to leverage DAG:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '在传统管道中，如下所示，`stage: B`中定义的任务仅在所有`stage: A`中的任务完成后才会开始执行。以下是设置为使用DAG的相同管道示例：'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'By adding the `needs` keyword to `Job3`, we have created a relationship between
    `Job1` and `Job3`. So, as soon as `Job1` is completed, `Job3` will begin execution.
    This occurs outside of regular stage ordering. In the event `needs` is not defined,
    stage ordering will be respected. As we can see with `Job4`, for `Job4` to begin
    execution, `stage: A` has to complete properly. However, if `needs: []` is defined
    but blank, then GitLab will execute that job the moment a pipeline starts and
    not assign it to any stage for execution.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '通过将 `needs` 关键字添加到 `Job3`，我们在 `Job1` 和 `Job3` 之间建立了依赖关系。所以，一旦 `Job1` 完成，`Job3`
    将开始执行。这种依赖关系超出了常规的阶段顺序。如果未定义 `needs`，则会遵循阶段顺序。如我们在 `Job4` 中所见，要让 `Job4` 开始执行，`stage:
    A` 必须先完成。然而，如果定义了 `needs: []` 且为空，则 GitLab 会在管道开始时立即执行该作业，并且不会分配给任何阶段执行。'
- en: Building code for multiple architectures
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为多个架构构建代码
- en: GitLab CI enables you to build artifacts for multiple architectures at once.
    This can easily speed up software builds by two or three times since, with multiple
    architectures, you typically have to build the software multiple times for each
    architecture. Here, we’re going to use CI jobs and pipelines to execute a software
    build for multiple architectures at the same time.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab CI 使你能够一次为多个架构构建工件。这可以轻松地加速软件构建，速度提升可达两到三倍，因为在多个架构下，通常需要为每个架构多次构建软件。在这里，我们将使用
    CI 作业和管道同时执行多个架构的软件构建。
- en: 'When building software for multiple architectures, there are some special requirements.
    The first requirement is that you must have GitLab Runners installed and configured
    on a machine running each architecture. For this section, we’re going to use three
    platforms as an example: `x86_64`, `arch64`, and `powerpc`. In this case, the
    expectation would be that you have a machine for each of the three architectures,
    with a GitLab Runner installed on it. That GitLab Runner also needs to have a
    tag assigned to it for which architecture it is running on.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在为多个架构构建软件时，有一些特殊要求。第一个要求是，必须在每个架构运行的机器上安装并配置 GitLab Runners。对于这一部分，我们将以三个平台作为示例：`x86_64`、`arch64`
    和 `powerpc`。在这种情况下，预期是你需要为这三种架构中的每一种准备一台机器，并在其上安装 GitLab Runner。该 GitLab Runner
    还需要为它所运行的架构分配一个标签。
- en: The second requirement is that the toolchain you use to build your software
    must be able to support a multi-architecture build. For this demo, we’re going
    to use GCC and a multi-architecture Docker image. We’re also going to be using
    the `parallel:` and `matrix:` keywords for GitLab CI.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个要求是，你用来构建软件的工具链必须能够支持多架构构建。为了演示，我们将使用 GCC 和多架构的 Docker 镜像。我们还将使用 GitLab CI
    的 `parallel:` 和 `matrix:` 关键字。
- en: 'The `parallel:` keyword is designed to allow a CI job to run multiple times
    in parallel. So, for example, if you set `parallel: 5` in a CI job, that CI job
    will run 5 times inside of that pipeline, in parallel.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`parallel:` 关键字旨在允许 CI 作业并行运行多次。例如，如果你在 CI 作业中设置 `parallel: 5`，该 CI 作业将在管道中并行执行
    5 次。'
- en: 'The `matrix:` keyword is designed to work with the `parallel:` keyword to spin
    up multiple CI jobs at a time, with different variables assigned to them. The
    following is an example of what this looks like when used in a pipeline for multi-architecture
    builds:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`matrix:` 关键字旨在与 `parallel:` 关键字一起使用，在同一时间启动多个 CI 作业，并为每个作业分配不同的变量。以下是当在多架构构建的管道中使用时的示例：'
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding example is going to do three key operations:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例将执行三个关键操作：
- en: First, with the use of `parallel:` and `matrix:`, GitLab is going to spin up
    three separate jobs – one for each of the variable pairs I’ve defined with `ARCH`
    and `CROSS_TRIPLE`.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，通过使用 `parallel:` 和 `matrix:`，GitLab 将启动三个独立的作业 —— 每个作业对应我定义的 `ARCH` 和 `CROSS_TRIPLE`
    的变量对。
- en: Second, each of those jobs will have a tag assigned to them, reflecting whatever
    value is defined in `ARCH:`. This will cause that job to be assigned to the appropriate
    runner for that tag.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，每个作业将会分配一个标签，反映 `ARCH:` 中定义的值。这将导致该作业分配到与标签对应的适当 runner。
- en: Third, GitLab will expose the `CROSS_TRIPLE:` environment variable to the `multiarch/crossbuild`
    container. This environment variable is used by the container to properly configure
    the GCC toolchain so that it’s ready to build for that architecture.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三，GitLab 将把 `CROSS_TRIPLE:` 环境变量暴露给 `multiarch/crossbuild` 容器。这个环境变量用于容器正确配置
    GCC 工具链，使其为目标架构做好构建准备。
- en: When the container spins up, and the CI job executes, the `make helloworld`
    command will be run. This command will invoke the preconfigured GCC toolchain
    and cause it to begin building our application binaries. The resulting binaries
    will be built to support the specified architecture.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器启动并执行 CI 作业时，`make helloworld` 命令将被执行。该命令将调用预配置的 GCC 工具链，并使其开始构建我们的应用程序二进制文件。生成的二进制文件将被构建为支持指定架构的版本。
- en: By building multi-architecture binaries this way, we take the complexity out
    of a multi-architecture build. We make those multi-architecture builds repeatable
    and easily understandable. We also run those builds in parallel so that they’re
    not waiting on each other, and we can see the results built from each architecture
    quickly.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式构建多架构二进制文件，我们简化了多架构构建的复杂性。我们使得这些多架构构建变得可重复且易于理解。我们还将这些构建并行运行，这样它们就不会相互等待，我们可以快速看到每个架构构建的结果。
- en: Important note
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `parallel:` and `matrix:` keywords can be used in any circumstance where
    you need multiple CI jobs with the same configurations, but with different injected
    variables. The `matrix:` keyword can also accept an array as the environment variable
    value. The environment variable key, however, *cannot* be an array.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`parallel:` 和 `matrix:` 关键字可以在任何需要多个具有相同配置但变量不同的 CI 作业的情况下使用。`matrix:` 关键字还可以接受数组作为环境变量的值。然而，环境变量的键*不能*是数组。'
- en: When and how to leverage caching or artifacts
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时以及如何利用缓存或工件
- en: With GitLab, there is often confusion about the usage of caching or artifacts.
    Many users are curious as to which functionality to leverage and when. We aim
    to demystify both in this chapter and give you the tools to implement either approach
    while explaining the benefits and pitfalls of each pattern.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 GitLab 时，关于缓存和工件的使用经常会引起困惑。许多用户都很想知道在什么时候使用哪种功能。本章的目标是为您澄清这两者的区别，并提供实现这两种方法的工具，同时解释每种模式的优缺点。
- en: Caching should be thought of as a method to save items that are commonly used
    in CI jobs or stages. It shouldn’t be thought of as a means to pass items between
    stages or jobs – that’s what artifacts are for. The difference is important because
    of the implementation and configuration of each. A cache is not built or designed
    to be a method to move items between CI jobs. Because of this, in the future,
    any features or changes that are made to it will be tailored toward that functionality.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存应该被视为一种保存 CI 作业或阶段中常用项目的方法。它不应被视为在阶段或作业之间传递项目的手段——这正是工件的作用。这个区别很重要，因为每种方式的实现和配置不同。缓存并不是为了作为一种在
    CI 作业之间移动项目的方法而构建或设计的。因此，未来对缓存的任何功能或更改都将围绕该功能进行调整。
- en: Artifacts are the main way to support storing items created by your CI job indefinitely,
    as well as passing them as a dependency to other CI jobs. With artifacts, you
    get insight into what was stored, and you can link CI jobs with hard dependencies
    on each other to ensure that the artifacts are shared. With caching, there is
    only a soft link. A job using a cache will still work if a cache doesn’t exist;
    however, a job with an artifact will not.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 工件是支持将 CI 作业创建的项目永久存储，并将其作为依赖项传递给其他 CI 作业的主要方式。使用工件时，您可以了解存储了哪些内容，并且可以将具有硬依赖关系的
    CI 作业关联起来，以确保工件得以共享。与缓存不同，缓存只有软链接。使用缓存的作业即使缓存不存在也能继续工作；然而，使用工件的作业则无法继续执行。
- en: The next consideration between caching and artifacts is how they’re stored,
    and the networking calls involved. Cache bundles are processed by the GitLab Runner,
    and the GitLab Runner’s configuration determines where it is stored. Under default
    configuration parameters, the cache is stored on the machine where the runner
    is operating. In terms of containers, the cache is destroyed. By adding an S3
    configuration to the GitLab Runner, the Runner will push all cache bundles to
    S3 storage. Any further CI jobs that use that cache will pull it from S3 storage
    before the CI job begins.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存和工件的下一个考虑因素是它们的存储方式以及涉及的网络调用。缓存包由 GitLab Runner 处理，GitLab Runner 的配置决定了缓存的存储位置。在默认配置参数下，缓存会存储在运行器所在的机器上。对于容器而言，缓存会被销毁。通过为
    GitLab Runner 添加 S3 配置，Runner 会将所有缓存包推送到 S3 存储。在 CI 作业开始之前，任何使用该缓存的 CI 作业都会从 S3
    存储中拉取缓存。
- en: In the case of artifacts, the Runner doesn’t play a role in its processing.
    Every artifact bundle is uploaded to the GitLab instance directly. GitLab’s configuration
    then determines when and where that artifact is stored. The most common configuration
    is also an S3 storage provider. Any future CI jobs that require this artifact
    also download it before the start of the CI job. Like cache bundles, the artifact
    bundle is then uncompressed into the working directory for usage.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于工件，Runner 在其处理过程中不发挥作用。每个工件包都会直接上传到 GitLab 实例。然后，GitLab 的配置决定该工件何时以及存储在何处。最常见的配置也是
    S3 存储提供商。任何需要此工件的未来 CI 作业都会在 CI 作业开始之前下载它。像缓存包一样，工件包会被解压到工作目录中以供使用。
- en: Important note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In this chapter, we will talk about two types of dependencies. The first is
    CI job dependencies, which should be handled with artifacts. CI job dependencies
    essentially link the result from one CI job to another. The second dependency
    type is toolchain dependencies, which are the dependencies of your application
    – usually, third-party libraries. These are used by multiple CI jobs or multiple
    CI pipelines, so they should leverage caching.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论两种类型的依赖关系。第一种是 CI 作业依赖关系，应通过工件进行处理。CI 作业依赖关系本质上将一个 CI 作业的结果链接到另一个作业。第二种依赖关系类型是工具链依赖关系，即应用程序的依赖项——通常是第三方库。这些依赖项由多个
    CI 作业或多个 CI 管道使用，因此应该利用缓存。
- en: Caching characteristics
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存特性
- en: 'These are the things that separate caching from artifacts:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是区分缓存与工件的特点：
- en: You can define a cache per job by using the `cache` keyword. Otherwise, it is
    disabled.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过使用`cache`关键字为每个作业定义缓存。否则，缓存将被禁用。
- en: Subsequent pipelines can use the cache.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后续管道可以使用缓存。
- en: Subsequent jobs in the same pipeline can use the cache if the dependencies are
    identical.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果依赖项相同，同一管道中的后续作业可以使用缓存。
- en: Different projects cannot share the cache.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的项目不能共享缓存。
- en: By default, protected and non-protected branches do not share the cache. However,
    you can change this behavior.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，受保护的分支和非受保护的分支不会共享缓存。但是，你可以更改此行为。
- en: Artifact characteristics
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工件特性
- en: 'These are the things that separate artifacts from caching:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是区分工件与缓存的特点：
- en: You can define artifacts per job.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以为每个作业定义工件。
- en: Subsequent jobs in later stages of the same pipeline can use artifacts.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一管道后续阶段的作业可以使用工件。
- en: Different projects cannot share artifacts.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的项目不能共享工件。
- en: Artifacts expire after 30 days by default. You can define a custom expiration
    time.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工件默认在 30 天后过期。你可以定义自定义的过期时间。
- en: The latest artifacts do not expire if **Keep latest artifacts** is enabled.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果启用了**保持最新工件**，则最新工件不会过期。
- en: You can use dependencies to control which jobs fetch the artifacts.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用依赖关系来控制哪些作业获取工件。
- en: Using caching
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用缓存
- en: 'The first step in leveraging the usage of caching is adding the configuration
    to your GitLab CI file. The following is a code sample of how this is done. If
    you look at this sample, you’ll see we’ve defined a CI job labeled `MyCIJob`.
    From there, we’ve defined a `cache` block and added a `path` parameter with a
    list of the directories and files we want to cache. This is the minimum viable
    code necessary to cache items as part of your CI job:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 利用缓存的第一步是将配置添加到你的 GitLab CI 文件中。以下是如何执行此操作的代码示例。如果你查看此示例，你会看到我们定义了一个名为`MyCIJob`的
    CI 作业。在此基础上，我们定义了一个`cache`块，并添加了一个`path`参数，列出了我们希望缓存的目录和文件。这是将项目缓存作为 CI 作业的一部分所需的最小有效代码：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, every time this CI job spins up, it will use the same cache bundle every
    single time. This is very useful when you have dependencies that are downloaded
    every time a CI job runs. By placing these dependencies inside a cache, they won’t
    need to be downloaded every time. Instead, GitLab will insert these dependencies
    at the beginning of the job. This cuts down time on CI jobs significantly, ultimately
    reducing the CI pipeline time to completion.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次此 CI 作业启动时，它都会使用相同的缓存包。这在你有每次 CI 作业运行时都会下载的依赖项时非常有用。通过将这些依赖项放入缓存中，它们就不需要每次都下载。相反，GitLab
    会在作业开始时插入这些依赖项。这大大缩短了 CI 作业的时间，最终减少了 CI 管道完成的时间。
- en: 'Now, we’re going to take this a step further. Let’s assume you have four separate
    CI jobs, and two of each of the CI jobs want to share a cache. In the previous
    example, we created a generic cache that could be used for all jobs. But in this
    example, we want to link a cache between two CI jobs. This can be done with the
    addition of the `key` value:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将进一步深入。假设你有四个独立的 CI 作业，其中每两个 CI 作业需要共享一个缓存。在前面的示例中，我们创建了一个通用的缓存，可以用于所有作业。但是在这个示例中，我们希望在两个
    CI 作业之间链接一个缓存。这可以通过添加 `key` 值来完成：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With the addition of the `key` value, GitLab will have an identifier with which
    to determine when and which cache bundle to download. This key value can obtain
    a string, a variable, or any combination of both. Many users will end up using
    a GitLab predefined variable as a key so that GitLab can manage the cache more
    effectively. For example, if you use the `$CI_PIPELINE_ID` variable, then that
    cache bundle will only be leveraged inside of a pipeline with an ID matching `$CI_PIPELINE_ID`.
    This means that every pipeline will have its own brand-new cache bundle.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加 `key` 值，GitLab 将拥有一个标识符，用来确定何时以及下载哪个缓存包。这个 `key` 值可以是一个字符串、一个变量或两者的任意组合。许多用户最终会使用
    GitLab 预定义的变量作为 key，这样 GitLab 就可以更有效地管理缓存。例如，如果你使用 `$CI_PIPELINE_ID` 变量，那么这个缓存包只会在
    ID 与 `$CI_PIPELINE_ID` 匹配的流水线中被使用。这意味着每个流水线都会有自己全新的缓存包。
- en: 'A final configuration you can leverage with caching is the ability to change
    when and how the cached bundle gets uploaded and downloaded:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以利用缓存的最终配置是改变缓存包的上传和下载的时机和方式：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, the cache GitLab CI object has a value called `policy`. By default,
    this is set to a value of `push-pull`, which means the cached bundle is pulled
    down when the job starts and pushed up when the job ends. However, you can also
    configure this to push or pull. By setting it to push, it will push the cache
    object but never pull it, while by setting it to pull, it will pull a cache but
    not push updates to the bundle.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，缓存的 GitLab CI 对象有一个名为 `policy` 的值。默认情况下，这个值设置为 `push-pull`，这意味着缓存的包会在作业开始时被拉取，在作业结束时被推送。然而，你也可以将其配置为仅推送或仅拉取。设置为推送时，它会推送缓存对象，但从不拉取；而设置为拉取时，它会拉取缓存，但不会推送更新到包中。
- en: Using artifacts
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用构件
- en: 'In the previous section, we discussed caching. Much of the same concepts of
    caching are going to apply to artifacts, but artifacts have a richer feature set.
    Because artifacts are used for things such as reporting, passing artifacts between
    jobs, and job dependency management, they require a deeper feature set. Let’s
    start with a basic artifact object and build a more intricate one from that:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一部分中，我们讨论了缓存。缓存的许多相同概念将应用于构件，但构件具有更丰富的功能集。由于构件用于报告、作业之间传递构件和作业依赖管理等，因此它们需要更深层次的功能集。让我们从一个基本的构件对象开始，并从中构建一个更复杂的构件：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: From the preceding example, you can see it’s very similar to caching at its
    core. We’ve added an artifact job, assigned an `artifacts:` object to it, added
    a `paths:` object to that, and listed the files we want to be artifacted. From
    here, when `MyArtifactJob` executes, at the end of the pipeline run, it will send
    everything listed in `paths:` to GitLab and store it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的示例中，你可以看到它的核心与缓存非常相似。我们添加了一个构件作业，分配了一个 `artifacts:` 对象给它，向其中添加了一个 `paths:`
    对象，并列出了我们希望进行构件化的文件。从这里开始，当 `MyArtifactJob` 执行时，流水线运行结束时，它将把 `paths:` 中列出的所有内容发送到
    GitLab 并进行存储。
- en: 'Similar to the cache’s `policy` option, which defines what to do with the cache,
    artifacts have a `when` object that allows you to specify what happens to the
    artifact when an artifact is created. Its options are `on_success`, `on_failure`,
    and `always`. The first option, `on_success`, will upload an artifact only on
    a job’s successful execution. The second, `on_failure`, will only upload when
    the job fails. Finally, `always` will always upload an artifact no matter the
    outcome. When applied to our job, the resulting job will look as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于缓存的 `policy` 选项，它定义了如何处理缓存，构件有一个 `when` 对象，允许你指定当构件创建时会发生什么。其选项为 `on_success`、`on_failure`
    和 `always`。第一个选项 `on_success` 只有在作业成功执行时才会上传构件。第二个选项 `on_failure` 只有在作业失败时才会上传构件。最后，`always`
    会在任何结果下始终上传构件。应用到我们的作业时，结果作业将如下所示：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In conclusion, the preceding job will only execute when other CI jobs are successful.
    It will then store the objects in the `theDirectoryToSave/` folder, in the `myFileToSave.js`
    file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，前面的任务只有在其他CI任务成功时才会执行。然后，它将把对象存储在`theDirectoryToSave/`文件夹中的`myFileToSave.js`文件里。
- en: Leveraging artifacts as job dependencies
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用产物作为任务依赖
- en: Now that we’ve covered the basics of artifacts, let’s use them in a real-world
    scenario by chaining jobs together with artifacts. By leveraging the `dependencies`
    keyword in a CI job block, we can pull artifacts from another job and make an
    intrinsic connection between two separate CI jobs.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了产物的基础知识，让我们通过在实际场景中将任务与产物链接在一起，来进一步应用它们。通过在CI任务块中使用`dependencies`关键字，我们可以从另一个任务中提取产物，并在两个独立的CI任务之间建立内在的联系。
- en: Our application will be built by the `MyBuildJob` job, which will be defined
    shortly. You may recognize much of the syntax from earlier chapters. This first
    job is an example of how to build a Node.js-based application. First, we leverage
    the `npm install` command to pull down any dependencies used to build this application.
    To keep this example simple, we’re not leveraging a cache for dependencies, but
    we should be in production.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序将由`MyBuildJob`任务构建，该任务将在稍后定义。你可能会从之前的章节中认出很多语法。这个第一个任务是一个构建基于Node.js的应用程序的示例。首先，我们使用`npm
    install`命令来拉取构建此应用所需的任何依赖项。为了保持这个示例的简洁，我们没有使用依赖项缓存，但在生产环境中应该使用缓存。
- en: Secondly, we’re running the `npm build` command to build the Node.js application.
    The common standard of all Node.js projects is that their built files are produced
    in a folder named `dist`. The Node.js dependencies are commonly stored in `node_modules`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，我们运行`npm build`命令来构建Node.js应用程序。所有Node.js项目的通用标准是，它们的构建文件都会生成在一个名为`dist`的文件夹中。Node.js的依赖项通常存储在`node_modules`文件夹中。
- en: 'Lastly, we have an artifact definition that lists both the folders of `node_modules`
    and `dist` as needing to be archived. Now, when this job is executed and completed,
    GitLab will store all of the items in the two folders listed:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有一个产物定义，列出了`node_modules`和`dist`文件夹作为需要归档的内容。现在，当这个任务执行并完成时，GitLab会存储这两个文件夹中所有的项目：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following CI job, defined as `MyDependentJob`, has been built to pull the
    artifacts from our previous job. Then, it leverages those artifacts in the build
    of a Dockerfile. The `dependencies` keyword is the glue that connects these two
    jobs:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以下CI任务，定义为`MyDependentJob`，被构建用来从我们之前的任务中提取构建产物。然后，它将这些产物用于Dockerfile的构建。`dependencies`关键字是连接这两个任务的桥梁：
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we can see, by using the `dependencies` keyword, we are instructing GitLab
    to make sure that `MyDependentJob` has everything it needs to run. Without this
    functionality, `MyDependentJob` would be required to pull down these artifacts
    itself, which will take additional time and configuration.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，通过使用`dependencies`关键字，我们指示GitLab确保`MyDependentJob`拥有执行所需的一切。如果没有这个功能，`MyDependentJob`将需要自己拉取这些产物，这将需要额外的时间和配置。
- en: Reducing repeated configuration code with anchors and extensions
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用锚点和扩展来减少重复的配置代码
- en: All GitLab CI pipeline files must be valid YAML. This also means they support
    various templates and repeatable code patterns that the YAML language supports.
    Writing multiple CI job definitions for each CI job in a pipeline can be time-consuming
    and lead to serious maintainability concerns. If you leverage the same variable
    in multiple places in a pipeline, it’s better to have it defined once, and then
    referenced multiple times. This way, when you need to change the variable, you
    do it in one place as opposed to many. Not only is this easier to do, but it’s
    also safer as with large pipelines, multiple variable replacements can lead to
    errors.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 所有GitLab CI管道文件必须是有效的YAML。这也意味着它们支持YAML语言支持的各种模板和可重复的代码模式。为每个CI任务编写多个CI任务定义可能会耗时，并且会导致严重的可维护性问题。如果你在管道中多个地方使用相同的变量，最好只定义一次，然后多次引用。这样，当你需要更改变量时，只需在一个地方进行更改，而不是在多个地方进行更改。这不仅更容易操作，而且更安全，因为在大型管道中，多次替换变量可能会导致错误。
- en: The three methods GitLab and YAML offer for creating reusable CI pipelines are
    `extends:`) keyword, and a `!reference`) tag. In the following sections, we’re
    going to explain the benefits and usage of each of these three methods. Each method
    comes with pros and cons in terms of functionality.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab和YAML提供的创建可重用CI管道的三种方法是`extends:`关键字和`!reference`标签。在接下来的章节中，我们将解释这三种方法的优点和使用方式。每种方法在功能上都有优缺点。
- en: Anchors
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 锚点
- en: The first method we’re going to review is **anchors**. YAML anchors allow you
    to duplicate or inherit properties of one CI job to another. With anchors, you
    can define an entire GitLab CI job or a few attributes and then repeat them.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要回顾的第一种方法是**锚点**。YAML锚点允许你将一个CI作业的属性复制或继承到另一个作业。使用锚点，你可以定义整个GitLab CI作业或几个属性，然后重复使用它们。
- en: 'Here, we’re going to utilize a basic YAML anchor. As you can see, `&job_definition`
    is the anchor we’re going to set. Then, we’re going to use it in `jobOne` and
    `jobTwo` to pull in the content from `&job_definition`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们将使用一个基本的YAML锚点。正如你所看到的，`&job_definition`是我们将要设置的锚点。然后，我们将在`jobOne`和`jobTwo`中使用它，以引入来自`&job_definition`的内容：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once GitLab has processed the CI file, the result will look something like
    this. Here, the contents of `&job_definition` has been merged into our two CI
    jobs:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦GitLab处理了CI文件，结果将类似于下面的样子。在这里，`&job_definition`的内容已合并到我们的两个CI作业中：
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding example, we defined a job with a dot (`.`) at the beginning
    of it. This dot means the CI job will not be executed as a CI job and merely exists
    as a reference. This was defined as `.job_definition:`. After this definition,
    we added a YAML anchor. This is the `&job_definition` statement that you can see.
    Everything after the `&` symbol defines the name of the anchor. Then, we define
    what a normal job should look like.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们定义了一个以点（`.`）开头的作业。这个点意味着该CI作业不会作为CI作业执行，而只是作为一个引用存在。这个作业定义为`.job_definition:`。在这个定义之后，我们添加了一个YAML锚点。这里是`&job_definition`语句，您可以看到它。所有在`&`符号之后的内容都定义了锚点的名称。接着，我们定义了一个正常的作业应该是什么样子。
- en: After, we define two CI jobs, each with different `script:` blocks. However,
    we use the `<<:` keyword to tell the YAML processor that we want to merge the
    `.job_definition:` attributes and keywords with this job. The `*` character followed
    by the name of the anchor references the anchor we defined with the `&` symbol.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们定义了两个CI作业，每个作业都有不同的`script:`块。然而，我们使用`<<:`关键字告诉YAML处理器，我们希望将`.job_definition:`的属性和关键字与此作业合并。`*`字符后跟锚点名称，引用了我们用`&`符号定义的锚点。
- en: The result is the two jobs inside of the merged result code block.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是合并后的代码块中包含了这两个作业。
- en: Important note
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: YAML anchors can only be used in the same GitLab CI file in which they were
    defined. This means that if you are leveraging the `includes:` keyword to break
    your CI files into multiple files, you must use `extends:` or `!reference` instead
    of YAML anchors.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: YAML锚点只能在定义它们的同一个GitLab CI文件中使用。这意味着，如果你正在利用`includes:`关键字将CI文件拆分成多个文件，你必须使用`extends:`或`!reference`，而不是YAML锚点。
- en: 'The extends: keyword'
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 'extends: 关键字'
- en: The second way of reusing CI jobs and configuration inside GitLab CI files is
    via the `extends:` keyword. The `extends:` keyword and YAML anchors are very similar
    in the way they operate. One major difference is that YAML anchors are mostly
    used for duplicating a single value or attribute across your CI pipeline file,
    whereas `extends:` is more often used to reuse entire configuration blocks inside
    your CI pipeline file. In the preceding anchor example, `extends:` is a better
    fit for usage.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitLab CI文件中复用CI作业和配置的第二种方式是通过`extends:`关键字。`extends:`关键字和YAML锚点在操作方式上非常相似。一个主要的区别是，YAML锚点通常用于在整个CI管道文件中复制单个值或属性，而`extends:`则更常用于复用整个配置块。在前面的锚点示例中，`extends:`更适合使用。
- en: 'In the following example, we’re defining a `.rules_definition` block. Then,
    we’re including it in the `.job_definition` block and using the `.job_definition`
    block in `jobOne` and `jobTwo`. Any job definitions that begin with a dot (`.`)
    are not processed by GitLab as an actual job. Instead, they are treated like templates:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，我们定义了一个`.rules_definition`块。然后，我们将其包含在`.job_definition`块中，并在`jobOne`和`jobTwo`中使用`.job_definition`块。任何以点（`.`）开头的作业定义不会被GitLab作为实际的作业处理。相反，它们被当作模板来处理：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After GitLab processes the preceding CI file, the final merged result will
    look as follows. Here, the contents of `.rule_definition` and `.job_definition`,
    which were defined once, are now included in both `jobOne` and `jobTwo`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitLab处理完前面的CI文件后，最终合并的结果如下所示。在这里，`.rule_definition`和`.job_definition`的内容（这两个内容只定义了一次）现在包含在`jobOne`和`jobTwo`中：
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, this example is slightly different than the one we used for
    anchors. That’s because another key difference between anchors and `extends:`
    is that `extends:` can inherit configuration from multiple CI job definitions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个示例与我们用锚点的示例略有不同。这是因为锚点和`extends:`之间的另一个主要区别是，`extends:`可以从多个CI作业定义中继承配置。
- en: Because of this, you can see the resulting merged job definitions have an added
    `rules:` attribute assigned to them. This is inherited through the `.job_definition`
    CI job, from the `.rules_definition` CI job.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以看到合并后的作业定义增加了一个`rules:`属性。这个属性是通过`.job_definition` CI作业继承自`.rules_definition`
    CI作业的。
- en: Reference tags
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用标签
- en: The third method of reusing configuration inside CI files is by using `!reference`
    tags. `!reference` tags are custom YAML tags that are used to select keyword configurations
    from other CI job sections and reuse them in the current section. They’re very
    similar in usage to YAML anchors, but you can use reference tags in multiple CI
    files. On the other hand, YAML anchors can only be used in the same file in which
    they were defined. Let’s look at an example.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 复用CI文件配置的第三种方法是使用`!reference`标签。`!reference`标签是自定义的YAML标签，用于从其他CI作业部分选择关键字配置，并在当前部分中重用它们。它们的使用方式与YAML锚点类似，但你可以在多个CI文件中使用引用标签。另一方面，YAML锚点只能在定义它们的同一个文件中使用。让我们来看一个例子。
- en: 'Create a `Build.gitlab-ci.yml` file that looks like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个看起来像这样的`Build.gitlab-ci.yml`文件：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a `.gitlab-ci.yml` file that looks like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个看起来像这样的`.gitlab-ci.yml`文件：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The result after GitLab processes these two files should look like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitLab处理这两个文件后，结果应该是这样的：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding example, a job definition was created in `Build.gitlab-ci.yml`.
    Then, we included that `Build` CI file in our main `.gitlab-ci.yml` file. After,
    we used the `!reference` keyword to pull the script block straight from the `.build-node`
    job definition. By leveraging `!reference` instead of `extends:`, we can only
    pull the configuration we want from that job definition, as opposed to the whole
    job definition. If we had used `extends:`, we would have brought over the `stage:`
    and `before_script:` attributes of that CI job definition as well.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们在`Build.gitlab-ci.yml`中创建了一个作业定义。然后，我们将这个`Build` CI文件包含到主`.gitlab-ci.yml`文件中。之后，我们使用`!reference`关键字直接从`.build-node`作业定义中提取脚本块。通过利用`!reference`而不是`extends:`，我们可以只从该作业定义中提取我们想要的配置，而不是整个作业定义。如果我们使用了`extends:`，我们还会将该CI作业定义的`stage:`和`before_script:`属性一并引入。
- en: Improving maintainability by combining multiple pipelines and leveraging parent-child
    pipelines
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过合并多个流水线和利用父子流水线来提高可维护性
- en: Most GitLab users simply utilize a single `.gitlab-ci.yml` file for their pipelines.
    This approach is perfectly acceptable, but in many cases, the amount of code inside
    this file can become very large and difficult to maintain. GitLab has introduced
    the ability to include multiple `gitlab-ci` files together as one. In this section,
    we’re going to cover how to break up a `.gitlab-ci.yml` file into multiple sections.
    Later, we’re going to cover how to take a second `.gitlab-ci.yml` file and execute
    a second child pipeline, and then discuss the reasons why you may want to do this.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数GitLab用户只使用一个`.gitlab-ci.yml`文件来配置他们的流水线。这种方法完全可以接受，但在许多情况下，这个文件中的代码量可能会变得非常庞大且难以维护。GitLab引入了将多个`gitlab-ci`文件作为一个文件包含在一起的功能。在本节中，我们将讨论如何将一个`.gitlab-ci.yml`文件拆分为多个部分。接下来，我们将讲解如何使用第二个`.gitlab-ci.yml`文件并执行一个子流水线，然后讨论为什么你可能会这样做的原因。
- en: Leveraging includes for maintainability
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用包含来提高可维护性
- en: 'Create a `.gitlab-ci.yml` file that looks like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个看起来像这样的`.gitlab-ci.yml`文件：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This preceding code shows an example of what a traditional `.gitlab-ci.yml`
    file looks like. For this example, we’ve included four jobs – two build jobs and
    two deploy jobs. In a normal `.gitlab-ci.yml` file, this would be tens of jobs
    with tons of logic between them, likely spanning hundreds of lines of code. This
    is a perfectly acceptable practice, but it is difficult to maintain and manage.
    As with all forms of source code, we want to ensure that the code we write is
    legible and understandable at a glance to ensure maintainability.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码展示了一个传统的`.gitlab-ci.yml`文件的示例。在这个示例中，我们包含了四个作业——两个构建作业和两个部署作业。在普通的`.gitlab-ci.yml`文件中，这可能会包含数十个作业，并且它们之间有大量的逻辑，代码行数可能会达到数百行。这是完全可以接受的做法，但它难以维护和管理。与所有源代码形式一样，我们希望确保我们编写的代码在第一眼就能被理解，以保证其可维护性。
- en: To break this code up, and make it more maintainable, we can leverage the `include:`
    keyword in the GitLab CI’s syntax. This keyword is used to tell GitLab’s YAML
    processor when to combine multiple YAML files into a single context. Let’s use
    this tool to break up our CI file into separate CI files for reusability.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了拆分这段代码并提高可维护性，我们可以利用 GitLab CI 语法中的 `include:` 关键字。该关键字用于告诉 GitLab 的 YAML
    处理器何时将多个 YAML 文件合并为一个单一的上下文。让我们使用这个工具将我们的 CI 文件拆分成多个独立的 CI 文件，以便于重用。
- en: 'Create a `Build.gitlab-ci.yml` file that looks like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `Build.gitlab-ci.yml` 文件，其内容如下：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a `Deploy.gitlab-ci.yml` file that looks like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `Deploy.gitlab-ci.yml` 文件，其内容如下：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a `.gitlab-ci.yml` file that looks like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `.gitlab-ci.yml` 文件，其内容如下：
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we split the individual jobs into files based on stages. Then, we included
    those files in our `.gitlab-ci.yml` file. When GitLab’s CI processor goes through
    our `.gitlab-ci.yml` file, it will merge each YAML file into a single context
    from top to bottom. This means that if I write the same job in `Build.gitlab-ci.yml`
    and `Deploy.gitlab-ci.yml` because `Deploy.gitlab-ci.yml` is included last, it
    will overwrite whatever was in the Build CI file. This is a simple example and
    method of separating your CI files for more maintainability. Next, we’re going
    to focus on combining an example from earlier with this method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将各个作业根据阶段拆分到不同的文件中。然后，我们将这些文件包含在 `.gitlab-ci.yml` 文件中。当 GitLab 的 CI 处理器遍历
    `.gitlab-ci.yml` 文件时，它会将每个 YAML 文件从上到下合并成一个单一的上下文。这意味着，如果我在 `Build.gitlab-ci.yml`
    和 `Deploy.gitlab-ci.yml` 中都写了相同的作业，因为 `Deploy.gitlab-ci.yml` 最后被包含，它将覆盖 `Build`
    CI 文件中的内容。这是一个简单的示例和方法，用于将 CI 文件拆分以提高可维护性。接下来，我们将结合之前的示例与这种方法进行讲解。
- en: Leveraging includes for reusability
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用包含以提高重用性
- en: Earlier, you learned how to use includes to help with maintainability. In this
    section, we will combine the usage of `include:` and the knowledge we learned
    earlier in this chapter around anchors and extensions to show you how to create
    reusable pipelines. We’ll start with an example.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，你已经学习了如何使用包含来帮助维护性。在本节中，我们将结合使用 `include:` 和本章中关于锚点和扩展的知识，向你展示如何创建可重用的流水线。我们将从一个示例开始。
- en: 'Create a `Templates.gitlab-ci.yml` file that looks like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `Templates.gitlab-ci.yml` 文件，其内容如下：
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding GitLab CI file, we’ve created a very simple CI job definition.
    Because this CI job’s name begins with a `.`, this job will not run on its own.
    We’ve included a `variables:` block and inserted an empty `NPM_CLI_OPTS` variable
    as a placeholder. Then, we used that variable in our `script:` block when we executed
    the `rebuild` command. The reason for this default variable is that we want to
    have a sane default when this job is used.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 GitLab CI 文件中，我们创建了一个非常简单的 CI 作业定义。由于该 CI 作业的名称以 `.` 开头，因此这个作业不会单独运行。我们包含了一个
    `variables:` 块，并插入了一个空的 `NPM_CLI_OPTS` 变量作为占位符。然后，我们在 `script:` 块中使用了这个变量，当我们执行
    `rebuild` 命令时。设置这个默认变量的原因是，我们希望在使用该作业时，能够有一个合理的默认值。
- en: We’ve named this CI file `Templates.gitlab-ci.yml` to indicate that it houses
    our CI job templates and not actual CI job definitions. However, we want to leverage
    this in a CI pipeline. The following example shows how to achieve this.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个 CI 文件命名为 `Templates.gitlab-ci.yml`，以表明它包含的是 CI 作业模板，而不是实际的 CI 作业定义。然而，我们希望在
    CI 流水线中利用它。以下示例展示了如何实现这一点。
- en: 'Create a `.gitlab-ci.yml` file that looks like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `.gitlab-ci.yml` 文件，其内容如下：
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we’re including all job definitions from the `Templates.gitlab-ci.yml`
    file, and we’re starting our own job based on those definitions. However, in the
    `variables:` block, we’re adding our own variables to control how the template
    CI job definition will run.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们包含了来自 `Templates.gitlab-ci.yml` 文件的所有作业定义，并基于这些定义启动了我们自己的作业。然而，在 `variables:`
    块中，我们添加了自己的变量来控制模板 CI 作业定义的执行方式。
- en: This method of templating a CI job and then using variables to expose configuration
    options for it is similar to how componentization occurs in traditional software
    development. It follows the same purpose, rules, and goals, even though the syntax
    is different.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这种将 CI 作业模板化，然后使用变量来暴露配置选项的方法，类似于传统软件开发中的组件化方式。尽管语法不同，但它遵循相同的目的、规则和目标。
- en: Includes from remote areas
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 来自远程区域的包含
- en: 'The `include:` keyword is not delegated to a single project or repository.
    You can include GitLab CI files from the open internet as well. Some examples
    of remote includes are listed here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`include:` 关键字并不局限于单个项目或仓库。你还可以从开放的互联网中包含 GitLab CI 文件。以下是一些远程包含的示例：'
- en: 'Including from a separate project and branch:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括来自不同项目和分支：
- en: '[PRE23]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Including from a remote location:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包括来自远程位置：
- en: '[PRE27]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Include from a template on the GitLab instance (`lib/gitlab/ci/templates`):'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 GitLab 实例的模板中包含（`lib/gitlab/ci/templates`）：
- en: '[PRE29]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Important note
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: You can include a CI file from anywhere the starter of a CI pipeline has access.
    Provided that the person who starts the CI pipeline has read access to the included
    file, the pipeline will succeed. However, if the person does not have access,
    the pipeline will fail.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 CI 流水线启动者有访问权限的任何地方包含 CI 文件。前提是启动 CI 流水线的人具有该文件的读取权限，流水线将会成功。如果启动者没有访问权限，流水线将会失败。
- en: Leveraging parent-child pipelines
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用父子流水线
- en: Now that we’ve spoken about including multiple YAML files and how you can templatize
    them for reusability, let’s talk about how we can leverage them with the `trigger:`
    keyword to create child pipelines.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了如何包含多个 YAML 文件，并且如何将它们模板化以便重用，接下来让我们谈谈如何使用`trigger:`关键字来创建子流水线。
- en: A **child pipeline** is a pipeline that is triggered by another pipeline. The
    triggering pipeline is referred to as the **parent pipeline**. Once a parent pipeline
    triggers a child pipeline, the parent’s pipeline execution waits for the new child
    pipeline to complete before it resumes. This is a powerful tool for building multiple
    pipelines to support a monorepo, or for breaking one large complex pipeline into
    smaller, more manageable pipelines.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**子流水线**是由另一个流水线触发的流水线。触发流水线的流水线称为**父流水线**。一旦父流水线触发子流水线，父流水线的执行将等待子流水线完成后才会继续。这是构建多个流水线来支持单体仓库，或将一个大型复杂流水线拆分为更小、更易管理流水线的强大工具。'
- en: 'To invoke a child pipeline, simply add the `trigger:` keyword as the parent
    to an `include:` statement. The following example will execute the `build.gitlab-ci.yml`
    file as a child pipeline:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要触发子流水线，只需将`trigger:`关键字添加到`include:`语句的父级。以下示例将会执行`build.gitlab-ci.yml`文件作为子流水线：
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: With the preceding example, in a CI pipeline view, you will see a CI job that
    states `My-Child-CI-Job`. This CI job will have another pipeline attached to it
    labeled `Downstream Pipeline`. In that view, you will be able to see all of the
    jobs from the child pipeline and their execution status.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，在 CI 流水线视图中，你会看到一个名为`My-Child-CI-Job`的 CI 作业。该 CI 作业将会附带另一个名为`Downstream
    Pipeline`的流水线。在这个视图中，你将能够看到来自子流水线的所有作业及其执行状态。
- en: Important note
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: An invoked child pipeline accepts all normal CI job attributes and keywords.
    Keywords such as `rules:` can determine when a child pipeline is invoked. The
    `environment:` keyword can also tie the invocation of a child pipeline to approval
    rules or environment tracking.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 被触发的子流水线接受所有正常的 CI 作业属性和关键字。像`rules:`这样的关键字可以决定何时触发子流水线。`environment:`关键字还可以将子流水线的触发与审批规则或环境跟踪关联起来。
- en: Securing and accelerating jobs with purpose-built containers
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用专用容器保障和加速作业
- en: GitLab, when set up properly, runs all the CI jobs of a pipeline in a container.
    This means that the entire build operation happens in a container. Because of
    this, container stewardship is exceptionally important. If a CI job happens in
    an insecure container, then that means the entire CI job and pipeline are insecure.
    If a CI job uses a non-performant container, that CI job and pipeline will take
    much longer to complete, resulting in a much slower time to show results. In every
    measurable way, the container used for your CI jobs is the most important part
    of your pipeline.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab 在正确配置的情况下，会在容器中运行流水线的所有 CI 作业。这意味着整个构建操作都发生在容器中。因此，容器的管理非常重要。如果 CI 作业发生在不安全的容器中，那么整个
    CI 作业和流水线都将不安全。如果 CI 作业使用性能不佳的容器，那么该作业和流水线将会花费更多时间才能完成，导致显示结果的时间大大延长。在所有可衡量的方面，CI
    作业使用的容器是流水线中最重要的部分。
- en: Important note
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: To quickly set or identify which container a specific CI job is using, look
    for the `image:` attribute in a CI job. This attribute will define the source
    of the container image, and the exact container image being used.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速设置或识别某个 CI 作业使用的容器，查找 CI 作业中的`image:`属性。该属性将定义容器镜像的来源，以及正在使用的具体容器镜像。
- en: A second area to look for this container image is at the top of the CI job log.
    There will be a message indicating which container image is being used.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 查找此容器镜像的第二个位置是在 CI 作业日志的顶部。那里会有一条消息，指示当前使用的容器镜像。
- en: We aim to resolve these concerns with a practice we call *purpose-built containers*.
    These are containers whose entire design is to be used in a CI pipeline. Here,
    we will outline some attributes of these containers and explain how to build them.
    When building containers for a CI pipeline, try to follow as much of this guidance
    as possible. Even if you’re not able to achieve every item mentioned here, following
    them as much as possible will result in a much more secure, performant, and maintainable
    container for your CI pipeline.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目标是通过一种称为*专用容器*的实践来解决这些问题。这些容器的整个设计都是用于在 CI 流水线中使用。在这里，我们将概述这些容器的一些特性，并解释如何构建它们。在为
    CI 流水线构建容器时，请尽可能遵循这些指导原则。即使您无法实现此处提到的每一项，尽可能遵循这些指导原则将使您的 CI 流水线容器更安全、更高效和更易于维护。
- en: The first item to consider is the file size of the container. A container for
    use in GitLab CI should contain only the minimum number of components necessary
    to run and perform its tasks. This container should also only perform one set
    of tasks. This means you would have a separate container for each toolchain –
    that is, one for Java and one for Node.js. You do not want to mix multiple toolchains
    because it will explode your container’s file size. There is rarely a scenario
    where you would need multiple toolchains in the same container as they are usually
    executed in separate CI jobs. A good rule to follow is that if a CI job does not
    need something, that something should not be included in the container.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑的第一个项目是容器的文件大小。用于 GitLab CI 的容器应仅包含运行和执行其任务所需的最少组件。此容器还应只执行一组任务。这意味着您会为每个工具链单独创建一个容器
    - 也就是说，一个用于 Java，一个用于 Node.js。您不希望混合多个工具链，因为这会增加容器的文件大小。很少有情况需要将多个工具链放在同一个容器中执行，因为它们通常在单独的
    CI 作业中执行。一个好的遵循规则是，如果 CI 作业不需要某些东西，那么容器中就不应该包含该东西。
- en: The second item to consider is ensuring your containers are multi-use. You still
    want to keep your toolchains in separate containers; however, you should avoid
    embedding configuration inside of a container that will prevent it from being
    used in multiple CI jobs or multiple pipelines. A good example of what to include
    would be encryption certificates so that the container can communicate with any
    resources it needs. An example of what not to include would be any configuration
    or settings that are related only to a single CI job or pipeline. The difference
    between these two items is that the first example (certificate) is used to enable
    the container to work properly, whereas the second example (configuration or setting)
    will restrict which CI jobs and pipelines the container can run in.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑的第二个项目是确保您的容器是多用途的。您仍然希望将工具链保持在单独的容器中；但是，您应避免将配置嵌入到只能用于多个 CI 作业或多个流水线的容器中。一个好的例子是包括加密证书，以便容器可以与其需要的任何资源通信。不应包括的示例是仅与单个
    CI 作业或流水线相关的任何配置或设置。这两个示例之间的区别在于，第一个示例（证书）用于使容器能够正常工作，而第二个示例（配置或设置）将限制容器可以运行的
    CI 作业和流水线。
- en: The third item to consider is preventing the container from being run under
    normal use. A purpose-built container for GitLab CI should effectively be a zombie
    or a shell. There should be no circumstance where the container executes anything
    other than what the CI job instructs it to. This can be performed by ensuring
    the container’s entry point is empty. If a Docker container executes anything
    as it starts in a GitLab CI, it can cause conflicts and will also take more time
    to start.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑的第三个项目是防止容器在正常使用时运行。专为 GitLab CI 构建的容器应有效地成为僵尸或外壳。容器执行除了 CI 作业指示其执行的任何内容之外的情况都不应该存在。这可以通过确保容器的入口点为空来实现。如果
    Docker 容器在 GitLab CI 中启动时执行任何操作，可能会导致冲突，并且启动时间也会更长。
- en: The fourth item to consider is to avoid adding needless layers inside of a Docker
    container. With every `RUN` or `ADD` command in a Dockerfile, Docker will create
    a new layer. Needless layers can balloon the size of the Docker container significantly
    and thus violate the first concern. When you run commands in a Dockerfile, you
    should use the `&` operator liberally to chain together run commands. We have
    provided an example of this usage in our Dockerfile example.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个需要考虑的事项是避免在Docker容器中添加不必要的层。每当Dockerfile中使用`RUN`或`ADD`命令时，Docker都会创建一个新层。不必要的层可能会显著增加Docker容器的大小，从而违反第一个考虑事项。当你在Dockerfile中运行命令时，应充分使用`&`操作符将多个命令链接在一起。我们在Dockerfile示例中提供了这种用法的例子。
- en: The final item to consider is privilege. A Docker container running in GitLab
    CI does not typically need elevated permissions to run and perform operations.
    On OpenShift and some Kubernetes platforms, any Docker container with elevated
    privileges may not be allowed to run and execute. Setting a random user ID when
    creating the container will help prevent these platforms from giving the container
    any form of privilege. If you need to provide permissions to a file or folder,
    they should be granted to a group as opposed to individual users.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个需要考虑的事项是权限。在GitLab CI中运行的Docker容器通常不需要提升的权限来运行和执行操作。在OpenShift和一些Kubernetes平台上，任何具有提升权限的Docker容器可能都不允许运行和执行。创建容器时设置随机用户ID有助于防止这些平台赋予容器任何形式的特权。如果需要为文件或文件夹提供权限，应将权限授予组，而不是单个用户。
- en: A purpose-built container example
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个定制容器示例
- en: 'Here, we have provided an example of a purpose-built container. This example
    follows all the considerations we listed previously. This is a Docker image that
    has been built upon the `alpine:3.12.0` base container. From there, we have a
    `RUN` command that combines multiple commands in one line. It makes use of the
    `&` operator to chain together multiple APK package manager commands. This reduces
    the number of layers in the Docker file. At the end of that command line, we assign
    a folder to the group of the running user. In doing so, we reserve the ability
    to manipulate that folder, but we prevent it from gaining any privilege from a
    bad group assignment:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们提供了一个定制容器的示例。该示例遵循了我们之前列出的所有考虑事项。这是一个基于`alpine:3.12.0`基础容器构建的Docker镜像。在此基础上，我们有一个`RUN`命令，该命令将多个命令合并为一行。它利用`&`操作符将多个APK包管理器命令连接在一起。这减少了Docker文件中的层数。在该命令行的末尾，我们将一个文件夹分配给运行用户的组。通过这样做，我们保留了操作该文件夹的能力，但防止它通过错误的组分配获得任何特权：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For the first consideration, you can see it is being met with `apk add –no-cache
    nodejs npm`. Node.js is the only toolchain that is installed in this container.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个考虑事项，你可以看到它通过`apk add –no-cache nodejs npm`来满足。Node.js是该容器中唯一安装的工具链。
- en: For the second consideration, you can see no configuration is embedded in the
    Dockerfile. This means the container will pull all of its configurations from
    the CI job’s configuration.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二个考虑事项，你可以看到Dockerfile中没有嵌入任何配置。这意味着容器将从CI作业的配置中获取所有配置。
- en: For the third consideration, you can look at the line starting with `CMD ["echo"`.
    This line prevents the container from running outside of a CI job. It presents
    an error message and kills the container.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第三个考虑事项，你可以查看以`CMD ["echo"`开头的那一行。该行防止容器在CI作业之外运行。它显示错误信息并终止容器。
- en: For the fourth consideration, look at the line starting with `RUN apk`. This
    line has multiple commands strung together with `&`. Each `RUN` command in a container
    creates a second layer. Here, we are using as few `RUN` commands as possible.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第四个考虑事项，请查看以`RUN apk`开头的那一行。该行将多个命令通过`&`连接在一起。每个容器中的`RUN`命令都会创建一个新的层。这里，我们尽量使用尽可能少的`RUN`命令。
- en: For the fifth consideration, we close the container with `USER 1001`. This line
    forces all commands in the container to be run as a random user ID. This means
    no commands will run with any form of escalated privilege.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第五个考虑事项，我们使用`USER 1001`关闭容器。这一行强制容器中的所有命令以随机用户ID运行。这意味着没有任何命令会以任何形式的提升权限运行。
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about many tools we can use with GitLab CI to create
    fast and reusable pipelines. We started with DAGs, which allow us to make pipelines
    execute faster. Then, we learned how to build code for multiple architectures.
    With the introduction of mainstream ARM platforms, this is going to gain importance
    over time. Later, we learned when to leverage caching or artifacts in pipelines
    for dependency management.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了许多可以与 GitLab CI 一起使用的工具，用于创建快速且可重用的流水线。我们从 DAG（有向无环图）开始，它可以使流水线执行得更快。接着，我们学习了如何为多种架构构建代码。随着主流
    ARM 平台的出现，这一点将随着时间的推移变得越来越重要。随后，我们学习了在流水线中何时利用缓存或工件进行依赖管理。
- en: The last two topics we covered are likely the most important. We learned three
    different methods to build reusable pipeline definitions so that you don’t have
    to write the same logic in multiple places. Finally, we learned about a concept
    called *purpose-built pipelines*, which enables you to build fast, secure, and
    stable containers to execute your CI workloads in.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论的最后两个主题可能是最重要的。我们学习了三种不同的方法来构建可重用的流水线定义，这样你就不必在多个地方重复编写相同的逻辑。最后，我们了解了一个名为*专用流水线*的概念，它使你能够构建快速、安全且稳定的容器来执行你的
    CI 工作负载。
- en: In the next chapter, you’re going to learn how to expand the reach of your CI/CD
    pipelines.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何扩展你的 CI/CD 流水线的覆盖范围。
