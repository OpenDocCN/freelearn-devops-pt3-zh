- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Enhancing the Speed and Maintainability of CI/CD Pipelines
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提升CI/CD管道的速度和可维护性
- en: In this chapter, we’re going to cover the different tools and methods you can
    leverage to enhance the speed and maintainability of your CI/CD pipelines. Our
    goal in this chapter is to cover three main methods for how to speed up your pipelines.
    We don’t plan on covering every method to speed up a CI pipeline in GitLab, but
    rather the most impactful methods on pipeline speed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍你可以利用的不同工具和方法，来提升CI/CD管道的速度和可维护性。本章的目标是介绍三种主要的方法来加速你的管道。我们不会涵盖GitLab中加速CI管道的所有方法，而是专注于对管道速度影响最大的几种方法。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将讨论以下内容：
- en: Accelerating pipelines with directed acyclic graphs and parent-child architecture
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用有向无环图（DAG）和父子架构加速管道
- en: Building code for multiple architectures
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为多种架构构建代码
- en: When and how to leverage caching or artifacts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时以及如何利用缓存或工件
- en: Reducing repeated configuration code with anchors and extensions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用锚点和扩展减少重复的配置代码
- en: Improving maintainability by combining multiple pipelines and leveraging parent-child
    pipelines
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过结合多个管道并利用父子管道提升可维护性
- en: Securing and accelerating jobs with purpose-built containers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用专用容器保障和加速任务
- en: Accelerating pipelines with directed acyclic graphs and parent-child architecture
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用有向无环图（DAG）和父子架构加速管道
- en: GitLab supports the usage of the **directed acyclic graph** (**DAG**) pattern
    for building CI pipelines. Under normal usage with GitLab, each stage represents
    a series of jobs that need to be completed. Each stage is comprised of multiple
    jobs that are executed in parallel. Once a stage completes, then the next stage
    begins, until the pipeline completes. This is the typical processing loop that
    GitLab utilizes to complete a CI pipeline.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab支持使用**有向无环图**（**DAG**）模式构建CI管道。在GitLab的正常使用中，每个阶段代表一系列需要完成的任务。每个阶段由多个并行执行的任务组成。当一个阶段完成后，下一个阶段开始，直到整个管道完成。这是GitLab用于完成CI管道的典型处理循环。
- en: However, it is possible to create an internal loop of CI jobs that are directed
    to execute in a specific order that does not loop. This pattern is called a **DAG**
    or directed acyclic graph. *Directed* refers to the ordering of operations, *acyclic*
    refers to the fact it only happens once, and *graph* indicates the ordering of
    steps.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，完全可以创建一个内部循环的CI任务，这些任务按特定顺序执行，但不会形成循环。这个模式叫做**DAG**，即有向无环图。*有向*指的是操作的顺序，*无环*指的是这个过程只会发生一次，*图*则表示步骤的顺序。
- en: When leveraged properly, the DAG pattern can dramatically decrease the time
    it takes a pipeline to complete. This occurs because you are creating processing
    loops inside of the CI pipeline and are explicitly defining the order of operations
    for CI jobs outside of stages. A good example of this is if one job’s execution
    is dependent on another job’s execution, you can leverage the `needs:` keyword
    to ensure they’re run one after another outside of a Stage ordering. This creates
    a simple DAG process.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正确使用，DAG模式可以显著减少管道完成所需的时间。这是因为你在CI管道中创建了处理循环，并且明确地定义了CI任务的执行顺序，而这些任务位于阶段之外。一个好的例子是，如果一个任务的执行依赖于另一个任务的执行，你可以使用`needs:`关键字来确保它们一个接一个地执行，而不受阶段顺序的影响。这样就创建了一个简单的DAG过程。
- en: How to create a DAG in GitLab CI
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何在GitLab CI中创建DAG
- en: 'The following is an example of a normal GitLab CI pipeline. The following is
    a YAML implementation of the example we described in the introduction:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个正常GitLab CI管道的示例。以下是我们在介绍中描述的示例的YAML实现：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In a traditional pipeline, as shown here, jobs defined in `stage: B` will only
    begin execution after all jobs in `stage: A` have finished. The following is an
    example of this same pipeline set up to leverage DAG:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '在传统管道中，如下所示，`stage: B`中定义的任务仅在所有`stage: A`中的任务完成后才会开始执行。以下是设置为使用DAG的相同管道示例：'
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'By adding the `needs` keyword to `Job3`, we have created a relationship between
    `Job1` and `Job3`. So, as soon as `Job1` is completed, `Job3` will begin execution.
    This occurs outside of regular stage ordering. In the event `needs` is not defined,
    stage ordering will be respected. As we can see with `Job4`, for `Job4` to begin
    execution, `stage: A` has to complete properly. However, if `needs: []` is defined
    but blank, then GitLab will execute that job the moment a pipeline starts and
    not assign it to any stage for execution.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Building code for multiple architectures
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitLab CI enables you to build artifacts for multiple architectures at once.
    This can easily speed up software builds by two or three times since, with multiple
    architectures, you typically have to build the software multiple times for each
    architecture. Here, we’re going to use CI jobs and pipelines to execute a software
    build for multiple architectures at the same time.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'When building software for multiple architectures, there are some special requirements.
    The first requirement is that you must have GitLab Runners installed and configured
    on a machine running each architecture. For this section, we’re going to use three
    platforms as an example: `x86_64`, `arch64`, and `powerpc`. In this case, the
    expectation would be that you have a machine for each of the three architectures,
    with a GitLab Runner installed on it. That GitLab Runner also needs to have a
    tag assigned to it for which architecture it is running on.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: The second requirement is that the toolchain you use to build your software
    must be able to support a multi-architecture build. For this demo, we’re going
    to use GCC and a multi-architecture Docker image. We’re also going to be using
    the `parallel:` and `matrix:` keywords for GitLab CI.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'The `parallel:` keyword is designed to allow a CI job to run multiple times
    in parallel. So, for example, if you set `parallel: 5` in a CI job, that CI job
    will run 5 times inside of that pipeline, in parallel.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'The `matrix:` keyword is designed to work with the `parallel:` keyword to spin
    up multiple CI jobs at a time, with different variables assigned to them. The
    following is an example of what this looks like when used in a pipeline for multi-architecture
    builds:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding example is going to do three key operations:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: First, with the use of `parallel:` and `matrix:`, GitLab is going to spin up
    three separate jobs – one for each of the variable pairs I’ve defined with `ARCH`
    and `CROSS_TRIPLE`.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second, each of those jobs will have a tag assigned to them, reflecting whatever
    value is defined in `ARCH:`. This will cause that job to be assigned to the appropriate
    runner for that tag.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Third, GitLab will expose the `CROSS_TRIPLE:` environment variable to the `multiarch/crossbuild`
    container. This environment variable is used by the container to properly configure
    the GCC toolchain so that it’s ready to build for that architecture.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the container spins up, and the CI job executes, the `make helloworld`
    command will be run. This command will invoke the preconfigured GCC toolchain
    and cause it to begin building our application binaries. The resulting binaries
    will be built to support the specified architecture.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器启动并执行 CI 作业时，`make helloworld` 命令将被执行。该命令将调用预配置的 GCC 工具链，并使其开始构建我们的应用程序二进制文件。生成的二进制文件将被构建为支持指定架构的版本。
- en: By building multi-architecture binaries this way, we take the complexity out
    of a multi-architecture build. We make those multi-architecture builds repeatable
    and easily understandable. We also run those builds in parallel so that they’re
    not waiting on each other, and we can see the results built from each architecture
    quickly.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种方式构建多架构二进制文件，我们简化了多架构构建的复杂性。我们使得这些多架构构建变得可重复且易于理解。我们还将这些构建并行运行，这样它们就不会相互等待，我们可以快速看到每个架构构建的结果。
- en: Important note
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: The `parallel:` and `matrix:` keywords can be used in any circumstance where
    you need multiple CI jobs with the same configurations, but with different injected
    variables. The `matrix:` keyword can also accept an array as the environment variable
    value. The environment variable key, however, *cannot* be an array.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`parallel:` 和 `matrix:` 关键字可以在任何需要多个具有相同配置但变量不同的 CI 作业的情况下使用。`matrix:` 关键字还可以接受数组作为环境变量的值。然而，环境变量的键*不能*是数组。'
- en: When and how to leverage caching or artifacts
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时以及如何利用缓存或工件
- en: With GitLab, there is often confusion about the usage of caching or artifacts.
    Many users are curious as to which functionality to leverage and when. We aim
    to demystify both in this chapter and give you the tools to implement either approach
    while explaining the benefits and pitfalls of each pattern.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 GitLab 时，关于缓存和工件的使用经常会引起困惑。许多用户都很想知道在什么时候使用哪种功能。本章的目标是为您澄清这两者的区别，并提供实现这两种方法的工具，同时解释每种模式的优缺点。
- en: Caching should be thought of as a method to save items that are commonly used
    in CI jobs or stages. It shouldn’t be thought of as a means to pass items between
    stages or jobs – that’s what artifacts are for. The difference is important because
    of the implementation and configuration of each. A cache is not built or designed
    to be a method to move items between CI jobs. Because of this, in the future,
    any features or changes that are made to it will be tailored toward that functionality.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存应该被视为一种保存 CI 作业或阶段中常用项目的方法。它不应被视为在阶段或作业之间传递项目的手段——这正是工件的作用。这个区别很重要，因为每种方式的实现和配置不同。缓存并不是为了作为一种在
    CI 作业之间移动项目的方法而构建或设计的。因此，未来对缓存的任何功能或更改都将围绕该功能进行调整。
- en: Artifacts are the main way to support storing items created by your CI job indefinitely,
    as well as passing them as a dependency to other CI jobs. With artifacts, you
    get insight into what was stored, and you can link CI jobs with hard dependencies
    on each other to ensure that the artifacts are shared. With caching, there is
    only a soft link. A job using a cache will still work if a cache doesn’t exist;
    however, a job with an artifact will not.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 工件是支持将 CI 作业创建的项目永久存储，并将其作为依赖项传递给其他 CI 作业的主要方式。使用工件时，您可以了解存储了哪些内容，并且可以将具有硬依赖关系的
    CI 作业关联起来，以确保工件得以共享。与缓存不同，缓存只有软链接。使用缓存的作业即使缓存不存在也能继续工作；然而，使用工件的作业则无法继续执行。
- en: The next consideration between caching and artifacts is how they’re stored,
    and the networking calls involved. Cache bundles are processed by the GitLab Runner,
    and the GitLab Runner’s configuration determines where it is stored. Under default
    configuration parameters, the cache is stored on the machine where the runner
    is operating. In terms of containers, the cache is destroyed. By adding an S3
    configuration to the GitLab Runner, the Runner will push all cache bundles to
    S3 storage. Any further CI jobs that use that cache will pull it from S3 storage
    before the CI job begins.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存和工件的下一个考虑因素是它们的存储方式以及涉及的网络调用。缓存包由 GitLab Runner 处理，GitLab Runner 的配置决定了缓存的存储位置。在默认配置参数下，缓存会存储在运行器所在的机器上。对于容器而言，缓存会被销毁。通过为
    GitLab Runner 添加 S3 配置，Runner 会将所有缓存包推送到 S3 存储。在 CI 作业开始之前，任何使用该缓存的 CI 作业都会从 S3
    存储中拉取缓存。
- en: In the case of artifacts, the Runner doesn’t play a role in its processing.
    Every artifact bundle is uploaded to the GitLab instance directly. GitLab’s configuration
    then determines when and where that artifact is stored. The most common configuration
    is also an S3 storage provider. Any future CI jobs that require this artifact
    also download it before the start of the CI job. Like cache bundles, the artifact
    bundle is then uncompressed into the working directory for usage.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于工件，Runner 在其处理过程中不发挥作用。每个工件包都会直接上传到 GitLab 实例。然后，GitLab 的配置决定该工件何时以及存储在何处。最常见的配置也是
    S3 存储提供商。任何需要此工件的未来 CI 作业都会在 CI 作业开始之前下载它。像缓存包一样，工件包会被解压到工作目录中以供使用。
- en: Important note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In this chapter, we will talk about two types of dependencies. The first is
    CI job dependencies, which should be handled with artifacts. CI job dependencies
    essentially link the result from one CI job to another. The second dependency
    type is toolchain dependencies, which are the dependencies of your application
    – usually, third-party libraries. These are used by multiple CI jobs or multiple
    CI pipelines, so they should leverage caching.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论两种类型的依赖关系。第一种是 CI 作业依赖关系，应通过工件进行处理。CI 作业依赖关系本质上将一个 CI 作业的结果链接到另一个作业。第二种依赖关系类型是工具链依赖关系，即应用程序的依赖项——通常是第三方库。这些依赖项由多个
    CI 作业或多个 CI 管道使用，因此应该利用缓存。
- en: Caching characteristics
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存特性
- en: 'These are the things that separate caching from artifacts:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是区分缓存与工件的特点：
- en: You can define a cache per job by using the `cache` keyword. Otherwise, it is
    disabled.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以通过使用`cache`关键字为每个作业定义缓存。否则，缓存将被禁用。
- en: Subsequent pipelines can use the cache.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 后续管道可以使用缓存。
- en: Subsequent jobs in the same pipeline can use the cache if the dependencies are
    identical.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果依赖项相同，同一管道中的后续作业可以使用缓存。
- en: Different projects cannot share the cache.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的项目不能共享缓存。
- en: By default, protected and non-protected branches do not share the cache. However,
    you can change this behavior.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 默认情况下，受保护的分支和非受保护的分支不会共享缓存。但是，你可以更改此行为。
- en: Artifact characteristics
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工件特性
- en: 'These are the things that separate artifacts from caching:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是区分工件与缓存的特点：
- en: You can define artifacts per job.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以为每个作业定义工件。
- en: Subsequent jobs in later stages of the same pipeline can use artifacts.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一管道后续阶段的作业可以使用工件。
- en: Different projects cannot share artifacts.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的项目不能共享工件。
- en: Artifacts expire after 30 days by default. You can define a custom expiration
    time.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工件默认在 30 天后过期。你可以定义自定义的过期时间。
- en: The latest artifacts do not expire if **Keep latest artifacts** is enabled.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果启用了**保持最新工件**，则最新工件不会过期。
- en: You can use dependencies to control which jobs fetch the artifacts.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用依赖关系来控制哪些作业获取工件。
- en: Using caching
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用缓存
- en: 'The first step in leveraging the usage of caching is adding the configuration
    to your GitLab CI file. The following is a code sample of how this is done. If
    you look at this sample, you’ll see we’ve defined a CI job labeled `MyCIJob`.
    From there, we’ve defined a `cache` block and added a `path` parameter with a
    list of the directories and files we want to cache. This is the minimum viable
    code necessary to cache items as part of your CI job:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 利用缓存的第一步是将配置添加到你的 GitLab CI 文件中。以下是如何执行此操作的代码示例。如果你查看此示例，你会看到我们定义了一个名为`MyCIJob`的
    CI 作业。在此基础上，我们定义了一个`cache`块，并添加了一个`path`参数，列出了我们希望缓存的目录和文件。这是将项目缓存作为 CI 作业的一部分所需的最小有效代码：
- en: '[PRE3]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, every time this CI job spins up, it will use the same cache bundle every
    single time. This is very useful when you have dependencies that are downloaded
    every time a CI job runs. By placing these dependencies inside a cache, they won’t
    need to be downloaded every time. Instead, GitLab will insert these dependencies
    at the beginning of the job. This cuts down time on CI jobs significantly, ultimately
    reducing the CI pipeline time to completion.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次此 CI 作业启动时，它都会使用相同的缓存包。这在你有每次 CI 作业运行时都会下载的依赖项时非常有用。通过将这些依赖项放入缓存中，它们就不需要每次都下载。相反，GitLab
    会在作业开始时插入这些依赖项。这大大缩短了 CI 作业的时间，最终减少了 CI 管道完成的时间。
- en: 'Now, we’re going to take this a step further. Let’s assume you have four separate
    CI jobs, and two of each of the CI jobs want to share a cache. In the previous
    example, we created a generic cache that could be used for all jobs. But in this
    example, we want to link a cache between two CI jobs. This can be done with the
    addition of the `key` value:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将进一步深入。假设你有四个独立的 CI 作业，其中每两个 CI 作业需要共享一个缓存。在前面的示例中，我们创建了一个通用的缓存，可以用于所有作业。但是在这个示例中，我们希望在两个
    CI 作业之间链接一个缓存。这可以通过添加 `key` 值来完成：
- en: '[PRE4]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: With the addition of the `key` value, GitLab will have an identifier with which
    to determine when and which cache bundle to download. This key value can obtain
    a string, a variable, or any combination of both. Many users will end up using
    a GitLab predefined variable as a key so that GitLab can manage the cache more
    effectively. For example, if you use the `$CI_PIPELINE_ID` variable, then that
    cache bundle will only be leveraged inside of a pipeline with an ID matching `$CI_PIPELINE_ID`.
    This means that every pipeline will have its own brand-new cache bundle.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加 `key` 值，GitLab 将拥有一个标识符，用来确定何时以及下载哪个缓存包。这个 `key` 值可以是一个字符串、一个变量或两者的任意组合。许多用户最终会使用
    GitLab 预定义的变量作为 key，这样 GitLab 就可以更有效地管理缓存。例如，如果你使用 `$CI_PIPELINE_ID` 变量，那么这个缓存包只会在
    ID 与 `$CI_PIPELINE_ID` 匹配的流水线中被使用。这意味着每个流水线都会有自己全新的缓存包。
- en: 'A final configuration you can leverage with caching is the ability to change
    when and how the cached bundle gets uploaded and downloaded:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以利用缓存的最终配置是改变缓存包的上传和下载的时机和方式：
- en: '[PRE5]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, the cache GitLab CI object has a value called `policy`. By default,
    this is set to a value of `push-pull`, which means the cached bundle is pulled
    down when the job starts and pushed up when the job ends. However, you can also
    configure this to push or pull. By setting it to push, it will push the cache
    object but never pull it, while by setting it to pull, it will pull a cache but
    not push updates to the bundle.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，缓存的 GitLab CI 对象有一个名为 `policy` 的值。默认情况下，这个值设置为 `push-pull`，这意味着缓存的包会在作业开始时被拉取，在作业结束时被推送。然而，你也可以将其配置为仅推送或仅拉取。设置为推送时，它会推送缓存对象，但从不拉取；而设置为拉取时，它会拉取缓存，但不会推送更新到包中。
- en: Using artifacts
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用构件
- en: 'In the previous section, we discussed caching. Much of the same concepts of
    caching are going to apply to artifacts, but artifacts have a richer feature set.
    Because artifacts are used for things such as reporting, passing artifacts between
    jobs, and job dependency management, they require a deeper feature set. Let’s
    start with a basic artifact object and build a more intricate one from that:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一部分中，我们讨论了缓存。缓存的许多相同概念将应用于构件，但构件具有更丰富的功能集。由于构件用于报告、作业之间传递构件和作业依赖管理等，因此它们需要更深层次的功能集。让我们从一个基本的构件对象开始，并从中构建一个更复杂的构件：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: From the preceding example, you can see it’s very similar to caching at its
    core. We’ve added an artifact job, assigned an `artifacts:` object to it, added
    a `paths:` object to that, and listed the files we want to be artifacted. From
    here, when `MyArtifactJob` executes, at the end of the pipeline run, it will send
    everything listed in `paths:` to GitLab and store it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的示例中，你可以看到它的核心与缓存非常相似。我们添加了一个构件作业，分配了一个 `artifacts:` 对象给它，向其中添加了一个 `paths:`
    对象，并列出了我们希望进行构件化的文件。从这里开始，当 `MyArtifactJob` 执行时，流水线运行结束时，它将把 `paths:` 中列出的所有内容发送到
    GitLab 并进行存储。
- en: 'Similar to the cache’s `policy` option, which defines what to do with the cache,
    artifacts have a `when` object that allows you to specify what happens to the
    artifact when an artifact is created. Its options are `on_success`, `on_failure`,
    and `always`. The first option, `on_success`, will upload an artifact only on
    a job’s successful execution. The second, `on_failure`, will only upload when
    the job fails. Finally, `always` will always upload an artifact no matter the
    outcome. When applied to our job, the resulting job will look as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于缓存的 `policy` 选项，它定义了如何处理缓存，构件有一个 `when` 对象，允许你指定当构件创建时会发生什么。其选项为 `on_success`、`on_failure`
    和 `always`。第一个选项 `on_success` 只有在作业成功执行时才会上传构件。第二个选项 `on_failure` 只有在作业失败时才会上传构件。最后，`always`
    会在任何结果下始终上传构件。应用到我们的作业时，结果作业将如下所示：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In conclusion, the preceding job will only execute when other CI jobs are successful.
    It will then store the objects in the `theDirectoryToSave/` folder, in the `myFileToSave.js`
    file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging artifacts as job dependencies
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve covered the basics of artifacts, let’s use them in a real-world
    scenario by chaining jobs together with artifacts. By leveraging the `dependencies`
    keyword in a CI job block, we can pull artifacts from another job and make an
    intrinsic connection between two separate CI jobs.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Our application will be built by the `MyBuildJob` job, which will be defined
    shortly. You may recognize much of the syntax from earlier chapters. This first
    job is an example of how to build a Node.js-based application. First, we leverage
    the `npm install` command to pull down any dependencies used to build this application.
    To keep this example simple, we’re not leveraging a cache for dependencies, but
    we should be in production.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, we’re running the `npm build` command to build the Node.js application.
    The common standard of all Node.js projects is that their built files are produced
    in a folder named `dist`. The Node.js dependencies are commonly stored in `node_modules`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we have an artifact definition that lists both the folders of `node_modules`
    and `dist` as needing to be archived. Now, when this job is executed and completed,
    GitLab will store all of the items in the two folders listed:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following CI job, defined as `MyDependentJob`, has been built to pull the
    artifacts from our previous job. Then, it leverages those artifacts in the build
    of a Dockerfile. The `dependencies` keyword is the glue that connects these two
    jobs:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we can see, by using the `dependencies` keyword, we are instructing GitLab
    to make sure that `MyDependentJob` has everything it needs to run. Without this
    functionality, `MyDependentJob` would be required to pull down these artifacts
    itself, which will take additional time and configuration.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Reducing repeated configuration code with anchors and extensions
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All GitLab CI pipeline files must be valid YAML. This also means they support
    various templates and repeatable code patterns that the YAML language supports.
    Writing multiple CI job definitions for each CI job in a pipeline can be time-consuming
    and lead to serious maintainability concerns. If you leverage the same variable
    in multiple places in a pipeline, it’s better to have it defined once, and then
    referenced multiple times. This way, when you need to change the variable, you
    do it in one place as opposed to many. Not only is this easier to do, but it’s
    also safer as with large pipelines, multiple variable replacements can lead to
    errors.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: The three methods GitLab and YAML offer for creating reusable CI pipelines are
    `extends:`) keyword, and a `!reference`) tag. In the following sections, we’re
    going to explain the benefits and usage of each of these three methods. Each method
    comes with pros and cons in terms of functionality.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Anchors
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first method we’re going to review is **anchors**. YAML anchors allow you
    to duplicate or inherit properties of one CI job to another. With anchors, you
    can define an entire GitLab CI job or a few attributes and then repeat them.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we’re going to utilize a basic YAML anchor. As you can see, `&job_definition`
    is the anchor we’re going to set. Then, we’re going to use it in `jobOne` and
    `jobTwo` to pull in the content from `&job_definition`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once GitLab has processed the CI file, the result will look something like
    this. Here, the contents of `&job_definition` has been merged into our two CI
    jobs:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the preceding example, we defined a job with a dot (`.`) at the beginning
    of it. This dot means the CI job will not be executed as a CI job and merely exists
    as a reference. This was defined as `.job_definition:`. After this definition,
    we added a YAML anchor. This is the `&job_definition` statement that you can see.
    Everything after the `&` symbol defines the name of the anchor. Then, we define
    what a normal job should look like.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: After, we define two CI jobs, each with different `script:` blocks. However,
    we use the `<<:` keyword to tell the YAML processor that we want to merge the
    `.job_definition:` attributes and keywords with this job. The `*` character followed
    by the name of the anchor references the anchor we defined with the `&` symbol.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: The result is the two jobs inside of the merged result code block.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: YAML anchors can only be used in the same GitLab CI file in which they were
    defined. This means that if you are leveraging the `includes:` keyword to break
    your CI files into multiple files, you must use `extends:` or `!reference` instead
    of YAML anchors.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'The extends: keyword'
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second way of reusing CI jobs and configuration inside GitLab CI files is
    via the `extends:` keyword. The `extends:` keyword and YAML anchors are very similar
    in the way they operate. One major difference is that YAML anchors are mostly
    used for duplicating a single value or attribute across your CI pipeline file,
    whereas `extends:` is more often used to reuse entire configuration blocks inside
    your CI pipeline file. In the preceding anchor example, `extends:` is a better
    fit for usage.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, we’re defining a `.rules_definition` block. Then,
    we’re including it in the `.job_definition` block and using the `.job_definition`
    block in `jobOne` and `jobTwo`. Any job definitions that begin with a dot (`.`)
    are not processed by GitLab as an actual job. Instead, they are treated like templates:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After GitLab processes the preceding CI file, the final merged result will
    look as follows. Here, the contents of `.rule_definition` and `.job_definition`,
    which were defined once, are now included in both `jobOne` and `jobTwo`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, this example is slightly different than the one we used for
    anchors. That’s because another key difference between anchors and `extends:`
    is that `extends:` can inherit configuration from multiple CI job definitions.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这个示例与我们用锚点的示例略有不同。这是因为锚点和`extends:`之间的另一个主要区别是，`extends:`可以从多个CI作业定义中继承配置。
- en: Because of this, you can see the resulting merged job definitions have an added
    `rules:` attribute assigned to them. This is inherited through the `.job_definition`
    CI job, from the `.rules_definition` CI job.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以看到合并后的作业定义增加了一个`rules:`属性。这个属性是通过`.job_definition` CI作业继承自`.rules_definition`
    CI作业的。
- en: Reference tags
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用标签
- en: The third method of reusing configuration inside CI files is by using `!reference`
    tags. `!reference` tags are custom YAML tags that are used to select keyword configurations
    from other CI job sections and reuse them in the current section. They’re very
    similar in usage to YAML anchors, but you can use reference tags in multiple CI
    files. On the other hand, YAML anchors can only be used in the same file in which
    they were defined. Let’s look at an example.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 复用CI文件配置的第三种方法是使用`!reference`标签。`!reference`标签是自定义的YAML标签，用于从其他CI作业部分选择关键字配置，并在当前部分中重用它们。它们的使用方式与YAML锚点类似，但你可以在多个CI文件中使用引用标签。另一方面，YAML锚点只能在定义它们的同一个文件中使用。让我们来看一个例子。
- en: 'Create a `Build.gitlab-ci.yml` file that looks like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个看起来像这样的`Build.gitlab-ci.yml`文件：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a `.gitlab-ci.yml` file that looks like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个看起来像这样的`.gitlab-ci.yml`文件：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The result after GitLab processes these two files should look like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在GitLab处理这两个文件后，结果应该是这样的：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding example, a job definition was created in `Build.gitlab-ci.yml`.
    Then, we included that `Build` CI file in our main `.gitlab-ci.yml` file. After,
    we used the `!reference` keyword to pull the script block straight from the `.build-node`
    job definition. By leveraging `!reference` instead of `extends:`, we can only
    pull the configuration we want from that job definition, as opposed to the whole
    job definition. If we had used `extends:`, we would have brought over the `stage:`
    and `before_script:` attributes of that CI job definition as well.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们在`Build.gitlab-ci.yml`中创建了一个作业定义。然后，我们将这个`Build` CI文件包含到主`.gitlab-ci.yml`文件中。之后，我们使用`!reference`关键字直接从`.build-node`作业定义中提取脚本块。通过利用`!reference`而不是`extends:`，我们可以只从该作业定义中提取我们想要的配置，而不是整个作业定义。如果我们使用了`extends:`，我们还会将该CI作业定义的`stage:`和`before_script:`属性一并引入。
- en: Improving maintainability by combining multiple pipelines and leveraging parent-child
    pipelines
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过合并多个流水线和利用父子流水线来提高可维护性
- en: Most GitLab users simply utilize a single `.gitlab-ci.yml` file for their pipelines.
    This approach is perfectly acceptable, but in many cases, the amount of code inside
    this file can become very large and difficult to maintain. GitLab has introduced
    the ability to include multiple `gitlab-ci` files together as one. In this section,
    we’re going to cover how to break up a `.gitlab-ci.yml` file into multiple sections.
    Later, we’re going to cover how to take a second `.gitlab-ci.yml` file and execute
    a second child pipeline, and then discuss the reasons why you may want to do this.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数GitLab用户只使用一个`.gitlab-ci.yml`文件来配置他们的流水线。这种方法完全可以接受，但在许多情况下，这个文件中的代码量可能会变得非常庞大且难以维护。GitLab引入了将多个`gitlab-ci`文件作为一个文件包含在一起的功能。在本节中，我们将讨论如何将一个`.gitlab-ci.yml`文件拆分为多个部分。接下来，我们将讲解如何使用第二个`.gitlab-ci.yml`文件并执行一个子流水线，然后讨论为什么你可能会这样做的原因。
- en: Leveraging includes for maintainability
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用包含来提高可维护性
- en: 'Create a `.gitlab-ci.yml` file that looks like this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个看起来像这样的`.gitlab-ci.yml`文件：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This preceding code shows an example of what a traditional `.gitlab-ci.yml`
    file looks like. For this example, we’ve included four jobs – two build jobs and
    two deploy jobs. In a normal `.gitlab-ci.yml` file, this would be tens of jobs
    with tons of logic between them, likely spanning hundreds of lines of code. This
    is a perfectly acceptable practice, but it is difficult to maintain and manage.
    As with all forms of source code, we want to ensure that the code we write is
    legible and understandable at a glance to ensure maintainability.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码展示了一个传统的`.gitlab-ci.yml`文件的示例。在这个示例中，我们包含了四个作业——两个构建作业和两个部署作业。在普通的`.gitlab-ci.yml`文件中，这可能会包含数十个作业，并且它们之间有大量的逻辑，代码行数可能会达到数百行。这是完全可以接受的做法，但它难以维护和管理。与所有源代码形式一样，我们希望确保我们编写的代码在第一眼就能被理解，以保证其可维护性。
- en: To break this code up, and make it more maintainable, we can leverage the `include:`
    keyword in the GitLab CI’s syntax. This keyword is used to tell GitLab’s YAML
    processor when to combine multiple YAML files into a single context. Let’s use
    this tool to break up our CI file into separate CI files for reusability.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Build.gitlab-ci.yml` file that looks like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Create a `Deploy.gitlab-ci.yml` file that looks like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Create a `.gitlab-ci.yml` file that looks like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we split the individual jobs into files based on stages. Then, we included
    those files in our `.gitlab-ci.yml` file. When GitLab’s CI processor goes through
    our `.gitlab-ci.yml` file, it will merge each YAML file into a single context
    from top to bottom. This means that if I write the same job in `Build.gitlab-ci.yml`
    and `Deploy.gitlab-ci.yml` because `Deploy.gitlab-ci.yml` is included last, it
    will overwrite whatever was in the Build CI file. This is a simple example and
    method of separating your CI files for more maintainability. Next, we’re going
    to focus on combining an example from earlier with this method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging includes for reusability
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier, you learned how to use includes to help with maintainability. In this
    section, we will combine the usage of `include:` and the knowledge we learned
    earlier in this chapter around anchors and extensions to show you how to create
    reusable pipelines. We’ll start with an example.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `Templates.gitlab-ci.yml` file that looks like this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the preceding GitLab CI file, we’ve created a very simple CI job definition.
    Because this CI job’s name begins with a `.`, this job will not run on its own.
    We’ve included a `variables:` block and inserted an empty `NPM_CLI_OPTS` variable
    as a placeholder. Then, we used that variable in our `script:` block when we executed
    the `rebuild` command. The reason for this default variable is that we want to
    have a sane default when this job is used.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: We’ve named this CI file `Templates.gitlab-ci.yml` to indicate that it houses
    our CI job templates and not actual CI job definitions. However, we want to leverage
    this in a CI pipeline. The following example shows how to achieve this.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `.gitlab-ci.yml` file that looks like this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we’re including all job definitions from the `Templates.gitlab-ci.yml`
    file, and we’re starting our own job based on those definitions. However, in the
    `variables:` block, we’re adding our own variables to control how the template
    CI job definition will run.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: This method of templating a CI job and then using variables to expose configuration
    options for it is similar to how componentization occurs in traditional software
    development. It follows the same purpose, rules, and goals, even though the syntax
    is different.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Includes from remote areas
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `include:` keyword is not delegated to a single project or repository.
    You can include GitLab CI files from the open internet as well. Some examples
    of remote includes are listed here:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Including from a separate project and branch:'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Including from a remote location:'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Include from a template on the GitLab instance (`lib/gitlab/ci/templates`):'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Important note
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: You can include a CI file from anywhere the starter of a CI pipeline has access.
    Provided that the person who starts the CI pipeline has read access to the included
    file, the pipeline will succeed. However, if the person does not have access,
    the pipeline will fail.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging parent-child pipelines
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve spoken about including multiple YAML files and how you can templatize
    them for reusability, let’s talk about how we can leverage them with the `trigger:`
    keyword to create child pipelines.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: A **child pipeline** is a pipeline that is triggered by another pipeline. The
    triggering pipeline is referred to as the **parent pipeline**. Once a parent pipeline
    triggers a child pipeline, the parent’s pipeline execution waits for the new child
    pipeline to complete before it resumes. This is a powerful tool for building multiple
    pipelines to support a monorepo, or for breaking one large complex pipeline into
    smaller, more manageable pipelines.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'To invoke a child pipeline, simply add the `trigger:` keyword as the parent
    to an `include:` statement. The following example will execute the `build.gitlab-ci.yml`
    file as a child pipeline:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: With the preceding example, in a CI pipeline view, you will see a CI job that
    states `My-Child-CI-Job`. This CI job will have another pipeline attached to it
    labeled `Downstream Pipeline`. In that view, you will be able to see all of the
    jobs from the child pipeline and their execution status.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: An invoked child pipeline accepts all normal CI job attributes and keywords.
    Keywords such as `rules:` can determine when a child pipeline is invoked. The
    `environment:` keyword can also tie the invocation of a child pipeline to approval
    rules or environment tracking.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Securing and accelerating jobs with purpose-built containers
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitLab, when set up properly, runs all the CI jobs of a pipeline in a container.
    This means that the entire build operation happens in a container. Because of
    this, container stewardship is exceptionally important. If a CI job happens in
    an insecure container, then that means the entire CI job and pipeline are insecure.
    If a CI job uses a non-performant container, that CI job and pipeline will take
    much longer to complete, resulting in a much slower time to show results. In every
    measurable way, the container used for your CI jobs is the most important part
    of your pipeline.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: To quickly set or identify which container a specific CI job is using, look
    for the `image:` attribute in a CI job. This attribute will define the source
    of the container image, and the exact container image being used.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: A second area to look for this container image is at the top of the CI job log.
    There will be a message indicating which container image is being used.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: We aim to resolve these concerns with a practice we call *purpose-built containers*.
    These are containers whose entire design is to be used in a CI pipeline. Here,
    we will outline some attributes of these containers and explain how to build them.
    When building containers for a CI pipeline, try to follow as much of this guidance
    as possible. Even if you’re not able to achieve every item mentioned here, following
    them as much as possible will result in a much more secure, performant, and maintainable
    container for your CI pipeline.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: The first item to consider is the file size of the container. A container for
    use in GitLab CI should contain only the minimum number of components necessary
    to run and perform its tasks. This container should also only perform one set
    of tasks. This means you would have a separate container for each toolchain –
    that is, one for Java and one for Node.js. You do not want to mix multiple toolchains
    because it will explode your container’s file size. There is rarely a scenario
    where you would need multiple toolchains in the same container as they are usually
    executed in separate CI jobs. A good rule to follow is that if a CI job does not
    need something, that something should not be included in the container.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: The second item to consider is ensuring your containers are multi-use. You still
    want to keep your toolchains in separate containers; however, you should avoid
    embedding configuration inside of a container that will prevent it from being
    used in multiple CI jobs or multiple pipelines. A good example of what to include
    would be encryption certificates so that the container can communicate with any
    resources it needs. An example of what not to include would be any configuration
    or settings that are related only to a single CI job or pipeline. The difference
    between these two items is that the first example (certificate) is used to enable
    the container to work properly, whereas the second example (configuration or setting)
    will restrict which CI jobs and pipelines the container can run in.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: The third item to consider is preventing the container from being run under
    normal use. A purpose-built container for GitLab CI should effectively be a zombie
    or a shell. There should be no circumstance where the container executes anything
    other than what the CI job instructs it to. This can be performed by ensuring
    the container’s entry point is empty. If a Docker container executes anything
    as it starts in a GitLab CI, it can cause conflicts and will also take more time
    to start.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: The fourth item to consider is to avoid adding needless layers inside of a Docker
    container. With every `RUN` or `ADD` command in a Dockerfile, Docker will create
    a new layer. Needless layers can balloon the size of the Docker container significantly
    and thus violate the first concern. When you run commands in a Dockerfile, you
    should use the `&` operator liberally to chain together run commands. We have
    provided an example of this usage in our Dockerfile example.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: The final item to consider is privilege. A Docker container running in GitLab
    CI does not typically need elevated permissions to run and perform operations.
    On OpenShift and some Kubernetes platforms, any Docker container with elevated
    privileges may not be allowed to run and execute. Setting a random user ID when
    creating the container will help prevent these platforms from giving the container
    any form of privilege. If you need to provide permissions to a file or folder,
    they should be granted to a group as opposed to individual users.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: A purpose-built container example
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we have provided an example of a purpose-built container. This example
    follows all the considerations we listed previously. This is a Docker image that
    has been built upon the `alpine:3.12.0` base container. From there, we have a
    `RUN` command that combines multiple commands in one line. It makes use of the
    `&` operator to chain together multiple APK package manager commands. This reduces
    the number of layers in the Docker file. At the end of that command line, we assign
    a folder to the group of the running user. In doing so, we reserve the ability
    to manipulate that folder, but we prevent it from gaining any privilege from a
    bad group assignment:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: For the first consideration, you can see it is being met with `apk add –no-cache
    nodejs npm`. Node.js is the only toolchain that is installed in this container.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: For the second consideration, you can see no configuration is embedded in the
    Dockerfile. This means the container will pull all of its configurations from
    the CI job’s configuration.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: For the third consideration, you can look at the line starting with `CMD ["echo"`.
    This line prevents the container from running outside of a CI job. It presents
    an error message and kills the container.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: For the fourth consideration, look at the line starting with `RUN apk`. This
    line has multiple commands strung together with `&`. Each `RUN` command in a container
    creates a second layer. Here, we are using as few `RUN` commands as possible.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: For the fifth consideration, we close the container with `USER 1001`. This line
    forces all commands in the container to be run as a random user ID. This means
    no commands will run with any form of escalated privilege.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about many tools we can use with GitLab CI to create
    fast and reusable pipelines. We started with DAGs, which allow us to make pipelines
    execute faster. Then, we learned how to build code for multiple architectures.
    With the introduction of mainstream ARM platforms, this is going to gain importance
    over time. Later, we learned when to leverage caching or artifacts in pipelines
    for dependency management.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: The last two topics we covered are likely the most important. We learned three
    different methods to build reusable pipeline definitions so that you don’t have
    to write the same logic in multiple places. Finally, we learned about a concept
    called *purpose-built pipelines*, which enables you to build fast, secure, and
    stable containers to execute your CI workloads in.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’re going to learn how to expand the reach of your CI/CD
    pipelines.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
