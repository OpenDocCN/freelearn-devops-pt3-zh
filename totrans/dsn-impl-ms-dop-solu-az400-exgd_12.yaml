- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Application Monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, you learned about applying DevOps principles to software
    delivery. You learned how to create a pipeline from source control all the way
    to production. You also learned how to ensure that your delivery is compliant
    and secure, without sacrificing speed or a focus on the delivery of business value.
    In this chapter, you will learn how to start transforming this pipeline into a
    DevOps loop, a continuous process of delivering new software, and then measure
    how your application performs. This is a continuous journey, as you evaluate how
    your application fares in production and learn how to proceed next.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, this chapter starts by introducing a means for gathering application
    crashes. Almost every application will, at some point, throw an unhandled exception
    and crash. Ensuring that application crashes are gathered and reported will enable
    you to investigate the causes and address them. Then, attention will shift to
    instrumenting applications.
  prefs: []
  type: TYPE_NORMAL
- en: Instrumentation is the practice of gathering logs and metrics that help you
    understand how your application performs in production. You can use them to get
    alerts when things go wrong or, hopefully, before they go wrong. The chapter concludes
    by exploring several options for integrating with other tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics are covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Investigating application crashes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instrumenting web applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating with other tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To experiment with the techniques described in this chapter, you will need
    one or more of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An App Center account for gathering mobile application crashes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Raygun subscription for gathering desktop application crashes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An Azure subscription for instrumenting web applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Free-trial options are available for all of these.
  prefs: []
  type: TYPE_NORMAL
- en: Investigating application crashes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: No matter how well an application is engineered, at some point, it will crash
    due to an unexpected condition. To learn from these crashes and to try and prevent
    them in the future, it helps to add code to applications to gather crash reports
    and send them to a central location. Here, they can be analyzed and grouped to
    identify application improvements. How to do this differs, depending on the type
    of application.
  prefs: []
  type: TYPE_NORMAL
- en: The following sections discuss how this process for mobile and desktop applications
    works. Regarding web applications, gathering crash reports can be done using the
    same tool as for instrumentation; we will discuss this in the *Instrumenting web
    applications* section later on.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering crash reports for mobile applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the many tools available for gathering crash reports and errors from
    mobile applications is Visual Studio App Center. Besides distributing mobile applications,
    **App Center** also allows applications to submit their crashes and errors for
    analysis.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started with crash reporting using App Center, the application first
    needs to be defined. This is called an app definition and how to work with it
    was discussed in[*Chapter 6*](B18655_06.xhtml#_idTextAnchor330), *Implementing
    Continuous Deployment and Release Management*. With this app definition, an app
    secret is created, which is needed to configure an application to send out crash
    reports. Along with crash reports, it is possible to track other errors, and exceptions
    that are of interest to developers. To start sending crash reports, the following
    steps need to be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the `Microsoft.AppCenter.Crashes` NuGet package in the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code to the application initialization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides crashes, it is also possible to track other errors that are of interest
    to developers. This can be done using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'All the unhandled exceptions are automatically caught and sent back to App
    Center. Here, they become available for analysis, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – An App Center diagnostics overview ](img/B18655_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – An App Center diagnostics overview
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on any of the reported errors or crashes to open a detailed view, as
    shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – An App Center diagnostics detailed view ](img/B18655_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – An App Center diagnostics detailed view
  prefs: []
  type: TYPE_NORMAL
- en: A dashboard with the most important information is shown for each crash or error.
    This includes the number of reports and the number of affected users. Also, the
    impacted device types and operating systems are shown. At the top of the page,
    the stack traces are shown, which can be used by developers to investigate and,
    hopefully, fix the issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'App Center has integration with Azure DevOps, Jira, and GitHub for bug tracking
    purposes. Refer to this link for more information: [https://docs.microsoft.com/en-us/appcenter/dashboard/bugtracker/](https://docs.microsoft.com/en-us/appcenter/dashboard/bugtracker/).'
  prefs: []
  type: TYPE_NORMAL
- en: For any critical events, App Center can directly create a bug and send email
    notifications.
  prefs: []
  type: TYPE_NORMAL
- en: That covers gathering crash reports and errors from mobile applications. The
    next section introduces the same concepts for desktop applications.
  prefs: []
  type: TYPE_NORMAL
- en: Gathering crash reports for desktop applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Crash reporting is also available for desktop applications. There are, again,
    many solutions available for desktop applications and most of them work in roughly
    the same way. One of these solutions is Raygun. Raygun is a commercial offering
    available for .NET applications but works for many other languages and platforms
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'To gather crashes using Raygun, follow these three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Sign up for a Raygun account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the `Mindscape.Raygun4Net` NuGet package on the solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Catch unhandled exceptions and forward them to Raygun.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following example shows you how to catch and forward unhandled exceptions
    to Raygun:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: All the exceptions can be explored in the Raygun web interface. Here, exceptions
    are automatically grouped if stack traces are sufficiently similar. They can also
    be grouped and browsed individually, but in most cases, it makes sense to only
    focus on the larger groups of exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows how these groups can be browsed in Raygun:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.3 – The Raygun view for desktop application exceptions  ](img/B18655_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – The Raygun view for desktop application exceptions
  prefs: []
  type: TYPE_NORMAL
- en: Clicking on the exception message in this interface shows the complete stack
    trace and all the shared properties of any instance of the exception that has
    occurred.
  prefs: []
  type: TYPE_NORMAL
- en: This completes our look into gathering crash reports from mobile and desktop
    applications. Doing so allows you to find and investigate issues that customers
    face in production. In the following section, instrumentation for web applications
    will be introduced to further enhance our insight into how applications behave
    in production.
  prefs: []
  type: TYPE_NORMAL
- en: Instrumenting web applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Web applications differ from mobile and desktop applications in many ways, including
    the fact that large portions of the application run on a server rather than a
    client. This enables developers to collect information on how web applications
    are run more easily than other types of applications. This is known as instrumenting
    an application.
  prefs: []
  type: TYPE_NORMAL
- en: Logs are text messages that are saved by a system to describe the execution
    path that the server follows. This helps developers go back in time and explore
    what has happened by examining the logging output. Structured logging is quickly
    becoming the standard for trace logging. **Structured logging** is a technique
    where logs are no longer only text messages. Instead, logs are parameterized text
    messages with a set of values for each parameter. This has two advantages – logs
    can be better compressed, and they can be searched more quickly.
  prefs: []
  type: TYPE_NORMAL
- en: '**Metrics** are values that are recorded for an application. They take the
    form of a timestamp, metric name, and value. One example is recording the percentage
    of a CPU in use every second.'
  prefs: []
  type: TYPE_NORMAL
- en: When instrumenting an application, it is easy to focus on many server-level
    types of logs and metrics. For example, many operators will, by default, start
    collecting metrics such as CPU usage, memory pressure, and I/O operations. While
    there is nothing wrong with these metrics, they are not always indicative of an
    application’s performance from a user’s point of view. Other metrics, such as
    response times or queue message processing delays, might yield better insights
    into the user experience. While there is nothing wrong with measuring system metrics
    (they are often great indicators of future issues), you should also try to gather
    user-centric metrics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Azure offers the Application Insights service for instrumenting applications,
    with a focus on web applications. An Application Insights workspace can be created
    using the Azure portal, which opens up a workspace, as shown in the following
    screenshot. In Azure portal in overview section, **instrumentation key** field
    is plainly shown, it is recommended that you treat this as an application secret:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.4 – Azure Application Insights Overview ](img/B18655_12_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.4 – Azure Application Insights Overview
  prefs: []
  type: TYPE_NORMAL
- en: The following subsections will go into detail about logging, metrics, and investigating
    individual requests.
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most basic types of instrumentation is adding logging statements
    to application code. In the past, these logs were saved to the disk of the server
    that ran the application. Retrieving and investigating these logs, therefore,
    took a lot of time and effort.
  prefs: []
  type: TYPE_NORMAL
- en: In modern hosting environments, logs are no longer saved on the local filesystem
    but instead stored remotely. With transient infrastructure and servers added or
    removed on the fly, it is no longer possible to store logs on a server and be
    sure that they can be retrieved later. For this reason, they are transmitted over
    HTTP to specialized log stores, such as Application Insights.
  prefs: []
  type: TYPE_NORMAL
- en: Emitting logs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To write log entries to a log store, such as Application Insights, from an
    ASP.NET application, two things must be done:'
  prefs: []
  type: TYPE_NORMAL
- en: Log entries need to be emitted from the application code, where applicable,
    using the `ILogger` interface. This interface is available from the `Microsoft.Extensions.Logging.Abstractions`
    NuGet package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Application Insights NuGet package (`Microsoft.ApplicationInsights.AspNetCore`)
    needs to be installed and Application Insights needs to be registered as `LoggingProvider`.
    This way, all logs sent to the preceding interface are forwarded to the Application
    Insights code. In turn, this code forwards all the logs to the Application Insights
    service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following example code shows you how to use the `ILogger` interface from
    a class to emit a structured log entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: There should be no dollar sign (`$`) at the start of the log entry. There is
    no string interpolation used here, but two placeholders are inserted into the
    text message. The structured logging entry will recognize these and, when showing
    the entry, insert the provided values.
  prefs: []
  type: TYPE_NORMAL
- en: With log entries emitted, a logging provider should be registered to capture
    these logs. This is done using the .NET Core built-in dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: After starting the application, all log entries at the level of warning and
    higher are automatically forwarded to Application Insights. To change which entries
    are forwarded and which aren’t, filters can be configured. A link to more details
    on configuring Application Insights in detail is provided at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Searching logs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Within a few minutes of emitting a log entry to Application Insights, it becomes
    available on the interface for querying. To do this, open the Application Insights
    instance and navigate to **Logs** in the left-hand-side menu (**1**). This opens
    the view shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.5 – The Application Insights Logs view ](img/B18655_12_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.5 – The Application Insights Logs view
  prefs: []
  type: TYPE_NORMAL
- en: Here, it is possible to write queries (**2**) that search the recorded logs
    in **Kusto Query Language** (**KQL**). Application Insights is optimized for handling
    large amounts of data and most queries return results within a second or less,
    even when searching millions of log entries.
  prefs: []
  type: TYPE_NORMAL
- en: Alerting on logs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Gathering and searching logs is useful when troubleshooting specific situations
    or bugs in response to a user complaint. However, there are situations where it
    is better to be notified automatically when a certain condition arises. This is
    called alerting.
  prefs: []
  type: TYPE_NORMAL
- en: Within Azure, it is possible to create alert rules that notify developers whenever
    a certain condition is met. Alerting functionality is provided by the Azure Monitor
    offering that is integrated with many Azure services, including Application Insights.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new alert rule, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to Azure Monitor using the portal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, choose **Alerts**. This opens the view shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.6 – The Azure Monitor Alerts view ](img/B18655_12_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.6 – The Azure Monitor Alerts view
  prefs: []
  type: TYPE_NORMAL
- en: 'If there are any alerts that need attention, they are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.7 – The Azure Monitor alert creation view ](img/B18655_12_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.7 – The Azure Monitor alert creation view
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the **Create** button at the top-left-hand side of the screen to add new
    alert rules. Doing so opens another view, as shown in the preceding screenshot.
    Here, the alerting conditions can be configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.8 – The Azure Monitor alerts Review + create view ](img/B18655_12_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.8 – The Azure Monitor alerts Review + create view
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, the view that opens to configure alerts – **Scope**
    – is shown. Here, it is necessary to make resource selections to create an alert.
  prefs: []
  type: TYPE_NORMAL
- en: This (**1**) is the resource that is the subject of the alert. This can be any
    type of resource, and in this instance, the alert will be on an Application Insights
    workspace.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These (`404` code result:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`400` code result.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**The interval to evaluate the alert condition over** (**2c**): When specifying
    a query that matches a specific number, this determines the interval in which
    this amount must be met.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**How often to evaluate the alert condition** (**2d**): Evaluating an alert
    condition too frequently can result in too many alerts opening and closing in
    a fast series. Evaluating an alert condition too infrequently can result in alerts
    coming in too late. Experimentation will help you understand how to configure
    this.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is the action to execute when the alert condition is met. Since there might
    be a lot of alerts that have to invoke the same group of actions, actions can
    be grouped, and these action groups can be referenced here. Some examples of actions
    are calling a Webhook or sending an SMS message or email.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The alert configuration is completed by putting in a name and description (**3**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the alert can be saved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the alert is reviewed and created as per the preceding screenshot, activation
    is done automatically, and within a few minutes, the alert is ready to inspect
    application logs and signal whenever the alert condition is met.
  prefs: []
  type: TYPE_NORMAL
- en: Logging is a great method of gaining deep knowledge about what happened with
    a request and how an error came to be. Another technique for learning more about
    an application’s behavior is by using metrics.
  prefs: []
  type: TYPE_NORMAL
- en: Metrics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Besides logs, an application can also emit one or more metrics. A metric is
    a series of values over time that describes one or more aspects of a system. Some
    examples of metrics are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The number of users currently logged in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of products viewed by users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of database transactions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gathering metrics such as these can provide insight into how a system is used
    and how it currently operates. Metrics are often used for creating dashboards
    and alerts.
  prefs: []
  type: TYPE_NORMAL
- en: Emitting metrics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To start working with metrics, they first have to be emitted by an application
    and stored in a centralized location. Besides logging, Application Insights can
    be used for metrics as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Application Insights for metrics, the following steps need to be taken:'
  prefs: []
  type: TYPE_NORMAL
- en: Metrics need to be emitted from the application code where applicable, using
    the `TelemetryClient` class. This interface is available from the `Microsoft.Extensions.Logging.Abstractions`
    NuGet package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the `Microsoft.ApplicationInsights.AspNetCore` Application Insights
    NuGet package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Register `TelemetryClient` with the `Dependency` container. Do this by using
    the extension method on the container builder, as shown in the following code
    snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once this is done, the application is ready to start emitting metrics. This
    is done using the `TelemetryClient` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Emitting a metric involves two steps. First, a reference to the metric is retrieved
    using the `GetMetric()` method. Next, a value is submitted using the `TrackValue`
    method. Submitted values should be doubles or allow an implicit conversion to
    a double.
  prefs: []
  type: TYPE_NORMAL
- en: Once the metrics are emitted, they can be used to create graphs and metrics.
    However, before moving on to these topics, first, another type of metric needs
    to be discussed – namely, Azure platform metrics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the metrics that an application emits, there are also numerous metrics
    that can be recorded from the Azure platform that the system is running on. Some
    examples are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The percentage of CPU used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of messages on a service bus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The number of database transactions per second
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The amount of free disk space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These metrics are often closely related to how an application performs and may
    even be leading indicators. For example, when the amount of free disk space reaches
    0, most web servers stop working.
  prefs: []
  type: TYPE_NORMAL
- en: In Azure, each service emits a series of metrics by default. These are called
    platform metrics. Which metrics are emitted differs from service to service and
    cannot be influenced by the user. These metrics are also automatically gathered
    by Azure Monitor, and they can be used in the same ways for graphing and alerting
    as they are emitted by an application.
  prefs: []
  type: TYPE_NORMAL
- en: Platform metrics are integrated, cost-free, and for the majority of resources
    metrics are retained for 93 days.
  prefs: []
  type: TYPE_NORMAL
- en: Graphing metrics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All metrics that are gathered, either in Application Insights or in Azure Monitor,
    can be used to build graphs and dashboards that visualize the metric. Graphs can
    be created using the **Metrics** tab that is available on every Azure resource.
    Graphs can also be created using the Azure Monitor. This way, graphs for multiple
    resources can be combined on a single canvas. To do this, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Azure Monitor, which is available from the menu on the left.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate to the **Metrics** menu. This opens the view shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.9 – Azure Monitor – Metrics ](img/B18655_12_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.9 – Azure Monitor – Metrics
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the canvas opens, one or more graphs can be added to it. A graph is built
    using the graph builder at the top. Four selections have to be made here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The resource that a graph needs to be drawn for.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TelemetryClient`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GetMetric()` method from the previous section.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The mathematical operation to combine multiple measurements into a single
    point on the graph**: This can be the minimum, maximum, average, sum, or count.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To add multiple graph lines to the same graph, choose **Add Metric** at the
    top. Repeat the preceding four selections to configure the new graph.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To make this graph part of a dashboard for easy reuse, click the **Pin to dashboard**
    button at the top.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Dashboards can then be accessed directly using the menu on the right:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.10 – The App Service Http400 metrics graph ](img/B18655_12_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.10 – The App Service Http400 metrics graph
  prefs: []
  type: TYPE_NORMAL
- en: Having a graph of a metric, or even multiple graphs in a dashboard, is great
    for investigating issues. However, no one likes to continuously watch dashboards
    to see how things are going. For that reason, it is also possible to configure
    alerts on metrics.
  prefs: []
  type: TYPE_NORMAL
- en: Alerting on metrics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just as with log entries, it is possible to be alerted by Azure Monitor when
    a metric goes above or below a certain threshold. Log entries that require a follow-up
    could be related to only a single user or customer that is having trouble. Metrics,
    on the other hand, are useful for detecting situations where all users are impacted
    by an issue, or situations where an infrastructure no longer works or will stop
    working soon.
  prefs: []
  type: TYPE_NORMAL
- en: Creating alerts for metrics works in a way that is very similar to creating
    alerts from logs. To create a new alert rule, navigate to Azure Monitor using
    the portal and then choose **Alerts**.
  prefs: []
  type: TYPE_NORMAL
- en: Investigating requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using Application Insights for logging and metrics, there are many more
    built-in capabilities of Application Insights that you can use. One of these capabilities
    is the possibility to execute search queries against all types of data collected
    by Application Insights from one view, called **Search**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, it is possible to search all the information collected by Application
    Insights, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Logs emitted by the application code, which includes NuGet packages and the
    .NET Framework.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**All dependency calls**: These are calls to databases and other systems that
    are automatically detected by Application Insights. Application Insights records
    the target system and duration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**All exceptions**: All exceptions that occur in an application are recorded
    by Application Insights, even if properly handled by the application code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Requests**: Every user request that comes in over HTTP is logged. Important
    properties, such as the URL, duration, and HTTP verb, are also included.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To search for a specific transaction using the search view, open the correct
    Application Insights instance within the Azure portal and navigate to the **Transaction
    search** menu (**1**) to get the view shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.11 – Application Insights – Transaction search ](img/B18655_12_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.11 – Application Insights – Transaction search
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Transaction search** view, several search parameters can be configured
    (**2**):'
  prefs: []
  type: TYPE_NORMAL
- en: '**An interval to search within**: This defaults to the last 24 hours.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The types of events to search in**: These can be requests, log entries, page
    views, exceptions, dependency calls, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any text to search for.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Within seconds, all matching results are shown in a bar chart. Each bar stands
    for a time period and shows how many matches there are within that time frame.
    Below this chart, all the individual matches are shown. These are a mix of all
    of the types of events available.
  prefs: []
  type: TYPE_NORMAL
- en: Clicking on any of the results opens a new view that shows the selected record
    in relation to all the other types, grouped per request. This allows you to quickly
    navigate to all the logs, dependency calls, and exceptions that are gathered by
    Application Insights during the execution of a single user request. The results
    can be displayed as a list and as a timeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'This allows you to see very quickly what the server was doing when performing
    the user request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.12 – Application Insights – End-to-end transaction details ](img/B18655_12_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.12 – Application Insights – End-to-end transaction details
  prefs: []
  type: TYPE_NORMAL
- en: With all of these means to investigate applications and be notified regarding
    events, it is important to decide which alerts to create and which not to, not
    only in order to create a healthy working environment but also to balance monitoring
    with new work. This is the topic of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing alerting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once teams start instrumenting their applications and adding alerts to metrics
    that they find important, it will not be long before the first alerts start coming
    in. At this point, it is important to not only respond to the alerts but also
    to investigate them and then close them. Alerts should also be evaluated and viewed
    as an opportunity for learning.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing alerts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An important thing to do after creating a series of alerts is to re-evaluate
    them on a regular basis. Two things that might come out of an evaluation such
    as this are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Changes in the alerting threshold**: Evaluating alerts regularly involves
    taking a look at the metric over time and seeing where the alerting threshold
    is at now. This might lead to the conclusion that the threshold is too low or
    too high.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Removing duplicates**: Looking at alerts that have been raised over the month(s),
    it is very likely you’ll identify one or more groups of alerts that are always
    raised at the same time. For example, a set of alerts set on a specific web server
    can be so related that they are always raised at the same time. A common example
    is CPU usage and the average response time for an HTTP request; these two often
    rise at the same time. If this is the case, it is worth considering either removing
    one of them or downgrading one of them to be a warning only. Duplicate alerts
    increase the number of items that need an immediate reaction, leading to increased
    pressure on a team without a clear benefit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constantly optimizing the set of alerts not only helps to reduce waste but also
    prevents so-called alert fatigue.
  prefs: []
  type: TYPE_NORMAL
- en: Alert fatigue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If alert rules are not constantly reviewed and updated, they could negatively
    influence a team, especially when alert rules trigger too easily or too frequently,
    as people will no longer respond to them properly. If there are too many alerts,
    it will wear people out and they will become numb to the effect of an alert. It
    does not even matter whether they are false alerts or real alerts; just the number
    of alerts can be enough to get people into a state where they do not care anymore.
  prefs: []
  type: TYPE_NORMAL
- en: If a situation such as this is observed within a team, it is time to drastically
    change the way alerts are generated and responded to. If this does not happen,
    team members might fall ill or leave a company altogether.
  prefs: []
  type: TYPE_NORMAL
- en: One of the ways to prevent this situation is by implementing a healthy on-call
    schedule.
  prefs: []
  type: TYPE_NORMAL
- en: Which metrics to capture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One question that comes up frequently when talking about metrics is what metrics
    to emit and monitor. There are many possible metrics and even more opinions on
    this subject. As a good starting point, the following metrics are often gathered
    for web applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Requests per minute, transactions per minute, or something similar**: This
    is a metric that is intended to capture the current load or throughput on a web
    application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The average response time**: This metric captures the response time for all
    requests within a time window.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`400` and upward are often taken.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When these three metrics are captured and graphed together in a single graph,
    it provides the very first step in understanding an application’s behavior. Let’s
    explore a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: When the average response time goes up but the throughput (requests per minute)
    stays the same, this might be an indication that the infrastructure that hosts
    the application is having issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When both the throughput and the average response times go up, this might be
    an indication that traffic is increasing and that the current infrastructure is
    not capable of sustaining that throughput at the same response times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the error rate goes up but the other metrics stay the same, this might
    be an indication that a deployment has gone wrong or that a specific code path
    is starting to generate (more) errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, these are just examples, and there are many more possible scenarios.
    Other metrics can help to rule out a specific scenario or try to avoid them. For
    example, also starting to monitor the database load as a percentage can help detect
    a specific instance of all three scenarios. If the database load gets close to
    100%, it might be time to scale the database up to a higher performance tier to
    help to sustain the higher throughput at the same response times as before.
  prefs: []
  type: TYPE_NORMAL
- en: To conclude this section, there is one final recommendation – when starting
    with monitoring, there is often a tendency to focus on the systems that host the
    application. As an alternative, also consider monitoring metrics that have a direct
    business impact or metrics that are an indication of user satisfaction in terms
    of the usability of an application. This comes much closer to measuring business
    value than when only you watch systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples of this are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In an online shop, the number of books sold per minute can be a very valuable
    business metric. Just imagine the impact it can have on a business if this metric
    is available in near real time using Azure Monitor and custom metrics from the
    application code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For an online reading platform, the number of virtual page turns can be a valuable
    metric that signals whether users are happily working with the service. As soon
    as this number sees a sharp drop or rapidly increases, this might be an indication
    that something is going wrong.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To find out which metrics make sense in a given scenario, it might help to talk
    to business or subject matter experts.
  prefs: []
  type: TYPE_NORMAL
- en: Having an on-call schedule
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once alerts are configured and start to be raised, it does not make sense to
    configure them to not trigger before 8 AM and after 5 PM. In other words, it is
    necessary to make sure that alerts of a certain severity are followed up even
    outside of business hours.
  prefs: []
  type: TYPE_NORMAL
- en: In many companies where having alerts is new, there is some form of implicit
    expectation that some people will be available outside of office hours (alongside
    their regular duties) to handle these alerts. Sometimes, when an alert is raised
    only once or twice a year, and there are no agreements about response times, this
    might not even be a problem at all.
  prefs: []
  type: TYPE_NORMAL
- en: However, in many organizations – especially over time – there is an expectation
    that these alerts are responded to within a certain period of time. Besides that,
    the number of alerts may increase as systems become larger and more complex, or
    the number of systems grows.
  prefs: []
  type: TYPE_NORMAL
- en: The way to cope with this is by creating an on-call schedule and formal agreements
    on what is expected of engineers and how the organization will reward them for
    their efforts. This allows the organization to set clear expectations and allows
    engineers to manage their free time based on these agreements. Having enough system
    downtime helps the engineers relax between periods of higher stress. This allows
    them to stay alert when they are on call, ready to react when this is expected
    of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is much material available on what constitutes a healthy on-call schedule
    and what doesn’t, and the keyword here is *healthy*. Some general pointers are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Those who are on call during non-business hours should not be on call during
    business hours as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide engineers who are on call with reasonable compensation for being close
    to a phone, not under the influence, and so on. What is reasonable differs from
    situation to situation, but the more demanding being on call is, the higher the
    compensation should be.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide the proper tools for being on call. For example, when a response time
    of 30 minutes or less is expected, provide those on call with a backpack with
    a laptop, phone, and means to connect to the internet.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that every employee is not on call at least 75% of the time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow employees to take time off in lieu so that they can be late for work if
    they had to respond to an alert overnight.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After every disturbance of the normal operation of a system, whether this is
    during business hours or after, a live site incident review can be performed to
    learn what happened and how to reduce the chance of it happening again.
  prefs: []
  type: TYPE_NORMAL
- en: Live site reviews
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After an alert is triggered and the team has responded and remediated the situation,
    it is time to evaluate what happened. This is called a live site incident review.
    Here, the whole team gathers to address the following:'
  prefs: []
  type: TYPE_NORMAL
- en: What happened – to start, a timeline should be constructed from the time the
    incident was discovered to the point that normal operations were restored. Next,
    the timeline is expanded with the events that led to the situation that triggered
    the incident.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, the series of events is evaluated to learn what worked well in the response.
    If one member of the team used a new tool to quickly diagnose a problem, this
    can benefit other members of the team as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only then is it time to look at the possible points of improvement and translate
    these points into high-priority work for the team. Possible fail-safes are identified
    and scheduled for implementation or new alerts are identified that send an alert
    before a similar problem occurs again.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The alert or group of alerts that triggered the initial response is evaluated
    to determine whether they are adequate or possibly contain duplicates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The best time for a live site incident review is as soon after the incident
    itself as possible. In practice, this means giving everyone enough time to rest
    and recuperate and plan a meeting for the next business day.
  prefs: []
  type: TYPE_NORMAL
- en: This completes our overview of Application Insights and the Azure Monitor capabilities
    for instrumenting web applications. The following section describes several approaches
    for integrating Application Insights and Azure Monitor with other tools.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with other tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Monitor and Application Insights are excellent tools for gathering application
    logs and metrics, as well as storing them and making them searchable. However,
    there could be reasons why development teams or businesses prefer to work with
    other tools to visualize application performance or respond to alerts. One important
    driver for integration is often the primary tool used by a person or team. If
    a team operates mainly in ServiceNow or Grafana, it is often useful to integrate
    these with Azure Monitor instead of forcing these teams to work with multiple
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: Many possible integrations exist; some examples are detailed in the following
    subsections.
  prefs: []
  type: TYPE_NORMAL
- en: IT service management applications
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Action groups were introduced in the previous section where we looked at instrumenting
    web applications. Action groups are groups of actions to be performed in response
    to an alert.
  prefs: []
  type: TYPE_NORMAL
- en: Next to the rich built-in capabilities, it is also possible to automatically
    raise an alert in an existing **IT Service Management** (**ITSM**) solution. If
    there is already an ITSM solution in place within a company, it makes sense not
    to create a separate alerting channel using Azure Monitor. Instead, using an ITSM
    connector from Azure Monitor allows you to manage all the company-wide alerts
    from one solution.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, there are integrations available with ServiceNow, Provance, System
    Center Service Manager, and more. These connections are created through the ITSM
    connector.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Boards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In many development teams, Azure DevOps is the tool that developers spend most
    of their time with. This is also where they perform their backlog management using
    Azure Boards.
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, operators (and hopefully, developers, too) perform investigative
    work in Application Insights to determine the cause of user errors and to drill
    down into the reasons for failure. This investigative work could result in new
    work that needs to be backlogged in Azure DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: 'To facilitate this, integration between Application Insights and Azure DevOps
    can be configured from Application Insights by taking the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the **Work Items** option on the left-hand side menu (**1**). This
    opens the view shown on the left in the following screenshot. Here, a connection
    to Azure Boards can be configured:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.13 – Application Insights – Work Item integration ](img/B18655_12_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.13 – Application Insights – Work Item integration
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure the connection, the following details need to be filled out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the Azure DevOps link. Here, the name of the organization needs to be
    appended.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Select the Azure DevOps project to use. This can be selected from the dropdown.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Select a product area where new items will be created. By default, this is the
    same as the name of the project, unless you change it.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide the name of a user as the default owner of new work items.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: After configuring this connection, a new **+ Create work item** button is visible
    on the relevant pages in Application Insights. This button allows you to create
    a bug with all the relevant information directly on the backlog.
  prefs: []
  type: TYPE_NORMAL
- en: Grafana
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Azure Monitor allows you to build simple, easy-to-use dashboards. The advantage
    of using Azure Monitor dashboards is that they integrate perfectly with all the
    other Azure practices, such as **Role-Based Access Control** (**RBAC**) and Azure
    Resource Manager templates.
  prefs: []
  type: TYPE_NORMAL
- en: However, teams may have already adopted other tools for visualization, such
    as Grafana. Grafana is a well-known platform that works well with operational
    dashboards. Grafana can be configured to connect using Azure Monitor and can query
    metrics for graphing. Grafana also has alerting capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'To connect Grafana to Azure Monitor, the following steps need to be taken:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new app registration in the Azure Active Directory account that is
    used by your Azure subscription. Take note of the **Tenant ID**, **Client ID**,
    **Subscription ID**, and **Client Secret** properties of this app registration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new RBAC role assignment for the app registration, with at least the
    **Reader** permissions set on the resources to monitor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure a new data source in Grafana of the **Azure Monitor** type. Insert
    the properties collected in *step 1* for authenticating to Azure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new graph to the dashboard, selecting **Azure Monitor** as a data source.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By taking the preceding steps, a Grafana-to-Azure Monitor connection can be
    set up within a matter of minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to start completing the DevOps loop. You also
    learned how to work with crash reports and gather them from all types of applications,
    as well as how to instrument web applications. You now know how to use Application
    Insights to centralize logs and metrics and to get insight into requests and dependency
    calls. You also learned how you can integrate Azure Monitor with other tools to
    further streamline your development processes.
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, you can now start learning about how your applications
    operate in production. By doing so, you can not only deliver your software faster
    but also learn from its usage and start improving from there.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about gathering user feedback to complement
    what you have learned from your system logs and metrics. You will also learn how
    to measure end user satisfaction with your application and new features.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter’s material. You will find the answers in the *Assessments*
    section of the *Appendix*:'
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to capture custom metrics from the Azure platform offerings using
    Application Insights – true or false?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How long are platform metrics retained for in Azure Monitor?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is possible to capture custom metrics from your own application code using
    Application Insights – true or false?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What do you call a situation where engineers start ignoring alerts as they are
    worn down by too many of them?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is possible to call a Webhook when an alert fires in Azure – true or false?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More information about the App Center SDK can be found at [https://docs.microsoft.com/en-us/appcenter/sdk/](https://docs.microsoft.com/en-us/appcenter/sdk/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Monitor-supported metrics by resource type: [https://docs.microsoft.com/en-us/azure/azure-monitor/essentials/metrics-supported](https://docs.microsoft.com/en-us/azure/azure-monitor/essentials/metrics-supported).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information on Raygun can be found at [https://raygun.com](https://raygun.com).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More detailed information on configuring Application Insights is available at
    [https://docs.microsoft.com/en-us/azure/azure-monitor/app/app-insights-overview](https://docs.microsoft.com/en-us/azure/azure-monitor/app/app-insights-overview).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The KQL reference page can be found at [https://docs.microsoft.com/en-us/sharepoint/dev/general-development/keyword-query-language-kql-syntax-reference](https://docs.microsoft.com/en-us/sharepoint/dev/general-development/keyword-query-language-kql-syntax-reference).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
