- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Source Code Management with Git and GitOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at the core concepts of modern DevOps, had
    an introduction to the cloud, and got a fair understanding of containers. In this
    chapter, we will understand source code management and one of the modern ways
    of enabling DevOps with **GitOps**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is source code management?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A crash course on Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is GitOps?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The principles of GitOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why GitOps?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Branching strategies and GitOps workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git versus GitOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow this chapter, you will need access to a Linux-based command line.
    If you are using macOS, you can use the inbuilt Terminal for all tasks. If you’re
    a Windows user, you must install **GitBash** from [https://git-scm.com/download/win](https://git-scm.com/download/win).
    We will cover the installation instructions for this in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s start by understanding source code management.
  prefs: []
  type: TYPE_NORMAL
- en: What is source code management?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Software development involves writing code. Code is the only tangible aspect
    of the software, allowing the software to function. Therefore, you need to store
    code somewhere to write and make changes to existing software. There are two kinds
    of code – **source code**, which is written in a high-level language, and **binaries**,
    which are compiled from the source code. Generally, binaries are nothing but functional
    applications that execute when we run the software, and source code is the human-readable
    code written to generate the binary, which is why source code is named as such.
  prefs: []
  type: TYPE_NORMAL
- en: A software development team has multiple members writing software features,
    so they must collaborate on code. They cannot just write code on silos without
    understanding how the application works. Sometimes, more than one developer works
    on the same feature, so they need some place to share their code with their peers.
    Source code is an asset in itself; therefore, we want to store it securely in
    a central location while still readily providing access to developers without
    hampering their work. You will also want to track changes and version them as
    you might want to know what caused a problem and immediately roll them back. You
    will also need to persist the history of code to understand what changes were
    made by whom, and you will want to have a mechanism for source code peer reviews.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, you would want to manage multiple aspects of source code, and
    therefore you would use a source code management tool to do so.
  prefs: []
  type: TYPE_NORMAL
- en: A source code management tool helps you manage all aspects of source code. It
    provides a central location to store your code, version changes and allows multiple
    developers to collaborate on the same source code. It also keeps a record of all
    changes through a version history and everything else that we’ve talked about
    before. Effective source code management practices improve collaboration; enable
    efficient development workflows; provide version control, repository management,
    branching and merging, change tracking, and auditing; and enhance the overall
    quality and maintainability of software projects. Some popular SCM tools are **Git**,
    **Subversion**, **Mercurial**, and **CVS**. However, the most popular and de facto
    standard for SCM is Git. So, let's go ahead and learn about it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: A crash course on Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git is the most popular source code management system available these days,
    and it has now become mandatory for all developers to learn Git, at least the
    basic stuff. In this crash course, we will learn about all basic Git operations
    and build from them in the subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Git is a distributed version control system. This means that every Git repository
    is a copy of the original, and you can replicate that to a remote location if
    needed. In this chapter, we will create and initialize a local Git repository
    and then push the entire repository to a remote location.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Git repository in a remote central location is also known as a **remote repository**.
    From this central repository, all developers sync changes in their local repository,
    similar to what’s shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Git distributed repository model](img/B19877_Figure_2.01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Git distributed repository model
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s install Git locally and initialize a local repository. We will
    look at a remote repository later.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Git
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Depending on your platform and workstation, there are different ways to install
    Git. To install Git on **Ubuntu**, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For other OSs and platforms, you can follow the steps at the following link:
    https://git-scm.com/book/en/v2/Getting-Started-Installing-Git.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To check if Git has been installed successfully, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s initialize our first Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing your first Git repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a Git repository, you need to create a directory and run the `git
    init` command, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You are now ready to use your Git repository. You can also see that when you
    initialized the Git repository, Git created a hidden directory, `.git`, which
    it uses to keep track of all changes and commits. Whatever changes you make in
    your repo, Git keeps them as a delta of changes, which it depicts using `+` and
    `-` signs. We will look at these in detail in the subsequent sections. For now,
    let’s create a new file within our Git repository and stage it for changes.
  prefs: []
  type: TYPE_NORMAL
- en: Staging code changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Git allows developers to stage their changes before they commit them. This helps
    you prepare what you want to commit to the repository. The staging area is a temporary
    holding area for your changes, and you can add and remove files from the staging
    area by using the `git add` and `git` `restore` commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create our first file within the local Git repository and stage the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can create a blank file in the `first-git-repo` directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will check if Git can detect the new file that we’ve created. To do
    so, we need to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'So, as we can see, Git has detected `file1` and is telling us that it is not
    tracking the file currently. To allow Git to track the file, let’s run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s run `git status` again to see what has changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, Git now shows `file1` as a new file in the staging area. You
    can continue making changes, and when you are done, you can commit the changes
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Git has now recorded a commit with your changes. Now, let’s look at its status
    again using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Git is now reporting that the working tree is clean, and there is nothing to
    commit. It also shows that there are no untracked files. Now, let’s change `file1`
    and add some text to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '`file1` now contains the first line. Let’s go ahead and commit this change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, Git is now reporting that one file has changed, and there is
    one insertion. Remember when we discussed that Git only tracks the delta changes
    between commits? That is what is happening here.
  prefs: []
  type: TYPE_NORMAL
- en: In the introduction, we mentioned that Git provides a history of all commits.
    Let’s look at how we can display this history.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying commit history
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Git keeps a history of all commits. To see a list of all commits that you’ve
    done, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, Git has displayed the history of both our commits. Notice that
    Git marks every commit with a commit ID. We can also delve into what changes were
    made in the commit by using the `git diff <first_commit_id> <second_commit_id>`
    command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The output clearly shows that the second commit has added `This is first line`
    within `file1`.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve suddenly realized that you needed to add another line to `file1` and
    wanted to do so in the same commit. We can do this by amending the commit. We’ll
    look at this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Amending the last commit
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is a best practice to have a single commit for your changes to a particular
    feature. This helps you track the changes better and makes it easier for the reviewer
    to review them. In turn, it is cleaner to visualize and manage. However, committing
    frequently is also a best practice so that your changes are not lost. Fortunately,
    Git allows you to add changes to the last commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate this, let’s change `file1` and add another line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s add the changes to the previous commit using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you run this command, Git will show you a prompt, allowing you to amend
    the commit message if you like. It will look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this file (use `ESC:wq` for Vim). This should amend the last commit with
    the changes. You should get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'When Git amends a commit, you can no longer refer to the previous commit with
    the same commit ID. Instead, Git generates a separate `SHA-1 id` for the amended
    commit. So, let’s look at the logs to see this for ourselves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s run the `diff` command again and see what it is reporting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The output clearly shows that the second commit has added `This is first line`,
    as well as `This is second line`, within `file1`. With that, you’ve successfully
    amended a commit.
  prefs: []
  type: TYPE_NORMAL
- en: Local repositories are as good as keeping files on your system. However, since
    you need to share your code with others and keep it secure from laptop OS crashes,
    theft, physical damage, and more, you need to push your code into a remote repository.
    We’ll look at remote repositories in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding remote repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Remote repositories** are replicas of the Git repository at a central location
    for multiple people to access. This allows your developers to work on the same
    code base simultaneously and provides you with a backup of your code. There are
    various tools you can use to host your remote repositories. Notable ones include
    **GitHub**, **Bitbucket**, and **Gerrit**. You can install them on your on-premises
    or cloud servers or use a **Software-as-a-Service** (**SaaS**) platform to store
    them online. In this book, we are going to focus on GitHub.'
  prefs: []
  type: TYPE_NORMAL
- en: GitHub is a web-based platform that helps developers collaborate on code. It
    is based on Git and allows you to host remote Git repositories. It was founded
    in 2008 and was acquired by Microsoft in 2018\. It is one of the most popular
    open-source SaaS-based Git repository services and contains almost all open-source
    code available worldwide.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can create our first remote repo, we must go to [https://github.com/signup](https://github.com/signup)
    to create an account.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve created an account, we can go ahead and create our first remote
    Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a remote Git repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a remote Git repository is simple on GitHub. Go to [https://github.com/new](https://github.com/new),
    set `first-git-repo`, keep the rest of the fields as-is, and click the **Create**
    **Repository** button.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve done that, GitHub will provide you with some steps that you can
    follow to connect with your remote repository. Before we go into any of that,
    we want to configure some authentication for our local Git command line to interact
    with the remote repository. Let’s take a look.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up authentication with the remote Git repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some of the ways you can authenticate with your remote Git repository are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HTTPS**: In this mode, Git uses HTTPS to connect with the remote Git repository.
    We need to create an HTTPS token within our GitHub account and use this token
    as a password to authenticate with the remote repository. This process requires
    you to key in your token every time you authenticate with Git; therefore, it is
    not a convenient option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SSH**: In this mode, Git uses the SSH protocol to connect with the remote
    Git repository. While using SSH, we do not need to use a password to authenticate;
    instead, we must add the **public key** of an **SSH key pair** we can generate
    from the Linux (or Windows if you’re using Git Bash) command line to the GitHub
    account. This process is more secure as well as convenient.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let’s set up SSH-based authentication with our remote Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we must generate the SSH key pair within our local system. Go to your
    Terminal and run the following command to generate an SSH key pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You will be prompted for other details. Keep pressing *Enter* until you reach
    the prompt again.
  prefs: []
  type: TYPE_NORMAL
- en: Once the key pair has been generated, copy the public key present in the `~/.``ssh/id_rsa.pub`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Then, go to [https://github.com/settings/ssh/new](https://github.com/settings/ssh/new),
    paste the public key in the **Key** field, and click the **Add SSH Key** button.
    We are now ready to connect with the remote Git repository. Now, let’s look at
    the configurations we must do on our local repository to connect with the remote
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the local repository to the remote repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need to add a remote entry using the following command to connect
    with the remote repository from the local repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You can also find these details on the **Quick Setup** page of your GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve set up the connection, let’s look at how we can push our changes
    to the remote repository.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing changes from the local repository to the remote repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To push the changes from the local repository to the remote repository, use
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, refresh the page on your remote repository. You should see that the code
    was synced, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Code synced in the remote repository](img/B19877_Figure_2.02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Code synced in the remote repository
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the inline editor to make further changes to the file using
    the GitHub web portal. While this is not recommended, we’ll do this to simulate
    a situation where another developer changed the same file you were working on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on **file1** and then click on the **pencil** icon to edit the file,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Editing the file in the remote repository](img/B19877_Figure_2.03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Editing the file in the remote repository
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon doing this, an editing window will open where you can make changes to
    the file. Let’s add `This is third line` within the file, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Adding a new line](img/B19877_Figure_2.04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Adding a new line
  prefs: []
  type: TYPE_NORMAL
- en: 'Scroll down – you should see a **Commit changes** section, where you can add
    a commit message field and click on the **Commit** button, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – The Commit changes section](img/B19877_Figure_2.05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – The Commit changes section
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve clicked on that button, you should see the third line, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Changes committed remotely](img/B19877_Figure_2.06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – Changes committed remotely
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, changes have been made to the remote repository, but you have
    also been working on your changes. To simulate this, let’s make a change in the
    local repository as well using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we’ve committed the changes in our local repository, let’s try to
    push the code to the remote repository using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Wait, what happened? Well, the remote repository rejected the changes as we
    tried to push changes while someone else made some commits in the remote repository,
    and our changes are not current. We would need to pull the changes in our local
    repository first to apply our changes on top of the existing ones in the remote
    repository. We’ll look at this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Pulling and rebasing your code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Pulling code** involves downloading up-to-date code from the remote to your
    local repository. **Rebasing** means applying your changes on top of the latest
    remote commit. It is a best practice to pull and rebase your changes on top of
    what already exists in the remote repository.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do so using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have another issue: we are unable to rebase our commit as we’ve tried
    to modify a file that has been modified by someone else. Git wants us to check
    the file and make appropriate changes so that the changes are applied correctly.
    This situation is known as a **merge conflict**. Git also provides us with the
    file that contains the conflict. Let’s open the file with a text editor and make
    the appropriate changes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The current file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The portion depicted by `HEAD` is the line in the remote repository and shows
    the recent changes made remotely. The `e411e91` commit shows the changes that
    we made locally. Let’s change the file to the following and save it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s add the file to the staging area and continue the rebase using the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we’ve rebased the changes, let’s look at the status of the Git repo
    by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, we’ve added a single commit that we need to push to the remote
    repository. Let’s do that now using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: And this time, the push worked successfully.
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, you would normally need to take a copy of the main code and make
    changes to it to test new features. You might also want someone to review your
    changes before they are merged into the main code base. Git allows you to manage
    that by using Git branches. We’ll look at Git branches in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Git branches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **Git branch** is a copy of the code base (from where the branch is created)
    that you can independently modify and work on without affecting the main code
    base. You will want to create branches while working on new features to ensure
    that you are not affecting the main branch, which contains reviewed code. Most
    technology companies normally have several environments where you have code deployed
    in various stages. For example, you might have a **development environment** where
    you test your features, a **staging environment** where you integrate all features
    and test the complete application, and a **production environment** where the
    application that your end users access resides. So, there would be a possibility
    that you might have additional environment-specific branches where code deployed
    on those branches reside. In the following sections of this chapter, we will talk
    about GitOps, which works on this fundamental principle. For now, let’s look at
    how we can create and manage Git branches.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and managing Git branches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a Git branch, you must be on the branch from where you want to branch
    your code. As in our example repo, we were working on the master branch. Let’s
    stay there and create a feature branch out of that.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the branch, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the feature branch has been created. To check what branch we
    are on now, we can use the `git branch` command. Let’s do that now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And as we see by the `*` sign over the `master` branch, we are still on the
    `master` branch. The good thing is that it also shows the `feature/feature1` branch
    in the list. Let’s switch to the feature branch now by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are on the `feature/feature1` branch. Let’s make some changes to the
    `feature/feature1` branch and commit it to the local repo:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the code is now committed to the `feature/feature1` branch.
    To check the version history, let’s run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the `Feature 1` commit is shown in the Git logs. Now, let’s
    switch to the `master` branch and run the same command again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see here, the `Feature 1` commit changes are absent. This shows that
    both branches are now isolated (and have now diverged). Now, the changes are locally
    present and are not in the remote repository yet. To push the changes to the remote
    repository, we will switch to the `feature/feature1` branch again. Let’s do that
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we’ve switched to the feature branch, let’s push the branch to the
    remote repository using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: With that, we’ve successfully pushed the new branch to the remote repository.
    Assuming the feature is ready, we want the changes to go into the master branch.
    For that, we would have to raise a pull request. We’ll look at pull requests in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Working with pull requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A `master`. Pull requests are generally useful for developers to get their
    code peer reviewed before they merge it with the *fair* version of the code. The
    reviewer generally checks the quality of the code, whether best practices are
    being followed, and whether coding standards are appropriate. If the reviewer
    is unhappy, they might want to flag certain sections of the changes and request
    modifications. There are normally multiple cycles of reviews, changes, and re-reviews.
    Once the reviewer is happy with the changes, they can approve the pull request,
    and the requester can merge the code. Let’s take a look at this process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try to raise a pull request for merging our code from the `feature/feature1`
    branch to the `master` branch. To do so, go to your GitHub repo, select **Pull
    requests**, and click on the **New pull request** button, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.7 – New pull request](img/B19877_Figure_2.07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – New pull request
  prefs: []
  type: TYPE_NORMAL
- en: 'Keep `master` and, in the `feature/feature1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Comparing changes](img/B19877_Figure_2.08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – Comparing changes
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, it shows you all the changes we’ve made on the `feature/feature1`
    branch. Click on the **Create pull request** button to create the pull request.
    On the next page, stick to the defaults and click on the **Create pull** **request**
    button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Pull request created](img/B19877_Figure_2.09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – Pull request created
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the pull request was created successfully. Here, you can assign
    a reviewer and get the code reviewed. Once the reviewer approves the code, you
    can merge the code to the master branch. For now, let’s click on the **Merge pull
    request** button, followed by the **Confirm merge** button, which should merge
    the pull request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, check if the `master` branch shows the changes within GitHub. If it does,
    switch to the `master` branch and pull the changes into your local repository.
    You should see the changes in your local repository as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: I leave this to you as an exercise.
  prefs: []
  type: TYPE_NORMAL
- en: This was a crash course on Git to help you get started. Now, let’s move on and
    understand GitOps, which uses Git as a single source of truth to spin up virtually
    anything within your application and infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: What is GitOps?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitOps is a method that involves implementing DevOps so that Git forms the single
    source of truth. Instead of maintaining a long list of scripts and tooling to
    support this, GitOps focuses on writing declarative code for everything, including
    the infrastructure, configuration, and application code. This means you can spin
    anything out of thin air by simply using the Git repository. The idea is that
    you declare what you need in your Git repository, and there is tooling behind
    the scenes that ensures the desired state is always maintained in the running
    application and infrastructure surrounding it. The code to spin up the tooling
    also resides in Git, and you don’t have anything outside of Git. This means everything,
    including the tooling, is automated in this process.
  prefs: []
  type: TYPE_NORMAL
- en: While GitOps also enables DevOps within the organization, it primarily focuses
    on using Git to manage infrastructure provisioning and application software deployments.
    DevOps is a broad term that contains a set of principles, processes, and tools
    to enable developers and operations teams to work seamlessly and shorten the development
    life cycle, with an end goal to deliver better software more quickly using a CI/CD
    cycle. While GitOps relies heavily on Git and its features and always looks to
    Git for versioning, finding configuration drift, and only applying deltas, DevOps
    is, as such, agnostic of any tool and focuses more on the concepts and processes.
    Therefore, you can implement DevOps without using Git, but you cannot implement
    GitOps without Git. Put simply, GitOps implements DevOps, but the reverse may
    not always be true.
  prefs: []
  type: TYPE_NORMAL
- en: Why GitOps?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GitOps provides us with the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**It deploys better software more quickly**: GitOps offers simplicity in delivering
    software. You don’t have to worry about what tool you need for the deployment
    type. Instead, you can commit your changes in Git, and the behind-the-scenes tooling
    automatically deploys it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git revert` and restore your environment. The idea is that you don’t need
    to learn anything else apart from Git to do a rollout or a rollback.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It offers better credential management**: With GitOps, you don’t need to
    store your credentials in different places for your deployments to work. You simply
    need to provide the tooling access to your Git repository and the binary repository,
    and GitOps will take care of the rest. You can keep your environment completely
    secure by restricting your developers’ access to it and providing them access
    to Git instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployments are self-documenting**: Because everything is kept within Git,
    which records all commits, the deployments are automatically self-documenting.
    You can know exactly who deployed what at what time by simply looking at the commit
    history.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It promotes shared ownership and knowledge**: As Git forms the single source
    of truth for all code and configurations within the organization, teams have a
    single place to understand how things are implemented without ambiguity and dependency
    on other team members. This helps promote the shared ownership of the code and
    knowledge within the team.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know about the benefits of GitOps, let’s look at its key principles.
  prefs: []
  type: TYPE_NORMAL
- en: The principles of GitOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GitOps has the following key principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**It describes the entire system declaratively**: Having declarative code forms
    the first principle of GitOps. This means that instead of providing instructions
    on how to build your infrastructure, applying the relevant configuration, and
    deploying your application, you declare the end state of what you need. This means
    that your Git repository always maintains a single source of truth. As declarative
    changes are idempotent, you don’t need to worry about the state of your system
    as this will eventually become consistent with the code in Git.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It versions desired system state using Git**: As Git forms an excellent version
    control system, you don’t need to worry too much about how to roll out and roll
    back your deployments. A simple Git commit means a new deployment, and a Git revert
    means a rollback. This means you do not need to worry about anything apart from
    ensuring that the Git repository reflects what you need.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It uses tooling to automatically apply approved changes**: As you’ve stored
    everything within Git, you can then use tooling that looks for changes within
    the repository and automatically applies them to your environment. You can also
    have several branches that apply changes to different environments, along with
    a pull request-based approval and gating process so that only approved changes
    end up in your environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It uses self-healing agents to alert and correct any divergence**: We have
    the tooling to automatically apply any changes in Git to the environment. However,
    we also require self-healing agents to alert us of any divergence from the repository.
    For example, suppose someone deletes a container manually from the environment
    but doesn’t remove it from the Git repository. In that scenario, the agent should
    alert the team and recreate the container to correct the divergence. This means
    there is no way to bypass GitOps, and Git remains the single source of truth.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing and living by these principles is simple with modern DevOps tools
    and techniques, and we will look at practically implementing them later in *Chapters
    11* and *12*. In this chapter, however, we’ll examine their design principles
    using a branching strategy and GitOps workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Branching strategies and the GitOps workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GitOps requires at least two kinds of Git repositories to function: the **application
    repository**, which is from where your builds are triggered, and the **environment
    repository**, which contains all of the infrastructure and **configuration as
    code** (**CaC**). All deployments are driven from the environment repository,
    and the changes to the code repository drive the deployments. GitOps follows two
    primary kinds of deployment models: the **push model** and the **pull model**.
    Let’s discuss each of them.'
  prefs: []
  type: TYPE_NORMAL
- en: The push model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The push model pushes any changes that occur within your Git repository to
    the environment. The following diagram explains this process in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – The push model](img/B19877_Figure_2.010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – The push model
  prefs: []
  type: TYPE_NORMAL
- en: The push model is inherently unaware of the existing configuration and reacts
    only to changes made to your Git repositories. Therefore, you will need to set
    up some form of monitoring to understand whether there are any deviations. Additionally,
    the push model needs to store all environment credentials within the tools. This
    is because it interacts with the environment and has to manage the deployments.
    Typically, we use **Jenkins**, **CircleCI**, or **Travis CI** to implement the
    push model. While the push model is not recommended, it becomes inevitable in
    cloud provisioning with **Terraform**, or config management with **Ansible**,
    as they are both push-based models. Now, let’s take a closer look at the pull
    model.
  prefs: []
  type: TYPE_NORMAL
- en: The pull model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The pull model is an *agent-based deployment model* (also known as an *operator-based
    deployment model*). An *agent* (or *operator*) within your environment monitors
    the Git repository for changes and applies them as and when needed. The operator
    constantly compares the existing configuration with the configuration in the environment
    repository and applies changes if required. The following diagram shows this process
    in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – The pull model](img/B19877_Figure_2.011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – The pull model
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of the pull model is that it monitors and reacts to environment
    changes alongside repository changes. This ensures that any changes that do not
    match the Git repository are reverted from the environment. It also alerts the
    operations team about anything it could not fix using mail notifications, ticketing
    tools, or Slack notifications. Because the operator lives within the same environment
    where the code is deployed, we do not need to store credentials within the tools.
    Instead, they live securely within the environment. You can also live without
    storing any credentials at all with tools such as Kubernetes, where you can employ
    **role-based access control** (**RBAC**) and service accounts for the operator
    managing the environment.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: When choosing a GitOps model, the best practice is to check whether you can
    implement a pull-based model instead of a push-based model. Implement a push-based
    model only if a pull-based model is not possible. It is also a good idea to implement
    polling in the push-based model by scheduling something, such as a `cron` job,
    that will run the push periodically to ensure there is no configuration drift.
  prefs: []
  type: TYPE_NORMAL
- en: We cannot solely live with one model or the other, so most organizations employ
    a **hybrid model** to run GitOps. This hybrid model combines push and pull models
    and focuses on using the pull model. It uses the push model when it cannot use
    the pull model. Now, let’s understand how to structure our Git repository so that
    it can implement GitOps.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring the Git repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement GitOps, we require at least two repositories: the **application
    repository and the environment repository**. This does not mean that you cannot
    combine the two, but for the sake of simplicity, let’s take a look at each of
    them separately.'
  prefs: []
  type: TYPE_NORMAL
- en: The application repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The application repository stores the application code. It is a repository in
    which your developers can actively develop the product that you run for your business.
    Typically, your builds result from this application code, and they end up as containers
    (if we use a container-based approach). Your application repository may or may
    not have environment-specific branches. Most organizations keep the application
    repository independent of the environment and focus on building semantic code
    versions using a branching strategy. Now, there are multiple branching strategies
    available to manage your code, such as **Gitflow**, **GitHub flow**, and any other
    branching strategy that suits your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Gitflow is one of the most popular branching strategies that organizations
    use. That said, it is also one of the most complicated ones as it requires several
    kinds of branches (for instance, master, hotfixes, release branches, develop,
    and feature branches) and has a rigid structure. The structure of Gitflow is shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – Gitflow structure](img/B19877_Figure_2.012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – Gitflow structure
  prefs: []
  type: TYPE_NORMAL
- en: 'A simplified way of doing things is using GitHub flow. It employs fewer branches
    and is easier to maintain. Typically, it contains a single master branch and many
    feature branches that eventually merge with the master branch. The master branch
    always has software that is ready to be deployed to the environments. You tag
    and version the code in the master branch, pick and deploy it, test it, and then
    promote it to higher environments. The following diagram shows GitHub flow in
    detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13 – GitHub flow](img/B19877_Figure_2.013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 – GitHub flow
  prefs: []
  type: TYPE_NORMAL
- en: Note that you are free to create your branching strategy according to your needs
    and what works for you.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Choose Gitflow if you have a large team, a vast monolithic repository, and multiple
    releases running in parallel. Choose GitHub flow if you work for a fast-paced
    organization that releases updates several times a week and doesn’t use the concept
    of parallel releases. GitHub flow also typically works for microservices where
    changes are minor and quick.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, application repositories do not have to worry too much about environments;
    they can focus more on creating deployable software versions.
  prefs: []
  type: TYPE_NORMAL
- en: The environment repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The environment repository stores the environment-specific configurations needed
    to run the application code. Therefore, they will typically have **Infrastructure
    as Code** (**IaC**) in the form of Terraform scripts, CaC in the form of Ansible
    playbooks, or Kubernetes manifests that typically help deploy the code we’ve built
    from the application repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The environment repository should follow an environment-specific branching
    strategy where a branch represents a particular environment. You can have pull
    request-based **gating** for these kinds of scenarios. Typically, you build your
    **development environments** from a development branch and then raise a pull request
    to merge the changes to a staging branch. From the staging branch to production,
    your code progresses with environments. If you have 10 environments, you might
    end up with 10 different branches in the environment repository. The following
    diagram showcases the branching strategy you might want to follow for your environment
    repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14 – The environment repository](img/B19877_Figure_2.014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.14 – The environment repository
  prefs: []
  type: TYPE_NORMAL
- en: The environment repository aims to act as the single source of truth for your
    environments. The configuration you add to the repository is applied directly
    to your environments.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: While you can combine the environment and application repository into one, the
    best practice is to keep them separate. GitOps offers a clear separation between
    the CI and CD processes using the application and environment repositories, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve covered Git and GitOps in detail, let’s look at why Git and GitOps
    are related but different concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Git versus GitOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table summarizes the differences between Git and GitOps:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Git** | **GitOps** |'
  prefs: []
  type: TYPE_TB
- en: '| Definition | Git is a distributed version control system that tracks changes
    to source code and other files. It allows multiple developers to collaborate and
    manage code revisions efficiently. | GitOps is a set of practices and principles
    that leverage Git as the single source of truth for managing and automating the
    deployment and operation of infrastructure and applications. |'
  prefs: []
  type: TYPE_TB
- en: '| Focus | Primarily focused on version control and collaboration for source
    code. | Focused on automating and managing the deployment and operation of infrastructure
    and applications through Git-based DevOps workflows. |'
  prefs: []
  type: TYPE_TB
- en: '| Usage | Widely used for version control and collaboration in software development
    projects. Developers use Git to track changes, manage branches, and merge code.
    | Used for declaratively defining and managing infrastructure and application
    configurations. Git repositories serve as a central hub for defining desired states
    and driving automation. |'
  prefs: []
  type: TYPE_TB
- en: '| Core Components | Repositories, branches, commits, and pull requests. | Git
    repositories, declarative configuration files (such as YAML), Kubernetes manifests,
    CI/CD pipelines, and deployment tools such as Argo CD or Flux. |'
  prefs: []
  type: TYPE_TB
- en: '| Workflow | Developers clone, modify, commit, and push changes to a remote
    repository. They collaborate through pull requests and branch merges. | Infrastructure
    and application configurations are stored in Git repositories. Changes to these
    configurations trigger automated processes, such as CI/CD pipelines or reconciliation
    loops, to apply those changes to the target environment. |'
  prefs: []
  type: TYPE_TB
- en: '| Benefits | Enables efficient version control, collaboration, and code management
    for software development teams. | Promotes infrastructure and application as code,
    versioning of configurations, and declarative management. It simplifies infrastructure
    deployment, provides consistency, and enables automated workflows. |'
  prefs: []
  type: TYPE_TB
- en: '| Focus Area | Source code management. | Infrastructure and application deployment
    and management. |'
  prefs: []
  type: TYPE_TB
- en: '| Examples | GitHub, Bitbucket, GitLab. | Argo CD, Flux, Jenkins X, Weave Flux.
    |'
  prefs: []
  type: TYPE_TB
- en: Remember that while Git is a version control system, GitOps extends this concept
    by utilizing Git as a central source of truth for infrastructure and application
    configurations, allowing for automated deployment and management of DevOps workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered Git, GitOps, why we need it, its principles, and various
    GitOps deployments. We also looked at different kinds of repositories that we
    can create to implement GitOps, along with the branching strategy choices for
    each of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand what source code management is and how it is necessary for many activities
    with modern DevOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a Git repository and play around with the `clone`, `add`, `commit`, `push`,
    `pull`, `branch`, and `checkout` commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand what GitOps is and how it fits the modern DevOps context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand why we need GitOps and how it achieves modern DevOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the salient principles of GitOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how to use an effective branching strategy to implement GitOps based
    on the org structure and product type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will develop a core understanding of containers and
    look at Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following is true about Git? (Choose three)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is a distributed SCM platform
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It is a centralized SCM platform
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It allows multiple developers to collaborate
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It has commits and branches
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In Git terms, what does Git checkout mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sync code from remote to local
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch from one branch to another
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Review and approve a pull request
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In GitOps, what forms a single source of truth
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Git repository
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The configuration stored in a datastore
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The secret management system
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The artifact repository
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following options are deployment models for GitOps? (Choose two)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The push model
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The pull model
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The staggering model
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Should you use Gitflow for your environment repository?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For monolithic applications with multiple parallel developments in numerous
    releases, what is the most suitable Git branching strategy?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Gitflow
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: GitHub flow
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Hybrid GitHub flow
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which is the recommended deployment model for GitOps?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The push model
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The pull model
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The staggering model
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A,C,D
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A,B
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'No'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
