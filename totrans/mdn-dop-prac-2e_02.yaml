- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Source Code Management with Git and GitOps
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Git 和 GitOps 进行源代码管理
- en: In the previous chapter, we looked at the core concepts of modern DevOps, had
    an introduction to the cloud, and got a fair understanding of containers. In this
    chapter, we will understand source code management and one of the modern ways
    of enabling DevOps with **GitOps**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解了现代 DevOps 的核心概念，简要介绍了云计算，并对容器有了基本了解。在本章中，我们将了解源代码管理以及启用 DevOps 的现代方法之一——**GitOps**。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: What is source code management?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是源代码管理？
- en: A crash course on Git
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git 快速入门
- en: What is GitOps?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是 GitOps？
- en: The principles of GitOps
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitOps 的原则
- en: Why GitOps?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么选择 GitOps？
- en: Branching strategies and GitOps workflow
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分支策略和 GitOps 工作流
- en: Git versus GitOps
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Git 与 GitOps
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow this chapter, you will need access to a Linux-based command line.
    If you are using macOS, you can use the inbuilt Terminal for all tasks. If you’re
    a Windows user, you must install **GitBash** from [https://git-scm.com/download/win](https://git-scm.com/download/win).
    We will cover the installation instructions for this in the following sections.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本章内容，您需要访问基于 Linux 的命令行。如果您使用 macOS，可以使用内建的终端完成所有任务。如果您是 Windows 用户，则必须从[https://git-scm.com/download/win](https://git-scm.com/download/win)安装**GitBash**。我们将在接下来的章节中介绍安装说明。
- en: Now, let’s start by understanding source code management.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从了解源代码管理开始。
- en: What is source code management?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是源代码管理？
- en: Software development involves writing code. Code is the only tangible aspect
    of the software, allowing the software to function. Therefore, you need to store
    code somewhere to write and make changes to existing software. There are two kinds
    of code – **source code**, which is written in a high-level language, and **binaries**,
    which are compiled from the source code. Generally, binaries are nothing but functional
    applications that execute when we run the software, and source code is the human-readable
    code written to generate the binary, which is why source code is named as such.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发涉及编写代码。代码是软件的唯一有形部分，它使软件能够运行。因此，您需要将代码存储在某个地方，以便编写和修改现有软件。代码有两种类型——**源代码**，它是用高级语言编写的，以及**二进制文件**，它是从源代码编译而来的。通常，二进制文件只不过是执行软件时运行的功能性应用，而源代码是为了生成二进制文件而编写的人类可读的代码，这也是为什么源代码被称为源代码的原因。
- en: A software development team has multiple members writing software features,
    so they must collaborate on code. They cannot just write code on silos without
    understanding how the application works. Sometimes, more than one developer works
    on the same feature, so they need some place to share their code with their peers.
    Source code is an asset in itself; therefore, we want to store it securely in
    a central location while still readily providing access to developers without
    hampering their work. You will also want to track changes and version them as
    you might want to know what caused a problem and immediately roll them back. You
    will also need to persist the history of code to understand what changes were
    made by whom, and you will want to have a mechanism for source code peer reviews.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个软件开发团队有多个成员在编写软件功能，因此他们必须在代码上进行协作。他们不能单独编写代码而不理解应用程序如何工作。有时，多个开发人员会共同开发同一个功能，因此他们需要一个地方来与同伴共享代码。源代码本身是一种资产；因此，我们希望将其安全地存储在中央位置，同时仍然能够便捷地为开发人员提供访问权限，而不妨碍他们的工作。您还需要跟踪更改并对其进行版本控制，因为您可能想知道是什么导致了问题，并能够立即回滚。您还需要保存代码的历史记录，以便了解哪些更改是由谁进行的，并且您还希望有一个源代码同行评审的机制。
- en: As you can see, you would want to manage multiple aspects of source code, and
    therefore you would use a source code management tool to do so.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，您可能希望管理源代码的多个方面，因此您将使用源代码管理工具来实现这一目标。
- en: A source code management tool helps you manage all aspects of source code. It
    provides a central location to store your code, version changes and allows multiple
    developers to collaborate on the same source code. It also keeps a record of all
    changes through a version history and everything else that we’ve talked about
    before. Effective source code management practices improve collaboration; enable
    efficient development workflows; provide version control, repository management,
    branching and merging, change tracking, and auditing; and enhance the overall
    quality and maintainability of software projects. Some popular SCM tools are **Git**,
    **Subversion**, **Mercurial**, and **CVS**. However, the most popular and de facto
    standard for SCM is Git. So, let's go ahead and learn about it in the next section.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 源代码管理工具帮助您管理源代码的各个方面。它提供一个集中位置来存储代码、版本更改，并允许多个开发者在相同的源代码上进行协作。它还通过版本历史记录保存所有的更改，以及我们之前提到的其他内容。有效的源代码管理实践能够提高协作效率；促进开发工作流的高效性；提供版本控制、仓库管理、分支和合并、变更跟踪、审计等功能；并提高软件项目的整体质量和可维护性。一些流行的
    SCM 工具有 **Git**、**Subversion**、**Mercurial** 和 **CVS**。然而，最流行且事实上的 SCM 标准是 Git。所以，接下来我们来学习它。
- en: A crash course on Git
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Git 快速入门
- en: Git is the most popular source code management system available these days,
    and it has now become mandatory for all developers to learn Git, at least the
    basic stuff. In this crash course, we will learn about all basic Git operations
    and build from them in the subsequent chapters.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Git 是目前最流行的源代码管理系统，现如今所有开发者都必须学习 Git，至少要掌握基础内容。在本次快速入门中，我们将学习所有基本的 Git 操作，并在后续章节中进行拓展。
- en: Git is a distributed version control system. This means that every Git repository
    is a copy of the original, and you can replicate that to a remote location if
    needed. In this chapter, we will create and initialize a local Git repository
    and then push the entire repository to a remote location.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Git 是一个分布式版本控制系统。这意味着每个 Git 仓库都是原始仓库的副本，您可以在需要时将其复制到远程位置。在本章中，我们将创建并初始化一个本地
    Git 仓库，然后将整个仓库推送到远程位置。
- en: 'A Git repository in a remote central location is also known as a **remote repository**.
    From this central repository, all developers sync changes in their local repository,
    similar to what’s shown in the following diagram:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在远程中央位置的 Git 仓库也被称为 **远程仓库**。在这个中央仓库中，所有开发者将本地仓库的更改同步到远程仓库，类似于下图所示：
- en: '![Figure 2.1 – Git distributed repository model](img/B19877_Figure_2.01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.1 – Git 分布式仓库模型](img/B19877_Figure_2.01.jpg)'
- en: Figure 2.1 – Git distributed repository model
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.1 – Git 分布式仓库模型
- en: First, let’s install Git locally and initialize a local repository. We will
    look at a remote repository later.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们在本地安装 Git 并初始化一个本地仓库。稍后我们将查看远程仓库。
- en: Installing Git
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 Git
- en: 'Depending on your platform and workstation, there are different ways to install
    Git. To install Git on **Ubuntu**, run the following command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的平台和工作站的不同，安装 Git 的方式也不同。在 **Ubuntu** 上安装 Git，请运行以下命令：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For other OSs and platforms, you can follow the steps at the following link:
    https://git-scm.com/book/en/v2/Getting-Started-Installing-Git.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他操作系统和平台，您可以按照以下链接中的步骤操作：https://git-scm.com/book/en/v2/Getting-Started-Installing-Git。
- en: 'To check if Git has been installed successfully, run the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查 Git 是否安装成功，请运行以下命令：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, let’s initialize our first Git repository.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们初始化第一个 Git 仓库。
- en: Initializing your first Git repository
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化您的第一个 Git 仓库
- en: 'To create a Git repository, you need to create a directory and run the `git
    init` command, as shown here:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 Git 仓库，您需要创建一个目录并运行 `git init` 命令，如下所示：
- en: '[PRE2]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You are now ready to use your Git repository. You can also see that when you
    initialized the Git repository, Git created a hidden directory, `.git`, which
    it uses to keep track of all changes and commits. Whatever changes you make in
    your repo, Git keeps them as a delta of changes, which it depicts using `+` and
    `-` signs. We will look at these in detail in the subsequent sections. For now,
    let’s create a new file within our Git repository and stage it for changes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在可以使用您的 Git 仓库了。您还可以看到，当您初始化 Git 仓库时，Git 创建了一个隐藏目录 `.git`，用于跟踪所有的更改和提交。您在仓库中所做的任何更改，Git
    都会将它们作为差异（delta）记录，使用 `+` 和 `-` 符号表示。我们将在后续部分详细探讨这些内容。现在，让我们在 Git 仓库中创建一个新文件并暂存更改。
- en: Staging code changes
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暂存代码更改
- en: Git allows developers to stage their changes before they commit them. This helps
    you prepare what you want to commit to the repository. The staging area is a temporary
    holding area for your changes, and you can add and remove files from the staging
    area by using the `git add` and `git` `restore` commands.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Git允许开发者在提交之前暂存他们的更改。这有助于你准备好提交到仓库的内容。暂存区是你更改的临时存放区，你可以通过使用`git add`和`git restore`命令将文件添加或移除出暂存区。
- en: 'Let’s create our first file within the local Git repository and stage the changes:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在本地Git仓库中创建第一个文件并暂存更改：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Alternatively, you can create a blank file in the `first-git-repo` directory.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以在`first-git-repo`目录中创建一个空白文件。
- en: 'Now, we will check if Git can detect the new file that we’ve created. To do
    so, we need to run the following command:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将检查Git是否能检测到我们创建的新增文件。为此，我们需要运行以下命令：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'So, as we can see, Git has detected `file1` and is telling us that it is not
    tracking the file currently. To allow Git to track the file, let’s run the following
    command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如我们所见，Git已经检测到`file1`并告诉我们它目前没有跟踪该文件。为了让Git跟踪该文件，让我们运行以下命令：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, let’s run `git status` again to see what has changed:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次运行`git status`来查看有哪些更改：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As we can see, Git now shows `file1` as a new file in the staging area. You
    can continue making changes, and when you are done, you can commit the changes
    using the following command:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Git现在显示`file1`作为暂存区中的新文件。你可以继续进行更改，当你完成后，可以使用以下命令提交这些更改：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Git has now recorded a commit with your changes. Now, let’s look at its status
    again using the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Git现在已记录了一个包含你更改的提交。现在，让我们再次使用以下命令查看它的状态：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Git is now reporting that the working tree is clean, and there is nothing to
    commit. It also shows that there are no untracked files. Now, let’s change `file1`
    and add some text to it:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Git现在报告工作树是干净的，没有任何需要提交的内容。它还显示没有未跟踪的文件。现在，让我们修改`file1`并在其中添加一些文本：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`file1` now contains the first line. Let’s go ahead and commit this change:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`file1`现在包含了第一行。让我们继续提交这个更改：'
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we can see, Git is now reporting that one file has changed, and there is
    one insertion. Remember when we discussed that Git only tracks the delta changes
    between commits? That is what is happening here.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所看到的，Git现在报告有一个文件已更改，并且有一处插入。记得我们讨论过Git只追踪提交之间的增量更改吗？这就是发生的情况。
- en: In the introduction, we mentioned that Git provides a history of all commits.
    Let’s look at how we can display this history.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在介绍中，我们提到Git提供了所有提交的历史记录。让我们看看如何显示这个历史记录。
- en: Displaying commit history
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示提交历史
- en: 'Git keeps a history of all commits. To see a list of all commits that you’ve
    done, you can use the following command:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Git保留了所有提交的历史记录。要查看你所做的所有提交列表，可以使用以下命令：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As we can see, Git has displayed the history of both our commits. Notice that
    Git marks every commit with a commit ID. We can also delve into what changes were
    made in the commit by using the `git diff <first_commit_id> <second_commit_id>`
    command, as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Git已显示了我们两个提交的历史记录。注意，Git为每个提交标记了一个提交ID。我们还可以通过使用`git diff <first_commit_id>
    <second_commit_id>`命令来深入查看在提交中进行了哪些更改，具体如下：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The output clearly shows that the second commit has added `This is first line`
    within `file1`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 输出清楚地显示，第二次提交已将`This is first line`添加到`file1`中。
- en: You’ve suddenly realized that you needed to add another line to `file1` and
    wanted to do so in the same commit. We can do this by amending the commit. We’ll
    look at this in the next section.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你突然意识到需要在`file1`中再添加一行，并希望将其与同一提交一起完成。我们可以通过修改提交来做到这一点。我们将在下一节中讨论这个问题。
- en: Amending the last commit
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改上一次提交
- en: It is a best practice to have a single commit for your changes to a particular
    feature. This helps you track the changes better and makes it easier for the reviewer
    to review them. In turn, it is cleaner to visualize and manage. However, committing
    frequently is also a best practice so that your changes are not lost. Fortunately,
    Git allows you to add changes to the last commit.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳实践是为某个特定功能的更改创建单独的提交。这有助于你更好地追踪更改，并使审阅者更容易进行审查。反过来，这也使得可视化和管理更清晰。然而，频繁提交也是最佳实践，以确保你的更改不会丢失。幸运的是，Git允许你向上一次提交中添加更改。
- en: 'To demonstrate this, let’s change `file1` and add another line:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示这一点，让我们修改`file1`并添加另一行：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let’s add the changes to the previous commit using the following commands:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令将更改添加到之前的提交中：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Once you run this command, Git will show you a prompt, allowing you to amend
    the commit message if you like. It will look something like the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你运行这个命令，Git 会显示一个提示，允许你修改提交信息（如果需要的话）。它将类似于以下内容：
- en: '[PRE15]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Save this file (use `ESC:wq` for Vim). This should amend the last commit with
    the changes. You should get the following output:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 保存此文件（使用 `ESC:wq` 保存退出 Vim）。这将修改最后一次提交并包含更改。你应该会看到以下输出：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'When Git amends a commit, you can no longer refer to the previous commit with
    the same commit ID. Instead, Git generates a separate `SHA-1 id` for the amended
    commit. So, let’s look at the logs to see this for ourselves:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Git 修改提交时，你将无法再使用相同的提交 ID 引用之前的提交。相反，Git 会为修改后的提交生成一个单独的`SHA-1 id`。所以，让我们查看日志，亲自看看这个变化：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let’s run the `diff` command again and see what it is reporting:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次运行 `diff` 命令，看看它报告了什么：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The output clearly shows that the second commit has added `This is first line`,
    as well as `This is second line`, within `file1`. With that, you’ve successfully
    amended a commit.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 输出清楚地显示，第二次提交在 `file1` 中添加了 `This is first line` 和 `This is second line`。这样，你就成功修改了提交。
- en: Local repositories are as good as keeping files on your system. However, since
    you need to share your code with others and keep it secure from laptop OS crashes,
    theft, physical damage, and more, you need to push your code into a remote repository.
    We’ll look at remote repositories in the next section.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 本地仓库的作用就像是在系统上保存文件。然而，既然你需要与他人共享代码，并防止因笔记本操作系统崩溃、盗窃、物理损坏等原因造成的安全隐患，你需要将代码推送到远程仓库。我们将在下一节讨论远程仓库。
- en: Understanding remote repositories
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解远程仓库
- en: '**Remote repositories** are replicas of the Git repository at a central location
    for multiple people to access. This allows your developers to work on the same
    code base simultaneously and provides you with a backup of your code. There are
    various tools you can use to host your remote repositories. Notable ones include
    **GitHub**, **Bitbucket**, and **Gerrit**. You can install them on your on-premises
    or cloud servers or use a **Software-as-a-Service** (**SaaS**) platform to store
    them online. In this book, we are going to focus on GitHub.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**远程仓库**是 Git 仓库在中央位置的副本，供多人访问。这样，开发者可以同时在同一个代码库上工作，并且为你的代码提供了备份。你可以使用各种工具来托管远程仓库。著名的包括**GitHub**、**Bitbucket**
    和 **Gerrit**。你可以将它们安装在本地服务器或云服务器上，或者使用**软件即服务**（**SaaS**）平台在线存储它们。本书将重点讲解 GitHub。'
- en: GitHub is a web-based platform that helps developers collaborate on code. It
    is based on Git and allows you to host remote Git repositories. It was founded
    in 2008 and was acquired by Microsoft in 2018\. It is one of the most popular
    open-source SaaS-based Git repository services and contains almost all open-source
    code available worldwide.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 是一个基于 web 的平台，帮助开发者进行代码协作。它基于 Git，并允许你托管远程 Git 仓库。GitHub 成立于 2008 年，并在
    2018 年被微软收购。它是最受欢迎的开源 SaaS Git 仓库服务之一，包含了几乎所有全球可用的开源代码。
- en: Before we can create our first remote repo, we must go to [https://github.com/signup](https://github.com/signup)
    to create an account.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建第一个远程仓库之前，我们必须访问 [https://github.com/signup](https://github.com/signup) 创建一个账户。
- en: Once you’ve created an account, we can go ahead and create our first remote
    Git repository.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 创建完账户后，我们可以继续创建第一个远程 Git 仓库。
- en: Creating a remote Git repository
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建远程 Git 仓库
- en: Creating a remote Git repository is simple on GitHub. Go to [https://github.com/new](https://github.com/new),
    set `first-git-repo`, keep the rest of the fields as-is, and click the **Create**
    **Repository** button.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitHub 上创建远程 Git 仓库非常简单。访问 [https://github.com/new](https://github.com/new)，设置
    `first-git-repo`，其他字段保持默认，然后点击 **创建** **仓库** 按钮。
- en: Once you’ve done that, GitHub will provide you with some steps that you can
    follow to connect with your remote repository. Before we go into any of that,
    we want to configure some authentication for our local Git command line to interact
    with the remote repository. Let’s take a look.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，GitHub 会为你提供一些步骤，指导你如何连接到远程仓库。在我们深入这些步骤之前，我们需要为本地 Git 命令行配置一些身份验证，以便与远程仓库交互。让我们来看看。
- en: Setting up authentication with the remote Git repository
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置远程 Git 仓库的身份验证
- en: 'Some of the ways you can authenticate with your remote Git repository are as
    follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下几种方式与远程 Git 仓库进行身份验证：
- en: '**HTTPS**: In this mode, Git uses HTTPS to connect with the remote Git repository.
    We need to create an HTTPS token within our GitHub account and use this token
    as a password to authenticate with the remote repository. This process requires
    you to key in your token every time you authenticate with Git; therefore, it is
    not a convenient option.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HTTPS**：在这种模式下，Git 使用 HTTPS 协议连接远程 Git 仓库。我们需要在 GitHub 账户中创建一个 HTTPS 令牌，并使用该令牌作为密码来进行身份验证。这个过程要求你每次进行
    Git 身份验证时都输入令牌，因此并不是一个方便的选项。'
- en: '**SSH**: In this mode, Git uses the SSH protocol to connect with the remote
    Git repository. While using SSH, we do not need to use a password to authenticate;
    instead, we must add the **public key** of an **SSH key pair** we can generate
    from the Linux (or Windows if you’re using Git Bash) command line to the GitHub
    account. This process is more secure as well as convenient.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SSH**：在这种模式下，Git 使用 SSH 协议连接远程 Git 仓库。在使用 SSH 时，我们无需使用密码进行身份验证；相反，我们必须将从
    Linux（或如果你使用 Git Bash 的话，可以在 Windows 上）命令行生成的 **SSH 密钥对** 的 **公钥** 添加到 GitHub
    账户中。这个过程既更安全又更方便。'
- en: So, let’s set up SSH-based authentication with our remote Git repository.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们通过 SSH 认证设置与远程 Git 仓库的连接。
- en: 'First, we must generate the SSH key pair within our local system. Go to your
    Terminal and run the following command to generate an SSH key pair:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们必须在本地系统中生成 SSH 密钥对。打开终端，运行以下命令生成 SSH 密钥对：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You will be prompted for other details. Keep pressing *Enter* until you reach
    the prompt again.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 系统会提示你输入其他详细信息。继续按 *Enter* 键，直到再次出现提示。
- en: Once the key pair has been generated, copy the public key present in the `~/.``ssh/id_rsa.pub`
    file.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦生成了密钥对，复制 `~/.ssh/id_rsa.pub` 文件中的公钥。
- en: Then, go to [https://github.com/settings/ssh/new](https://github.com/settings/ssh/new),
    paste the public key in the **Key** field, and click the **Add SSH Key** button.
    We are now ready to connect with the remote Git repository. Now, let’s look at
    the configurations we must do on our local repository to connect with the remote
    repository.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，访问 [https://github.com/settings/ssh/new](https://github.com/settings/ssh/new)，将公钥粘贴到
    **Key** 字段，并点击 **Add SSH Key** 按钮。现在，我们已经准备好连接远程 Git 仓库。接下来，让我们看看在本地仓库中需要做哪些配置才能连接到远程仓库。
- en: Connecting the local repository to the remote repository
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将本地仓库与远程仓库连接
- en: 'You will need to add a remote entry using the following command to connect
    with the remote repository from the local repository:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要使用以下命令添加远程条目，以便从本地仓库连接到远程仓库：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can also find these details on the **Quick Setup** page of your GitHub repository.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以在 GitHub 仓库的 **快速设置** 页面找到这些详细信息。
- en: Now that we’ve set up the connection, let’s look at how we can push our changes
    to the remote repository.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好连接，接下来让我们看看如何将更改推送到远程仓库。
- en: Pushing changes from the local repository to the remote repository
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将更改从本地仓库推送到远程仓库
- en: 'To push the changes from the local repository to the remote repository, use
    the following command:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要将本地仓库的更改推送到远程仓库，使用以下命令：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, refresh the page on your remote repository. You should see that the code
    was synced, as shown in the following screenshot:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，刷新远程仓库页面。你应该能看到代码已经同步，如下图所示：
- en: '![Figure 2.2 – Code synced in the remote repository](img/B19877_Figure_2.02.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – 远程仓库中的代码同步](img/B19877_Figure_2.02.jpg)'
- en: Figure 2.2 – Code synced in the remote repository
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 远程仓库中的代码同步
- en: You can also use the inline editor to make further changes to the file using
    the GitHub web portal. While this is not recommended, we’ll do this to simulate
    a situation where another developer changed the same file you were working on.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用内联编辑器通过 GitHub Web 门户进一步修改文件。虽然不推荐这么做，但我们会这样做来模拟另一位开发者更改了你正在工作的相同文件的情况。
- en: 'Click on **file1** and then click on the **pencil** icon to edit the file,
    as shown in the following screenshot:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **file1**，然后点击 **铅笔** 图标以编辑文件，如下图所示：
- en: '![Figure 2.3 – Editing the file in the remote repository](img/B19877_Figure_2.03.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 编辑远程仓库中的文件](img/B19877_Figure_2.03.jpg)'
- en: Figure 2.3 – Editing the file in the remote repository
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 编辑远程仓库中的文件
- en: 'Upon doing this, an editing window will open where you can make changes to
    the file. Let’s add `This is third line` within the file, as shown in the following
    screenshot:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此操作后，会打开一个编辑窗口，你可以在文件中进行更改。让我们在文件中添加 `This is third line`，如图所示：
- en: '![Figure 2.4 – Adding a new line](img/B19877_Figure_2.04.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Adding a new line
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Scroll down – you should see a **Commit changes** section, where you can add
    a commit message field and click on the **Commit** button, as shown in the following
    screenshot:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – The Commit changes section](img/B19877_Figure_2.05.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – The Commit changes section
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve clicked on that button, you should see the third line, as shown
    in the following screenshot:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Changes committed remotely](img/B19877_Figure_2.06.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – Changes committed remotely
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, changes have been made to the remote repository, but you have
    also been working on your changes. To simulate this, let’s make a change in the
    local repository as well using the following commands:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now that we’ve committed the changes in our local repository, let’s try to
    push the code to the remote repository using the following commands:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Wait, what happened? Well, the remote repository rejected the changes as we
    tried to push changes while someone else made some commits in the remote repository,
    and our changes are not current. We would need to pull the changes in our local
    repository first to apply our changes on top of the existing ones in the remote
    repository. We’ll look at this in the next section.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Pulling and rebasing your code
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Pulling code** involves downloading up-to-date code from the remote to your
    local repository. **Rebasing** means applying your changes on top of the latest
    remote commit. It is a best practice to pull and rebase your changes on top of
    what already exists in the remote repository.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do so using the following command:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we have another issue: we are unable to rebase our commit as we’ve tried
    to modify a file that has been modified by someone else. Git wants us to check
    the file and make appropriate changes so that the changes are applied correctly.
    This situation is known as a **merge conflict**. Git also provides us with the
    file that contains the conflict. Let’s open the file with a text editor and make
    the appropriate changes.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: 'The current file looks like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The portion depicted by `HEAD` is the line in the remote repository and shows
    the recent changes made remotely. The `e411e91` commit shows the changes that
    we made locally. Let’s change the file to the following and save it:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, let’s add the file to the staging area and continue the rebase using the
    following commands:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now that we’ve rebased the changes, let’s look at the status of the Git repo
    by running the following command:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As we can see, we’ve added a single commit that we need to push to the remote
    repository. Let’s do that now using the following command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: And this time, the push worked successfully.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: In most cases, you would normally need to take a copy of the main code and make
    changes to it to test new features. You might also want someone to review your
    changes before they are merged into the main code base. Git allows you to manage
    that by using Git branches. We’ll look at Git branches in the next section.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Git branches
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **Git branch** is a copy of the code base (from where the branch is created)
    that you can independently modify and work on without affecting the main code
    base. You will want to create branches while working on new features to ensure
    that you are not affecting the main branch, which contains reviewed code. Most
    technology companies normally have several environments where you have code deployed
    in various stages. For example, you might have a **development environment** where
    you test your features, a **staging environment** where you integrate all features
    and test the complete application, and a **production environment** where the
    application that your end users access resides. So, there would be a possibility
    that you might have additional environment-specific branches where code deployed
    on those branches reside. In the following sections of this chapter, we will talk
    about GitOps, which works on this fundamental principle. For now, let’s look at
    how we can create and manage Git branches.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Creating and managing Git branches
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a Git branch, you must be on the branch from where you want to branch
    your code. As in our example repo, we were working on the master branch. Let’s
    stay there and create a feature branch out of that.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the branch, run the following command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'As we can see, the feature branch has been created. To check what branch we
    are on now, we can use the `git branch` command. Let’s do that now:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And as we see by the `*` sign over the `master` branch, we are still on the
    `master` branch. The good thing is that it also shows the `feature/feature1` branch
    in the list. Let’s switch to the feature branch now by using the following command:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we are on the `feature/feature1` branch. Let’s make some changes to the
    `feature/feature1` branch and commit it to the local repo:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'As we can see, the code is now committed to the `feature/feature1` branch.
    To check the version history, let’s run the following command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'As we can see, the `Feature 1` commit is shown in the Git logs. Now, let’s
    switch to the `master` branch and run the same command again:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As we can see here, the `Feature 1` commit changes are absent. This shows that
    both branches are now isolated (and have now diverged). Now, the changes are locally
    present and are not in the remote repository yet. To push the changes to the remote
    repository, we will switch to the `feature/feature1` branch again. Let’s do that
    with the following command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now that we’ve switched to the feature branch, let’s push the branch to the
    remote repository using the following command:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: With that, we’ve successfully pushed the new branch to the remote repository.
    Assuming the feature is ready, we want the changes to go into the master branch.
    For that, we would have to raise a pull request. We’ll look at pull requests in
    the next section.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就成功地将新分支推送到了远程仓库。假设功能已经准备好，我们希望将更改合并到master分支。为此，我们需要发起一个拉取请求。我们将在下一部分查看拉取请求。
- en: Working with pull requests
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用拉取请求
- en: 'A `master`. Pull requests are generally useful for developers to get their
    code peer reviewed before they merge it with the *fair* version of the code. The
    reviewer generally checks the quality of the code, whether best practices are
    being followed, and whether coding standards are appropriate. If the reviewer
    is unhappy, they might want to flag certain sections of the changes and request
    modifications. There are normally multiple cycles of reviews, changes, and re-reviews.
    Once the reviewer is happy with the changes, they can approve the pull request,
    and the requester can merge the code. Let’s take a look at this process:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`master`。拉取请求通常对开发者有用，帮助他们在将代码合并到*最终*版本之前进行同行评审。评审者通常会检查代码质量、是否遵循最佳实践、以及编码标准是否合适。如果评审者不满意，他们可能会标记出某些更改部分并要求修改。通常会有多轮评审、修改和重新评审。一旦评审者对更改满意，他们可以批准拉取请求，然后请求者就可以合并代码。让我们看一下这个过程：'
- en: 'Let’s try to raise a pull request for merging our code from the `feature/feature1`
    branch to the `master` branch. To do so, go to your GitHub repo, select **Pull
    requests**, and click on the **New pull request** button, as shown in the following
    screenshot:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试发起一个拉取请求，将我们的代码从`feature/feature1`分支合并到`master`分支。为此，进入你的GitHub仓库，选择**拉取请求**，然后点击**新建拉取请求**按钮，如下图所示：
- en: '![Figure 2.7 – New pull request](img/B19877_Figure_2.07.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.7 – 新拉取请求](img/B19877_Figure_2.07.jpg)'
- en: Figure 2.7 – New pull request
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.7 – 新拉取请求
- en: 'Keep `master` and, in the `feature/feature1`:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保持`master`，并在`feature/feature1`中：
- en: '![Figure 2.8 – Comparing changes](img/B19877_Figure_2.08.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8 – 比较更改](img/B19877_Figure_2.08.jpg)'
- en: Figure 2.8 – Comparing changes
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – 比较更改
- en: 'As you can see, it shows you all the changes we’ve made on the `feature/feature1`
    branch. Click on the **Create pull request** button to create the pull request.
    On the next page, stick to the defaults and click on the **Create pull** **request**
    button:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，它显示了我们在`feature/feature1`分支上所做的所有更改。点击**创建拉取请求**按钮来创建拉取请求。在下一页，保持默认设置并点击**创建拉取请求**按钮：
- en: '![Figure 2.9 – Pull request created](img/B19877_Figure_2.09.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.9 – 拉取请求已创建](img/B19877_Figure_2.09.jpg)'
- en: Figure 2.9 – Pull request created
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 – 拉取请求已创建
- en: As you can see, the pull request was created successfully. Here, you can assign
    a reviewer and get the code reviewed. Once the reviewer approves the code, you
    can merge the code to the master branch. For now, let’s click on the **Merge pull
    request** button, followed by the **Confirm merge** button, which should merge
    the pull request.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，拉取请求已成功创建。在这里，你可以分配评审者并进行代码评审。一旦评审者批准代码，你就可以将代码合并到master分支。现在，让我们点击**合并拉取请求**按钮，接着点击**确认合并**按钮，这样就可以合并拉取请求。
- en: Now, check if the `master` branch shows the changes within GitHub. If it does,
    switch to the `master` branch and pull the changes into your local repository.
    You should see the changes in your local repository as well.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，检查`master`分支是否在GitHub上显示了更改。如果显示了，切换到`master`分支，并将更改拉取到本地仓库。你应该也能在本地仓库中看到这些更改。
- en: I leave this to you as an exercise.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这个留给你作为练习。
- en: This was a crash course on Git to help you get started. Now, let’s move on and
    understand GitOps, which uses Git as a single source of truth to spin up virtually
    anything within your application and infrastructure.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关于Git的速成课程，帮助你入门。现在，让我们继续了解GitOps，它使用Git作为单一的真理来源，来启动你应用程序和基础设施中的几乎任何内容。
- en: What is GitOps?
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是GitOps？
- en: GitOps is a method that involves implementing DevOps so that Git forms the single
    source of truth. Instead of maintaining a long list of scripts and tooling to
    support this, GitOps focuses on writing declarative code for everything, including
    the infrastructure, configuration, and application code. This means you can spin
    anything out of thin air by simply using the Git repository. The idea is that
    you declare what you need in your Git repository, and there is tooling behind
    the scenes that ensures the desired state is always maintained in the running
    application and infrastructure surrounding it. The code to spin up the tooling
    also resides in Git, and you don’t have anything outside of Git. This means everything,
    including the tooling, is automated in this process.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: While GitOps also enables DevOps within the organization, it primarily focuses
    on using Git to manage infrastructure provisioning and application software deployments.
    DevOps is a broad term that contains a set of principles, processes, and tools
    to enable developers and operations teams to work seamlessly and shorten the development
    life cycle, with an end goal to deliver better software more quickly using a CI/CD
    cycle. While GitOps relies heavily on Git and its features and always looks to
    Git for versioning, finding configuration drift, and only applying deltas, DevOps
    is, as such, agnostic of any tool and focuses more on the concepts and processes.
    Therefore, you can implement DevOps without using Git, but you cannot implement
    GitOps without Git. Put simply, GitOps implements DevOps, but the reverse may
    not always be true.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Why GitOps?
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GitOps provides us with the following benefits:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '**It deploys better software more quickly**: GitOps offers simplicity in delivering
    software. You don’t have to worry about what tool you need for the deployment
    type. Instead, you can commit your changes in Git, and the behind-the-scenes tooling
    automatically deploys it.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git revert` and restore your environment. The idea is that you don’t need
    to learn anything else apart from Git to do a rollout or a rollback.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It offers better credential management**: With GitOps, you don’t need to
    store your credentials in different places for your deployments to work. You simply
    need to provide the tooling access to your Git repository and the binary repository,
    and GitOps will take care of the rest. You can keep your environment completely
    secure by restricting your developers’ access to it and providing them access
    to Git instead.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployments are self-documenting**: Because everything is kept within Git,
    which records all commits, the deployments are automatically self-documenting.
    You can know exactly who deployed what at what time by simply looking at the commit
    history.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It promotes shared ownership and knowledge**: As Git forms the single source
    of truth for all code and configurations within the organization, teams have a
    single place to understand how things are implemented without ambiguity and dependency
    on other team members. This helps promote the shared ownership of the code and
    knowledge within the team.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know about the benefits of GitOps, let’s look at its key principles.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: The principles of GitOps
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GitOps has the following key principles:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '**It describes the entire system declaratively**: Having declarative code forms
    the first principle of GitOps. This means that instead of providing instructions
    on how to build your infrastructure, applying the relevant configuration, and
    deploying your application, you declare the end state of what you need. This means
    that your Git repository always maintains a single source of truth. As declarative
    changes are idempotent, you don’t need to worry about the state of your system
    as this will eventually become consistent with the code in Git.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It versions desired system state using Git**: As Git forms an excellent version
    control system, you don’t need to worry too much about how to roll out and roll
    back your deployments. A simple Git commit means a new deployment, and a Git revert
    means a rollback. This means you do not need to worry about anything apart from
    ensuring that the Git repository reflects what you need.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It uses tooling to automatically apply approved changes**: As you’ve stored
    everything within Git, you can then use tooling that looks for changes within
    the repository and automatically applies them to your environment. You can also
    have several branches that apply changes to different environments, along with
    a pull request-based approval and gating process so that only approved changes
    end up in your environment.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It uses self-healing agents to alert and correct any divergence**: We have
    the tooling to automatically apply any changes in Git to the environment. However,
    we also require self-healing agents to alert us of any divergence from the repository.
    For example, suppose someone deletes a container manually from the environment
    but doesn’t remove it from the Git repository. In that scenario, the agent should
    alert the team and recreate the container to correct the divergence. This means
    there is no way to bypass GitOps, and Git remains the single source of truth.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing and living by these principles is simple with modern DevOps tools
    and techniques, and we will look at practically implementing them later in *Chapters
    11* and *12*. In this chapter, however, we’ll examine their design principles
    using a branching strategy and GitOps workflow.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Branching strategies and the GitOps workflow
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GitOps requires at least two kinds of Git repositories to function: the **application
    repository**, which is from where your builds are triggered, and the **environment
    repository**, which contains all of the infrastructure and **configuration as
    code** (**CaC**). All deployments are driven from the environment repository,
    and the changes to the code repository drive the deployments. GitOps follows two
    primary kinds of deployment models: the **push model** and the **pull model**.
    Let’s discuss each of them.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: The push model
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The push model pushes any changes that occur within your Git repository to
    the environment. The following diagram explains this process in detail:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – The push model](img/B19877_Figure_2.010.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – The push model
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: The push model is inherently unaware of the existing configuration and reacts
    only to changes made to your Git repositories. Therefore, you will need to set
    up some form of monitoring to understand whether there are any deviations. Additionally,
    the push model needs to store all environment credentials within the tools. This
    is because it interacts with the environment and has to manage the deployments.
    Typically, we use **Jenkins**, **CircleCI**, or **Travis CI** to implement the
    push model. While the push model is not recommended, it becomes inevitable in
    cloud provisioning with **Terraform**, or config management with **Ansible**,
    as they are both push-based models. Now, let’s take a closer look at the pull
    model.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: The pull model
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The pull model is an *agent-based deployment model* (also known as an *operator-based
    deployment model*). An *agent* (or *operator*) within your environment monitors
    the Git repository for changes and applies them as and when needed. The operator
    constantly compares the existing configuration with the configuration in the environment
    repository and applies changes if required. The following diagram shows this process
    in detail:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – The pull model](img/B19877_Figure_2.011.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – The pull model
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of the pull model is that it monitors and reacts to environment
    changes alongside repository changes. This ensures that any changes that do not
    match the Git repository are reverted from the environment. It also alerts the
    operations team about anything it could not fix using mail notifications, ticketing
    tools, or Slack notifications. Because the operator lives within the same environment
    where the code is deployed, we do not need to store credentials within the tools.
    Instead, they live securely within the environment. You can also live without
    storing any credentials at all with tools such as Kubernetes, where you can employ
    **role-based access control** (**RBAC**) and service accounts for the operator
    managing the environment.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: When choosing a GitOps model, the best practice is to check whether you can
    implement a pull-based model instead of a push-based model. Implement a push-based
    model only if a pull-based model is not possible. It is also a good idea to implement
    polling in the push-based model by scheduling something, such as a `cron` job,
    that will run the push periodically to ensure there is no configuration drift.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: We cannot solely live with one model or the other, so most organizations employ
    a **hybrid model** to run GitOps. This hybrid model combines push and pull models
    and focuses on using the pull model. It uses the push model when it cannot use
    the pull model. Now, let’s understand how to structure our Git repository so that
    it can implement GitOps.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Structuring the Git repository
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement GitOps, we require at least two repositories: the **application
    repository and the environment repository**. This does not mean that you cannot
    combine the two, but for the sake of simplicity, let’s take a look at each of
    them separately.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: The application repository
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The application repository stores the application code. It is a repository in
    which your developers can actively develop the product that you run for your business.
    Typically, your builds result from this application code, and they end up as containers
    (if we use a container-based approach). Your application repository may or may
    not have environment-specific branches. Most organizations keep the application
    repository independent of the environment and focus on building semantic code
    versions using a branching strategy. Now, there are multiple branching strategies
    available to manage your code, such as **Gitflow**, **GitHub flow**, and any other
    branching strategy that suits your needs.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'Gitflow is one of the most popular branching strategies that organizations
    use. That said, it is also one of the most complicated ones as it requires several
    kinds of branches (for instance, master, hotfixes, release branches, develop,
    and feature branches) and has a rigid structure. The structure of Gitflow is shown
    in the following diagram:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – Gitflow structure](img/B19877_Figure_2.012.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – Gitflow structure
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'A simplified way of doing things is using GitHub flow. It employs fewer branches
    and is easier to maintain. Typically, it contains a single master branch and many
    feature branches that eventually merge with the master branch. The master branch
    always has software that is ready to be deployed to the environments. You tag
    and version the code in the master branch, pick and deploy it, test it, and then
    promote it to higher environments. The following diagram shows GitHub flow in
    detail:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13 – GitHub flow](img/B19877_Figure_2.013.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 – GitHub flow
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Note that you are free to create your branching strategy according to your needs
    and what works for you.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Choose Gitflow if you have a large team, a vast monolithic repository, and multiple
    releases running in parallel. Choose GitHub flow if you work for a fast-paced
    organization that releases updates several times a week and doesn’t use the concept
    of parallel releases. GitHub flow also typically works for microservices where
    changes are minor and quick.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Typically, application repositories do not have to worry too much about environments;
    they can focus more on creating deployable software versions.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: The environment repository
  id: totrans-228
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The environment repository stores the environment-specific configurations needed
    to run the application code. Therefore, they will typically have **Infrastructure
    as Code** (**IaC**) in the form of Terraform scripts, CaC in the form of Ansible
    playbooks, or Kubernetes manifests that typically help deploy the code we’ve built
    from the application repository.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'The environment repository should follow an environment-specific branching
    strategy where a branch represents a particular environment. You can have pull
    request-based **gating** for these kinds of scenarios. Typically, you build your
    **development environments** from a development branch and then raise a pull request
    to merge the changes to a staging branch. From the staging branch to production,
    your code progresses with environments. If you have 10 environments, you might
    end up with 10 different branches in the environment repository. The following
    diagram showcases the branching strategy you might want to follow for your environment
    repository:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14 – The environment repository](img/B19877_Figure_2.014.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
- en: Figure 2.14 – The environment repository
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: The environment repository aims to act as the single source of truth for your
    environments. The configuration you add to the repository is applied directly
    to your environments.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: While you can combine the environment and application repository into one, the
    best practice is to keep them separate. GitOps offers a clear separation between
    the CI and CD processes using the application and environment repositories, respectively.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve covered Git and GitOps in detail, let’s look at why Git and GitOps
    are related but different concepts.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Git versus GitOps
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following table summarizes the differences between Git and GitOps:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **Git** | **GitOps** |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
- en: '| Definition | Git is a distributed version control system that tracks changes
    to source code and other files. It allows multiple developers to collaborate and
    manage code revisions efficiently. | GitOps is a set of practices and principles
    that leverage Git as the single source of truth for managing and automating the
    deployment and operation of infrastructure and applications. |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
- en: '| Focus | Primarily focused on version control and collaboration for source
    code. | Focused on automating and managing the deployment and operation of infrastructure
    and applications through Git-based DevOps workflows. |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
- en: '| Usage | Widely used for version control and collaboration in software development
    projects. Developers use Git to track changes, manage branches, and merge code.
    | Used for declaratively defining and managing infrastructure and application
    configurations. Git repositories serve as a central hub for defining desired states
    and driving automation. |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
- en: '| Core Components | Repositories, branches, commits, and pull requests. | Git
    repositories, declarative configuration files (such as YAML), Kubernetes manifests,
    CI/CD pipelines, and deployment tools such as Argo CD or Flux. |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
- en: '| Workflow | Developers clone, modify, commit, and push changes to a remote
    repository. They collaborate through pull requests and branch merges. | Infrastructure
    and application configurations are stored in Git repositories. Changes to these
    configurations trigger automated processes, such as CI/CD pipelines or reconciliation
    loops, to apply those changes to the target environment. |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
- en: '| Benefits | Enables efficient version control, collaboration, and code management
    for software development teams. | Promotes infrastructure and application as code,
    versioning of configurations, and declarative management. It simplifies infrastructure
    deployment, provides consistency, and enables automated workflows. |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
- en: '| Focus Area | Source code management. | Infrastructure and application deployment
    and management. |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
- en: '| Examples | GitHub, Bitbucket, GitLab. | Argo CD, Flux, Jenkins X, Weave Flux.
    |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
- en: Remember that while Git is a version control system, GitOps extends this concept
    by utilizing Git as a central source of truth for infrastructure and application
    configurations, allowing for automated deployment and management of DevOps workflows.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered Git, GitOps, why we need it, its principles, and various
    GitOps deployments. We also looked at different kinds of repositories that we
    can create to implement GitOps, along with the branching strategy choices for
    each of them.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now be able to do the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Understand what source code management is and how it is necessary for many activities
    with modern DevOps
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a Git repository and play around with the `clone`, `add`, `commit`, `push`,
    `pull`, `branch`, and `checkout` commands
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand what GitOps is and how it fits the modern DevOps context
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand why we need GitOps and how it achieves modern DevOps
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand the salient principles of GitOps
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand how to use an effective branching strategy to implement GitOps based
    on the org structure and product type
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will develop a core understanding of containers and
    look at Docker.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following is true about Git? (Choose three)
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is a distributed SCM platform
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It is a centralized SCM platform
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It allows multiple developers to collaborate
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: It has commits and branches
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In Git terms, what does Git checkout mean?
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sync code from remote to local
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch from one branch to another
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Review and approve a pull request
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In GitOps, what forms a single source of truth
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Git repository
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The configuration stored in a datastore
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The secret management system
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The artifact repository
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following options are deployment models for GitOps? (Choose two)
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The push model
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The pull model
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The staggering model
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Should you use Gitflow for your environment repository?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For monolithic applications with multiple parallel developments in numerous
    releases, what is the most suitable Git branching strategy?
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Gitflow
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: GitHub flow
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Hybrid GitHub flow
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which is the recommended deployment model for GitOps?
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The push model
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The pull model
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The staggering model
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A,C,D
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A,B
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'No'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
