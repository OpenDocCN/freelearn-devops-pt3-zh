- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security Reality Check
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security in general, and especially in Kubernetes, is an ironic thing. Everyone
    knows it’s important, yet it’s not held to the same necessity as, for example,
    developers. In fact, if you look at the ratio, there’s probably 1 security engineer
    to 100 developers. Environments aren’t secure out of the box, especially when
    it comes to access control, yet security is arguably one of the most overlooked
    pieces of Kubernetes. Because of the lack of security awareness around Kubernetes,
    this chapter is going to focus on a little bit of everything that you should be
    thinking about when securing a Kubernetes environment.
  prefs: []
  type: TYPE_NORMAL
- en: From a theoretical perspective, you’ll be learning how to think about security
    in Kubernetes. From a hands-on perspective, you’ll be learning not only how to
    implement security practices, but which tools and platforms to use.
  prefs: []
  type: TYPE_NORMAL
- en: When thinking about production, this chapter may very well be the most important
    one in this entire book. You must walk before you run, and therefore, you must
    learn how to use Kubernetes in production before you can secure it. The focus
    of *Chapters 1-7* was to get you to that point. This chapter, however, is all
    about taking things to the next level, and as with most areas of **Information
    Technology** (**IT**), that *next level* is security.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll know which practices to utilize when securing
    a Kubernetes environment from the cluster itself to the containerized applications
    running inside of the cluster. You’ll also know which tools and platforms to use
    to get the job done.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Out-of-the-box Kubernetes security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Investigating cluster security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding **role-based access** **control** (**RBAC**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes resource (object) security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes Secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Much as with all other engineering-related books and research analyst analyses,
    the figures/percentages used within this chapter are based on various experiences
    in the field. In this book, if there are figures that do not have specific associated
    data sources, the data is collated from the production experiences of the author,
    Michael Levan.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, as with most of the chapters in this book, you will need a
    Kubernetes cluster running. Although you can run these tests on something such
    as Minikube, it’s highly recommended to create a Kubeadm cluster or a Kubernetes
    managed service cluster in the cloud with something such as **Azure Kubernetes
    Service** (**AKS**), **Amazon Elastic Kubernetes Service** (**Amazon EKS**), or
    **Google Kubernetes Engine** (**GKE**). The reason why is that you should see
    what it’s truly like from a production perspective to run Kubernetes security
    tests, which will open your eyes to see how secure (or insecure) it is out of
    the box and what you can do to mitigate those risks.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to deploy a Kubeadm cluster, check out this Git repo for help:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/AdminTurnedDevOps/Kubernetes-Quickstart-Environments/tree/main/Bare-Metal/kubeadm](https://github.com/AdminTurnedDevOps/Kubernetes-Quickstart-Environments/tree/main/Bare-Metal/kubeadm%0D)'
  prefs: []
  type: TYPE_NORMAL
- en: 'For the overall code used in this chapter, you can find it here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/50-Kubernetes-Concepts-Every-DevOps-Engineer-Should-Know/tree/main/Ch8](https://github.com/PacktPublishing/50-Kubernetes-Concepts-Every-DevOps-Engineer-Should-Know/tree/main/Ch8)'
  prefs: []
  type: TYPE_NORMAL
- en: Out-of-the-box Kubernetes security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point in time, there are two typical groups of people—those who are
    so incredibly new to Kubernetes and those who are as close to an *expert* as possible.
  prefs: []
  type: TYPE_NORMAL
- en: With the group that’s new to Kubernetes, they’re just trying to understand the
    breakdown of the environment. They aren’t even at the stage of thinking about
    security yet.
  prefs: []
  type: TYPE_NORMAL
- en: With the group that’s advanced—yes, they’re implementing security practices.
    The problem is that the advanced group is extremely small compared to the group
    that’s new to Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Then, there are the engineers that are somewhat in between. They aren’t super
    new, but they aren’t ridiculously advanced either. This is the group that a lot
    of engineers fall into, and quite frankly, the group that’s somewhat in between
    is just starting to think about security.
  prefs: []
  type: TYPE_NORMAL
- en: As with most platforms, nothing is 100% secure out of the box. In fact, regardless
    of how much time you spend to secure an environment, it will never be 100%. The
    whole goal of security is to mitigate as much risk as possible, but you’ll never
    be able to mitigate 100% of the risk.
  prefs: []
  type: TYPE_NORMAL
- en: From a theoretical perspective, let’s talk about a few things around overall
    security and Kubernetes security.
  prefs: []
  type: TYPE_NORMAL
- en: Security breakdown
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cybersecurity by definition is the protection of systems and networks from system
    disclosure. This means the protection of anything from the physical server/computer
    itself to the operating system to any data and metadata on the server/computer
    or network. If you think about it, that’s a lot of information. How many emails
    do you think get sent through Gmail per day? The specific number for Gmail isn’t
    certain, but for all email providers, the number is collectively 319.6 billion
    (with a B). Thinking about it from a theoretical but most likely accurate perspective,
    it’s safe to guess that at least 25% of that is Gmail.
  prefs: []
  type: TYPE_NORMAL
- en: The point?
  prefs: []
  type: TYPE_NORMAL
- en: 'Emails alone contain a massive amount of information, but what about everything
    else? Information getting sent through networks from one country to another; data
    on hard drives: there’s a lot that falls into the *protection of systems* *and
    networks*.'
  prefs: []
  type: TYPE_NORMAL
- en: Norton states in a recent blog ([https://us.norton.com/blog/emerging-threats/cybersecurity-statistics#](https://us.norton.com/blog/emerging-threats/cybersecurity-statistics#))
    that there are roughly 2,200 cybersecurity attacks per day. To be honest, that
    seems a bit low. However, even if that number is accurate, that’s 800,000 cyberattacks
    per year. It’s certainly no small number.
  prefs: []
  type: TYPE_NORMAL
- en: With that knowledge, as engineers, we must prepare our systems and networks
    for such types of behavior. As the cloud continues to grow and Kubernetes becomes
    more mainstream, there will be more attacks directly related to Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in the opening of this section, the idea of security isn’t to stop
    all risks. The truth is, you’ll never be able to stop everything. The security
    tools, platforms, and engineers that focus on security implementations have one
    goal in mind—to stop as many security threats as possible. If a system is secure,
    the operating system may not be. If the operating system is secure, the network
    may not be. If the network is secure, the applications may not be… and around
    and around we go. Security is something that can never be 100%, but engineers
    can take precautions to get as close to 100% as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thinking about everything in this section, the question comes back to this:
    *What is security?* In short, it’s a method of protecting data.'
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The *State Of Kubernetes* security report from Red Hat ([https://www.redhat.com/en/resources/state-kubernetes-security-report](https://www.redhat.com/en/resources/state-kubernetes-security-report))
    highlights security issues directly related to the Kubernetes security landscape:'
  prefs: []
  type: TYPE_NORMAL
- en: 93% of respondents experienced at least 1 security incident in their Kubernetes
    environments in the last 12 months.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More than half of the respondents (55%) have had to delay an application rollout
    because of security concerns.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Around 70% of security issues in Kubernetes are due to misconfigurations (according
    to Gartner, it’s 99%).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you look at these statistics from a security report coming right from Red
    Hat, there’s a trend that everyone can easily see—security is a huge issue in
    the Kubernetes space.
  prefs: []
  type: TYPE_NORMAL
- en: The truth is, as many engineers and executives will attest, security is an absolute
    mess in the Kubernetes space right now. There’s no specific reason why, but there’s
    an educated guess as to why. If you look at the preceding statistics from Red
    Hat stating that 70% of security issues are due to misconfigurations, that means
    the primary reason is that engineers are still trying to figure out Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: As you’ve learned about in this book, and as I’m sure you’ve seen online, almost
    everyone is still trying to figure out Kubernetes. There’s no expert in Kubernetes
    because the landscape changes every day. There’s no end goal to all things Kubernetes
    because it constantly changes. It’s not like a math equation where once you solve
    it, it’s complete. Once you *solve* Kubernetes, 10 more things around Kubernetes
    would emerge. Because of that, how could a configuration not be misconfigured
    most of the time? This goes especially for engineers that aren’t just focused
    on Kubernetes, but focused on many areas as well. How can engineers be as close
    to *experts* as possible within Kubernetes if it’s always changing? Misconfigurations
    are constantly bound to occur.
  prefs: []
  type: TYPE_NORMAL
- en: Because of that, the landscape of Kubernetes security is a mess. In fact, it
    most likely will be for a long time. It’s tough to secure something that’s constantly
    changing.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s some light at the end of the tunnel, though. As with all platforms
    and environments, there are best practices that you can follow. Again, thinking
    about security, what’s the goal? To not fix all problems, but to mitigate as many
    as possible. The purpose of this chapter is to do exactly that: to mitigate as
    many security risks inside of your Kubernetes environment as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s jump in!
  prefs: []
  type: TYPE_NORMAL
- en: Investigating cluster security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Taking Kubernetes out of the equation, let’s think about overall infrastructure
    and/or cloud security. At a high level, you have the network, the servers, the
    connections to the servers, user access, and ensuring that the applications installed
    on the servers are secure. In the world of cloud computing, you don’t have to
    worry about the physical security aspect. But if your clusters are in a data center,
    you do have to think about physical security. Locks on the data center rack cages
    ensure that no one can plug in any old USB key and that no one can literally take
    a server out of the rack and walk away with it.
  prefs: []
  type: TYPE_NORMAL
- en: Server security is a combination of what’s running inside and on the server—the
    applications running, programs that are being executed, and the overall operating
    system itself. Let’s say, for example, you’re running an older version of Ubuntu.
    Chances are you should absolutely check and confirm that there are no security
    holes. That’s still very important for any Kubernetes cluster running on Ubuntu.
    However, Kubernetes has its own set of standards.
  prefs: []
  type: TYPE_NORMAL
- en: From a networking perspective, security still holds true in Kubernetes as well
    as in any other environment. If you have a frontend or backend Kubernetes service
    that’s accepting traffic from anywhere, that essentially means you have a blanket
    open firewall. If you’re not encrypting Pod-to-Pod and/or service-to-service communication
    with something such as a service mesh or a security-centric **Container Network
    Interface** (**CNI**), you could open yourself up to more risks.
  prefs: []
  type: TYPE_NORMAL
- en: For example, Kubernetes by definition is an API. As with all APIs, there can
    be security risks. That means one of the biggest security focus points is to ensure
    that the Kubernetes API version that you’re currently on doesn’t have a major
    security risk as that could literally take down your entire environment.
  prefs: []
  type: TYPE_NORMAL
- en: A big portion of Kubernetes security is benchmarks and other automated testing,
    which you’ll learn about in this section.
  prefs: []
  type: TYPE_NORMAL
- en: Cluster hardening and benchmarks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Center for Internet Security** (**CIS**) has been the de facto standard
    of hardening systems for years. CIS benchmarks are a set of globally identified
    standards and best practices when it comes to helping engineers set up their security
    defenses. Whether it’s in the cloud, on-prem, or a specific application/tool,
    there’s a best practice for it, and that’s exactly what CIS helps you figure out.
  prefs: []
  type: TYPE_NORMAL
- en: Because CIS is essentially a list of best practices, you have to imagine that
    there are thousands of different best practices spread across platforms and environments.
    If you think about a Linux distro, such as Ubuntu, there are specific best practices
    for that distro alone. If you think about across an entire platform such as **Amazon
    Web Services** (**AWS**), there are even more best practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you look at CIS in general, you’ll see that there are a ton of prepopulated
    CIS environments. For example, in AWS, there are CIS-hardened **Amazon Machine**
    **Images** (**AMIs**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Hardened AMI'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19116_08_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.1 – Hardened AMI
  prefs: []
  type: TYPE_NORMAL
- en: 'In other clouds, such as **Google Cloud Platform** (**GCP**) or Azure, there’s
    the same thing. Even on phones such as an iPhone, there are CIS benchmarks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – iOS hardening'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19116_08_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.2 – iOS hardening
  prefs: []
  type: TYPE_NORMAL
- en: CIS can literally be an entire book in itself, so here’s the takeaway—CIS benchmarks
    are a list of best practices and standards to follow from a security perspective
    across systems, platforms, apps, and environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because of the popularity of Kubernetes, in 2017, CIS worked with the community
    to create a benchmark specifically for Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Securing Kubernetes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19116_08_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.3 – Securing Kubernetes
  prefs: []
  type: TYPE_NORMAL
- en: There are even CIS benchmarks for specific Kubernetes environments, such as
    GKE.
  prefs: []
  type: TYPE_NORMAL
- en: As you go through this chapter, and as you go through your Kubernetes security
    journey in general, a lot of tools and platforms you’ll see that do things such
    as container image scanning and cluster scanning use CIS benchmarks. Platforms
    such as Checkov, `kube-bench`, Kubescape, and a few of the other popular tools
    in the security space all scan against CIS and the **National Vulnerability**
    **Database** (**NVD**).
  prefs: []
  type: TYPE_NORMAL
- en: You can download the latest Kubernetes CIS benchmark for free. You just need
    to put in your name and email at https://www.cisecurity.org/benchmark/kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Going over the Kubernetes CIS benchmark
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The CIS benchmarks in Kubernetes is a huge PDF that you can download and go
    through to ensure that how you’re implementing a Kubernetes environment is up
    to the best standards and best practices possible for the Kubernetes API version
    that you’re running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s learn how to download the PDF for the Kubernetes CIS benchmark. Follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to this link and fill in your information: [https://www.cisecurity.org/benchmark/kubernetes](https://www.cisecurity.org/benchmark/kubernetes).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the information is filled in, you should get an email to download the
    PDFs. There are going to be a lot, so search for `Kubernetes`. You should then
    see all the Kubernetes benchmarks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Choose the first one, which at the time of writing this, is for Kubernetes
    API version 1.23, and click the orange **Download** **PDF** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Kubernetes CIS information'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19116_08_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.4 – Kubernetes CIS information
  prefs: []
  type: TYPE_NORMAL
- en: There are 302 pages, so the reality is you probably don’t want to read through
    it all, especially after reading this chapter (or maybe you do!). Skim through
    it and search for things that you find interesting. I like the part about Kubernetes
    Secrets where it explicitly says that you should think about an external Secrets
    store.
  prefs: []
  type: TYPE_NORMAL
- en: A note about general server hardening
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Server hardening should be an absolute priority across any environment. Whether
    you’re running Windows servers, Linux servers, or a mixture of both, hardening
    your systems is the key to mitigating as much security vulnerability at the system
    level as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because CIS has been around for such a long time, there’s a benchmark for almost
    everything. For example, here is a screenshot that showcases just a few benchmarks
    available:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Benchmark options'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19116_08_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.5 – Benchmark options
  prefs: []
  type: TYPE_NORMAL
- en: 'Even from a desktop perspective, you can run CIS benchmarks against certain
    applications and tools such as Google Chrome or Microsoft Office:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Desktop benchmark options'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19116_08_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.6 – Desktop benchmark options
  prefs: []
  type: TYPE_NORMAL
- en: To see a full list, check out [https://www.cisecurity.org/cis-benchmarks/](https://www.cisecurity.org/cis-benchmarks/).
  prefs: []
  type: TYPE_NORMAL
- en: System scanning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Although not Kubernetes-specific, or Kubernetes-scanning-specific, the truth
    is that if you’re running any type of system that is in your Kubernetes environment
    as a Control Plane, worker node, or both, you should run a system scan to ensure
    that the environment is properly configured. To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the CIS-CAT® Lite tool (it’s the free one) from [https://learn.cisecurity.org/cis-cat-lite](https://learn.cisecurity.org/cis-cat-lite).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, extract it and open up the `Assessor-GUI` binary:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.7 – GUI binary'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19116_08_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.7 – GUI binary
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the GUI tool, choose the **Advanced** option so that you can specify
    a remote host:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Advanced option'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19116_08_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.8 – Advanced option
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose an option that gives you the ability to add a remote system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.9 – Adding target system'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19116_08_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.9 – Adding target system
  prefs: []
  type: TYPE_NORMAL
- en: 'Type in the information of the host that you wish to scan, such as the IP address,
    name, system type, and username/password (or SSH key):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Target system information'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19116_08_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.10 – Target system information
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the next screenshot, there’s no specific scan for Kubernetes.
    Hopefully, this will be something that’s added in the future, although you’ll
    see later in this chapter that there are tools that specifically scan Kubernetes
    against CIS. In this case, you can choose the Ubuntu Linux option:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.11 – Available benchmarks'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19116_08_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.11 – Available benchmarks
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the **Save** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.12 – Adding target system'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19116_08_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.12 – Adding target system
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that you can properly scan the server, test the connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.13 – Specifying the Control Plane'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19116_08_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.13 – Specifying the Control Plane
  prefs: []
  type: TYPE_NORMAL
- en: 'Click **Next**, and the testing should begin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.14 – Running the installation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19116_08_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.14 – Running the installation
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll then see a screen that asks you to pick a location to save the report.
    Leave this at its default settings and then start the assessment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.15 – Assessment results'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19116_08_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.15 – Assessment results
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the assessment is complete, you’ll see the report output in the default
    report location that you saw in the prior step:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.16 – Benchmark report'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19116_08_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.16 – Benchmark report
  prefs: []
  type: TYPE_NORMAL
- en: Cluster network security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Kubernetes, there are going to be two different types of network security—internal
    security and host security. Host security, of course, can be anything from your
    cloud VPC and security groups to on-prem firewalls running in your environment.
    Internal security is Pod security, service security, and, overall, how Kubernetes
    resources communicate with each other.
  prefs: []
  type: TYPE_NORMAL
- en: To keep things Kubernetes-centric, you’ll be learning about internal security
    and not host security. If you’d like to learn about host security, it’s highly
    recommended to take a look at how networking works as a whole and different security-related
    topics such as firewalls, firewall rules, port mappings, and how network routes
    are configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the rest of this section, you’ll be learning about:'
  prefs: []
  type: TYPE_NORMAL
- en: CNI security methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**extended Berkeley Packet** **Filter** (**eBPF**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CNI security
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Throughout this book, you’ve learned about service mesh, and in the next section,
    you’ll be learning about eBPF. There is, however, one other security approach
    you can take from a CNI perspective. As you look through different CNIs, you’ll
    see multiple different types of plugins. Some, such as Flannel, are for the beginner-level
    engineer that just needs to get something up and running. It doesn’t have any
    fancy features. It’s watered down and pretty basic, and that’s the purpose of
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you see other plugins, such as Calico, which is more of an advanced-level
    CNI and has a strong emphasis on security. In fact, you can actually encrypt Pod-to-Pod
    communication using Calico and WireGuard without even having to implement a service
    mesh, and that’s one of the main reasons that engineers implement a service mesh.
  prefs: []
  type: TYPE_NORMAL
- en: When you’re starting down your internal network security journey, one of the
    primary questions you should ask yourself concerns how you want to implement a
    CNI and why you want to implement it. Do you want a CNI that’s simply *ready to
    go* out of the box? Or do you want a CNI that may require a bit more configuration
    and time, but has the proper security components in place to make your life easier
    in the long run?
  prefs: []
  type: TYPE_NORMAL
- en: You can learn more about Calico and WireGuard at [https://projectcalico.docs.tigera.io/security/encrypt-cluster-pod-traffic](https://projectcalico.docs.tigera.io/security/encrypt-cluster-pod-traffic).
  prefs: []
  type: TYPE_NORMAL
- en: eBPF
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: eBPF can be an entire book in itself, but in short, it’s a way to remove the
    need to update Linux kernel code for certain programs to run. From a Kubernetes
    perspective, it can also remove the need for `kube-proxy`’s responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s focus on a few key parts when it comes to Kubernetes and eBPF:'
  prefs: []
  type: TYPE_NORMAL
- en: Removal of `kube-proxy`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easier scaling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kube-proxy` has helped make Kubernetes usable. Without it, Kubernetes wouldn’t
    have worked. However, there’s a concern. `kube-proxy` uses iptables. Although
    iptables have been in Linux for a long time, it doesn’t scale very well. iptables
    rules are stored in a list, and when Pods establish a new connection to a Kubernetes
    Service, they go through every single iptable rule until the specific rule that’s
    being looked for is reached. Although that may not seem like a lot for a few rules,
    if you have thousands (which you most likely will), it’s a performance concern.'
  prefs: []
  type: TYPE_NORMAL
- en: From a scalability perspective, as the number of Kubernetes Services (any type
    of Kubernetes Service) grows inside your cluster, the connection performance degrades.
    One of the reasons is that iptable rules are not incremental when you create them,
    which means that `kube-proxy` writes the whole table for every single update.
    It’s a huge performance impact.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know some theory behind why eBPF matters, which again, can be
    an entire book in itself, let’s dive into the hands-on implementation of eBPF:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it all depends on the cluster you’re using. As with every other Kubernetes
    environment, if you’re using a managed Kubernetes Service in the cloud, using
    eBPF will vary based on the CNI you specify for the Kubernetes Managed Service
    deployment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you’re planning to run Kubeadm, for example, the following command is what
    you should use to remove `kube-proxy`. Even if you don’t use all the flags, ensure
    that you use the `--skip-phases=addon/kube-proxy` flag as this is needed so that
    `kube-proxy` doesn’t get installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, install Helm if you don’t already have it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the Cilium Helm repo:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the repo is added, you can install Cilium with Helm. Notice the flag to
    set the `kube-proxy` replacement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After a few minutes, check to see that the Cilium Pods are running successfully
    by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output should look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.17 – Cilium Pods'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19116_08_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.17 – Cilium Pods
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing eBPF is still an extremely new topic and you may not see it through
    all environments. However, I can assure you that you’ll begin to see it more and
    more as eBPF becomes more popular and the benefits are seen more.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading the Kubernetes API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In every Kubernetes environment, you must keep track of the Kubernetes API.
    The last thing you want to do is have an insanely out-of-date API for any software/platform,
    but definitely for Kubernetes as well. All APIs, even Kubernetes, can eventually
    have a security hole that needs to be patched. You must ensure that your environment
    is ready for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you keep track of a Kubernetes API, the inevitable will happen: you’ll
    have to upgrade the API. This isn’t just for features and to keep the system up
    to date, but from a security perspective, you don’t want to be too far behind
    as every old version of every piece of software stops getting patched and security
    holes open.'
  prefs: []
  type: TYPE_NORMAL
- en: For the rest of this section, you’ll learn how to do a Kubernetes upgrade on
    a cluster running Kubeadm. If you don’t have Kubeadm, that’s fine—still follow
    along. Eventually, you’ll have to do an upgrade on a raw Kubernetes cluster, so
    it’s still good to know.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: For any type of upgrade, especially in production, you should not only vigorously
    test the upgrade path, but you should back up your environment components.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading Control Planes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s begin by upgrading a Kubeadm Control Plane. Follow along with these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `upgrade` command, which will show which upgrade path is available:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 8.18 – Kubernetes upgrade'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19116_08_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.18 – Kubernetes upgrade
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following output, you’ll see the target versions for every upgrade available,
    along with the command to run. The output will also show what the current Kubernetes
    API version is and which Control Plane components will be upgraded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.19 – Upgrade path'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19116_08_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.19 – Upgrade path
  prefs: []
  type: TYPE_NORMAL
- en: 'Before running the upgrade, you’ll want to download the latest version of the
    API and confirm that Kubeadm gets put on hold to not upgrade all Control Plane
    components at once. Note that running the following command may result in you
    having to restart the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once complete, run the upgrade, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You’ll see an output similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.20 – Upgrade output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19116_08_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.20 – Upgrade output
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the second part of the output from the preceding screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.21 – Upgrade output continued'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19116_08_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.21 – Upgrade output continued
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve upgraded the Control Plane, let’s learn how to upgrade worker
    nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading worker nodes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before running the upgrade, you’ll want to download the latest version and
    confirm that Kubeadm gets put on hold to not upgrade all Control Plane components
    at once. Note that running the following command may result in you having to restart
    the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, upgrade the worker node, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 8.22 – Node upgrade'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19116_08_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.22 – Node upgrade
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! This process is a bit more straightforward compared to the Control
    Plane.
  prefs: []
  type: TYPE_NORMAL
- en: Upgrading the kubelet
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last step is to upgrade the kubelet on both the Control Planes and worker
    nodes. Follow along:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following for the kubelet upgrade:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, reload the kubelet, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following command, and you should now see that the Kubernetes cluster
    is upgraded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Although this may not seem like something purely security related, and maybe
    it’s not, it’s still extremely important for security. You can’t have old versions
    of software lying around, just as you can’t have old versions of APIs lying around.
    For platform engineering teams, it’s no different.
  prefs: []
  type: TYPE_NORMAL
- en: Audit logging and troubleshooting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes generates several logs. In fact, most Kubernetes resources have the
    metrics endpoint enabled. That means, everything and anything that’s generated
    with that Kubernetes resource—such as authentication, access, Pods going down,
    containers coming up, end users accessing it, and everything in between—is recorded.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that audit logging—and, sometimes, even the metrics server—isn’t
    enabled or even installed by default. You have the ability to install and configure
    audit logging in Kubernetes, but it’s not prepared out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: What’s meant by that is the Kubernetes API for audit logging is available and
    *turned on* out of the box. It just won’t start to generate any logs that you
    can see because you first need to set up a policy via the `audit.k8s.io/v1` API,
    but policies don’t exist by default—it’s up to the engineer to create those policies.
    The policy can be anything from *show me everything* to *show me particular read
    actions on these particular Kubernetes resources*. It can be as high-level or
    as granular as you’d like.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a lot of policies, including audit logging, that can be turned on.
    In fact, it could most likely be a topic that spans an entire cluster itself.
    Because of that, we’ll stick with audit logging in this section. However, the
    following screenshot showcases the **Open Web Application Security Project** (**OWASP**)
    Top 10 for Kubernetes, and one of the top 10 is proper logging:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.23 – OWASP Top 10'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19116_08_23.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.23 – OWASP Top 10
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see more information about it here: [https://github.com/OWASP/www-project-kubernetes-top-ten/blob/main/2022/en/src/K05-inadequate-logging.md](https://github.com/OWASP/www-project-kubernetes-top-ten/blob/main/2022/en/src/K05-inadequate-logging.md).'
  prefs: []
  type: TYPE_NORMAL
- en: Before jumping into the hands-on part, let’s talk about what audit logging is.
    Audit logging is recorded by the Kubernetes API server. With those *recordings*,
    which are just logs, it documents a chronological set in an order that shows the
    sequence of actions on a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'It generates:'
  prefs: []
  type: TYPE_NORMAL
- en: Actions taken by users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actions taken by Kubernetes resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Control Plane itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Essentially, audit logs allow you to ask yourself questions such as the following:
    1) *What happened?* 2) *When did it happen?* 3) *How did it happen?* No question
    should be left unanswered as you can retrieve everything and anything about a
    Kubernetes cluster via the audit logs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, let’s learn how to set them up. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a network policy such as the one shown next. For the purposes of this
    section, you can store it under `/etc/kubernetes/simple-policy.yaml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If you’re on a managed Kubernetes Service, such as AKS or EKS, you’ll have to
    turn on audit logging in a different way, and it all depends on the server you’re
    using. However, you should still read through this section as you’ll end up coming
    across audit logs on bare-metal/VM environments (especially during this time when
    hybrid cloud is becoming far more popular) at some point on your Kubernetes journey.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open up the following location via Vim or an editor of your choosing:
    `/etc/kubernetes/manifests/kube-apiserver.yaml`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add in the following code, as shown in *Figure 8**.24*. This will give you
    the ability to set audit log consumption and set how long the logs are kept, which
    path the output of the audit logs should go to, and where your audit policy exists:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 8.24 – Audit policy path'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19116_08_24.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.24 – Audit policy path
  prefs: []
  type: TYPE_NORMAL
- en: 'Under `volumeMounts`, add the following code, as shown in *Figure 8**.25*.
    For Kubernetes, the policy and the path for the audit logs need to be mounted
    in the cluster:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 8.25 – Policy mount'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19116_08_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.25 – Policy mount
  prefs: []
  type: TYPE_NORMAL
- en: 'Under `hostPath`, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 8.26 – Policy host path'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19116_08_26.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.26 – Policy host path
  prefs: []
  type: TYPE_NORMAL
- en: 'Restart the kubelet by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Confirm that the kubelet is still running, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can now view the audit logs on the Control Plane at the path/location where
    you stored the `audit.log` file by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You should see a bunch of log output. For security purposes, I haven’t included
    a screenshot showcasing the output.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, this type of configuration would be for a Kubeadm cluster
    or something on-prem. For the cloud, it’s going to be a bit different. However,
    it’s still important to understand this process. Remember—the cloud abstracts
    a lot away from engineers, but engineers must still understand the underlying
    components of a system to properly work with it.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding RBAC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When it comes to users, groups, and service accounts, there are two questions
    you must ask yourself. The first is: *Who can access your cluster?* Which users,
    service accounts, and groups have the ability to run `kubectl` commands on the
    clusters in development, staging, and production? Which of those users have a
    Kubeconfig that gives them access to particular clusters? Which environments can
    they connect to?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second question is: *What can they do once they’re inside the cluster?*
    Can they list Pods? Create Pods? See Ingress Controllers? Create Ingress Controllers?
    What types of Kubernetes resources can they interact with throughout each environment?'
  prefs: []
  type: TYPE_NORMAL
- en: When you’re setting up a Kubernetes environment, you must also think about authentication
    and authorization. Who can access your cluster and what can they do? Further,
    you must think about what the users can do throughout each environment. For example,
    thinking about the single tenancy model that you learned about in a previous chapter,
    one engineer may have full admin access on one cluster and read-only access on
    another. With that, you must also think about multiple authorization methods in
    terms of which permissions you’re giving people.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you’re going to learn how to manage from a permissions perspective
    users, groups, and teams in Kubernetes using RBAC.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that although this section is not huge, it should point you in the
    right direction in terms of how to think about RBAC and how to start implementing
    it.
  prefs: []
  type: TYPE_NORMAL
- en: What is RBAC?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: RBAC, as with many other topics in this book (I’m a broken record at this point),
    can be an entire book in itself. Because of that, let’s do a brief theoretical
    explanation and then dive into the hands-on piece.
  prefs: []
  type: TYPE_NORMAL
- en: RBAC, by definition, is a way to ensure that users, groups, and service accounts
    only have the permissions that they need from an authorization perspective. RBAC
    does not do authentication—it does authorization. The authentication piece comes
    before RBAC. Once there’s a user, group, or service account created, then RBAC
    can jump into action and start creating permissions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within RBAC for Kubernetes, you have four primary resources that you want to
    utilize:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Roles`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ClusterRoles`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RoleBindings`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ClusterRoleBindings`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You’ll learn more about them in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you’re thinking about RBAC, think: *What am I allowing this person to
    do* *inside Kubernetes?*'
  prefs: []
  type: TYPE_NORMAL
- en: One thing to keep in mind is that RBAC is typically the bane of every security
    engineer’s existence. It’s one of those topics in Kubernetes that makes everyone
    bang their head against a wall because it can start to become insanely complex,
    and there’s no central way to manage hundreds of RBAC roles and permissions. There
    are tools and platforms out there that are trying to mitigate this, such as Kubescape’s
    RBAC Visualizer.
  prefs: []
  type: TYPE_NORMAL
- en: To continue along with this chapter, you’ll need a user, group, or service account.
    Because Kubernetes doesn’t have an out-of-the-box method for creating users and
    groups, let’s use a service account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to create a new service account called `miketest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Once the service account is created, it can be used for the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Roles and ClusterRoles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Roles` are permissions that you can give users, groups, and service accounts,
    and they are namespace scoped. Meaning, let’s say you create a role called `readpods`.
    That role would be tied to a namespace—for example, a namespace called `ingress`.
    That means the `readpods` role only works on the `ingress` namespace, and it’s
    not tied to any other namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: How about if you want a role/permissions for a user/group/service account that’s
    used across all namespaces through the cluster? That’s where `ClusterRoles` come
    into play. A `ClusterRole` is the same thing as a `Role`. The only difference
    is that it’s not namespace scoped.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dive in to learn how you can create `Roles` and `ClusterRoles`.
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code snippet is an example of a `Role` that you can create. It’s
    scoped to the `ingress` namespace and sets read-only permissions for the Pod Kubernetes
    resource. Notice in the verbs that it’s all read permissions—`get`, `watch`, and
    `list`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the preceding `Role` will ensure that you have a proper role created
    to give a user/group/service account read-only permissions for Pods in the `ingress`
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: ClusterRoles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As with the preceding `Role`, the following `ClusterRole` creates a `ClusterRole`
    called `reader` for read-only permissions on Pods. The key difference is that
    it’s not scoped to a particular namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the preceding `ClusterRole` will ensure that you have a proper
    role created to give a user/group/service account read-only permissions for Pods
    across all namespaces in the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s learn how to bind `Roles` to a particular service account.
  prefs: []
  type: TYPE_NORMAL
- en: RoleBindings and ClusterRoleBindings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `RoleBinding` is a way that you tie/attach a `Role` to a user/group/service
    account. For example, let’s say you have a `Role` called `podreaders` and you
    want to tie/attach that role to the `miketest` service account. You would use
    a `RoleBinding` to perform that action.
  prefs: []
  type: TYPE_NORMAL
- en: Just as with `Roles` and `ClusterRoles`, the only difference is that `RoleBindings`
    are namespace scoped and `ClusterRoleBindings` are not and can be used throughout
    the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s learn how to implement `RoleBindings` and `ClusterRoleBindings`.
  prefs: []
  type: TYPE_NORMAL
- en: RoleBinding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following `RoleBinding` takes the `Role` that you created in the previous
    section and attaches it to the `miketest` service account. See how there’s a `kind`
    and the service account kind is specified? This is where you can specify a `group`
    or a `user`. It’s also scoped to the `ingress` namespace as this is not a `ClusterRoleBinding`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: ClusterRoleBinding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Much as with the preceding `RoleBinding`, the following `ClusterRoleBinding`
    will attach the `miketest` service account to the `ClusterRole` and reference
    the following `ClusterRole`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Now that you know about overall authentication and authorization permissions,
    it’s time to learn about overall Kubernetes resource security and the approaches
    that you can take out of the gate to ensure a successful security-centric deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes resource (object) security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, you learned a little bit about Kubernetes resource
    security. Remember, Kubernetes resources can be anything from Pods to Ingress
    Controllers to Services. Essentially, anything running inside of the Kubernetes
    cluster that you’re reaching via the API is a Kubernetes resource.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you’re going to learn the top methods of today to secure Kubernetes
    resources within Kubernetes and by using third-party tools.
  prefs: []
  type: TYPE_NORMAL
- en: Pod security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When it comes to network security in a Kubernetes environment, there are two
    parts—the host network and the internal network. For the purposes of this section,
    we can’t go into host networking because every environment is going to be different.
    Whether it’s different physical hardware or virtual hardware setups, there’s no
    *one-size-fits-all* network environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are a few helpful tips that work across every environment:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that you have proper firewall rules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that you’re implementing proper routing protocols and not just opening
    up the entire network.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that you have the proper port setup in place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that you’re logging and observing network traffic.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For Kubernetes network security, there are network policies.
  prefs: []
  type: TYPE_NORMAL
- en: Network Policies are built into Kubernetes via the `networking.k8s.io/v1` API.
    Network Policies act like firewall rules for both Ingress and Egress traffic.
    However, network policies aren’t just about whitelisting or blacklisting IP addresses
    and ports. You can do much more with a policy. For example, you can block traffic
    from a specific network to a specific namespace, from a specific namespace, or
    to/from a specific application. Because of the vast number of options that come
    with Network Policies, you have plenty of options, but you’ll want to ensure that
    you’re setting up the right policies. One wrong accidental `162.x.x.x` instead
    of `172.x.x.x` can completely throw off the entire network workflow in a network
    policy and completely halt application workloads.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dive into what a network policy looks like.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this out, run the following Pods in your Kubernetes environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The preceding new Pods will run a container image called `busybox`, which is
    a small form factor that’s usually used for testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, obtain the IP address of the Pods, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 8.27 – Pod output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19116_08_27.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.27 – Pod output
  prefs: []
  type: TYPE_NORMAL
- en: 'Run a ping against the `busybox1` Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '![Figure 8.28 – Ping output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B19116_08_28.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 8.28 – Ping output
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you know there’s proper `busybox1` Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the ping against `busybox1` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: There should now be 100% packet loss.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re in an environment where this didn’t work, such as a standard Minikube
    environment, the reason why it’s most likely not working is that you’re using
    a CNI that doesn’t have network policies enabled or doesn’t support network policies.
  prefs: []
  type: TYPE_NORMAL
- en: To find out how to enable network policies, you’ll need to do a quick search
    on how to implement network policies for your specific CNI.
  prefs: []
  type: TYPE_NORMAL
- en: Policy enforcement
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, you learned about security at the network layer, which
    is of course needed. After (or before) the network layer is the application layer,
    which is where policy enforcement around Pods and containers comes into play.
  prefs: []
  type: TYPE_NORMAL
- en: The whole idea behind policy enforcement is to give you the ability to protect
    your Pods, ensure best security practices, and set standards for your organization.
  prefs: []
  type: TYPE_NORMAL
- en: For example, one of the biggest best practices in production is to ensure that
    you’re not using the latest container image version in production. Instead, you
    always want to use a container image version that’s properly versioned and battle-tested
    for protection. With policy enforcement in Kubernetes, you can accomplish that.
  prefs: []
  type: TYPE_NORMAL
- en: Right now, the two biggest ways to implement policy enforcement are using **Open
    Policy Agent** (**OPA**) and Kyverno. They’re both the same from a policy enforcement
    perspective, but the biggest difference is that Kyverno only works inside of Kubernetes.
    Because of that, a lot of engineers are going toward using OPA so that they can
    use it throughout their environment and not just in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Because of that, the hands-on section will be using OPA.
  prefs: []
  type: TYPE_NORMAL
- en: What about Pod Security Policies?
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve heard of Pod Security Policies, they’re essentially the same thing
    as OPA. However, they were deprecated in v1.21 of Kubernetes and completely removed
    in v1.25.
  prefs: []
  type: TYPE_NORMAL
- en: OPA
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you want to configure a specific policy, you can use a policy agent such
    as OPA. OPA allows you to write policies in an OPA-specific language called Rego
    (which you’ll see later in this section). When you write a policy, any request
    or event that comes in from another Kubernetes resource or an outside entity will
    be queried. OPA’s decision agent will give it a *pass* or *fail*.
  prefs: []
  type: TYPE_NORMAL
- en: But how does OPA know how to implement policies?
  prefs: []
  type: TYPE_NORMAL
- en: That’s where OPA Gatekeeper comes into play. Gatekeeper is a *middle ground*
    of sorts that allows Kubernetes to interact with OPA. Gatekeeper is installed
    on Kubernetes and enables the use of OPA policies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s dive in from a hands-on perspective to set up OPA. The first part will
    be deploying OPA Gatekeeper and the second part will be implementing a policy.
    Proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add Helm chart for Gatekeeper, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install the Helm chart by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Confirm that all Kubernetes resources for Gatekeeper were deployed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that Gatekeeper is installed, let’s start implementing the OPA policies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration is the definition/output of what OPA Gatekeeper is allowed
    to create policies for. In the following `config.yaml` file, because of the way
    that it’s written, Gatekeeper knows that it can only specify policies for Pods
    and no other Kubernetes resources. Run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: A constraint template is a policy that you configure for an environment. It’s
    a template, so you can use it across multiple places.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Rego code/policy in the following constraint template ensures no one can
    utilize the latest tag of a container image. Run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, you have the constraint. The constraint takes the template that you created
    earlier and allows you to use the template to create a policy inside of a Kubernetes
    cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The OPA policy is now created.
  prefs: []
  type: TYPE_NORMAL
- en: 'To confirm that the policy is working as expected, you can test it out with
    the two following Kubernetes manifests:'
  prefs: []
  type: TYPE_NORMAL
- en: The following manifest with the container image’s latest tag shouldn’t work
    because of the policy that you created earlier. The deployment itself will deploy,
    but the Pods won’t be scheduled and won’t come online.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Try running the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Wait a few minutes and when you see that it doesn’t come online, delete it,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, try the following manifest. It will work, and the Pods will come online
    because the container image version is specified:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: OPA is a huge topic in itself. I highly recommend diving into it more. We only
    had a few pages together in this book to dive into it, but it goes far more in-depth.
  prefs: []
  type: TYPE_NORMAL
- en: Scanning container images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One popular security-style *entry point* for many engineers to start their security
    journey is by scanning container images. Scanning a container image means that
    you’re using a tool/platform to look inside the container image and see if there
    are any vulnerabilities. The vulnerability list typically comes from the NVD and
    the CIS benchmarks for Kubernetes. Both are a curated list of best practices from
    a security perspective and also contain known vulnerabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a lot of tools in this space. In this section, let’s stick to one
    that’s as *built in* as possible: Snyk.'
  prefs: []
  type: TYPE_NORMAL
- en: Snyk is used to scan containers for vulnerabilities from a list that’s pre-defined
    (as stated earlier) of best practices. A while back, Docker and Snyk partnered
    to ensure that security is embedded natively into any containerized workload.
    With that partnership, when you run the `docker scan` command, it’s actually using
    Snyk on the backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Snyk, ensure that you have the Docker CLI installed and run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, let’s say you want to scan the `ubuntu:latest` container image,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Once you run the `docker scan` command, you can scroll through all of the vulnerabilities.
    You’ll see a summary of the vulnerabilities that were found, what was tested,
    and which platform was used.
  prefs: []
  type: TYPE_NORMAL
- en: Vulnerabilities can range from being super basic, in that it just ends up being
    a best practice to fix, or something that’s incredibly crucial and leaves your
    environment open for attack.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes Secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Wrapping up this chapter, and the overall book, you’ll learn about Kubernetes
    Secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Secrets, in short, are anything that you don’t want to be in plain text. Typically,
    they are things such as passwords and API keys. However, they could even be usernames.
    Any type of data that you don’t want to be in plain text, at rest, or in transit
    can be considered a Secret.
  prefs: []
  type: TYPE_NORMAL
- en: At this point in your engineering journey, it’s assumed that you don’t need
    to be taught about Secrets, so we’re going to skip that part and dive right into
    the hands-on part.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Kubernetes Secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a Kubernetes Secret, you’ll use the `secret` resource from the `v1`
    core API group.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following is a Secret called `testsecret` with a username
    and password:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'Confirm that the Secret was created by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, use the `secret` by putting it inside a Pod, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: Don’t use Kubernetes Secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although you literally just created a new Kubernetes Secrets a few seconds ago,
    here’s the thing—it’s not a recommended practice.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest reason is that the default opaque standard for Kubernetes Secrets
    stores secrets in plain text. Yes—that’s right. The secrets will be stored in
    plain text in the `etcd` database. Thinking about it from another perspective,
    think about Kubernetes Manifests. Even if the secret wasn’t in plain text in Etcd,
    it would still be in plain text in the Kubernetes Manifest that’s creating the
    secret, and if it’s in plain text, where would you store it? You can’t push the
    manifest up to GitHub because then your secret would be compromised. Because of
    this, many engineers—and, quite frankly, even the Kubernetes documentation—highly
    recommend using a third-party secret provider. The most popular at this time for
    Kubernetes is HashiCorp Vault.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you went through this chapter, there may have been some thoughts in your
    head of pure confusion. That’s okay—we’re all trying to *get it* when it comes
    to security in general, especially in Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes security is an advanced topic, which is why the goal was to leave
    this topic for the last chapter of the book. Without Kubernetes security, environments
    will continue to be targets for attackers. However, before understanding Kubernetes
    security, you must fully understand how to utilize Kubernetes in production. The
    goal of *Chapters 1-7* was to help with understanding Kubernetes in production.
  prefs: []
  type: TYPE_NORMAL
- en: The next goal, once you close this book, is to take what you’ve learned in this
    chapter along with the various methodologies highlighted and implement them in
    your production environment for optimal results.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Learn Kubernetes Security* by *Kaizhe Huang* and *Pranjal* *Jumde*: [https://www.packtpub.com/product/learn-kubernetes-security/9781839216503](https://www.packtpub.com/product/learn-kubernetes-security/9781839216503)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
