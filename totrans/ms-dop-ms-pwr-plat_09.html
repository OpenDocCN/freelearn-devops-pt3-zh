<html><head></head><body>
		<div id="_idContainer133">
			<h1 id="_idParaDest-138" class="chapter-number"><a id="_idTextAnchor149"/><st c="0">9</st></h1>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor150"/><st c="2">Implementing the Fusion Development Approach</st></h1>
			<p><st c="46">Power Platform, with its low-code/no-code approach, allows citizen developers who are close to business processes to use their knowledge of the business problem to design and bring new applications to usage faster. </st><st c="262">It often can happen, that the challenges they are facing scale to be more complex or the feature demand surpasses their capabilities, thus pro-developers are required to support the development process and help citizen developers avoid </st><span class="No-Break"><st c="498">repetitive tasks.</st></span></p>
			<p><st c="515">In this chapter, we will look at how organizations can connect different personas to build effective teams that will work together to solve challenges and enable organizations with digitized business solutions. </st><st c="727">We will start by focusing on the general understanding of the fusion development approach and how teams are represented by different personas. </st><st c="870">We will continue with some good open source development practices that can be applied also in low-code/no-code and drill into a tool in Power Platform that </st><span class="No-Break"><st c="1026">supports them.</st></span></p>
			<p><st c="1040">The final part will focus on the integration between the Azure cloud and Power Platform. </st><st c="1130">The emphasis here will be on specific Azure services, such as the Azure API Management service, which serves as the integration service between Azure and Power Platform. </st><st c="1300">Some other common Azure services that are often used in the integration scenarios with Power Platform will be covered as well. </st><st c="1427">We will finish off by looking into an example of building an integration between a low-code application and a </st><span class="No-Break"><st c="1537">code-first solution.</st></span></p>
			<p><st c="1557">We will cover the following main topics in </st><span class="No-Break"><st c="1601">this chapter:</st></span></p>
			<ul>
				<li><a id="_idTextAnchor151"/><st c="1614">What is the fusion </st><span class="No-Break"><st c="1634">development approach?</st></span></li>
				<li><st c="1655">Microsoft Azure and Power </st><span class="No-Break"><st c="1682">Platform together</st></span></li>
				<li><st c="1699">Example of an Azure and Power Platform </st><span class="No-Break"><st c="1739">integration scenario</st></span></li>
			</ul>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor152"/><st c="1759">Technical requirements</st></h1>
			<p><st c="1782">This chapter connects Power Platform solutions together with Azure services. </st><st c="1860">To follow along, we recommend having these requirements </st><span class="No-Break"><st c="1916">in place:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="1925">Power Platform subscription</st></strong><st c="1953">: You can sign up for a Power Platform Developer Plan (</st><a href="https://powerapps.microsoft.com/en-us/developerplan/"><st c="2009">https://powerapps.microsoft.com/en-us/developerplan/</st></a><st c="2062">) if you already have a Microsoft Entra ID work account, or you can join the Microsoft 365 Developer </st><span class="No-Break"><st c="2164">Program (</st></span><a href="https://developer.microsoft.com/en-us/microsoft-365/dev-program"><span class="No-Break"><st c="2173">https://developer.microsoft.com/en-us/microsoft-365/dev-program</st></span></a><span class="No-Break"><st c="2237">).</st></span></li>
				<li><strong class="bold"><st c="2240">Azure subscription</st></strong><st c="2259">: You can provision a free Azure account following the guidance on this website: </st><a href="https://azure.microsoft.com/en-us/free"><st c="2341">https://azure.microsoft.com/en-us/free</st></a><st c="2379">. Once provisioned, the Microsoft Azure portal can be accessed via the following </st><span class="No-Break"><st c="2460">URL: </st></span><a href="https://portal.azure.com/"><span class="No-Break"><st c="2465">https://portal.azure.com/</st></span></a><span class="No-Break"><st c="2490">.</st></span></li>
				<li><strong class="bold"><st c="2491">Visual Studio</st></strong><st c="2505">: If you do not have access to any other version of Visual Studio, you can use the free Community Edition (</st><a href="https://visualstudio.microsoft.com/vs/community/"><st c="2613">https://visualstudio.microsoft.com/vs/community/</st></a><st c="2662">). </st><st c="2666">Some examples demonstrate the capabilities of Power Platform tools for Visual Studio that are not available in Visual Studio Code. </st><st c="2797">For other cases, you can also use </st><strong class="bold"><st c="2831">Visual Studio Code</st></strong><st c="2849"> (</st><strong class="bold"><st c="2851">VS Code</st></strong><st c="2858">) with the </st><strong class="bold"><st c="2870">Power Platform Tools</st></strong><st c="2890"> extension. </st><st c="2902">VS Code can be found </st><span class="No-Break"><st c="2923">here: </st></span><a href="https://code.visualstudio.com/"><span class="No-Break"><st c="2929">https://code.visualstudio.com/</st></span></a><span class="No-Break"><st c="2959">.</st></span></li>
				<li><strong class="bold"><st c="2960">Samples</st></strong><st c="2968"> discussed in this chapter are located in the following </st><span class="No-Break"><st c="3024">repository: </st></span><a href="https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/tree/main/Chapter09"><span class="No-Break"><st c="3036">https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/tree/main/Chapter09</st></span></a><span class="No-Break"><st c="3135">.</st></span></li>
			</ul>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor153"/><st c="3136">What is the fusion development approach?</st></h1>
			<p><st c="3177">This section covers how individuals</st><a id="_idIndexMarker1127"/><st c="3213"> from different teams collaborate to realize projects through a concept known as the </st><strong class="bold"><st c="3298">fusion development approach</st></strong><st c="3325">. We will explain what this is and how it bridges the gap between citizen developers and pro-developers. </st><st c="3430">We will explain how Power Platform can also benefit from the practices coming from the open source development world, and finish off by preparing our development environment to be connected with </st><span class="No-Break"><st c="3625">Power Platform.</st></span></p>
			<p><st c="3640">Fusion development involves merging diverse teams and their skillset, to facilitate the digitization of business capabilities and deliver value. </st><st c="3786">It is a term that was first defined by Gartner as a multidisciplinary digital business team that blends technology and business domain expertise and is responsible for delivering digital products. </st><st c="3983">Gartner’s research showed that implementing distributed fusion teams can help speed up the progress of realizing the organization’s digital transformation agenda much faster compared to the traditional centralized teams. </st><st c="4204">You can read more about Gartner’s research in the article published on this </st><span class="No-Break"><st c="4280">page: </st></span><a href="https://www.gartner.com/en/articles/why-fusion-teams-matter"><span class="No-Break"><st c="4286">https://www.gartner.com/en/articles/why-fusion-teams-matter</st></span></a><span class="No-Break"><st c="4345">.</st></span></p>
			<p><st c="4346">In the world of Power Platform, the fusion development approach</st><a id="_idIndexMarker1128"/><st c="4410"> blends together a low-code/no-code development approach with a traditional software development approach and IT operations for managing resources and platforms. </st><st c="4572">The purpose of these multidisciplinary teams working together is to take advantage of the knowledge that teams have and use that to scale the application modernization or the digitization of the business processes with the use of low-code/no-code tools. </st><st c="4826">It helps organizations succeed with business transformation in a fast-changing business environment, where it is imperative to have business solutions available in the market soon enough to gain a </st><span class="No-Break"><st c="5023">competitive advantage.</st></span></p>
			<p><st c="5045">We can group team members of fusion teams into three different </st><span class="No-Break"><st c="5109">persona groups:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="5124">Citizen developers</st></strong><st c="5143">: This group consists of people who have business knowledge, understand</st><a id="_idIndexMarker1129"/><st c="5215"> the business</st><a id="_idIndexMarker1130"/><st c="5228"> processes and the business challenges, and are determined to digitize existing business processes. </st><st c="5328">Here, we can find business users, business analysts, and business engineers. </st><st c="5405">They will be using tools that support low-code/no-code development approaches, such as Microsoft Power Platform, to visually design and build certain parts of the project. </st><st c="5577">This could be building a frontend prototype of the application in Power Apps or workflows that support business processes in </st><span class="No-Break"><st c="5702">Power Automate.</st></span></li>
				<li><strong class="bold"><st c="5717">Professional developers</st></strong><st c="5741">: This is a group </st><a id="_idIndexMarker1131"/><st c="5760">of skilled professional developers</st><a id="_idIndexMarker1132"/><st c="5794"> who are experienced in various programming languages that will be used to solve complex application development challenges. </st><st c="5919">Using traditional software development tools, such as Visual Studio, they will primarily be building extensions for low-code solutions. </st><st c="6055">Their work will focus on developing backend APIs, integration scenarios, or custom code components that will be used by citizen developers in their low-code/no-code projects. </st><st c="6230">Where possible, it is recommended that professional developers also use the same low-code development tool as citizen developers, to support the development of simpler tasks</st><a id="_idIndexMarker1133"/><st c="6403"> and to integrate custom solutions into the newly </st><a id="_idIndexMarker1134"/><span class="No-Break"><st c="6453">developed solution.</st></span></li>
				<li><strong class="bold"><st c="6472">IT professionals/DevOps engineers</st></strong><st c="6506">: The last group is where we will find IT professionals, who will look after the resources</st><a id="_idIndexMarker1135"/><st c="6597"> that will be</st><a id="_idIndexMarker1136"/><st c="6610"> running newly built business applications in order to be used in a managed and governed way, aligned with organizational IT policies. </st><st c="6745">In this group, we will find DevOps engineers, who will be responsible for managing the DevOps processes of the business solution. </st><st c="6875">They will make sure the project is aligned with DevOps practices, such as having CI/CD pipelines up and running and ensuring that all components of the business solution are </st><span class="No-Break"><st c="7049">properly version-controlled.</st></span></li>
			</ul>
			<p><st c="7077">The following figure shows how the personas are all connected and work together to achieve the goal of building a </st><span class="No-Break"><st c="7192">business solution:</st></span></p>
			<div>
				<div id="_idContainer119" class="IMG---Figure">
					<img src="image/B22208_09_1.jpg" alt="Figure 9.1 – The fusion development approach"/><st c="7210"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="7577">Figure 9.1 – The fusion development approach</st></p>
			<p><st c="7621">Additionally, we should</st><a id="_idIndexMarker1137"/><st c="7645"> introduce two more personas in the fusion development approach that will bring benefit to the </st><span class="No-Break"><st c="7740">fusion team.</st></span></p>
			<p><st c="7752">The first one is the </st><strong class="bold"><st c="7774">fusion team leader</st></strong><st c="7792">. Their role is to oversee</st><a id="_idIndexMarker1138"/><st c="7818"> the entire project development and coordinate team members, taking care of the communication and the </st><span class="No-Break"><st c="7920">project delivery.</st></span></p>
			<p><st c="7937">The second one is the </st><strong class="bold"><st c="7960">solution architect</st></strong><st c="7978"> role. </st><st c="7985">It is recommended to include</st><a id="_idIndexMarker1139"/><st c="8013"> a solution architect in the planning and designing phase of the project, as they will dive into the technical details and help with creating a high-level architectural design of the solution, take care of the design patterns, share recommendations on the tools and technology selection, </st><span class="No-Break"><st c="8301">and more.</st></span></p>
			<p><st c="8310">The recommendation for the fusion team size is very similar to the general recommendation for the agile team size. </st><st c="8426">There is no one-size-fits-all; it will all depend on the project’s complexity and organizational maturity. </st><st c="8533">However, we should keep the fusion teams </st><em class="italic"><st c="8574">small</st></em><st c="8579"> in size in order to maintain the autonomy and agility of </st><span class="No-Break"><st c="8637">the team.</st></span></p>
			<p><st c="8646">Somewhere between 5 and 7 people in a team is considered the appropriate agile team size. </st><st c="8737">This is many times linked to Amazon’s </st><em class="italic"><st c="8775">two-pizza rule</st></em><st c="8789"> which states that the teams should be small enough to be fed by two pizzas. </st><st c="8866">Smaller teams allow communication and collaboration to be efficient while maintaining agility. </st><st c="8961">This includes the ability to rapidly adapt to the challenges the team is facing, without introducing </st><span class="No-Break"><st c="9062">necessary bottlenecks.</st></span></p>
			<p><st c="9084">The fusion team</st><a id="_idIndexMarker1140"/><st c="9100"> itself may be a temporary, </st><strong class="bold"><st c="9128">short-lived team</st></strong><st c="9144">. Its purpose could be to solve a particular business problem and once this is done, the team disperses and team members continue their normal work routine – for example, citizen developers, who could be business users and business analysts, will continue their work, while software developers might go back to another traditional software </st><span class="No-Break"><st c="9484">development project.</st></span></p>
			<p><st c="9504">As mentioned, in some ways, fusion development</st><a id="_idIndexMarker1141"/><st c="9551"> overlaps with an agile culture. </st><st c="9584">The fusion development approach follows the lean methodology, which we described in </st><a href="B22208_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><st c="9668">Chapter 1</st></em></span></a><st c="9677">. The idea of the lean methodology is to focus on delivering value in a fast iterative development. </st><st c="9777">Fusion teams can work in sprints to track and deliver work, using DevOps tools and project planning tools, such as </st><span class="No-Break"><st c="9892">Azure Boards.</st></span></p>
			<h2 id="_idParaDest-142"><a id="_idTextAnchor154"/><st c="9905">Common examples of the fusion development approach in Power Platform</st></h2>
			<p><st c="9974">Fusion teams come together to solve business problems. </st><st c="10030">During the planning and design phase, these challenges are thought through and tasks are divided between the stakeholders. </st><st c="10153">Next, we will provide a couple of examples of how, with a fusion approach, pro-developers and citizen developers can tackle these problems with </st><span class="No-Break"><st c="10297">technological solutions.</st></span></p>
			<h3><st c="10321">Custom connector to backend API</st></h3>
			<p><st c="10353">We often </st><a id="_idIndexMarker1142"/><st c="10363">see in organizations that there are already a set of systems and services that are being utilized in legacy applications and business processes. </st><st c="10508">If we wish to modernize only our frontend application or build an entirely new application from scratch, but utilize some of the backend services, we can use custom connectors in Power Platform to connect backend services with the Power Platform applications. </st><st c="10768">Building custom connectors in Power Platform helps organizations unlock access to those APIs from different Power Platform services and allows makers to reuse them for any potential </st><span class="No-Break"><st c="10950">new scenario.</st></span></p>
			<p><st c="10963">If we are building new APIs, we can keep in mind that they might be used in Power Platform. </st><st c="11056">Therefore, building and using custom connectors is a common practice when building applications, flows, and copilots with Power Platform services. </st><st c="11203">From the roles perspective, as an example, we might see professional developers building new Web APIs, citizen developers utilizing them in Power Apps applications, and IT operations taking control of managing Power Platform environments, building data loss prevention policies, and describing</st><a id="_idIndexMarker1143"/><st c="11496"> required infrastructure, using an </st><strong class="bold"><st c="11531">infrastructure as code</st></strong><st c="11553"> (</st><strong class="bold"><st c="11555">IaC</st></strong><st c="11558">) approach, which will be used to provision the required infrastructure, including Azure API Management, to run supporting services. </st><st c="11692">DevOps engineers would, together with pro-developers, make sure that the CI/CD pipelines are configured to build and deploy applications and APIs in an </st><span class="No-Break"><st c="11844">automated way.</st></span></p>
			<p><st c="11858">Once a custom connector is built and deployed to Power Platform, we can reuse it in Power Automate to bring the capabilities of our legacy systems and services into the business logic that the </st><a id="_idIndexMarker1144"/><st c="12052">Power Automate flow </st><span class="No-Break"><st c="12072">is implementing.</st></span></p>
			<p><st c="12088">Copilot Studio</st><a id="_idIndexMarker1145"/><st c="12103"> now also offers the ability to use connectors, including custom connectors directly within the </st><span class="No-Break"><st c="12199">custom copilot.</st></span></p>
			<h3><st c="12214">Extending with PCF control</st></h3>
			<p><st c="12241">Sometimes, controls that are available out of the box in Power Pages or Power Apps, canvas, and </st><a id="_idIndexMarker1146"/><st c="12338">model-driven apps might not be enough. </st><st c="12377">Maybe we are looking for a graphically richer component or just a custom component that does a very specific job. </st><st c="12491">In this case, we can reach out to pro-developers</st><a id="_idIndexMarker1147"/><st c="12539"> to support us by building custom code components with </st><strong class="bold"><st c="12594">Power Apps Component Framework</st></strong><st c="12624"> (</st><strong class="bold"><st c="12626">PCF</st></strong><st c="12629">). </st><st c="12633">PCF components are reusable and enrich the </st><span class="No-Break"><st c="12676">user experience.</st></span></p>
			<p><st c="12692">This is another good example of where pro-developers utilize their skills in software development. </st><st c="12792">By using the TypeScript</st><a id="_idIndexMarker1148"/><st c="12815"> programming language, they develop a component that citizen developers can add to their applications built in Power Apps or websites built with Power Pages, to improve the user experience or enable certain additional </st><span class="No-Break"><st c="13033">business scenarios.</st></span></p>
			<p><st c="13052">While the previous example with custom connectors allowed pro-developers to be almost separated from Power Platform as they were focusing only on Web APIs, with code</st><a id="_idIndexMarker1149"/><st c="13218"> components, pro-developers should know about Power Platform since each application type (canvas, model-driven, or website/portal) has its own set of development best practices </st><span class="No-Break"><st c="13395">and limitations.</st></span></p>
			<h3><st c="13411">Enabling complex skills in custom copilots</st></h3>
			<p><st c="13454">Another </st><a id="_idIndexMarker1150"/><st c="13463">example of the fusion approach is related to building custom copilots or bots in </st><a id="_idIndexMarker1151"/><st c="13544">Copilot Studio. </st><st c="13560">Copilot Studio allows extending capabilities of custom copilots with Power Automate flows, connectors, plugins, and Copilot framework skills. </st><st c="13702">If using existing connectors and building flows that integrate with Copilot Studio is something that can be done by a citizen developer, building skill actions requires the involvement </st><span class="No-Break"><st c="13887">of pro-developers.</st></span></p>
			<p><st c="13905">A skill</st><a id="_idIndexMarker1152"/><st c="13913"> is a bot that can perform a set of actions for another bot/skill consumer, which is often a user-facing bot. </st><st c="14023">It supports multi-turn operations, such as making a product order, as opposed to integrations with Power Automate flows, which allow single-turn operations, such as getting the status of </st><span class="No-Break"><st c="14210">a parcel.</st></span></p>
			<p><st c="14219">In this case, pro-developers will be using the Copilot framework SDK to build a skill that will be then used by citizen developers in a user-facing custom copilot bot that will be built in </st><span class="No-Break"><st c="14409">Copilot Studio.</st></span></p>
			<p><st c="14424">All these examples have one thing in common – reusability. </st><st c="14484">Let’s take a look at how building a catalog in Power Platform can help with the discoverability and reusability of the </st><span class="No-Break"><st c="14603">built components.</st></span></p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor155"/><st c="14620">Empowering collaboration with open source development practices</st></h2>
			<p><st c="14684">Organizations will move at a rapid</st><a id="_idIndexMarker1153"/><st c="14719"> pace to implement</st><a id="_idIndexMarker1154"/><st c="14737"> new applications, flows, or chatbots. </st><st c="14776">Fusion teams will develop many components in Power Platform that can be reusable in other projects instead of wasting time on reinventing the wheel. </st><st c="14925">How can we remove silos in the organizations and empower any developer, no matter whether they are pro-developers or citizen developers, to understand what has already been done and allow them to reuse that in their own projects? </st><st c="15155">Before answering this question, let us step back a bit and see how this has been solved in the traditional software </st><span class="No-Break"><st c="15271">development world.</st></span></p>
			<p><st c="15289">Not too long ago, many organizations</st><a id="_idIndexMarker1155"/><st c="15326"> were very closed, independently</st><a id="_idIndexMarker1156"/><st c="15358"> working on projects without collaboration. </st><st c="15402">This led to duplicated efforts and inefficiencies in the development processes. </st><st c="15482">Teams were isolated and collaboration and communication were very poor or non-existent. </st><st c="15570">We also sometimes experienced resistance to new ideas or practices that could lead to changing the way </st><span class="No-Break"><st c="15673">teams operated.</st></span></p>
			<p><st c="15688">However, if we look at the software development practices in the open source world, we can see how open source software is potentially shared with anyone, open for use and modifications. </st><st c="15876">Practically anyone can review the project, and modify and reuse the open source software. </st><st c="15966">The goal of such an approach is to build code that is more reliable </st><span class="No-Break"><st c="16034">and better.</st></span></p>
			<p><st c="16045">This is where we need to introduce </st><strong class="bold"><st c="16081">InnerSource</st></strong><st c="16092">. InnerSource is a development</st><a id="_idIndexMarker1157"/><st c="16122"> methodology that takes the good practices of open source software development and applies them to a closed group – employees of an organization. </st><st c="16268">This would mean that software development projects become private open-sourced projects of </st><span class="No-Break"><st c="16359">an organization.</st></span></p>
			<p><st c="16375">The interesting thing is that this kind of development approach, which uses DevOps tools such as Azure DevOps and GitHub, can be used for any kind of project, even outside of </st><span class="No-Break"><st c="16551">software development.</st></span></p>
			<p><st c="16572">InnerSource brings a modern approach to software development and helps us to remove challenges that older and more rigid ways of building proprietary software have on an organization. </st><st c="16757">Collaborating openly in the organization will help improve innovation since more people can collaborate and contribute to the project. </st><st c="16892">Developers don’t always have to build projects from</st><a id="_idIndexMarker1158"/><st c="16943"> the beginning, as InnerSource helps with </st><strong class="bold"><st c="16985">discoverability</st></strong><st c="17000">. It may be that something already exists within our organization that can be reused. </st><st c="17086">This will drive rapid development, decrease development costs, and improve time to market. </st><st c="17177">It will improve collaboration and, most importantly, foster a culture </st><span class="No-Break"><st c="17247">of openness.</st></span></p>
			<p><st c="17259">The annual research that is done by the</st><a id="_idIndexMarker1159"/><st c="17299"> InnerSource Commons Foundation, called the </st><em class="italic"><st c="17343">State of InnerSource Report</st></em><st c="17370"> (available at </st><a href="https://innersourcecommons.org/"><st c="17385">https://innersourcecommons.org/</st></a><st c="17416">), identifies the benefits and blockers of InnerSource. </st><st c="17473">Common blockers for not applying InnerSource practices are due to the organizational culture, siloed thinking, and lack of awareness and familiarity with Innersource principles. </st><st c="17651">This is why it is important to make sure developers get familiar with these practices and there is a buy-in for this strategy in the organization, which will help us allocate resources and time for implementing and unlocking the benefits of InnerSource within </st><span class="No-Break"><st c="17911">the organization.</st></span></p>
			<p><st c="17928">These good practices can also be applied to the low-code/no-code </st><span class="No-Break"><st c="17994">development approach.</st></span></p>
			<p><st c="18015">Fusion development teams – more specifically, pro-developers and DevOps engineers – perform many tasks with DevOps tools, such as Azure DevOps and GitHub, where the InnerSource approach is at the heart of the product. </st><st c="18234">Tools such as Azure Boards or GitHub Issues enable developers to bring up ideas for new features, report bugs in the product, comment on tasks, and more. </st><st c="18388">Pull request mechanisms enable better results, as build validations and peer reviews make sure the final artifact meets all requirements. </st><st c="18526">To further support good DevOps practices, companies can expand their set of tools with products such as Microsoft Teams to improve communication and collaboration of fusion teams and </st><span class="No-Break"><st c="18709">implement ChatOps.</st></span></p>
			<p><st c="18727">Services and features of DevOps tools</st><a id="_idIndexMarker1160"/><st c="18765"> are built in a way that helps</st><a id="_idIndexMarker1161"/><st c="18795"> organizations enable and foster InnerSource more easily. </st><st c="18853">For an organization to understand whether they are moving toward the desired goal, they should implement periodic reviews to understand how InnerSource is </st><span class="No-Break"><st c="19008">being adopted.</st></span></p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor156"/><st c="19022">Building a catalog process</st></h2>
			<p><st c="19049">When working on a business solution for Power Platform, we should also consider how to follow InnerSource best practices, allow fusion teams to share their work, and allow other teams to reuse components and built templates. </st><st c="19275">While opening projects in Azure DevOps and GitHub would allow pro-developers to understand which projects are available in the organizations, we cannot expect our business users to follow the same steps as pro-developers. </st><st c="19497">There is another way to share our work with anyone in </st><span class="No-Break"><st c="19551">the organization.</st></span></p>
			<p><st c="19568">The </st><strong class="bold"><st c="19573">catalog</st></strong><st c="19580"> in Power Platform is the single source</st><a id="_idIndexMarker1162"/><st c="19619"> of truth of all components and templates that were deployed to the catalog to be cataloged and reused. </st><st c="19723">It is presented as a model-driven app within Power Apps and it helps us understand what is already available in the organization. </st><st c="19853">The Power Platform catalog is not a version control system and does not replace DevOps tools for version control and CI/CD pipelines. </st><st c="19987">However, it does enhance the ALM/DevOps processes as it supports the automation scenarios through the PAC CLI commands, as we have seen in an example in </st><a href="B22208_06.xhtml#_idTextAnchor103"><span class="No-Break"><em class="italic"><st c="20140">Chapter 6</st></em></span></a><span class="No-Break"><st c="20149">.</st></span></p>
			<p><st c="20150">Components and templates are represented in the catalog as items. </st><st c="20217">Pro-developers and citizen developers will use the catalog to understand which existing items are available in the organization and who has published them. </st><st c="20373">It will serve also to find and reuse components in new projects or start by using the built templates. </st><st c="20476">On the other hand, the IT operations team will use the management capabilities of the catalog to control the usage of code components </st><span class="No-Break"><st c="20610">and templates.</st></span></p>
			<p><st c="20624">We recommend starting by installing one catalog in the organization. </st><st c="20694">However, there are cases when an organization needs to install more than one catalog in the Power Platform tenant – for example, if an organization has very sensitive projects that have to be isolated from others. </st><st c="20908">In this case, another catalog should be installed to provide the level of </st><span class="No-Break"><st c="20982">isolation needed.</st></span></p>
			<p class="callout-heading"><st c="20999">Preview functionality</st></p>
			<p class="callout"><st c="21021">Note that as</st><a id="_idIndexMarker1163"/><st c="21034"> of the time of writing, </st><strong class="bold"><st c="21059">Catalog in Power Platform</st></strong><st c="21084"> is a preview feature and so has some limitations in functionalities, such as, for example, that it cannot be utilized in an environment that uses a customer-managed key. </st><st c="21255">During preview, the catalog can be used in all types of environments, but when released to general</st><a id="_idIndexMarker1164"/><st c="21353"> availability, this will only be available in the </st><span class="No-Break"><strong class="bold"><st c="21403">managed</st></strong></span><span class="No-Break"><st c="21410"> environments.</st></span></p>
			<h3><st c="21424">Catalog process</st></h3>
			<p><st c="21440">Catalog in Power Platform</st><a id="_idIndexMarker1165"/><st c="21466"> follows a process life cycle from the creation of catalog items to the acquisition phase when a new team reuses the previously developed </st><span class="No-Break"><st c="21604">catalog item.</st></span></p>
			<p><st c="21617">It starts with the fusion team of pro-developers and citizen developers creating components and building catalog items with all the components that solved their initial business challenges. </st><st c="21808">These catalog items also include configuration parameters that would be required for the catalog item to be </st><span class="No-Break"><st c="21916">properly configured.</st></span></p>
			<p><st c="21936">These catalog items are then submitted to the catalog for reuse purposes. </st><st c="22011">Once submitted, IT administrators and line-of-business approvers will review these new catalog items and approve </st><span class="No-Break"><st c="22124">them accordingly.</st></span></p>
			<p><st c="22141">Other pro-developers and app makers</st><a id="_idIndexMarker1166"/><st c="22177"> will use the catalog to find existing solutions and templates. </st><st c="22241">Those catalog items that seem fit for their business problem will be reused. </st><st c="22318">In order to finish the configuration, makers have to provide all necessary configuration parameters and establish required connections. </st><st c="22454">After that, this catalog item is successfully provisioned in their environment. </st><st c="22534">Now, they can reuse the components in their own solutions that they </st><span class="No-Break"><st c="22602">are building.</st></span></p>
			<h3><st c="22615">Starting with the Catalog Manager</st></h3>
			<p><st c="22649">Before we can start using Catalog</st><a id="_idIndexMarker1167"/><st c="22683"> in Power Platform, we must first install it from Microsoft AppSource. </st><st c="22754">We should have a </st><em class="italic"><st c="22771">system administrator</st></em><st c="22791"> security role assigned in the environment to be able to install the Catalog Manager. </st><st c="22877">The Catalog Manager will be installed in a Dataverse environment, which should have a minimum database version of </st><strong class="source-inline"><st c="22991">9.2.22122.00148</st></strong><st c="23006">. We can check the Dataverse version in the </st><strong class="bold"><st c="23050">Version</st></strong><st c="23057"> card inside the environment settings. </st><st c="23096">We need to first open </st><strong class="bold"><st c="23118">Power Platform admin center</st></strong><st c="23145"> | </st><strong class="bold"><st c="23148">Environments</st></strong><st c="23160"> and then select the environment and the </st><span class="No-Break"><strong class="bold"><st c="23201">Version</st></strong></span><span class="No-Break"><st c="23208"> card.</st></span></p>
			<p><st c="23214">We recommend having a separate Power Platform environment that will be used for the catalog. </st><st c="23308">This allows anyone to access the environment and review the catalog items as well as install catalog items from this catalog to </st><span class="No-Break"><st c="23436">their environments.</st></span></p>
			<p><st c="23455">Once we have cleared all the prerequisites, we can proceed to </st><span class="No-Break"><st c="23518">the installation.</st></span></p>
			<p><st c="23535">We have the option to install the Catalog Manager via the PAC CLI. </st><st c="23603">In order to do this, we first connect to the Power Platform environment where we would like to install it. </st><st c="23710">There, we use </st><strong class="source-inline"><st c="23724">pac application list</st></strong><st c="23744"> to find all applications that are available in our tenant. </st><st c="23804">One of these will be </st><strong class="bold"><st c="23825">Catalog in Power Platform Manager</st></strong><st c="23858">, with the unique name </st><strong class="source-inline"><st c="23881">mspcat_CatalogManager</st></strong><st c="23902"> or a GUID of </st><strong class="source-inline"><st c="23916">83a35943-cb41-4266-b7d2-81d60f383695</st></strong><st c="23952">. This unique name or GUID can be used to install the application in the current environment by using </st><strong class="source-inline"><st c="24054">pac application install --application-name mspcat_CatalogManager</st></strong><st c="24118">. To install the application to a different environment, switch </st><strong class="source-inline"><st c="24182">--environment &lt;ENV_ID&gt;</st></strong><st c="24204"> with the appropriate environment ID or URL. </st><st c="24249">To verify that we have installed the catalog in our tenant, we can use </st><strong class="source-inline"><st c="24320">pac admin list --application 83a35943-cb41-4266-b7d2-81d60f383695</st></strong><st c="24385">, which will return information on the environments where Catalog Manager </st><span class="No-Break"><st c="24459">is installed.</st></span></p>
			<p><st c="24472">If we would like to install this application using the UI, we will need to use this link directly to install it: </st><a href="https://appsource.microsoft.com/product/dynamics-365/powerappssvc.catalogmanager-preview?flightCodes=dde212e5c66047c59bf2b346c419cef6"><st c="24586">https://appsource.microsoft.com/product/dynamics-365/powerappssvc.catalogmanager-preview?flightCodes=dde212e5c66047c59bf2b346c419cef6</st></a><st c="24719">. When prompted to sign in to Microsoft AppSource, we need to do so with our system administrator and confirm the installation by clicking </st><strong class="bold"><st c="24858">Get it now</st></strong><st c="24868">. This takes us to </st><strong class="bold"><st c="24887">Dynamics 365 apps</st></strong><st c="24904"> inside </st><strong class="bold"><st c="24912">Power Platform admin center</st></strong><st c="24939"> to complete the installation process. </st><st c="24978">As a final step, we need to select an environment in which this application will be installed. </st><st c="25073">We need to agree with the terms and privacy statements and then we can click </st><strong class="bold"><st c="25150">Install</st></strong><st c="25157"> to install the app. </st><st c="25178">The process</st><a id="_idIndexMarker1168"/><st c="25189"> of installation takes a couple </st><span class="No-Break"><st c="25221">of minutes.</st></span></p>
			<div>
				<div id="_idContainer120" class="IMG---Figure">
					<img src="image/B22208_09_2.jpg" alt="Figure 9.2 – Installing the Catalog Manager app"/><st c="25232"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="25728">Figure 9.2 – Installing the Catalog Manager app</st></p>
			<p><st c="25775">The installation process installs a new Power Apps application. </st><st c="25840">After installation is done, we will need to configure the catalog metadata. </st><st c="25916">First, we need to run the Catalog Manager. </st><st c="25959">Accessing the Catalog Manager is done through Power Apps. </st><st c="26017">We can find the application in the list of apps in the corresponding environment. </st><st c="26099">Simply go to </st><strong class="bold"><st c="26112">Power Apps</st></strong><st c="26122"> | </st><strong class="bold"><st c="26125">Apps</st></strong><st c="26129">, hover over the </st><strong class="bold"><st c="26146">Power Platform Catalog Manager</st></strong><st c="26176"> app name, and click on the </st><em class="italic"><st c="26204">play</st></em><st c="26208"> icon to run the application, or click on the three dots next to the name and then click </st><strong class="bold"><st c="26297">Play</st></strong><st c="26301"> to run </st><span class="No-Break"><st c="26309">the application.</st></span></p>
			<p><st c="26325">Now that we have the application running, we can configure metadata by opening the configuration group. </st><st c="26430">In the left navigation bar, at the very bottom, click </st><strong class="bold"><st c="26484">Catalog</st></strong><st c="26491">, which opens an option to select an area; from there, click </st><strong class="bold"><st c="26552">Settings</st></strong><st c="26560">. This will open the configuration group, where we have options to configure </st><strong class="bold"><st c="26637">Catalog</st></strong><st c="26644">, </st><strong class="bold"><st c="26646">Rule sets for PowerApps checker</st></strong><st c="26677">, </st><strong class="bold"><st c="26679">Static Analysis Policies</st></strong><st c="26703">, and </st><strong class="bold"><st c="26709">Configurations for PowerApps checker</st></strong><st c="26745">. Clicking </st><strong class="bold"><st c="26756">Catalog</st></strong><st c="26763"> will open </st><strong class="bold"><st c="26774">Catalog Configuration</st></strong><st c="26795">, as can be seen in </st><span class="No-Break"><em class="italic"><st c="26815">Figure 9</st></em></span><em class="italic"><st c="26823">.3</st></em><st c="26825">. Here, we can change the catalog name, description, help link, and image to help us identify the catalog. </st><st c="26932">On the right, in </st><strong class="bold"><st c="26949">Catalog Configuration</st></strong><st c="26970">, we have the option to enable the catalog, allow unmanaged solutions (future feature plans) to be deployed to the catalog, and enable global auto-approval for the published catalog items on the catalog level. </st><st c="27180">This final setting of auto-approval, if configured on a global level, will override</st><a id="_idTextAnchor157"/><a id="_idTextAnchor158"/><st c="27263"> the setting</st><a id="_idIndexMarker1169"/><st c="27275"> on the </st><span class="No-Break"><st c="27283">publisher level.</st></span></p>
			<div>
				<div id="_idContainer121" class="IMG---Figure">
					<img src="image/B22208_09_3.jpg" alt="Figure 9.3 – Catalog metadata and configuration"/><st c="27299"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="27945">Figure 9.3 – Catalog metadata and configuration</st></p>
			<p><st c="27992">To return to the main </st><strong class="bold"><st c="28015">Catalog</st></strong><st c="28022"> area, we can click on the </st><strong class="bold"><st c="28049">Home</st></strong><st c="28053"> navigation in the left navigation bar. </st><st c="28093">Among other things, here we will find individual dashboards with action items, an </st><strong class="bold"><st c="28175">Approvals</st></strong><st c="28184"> section with all the approval requests, </st><strong class="bold"><st c="28225">Catalog</st></strong><st c="28232"> section with published catalog items, and the deployment history. </st><st c="28299">Details of each section and explanation can be found </st><span class="No-Break"><st c="28352">here: </st></span><a href="https://learn.microsoft.com/en-us/power-platform/developer/administer-catalog"><span class="No-Break"><st c="28358">https://learn.microsoft.com/en-us/power-platform/developer/administer-catalog</st></span></a><span class="No-Break"><st c="28435">.</st></span></p>
			<h3><st c="28436">Publishing a new catalog item</st></h3>
			<p><st c="28466">Let’s say we have successfully</st><a id="_idIndexMarker1170"/><st c="28497"> built a solution that we would like to publish to a catalog and allow its reuse. </st><st c="28579">To publish an item to the catalog, we need a solution or package deployer package with items that we wish to publish as well as a submission metadata </st><span class="No-Break"><st c="28729">JSON file.</st></span></p>
			<p><st c="28739">We will be using the PAC CLI to perform operations with the catalog item. </st><st c="28814">As we are already used to doing, we will start our terminal and run the </st><strong class="source-inline"><st c="28886">pac auth create</st></strong><st c="28901"> command to create an authentication profile (if we do not have one yet) or reuse an existing authentication profile. </st><st c="29019">We can check the existing authentication profiles by using the </st><strong class="source-inline"><st c="29082">pac auth list</st></strong><st c="29095"> command. </st><st c="29105">Keep in mind that when we need to connect to an environment with the catalog in which we would like to publish items, we use the </st><strong class="source-inline"><st c="29234">pac auth create –-environment</st></strong><st c="29263"> or </st><strong class="source-inline"><st c="29267">-env</st></strong><st c="29271"> switch with the name or ID of the environment in which the catalog </st><span class="No-Break"><st c="29339">is installed.</st></span></p>
			<p><st c="29352">Using </st><strong class="source-inline"><st c="29359">pac catalog list</st></strong><st c="29375"> will show us all published </st><span class="No-Break"><st c="29403">catalog items.</st></span></p>
			<p><st c="29417">Now, we are ready to publish new items to the catalog. </st><st c="29473">We will use the </st><strong class="source-inline"><st c="29489">pac catalog create-submission</st></strong><st c="29518"> command to generate a default submission metadata JSON document called </st><strong class="source-inline"><st c="29590">submission.json</st></strong><st c="29605"> in the current operating folder of your terminal (to change the path, we can use the </st><strong class="source-inline"><st c="29691">--path</st></strong><st c="29697"> switch). </st><st c="29707">We need to edit this file to prepare it for the catalog item that we plan </st><span class="No-Break"><st c="29781">to submit.</st></span></p>
			<p class="callout-heading"><st c="29791">Note</st></p>
			<p class="callout"><st c="29796">This command is also subject to change when this preview feature comes closer to general availability. </st><st c="29900">Use </st><strong class="source-inline"><st c="29904">pac catalog --help</st></strong><st c="29922"> to find a list of all </st><span class="No-Break"><st c="29945">possible commands.</st></span></p>
			<p><st c="29963">The submission</st><a id="_idIndexMarker1171"/><st c="29978"> metadata JSON file contains submission attributes that we need to update to match our catalog item. </st><st c="30079">An example file, created using the previous command, looks similar </st><span class="No-Break"><st c="30146">to this:</st></span></p>
			<pre class="source-code"><st c="30154">
{
  "modelVersion": "1.0.0.0",
  "sourcePortal": 526430000,
  "operation": "CreateOrUpdate",
  "businessJustification": "Business Justification",
  "publisherDetails": {
    "publisherId": "742d02b8-59ad-4aa4-b95a-bd41cd0459ed",
    "publisherDisplayName": "Publisher Display Name"
  },
  "catalogItemDefinition": {
    "id": "1cd8fe87-f508-42ad-8dcd-d12dda7d8668",
    "displayName": "Catalog Item Display Name",
    "description": "Catalog Item Description",
    "offer": {
      "type": "Component_Collection",
      "deploymentType": "Normal",
      "engineeringName": {
...},
      "supportName": {...}
    },
    "packageFile": {...}
  }
}</st></pre>			<p><st c="30728">From the submission metadata</st><a id="_idIndexMarker1172"/><st c="30757"> file, four attributes are required for submission: publisher, catalog item, engineering contact, and </st><span class="No-Break"><st c="30859">support contact.</st></span></p>
			<p><st c="30875">The publisher attributes are in the section in JSON described as </st><strong class="source-inline"><st c="30941">publisherDetails</st></strong><st c="30957">. They are one or more Microsoft Entra ID groups, which will allow users who are part of that group to update catalog items in the future. </st><st c="31096">When we think of </st><strong class="source-inline"><st c="31113">publisher</st></strong><st c="31122">, this can be a fusion development team that is working on a specific project or a group of developers who are part of a specific department in the organization. </st><st c="31284">We recommend providing </st><strong class="source-inline"><st c="31307">publisherID</st></strong><st c="31318"> and </st><strong class="source-inline"><st c="31323">publisherDisplayName</st></strong><st c="31343">, as these are used to verify whether the publisher </st><span class="No-Break"><st c="31395">already exists.</st></span></p>
			<p><st c="31410">The catalog item is the solution that we plan to publish. </st><st c="31469">We need to provide </st><strong class="source-inline"><st c="31488">id</st></strong><st c="31490"> and </st><strong class="source-inline"><st c="31495">displayName</st></strong><st c="31506"> as well as </st><strong class="source-inline"><st c="31518">engineeringName</st></strong><st c="31533"> and </st><strong class="source-inline"><st c="31538">supportName</st></strong><st c="31549">, as these are required attributes. </st><st c="31585">The engineering contact helps those who would like to reuse the catalog item to understand who to contact in case of any additional questions about the item. </st><st c="31743">The support name</st><a id="_idIndexMarker1173"/><st c="31759"> helps identify who can offer support if there are any technical issues with the </st><span class="No-Break"><st c="31840">catalog item.</st></span></p>
			<p><st c="31853">A full description of attributes</st><a id="_idIndexMarker1174"/><st c="31886"> can be found on this documentation </st><span class="No-Break"><st c="31922">page: </st></span><a href="https://learn.microsoft.com/en-us/power-platform/developer/submit-catalog-items"><span class="No-Break"><st c="31928">https://learn.microsoft.com/en-us/power-platform/developer/submit-catalog-items</st></span></a><span class="No-Break"><st c="32007">.</st></span></p>
			<h3><st c="32008">Example – submitting items to the catalog</st></h3>
			<p><st c="32050">Imagine we have a template</st><a id="_idIndexMarker1175"/><st c="32077"> app, built as a canvas app in Power Apps. </st><st c="32120">This will represent our templatized canvas app. </st><st c="32168">Along with the app, we could also have additional components as part of the solution, such as flows, Dataverse tables, and more. </st><st c="32297">All of that is packaged in </st><span class="No-Break"><st c="32324">a solution.</st></span></p>
			<p><st c="32335">From the catalog process perspective, in the creation stage, we are working on our solution. </st><st c="32429">In the previous chapters, we have already seen how we can create packages as part of the ALM process. </st><st c="32531">Now, once we have the exported solution ready, we can create a submission JSON file by running a </st><strong class="source-inline"><st c="32628">pac catalog create-submission</st></strong><st c="32657"> command. </st><st c="32667">We will need to update the submission attributes to correctly reflect our catalog item. </st><st c="32755">We will update the business category, provide publisher details, and modify the catalog item definition, by providing the ID, display name, description, contacts, and other required attributes. </st><st c="32949">An example of a submission JSON file for an example solution is uploaded in a chapter folder in the book’s GitHub </st><span class="No-Break"><st c="33063">repository (</st></span><a href="https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/tree/main/Chapter09"><span class="No-Break"><st c="33075">https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/tree/main/Chapter09</st></span></a><span class="No-Break"><st c="33175">).</st></span></p>
			<p><st c="33178">When we are ready with the JSON file and would like to start the </st><strong class="source-inline"><st c="33244">submit</st></strong><st c="33250"> process, we use </st><strong class="source-inline"><st c="33267">pac catalog submit --path &lt;submission JSON file location&gt; –-solution-zip &lt;solution </st></strong><span class="No-Break"><strong class="source-inline"><st c="33350">file location&gt;</st></strong></span><span class="No-Break"><st c="33364">.</st></span></p>
			<p><st c="33365">If we would like to submit to a catalog in a different environment, we can add the </st><strong class="source-inline"><st c="33449">–environment</st></strong><st c="33461"> switch to the command and specify the environment. </st><st c="33513">This will produce an output similar to the </st><span class="No-Break"><st c="33556">following one:</st></span></p>
			<pre class="console"><st c="33570">
PS E:\PACKT\CH9&gt; pac catalog submit -p .\claims-submission.json -sz .\Claims_managed.zip
Connected as &lt;your_user@domain&gt;
Connected to... </st><st c="33708">&lt;your environment name&gt;
Creating package for catalog submit request...
</st><st c="33779">Tracking ID for this submission is 9dc32d51-9de4-ee11-904d-000d3a1e7712</st></pre>			<p><st c="33850">We can check the status of the submission using the </st><strong class="source-inline"><st c="33903">pac catalog status --tracking-id &lt;submission tracking id&gt; --type submit</st></strong><st c="33974"> command. </st><st c="33984">If we are submitting to a different environment, we need to also provide the environment name to the command. </st><st c="34094">The </st><strong class="source-inline"><st c="34098">type</st></strong><st c="34102"> parameter allows us to check the status of </st><strong class="source-inline"><st c="34146">install</st></strong><st c="34153"> and </st><strong class="source-inline"><st c="34158">submit</st></strong><st c="34164"> operations. </st><st c="34177">The preceding command would generate a similar output to the following, which also demonstrates the use of short aliases for tracking ID </st><span class="No-Break"><st c="34314">and type:</st></span></p>
			<pre class="console"><st c="34323">
PS E:\PACKT\CH9&gt; pac catalog status -id 9dc32d51-9de4-ee11-904d-000d3a1e7712 -t submit
Connected as &lt;your_user@domain&gt;
Connected to... </st><st c="34459">&lt;your environment name&gt;
Status of the Submit request: Submitted</st></pre>			<p><st c="34522">If the status is </st><strong class="source-inline"><st c="34540">Failed Prevalidation</st></strong><st c="34560">, we can check the details of the error in the Catalog Manager, under </st><span class="No-Break"><strong class="bold"><st c="34630">Failed Pre-Validation</st></strong></span><span class="No-Break"><st c="34651">.</st></span></p>
			<p><st c="34652">Now that we see our status</st><a id="_idIndexMarker1176"/><st c="34679"> as </st><strong class="source-inline"><st c="34683">Submitted</st></strong><st c="34692">, the second stage of the catalog process (submit) is complete and we are moving to the next stage (approve and store). </st><st c="34812">Our catalog items are submitted for approval. </st><st c="34858">The approval can be seen in the Catalog Manager application either in the dashboard section of </st><strong class="bold"><st c="34953">Approval Request Status</st></strong><st c="34976"> or in </st><strong class="bold"><st c="34983">Approvals</st></strong><st c="34992"> | </st><span class="No-Break"><strong class="bold"><st c="34995">Request</st></strong></span><span class="No-Break"><st c="35002">.</st></span></p>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="image/B22208_09_4.jpg" alt="Figure 9.4 – Approval request for submitted catalog items"/><st c="35003"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="35604">Figure 9.4 – Approval request for submitted catalog items</st></p>
			<p><st c="35661">Once the catalog item gets approved, it gets stored in the catalog and can be found by going to the Catalog Manager and navigating to </st><strong class="bold"><st c="35796">Catalog Items</st></strong><st c="35809">. Publishers will also be visible in </st><strong class="bold"><st c="35846">Catalog Publishers</st></strong><st c="35864"> and engineering and support contacts are added to the </st><strong class="bold"><st c="35919">Contact </st></strong><span class="No-Break"><strong class="bold"><st c="35927">Info</st></strong></span><span class="No-Break"><st c="35931"> list.</st></span></p>
			<p><st c="35937">Pro-developers will find a convenient attribute</st><a id="_idIndexMarker1177"/><st c="35985"> in the catalog item details that can provide a </st><strong class="bold"><st c="36033">Code Repository</st></strong><st c="36048"> link, which can be found in the </st><strong class="bold"><st c="36081">Links and Legal</st></strong><st c="36096"> section of the catalog item. </st><st c="36126">This allows us to inform pro-developers where the source code is located, which only improves the InnerSource methodology described earlier, as now pro-developers can also review the code and contribute to the </st><span class="No-Break"><st c="36336">development process.</st></span></p>
			<h3><st c="36356">Example – installing a catalog item from the catalog</st></h3>
			<p><st c="36409">We are moving now to the discovery phase</st><a id="_idIndexMarker1178"/><st c="36450"> of the catalog process. </st><st c="36475">Here, app makers or pro-developers review the catalog or use the PAC CLI to list any catalog item from a given catalog by using the </st><strong class="source-inline"><st c="36607">pac catalog list</st></strong><st c="36623"> command. </st><st c="36633">This returns all catalog items inside an environment. </st><st c="36687">We can also use </st><strong class="source-inline"><st c="36703">--catalog-item-name</st></strong><st c="36722"> or </st><strong class="source-inline"><st c="36726">--catalog-item-id</st></strong><st c="36743"> as an additional search mechanism, to find only specific catalog items by name </st><span class="No-Break"><st c="36823">or ID.</st></span></p>
			<p><st c="36829">Once we have reviewed the catalog items and are determined to test them out in our development environment, we can install an item by using </st><strong class="source-inline"><st c="36970">pac catalog install --catalog-item-id &lt;catalog-item-id&gt; --environment &lt;your environment guid or absolute https URL&gt;</st></strong><st c="37085">. This moves us to the final stage of the catalog process, </st><span class="No-Break"><st c="37144">called acquisition.</st></span></p>
			<p><st c="37163">Keep in mind that if we plan to install the catalog item in another environment, we need to have the Catalog Manager installed in that environment </st><span class="No-Break"><st c="37311">as well.</st></span></p>
			<p><st c="37319">Once we run the command, we will get output similar </st><span class="No-Break"><st c="37372">to this:</st></span></p>
			<pre class="console"><st c="37380">
PS E:\PACKT\CH9&gt; pac catalog install -env https://&lt;orgid&gt;.crm.dynamics.com/ -cid 1cd8fe87-f508-51ad-8dcd-d12dda7d8668
Connected as &lt;user@domain&gt;
Connected to... </st><st c="37542">&lt;your environment name&gt;
Tracking ID for this installation is 34f8e610-a7e4-ee12-904d-000d3a1d5312</st></pre>			<p><st c="37639">To discover, review, and install available catalog items using the UI, app makers can also go to Power Apps or Power Automate and click </st><strong class="bold"><st c="37776">More</st></strong><st c="37780"> | </st><strong class="bold"><st c="37783">Catalog</st></strong><st c="37790"> in the left navigation bar (be informed that this functionality is currently in public preview). </st><st c="37888">This will open the </st><strong class="bold"><st c="37907">Catalog</st></strong><st c="37914"> area where we can search across all available catalog items within one or more catalogs in our tenant. </st><st c="38018">Here, we will find all reusable published catalog items and information about personal activity in either acquiring catalog items or submitting new </st><span class="No-Break"><st c="38166">catalog items.</st></span></p>
			<div>
				<div id="_idContainer123" class="IMG---Figure">
					<img src="image/B22208_09_5.jpg" alt="Figure 9.5 – Catalog area in Power Apps"/><st c="38180"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="38757">Figure 9.5 – Catalog area in Power Apps</st></p>
			<p><st c="38796">We can proceed by using the </st><strong class="bold"><st c="38825">Get</st></strong><st c="38828"> button for each catalog item that we would like to install in a current environment, following the installation wizard, and completing the </st><span class="No-Break"><st c="38968">installation process.</st></span></p>
			<p><st c="38989">Now that the item has been installed either using the UI or PAC CLI, we can use this new component. </st><st c="39090">If the solution is deployed as unmanaged to a development environment with the intention of further developing it, we can proceed with developing it to our needs and then follow the ALM process to get it deployed to the production environment with the </st><span class="No-Break"><st c="39342">created changes.</st></span></p>
			<p><st c="39358">Let’s not forget that the catalog</st><a id="_idIndexMarker1179"/><st c="39392"> process is continuous and involves development and deployment to the catalog for further reuse. </st><st c="39489">As developers, we will spend more time in the development phase, so let’s explore some of the additional tools that developers, using Visual Studio, can use in </st><span class="No-Break"><st c="39649">Power Platform.</st></span></p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor159"/><st c="39664">Additional tools for developers using Visual Studio</st></h2>
			<p><st c="39716">From the tooling perspective, citizen developers</st><a id="_idIndexMarker1180"/><st c="39765"> focus on using low-code/no-code</st><a id="_idIndexMarker1181"/><st c="39797"> development tools, such as Microsoft Power Platform. </st><st c="39851">Although pro-developers should also use the same low-code/no-code tool as citizen developers where possible, integrations and custom components would require custom coding, for which an IDE such as Visual Studio or VS Code will be used. </st><st c="40088">Some of the developer’s tools have already been mentioned and used in previous chapters, such as Power Platform CLI and Power Platform Build Tools, together with Azure DevOps and GitHub. </st><st c="40275">Similar to the Power Platform Tools extension for VS Code, developers who write code in Visual Studio can install the Power Platform Tools for Visual </st><span class="No-Break"><st c="40425">Studio extension.</st></span></p>
			<p><st c="40442">The Power Platform Tools extension for Visual Studio can be found in Visual Studio Marketplace, similar to what we described in </st><a href="B22208_02.xhtml#_idTextAnchor030"><span class="No-Break"><em class="italic"><st c="40571">Chapter 2</st></em></span></a><st c="40580"> for VS Code. </st><st c="40594">As a prerequisite for the installation, we will need to have at least Visual Studio 2019 or higher and .NET Framework 4.6.2, if we want to build plug-ins or </st><span class="No-Break"><st c="40751">workflow activities.</st></span></p>
			<p><st c="40771">We can install the extension</st><a id="_idIndexMarker1182"/><st c="40800"> from Visual Studio Marketplace (</st><a href="https://marketplace.visualstudio.com"><st c="40833">https://marketplace.visualstudio.com</st></a><st c="40870">) or in Visual Studio: on the top menu bar, click </st><strong class="bold"><st c="40921">Extensions</st></strong><st c="40931"> | </st><strong class="bold"><st c="40934">Manage Extensions</st></strong><st c="40951">. Once the new window for managing extensions opens, we must make sure that we have selected </st><strong class="bold"><st c="41044">Online</st></strong><st c="41050"> | </st><strong class="bold"><st c="41053">Visual Studio Marketplace</st></strong><st c="41078"> on the left menu bar. </st><st c="41101">Now, we can search for </st><strong class="source-inline"><st c="41124">Power Platform</st></strong><st c="41138"> in the search bar and click </st><strong class="bold"><st c="41167">Download</st></strong><st c="41175">. When the download completes, we must restart Visual Studio for the scheduled extension installation </st><span class="No-Break"><st c="41277">to complete.</st></span></p>
			<div>
				<div id="_idContainer124" class="IMG---Figure">
					<img src="image/B22208_09_6.jpg" alt="Figure 9.6 – Installing the extension for Visual Studio"/><st c="41289"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="42312">Figure 9.6 – Installing the extension for Visual Studio</st></p>
			<p><st c="42367">Uninstallation can be done</st><a id="_idIndexMarker1183"/><st c="42394"> in a similar way as installation. </st><st c="42429">Go to </st><strong class="bold"><st c="42435">Extensions</st></strong><st c="42445"> | </st><strong class="bold"><st c="42448">Manage Extensions</st></strong><st c="42465">. This time, select </st><strong class="bold"><st c="42485">Installed</st></strong><st c="42494"> in the left navigation bar, find the Power Platform Tools extension, and </st><span class="No-Break"><st c="42568">click </st></span><span class="No-Break"><strong class="bold"><st c="42574">Uninstall</st></strong></span><span class="No-Break"><st c="42583">.</st></span></p>
			<p><st c="42584">The extension will only be visible</st><a id="_idIndexMarker1184"/><st c="42619"> when we either create a new project using Power Platform project templates or open an existing project that already contains at least one project created with the Power Platform </st><span class="No-Break"><st c="42798">Tools template.</st></span></p>
			<p><st c="42813">We can also show </st><strong class="bold"><st c="42831">Power Platform Explorer</st></strong><st c="42854"> after we first connect to the Dataverse environment. </st><st c="42908">We can do that by selecting </st><strong class="bold"><st c="42936">Tools</st></strong><st c="42941"> in the top menu bar and then clicking </st><strong class="bold"><st c="42980">Connect </st></strong><span class="No-Break"><strong class="bold"><st c="42988">to Dataverse…</st></strong></span><span class="No-Break"><st c="43001">.</st></span></p>
			<div>
				<div id="_idContainer125" class="IMG---Figure">
					<img src="image/B22208_09_7.jpg" alt="Figure 9.7 – Connecting to Dataverse from Visual Studio"/><st c="43002"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="43404">Figure 9.7 – Connecting to Dataverse from Visual Studio</st></p>
			<p><st c="43459">This will open a new wizard</st><a id="_idIndexMarker1185"/><st c="43487"> window, where we will authenticate with our user to our Dataverse environment. </st><st c="43567">For the login deployment type, we select </st><strong class="bold"><st c="43608">Office 365</st></strong><st c="43618"> since this will allow us to use Microsoft Entra ID as the authentication provider. </st><st c="43702">Once we authenticate with our user, we will be prompted to select the solution in which we will </st><span class="No-Break"><st c="43798">be operating.</st></span></p>
			<p><st c="43811">If all steps complete successfully, then Power Platform Explorer</st><a id="_idIndexMarker1186"/><st c="43876"> should appear in front of us, connected to the environment in which the selected solution resides. </st><st c="43976">We have a chance now to explore our environment and add plug-ins to the selected tables, register webhooks, add workflow activities, and more. </st><st c="44119">Note that for the developing custom workflow activity, we need to have installed </st><strong class="bold"><st c="44200">Windows Workflow Foundation</st></strong><st c="44227">. This can be installed through Visual Studio Installer by selecting </st><strong class="bold"><st c="44296">Modify</st></strong><st c="44302"> on the version of Visual Studio that we use for the development. </st><st c="44368">Once in Installer, a window for modifying installation will open. </st><st c="44434">Here, we select </st><strong class="bold"><st c="44450">Individual components</st></strong><st c="44471"> and search for the Windows Workflow Foundation. </st><st c="44520">We select it and click </st><strong class="bold"><st c="44543">Modify</st></strong><st c="44549">, which will download and install </st><span class="No-Break"><st c="44583">the functionality.</st></span></p>
			<div>
				<div id="_idContainer126" class="IMG---Figure">
					<img src="image/B22208_09_8.jpg" alt="Figure 9.8 – Power Platform Explorer"/><st c="44601"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="44863">Figure 9.8 – Power Platform Explorer</st></p>
			<p><st c="44899">Power Platform Tools for Visual Studio offers a set of project templates that allow us to use the C# programming language to develop the aforementioned Power Platform plug-ins, custom workflow activity, solution templates, and packages that are used to deploy solution and custom code libraries to our </st><span class="No-Break"><st c="45202">Dataverse environment.</st></span></p>
			<p><st c="45224">Developers who are using Visual Studio to develop</st><a id="_idIndexMarker1187"/><st c="45274"> backend APIs can also extend</st><a id="_idIndexMarker1188"/><st c="45303"> the capabilities of Visual Studio with </st><strong class="bold"><st c="45343">Connected Services</st></strong><st c="45361"> in order to create customer connectors in Power Platform. </st><st c="45420">In order to leverage this capability, we should be using at least Visual Studio 2022, version 17.7, with ASP.NET and the web development workload installed. </st><st c="45577">This is a capability that, at this moment, is not enabled in Visual Studio for Mac. </st><st c="45661">Our API should be developed as an ASP.NET Core Web </st><span class="No-Break"><st c="45712">API project.</st></span></p>
			<p><st c="45724">We will be talking more about custom</st><a id="_idIndexMarker1189"/><st c="45761"> connectors, code components, and pro-developer</st><a id="_idIndexMarker1190"/><st c="45808"> extensibilities in </st><a href="B22208_10.xhtml#_idTextAnchor172"><span class="No-Break"><em class="italic"><st c="45828">Chapter 10</st></em></span></a><span class="No-Break"><st c="45838">.</st></span></p>
			<p><st c="45839">Now that we have all the tools ready, we can look at how Power Platform can be integrated with </st><span class="No-Break"><st c="45935">Azure services.</st></span></p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor160"/><st c="45950">Microsoft Azure and Power Platform together</st></h1>
			<p><st c="45994">This section focuses on explaining the most commonly used Azure services in the integration scenarios with Power Platform. </st><st c="46118">We have grouped these services into workloads specific to the capabilities they provide and briefly described them. </st><st c="46234">For each workload, we provide an example of how the Azure service could be used with </st><span class="No-Break"><st c="46319">Power Platform.</st></span></p>
			<p><st c="46334">Microsoft Azure, as a cloud platform, allows</st><a id="_idIndexMarker1191"/><st c="46379"> us to run different workloads in the cloud, such as hosting our applications entirely in Azure or extending and connecting our on-premise applications with Azure services. </st><st c="46552">As we have seen in previous chapters, when organizations are modernizing their applications or building new applications, they always have a chance to select the path of using a low-code/no-code development approach to modernize existing apps or build new ones. </st><st c="46814">However, many times, scenarios are too complex and require teams to work as a fusion team, where pro-developers focus on developing complex scenarios with the services that </st><span class="No-Break"><st c="46987">Azure provides.</st></span></p>
			<p><st c="47002">Microsoft Azure, with its vast array of cloud computing services, can cover complex scenarios that span compute services, networking, storage, web services, and more. </st><st c="47170">Let’s take a look at some Azure services that are widely used with Power Platform. </st><st c="47253">We will not be able to cover all of them, as there are too many options, so we encourage you to navigate</st><a id="_idIndexMarker1192"/><st c="47357"> to the Azure </st><strong class="bold"><st c="47371">Products</st></strong><st c="47379"> web page to read more about </st><span class="No-Break"><st c="47408">them: </st></span><a href="https://azure.microsoft.com/en-us/products"><span class="No-Break"><st c="47414">https://azure.microsoft.com/en-us/products</st></span></a><span class="No-Break"><st c="47456">.</st></span></p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor161"/><st c="47457">Application hosting services</st></h2>
			<p><st c="47486">Azure provides a wide range</st><a id="_idIndexMarker1193"/><st c="47514"> of services that are able to host applications. </st><st c="47563">They have different purposes, from services that can run Spring Boot applications to container hosting services to multi-purpose web hosting services, such as Azure </st><span class="No-Break"><st c="47728">App Service:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="47740">Azure App Service</st></strong><st c="47758"> is a managed service that allows</st><a id="_idIndexMarker1194"/><st c="47791"> us to host web applications, Web APIs, and mobile backends. </st><st c="47852">Since it is a managed PaaS service, it is up to the cloud provider to maintain the operating system and underlying infrastructure, while we focus on building the application. </st><st c="48027">It is a scalable, enterprise-grade service that allows applications to be scaled automatically depending on the load while keeping a high degree </st><span class="No-Break"><st c="48172">of security.</st></span></li>
				<li><strong class="bold"><st c="48184">Azure Container Apps</st></strong><st c="48205"> is a serverless platform designed to run</st><a id="_idIndexMarker1195"/><st c="48246"> containerized applications. </st><st c="48275">Compared to </st><strong class="bold"><st c="48287">Azure Kubernetes Service</st></strong><st c="48311"> (</st><strong class="bold"><st c="48313">AKS</st></strong><st c="48316">), a managed Kubernetes cluster</st><a id="_idIndexMarker1196"/><st c="48348"> in which we need to manage nodes attached to the AKS cluster, with Azure Container Apps, we get a fully managed Kubernetes service that provides automatic scaling of our application workloads without the need to manage </st><span class="No-Break"><st c="48568">the infrastructure.</st></span></li>
			</ul>
			<p><st c="48587">Let’s look at a Power Platform</st><a id="_idIndexMarker1197"/><st c="48618"> integration example. </st><st c="48640">Both of the preceding services are used for running either frontend applications or backend API endpoints. </st><st c="48747">We can use them to run background processing jobs or to build and run our Web APIs. </st><st c="48831">When we choose containers as the packaging and deployment option, we can also deploy our microservices to Azure Container Apps or similar container-running services on Azure. </st><st c="49006">These APIs will be exposed securely through Azure API Management and will serve as a backend for our </st><span class="No-Break"><st c="49107">custom connectors.</st></span></p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor162"/><st c="49125">Integration Services</st></h2>
			<p><st c="49146">Azure Integration Services is a set of Azure</st><a id="_idIndexMarker1198"/><st c="49191"> services that allow organizations to build solutions that connect different systems and applications together. </st><st c="49303">They can be used to provide a highly secure messaging platform, build ETL processes, and perform data transformation, or to securely expose backend systems through APIs for internal and </st><span class="No-Break"><st c="49489">external use:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="49502">Azure API Management</st></strong><st c="49523"> (</st><strong class="bold"><st c="49525">Azure APIM</st></strong><st c="49535">) enables organizations to manage APIs and expose</st><a id="_idIndexMarker1199"/><st c="49585"> them to other applications easily and securely. </st><st c="49634">It is built from three components: the gateway, developer portal, and admin management plane. </st><st c="49728">Backend applications and data can reside in Azure or in other environments (including on-premises) while providing the clients with this front door, which allows routing requests to the backend while keeping control of the request and </st><span class="No-Break"><st c="49963">response flow.</st></span><p class="list-inset"><strong class="bold"><st c="49977">Power Platform integration example</st></strong><st c="50012">: Once we have APIs ready, exposing them through Azure APIM</st><a id="_idIndexMarker1200"/><st c="50072"> enables us to quickly create custom connectors in Power Platform. </st><st c="50139">Custom connectors will be used in our applications </st><span class="No-Break"><st c="50190">or flows.</st></span></p></li>
				<li><strong class="bold"><st c="50199">Azure Functions</st></strong><st c="50215"> is an event-driven, serverless compute platform that allows developers to use </st><a id="_idIndexMarker1201"/><st c="50294">event-driven triggers and bindings to connect functions to other services and execute the application logic. </st><st c="50403">Since it is a serverless platform, the overhead of managing the cloud infrastructure is managed by the cloud provider and the platform. </st><st c="50539">Azure Functions are commonly used in scenarios where processing data needs to be done (such as responding to an event, database changes, or reading requests that are stored in Azure Service Bus) or where data is captured from different IoT streams and needs to be processed in </st><span class="No-Break"><st c="50816">real time.</st></span><p class="list-inset"><strong class="bold"><st c="50826">Power Platform integration example</st></strong><st c="50861">: Azure Functions is used for processing data</st><a id="_idIndexMarker1202"/><st c="50907"> that is stored in a data store, including Dataverse. </st><st c="50961">It allows implementing Web APIs through REST endpoints to perform specific complex logic. </st><st c="51051">Such APIs can be connected through custom connectors with our Power Platform solution to perform an </st><span class="No-Break"><st c="51151">API operation.</st></span></p></li>
				<li><strong class="bold"><st c="51165">Azure Service Bus</st></strong><st c="51183"> is an asynchronous messaging cloud </st><a id="_idIndexMarker1203"/><st c="51219">platform that allows us to create reliable messaging solutions. </st><st c="51283">It is designed to enable application decoupling and building </st><span class="No-Break"><st c="51344">scalable systems.</st></span><p class="list-inset"><strong class="bold"><st c="51361">Power Platform integration example</st></strong><st c="51396">: It allows us to enable asynchronous communication between</st><a id="_idIndexMarker1204"/><st c="51456"> applications and backend services in order to decouple applications and services from each other. </st><st c="51555">Using the Service Bus connector in Power Platform, we can perform operations such as sending or receiving messages </st><span class="No-Break"><st c="51670">to/from queues.</st></span></p></li>
				<li><strong class="bold"><st c="51685">Azure Logic Apps</st></strong><st c="51702"> is a cloud platform to create</st><a id="_idIndexMarker1205"/><st c="51732"> and run automated workflows, similar to Power Automate, with more emphasis on pro-developers and IT professionals. </st><st c="51848">It has some unique capabilities that Power Automate does not have, such as utilizing Visual Studio and VS Code with extensions in order to develop and review workflows </st><span class="No-Break"><st c="52016">through code.</st></span><p class="list-inset"><strong class="bold"><st c="52029">Power Platform integration example</st></strong><st c="52064">: It can be used to automate Azure-related tasks or more</st><a id="_idIndexMarker1206"/><st c="52121"> complex processes that are not Power Platform solution-related. </st><st c="52186">We can build custom connectors that are connected to Logic Apps workflows and run the workflow through custom connectors in Power Automate or </st><span class="No-Break"><st c="52328">Power Apps.</st></span></p></li>
			</ul>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor163"/><st c="52339">Data analytics</st></h2>
			<p><st c="52354">Azure offers a set of data analytics</st><a id="_idIndexMarker1207"/><st c="52391"> services that help us gain insights into the data stored anywhere, enable real-time data streaming from IoT devices, take care of the telemetry ingestion, </st><span class="No-Break"><st c="52547">and more:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="52556">Azure Event Hubs</st></strong><st c="52573"> brings a common point to integration</st><a id="_idIndexMarker1208"/><st c="52610"> scenarios where applications need to respond to events that are happening in real time. </st><st c="52699">It allows the ingestion of real-time event data from different sources. </st><st c="52771">It is very common to use it when working with IoT scenarios or application monitoring. </st><st c="52858">Since Power Platform includes a connector for Azure Event Hubs, we can build integrations </st><span class="No-Break"><st c="52948">more easily.</st></span><p class="list-inset"><strong class="bold"><st c="52960">Power Platform integration example</st></strong><st c="52995">: When an IoT device sends data to IoT Hub, that data gets</st><a id="_idIndexMarker1209"/><st c="53054"> processed by Azure Functions and sent to Azure Event Hubs. </st><st c="53114">When events are available in Event Hubs, a Power Automate flow gets triggered and performs </st><span class="No-Break"><st c="53205">the logic.</st></span></p></li>
				<li><strong class="bold"><st c="53215">Microsoft Fabric</st></strong><st c="53232"> is a single unified analytics platform</st><a id="_idIndexMarker1210"/><st c="53271"> that connects tools such as Azure Data Factory, Azure Synapse Analytics, and Power BI together. </st><st c="53368">Fabric includes</st><a id="_idIndexMarker1211"/><st c="53383"> a multi-cloud data lake, called OneLake, which sits underneath the mentioned Fabric tools and helps eliminate data silos. </st><st c="53506">OneLake works as a single storage system allowing organizations to combine data from different data sources, including Dynamics 365 data. </st><st c="53644">Once data is represented in OneLake, organizations can perform different types of analytics in </st><span class="No-Break"><st c="53739">Microsoft Fabric.</st></span><p class="list-inset"><strong class="bold"><st c="53756">Power Platform integration example</st></strong><st c="53791">: Recently, Power Platform introduced a Dataverse </st><a id="_idIndexMarker1212"/><st c="53842">integration with Microsoft Fabric. </st><st c="53877">It opens possibilities to connect Dataverse to Fabric, using </st><strong class="bold"><st c="53938">Link to Fabric</st></strong><st c="53952">, and a scenario where Fabric</st><a id="_idIndexMarker1213"/><st c="53981"> is connected to Dataverse, using virtual tables. </st><st c="54031">Link to Fabric allows organizations to keep the data in Dataverse while enabling analytical capabilities in Fabric to find insights into the data. </st><st c="54178">These insights can be sent back to Dataverse in the format of virtual tables, which allows developers to utilize these findings in a business process. </st><st c="54329">Similar to before where data stayed in Dataverse, here, data resides </st><span class="No-Break"><st c="54398">in OneLake.</st></span></p></li>
			</ul>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor164"/><st c="54409">AI services</st></h2>
			<p><strong class="bold"><st c="54421">Azure AI services</st></strong><st c="54439"> are a set of REST APIs and client library SDKs</st><a id="_idIndexMarker1214"/><st c="54486"> that enable pro-developers to create intelligent applications with pre-built and customizable AI models that have cognitive capabilities such as natural language understanding through conversation, speech capabilities, vision, and more. </st><st c="54724">Azure AI services are an umbrella for services such as Azure OpenAI, Azure AI Search, Vision, Speech, </st><span class="No-Break"><st c="54826">and more.</st></span></p>
			<p><st c="54835">Let’s look at a Power Platform integration example. </st><st c="54888">Although Power Platform includes AI Builder, which utilizes some of these pre-built models, Azure AI services allow additional capabilities, such as integrating speech-to-text and text-to-speech capabilities or utilizing other AI models</st><a id="_idIndexMarker1215"/><st c="55124"> in our </st><span class="No-Break"><st c="55132">business applications.</st></span></p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor165"/><st c="55154">Data storage</st></h2>
			<p><strong class="bold"><st c="55167">Azure SQL Database</st></strong><st c="55186"> is a fully managed relational database. </st><st c="55227">It is a PaaS deployment of Azure SQL that enables</st><a id="_idIndexMarker1216"/><st c="55276"> hyperscale (unlimited database storage) and autoscaling. </st><st c="55334">As many organizations are already utilizing SQL Server for their database systems, such an option enables them to modernize their database and eliminate the need to manage </st><span class="No-Break"><st c="55506">the infrastructure.</st></span></p>
			<p><st c="55525">Let’s look at a Power Platform integration example. </st><st c="55578">Power Platform meets customers where they are with their data. </st><st c="55641">This is why there are more than 1,000 connectors available in Power Platform, and one of them is also for connecting to SQL Servers. </st><st c="55774">This allows us to build applications and flows that connect to the existing </st><span class="No-Break"><st c="55850">data sources.</st></span></p>
			<p><st c="55863">Azure provides additional database services. </st><st c="55909">Depending on the need of the project, we could utilize other relational databases, such as PostgreSQL, MySQL, or MariaDB, or non-relational database services such as Cosmos DB. </st><st c="56086">For each of these data services, there is a connector that we can use to build our automation flows or business applications using the </st><span class="No-Break"><st c="56221">existing databases.</st></span></p>
			<p><st c="56240">The aforementioned services are just a handful of services in the pool of all the available options on Azure. </st><st c="56351">When planning a project, consult with a solution architect or enterprise architect in the organization who has a knowledge of cloud computing to determine which services are best suited for the </st><span class="No-Break"><st c="56545">planned project.</st></span></p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor166"/><st c="56561">Example of an Azure and Power Platform integration scenario</st></h1>
			<p><st c="56621">This section focuses on a practical example</st><a id="_idIndexMarker1217"/><st c="56665"> that demonstrates how fusion teams could work together. </st><st c="56722">This case shows a connection between Power Platform and Azure through the use of custom connectors and Azure services, such as Azure </st><span class="No-Break"><st c="56855">API Management.</st></span></p>
			<p><st c="56870">For the example in this chapter, we focus on integrating Web API templates written in the C# programming language in Visual Studio 2022, with Power Platform as a custom connector. </st><st c="57051">We have already installed Power Platform Tools in Visual Studio 2022 in the previous chapter. </st><st c="57145">This will demonstrate how pro-developers can use modern tools to build and test Web APIs that support business applications in Power Apps. </st><st c="57284">The Web API will be deployed to the Azure service and exposed over Azure </st><span class="No-Break"><st c="57357">API Management.</st></span></p>
			<p><st c="57372">Here, we will introduce two ways of creating a custom connector: one with the support of Visual Studio 2022 and the other with the support of Azure </st><span class="No-Break"><st c="57521">API Management.</st></span></p>
			<p><st c="57536">Once a custom connector is created, our citizen developers can use operations in Power Platform in their </st><span class="No-Break"><st c="57642">business solution.</st></span></p>
			<p><st c="57660">The next chapter will focus on the ALM process for many different Power Platform components, so here we will be showing</st><a id="_idIndexMarker1218"/><st c="57780"> the concept of the fusion </st><span class="No-Break"><st c="57807">development approach.</st></span></p>
			<p><st c="57828">Let’s jump into creating a Web </st><span class="No-Break"><st c="57860">API first.</st></span></p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor167"/><st c="57870">Creating a Web API and a Power Platform custom connector with Visual Studio 2022</st></h2>
			<p><st c="57951">We will put on our pro-developer</st><a id="_idIndexMarker1219"/><st c="57984"> hats and create our sample API using</st><a id="_idIndexMarker1220"/><st c="58021"> the ASP.NET Core Web API template in Visual Studio 2022. </st><st c="58079">We will do this to demonstrate the capabilities that pro-developers gain using Visual Studio while working in the fusion development team on a project that will mainly reside on Power </st><span class="No-Break"><st c="58263">Platform services.</st></span></p>
			<p><st c="58281">When Visual Studio starts, it welcomes us with a window in which we can create a new project by clicking on the </st><strong class="bold"><st c="58394">Create a new project</st></strong><st c="58414"> button. </st><st c="58423">This will take us to the next screen, where we will select a template for our project. </st><st c="58510">We will search for </st><strong class="source-inline"><st c="58529">web api</st></strong><st c="58536">, select the </st><strong class="bold"><st c="58549">ASP.NET Core Web API</st></strong><st c="58569"> template in the C# language, and click </st><strong class="bold"><st c="58609">Next</st></strong><st c="58613">, as shown in the </st><span class="No-Break"><st c="58631">following figure:</st></span></p>
			<div>
				<div id="_idContainer127" class="IMG---Figure">
					<img src="image/B22208_09_9.jpg" alt="Figure 9.9 – Creating a new Web API project"/><st c="58648"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="59634">Figure 9.9 – Creating a new Web API project</st></p>
			<p><st c="59677">On the next</st><a id="_idIndexMarker1221"/><st c="59689"> screen, we will</st><a id="_idIndexMarker1222"/><st c="59705"> provide our </st><strong class="bold"><st c="59718">Project name</st></strong><st c="59730">, </st><strong class="bold"><st c="59732">Location</st></strong><st c="59740"> (where to save the project), and </st><strong class="bold"><st c="59774">Solution name</st></strong><st c="59787"> details. </st><st c="59797">After providing the location and names, we can click </st><strong class="bold"><st c="59850">Next</st></strong><st c="59854"> to get to the final screen, where we can select the framework and other additional information for the project, such as whether we would like to enable HTTPS, Docker, and so on. </st><st c="60033">We will keep the default options here, with the LTS version of .NET 8.0, and click </st><strong class="bold"><st c="60116">Create</st></strong><st c="60122">. Our Web API template is now ready with one </st><strong class="source-inline"><st c="60167">GET</st></strong><st c="60170"> operation, called </st><strong class="source-inline"><st c="60189">WeatherForecast</st></strong><st c="60204">, which is already part of </st><span class="No-Break"><st c="60231">the template.</st></span></p>
			<p><st c="60244">As part of the DevOps experience, our task would be to version control our code, which would mean that we either create a new project in Azure DevOps or GitHub or use an existing project for this part of the project, and then commit our code to the repository with the initial commit. </st><st c="60530">We enable branch protection on the </st><strong class="source-inline"><st c="60565">main</st></strong><st c="60569"> branch and configure other policies, as we have learned in previous chapters. </st><st c="60648">At this point, our pro-developers who are working on the API can continue their work following the DevOps </st><span class="No-Break"><st c="60754">best practices.</st></span></p>
			<p><st c="60769">Coming back to our example, we can test the newly created project or continue with development and remove the existing </st><strong class="source-inline"><st c="60889">WeatherForecast</st></strong><st c="60904"> operation and go ahead and develop the API operations that the business project that we are working on is requesting </st><span class="No-Break"><st c="61022">from us.</st></span></p>
			<p><st c="61030">When we want to test </st><a id="_idIndexMarker1223"/><st c="61052">our developed API, we can simply hit </st><em class="italic"><st c="61089">F5</st></em><st c="61091"> on our keyboard to launch</st><a id="_idIndexMarker1224"/><st c="61117"> a debugging process or head over to the top navigation bar, expand </st><strong class="bold"><st c="61185">Debug</st></strong><st c="61190">, and select </st><strong class="bold"><st c="61203">Start Debugging</st></strong><st c="61218"> to launch our API in a browser. </st><st c="61251">This will open the Swagger UI, which shows our Swagger file with all the operations that exist in our Web API. </st><st c="61362">Swagger provides a convenient way to design, document, and consume our API. </st><st c="61438">It uses </st><strong class="bold"><st c="61446">OpenAPI</st></strong><st c="61453"> specification and provides a set of open source</st><a id="_idIndexMarker1225"/><st c="61501"> and commercial tools to work with the Swagger file, which is in a JSON format describing our API operations. </st><st c="61611">An OpenAPI definition is also consumed by Power Platform when creating a custom connector</st><a id="_idIndexMarker1226"/><st c="61700"> and it needs to be in OpenAPI 2.0 (previously known as </st><span class="No-Break"><st c="61756">Swagger) format.</st></span></p>
			<p><st c="61772">When we are ready with our API and would like to test it in the Power Apps application or Power Automate flow, we can add Power Platform as a connected service. </st><st c="61934">This way, Visual Studio will automatically create a custom connector for us in Power Platform. </st><st c="62029">To do this, we head to our Web API project in Visual Studio. </st><st c="62090">Inside </st><strong class="bold"><st c="62097">Solution Explorer</st></strong><st c="62114">, we expand our project so that we are able to see </st><strong class="bold"><st c="62165">Connected Services</st></strong><st c="62183"> | </st><strong class="bold"><st c="62186">Add</st></strong><st c="62189"> | </st><strong class="bold"><st c="62192">Microsoft Power Platform</st></strong><st c="62216">. This will open a new tab, opened in the </st><strong class="bold"><st c="62258">Connected Services</st></strong><st c="62276"> part, and a </st><strong class="bold"><st c="62289">Connect to Microsoft Power </st></strong><span class="No-Break"><strong class="bold"><st c="62316">Platform</st></strong></span><span class="No-Break"><st c="62324"> window:</st></span></p>
			<div>
				<div id="_idContainer128" class="IMG---Figure">
					<img src="image/B22208_09_10.jpg" alt="Figure 9.10 – Adding Power Platform as a connected service"/><st c="62332"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="62796">Figure 9.10 – Adding Power Platform as a connected service</st></p>
			<p><st c="62854">This new window holds all parameters for a new custom connector. </st><st c="62920">Before creating it, we need to make sure that we are signed in. </st><st c="62984">If not, in the top-right corner, we can sign in and provide the right credentials of the user. </st><st c="63079">Once authenticated, we select a Power Platform environment into which we would like to deploy our custom connector. </st><st c="63195">In the </st><strong class="bold"><st c="63202">Power Platform Solutions</st></strong><st c="63226"> dropdown, we select the solution in which the connector will </st><span class="No-Break"><st c="63288">be deployed.</st></span></p>
			<p><st c="63300">Next, we connect</st><a id="_idIndexMarker1227"/><st c="63317"> to the custom</st><a id="_idIndexMarker1228"/><st c="63331"> connector. </st><st c="63343">In our case, we are creating it for the first time, so we will click </st><strong class="bold"><st c="63412">+</st></strong><st c="63413"> (the plus icon) to create a new custom connector. </st><st c="63464">We will check </st><strong class="bold"><st c="63478">Auto-generate the OpenAPI V2 specification</st></strong><st c="63520"> so that Visual Studio generates the OpenAPI definition for us. </st><st c="63584">Lastly, we will create a </st><strong class="bold"><st c="63609">public dev tunnel</st></strong><st c="63626"> by clicking </st><strong class="bold"><st c="63639">+</st></strong><st c="63640"> (the plus icon) next</st><a id="_idIndexMarker1229"/><st c="63661"> to </st><strong class="bold"><st c="63665">Select a public dev tunnel</st></strong><st c="63691">, which will be used for debugging purposes between the custom connector and our instance of </st><span class="No-Break"><st c="63784">Visual Studio.</st></span></p>
			<p class="callout-heading"><st c="63798">Dev tunnel</st></p>
			<p class="callout"><st c="63809">Dev tunnels in Visual Studio provide a quick and secure way to test Web APIs across the internet. </st><st c="63908">In our case within Power Platform services, it will create a connection between our local machine, which is running Visual Studio, and a Power Platform service that is utilizing the custom connector (i.e., the Power Apps application using a custom connector). </st><st c="64168">This approach is intended to create ad hoc connections for development and testing purposes only, not for </st><span class="No-Break"><st c="64274">production workloads.</st></span></p>
			<p><st c="64295">The following screenshot shows</st><a id="_idIndexMarker1230"/><st c="64326"> us how a public dev tunnel</st><a id="_idIndexMarker1231"/><st c="64353"> can be created after connecting to Microsoft Power Platform. </st><st c="64415">When we click on </st><strong class="bold"><st c="64432">Next</st></strong><st c="64436">, we can see the </st><strong class="bold"><st c="64453">Summary of changes</st></strong><st c="64471"> screen, which informs us that a custom connector will be created in Microsoft Power Platform. </st><st c="64566">We confirm this by clicking </st><strong class="bold"><st c="64594">Finish</st></strong><st c="64600">. The process will build our project, configure a dev tunnel, generate a Swagger JSON file (OpenAPI specification file), and create a custom connector in our selected Power </st><span class="No-Break"><st c="64773">Platform environment:</st></span></p>
			<div>
				<div id="_idContainer129" class="IMG---Figure">
					<img src="image/B22208_09_11.jpg" alt="Figure 9.11 – Creating a custom connector"/><st c="64794"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="65285">Figure 9.11 – Creating a custom connector</st></p>
			<p><st c="65326">Now that the dev tunnel and custom connector are created, if we run our API now (by pressing </st><em class="italic"><st c="65420">F5</st></em><st c="65422"> or clicking on </st><strong class="bold"><st c="65438">Debug</st></strong><st c="65443"> | </st><strong class="bold"><st c="65446">Start Debugging</st></strong><st c="65461">), we will see that Visual Studio will use the </st><em class="italic"><st c="65509">dev tunnels</st></em><st c="65520"> feature and will expose our web API to the public endpoint, which we are also informed about in the notification that has opened in the web browser. </st><st c="65670">Once we confirm it, the dev tunnel is established and we can use a custom connector in Power Platform, which is now connected to our Visual Studio dev environment. </st><st c="65834">This is a very convenient way for debugging our Web API and custom connector. </st><st c="65912">We can now use this custom connector in any Power Apps application or other Power Platform services and set breakpoints in the source code of our Web API in Visual Studio for the debugging purposes. </st><st c="66111">We will be able to see in Visual Studio that our breakpoint was hit by debug engine once the API operation is executed . </st><st c="66232">This will allow us to continue with the </st><span class="No-Break"><st c="66272">debugging/testing process.</st></span></p>
			<p><st c="66298">As a citizen developer</st><a id="_idIndexMarker1232"/><st c="66321"> or an app maker, we can now</st><a id="_idIndexMarker1233"/><st c="66349"> see the newly created custom connector in Power Apps. </st><st c="66404">Navigate to </st><strong class="bold"><st c="66416">Power Automate</st></strong><st c="66430"> or </st><strong class="bold"><st c="66434">Power Apps</st></strong><st c="66444">. Either click on </st><strong class="bold"><st c="66462">Solutions</st></strong><st c="66471"> in the left navigation bar and open the solution that was used to deploy the custom connector from Visual Studio, or go to </st><strong class="bold"><st c="66595">Custom connectors</st></strong><st c="66612"> and find our custom connector and click </st><strong class="bold"><st c="66653">Edit</st></strong><st c="66657"> (the </st><span class="No-Break"><st c="66663">pencil icon):</st></span></p>
			<div>
				<div id="_idContainer130" class="IMG---Figure">
					<img src="image/B22208_09_12.jpg" alt="Figure 9.12 – Opening the custom connector definition"/><st c="66676"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="67132">Figure 9.12 – Opening the custom connector definition</st></p>
			<p><st c="67185">We can see that the host and the URL in the definition of the API operations are pointing to the </st><span class="No-Break"><st c="67283">dev tunnel.</st></span></p>
			<p><st c="67294">We can create a Power Apps application, a flow, or anything else in Power Platform and utilize the custom connector. </st><st c="67412">As long as the connection via the dev tunnel is active in Visual Studio, our custom connector will be able to get the results of an API operation that we will be calling. </st><st c="67583">Using the </st><strong class="source-inline"><st c="67593">pac connector list</st></strong><st c="67611"> command, we will be able to see all custom connectors registered in Dataverse and their display names and IDs. </st><st c="67723">As an example, we can use this information about connectors to create a sample canvas app from the PAC CLI. </st><st c="67831">The app</st><a id="_idIndexMarker1234"/><st c="67838"> is generated based</st><a id="_idIndexMarker1235"/><st c="67857"> on the OpenAI definition from a </st><span class="No-Break"><st c="67890">custom connector:</st></span></p>
			<pre class="console"><st c="67907">
pac canvas create --msapp &lt;new-msapp-file&gt; --connector-id &lt;connector-id&gt;</st></pre>			<h2 id="_idParaDest-154"><a id="_idTextAnchor168"/><st c="67980">Creating a Power Platform custom connector with Azure APIM</st></h2>
			<p><st c="68039">Let us continue with the example. </st><st c="68074">Let’s say</st><a id="_idIndexMarker1236"/><st c="68083"> that our pro-developers </st><a id="_idIndexMarker1237"/><st c="68108">are progressing with their new Web API. </st><st c="68148">They are using DevOps principles to build, test, and deploy the Web API to a test environment. </st><st c="68243">The test environment differs from the local development machine, as this environment is now provisioned in Azure. </st><st c="68357">For our Web API to be hosted, we can choose from the plethora of application hosting services available in Azure. </st><st c="68471">We will be using Azure App Services, a PaaS service that is capable of hosting </st><span class="No-Break"><st c="68550">Web APIs.</st></span></p>
			<p><st c="68559">As with DevOps best practices, we are following an IaC approach and describing the environment in a Bicep or ARM template file. </st><st c="68688">This IaC definition file is also version-controlled in our Azure DevOps/GitHub repository, so we can keep track of changes and run validation checks over the </st><span class="No-Break"><st c="68846">template file.</st></span></p>
			<p><st c="68860">The CI/CD pipelines make sure that our Web API, as an artifact, is deployable and we deploy it automatically to the newly provisioned test environment. </st><st c="69013">Once our API is deployed to a hosting platform, we are ready to connect our Web API to Azure </st><span class="No-Break"><st c="69106">API Management.</st></span></p>
			<p><st c="69121">Azure services such as Logic Apps, App Service, Functions, and Container Apps provide a seamless integration between the Web API and the Azure APIM to register the API in APIM. </st><st c="69299">However, Azure APIM also provides options to add APIs by providing definition files, such as OpenAPI, WSDL, OData, and WADL. </st><st c="69424">Of course, we can also start completely from scratch and manually add all properties and operations of </st><span class="No-Break"><st c="69527">the API.</st></span></p>
			<div>
				<div id="_idContainer131" class="IMG---Figure">
					<img src="image/B22208_09_13.jpg" alt="Figure 9.13 – Creating new APIs in APIM"/><st c="69535"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="70529">Figure 9.13 – Creating new APIs in APIM</st></p>
			<p><st c="70568">APIM provides a convenient</st><a id="_idIndexMarker1238"/><st c="70595"> way to configure </st><em class="italic"><st c="70613">mock responses</st></em><st c="70627">. This allows to speed up development time, as pro-developers</st><a id="_idIndexMarker1239"/><st c="70688"> can add all operations to Azure APIM with mocked responses, while app makers in Power Platform utilize such an API and build the rest of the service in Power Platform. </st><st c="70857">For example, citizen developers use the custom connector that has all the operations available, but the responses are mocked by APIM. </st><st c="70991">Once the backend Web API is developed and ready to be used, pro-developers disable mock responses on the operation and leave it to the Web API to perform the logic and return correct responses. </st><st c="71185">On the other hand, the frontend that has been developed by citizen developers does not see any differences – only the returned data from the API </st><span class="No-Break"><st c="71330">is different.</st></span></p>
			<p><st c="71343">Once our API is ready to be consumed, we can create a connector in Power Platform directly from </st><span class="No-Break"><st c="71440">Azure APIM:</st></span></p>
			<div>
				<div id="_idContainer132" class="IMG---Figure">
					<img src="image/B22208_09_14.jpg" alt="Figure 9.14 – Creating a custom connector from Azure APIM"/><st c="71451"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="72427">Figure 9.14 – Creating a custom connector from Azure APIM</st></p>
			<p><st c="72484">After we click on the </st><strong class="bold"><st c="72507">Create a connector</st></strong><st c="72525"> button, the next step asks us to provide the </st><strong class="bold"><st c="72571">API</st></strong><st c="72574"> name, which will be used</st><a id="_idIndexMarker1240"/><st c="72599"> for the custom</st><a id="_idIndexMarker1241"/><st c="72614"> connector. </st><st c="72626">We need to select the one that we were working on. </st><st c="72677">Following that, we need to provide the Power Platform environment and API display name, as this will represent the custom connector that will be deployed to the selected environment. </st><st c="72860">Once we have provided this information, we can proceed by clicking on the </st><strong class="bold"><st c="72934">Create</st></strong><st c="72940"> button. </st><st c="72949">After that, a new custom connector will appear in the selected Power Platform environment and will be ready to be used by any app maker in </st><span class="No-Break"><st c="73088">Power Platform.</st></span></p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor169"/><st c="73103">Applying ALM to custom connectors</st></h2>
			<p><st c="73137">The preceding examples</st><a id="_idIndexMarker1242"/><st c="73160"> demonstrated how to create a custom connector</st><a id="_idIndexMarker1243"/><st c="73206"> through either Visual Studio or Azure APIM. </st><st c="73251">However, if we would like to use CI/CD pipelines to deploy our custom connectors to different environments, it is good to know how to follow a code-first approach to operate with custom connectors in order to deploy them to different target environments. </st><st c="73506">We will be using Power Platform CLI commands for </st><span class="No-Break"><st c="73555">these purposes.</st></span></p>
			<p><st c="73570">In order to create a custom connector using the PAC CLI, we need to obtain the API definition file and generate supporting properties files. </st><st c="73712">An API definition file is an OpenAPI 2.0 (Swagger) definition file that describes the API and its operations. </st><st c="73822">We can either create a Swagger definition file from scratch or obtain it from the existing custom connector that we created in the </st><span class="No-Break"><st c="73953">previous exercise.</st></span></p>
			<p><st c="73971">Along with the API definition file, we will require the API properties file. </st><st c="74049">An API properties file is a JSON file that holds supporting information for our connector, such as authentication information, brand color, publisher information, and </st><span class="No-Break"><st c="74216">so on.</st></span></p>
			<p><st c="74222">Optionally, we can use additional files such as icons files, script files (CSX files), and </st><span class="No-Break"><st c="74314">settings files.</st></span></p>
			<p><st c="74329">We can start creating a custom connector from scratch using the </st><strong class="source-inline"><st c="74394">pac connector init</st></strong><st c="74412"> command with additional parameters that will generate the additional files needed for the custom connector. </st><st c="74521">Next, we can see an example that generates an API properties file with an API key that will be used to authenticate requests against the custom connector. </st><st c="74676">It also generates settings files, a properties file, and a script file in a separate </st><span class="No-Break"><strong class="source-inline"><st c="74761">DemoBankAPI</st></strong></span><span class="No-Break"><st c="74772"> folder:</st></span></p>
			<pre class="console"><st c="74780">
pac connector init --connection-template "ApiKey" --generate-script-file --generate-settings-file --outputDirectory "DemoBankAPI"</st></pre>			<p><st c="74910">If we want to generate an API definition file from an existing custom connector that we have created in the previous examples, we can use the </st><strong class="source-inline"><st c="75053">pac connector list</st></strong><st c="75071"> command to get a list of all the connectors in the current environment with the connector IDs of </st><span class="No-Break"><st c="75169">each connector.</st></span></p>
			<p><st c="75184">Once we have found the connector ID information for a custom connector, we can use </st><strong class="source-inline"><st c="75268">pac connector download --connector-id &lt;CONNECTOR-ID&gt;</st></strong><st c="75320"> to download </st><strong class="source-inline"><st c="75333">apiDefinition.json</st></strong><st c="75351"> and </st><strong class="source-inline"><st c="75356">apiProperties.json</st></strong><st c="75374"> for the selected </st><span class="No-Break"><st c="75392">custom connector.</st></span></p>
			<p><st c="75409">At this point, we should already commit our files to the repository so that any modification is version-controlled. </st><st c="75526">We will perform changes to the files so that they reflect the right values for the target environment. </st><st c="75629">This means changing the </st><em class="italic"><st c="75653">host</st></em><st c="75657"> value, which is an endpoint to which our custom connector is pointing, as well as any additional </st><span class="No-Break"><st c="75755">property values.</st></span></p>
			<p><st c="75771">When we want to create</st><a id="_idIndexMarker1244"/><st c="75794"> a custom connector in a target </st><a id="_idIndexMarker1245"/><st c="75826">environment, we can use a simple </st><strong class="source-inline"><st c="75859">pac connector create --settings-file .\settings.json</st></strong><st c="75911"> command, since the settings file already includes information about all supporting files as well as the environment value for deploying to the target environment. </st><st c="76075">Next, we can see a sample </st><span class="No-Break"><strong class="source-inline"><st c="76101">settings.json</st></strong></span><span class="No-Break"><st c="76114"> file:</st></span></p>
			<pre class="source-code"><st c="76120">
{
  "connectorId": null,
  "environment": "1f9283b6-deea-eed7-899c-4da273a3f957",
  "apiProperties": "apiProperties.json",
  "apiDefinition": "apiDefinition.json",
  "icon": null,
  "script": "script.csx"
}</st></pre>			<p><st c="76315">Values in </st><strong class="source-inline"><st c="76326">settings.json</st></strong><st c="76339"> and any supporting file, such as an API properties file, which holds information for authentication, should be changed and parameterized so that we will not have values hardcoded in the file, but rather, only variable names, which get changed with actual values during the </st><span class="No-Break"><st c="76613">CI/CD pipelines.</st></span></p>
			<p><st c="76629">Another variation of the </st><strong class="source-inline"><st c="76655">create</st></strong><st c="76661"> command, using manually defined values, is </st><span class="No-Break"><st c="76705">as follows:</st></span></p>
			<pre class="console"><st c="76716">
pac connector create --environment 1f9283b6-deea-eed7-899c-4da273a3f957 --api-definition-file .\apiDefinition.json --api-properties-file .\apiProperties.json</st></pre>			<p><st c="76874">When we need to update the custom connector in the target environments, we should use </st><strong class="source-inline"><st c="76961">pac connector update --</st></strong><span class="No-Break"><strong class="source-inline"><st c="76984">settings-file .\settings.json</st></strong></span><span class="No-Break"><st c="77014">.</st></span></p>
			<p><st c="77015">Once we have a custom connector created in the target environment, we can use it to test the operations in our existing application or create a new dummy application using </st><strong class="source-inline"><st c="77188">pac canvas create --msapp &lt;new-msapp-file&gt; --connector-id &lt;connector-id&gt;</st></strong><st c="77260">. We are now ready</st><a id="_idIndexMarker1246"/><st c="77278"> to test our newly </st><span class="No-Break"><st c="77297">deployed</st></span><span class="No-Break"><a id="_idIndexMarker1247"/></span><span class="No-Break"><st c="77305"> connector.</st></span></p>
			<h1 id="_idParaDest-156"><a id="_idTextAnchor170"/><st c="77316">Summary</st></h1>
			<p><st c="77324">This chapter covered the important aspect of the methodology that embraces collaboration, agility, and innovation. </st><st c="77440">Organizations should recognize that fusion teams can lead to reduced time to solve business challenges since these teams break down the traditional barriers between business users, pro-developers, and IT professionals with their agile approach </st><span class="No-Break"><st c="77684">and synergy.</st></span></p>
			<p><st c="77696">Organizations should also adopt best practices that are coming from open source development, which enhance the possibilities of app makers within the organization, as we are empowering makers to be able to discover and reuse what has already been done internally. </st><st c="77961">Similar to the traditional software development tools, Power Platform provides all the tools to support this experience, such as Catalog Manager and integrations </st><span class="No-Break"><st c="78123">with Azure.</st></span></p>
			<p><st c="78134">Integrations with Azure are even more important for organizations that are already onboarded on Azure and running business workloads on this public cloud. </st><st c="78290">With integration in mind, we investigated some common cases of how Power Platform can be connected with </st><span class="No-Break"><st c="78394">Azure services.</st></span></p>
			<p><st c="78409">We finished the chapter with an example of a pro-developer experience when building a Web API that will be used as a backend for the Power Platform services and how Visual Studio enables quicker development and efficient testing experience. </st><st c="78651">When the Web API was ready, we showed how fast and smooth the integration between Azure APIM and Power Platform services </st><span class="No-Break"><st c="78772">can be.</st></span></p>
			<p><st c="78779">The next chapter will focus on pro-developer extensibility in Power Platform. </st><st c="78858">We will continue exploring the possibilities for pro-developers when it comes to connectors, code components, and more, with examples that can be reused in the </st><span class="No-Break"><st c="79018">DevOps process.</st></span></p>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor171"/><st c="79033">Further reading</st></h1>
			<ul>
				<li><st c="79049">InnerSource </st><span class="No-Break"><st c="79062">fundamentals: </st></span><a href="https://resources.github.com/innersource/fundamentals/"><span class="No-Break"><st c="79076">https://resources.github.com/innersource/fundamentals/</st></span></a></li>
				<li><st c="79130">View Dataverse data in Microsoft </st><span class="No-Break"><st c="79164">Fabric: </st></span><a href="https://learn.microsoft.com/en-us/power-apps/maker/data-platform/azure-synapse-link-view-in-fabric"><span class="No-Break"><st c="79172">https://learn.microsoft.com/en-us/power-apps/maker/data-platform/azure-synapse-link-view-in-fabric</st></span></a></li>
				<li><st c="79270">Azure and Power Platform architecture </st><span class="No-Break"><st c="79309">examples: </st></span><a href="https://learn.microsoft.com/en-us/azure/architecture/browse/?products=power-platform"><span class="No-Break"><st c="79319">https://learn.microsoft.com/en-us/azure/architecture/browse/?products=power-platform</st></span></a></li>
				<li><st c="79403">Dev tunnels in Visual </st><span class="No-Break"><st c="79426">Studio: </st></span><a href="https://learn.microsoft.com/en-us/connectors/custom-connectors/port-tunneling"><span class="No-Break"><st c="79434">https://learn.microsoft.com/en-us/connectors/custom-connectors/port-tunneling</st></span></a></li>
				<li><st c="79511">Exporting APIs from Azure APIM to Power </st><span class="No-Break"><st c="79552">Platform: </st></span><a href="https://learn.microsoft.com/en-us/azure/api-management/export-api-power-platform"><span class="No-Break"><st c="79562">https://learn.microsoft.com/en-us/azure/api-management/export-api-power-platform</st></span></a></li>
				<li><st c="79642">Custom connectors with PAC </st><span class="No-Break"><st c="79670">CLI: </st></span><a href="https://learn.microsoft.com/en-us/power-platform/developer/cli/reference/connector"><span class="No-Break"><st c="79675">https://learn.microsoft.com/en-us/power-platform/developer/cli/reference/connector</st></span></a></li>
			</ul>
		</div>
	<div id="charCountTotal" value="79757"/></body></html>