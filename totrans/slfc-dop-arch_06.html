<html><head></head><body>
		<div id="_idContainer029">
			<h1 class="chapter-number" id="_idParaDest-120"><a id="_idTextAnchor139"/>6</h1>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor140"/>Exploring Packaging</h1>
			<p>There are many ways to deliver Salesforce changes between environments and still adhere to DevOps principles. One of the popular mechanisms is the use of Salesforce packages, which can be either managed, unmanaged, or <span class="No-Break">unlocked packages.</span></p>
			<p>In this chapter, we’ll look at these three types of Salesforce packages, their use cases, <span class="No-Break">and considerations:</span></p>
			<ul>
				<li><strong class="bold">Unmanaged packages</strong> – Used to <a id="_idIndexMarker259"/>share customizations or applications with other organizations or users without any built-in versioning or <span class="No-Break">upgrade capabilities.</span></li>
				<li><strong class="bold">Unlocked packages</strong> – Designed for efficient application life cycle management, modular development, and versioning within a single organization. They are also a popular means of distributing open source solutions on the <span class="No-Break">Salesforce platform.</span></li>
				<li><strong class="bold">Managed packages</strong> – Designed to distribute custom applications, extensions, or integrations built on the Salesforce platform to multiple organizations or customers, with protection of the code used to build them, versioning, <span class="No-Break">and upgradability.</span></li>
			</ul>
			<p>By the end of the chapter, you will have a clear idea of not only the differences between these different types of packages but also when to use them and how to build them <span class="No-Break">in Salesforce.</span></p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor141"/>Technical requirements</h1>
			<p>For unmanaged, unlocked, and 2GP-managed packages, there shouldn’t be any additional requirements other than your Salesforce environment – ideally either a <strong class="bold">Sandbox</strong> or a <span class="No-Break"><strong class="bold">Developer</strong></span><span class="No-Break"> Edition.</span></p>
			<p>For 1GP-managed packages, you will need a separate packaging org when developing a managed package for distribution. A packaging org is a separate Salesforce org used to develop, package, and distribute <span class="No-Break">managed packages.</span></p>
			<p>For Salesforce ISV partners, this would typically be a <strong class="bold">Partner Developer Edition </strong>org, which has additional features and higher limits compared to a regular Developer Edition org. These are for use by Salesforce registered partners and aren’t for general everyday use by most <span class="No-Break">Salesforce customers.</span></p>
			<p>An example project for testing package commands is provided in the <strong class="source-inline">Chapter6</strong> folder of the GitHub repository associated with <span class="No-Break">this book.</span></p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor142"/>Unmanaged packages</h1>
			<p>Unmanaged packages <a id="_idIndexMarker260"/>form a part of Salesforce’s original implementation of packaging, and as such, form part of what is now <a id="_idIndexMarker261"/>known as <strong class="bold">first-generation packaging</strong> (<strong class="bold">1GP</strong>). They are used to bundle and share customizations, applications, or templates between different organizations or users. Unmanaged packages provide a way to distribute components, allowing developers to modify or build upon them as needed <span class="No-Break">after installation.</span></p>
			<p>Since unmanaged packages are part of 1GP, they follow a development and packaging process that is seldom source-driven. This means that the components within the package are typically selected from an org rather than a branch in a version control system. The lack of source-driven development with unmanaged packages makes it difficult to establish a streamlined and efficient DevOps process that involves version control, continuous integration, and <span class="No-Break">continuous deployment.</span></p>
			<p>Another limitation of this approach is that unmanaged packages do not support versioning of the packages themselves or in-place upgrades. Any updates or changes to the components within an unmanaged package must be done manually in the target org after installation. This can lead to challenges in managing and maintaining customizations over time, especially in larger and more complex <span class="No-Break">Salesforce implementations.</span></p>
			<p>The absence of a package-specific namespace in unmanaged packages also means that their components merge into the target org’s metadata without any separation. This can lead to naming conflicts and potential issues during deployment, making it more difficult to manage dependencies and maintain a clean metadata structure in the target org. If an unmanaged package is installed into a namespaced org, the components will inherit the <span class="No-Break">org’s namespace.</span></p>
			<p>As you can see, there are several limitations to the original 1GP approach and this is why Salesforce replaced it <a id="_idIndexMarker262"/>with <strong class="bold">second-generation packaging</strong> (<strong class="bold">2GP</strong>), which is what is <span class="No-Break">now recommended.</span></p>
			<p>As we’ve discussed, unmanaged packages are not ideally suited for use as part of your DevOps strategy, so let’s<a id="_idIndexMarker263"/> look at unlocked packages, which were introduced with Salesforce’s <span class="No-Break">2GP implementation.</span></p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor143"/>Unlocked packages</h1>
			<p>Salesforce unlocked packages are<a id="_idIndexMarker264"/> a modern, flexible, and modular packaging solution that allows developers and administrators to bundle, deploy, and manage customizations and applications built on the Salesforce platform. They are part of Salesforce’s source-driven development approach, which emphasizes version control systems and continuous integration pipelines for efficient development and <span class="No-Break">deployment processes.</span></p>
			<p>Unlocked packages address the challenges of managing and deploying customizations in large-scale and complex Salesforce implementations. By breaking down applications and customizations into modular units, they enable teams to manage and distribute these components more effectively. This modular approach promotes better collaboration, easier version control, and a streamlined development process. Unlocked packages are aimed at both developers and administrators who want to leverage best practices in application life cycle management, streamline their deployment processes, and reduce the complexity associated with <span class="No-Break">metadata deployments.</span></p>
			<p>Unlike managed packages, which are primarily used for distributing applications to multiple companies or customers, unlocked packages are designed for use within a single company. They are especially useful for enterprises with large Salesforce teams that require a structured and maintainable way to manage and deploy customizations across various environments, such as development, testing, and production. By providing a scalable and modular approach to Salesforce development, unlocked packages help organizations optimize their Salesforce implementations and drive better <span class="No-Break">business outcomes.</span></p>
			<p>Since unlocked packages are a source-driven approach to packaging, there is a greater reliance on the use of the command line to create them. You will need to be using the <strong class="bold">Salesforce DX</strong> (<strong class="bold">SFDX</strong>) approach<a id="_idIndexMarker265"/> to managing your metadata, and thus have a Dev Hub enabled. To do this, follow <span class="No-Break">these steps:</span></p>
			<ol>
				<li>Log in to your <span class="No-Break">Salesforce org.</span></li>
				<li>Click on the gear icon in the top-right corner and <span class="No-Break">select </span><span class="No-Break"><strong class="bold">Setup</strong></span><span class="No-Break">.</span></li>
				<li>In the <strong class="bold">Quick Find</strong> box, type <strong class="source-inline">Dev Hub</strong> and <span class="No-Break">select it.</span></li>
				<li>Toggle the <strong class="bold">Enable Dev Hub</strong> switch to <strong class="bold">On</strong> and enable <strong class="bold">Unlocked Packages</strong> on the <span class="No-Break">same screen.</span></li>
			</ol>
			<p>Once this is enabled, you can then work with your Dev Hub org from the command line – whether that’s a standalone one or the embedded terminal in VS Code. To create a new unlocked<a id="_idIndexMarker266"/> package, run the <span class="No-Break">following command:</span></p>
			<pre class="console">
sf package create --name MyPackageName –t Unlocked --path force-app -v MyDevHub</pre>			<p>Replace <strong class="source-inline">MyPackageName</strong> with the name of your package and <strong class="source-inline">MyDevHub</strong> with the alias you used when authenticating with your Dev <span class="No-Break">Hub org.</span></p>
			<p>At this point, it is assumed that you have a local project and that you have committed your code to Git. While source control of your changes is not essential for creating the package, as part of a DevOps process, this would be a good time to ensure your Git repository is up to date before creating your new package. With your updated metadata components in your local project, you can create a new package with the <span class="No-Break">following command:</span></p>
			<pre class="console">
sf package version create -p MyPackageName -d force-app -k MyPassword --wait 10 -v MyDevHub</pre>			<p>Replace <strong class="source-inline">MyPackageName</strong> with the name of your package, <strong class="source-inline">MyPassword</strong> with a password for the package (optional), and <strong class="source-inline">MyDevHub</strong> with the alias you used when authenticating with your Dev <span class="No-Break">Hub org.</span></p>
			<p>After creating a new package version, the added metadata components will be included in the unlocked package. You can install this package in your target Salesforce org with the <span class="No-Break">following command:</span></p>
			<pre class="console">
sf package install --package MyPackageName@1.0.0 -o MyTargetOrg -w 10</pre>			<p>Again, you will need to replace <strong class="source-inline">MyPackageName@1.0.0</strong> with the package name and version, and <strong class="source-inline">MyTargetOrg</strong> with the username or alias of your target org. It is worth noting that if a password was set in the preceding version creation, it will have to be supplied here with the <strong class="source-inline">-k</strong> flag for the installation <span class="No-Break">to work.</span></p>
			<p>Since unlocked packages have the foundation of a source-driven development approach rather than an org-driven approach, it is much better aligned to the use of DevOps throughout your entire process. By making use of source control and breaking down larger code bases into modular groups of functionality that could potentially be in their own separate Git repositories, you can be much more flexible in your approach to delivery using <span class="No-Break">unlocked packages.</span></p>
			<p>The one potential catch in this degree of modularization, however, is that there are sometimes situations in which there are pieces of metadata that overlap multiple packages. For example, if you have two distinct pieces of functionality that both make use of or depend upon the <strong class="source-inline">Opportunity</strong> object, you could potentially end up with a situation where there is a circular dependency on changes <span class="No-Break">across packages.</span></p>
			<p>A workaround to this could be to have a centralized <strong class="source-inline">core</strong> package that the other packages all <a id="_idIndexMarker267"/>reference. During the development of new functionality outside of this package, you would ensure you have installed the latest version of this core package in your <span class="No-Break">development environment.</span></p>
			<p>A better approach is to make good use of namespaces in your unlocked package development. Namespaces should be an integral part of creating Salesforce unlocked packages. They guarantee uniqueness – if someone already has an Apex class named <strong class="source-inline">MyClass</strong>, your <strong class="source-inline">MyClass</strong> won’t conflict with it, which avoids tricky <span class="No-Break">naming clashes.</span></p>
			<p>Namespaces also enable effective versioning of packages. Salesforce uses the namespace to manage multiple versions of a package, knowing which are compatible and how to handle upgrades <span class="No-Break">or rollbacks.</span></p>
			<p>Additionally, namespaces provide another means to provide clear separation of package code. It becomes evident which components belong to a particular package, isolating its code from the rest of the org’s m<a id="_idTextAnchor144"/>etadata. This aids in debugging <span class="No-Break">and maintenance.</span></p>
			<p>At the code level, rather than at the point of packaging, there are some additional benefits to be found. Namespaces remove ambiguity when third-party systems integrate with your package’s APIs and components. References are clear even with dynamic SOQL or REST calls, and namespaces allow control over which components are globally accessible versus private. Boundaries can be set on what’s exposed for <span class="No-Break">general use.</span></p>
			<p>When creating a package, the first step is registering a unique namespace identifier. This ties all components to that namespace. Next, the namespace is included in the package metadata when building a new version – during installation, Salesforce leverages the namespace to separate incoming components, avoiding conflicts. In code and configuration, components can be referenced with their namespace prefix, such <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">namespace__MyClass</strong></span><span class="No-Break">.</span></p>
			<p>However, namespaces also come with some downsides. They lock you into a permanent identifier that can’t easily change later. Complexity gets introduced by referencing namespaced components. Migrating existing <strong class="source-inline">un-namespaced</strong> code can require cumbersome adjustments. The availability of intuitive namespaces may be limited. Debugging across multiple namespaced packages can <span class="No-Break">become complicated.</span></p>
			<p>Overall, the benefits outweigh the limitations, especially for manageability and version control. But it’s important to be aware of the cons and plan your naming and <span class="No-Break">development</span><span class="No-Break"><a id="_idIndexMarker268"/></span><span class="No-Break"> accordingly.</span></p>
			<p>Thankfully, Salesforce also recognizes this challenge and provides another package type to cover this eventuality. Let’s explore these org-dependent packages a <span class="No-Break">little further.</span></p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor145"/>Org-dependent packages</h1>
			<p>The other type of unlocked <a id="_idIndexMarker269"/>package that Salesforce provides, org-dependent packages, tackles the problem of dependencies by deferring compilation and validation of your changes until installation time. This means that these dependencies don’t necessarily need to be in your development org or in your source control for you to build the package – you can depend on metadata that exists in the <span class="No-Break">target org.</span></p>
			<p>This type of unlocked package is ideal for Salesforce orgs that are large, complex, and have been in use for a long time and thus have accumulated a lot of changes. Unpicking these changes into separate modules is lengthy, challenging work, but by having a package type that is able to depend on unpackaged metadata in the target org, you can defer (or even avoid) the need to refactor your <span class="No-Break">entire org.</span></p>
			<p>Creating an org-dependent package is incredibly simple, too – the command is the same as that for creating an unlocked package, but with the <strong class="source-inline">--orgdependent</strong> flag specified, such as in the <span class="No-Break">following example:</span></p>
			<pre class="console">
sf package create --name MyPackageName -t Unlocked --path force-app -v MyDevHub --org-dependent</pre>			<p>You might be tempted to make all your unlocked packages org-dependent to gain the advantage of just-in-time validation, but there are some key drawbacks to org-dependent packages that<a id="_idIndexMarker270"/> ultimately mean you should always assess the correct package type for your <span class="No-Break">use case:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table001-3">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Feature</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Unlocked packages</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Org-dependent packages</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Installation flexibility</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>You can install these packages in any org, regardless of the metadata <span class="No-Break">they contain.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>You can only install these packages in orgs that have the specific metadata that the package <span class="No-Break">depends on.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Dependency </strong><span class="No-Break"><strong class="bold">validation time</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>The package dependencies are checked when you create the <span class="No-Break">package version.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>The package dependencies are checked when you install the package in <span class="No-Break">an org.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Dependency on </strong><span class="No-Break"><strong class="bold">other packages</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>These packages can depend on <span class="No-Break">other packages.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>These packages cannot depend on <span class="No-Break">other packages.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Dependency resolution</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>You need to resolve all the dependencies before you can create <span class="No-Break">the package.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>You do not need to resolve any dependencies before you can create <span class="No-Break">the package.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Supported </strong><span class="No-Break"><strong class="bold">metadata types</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Refer to the unlocked packaging channel of the Metadata Coverage report for the list of supported <span class="No-Break">metadata types.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Refer to the unlocked packaging channel of the Metadata Coverage report for the list of supported <span class="No-Break">metadata types.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Development and </strong><span class="No-Break"><strong class="bold">test environment</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Use scratch orgs to develop and test your <span class="No-Break">unlocked packages.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Use a sandbox that has the dependent metadata. You can also enable Source Tracking in sandboxes to develop your org-dependent unlocked package. Test the package in a sandbox org before installing it in your <span class="No-Break">production org.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Code </strong><span class="No-Break"><strong class="bold">coverage requirement</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>You must have at least 75% code coverage for the Apex code in your package before you can promote and <span class="No-Break">release it.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>There is no code coverage calculation, but you should test your Apex <span class="No-Break">code well.</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 6.1 – A comparison of unlocked and org-dependent packages</p>
			<p>In the next section, we’re<a id="_idIndexMarker271"/> going to look at the final type of packaging in Salesforce, <span class="No-Break">managed packages.</span></p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor146"/>Managed packages</h1>
			<p>Salesforce managed <a id="_idIndexMarker272"/>packages are developed, packaged, and distributed by Salesforce partners – also known<a id="_idIndexMarker273"/> as <strong class="bold">independent software vendors</strong> (<strong class="bold">ISVs</strong>). These packages provide a way to extend the functionality of Salesforce by adding new features, processes, or applications without having to build them from scratch. Managed packages are distributed through the Salesforce AppExchange, which is an online marketplace for Salesforce applications, components, and services. AppExchange allows developers and partners to publish their managed packages for Salesforce customers to discover, evaluate, and install them directly into their <span class="No-Break">Salesforce environments.</span></p>
			<p>Managed packages often can be customized to meet specific business needs while maintaining the core functionality provided by the package, but the level of customization possible will vary depending on the metadata contained within the package. The Salesforce DX Developer Guide has a section on what can and can’t be changed in managed packages and can be found <span class="No-Break">at </span><a href="https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/packaging_packageable_components.htm"><span class="No-Break">https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/packaging_packageable_components.htm</span></a><span class="No-Break">.</span></p>
			<p>The package provider is responsible for maintaining and upgrading the package, ensuring it stays compatible with the latest Salesforce releases and industry standards. This reduces the burden on the organization using the package, especially if it is using the package as installed with no further customizations or changes to the metadata in <span class="No-Break">the package.</span></p>
			<p>Salesforce stands out from other development platforms such as Java or C# due to its strong emphasis on backward compatibility and API stability for developers. When you build applications on top of the Salesforce platform, you can have confidence that the core APIs you rely on will not suddenly be deprecated or <span class="No-Break">altered unexpectedly.</span></p>
			<p>With languages such as Java or C#, core libraries or methods can be deprecated with just a notification that they will be removed in an upcoming release. This forces you, as a developer, to continually refactor your code to stay current. But Salesforce takes a very different approach <a id="_idIndexMarker274"/>to managing upgrades and keeping <span class="No-Break">customers happy.</span></p>
			<p>Once an Apex API is released as part of a managed package on Salesforce, its method signature is locked in place. The API functionality may evolve over time, even to the point of throwing new exceptions, but the original method and signature will remain intact. This prevents the common problem developers face of having to hastily refactor their own customizations just to install an upgrade to a <span class="No-Break">dependent package.</span></p>
			<p>Additionally, managed packages undergo a thorough security review process by Salesforce to ensure they meet the necessary standards for performance, data protection, and privacy. This provides an additional layer of trust for organizations using <span class="No-Break">these packages.</span></p>
			<p>Typically, the life cycle of managed packages differs only in the approval and distribution stages. Managed packages are developed in scratch orgs and distributed through the Salesforce AppExchange. Participating in this marketplace requires you to enroll with Salesforce as an ISV partner with a valid business case for your package. Once approved, you can then move on to producing <span class="No-Break">your package.</span></p>
			<p>Here’s how the distribution process <span class="No-Break">typically works:</span></p>
			<ol>
				<li><span class="No-Break">Development</span></li>
				<li><span class="No-Break">Testing</span></li>
				<li><span class="No-Break">Packaging</span></li>
				<li><span class="No-Break">Security review</span></li>
				<li><span class="No-Break">AppExchange listing</span></li>
				<li>Installation <a id="_idIndexMarker275"/><span class="No-Break">and configuration</span></li>
				<li>Ongoing support <span class="No-Break">and upgrades</span></li>
			</ol>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor147"/>Development</h2>
			<p>The package creator <a id="_idIndexMarker276"/>develops the managed package using Salesforce tools such as Apex, Visualforce, Lightning Components, and more, ensuring compatibility <span class="No-Break">with Salesforce.</span></p>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor148"/>Testing</h2>
			<p>Like any other piece of<a id="_idIndexMarker277"/> Salesforce development, the metadata and code for the package should be fully tested, not just to ensure that it is functionally complete but also to meet the stringent expectations for security that ISV partners should <span class="No-Break">adhere to.</span></p>
			<p>Salesforce provides several tools to help guide developers through this process, such as Salesforce Code Analyzer. This tool makes use of the Salesforce Graph Engine to do a deep walk through the code, following dependencies and looking for common security issues – particularly those around record access – using a technique called <strong class="bold">data flow analysis</strong> (<strong class="bold">DFA</strong>). DFA is<a id="_idIndexMarker278"/> a method that helps you to understand complicated parts of computer code better. It looks at the whole code all at once to figure out what’s going on in it. It does this by breaking down the code’s steps, including things such as evaluating  conditions, creating classes, and calling methods and static calls. It also tries to guess the value of the variables and fields at each step along the way. This all helps to give a better picture of how the <span class="No-Break">code works.</span></p>
			<p>The analyzer also <a id="_idIndexMarker279"/>makes use of other open source analysis engines, such as PMD and ESLint, to round out the coverage of <span class="No-Break">these checks.</span></p>
			<h2 id="_idParaDest-129"><a id="_idTextAnchor149"/>Packaging</h2>
			<p>Historically, managed<a id="_idIndexMarker280"/> packages followed a lengthy process along the lines of 1GP, as discussed earlier, which involved <span class="No-Break">the following:</span></p>
			<ul>
				<li>Selecting the components to be included, such as Apex classes, Visualforce pages, Lightning Components, custom objects, <span class="No-Break">and more</span></li>
				<li>Setting the package properties, such as the package name, namespace, version number, <span class="No-Break">and description</span></li>
				<li>Defining dependencies on other packages or Salesforce features, <span class="No-Break">if any</span></li>
				<li>Designating the package as managed to ensure versioning, upgradeability, and intellectual <span class="No-Break">property protection</span></li>
			</ul>
			<p>The package can then be uploaded to the Salesforce environment, generating an installation URL <span class="No-Break">for distribution.</span></p>
			<p>With the advent of 2GP, this process has become much more simplified. First, ensure that all components required for your package are in your project directory (typically in the <strong class="source-inline">force-app</strong> folder). This project should be linked to a corresponding scratch org and the required namespace should be specified in your <span class="No-Break"><strong class="source-inline">sfdx-project.json</strong></span><span class="No-Break"> file.</span></p>
			<p>The process for creating the actual package is more straightforward than the old 1GP approach, differing from unlocked packages by one simple command-line parameter, <strong class="source-inline">-t Managed</strong>, as shown in <span class="No-Break">the following:</span></p>
			<pre class="console">
sf force package create –n "My Managed Package" -t Managed –r force-app</pre>			<h2 id="_idParaDest-130"><a id="_idTextAnchor150"/>Security review</h2>
			<p>Before a managed <a id="_idIndexMarker281"/>package can be listed on the AppExchange, it must undergo a<a id="_idIndexMarker282"/> security review process. This process involves <span class="No-Break">the following:</span></p>
			<ul>
				<li>A comprehensive assessment of the package’s code and components to identify potential security vulnerabilities, such as injection attacks, insecure storage of sensitive data, and improper <span class="No-Break">access controls</span></li>
				<li>Ensuring that the package adheres to Salesforce’s security guidelines, best practices, and <span class="No-Break">compliance requirements</span></li>
				<li>Submitting a security review request to Salesforce, along with relevant documentation and <span class="No-Break">test cases</span></li>
				<li>Addressing any security issues identified by Salesforce during the review process and resubmitting the package <span class="No-Break">for approval</span></li>
			</ul>
			<p>Once the package passes the security review, it is granted the <strong class="bold">Passed Security Review</strong> status, signaling to customers that it meets Salesforce’s <span class="No-Break">security standards.</span></p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor151"/>AppExchange listing</h2>
			<p>After passing the<a id="_idIndexMarker283"/> security review, the package can be listed on<a id="_idIndexMarker284"/> the Salesforce AppExchange. Listing the package involves <span class="No-Break">the following:</span></p>
			<ul>
				<li>Creating an AppExchange listing with essential information about the package, such as its name, description, features, pricing, and <span class="No-Break">support details</span></li>
				<li>Adding screenshots, videos, or other media that showcase the package’s functionality <span class="No-Break">and benefits</span></li>
				<li>Associating the listing with the managed package using the installation URL generated during the <span class="No-Break">packaging process</span></li>
				<li>Submitting the listing for approval by Salesforce, which will review it for quality, branding, and <span class="No-Break">content guidelines</span></li>
			</ul>
			<p>Once the listing is approved, it becomes publicly available on the AppExchange, allowing customers to<a id="_idIndexMarker285"/> discover<a id="_idIndexMarker286"/> and evaluate <span class="No-Break">the package.</span></p>
			<h2 id="_idParaDest-132"><a id="_idTextAnchor152"/>Installation and configuration</h2>
			<p>Salesforce customers <a id="_idIndexMarker287"/>can find, evaluate, and install managed packages from the AppExchange by following <span class="No-Break">these steps:</span></p>
			<ul>
				<li>Browsing the AppExchange to discover packages that address their specific needs using search, filters, <span class="No-Break">and categories</span></li>
				<li>Evaluating the package by reviewing its description, features, pricing, customer reviews, and any available demos <span class="No-Break">or trials</span></li>
				<li>Installing the package by clicking the <strong class="bold">Get It Now</strong> button on the AppExchange listing, which initiates the installation process in the customer’s <span class="No-Break">Salesforce environment</span></li>
				<li>Granting access and setting up security settings for the package during installation, ensuring it aligns with the organization’s <span class="No-Break">security policies</span></li>
				<li>Configuring the package post-installation by customizing settings, adjusting layouts, or setting up any <span class="No-Break">required integrations</span></li>
			</ul>
			<p>Once installed and configured, the managed package becomes an integral part of the customer’s Salesforce environment, extending the platform’s functionality to address their specific needs <span class="No-Break">and requirements.</span></p>
			<h2 id="_idParaDest-133"><a id="_idTextAnchor153"/>Ongoing support and upgrades</h2>
			<p>After the package is <a id="_idIndexMarker288"/>installed and configured, the package provider is responsible for offering ongoing support and updates. This ensures that the package remains compatible with the latest Salesforce releases, industry standards, and customer expectations. The ongoing support and upgrade process typically involves <span class="No-Break">the following:</span></p>
			<ul>
				<li>Monitoring and addressing customer feedback, questions, and issues through support channels such as email, phone, or <span class="No-Break">online forums.</span></li>
				<li>Regularly releasing updates to the package to fix bugs, enhance features, and add new functionality. These updates are created as new package versions that customers can choose to install at <span class="No-Break">their convenience.</span></li>
				<li>Ensuring compatibility with the latest Salesforce releases, making any necessary adjustments to maintain seamless integration with <span class="No-Break">the platform.</span></li>
				<li>Staying up to date with industry trends, customer needs, and technology advancements to ensure the package remains relevant and valuable <span class="No-Break">to customers.</span></li>
				<li>Informing customers about important updates, new features, and best practices through communication channels such as newsletters, webinars, or <span class="No-Break">in-app notifications.</span></li>
			</ul>
			<p>The ongoing support<a id="_idIndexMarker289"/> and upgrades provided by the package provider contribute to the package’s long-term success, customer satisfaction, and <span class="No-Break">overall value.</span></p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor154"/>Packaging models’ pros and cons</h1>
			<p>Packaging serves as <a id="_idIndexMarker290"/>a distribution method for development updates in a broader DevOps process, aligning with source-driven software development principles. As various package types offer distinct use cases and strengths, selecting the most suitable delivery model is crucial to optimizing your workflow within the DevOps <span class="No-Break">life cycle.</span></p>
			<p>Let’s remind ourselves of <span class="No-Break">the differences:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table002-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Package type</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Pros</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Cons</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Primary </strong><span class="No-Break"><strong class="bold">use cases</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Unmanaged</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Easy <span class="No-Break">to customize</span></p>
						</td>
						<td class="No-Table-Style">
							<p>No <span class="No-Break">version control</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Sharing code and configurations for <span class="No-Break">learning purposes</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p>Allows for <span class="No-Break">code editing</span></p>
						</td>
						<td class="No-Table-Style">
							<p>No <span class="No-Break">automatic upgrades</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Sharing <span class="No-Break">sample solutions</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p>No namespace <span class="No-Break">requirements</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Security concerns due to <span class="No-Break">editable code</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Collaborative development</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p>No support for managed <span class="No-Break">package features</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Can be used by Professional Services teams where there’s a common customization that many customers require, but which itself may need the odd tweak for <span class="No-Break">each customer</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Unlocked</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Easy <span class="No-Break">to customize</span></p>
						</td>
						<td class="No-Table-Style">
							<p>No <span class="No-Break">automatic upgrades</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Deploying reusable components across <span class="No-Break">multiple orgs</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p><span class="No-Break">Version control</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Manual <span class="No-Break">upgrade process</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Sharing <span class="No-Break">modular solutions</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p>Allows for <span class="No-Break">code editing</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Security concerns due to <span class="No-Break">editable code</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Facilitating internal collaboration <span class="No-Break">and development</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p>Supports managed package features (<span class="No-Break">e.g., namespaces)</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Requires Salesforce DX and source-driven <span class="No-Break">development</span></p>
						</td>
						<td class="No-Table-Style"/>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Managed</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Automatic upgrades</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Limited <span class="No-Break">customization</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Commercial <span class="No-Break">app distribution</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p><span class="No-Break">Version control</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Code <span class="No-Break">not editable</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Distributing apps on <span class="No-Break">the AppExchange</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p>Enhanced security due to <span class="No-Break">uneditable code</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Requires namespaces</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Protecting <span class="No-Break">intellectual property</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p>Supports managed package features (<span class="No-Break">e.g., namespaces)</span></p>
						</td>
						<td class="No-Table-Style">
							<p>2GP requires Salesforce DX and source-driven development (although 1GP can still be done without <span class="No-Break">DX patterns)</span></p>
						</td>
						<td class="No-Table-Style"/>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 6.2 – The pros and cons of each package type</p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor155"/>Breaking up an existing monolithic application</h1>
			<p>Migrating a mature, monolithic <a id="_idIndexMarker291"/>application to Salesforce’s package development model can be a major undertaking filled with complexities <span class="No-Break">and challenges.</span></p>
			<p>On the<a id="_idTextAnchor156"/> complexity side, code refactoring is often needed to break tight couplings and fit components into modular packages. Dependency management becomes critical to untangle interconnected components. Introducing namespaces can add complexity in updating all references. Data models may need reworking to fit the new packaged schema. Permission sets and profiles will likely require redefinition. Automation and CI/CD pipelines need adaptation to handle packaging, versioning, and dependencies. Keeping various org environments in sync with the correct package versions is complex <span class="No-Break">to orchestrate.</span></p>
			<p>In terms of challenges, the transition will require extensive investment in resources and time. There will be a knowledge gap as teams learn the new model. Testing strategies need an overhaul, potentially including rewriting tests and scripts while setting up new test environments. Maintaining backward compatibility could limit changes,<a id="_idTextAnchor157"/> forcing  the need for legacy system support. Once transitioned, version management across packages and customers multiplies the complexity. Stakeholders accustomed to quick deployments may resist the slower, more controlled package life cycle. Apart from staffing costs, expenses such as training, downtime, and tools <span class="No-Break">will accumulate.</span></p>
			<p>To smooth the transition, a phased, gradual approach can help. Extensive training and expert consulting will build the necessary skills. Detailed documentation provides a knowledge base. Feedback channels give early visibility of issues. Risk assessments and rollback plans mitigate pitfalls. Proper resource allocation, both human and computational, lays <span class="No-Break">the groundwork.</span></p>
			<p>While difficult, migrating <a id="_idIndexMarker292"/>a monolithic application to the package model can ultimately enable modular, scalable development and easier maintenance. With careful planning and execution, the long-term benefits may outweigh the complexities of <span class="No-Break">getting there.</span></p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor158"/>Summary</h1>
			<p>In this chapter, we’ve looked at packaging as a technique for deploying our code changes and compared the different types of packages available. For each type of package, we have seen the steps required to bundle our Salesforce changes into those packages for <span class="No-Break">further distribution.</span></p>
			<p>We’ve also seen that these changes can follow a source-driven DevOps process if we select the appropriate type of package. Packaging by no means replaces DevOps processes; rather, it is a technique that forms part of DevOps on the Salesforce platform. Equally, it is not the only means of delivering your changes for scenarios outside of the ISV <span class="No-Break">Partner space.</span></p>
			<p>In the next chapter, we’ll start looking at bringing all the elements of our source-driven workflow together and adding some automation as we investigate the CI/CD automation of our processes. This represents an alternative delivery mechanism for our changes that doesn’t <span class="No-Break">require packaging.</span></p>
		</div>
	</body></html>