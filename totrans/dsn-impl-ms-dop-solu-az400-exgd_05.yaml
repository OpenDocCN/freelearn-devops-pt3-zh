- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Moving to Continuous Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After setting up source control for your organization and deciding on a branching
    and merging strategy that supports parallel work, you are ready to move on to
    continuous integration. Continuous integration is a method where every developer
    takes their work and integrates it with the work of others, and then verifies
    the quality of the combined work. The value of this is an increase in quality
    early on in the pipeline. This reduces the risk of error later on when merging
    code changes and reduces the number of bugs that are found in production, thereby
    reducing costs and protecting your reputation.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration is only possible when you have the proper setup with
    the necessary tools. In this chapter, you will learn how to use Azure DevOps pipelines
    to set up continuous integration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing continuous integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a build definition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running a build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with YAML pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Agents and agent queues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automate **Continuous Integration** (**CI**) builds using GitHub Actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To go through the examples that are covered in this chapter, you will need
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: An Azure DevOps organization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git command-line tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A code editor such as Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing continuous integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Continuous integration** is a methodology where you integrate your own changes
    with those of all of the other developers in your project and test whether the
    combined code still works as expected. This way, you create a fast loop that provides
    you with feedback on your work.'
  prefs: []
  type: TYPE_NORMAL
- en: When working with extensive branching strategies for isolating code changes,
    it is not uncommon for one or more developers to work for days, weeks, or even
    months on an isolated branch. While this is great for making sure that their changes
    do not disrupt others, continuous integration is a great way to make sure that
    there won’t be merge issues later. If you have ever had to merge weeks or months
    of work back into the main branch, you will know how much work is involved and
    how often this results in bugs or other issues.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent this, developers should make it a habit to integrate their changes
    with those of all the other developers at least once a day. Here, integrating
    means at least merging, compiling, and running unit tests. This way, there is
    a constant stream of feedback on the quality of the developer’s changes, and since
    this feedback is combined, it is a great way to prevent merge issues later.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration also enables you to embed other concerns in your pipeline
    to automatically preserve the quality of your code. Static code analysis, unit
    testing, and security scanning are three prime examples of this. These topics
    are discussed in later chapters, but a good continuous integration pipeline is
    the basis for these practices.
  prefs: []
  type: TYPE_NORMAL
- en: In the rest of this chapter, you will learn about the technical means to set
    up continuous integration using Azure Pipelines. But first, let’s look at a common
    misconception and the four pillars of continuous integration.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: While an automated continuous integration build is an important ingredient for
    performing continuous integration, continuous integration entails more than just
    having a build pipeline. The important thing to remember is that continuous integration
    is a process where every developer integrates their work with that of their colleagues
    at least daily. Then, the integrated sources are compiled and tested. The value
    comes from compiling and testing the integrated work, not the isolated work.
  prefs: []
  type: TYPE_NORMAL
- en: The four pillars of continuous integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are four pillars that underpin the successful adoption of continuous
    integration:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A version control system**: Used for storing all of the changes made to a
    system since its inception. Version control systems were discussed in the previous
    chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A package management system**: Used to store the binary packages that you
    use in your own application and the packages that you create. This will be discussed
    in detail in [*Chapter 7*](B18655_07.xhtml#_idTextAnchor453), *Dependency Management*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A continuous integration system**: A system that can pull the changes of
    all developers together – several times a day – and create one integrated source
    version. This can be done using Azure DevOps pipelines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**An automated build process**: Used to compile and test the combined sources.
    We will look at how to implement this process using Azure DevOps pipelines.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous integration and automated builds can be set up in Azure DevOps. The
    next section explains how to set both up in Azure DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a build definition in Azure DevOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The main way to perform continuous integration is by using a continuous integration
    build. In Azure DevOps, builds can be configured as part of the Azure Pipelines
    offering. There are currently two approaches available for creating a build definition:'
  prefs: []
  type: TYPE_NORMAL
- en: Via the visual designer (also called **classic builds and releases**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Through **Yet Another Markup Language** (**YAML**) files (also called YAML pipelines
    or multistage pipelines)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of this section will focus on the visual designer. The following section,
    *YAML build definitions*, will go into more detail about YAML pipelines. Both
    approaches support roughly the same capabilities, although there are some differences.
    Some features that are available in classic builds and releases are not (yet)
    available in YAML build definitions. Also, some new features are only provided
    to YAML pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: If you have no experience with pipelines, the classic editor is a good way to
    get familiar with the workings of continuous integration/continuous development
    pipelines before moving on to YAML pipelines. Almost all of the concepts in classic
    builds translate to YAML builds as well.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will start by building a classic build pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to source control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get started with a build definition, follow these simple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Pipelines** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From this menu, click on **Builds**. Here, you will be presented with a button
    to create a new build. After clicking on this button, a new view for creating
    a build will open, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Source code repository options for pipelines  ](img/B18655_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Source code repository options for pipelines
  prefs: []
  type: TYPE_NORMAL
- en: You will then be guided to the new YAML experience, but you can still opt to
    go back by choosing the classic editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After choosing the classic editor, you can configure how to connect to the source
    control. The classical editor is the editor that is visible in all of the screenshots
    in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Many source control systems are supported. If you are working with a hosted
    Git repository, pick your specific product, if available, and only choose **Other
    Git** if your product is not available; currently, **GitHub**, **GitHub Enterprise
    Server**, and **Bitbucket Cloud** are supported. The reason for this is that continuous
    integration using **Other Git** works by using a polling model, where all the
    specific products use their known integration Webhooks. The following example
    works with a Git repository that is in the same Azure DevOps organization.
  prefs: []
  type: TYPE_NORMAL
- en: When you select the **Pipeline** header, you can set the name of the build definition
    and select an agent pool that the phases will run on by default. Agents take care
    of the actual execution of your tasks and will be looked at in more detail in
    the *Agents and agent queues* section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Below the **Pipeline** header, you can see the chronological layout of your
    build definition. First up is downloading sources. Here, you can once again choose
    to connect to a source control system. You can also specify more advanced settings
    that relate to the way sources are fetched, such as whether to clean the build
    directory first, select a branch, or add tags.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a job
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Below the source’s node, you can add one or more jobs that will perform the
    bulk of the work that you want to perform. Jobs can be added using the ellipsis
    on the **Pipeline** header. There are two types of jobs available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Agentless jobs**: Agentless jobs can be used to run tasks that do not require
    an agent. They are run on Azure DevOps Server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Agent jobs**: Agent jobs are used to run tasks that require an agent to run
    on, which is the case for the bulk of the tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some examples of agentless tasks are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Waiting for manual approval before continuing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inserting a delay before proceeding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling a REST API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling an Azure function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main benefit of an agentless job is that it does not keep an agent occupied
    while running. This frees the agent up to do other work, meaning that you need
    fewer agents, which can save costs. Also, the number of agents that you can use
    concurrently is governed by the number of parallel pipelines that you have bought
    in Azure DevOps. Limiting the number of agent jobs will save money here as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go over the process of configuring a job:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select any job. You will see the view shown in the following screenshot. In
    this view, you can change the name of the job and, for agent jobs, override the
    agent pool to execute this job on:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Add/update jobs for the pipeline ](img/B18655_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Add/update jobs for the pipeline
  prefs: []
  type: TYPE_NORMAL
- en: Next, specify which agent pool to use for running the job. Here, it also specifies
    the demands that you have of the agent that will execute this job. Demands will
    be discussed in the *Agents and agent queues* section of this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As part of the execution plan for an agent, you can specify **Parallelism**
    and choose one of three options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**None**: This will just execute all the tasks you add to the agent job one
    after another on the same agent.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multi-configuration**: Here, you can specify a series of variables that determine
    the number of variations of the build to run. This is useful if you want to create,
    for example, x86 and x64 builds from the same code.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multi-agent**: Here, you can specify the number of agents that will run the
    same tasks in parallel.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, you can specify one or more dependencies. These are the other jobs that
    need to be completed before the selected job runs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, for any job, you can specify how to cope with errors in previous jobs
    by telling it to continue or stop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As an alternative to *step 3* and *step 4*, you can also specify a custom expression
    to specify whether a job should run. This expression should evaluate to a Boolean
    and support rudimentary operations, such as `or()`, `and()`, or `eq()`. The following
    is an example condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This condition specifies that the job will only run when all previous jobs have
    succeeded and the build is not started from the main branch. A link to a detailed
    description of the conditions syntax is included at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Agentless jobs have fewer options available than agent jobs. For example, it
    is not possible to execute the same build for multiple variable values in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: Adding tasks to your job
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After adding one or more jobs, you can add tasks to a job. Tasks define the
    actual work that is to be done during the execution of your build. The following
    screenshot shows you how to add a task and then configure it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the plus sign next to the job you want to add tasks to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Select a task and specify the configuration parameters for the
    job ](img/B18655_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Select a task and specify the configuration parameters for the
    job
  prefs: []
  type: TYPE_NORMAL
- en: You will then be presented with a task picker, where you can find any task that
    matches your search input and add one or more tasks by clicking the **Add** button.
    A new screen will then open, where you can configure the individual task. The
    options provided here differ for each task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There can be multiple versions of a task, and you can switch between the major
    versions of it. This means that the maintainer can push non-breaking updates and
    you will receive them automatically. Major or breaking updates can be pushed with
    a new major version number, and you can upgrade them at your own discretion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is possible to add as many tasks as needed to a pipeline job.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing build artifacts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An important part of a build definition is its outcomes. Builds are often used
    to produce one or more artifacts that are later used for the deployment of an
    application. Examples of artifacts can be executables or installer files. These
    files need to be made available for use after the execution of the build pipeline
    has beencompleted.
  prefs: []
  type: TYPE_NORMAL
- en: The **Publish Build Artifacts** task that is shown in the preceding screenshot
    is a task that is specifically designed to do this. It allows you to select a
    file or directory and publish it under an **artifact name**. The result of this
    is that the file(s) in the selected path are retained with every execution of
    the pipeline for manual download or use in a release definition later. Release
    definitions will be discussed in [*Chapter 6*](B18655_06.xhtml#_idTextAnchor330),
    *Implementing Continuous Deployment and Release Management*.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll learn how to integrate our pipeline with other tools and configure
    our service connection.
  prefs: []
  type: TYPE_NORMAL
- en: Calling other tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When building pipelines, we will often need to integrate them with other tools.
    For source control systems, this is part of the flow when creating a pipeline
    and you are limited to the built-in options. For tasks, you can create references
    to any tool or location you want using service connections. An example of a task
    that uses a service connection to an Azure app service is shown in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'A service connection is a pointer to an external system, with a name and series
    of properties that differ for each type of service connection. Often, you will
    need to put in a URL to locate the other service and a mechanism for authentication.
    The following steps will help you configure your service connection:'
  prefs: []
  type: TYPE_NORMAL
- en: 'After defining one or more service connections, you can select the one to use
    from a drop-down menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Use the service connection in the task ](img/B18655_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Use the service connection in the task
  prefs: []
  type: TYPE_NORMAL
- en: 'Service connections are managed in a central location as project settings.
    You can access them by going to the management view directly from the task you
    are currently configuring, as shown in the preceding screenshot. You can also
    do this by navigating to **Project Settings** and then to **Service connections**,
    as in the following screenshot (see **2**):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Service connection dialog ](img/B18655_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Service connection dialog
  prefs: []
  type: TYPE_NORMAL
- en: In this view, you can then either add a new service connection or update an
    existing service connection (see **2** and **3** in the preceding screenshot).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, service connections are scoped to the project level, meaning they
    are not available for everyone in the Azure DevOps organization. To encourage
    the reuse of service connections, Azure has made it possible to share them between
    projects since mid-2019.
  prefs: []
  type: TYPE_NORMAL
- en: Task Marketplace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A set of frequently used tasks is built into Azure Pipelines; however, there
    are even more available using the Visual Studio Marketplace for Azure DevOps.
    If you are an administrator of the DevOps organization, you can find and install
    extensions that add tasks here. If you are a regular user, you can find tasks
    here as well; however, you cannot install them, only request them. Your Azure
    DevOps administrator will then be notified and can install the extension on your
    behalf if they approve.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, you can write and distribute extensions with tasks of your own as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Creating variables and variable groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you are configuring your build, there might be values that you need to
    use more than once. It is often wise to extract these values into variables, rather
    than just repeating them throughout your tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Variables can be used to note down values that you do not want to have stored
    in source control. Values such as passwords and license keys can be safely stored
    as non-retrievable values when locked down using the lock symbol (see **1** in
    the following screenshot). After saving the build definition, these values are
    encrypted and can only be used by the build that they belong to.
  prefs: []
  type: TYPE_NORMAL
- en: 'To learn how to work with variables in Azure Pipelines, go through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Azure Pipelines, you can add variables to your build definition by going
    to the **Variables** | **Pipeline variables** tab (see **3** in the following
    screenshot). Here, you can enter them as name values, as can be seen in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Pipeline variables  ](img/B18655_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Pipeline variables
  prefs: []
  type: TYPE_NORMAL
- en: 'Once defined, you can use the variables in the configuration of all tasks in
    all jobs of the same build. For this, you can use the following notation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, you can mark variables as `system.debug` built-in variable. When this
    variable is set to `true`, there is a verbose debug logging included in the build.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next to your own variables, system variables are also defined. These are variables
    that contain information about the build that is currently running, including
    version numbers, agent names, build definition details, and the source version.
    A link to the full list of system-defined variables is included at the end of
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Variable groups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As well as creating the variables that go with a specific build, you can create
    variable groups. These variable groups can, in turn, be linked to one or more
    builds. This is an effective way of sharing variables between builds; some examples
    of these might be the name of your company, trademark texts, and product names.
    Let’s see how we can work with variable groups:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Access variable groups through the menu by clicking on **Library** in the **Pipelines**
    menu (see **1** in the following screenshot). This displays a list of the existing
    variable groups that you can edit, and you can add a new group here as well, as
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.7 – A new variable group  ](img/B18655_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – A new variable group
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can work with variables in the same way that you would with the variables
    that come with a build. The only differences are highlighted in the following
    list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You cannot mark variables in a group as settable at queue time.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can allow or deny the use of this group in all pipelines. If you deny their
    use in all pipelines, then only you can use the variable group. You can authorize
    other users or groups through the **Security** option (see **2** in the preceding
    screenshot).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can reference an Azure key vault for which this variable group will act
    as a placeholder. After logging into Azure, you can select a key vault and which
    values that are stored in the key vault you want to be accessible through the
    variable group.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Key Vault** is an Azure offering that can be used for the secure storage
    of secrets. Secrets in a key vault are automatically versioned, so older values
    are not overwritten but replaced by a newer version. In addition to this, you
    can specify segregated access policies that specify, per user, whether they can
    read, write, update, or delete values. All these actions are audited in a key
    vault, so you can also find who has made which change. If you are linking Azure
    DevOps to a key vault, then a new service principal will be created in your active
    directory that has access to that key vault. Now, whenever Azure DevOps needs
    a variable from the variable group, the actual values will be pulled from the
    key vault.'
  prefs: []
  type: TYPE_NORMAL
- en: Variable groups can be linked to the variables of a build under the **Variable
    group** tab (refer to the screenshot in *Figure 5.7*).
  prefs: []
  type: TYPE_NORMAL
- en: 'As well as working with variable groups, you can also work with files in the
    library. You can upload files that are not accessible by other users but that
    can be used within a build. This is useful for files with private keys, license
    keys, and other secrets. Refer to this link for more information: [https://docs.microsoft.com/en-us/azure/devops/pipelines/library/secure-files?view=azure-devops](https://docs.microsoft.com/en-us/azure/devops/pipelines/library/secure-files?view=azure-devops).'
  prefs: []
  type: TYPE_NORMAL
- en: Just as you can with variable groups, you can specify whether each secure file
    can be used by any build or authorize specific users only.
  prefs: []
  type: TYPE_NORMAL
- en: Triggering the build
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next tab in a build definition governs what should start or trigger the
    build. To implement continuous integration, go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Triggers** tab and select the first header on the left:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Defining triggers for the pipeline ](img/B18655_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – Defining triggers for the pipeline
  prefs: []
  type: TYPE_NORMAL
- en: Check the **Enable continuous integration** box. This means that Azure DevOps
    will track for changes in your repository and queue a new build as soon as a new
    chance is available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, you can choose whether you want to build every incoming change individually
    or batch multiple changes when more than one new change comes in while building
    a change. It is recommended that you build every single change separately if this
    is feasible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Along with the continuous integration trigger, specify one or more branch and
    path filters. Here, you can specify which branches and files to queue a new build
    for. You can specify either inclusions or exclusions, depending on your needs.
    A common example is to limit your build to the main branch. If you have folders
    named `doc` and `src` in your repository and all your sources are in the latter
    folder, then it might make sense to limit the trigger to this path.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As well as choosing to have a continuous integration trigger, you can also opt
    to execute a build on a recurring schedule where you select one or more weekdays
    and a time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also schedule a build to run whenever another build completes. This
    is called **chaining** builds.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, let’s learn how to change the configurations of our build definition.
  prefs: []
  type: TYPE_NORMAL
- en: Build options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can change the advanced configuration options for your build definition.
    These options include a description, the format of the build number, and the automated
    creation of work items on failures and times. To set this up, go through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Options** tab. You should arrive at the following screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Build options ](img/B18655_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – Build options
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create your build number format. If this field is left empty, then the
    build number for your application will be set to an ever-increasing number that
    will increase by one with every build. This number is unique within a team project
    and counts over all the build definitions. You can also specify a format of your
    own using the variables available to you. A common approach is to specify a major
    and minor version number manually and then add an increasing number using a variable.
    The following example specifies a version of 4.1.xx, where the last part is replaced
    by a two-digit increasing number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: On the right, there are advanced (but rarely used) options for specifying the
    authorization scope for the **Build job** timeouts for each job in the build definition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is also possible to specify the agent demands that every agent, for every
    job in the build definition, should fulfill. Again, we will look further at demands
    in the *Agents and agent queues* section of this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Other options on the left enable you to suspend the pipeline temporarily.
  prefs: []
  type: TYPE_NORMAL
- en: Build history
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The final tab, called **History**, shows you a list of every change that has
    been made to the build definition. Build definitions are stored in JSON format,
    and you can pull up side-by-side comparisons for every change. The comment that
    you put in when saving a build is also stored here and can be used to provide
    the rationale for a change. You can revert to an older version of the pipeline
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Since builds are an important means of preserving quality, it is important to
    keep track of who has changed them to ensure that automated quality metrics are
    not removed.
  prefs: []
  type: TYPE_NORMAL
- en: With this, you are now ready to run your first build. You can directly run it
    using the **Save & queue** button that is visible in most of the screenshots in
    this section. The *Running a build* section of this chapter will teach you how
    to work with the results that you obtain.
  prefs: []
  type: TYPE_NORMAL
- en: Task groups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When working in a team or organization that has more than one pipeline, it often
    doesn’t take long before multiple pipelines that have the same shape emerge. For
    example, in some companies, all pipelines contain tasks for security scanning,
    running tests, and calculating the test coverage.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of repeating these tasks everywhere, they can be extracted from an existing
    pipeline into a task group. Task groups, in turn, can be used within multiple
    pipelines as if they are tasks themselves. Doing this reduces the effort needed
    to create a new pipeline or update all the pipelines with a new requirement. Doing
    this also ensures that all the pipelines using the task group have the same task
    configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new task group, open any existing build definition and go through
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select one or more tasks by clicking on them while holding down *Ctrl*, or
    by using the selectors that appear when hovering the mouse over a task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Creating a task group ](img/B18655_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – Creating a task group
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the selection and select **Create task group**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the popup that now appears (not shown in the screenshot), choose a name,
    description, and category for the task group. If any of the selected tasks have
    a variable value specified, you can now provide a default value and description
    for these parameters. These parameters will be available within the task group
    and need to be configured when the task group is used.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After clicking **Create** (not shown in the screenshot), the existing build
    definition is updated by removing the selected tasks and replacing them with the
    new task group.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding an already existing task group to a build or release definition is done
    in precisely the same way as adding regular tasks. Task groups show up in the
    same list of tasks to choose from.
  prefs: []
  type: TYPE_NORMAL
- en: A list of all the existing task groups can be found by navigating to the **Pipelines**
    menu and then **Task groups**. To edit an existing task group, select it in the
    list that is shown, and then select the **Edit** option. Editing task groups works
    in precisely the same way as editing a build definition.
  prefs: []
  type: TYPE_NORMAL
- en: This section was all about creating a build definition and describing how an
    application should be built. The next section is about executing the build.
  prefs: []
  type: TYPE_NORMAL
- en: Running a build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, you will learn how to work with the build results and use them
    to report and generate builds. You will also learn how to run a build with every
    pull request and report the quality of the changes back to that pull request to
    assist the reviewer.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the build results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While a build is running, an agent will perform all the configured steps. Azure
    Pipelines will capture detailed information and logs from all these steps. As
    you can see in the following screenshot, a build will display a list of all the
    steps it has executed on the left. Clicking on any of these steps will open a
    detailed view that displays the logs per step:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – Build results ](img/B18655_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 – Build results
  prefs: []
  type: TYPE_NORMAL
- en: Whenever there are warnings or errors during the build, they show up in orange
    or red, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Building a pull request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After setting up your build definition and running your first builds, you might
    also see the first failures coming in – for example, when someone accidentally
    commits and pushes changes that do not compile or contain unit tests that do not
    run successfully. You can prevent this by having a build definition run automatically
    whenever a pull request comes in. To configure this, go through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on **Policies** under **Project Settings**. The following screen will
    open. Click on **Add build policy**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.12 – Adding a build policy ](img/B18655_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.12 – Adding a build policy
  prefs: []
  type: TYPE_NORMAL
- en: Select a build definition that you want to use to validate the pull request.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, there will be three more things that you can configure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Trigger**: When the build definition should start, either automatically or
    manually. Of course, the real value comes from running a verification build automatically.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Policy requirement**: This determines whether a pull request can be completed
    if the build fails. In other words, this determines whether you can ignore a failing
    build. It is recommended that you avoid setting this to **Optional**, if possible.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build expiration**: This determines how long a positive build result is valid
    for. The default value is **12** hours, but you should consider changing this
    to **Immediately when main is updated**. The advantage of this is that you cannot
    merge changes without first running the build against a combination of the current
    state of the branch that you will merge to and the proposed changes.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can add more than one build policy. If you have a lot of things that you
    can automatically validate and want to keep automated validation times to a minimum,
    then this is a good approach.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing build artifacts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As well as compiling, testing, and validating your source code, builds can also
    be used to generate what are called **artifacts**. Artifacts are outputs from
    a build and can be anything that you want to save and publish from a build, such
    as test results and application packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'An application package is intended to be an immutable build of a version of
    your application. This package can later be picked up in a release and deployed
    to one or more environments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13 – Viewing application packages  ](img/B18655_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.13 – Viewing application packages
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you can see that, as part of the summary of an
    executed build, there were two artifacts published. Artifacts can be accessed
    from either the **Artifacts** drop-down menu in the top-right corner of the screen
    or from the **Summary** tab. You can download and explore artifacts from this
    page, and in the next chapter, you will see how to work with them to set up continuous
    delivery.
  prefs: []
  type: TYPE_NORMAL
- en: Great! With this, you have learned how to create a definition using the visual
    designer. But wait – as we mentioned earlier, there is another way of doing this,
    which is by using YAML files. Let’s see how this works in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Working with YAML pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You have seen how to create a build definition using the visual designer. A
    new, alternative approach, which has been available since early 2019, is the use
    of YAML pipelines. When working with YAML pipelines, you specify your complete
    build definition in a YAML file and store it in source control, often next to
    the source code that the build is for.
  prefs: []
  type: TYPE_NORMAL
- en: While both pipeline systems coexist, using YAML pipelines is now the preferred
    approach for defining pipelines. This means that it is very likely that new features
    will only surface in YAML pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for using build definitions as code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you first start working with YAML build definitions, you might find that
    the learning curve is steeper than it is when working with a visual designer.
    This might raise the question as to why you would use YAML-defined builds. There
    are two main advantages that YAML build definitions have over visually designed
    definitions.
  prefs: []
  type: TYPE_NORMAL
- en: When you are writing your definition in YAML, it can be hosted in source control
    next to your code. The consequence of this is that all the policies that you have
    in place for changing source control now automatically apply to your build definition.
    This means that any change must go through a pull request, be reviewed by a peer,
    and can be built and verified ahead of time. Enforcing the **four-eyes principle**
    on your build definition, as well as your code, increases the stability of your
    build process. Of course, it also benefits security and compliance, topics that
    will be discussed in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: As well as this increase in security, having the build definition in source
    control also means that it is available in every branch. This means that it can
    be changed in every branch to build that specific branch before merging it with
    the main branch. When working with a visually designed build definition, this
    single definition is responsible for building not only your main branch but also
    all the branches that you want to merge through a pull request.
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that you must do one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Update the build definition for the change that you will merge. However, this
    will terminate the building of the current state of the main branch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Merge the change, which will also result in a broken build, since the build
    definition has not yet been updated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Either option has the risk of allowing faulty changes to flow through the target
    branch, defeating the purpose of a continuous integration build. With a build
    definition per branch, we eradicate this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a basic YAML pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get started with YAML builds, there are two things you need to do:'
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to write your YAML file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, you need to create a build definition out of it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the YAML file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code sample contains an example YAML definition for building
    a .NET Core application and running unit tests. Save a file with any name – for
    example, `pipeline.yaml` – in any Git repository in Azure DevOps. Then, it can
    be used to create a pipeline out of it later on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This YAML example defines a basic pipeline. Every pipeline needs to be triggered
    in some way. Just as with classic builds, this can be done by connecting the pipeline
    to a change in a source code repository. The default repository for this is the
    repository that also contains the YAML definition. The **trigger** keyword is
    used to specify a push to which branches should trigger the pipeline. A good starting
    point is the main branch. As the trigger keyword accepts a list, multiple branches
    can be specified, and wildcards can be used.
  prefs: []
  type: TYPE_NORMAL
- en: A trigger is not mandatory, as a pipeline can also be started manually.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: There are also alternative options to using the trigger keyword, such as including
    or excluding one or more branches, tags, or paths in the repository. These options
    are described in detail at [https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema#triggers](https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema#triggers).
  prefs: []
  type: TYPE_NORMAL
- en: As well as a trigger, every pipeline contains one or more tasks, just as in
    classic build definitions. All these tasks need to execute on an agent pool –
    again, just as in classic build definitions. The `pool` keyword is used to specify
    a set of key/value pairs that determine which pool the tasks will run on by specifying
    the name of the pool. When working with the default agents that Microsoft provides,
    the default name of `Azure Pipelines` can be used. When using this specific pool,
    a **Virtual Machine** (**VM** ) image has to be specified. This determines which
    operating system and what software is available on the agent that will execute
    the task.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: An up-to-date list of all the VM images that are available can be found at [https://docs.microsoft.com/en-us/azure/devops/pipelines/agents/hosted#use-a-microsoft-hosted-agent](https://docs.microsoft.com/en-us/azure/devops/pipelines/agents/hosted#use-a-microsoft-hosted-agent).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the definition contains a list of the steps that make up the pipeline
    itself. These steps correspond one to one with the tasks that you can drag into
    a classic build pipeline. A task is added by specifying the name and version –
    separated by the `@` sign – of the task that you want to run. Next, you can optionally
    specify a display name for the task. This display name will later be visible in
    the views that show the results of an executed pipeline. Finally, specify one
    or more inputs for the task. These inputs relate to the task-specific configuration
    that you have already seen for the visual designer.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a YAML pipeline
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After saving your YAML file in a repository, you can create a build definition
    from it. When creating a new build definition (see the *Creating a build definition*
    section of this chapter), you should go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Choose the **Azure Repos Git YAML** option when the wizard starts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From here, go through the wizard to select and review the YAML you want to
    build, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.14 – A YAML pipeline for a repository  ](img/B18655_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14 – A YAML pipeline for a repository
  prefs: []
  type: TYPE_NORMAL
- en: Then, locate the repository that contains the YAML file that you want to use
    as your pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, configure the pipeline by choosing an example YAML file to start from
    or by referring to an already existing file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, you can review the YAML file that you have selected and start a build
    from it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your pipeline is saved automatically. Once the pipeline is saved, it can be
    started, and you can interact with it in the same way as you would with classic
    build pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-job pipelines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The pipeline you saw in the previous section does not specify any jobs, as
    you may recall from the section on classic builds. Instead, it contains a list
    of tasks under the `steps` keyword. This means that it implicitly contains only
    a single job. With YAML pipelines, it is also possible to create a definition
    that contains more than one job. To do this, the following structure can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Instead of adding the `steps` keyword directly to the pipeline, a list of jobs
    is created first. Within that list, one or more `job` keywords are added, followed
    by the name for that job. Next to this technical name, a display name (`displayName`)
    can be specified for each job.
  prefs: []
  type: TYPE_NORMAL
- en: As the second job in the preceding example shows, it is also possible to specify
    which agent pool to use per job. When no pool is specified for a job, the default
    pool specified at the top of the file is used.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The jobs that are discussed in this section are called agent jobs. Besides agent
    jobs, there are also server jobs, container jobs, and deployment jobs available.
    More information about these types of jobs can be found at [https://docs.microsoft.com/en-us/azure/devops/pipelines/process/phases#types-of-jobs](https://docs.microsoft.com/en-us/azure/devops/pipelines/process/phases#types-of-jobs).
  prefs: []
  type: TYPE_NORMAL
- en: By default, all the jobs in a pipeline run in parallel, but there are control
    options available to change this.
  prefs: []
  type: TYPE_NORMAL
- en: Control options
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To control the order of jobs, the `dependsOn` keyword can be used in the definition
    of a job. This signals that the job can only be started after one or more jobs
    are completed. Besides this, the `condition` keyword can be used to specify a
    condition that a job should run under. These two keywords can be combined to realize
    more complex scenarios, such as the one shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This pipeline will start by running the job named `compile`. Once this job completes,
    the next two jobs, `test` and `build_schema`, will run in parallel, as they both
    depend on the `compile` task. After both of these tasks complete, the `report`
    task runs, as it declares a dependency on both the `test` and `build_schema` jobs.
    Before this job actually starts, the condition is evaluated to determine whether
    the job should actually run or be skipped.
  prefs: []
  type: TYPE_NORMAL
- en: Conditions can be built using a syntax that is similar to many programming languages.
    It checks the successful completion of a job using the `succeeded()` and `failed()`
    functions. There is also support for Boolean operators such as `or()`, `and()`,
    and `ne()`.
  prefs: []
  type: TYPE_NORMAL
- en: You can combine the `dependsOn` and `condition` keywords in any way you see
    fit. The only requirement is that there should be at least one job that does not
    depend on any other job.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Just like classic build pipelines, YAML pipelines support the use of variables.
    Variables can be defined at every level of a YAML pipeline (except for within
    a task) using the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Variables can later be retrieved using the syntax that you already know from
    classic build pipelines – `$(name)` and `$(anotherName)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to reference existing variable groups from within a YAML
    pipeline. This is done by using the `group` keyword, instead of specifying the
    name of a variable. To also retrieve all the variables from a variable group called
    `myVariableGroup`, you would extend the preceding YAML, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Variables can be set at every level in a YAML pipeline, but only variables
    set at the root level can be overridden when queuing a new execution manually.
    You can learn more here: [https://docs.microsoft.com/en-us/azure/devops/pipelines/process/variables](https://docs.microsoft.com/en-us/azure/devops/pipelines/process/variables).'
  prefs: []
  type: TYPE_NORMAL
- en: Pipeline artifacts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like classic builds, YAML pipelines can be used to build and publish artifacts.
    As the task used to do this is a task like any other, it can be added directly
    to the list of steps in a job.
  prefs: []
  type: TYPE_NORMAL
- en: However, with the introduction of YAML pipelines, a new type of artifact has
    become available – the so-called pipeline artifact. This comes with the benefit
    of improving the speed at which large artifacts can be uploaded and downloaded.
    When working with classic releases, pipeline artifacts are not automatically downloaded,
    whereas build artifacts are.
  prefs: []
  type: TYPE_NORMAL
- en: 'To publish a pipeline artifact, the following YAML can be used in the `steps`
    keyword of a job:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Pipeline artifacts are mainly intended to be downloaded in multi-stage YAML
    pipelines, which are also covered in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Tips for writing YAML pipelines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing YAML pipelines from scratch can be complicated when you are just getting
    started. There are two tools available that can help you.
  prefs: []
  type: TYPE_NORMAL
- en: First, there is the option to export YAML from the visual designer. For every
    task, there is a link with the **View YAML** title. This opens a small pop-up
    box that shows you the YAML corresponding to the task and configuration that you
    currently have open. The same can be done for jobs and, under specific conditions,
    complete build definitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other tool available for writing YAML is the built-in YAML editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15 – The YAML editor ](img/B18655_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.15 – The YAML editor
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you open a YAML build definition, there are two tools available to
    help you. First, there is autocompletion for every location in your YAML file.
    This shows you the options available at that point in the file. As well as this,
    there are snippets available in the task picker on the right. When selecting any
    of the tasks on the right, you configure them visually and then click the **Add**
    button to add the generated YAML to your definition.
  prefs: []
  type: TYPE_NORMAL
- en: These two tools aim to bring the ease of the visual designer to the YAML build
    experience as well, combining the best of both worlds.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to these docs for a complete YAML schema reference: [https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema/?view=azure-pipelines](https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema/?view=azure-pipelines).'
  prefs: []
  type: TYPE_NORMAL
- en: Agents and agent queues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The build definitions that you have created so far can contain agent jobs,
    which in turn contain tasks. These tasks are not executed within your Azure DevOps
    organization directly but are instead executed by agents that run on VMs or in
    containers. In turn, agents are grouped in agent pools. There are two types of
    agent pools that you can work with:'
  prefs: []
  type: TYPE_NORMAL
- en: Built-in agent pools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Self-hosted agent pools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s go through them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in agent pools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Built-in agent pools are managed by Microsoft and are made available to you
    as part of the Azure DevOps product itself. There are different agent pools available,
    depending on your needs. Pools run different versions of Windows and Visual Studio,
    and there are also pools available that run Linux (Ubuntu) and macOS.
  prefs: []
  type: TYPE_NORMAL
- en: The disadvantage of these managed pools is that you cannot install extra software
    on the machines or containers that host the agents if you need to. This means
    that, in these cases, you have to create your own private agent pools.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a private agent pool
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Private pools are defined in your Azure DevOps organization and are provisioned
    from there to one or more of your team projects. However, you can also create
    your private pools at the team project level if they are created and provisioned
    in one go. To do so, go to **Project Settings** | **Agent pools**. You should
    see the following **Add agent pool** option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16 – Agent pool settings ](img/B18655_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.16 – Agent pool settings
  prefs: []
  type: TYPE_NORMAL
- en: After giving the pool a name and determining whether you want to automatically
    provide access to all pipelines, you can save the pool. After creating the pool,
    you can add or remove agents.
  prefs: []
  type: TYPE_NORMAL
- en: Adding and removing agents
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Adding an agent is done in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download and extract the agent runtime. You can find the agent runtime by going
    to the section with the overview of the agent pools and opening the details of
    any private agent pool. After the details of the pool are opened, click on **New
    agent** in the top-right corner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.17 – Adding a new agent ](img/B18655_05_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.17 – Adding a new agent
  prefs: []
  type: TYPE_NORMAL
- en: In the dialog that opens, you can download a ZIP file with the agent and instructions
    for extracting and installing the agent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: During the configuration phase, you will be prompted to authenticate with your
    Azure DevOps organization and provide the name of the agent pool you want to install
    the agent in. While there are x86 and x64 agents available, it is recommended
    that you work with the x64 agent unless you have a specific reason not to.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove agents from the pool, you can use one of two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can return to the PowerShell command line, just as you did for the installation,
    and use the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Alternatively, you can also remove agents from the agent pool overview using
    the **Agents** tab. Go to **Project Settings** | **Agent pools** (see **1** in
    the following screenshot) | **Agents** (see **2** in the following screenshot),
    and then select the options button (see **3** in the following screenshot) on
    the agent you want to remove. Then, click **Delete** (see **4** in the following
    screenshot):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.18 – Deleting an agent ](img/B18655_05_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.18 – Deleting an agent
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you can see the steps to remove an agent using
    the interface. Be aware that this does not clean up the binaries and any files
    on the host machine; however, if a machine that is hosting an agent breaks down
    or a VM is removed, this is the only way to remove the agent.
  prefs: []
  type: TYPE_NORMAL
- en: Agent selection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Whenever a build job starts running, an agent is selected from the pool that
    will perform the tasks that you have defined in the pipeline. The selection of
    an agent is done in two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Only agents that are part of the selected pool are eligible for running the
    tasks. This means that when working with private agent pools, it is wise to have
    multiple agents in a pool. If you then take one agent offline for maintenance,
    the agent jobs that rely on the agent pool can continue running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before an agent job can run, the demands from each job and the tasks it contains
    are gathered. As you learned in the *Variable groups* section, an agent job can
    specify the demands it has of the agent that it uses. The same goes for tasks
    – they can also specify demands. To run a job, only agents that meet all of these
    demands are used. Demands and capabilities are key/value pairs, where the value
    is an integer. Refer to these docs for examples of demands: [https://docs.microsoft.com/en-us/azure/devops/pipelines/process/demands](https://docs.microsoft.com/en-us/azure/devops/pipelines/process/demands).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When there is no eligible agent for a build definition, the build eventually
    fails after a timeout.
  prefs: []
  type: TYPE_NORMAL
- en: Finding agent capabilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To find the capabilities that are available on the individual agents, go through
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to **Organization Settings** | **Agent pools**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.19 – Viewing agent settings ](img/B18655_05_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.19 – Viewing agent settings
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the correct agent pool (either hosted or private), then **Agents**,
    and then open the agent details (not shown in the preceding screenshot).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Capabilities** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, you can specify one or more custom capabilities for the agent using the
    top block, called **User-defined capabilities**. For self-hosted (private) agents,
    all the capabilities that were discovered on the machine when you installed the
    agent are also shown.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of self-hosted agent pools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Use of Microsoft (cloud)-hosted agents is a fairly common practice and saves
    you a lot of time in managing and configuring your build infrastructure. Self-hosted
    agents have proven to be beneficial on many occasions. Due to the availability
    of a lot of good documentation, it has become an easy task for administrators
    to provision and configure a self-hosted agent for use in their pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main benefits of using a self-hosted agent are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing the cost of your build agents.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing additional software as required for your specific build tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving the performance of your builds, making them run faster by caching
    resources, and enabling incremental builds.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The debugging and troubleshooting of build issues are easier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows for **Virtual Network** (**Vnet**) integration, and you can securely
    run your builds behind the firewall.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing other corporate resources securely using whitelisted IP addresses.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will explore the option to automate CI builds for repositories
    hosted on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Automating CI builds using GitHub Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are using a GitHub repository, you can also automate your CI builds
    using GitHub Actions (available as a tab within the repository’s top navigation
    menu). You can either choose from an existing template workflow (with more than
    50 workflows available) or set up a custom workflow of your own:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20 – The available options in GitHub Actions ](img/B18655_05_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.20 – The available options in GitHub Actions
  prefs: []
  type: TYPE_NORMAL
- en: 'The experience of authoring a workflow is similar to creating a YAML file and
    saving it within your GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.21 – Editing a YAML file in the GitHub repository ](img/B18655_05_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.21 – Editing a YAML file in the GitHub repository
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, we will introduce alternative tools that can be used for
    managing the CI processes.
  prefs: []
  type: TYPE_NORMAL
- en: Other tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many tools available besides Azure DevOps. Two other well-known tools
    are GitLab CI and Jenkins. Some very basic knowledge of these tools will help
    you to understand how to integrate with them if that is ever necessary. Also,
    a limited understanding of other tools will help you to quickly understand the
    concepts and generalize your knowledge of how to work with these other tools.
  prefs: []
  type: TYPE_NORMAL
- en: To highlight how these tools work with the same concepts, both examples in this
    section are equivalent to the Azure DevOps YAML pipeline in the *Writing a YAML
    build definition* section.
  prefs: []
  type: TYPE_NORMAL
- en: GitLab CI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'GitLab offers build pipelines using the GitLab CI capabilities. GitLab CI is
    configured by putting a file with the `.gitlab-ci.yml` name in the root of a repository.
    In this file, you can define one or more stages and jobs, along with the tasks
    that they should perform. An example YAML file for GitLab CI can appear, as shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Just as Azure DevOps uses agent pools with agents, GitLab CI relies on **runners**
    to perform the actual work. In GitLab CI, there is currently no support for visually
    creating or editing your pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Jenkins is another tool used to run build pipelines. Complex builds can be
    run using Jenkins pipelines, which get their work from a Jenkinsfile. A **Jenkinsfile**
    is written in a Jenkins-specific notation, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Jenkins has limited support for visually creating and editing a pipeline. This
    is referred to as a freestyle project.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at continuous integration and learned how it is a
    combination of your mindset, the processes, and tools used by the development
    teams. You learned how to create build definitions using Azure Pipelines, using
    both the graphical designer and YAML, as well as how to run builds. You learned
    that you can use build pipelines to compile and test your code, as well as report
    the outcome back to pull requests.
  prefs: []
  type: TYPE_NORMAL
- en: You learned that builds can produce outputs, termed as Artifacts. Artifacts
    are stored and retained within Azure pipelines and can be used to store reports,
    but they are also the starting point of deployment pipelines, which you will learn
    about in the next chapter. You also learned about the infrastructure that you
    need to run builds – namely, agents and agent pools. Finally, you saw two brief
    examples of how to run a continuous integration build using GitLab CI and Jenkins,
    which are two other tools that you can use for build pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, you are now able to create build pipelines for your projects.
    You can hook up to source control and produce the builds that you will use in
    the next chapter to deploy your applications. With this deep knowledge of the
    underlying structure of tasks, jobs, stages, and pipelines, you can solve complex
    application-building problems.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will continue learning about pipelines but this time,
    for releases. You will learn how to pick up builds and release them to one or
    more environments.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter’s material. You will find the answers in the *Assessments*
    section of the appendix:'
  prefs: []
  type: TYPE_NORMAL
- en: True or false? You achieve continuous integration if you compile all the branches
    of your project at least daily.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: True or false? A classic build definition is always connected to a source code
    repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: True or false? A YAML pipeline definition is always connected to a source code
    repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is needed to call an external tool from an Azure pipeline?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: An external service definition
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: An Azure service connection
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A service connection
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A service locator
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What are some common reasons for using self-hosted agents? Choose all of the
    correct answers from the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Access to closed networks is needed.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Specific extension tasks need to be available to the agent.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: The number of parallel pipeline executions needs to be larger than 10.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Specific software needs to be installed in order for the agent to use it.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Add a folder named `pipelines` under the root directory of the `PacktBookLibrary`
    repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a subfolder named `build` under the `pipelines` directory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a build file named `main-ci-build.yml`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Insert the following code block in the file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the file and commit your changes to the branch. Push and then raise a pull
    request to merge your changes with the main branch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a new pipeline in your team project. In the **Configure your pipeline**
    step, select the **Existing Azure Pipelines YAML file** option:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 5.22 – Using an existing pipeline option ](img/B18655_05_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.22 – Using an existing pipeline option
  prefs: []
  type: TYPE_NORMAL
- en: When prompted to select the build pipeline, specify the `main-ci-build.yml`
    file. Click **Continue** to finish creating your build pipeline.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the pipeline job to verify that the build pipeline works. On the pipeline
    status page, review for any errors and the successful execution of the pipeline
    job.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The pipeline is composed of tasks to build a .NET Core project. To build other
    types of code components, make use of the appropriate task library.
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code repository for the starter kit can be found here: [https://github.com/PacktPublishing/Designing-and-Implementing-Microsoft-DevOps-Solutions-AZ-400-Exam-Guide](https://github.com/PacktPublishing/Designing-and-Implementing-Microsoft-DevOps-Solutions-AZ-400-Exam-Guide)'
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An in-depth definition of continuous integration by Martin Fowler is available
    at [https://martinfowler.com/articles/continuousIntegration.xhtml](https://martinfowler.com/articles/continuousIntegration.xhtml).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A detailed description of the conditions syntax is available at [https://docs.microsoft.com/en-us/azure/devops/pipelines/process/conditions?view=azure-devopstabs=classic](https://docs.microsoft.com/en-us/azure/devops/pipelines/process/conditions?view=azure-devopstabs=classic).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exercises for practicing with Azure DevOps builds can be found at [https://docs.microsoft.com/en-us/learn/modules/create-a-build-pipeline/index](https://docs.microsoft.com/en-us/learn/modules/create-a-build-pipeline/index).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the Visual Studio Marketplace for Azure DevOps at [https://marketplace.visualstudio.com/azuredevops](https://marketplace.visualstudio.com/azuredevops).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find a detailed description of the Azure Pipelines YAML syntax at [https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=azure-devopstabs=schema](https://docs.microsoft.com/en-us/azure/devops/pipelines/yaml-schema?view=azure-devopstabs=schema).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Details of the pricing of the Azure Pipelines’ hosted and self-hosted agent
    pools are available at [https://azure.microsoft.com/en-us/pricing/details/devops/azure-pipelines/](https://azure.microsoft.com/en-us/pricing/details/devops/azure-pipelines/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about GitLab CI can be found at [https://about.gitlab.com/product/continuous-integration/](https://about.gitlab.com/product/continuous-integration/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about Jenkins can be found at [https://jenkins.io/](https://jenkins.io/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Build tasks for .NET Core projects: [https://docs.microsoft.com/en-us/azure/devops/pipelines/ecosystems/dotnet-core?view=azure-devops&tabs=dotnetfive.](https://docs.microsoft.com/en-us/azure/devops/pipelines/ecosystems/dotnet-core?view=azure-devops&tabs=dotnetfive%20)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Develop a web extension*: [https://docs.microsoft.com/en-us/azure/devops/extend/get-started/node?view=azure-devops](https://docs.microsoft.com/en-us/azure/devops/extend/get-started/node?view=azure-devops).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
