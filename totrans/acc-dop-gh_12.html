<html><head></head><body>
		<div id="_idContainer139">
			<h1 id="_idParaDest-239"><em class="italic"><a id="_idTextAnchor239"/>Chapter 10</em>: Feature Flags and the Feature Lifecycle</h1>
			<p><strong class="bold">Feature Flags</strong> are one of the most game-changing capabilities I've seen over the years when working with teams. They have many different use cases. They can help you to reduce complexity in your development workflow by merging code early, or they can help you to perform zero-downtime deployments. Feature Flags help you to get more value out of your features by managing the entire feature lifecycle.</p>
			<p>In this chapter, I will explain what Feature Flags – also known as <strong class="bold">Feature Toggles</strong> – are and what you can do with them. Unfortunately, there is no native solution in GitHub to help with Feature Flags. There are too many frameworks and services available that you could use to introduce them all. But I will give you some guidance on how to pick the best tools for your use case.</p>
			<p>The main topics of this chapter are as follows:</p>
			<ul>
				<li>What are Feature Flags?</li>
				<li>The lifecycle of features</li>
				<li>The benefits of Feature Flags</li>
				<li>Getting started with Feature Flags</li>
				<li>Feature Flags and technical debt</li>
				<li>Experimentation with Feature Flags</li>
			</ul>
			<h1 id="_idParaDest-240"><a id="_idTextAnchor240"/>What are Feature Flags?</h1>
			<p><strong class="bold">Feature Flags</strong> are a technique in software development that allows modifying runtime behavior without <a id="_idIndexMarker663"/>changing code. It decouples the release of functionality to the end users from the rollout of the binaries.</p>
			<p>Feature Flags work like a switch or toggle and are, therefore, often called <strong class="bold">Feature Toggles</strong> or <strong class="bold">Feature Switches</strong> because of <a id="_idIndexMarker664"/>their Boolean nature. But Feature Flags can have <a id="_idIndexMarker665"/>many different use cases and can be more complex than a toggle. That's why the term <em class="italic">Feature Flag</em> is more suitable.</p>
			<p>Feature Flags allow you to encapsulate new code behind a Feature Flag and roll it out to the production system. The feature can <a id="_idIndexMarker666"/>then be enabled based on the context for a given target audience only (see <em class="italic">Figure 10.1</em>):</p>
			<div>
				<div id="_idContainer134" class="IMG---Figure">
					<img src="image/B17827_10_001.jpg" alt="Figure 10.1 – How Feature Flags work&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.1 – How Feature Flags work</p>
			<p>Feature Flags are a very natural technique for developers if you have continuous delivery available and a separate team that is responsible for the infrastructure. It's easier for developers to add a flag to the code than to change infrastructure, so you often end up with flags that allow testers to do different things than normal users or with some that allow some beta users to test some stuff. The problem is that if you are not explicit about Feature Flags, the configuration will normally end up in different places: config files, group memberships, and the application database. Being explicit about flags helps to <a id="_idIndexMarker667"/>improve the transparency in the team and ensures a uniform approach, and it enables more advanced use cases and ensures security and scalability.</p>
			<h1 id="_idParaDest-241"><a id="_idTextAnchor241"/>The lifecycle of features</h1>
			<p>Until a few years ago, most software was released every 1 or 2 years in major versions that had to be <a id="_idIndexMarker668"/>purchased separately or at least were coupled tightly to licensing through subscriptions. All the new features were squeezed into these new release versions. The new releases normally came with pieces of training, books, and online courses to teach the users the new features.</p>
			<p>These sales models basically do not exist anymore today. Customers want their software as a service. No matter if we talk about mobile apps such as Facebook or WhatsApp, or desktop software such as Office or Windows, software is updated and optimized continuously, and new features are added constantly. This brings the challenge of educating your end users on how to use the new features properly. An intuitive user experience and easy discoverability of new features are more important than they were with the old sales model. Features must be self-explanatory, and a simple on-screen dialog must be sufficient to educate users on how to use the new feature.</p>
			<p>Also, value creation is completely different. Customers do not make their buy decision every few years. They decide every day if they use the software for a task at hand or not. So, instead of putting a ton of new features into a new version to influence buy decisions, the focus is on delivering fewer features with a high value by removing features that are not used or optimizing them until they are of high value.</p>
			<p>This means every feature is subject to a lifecycle. The lifecycle of a feature could look like the one in <em class="italic">Figure 10.2</em>:</p>
			<div>
				<div id="_idContainer135" class="IMG---Figure">
					<img src="image/B17827_10_002.jpg" alt="Figure 10.2 – The lifecycle of features&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.2 – The lifecycle of features</p>
			<p>The lifecycle is subject to the following phases:</p>
			<ul>
				<li><strong class="bold">Ideation and development</strong>: After the idea for a new feature, the implementation starts with a few internal users. The feedback of these users is used to improve the feature.</li>
				<li><strong class="bold">Alpha or beta</strong>: In the alpha and/or beta phase, the feature is provisioned to a broader, but still very <a id="_idIndexMarker669"/>limited, audience. The audience can be internal or selected external customers. The alpha or beta phase can be closed (private) or open (public), but the feature in this phase is still very dynamic and can change dramatically.</li>
				<li><strong class="bold">Adoption</strong>: If the feature is mature enough for the market, it is gradually exposed to a broader audience. The adoption phase can be divided into the following sub-phases:<ol><li><strong class="bold">Preview</strong>: The users can <strong class="bold">opt in</strong> and enable the preview feature. </li><li><strong class="bold">Default for new users</strong>: The feature is the default for new users – but users could still <strong class="bold">opt out</strong> if they don't want to use it.</li><li><strong class="bold">Default for all users</strong>: The feature is enabled for all users, but users can still opt out.</li></ol></li>
				<li><strong class="bold">Normal operation</strong>: The feature is used by all users and an opt-out is not possible anymore. Previous <a id="_idIndexMarker670"/>versions of the feature get removed from the system. The normal operation can go on for many years.</li>
				<li><strong class="bold">Sundown</strong>: The feature is replaced by a newer and hopefully better feature. The number of users that use this feature declines and the cost of maintaining the feature exceeds its value. The feature is removed from the system when all users can be redirected to a new feature.</li>
			</ul>
			<p>Note that the value of the feature is the biggest in the early adoption phase as it attracts new users to your application. In the normal operations phase, the hype has probably flattened, and the competition has also learned from your feature and reacted by adjusting their software.</p>
			<h1 id="_idParaDest-242"><a id="_idTextAnchor242"/>The benefits of Feature Flags</h1>
			<p>Managing the lifecycle of a feature without using Feature Flags is impossible, but there are many other use cases <a id="_idIndexMarker671"/>where Feature Flags can bring value to your DevOps teams:</p>
			<ul>
				<li><strong class="bold">Release flags</strong>: These are used to roll out code behind a flag. Release flags normally stay in the <a id="_idIndexMarker672"/>code until the feature is rolled out completely. This can be weeks or months. Release flags change with each deployment or with the system's <a id="_idIndexMarker673"/>configuration. This means they can be implemented very easily by just reading a configuration value. But if you want to use release flags for <strong class="bold">canary releases</strong> (gradually exposing the feature to more and more users) or <strong class="bold">blue-green deployments</strong> (swapping staging and production environments), they are much more dynamic.</li>
				<li><strong class="bold">Experimentation flags</strong>: If you roll out multiple versions of the same feature and expose it to <a id="_idIndexMarker674"/>different audiences, it is called <strong class="bold">A/B testing</strong> or <strong class="bold">experimentation</strong>. It is normally used to confirm or diminish a hypothesis by measuring certain metrics <a id="_idIndexMarker675"/>of how users interact with the version <a id="_idIndexMarker676"/>of the feature. Experimentation flags are highly dynamic and rely on a lot of contexts to use them to address different target audiences.</li>
				<li><strong class="bold">Permission flags</strong>: A common use case of Feature Flags is to control what users can access. This can be <em class="italic">administration features</em> or <em class="italic">testing features</em> that are only exposed to certain audiences, or <em class="italic">premium features</em> that are only exposed to paying <a id="_idIndexMarker677"/>customers. Permission flags are highly dynamic <a id="_idIndexMarker678"/>and normally stay in the code for a long time – sometimes until the end of the application lifecycle. They also expose a high risk of fraud and must, therefore, be used carefully.</li>
				<li><strong class="bold">Operation flags</strong>: Some flags are used for operational aspects of the application – for example, <em class="italic">kill switches</em> used to disable certain functionality that can be a bottleneck <a id="_idIndexMarker679"/>for other features (also known as a <em class="italic">circuit breaker</em>). A flag to control <a id="_idIndexMarker680"/>different versions of a backend system is also considered an operation flag. Multi-variant flags are often used to control logging verbosity or other operational aspects.</li>
			</ul>
			<p><em class="italic">Figure 10.3</em> shows an overview of the different types of Feature Flags categorized by dynamic and the time they stay in the system:</p>
			<div>
				<div id="_idContainer136" class="IMG---Figure">
					<img src="image/B17827_10_003.jpg" alt="Figure 10.3 – Types of Feature Flags&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.3 – Types of Feature Flags</p>
			<p>Now that we have learned what Feature Flags are and what you can do with them, I will show you how you can implement them in code.</p>
			<h1 id="_idParaDest-243"><a id="_idTextAnchor243"/>Getting started with Feature Flags</h1>
			<p>In code, a Feature Flag is nothing more than an <strong class="source-inline">if</strong> statement. Let's assume you have a current <a id="_idIndexMarker681"/>implementation of the dialog to register new users:</p>
			<pre class="source-code">function showRegisterDialog(){</pre>
			<pre class="source-code">    // current implementation</pre>
			<pre class="source-code">}</pre>
			<p>Now, you want to create a new dialog using a Feature Flag and be able to switch on the new dialog at runtime:</p>
			<pre class="source-code">function showRegisterDialog(){</pre>
			<pre class="source-code">    var <strong class="bold">newRegisterDialog</strong> = false;</pre>
			<pre class="source-code">    if( <strong class="bold">newRegisterDialog</strong> ){</pre>
			<pre class="source-code">        return showNewRegisterDialog();</pre>
			<pre class="source-code">    }else{</pre>
			<pre class="source-code">        return showOldRegisterDialog();</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">function showNewRegisterDialog(){</pre>
			<pre class="source-code">    // new implementation</pre>
			<pre class="source-code">}</pre>
			<pre class="source-code">function showOldRegisterDialog(){</pre>
			<pre class="source-code">    // old implementation</pre>
			<pre class="source-code">}</pre>
			<p>To enable or disable <a id="_idIndexMarker682"/>the feature dynamically, you have to extract the validation of the Feature Flag into its own function:</p>
			<pre class="source-code">function showRegisterDialog(){</pre>
			<pre class="source-code">    if( featureIsEnabled("<strong class="bold">new-register-user-dialog</strong>") ){</pre>
			<pre class="source-code">        return showNewRegisterDialog();</pre>
			<pre class="source-code">    }else{</pre>
			<pre class="source-code">        return showOldRegisterDialog();</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>There are many options where you can store the configuration of the Feature Flag:</p>
			<ul>
				<li>The system configuration</li>
				<li>The user configuration</li>
				<li>The application database</li>
				<li>A separate database</li>
				<li>A separate system (accessed through an API)</li>
			</ul>
			<p>It highly depends on your <a id="_idIndexMarker683"/>use case what locations work or don't work.</p>
			<h1 id="_idParaDest-244"><a id="_idTextAnchor244"/>Feature Flags and technical debt</h1>
			<p>If you start using Feature Flags, you normally end up with a highly configurable system that can change its <a id="_idIndexMarker684"/>behavior at runtime – normally by many flags that are scattered across multiple configuration sources. The flags tend to have dependencies between each other, so enabling or disabling flags exposes a great risk to the stability of the system. You managed to escape <em class="italic">merge hell</em> by avoiding parallel branches, but ended up in <em class="italic">feature flag hell</em>, with hundreds of flags that nobody knows what they are for.</p>
			<p>To avoid this, you should <a id="_idIndexMarker685"/>follow these best practices:</p>
			<ul>
				<li><strong class="bold">Metrics</strong>: Even with all the value they provide, Feature Flags in your code are some kind of technical debt. You should measure them as you do code coverage or other code-related metrics. Measure the <em class="italic">number</em> of Feature Flags, how long they exist (<em class="italic">duration</em>), how they evaluate in each environment (<em class="italic">value</em>, 100% true in production probably means the flag can be removed), and how often the flags are used (<em class="italic">calls</em>).</li>
				<li><strong class="bold">Central management</strong>: Manage your flags in one central place, especially if you use different methods to manage the flags. Each flag should have an <em class="italic">owner</em> and a <em class="italic">description</em>. Document the <em class="italic">dependencies</em> between Feature Flags.</li>
				<li><strong class="bold">Integration into your process</strong>: Integrate the management of Feature Flags into your process. For example, if you use Scrum, you can integrate the review of the Feature Flags in the <em class="italic">review</em> meeting. Make sure that all the people who work with the flags regularly go through all the flags and check which ones can be removed from the system.</li>
				<li><strong class="bold">Naming conventions</strong>: Use naming conventions for all types of flags that you use. You could use <strong class="source-inline">tmp-</strong> as a prefix for temporary flags and <strong class="source-inline">perm-</strong> for permanent ones. Don't make it too complicated, but the name of the flag should immediately <a id="_idIndexMarker686"/>indicate what kind of flag it is and how long it is supposed to stick around in the code base.</li>
			</ul>
			<p>A technique that some teams like and others do not is <strong class="bold">cleaning up branches</strong>. You can see if this technique works for you. The idea is that the moment you create the flag and write the code, you know best how the code should look if the flag is removed one day. So, you create a cleanup branch and pull request alongside the code and leave the pull request open until the flag is removed. The technique works best with good naming conventions.</p>
			<p>Take the preceding example; you have a flag for a new feature dialog. The code with the flag looks like this:</p>
			<pre class="source-code">function showRegisterDialog(){</pre>
			<pre class="source-code">    if( featureIsEnabled("tmp-new-register-user-dialog") ){</pre>
			<pre class="source-code">        return showNewRegisterDialog();</pre>
			<pre class="source-code">    }else{</pre>
			<pre class="source-code">        return showOldRegisterDialog();</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">}</pre>
			<p>The code is developed in a <strong class="source-inline">features/new-register-dialog</strong> branch and you create the pull request to merge the code.</p>
			<p>You already know that the final state of the code, when the flag is removed, will only use the new dialog, so you create a new branch (for example, <strong class="source-inline">cleanup/new-register-dialog</strong>) and add the final version of the code:</p>
			<pre class="source-code">function showRegisterDialog(){</pre>
			<pre class="source-code">    return showNewRegisterDialog();</pre>
			<pre class="source-code">}</pre>
			<p>You can then create a pull request and leave it open until the feature is rolled out completely and <a id="_idIndexMarker687"/>you want to clean up the code.</p>
			<p>As I said, this technique is not well suited for all teams. Maintaining the cleanup branches can be a lot of work in a complex environment, but you can give it a try.</p>
			<p>Feature Flags that do not get cleaned up and are not actively maintained are technical debt, but the advantages outweigh the disadvantages. If you are careful from the beginning, you can avoid the feature flag hell and only benefit from the flexible power they provide you when releasing and operating your application.</p>
			<h1 id="_idParaDest-245"><a id="_idTextAnchor245"/>Frameworks and products</h1>
			<p>There are many frameworks available that you can leverage when implementing Feature Flags. The framework that is the best for you depends a lot on your programming languages and use cases. Some focus more on UI integration, some more on rollout and <a id="_idIndexMarker688"/>operations. When picking your framework, you should consider the following aspects:</p>
			<ul>
				<li><strong class="bold">Performance</strong>: Feature Flags must be fast and must not reduce the performance of your application. Proper caching should be used and also default values that are used if the data store cannot be reached on time.</li>
				<li><strong class="bold">Supported programming languages</strong>: Your solution should work with all your languages, especially when you use client-side flags; you must also evaluate them on the server for security reasons. You don't want to configure the flags in different locations.</li>
				<li><strong class="bold">UI integration</strong>: If you want to provide the users with the ability to opt in or out of features, you want a good integration into your UI. Normally, you need two flags for that: one to control the visibility, and one to enable or disable the feature.</li>
				<li><strong class="bold">Context</strong>: When you want to use Feature Flags for A/B testing and experimentation, you need a lot of context information to evaluate the flags: the user, group memberships, the region, and the server, for example. This is where many frameworks fail.</li>
				<li><strong class="bold">Central management</strong>: Flags that you configure for each environment separately, for example, are impossible to maintain. You need one central management platform where you can control all the flags in one place.</li>
				<li><strong class="bold">Data store</strong>: Some frameworks store the configuration in your application database. This is problematic for many scenarios. Normally, you have a different database in all <a id="_idIndexMarker689"/>your environments, so managing the settings across the environments is difficult.</li>
			</ul>
			<p>Building a scalable, performant, and mature solution takes a lot of time and effort, even when using frameworks, but there are also products available that you can install or consume <a id="_idIndexMarker690"/>as a service. A product that has been around for many <a id="_idIndexMarker691"/>years <a id="_idIndexMarker692"/>and is established mature is <strong class="bold">LaunchDarkly</strong> (<a href="https://launchdarkly.com/">https://launchdarkly.com/</a>). There <a id="_idIndexMarker693"/>is a lot of <a id="_idIndexMarker694"/>competition now, including <a id="_idIndexMarker695"/>the following:</p>
			<ul>
				<li><strong class="bold">Switchover</strong> (<a href="https://switchover.io/">https://switchover.io/</a>)</li>
				<li><strong class="bold">VWO</strong> (<a href="https://vwo.com/">https://vwo.com/</a>)</li>
				<li><strong class="bold">Split</strong> (<a href="https://www.split.io/">https://www.split.io/</a>)</li>
				<li><strong class="bold">Flagship</strong> (<a href="https://www.flagship.io/">https://www.flagship.io/</a>)</li>
				<li><strong class="bold">Azure App configuration</strong> (<a href="https://docs.microsoft.com/en-us/azure/azure-app-configuration/overview">https://docs.microsoft.com/en-us/azure/azure-app-configuration/overview</a>)</li>
			</ul>
			<p><strong class="bold">Unleash</strong> (https://www.getunleash.io/) is also worth mentioning. It has an <strong class="bold">open core</strong> (https://github.com/Unleash/unleash) and can be self-hosted free of charge as a Docker container. Unleash is <a id="_idIndexMarker696"/>also the solution that is used by GitLab.</p>
			<p>I could not find a good resource that compares the solutions, so I added a page on GitHub (<a href="https://wulfland.github.io/FeatureFlags/">https://wulfland.github.io/FeatureFlags/</a>) that provides an independent comparison of the solutions.</p>
			<p>When it comes to the make-or-buy decision, most companies are better off using an existing service or product. Building and running a good solution for Feature Flags is difficult and time-consuming, especially if you are new to Feature Flags. Start with a good product. If, after some time, you still find it necessary to build your own solution, at least you have experience knowing what a solution should be able to do.</p>
			<h1 id="_idParaDest-246"><a id="_idTextAnchor246"/>Experimentation with Feature Flags</h1>
			<p>Experimentation and A/B testing cannot only be done using Feature Flags. You can also develop containers <a id="_idIndexMarker697"/>in different branches and <a id="_idIndexMarker698"/>use Kubernetes to run different versions in production; however, this will increase your complexity in Git and does not scale well. You don't have the context for the users either, so gathering the data to prove or diminish your hypothesis is much harder. Most of the solutions for Feature Flags have built-in support for experiments, so this is the fastest way to get started.</p>
			<p>To experiment, you define a hypothesis, conduct an experiment, and then learn from the results. An experiment can be defined as follows (see <em class="italic">Figure 10.4</em>):</p>
			<ul>
				<li><strong class="bold">Hypothesis</strong>: We believe <em class="italic">{customer segment}</em>, wants <em class="italic">{product/feature}</em> because <em class="italic">{value prop}</em>.</li>
				<li><strong class="bold">Experiment</strong>: To prove or disprove the preceding, the team will conduct an experiment.</li>
				<li><strong class="bold">Learning</strong>: The experiment will prove the hypothesis by impacting the following metrics.</li>
			</ul>
			<div>
				<div id="_idContainer137" class="IMG---Figure">
					<img src="image/B17827_10_004.jpg" alt="Figure 10.4 – Conducting experiments with Feature Flags&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.4 – Conducting experiments with Feature Flags</p>
			<p>Let's have a look at an example. By looking into the usage data of your application, you realize that the page views for the first page of the registration dialog for new users are much higher <a id="_idIndexMarker699"/>than the number of people that <a id="_idIndexMarker700"/>finish the registration process. Only about 20% of them finish the registration. The hypothesis is that the register dialog is too complex and that the number of people finishing the registration will increase dramatically when the dialog is simplified.</p>
			<p>To conduct the experiment, you add two new metrics to your application: <strong class="source-inline">started-registration</strong>, which increases every time a user clicks on the <strong class="bold">Register</strong> link, and <strong class="source-inline">finished-registrations</strong>, which increase after the user successfully registers for your application. The two metrics make it easy to calculate <strong class="source-inline">aborted-registrations</strong>. You gather the data during the next few weeks and confirm that the aborted registration rate has an average of 80% over these weeks. Your team creates a new, simple dialog using a <strong class="source-inline">new-register-dialog</strong> Feature Flag. It removes all required fields that are not necessary for the registration itself, such as address and payment information, and ships the code to production. The data is validated before checkout anyway, so the simplified registration works, even if this might be a usability problem for the checkout.</p>
			<p>In production, you turn on the flag for 50% of the new users and compare the <strong class="source-inline">aborted-registrations</strong> rate for the two groups. The users that see the old dialog stay as expected at around 70% to 80% aborted, whereas the users with the new dialog only have an aborted rate of 55%.</p>
			<p>The result is still not perfect so you start adding new metrics to find out where in the dialog the people are struggling. This leads to the next hypothesis (see <em class="italic">Figure 10.5</em>):</p>
			<div>
				<div id="_idContainer138" class="IMG---Figure">
					<img src="image/B17827_10_005.jpg" alt="Figure 10.5 – Conducting experiments with Feature Flags&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 10.5 – Conducting experiments with Feature Flags</p>
			<p>To experiment <a id="_idIndexMarker701"/>with Feature Flags, you need data. Only <a id="_idIndexMarker702"/>with the right metrics and the ability to map the metrics to audiences that have certain flags on or off are you able to really perform evidence-based development.</p>
			<p>In <em class="italic">Chapter 19</em>, <em class="italic">Experimentation and A/B Testing with GitHub</em>, we will, unsurprisingly, have a closer look into experimentation and A/B testing with GitHub.</p>
			<h1 id="_idParaDest-247"><a id="_idTextAnchor247"/>Summary</h1>
			<p>Feature Flags are one of the most important capabilities for the acceleration of DevOps teams. Unfortunately, GitHub does not have a built-in solution so far. But there are many products that can help you to get up to speed.</p>
			<p>In this chapter, you learned about the feature lifecycle and how you can manage it using Feature Flags. You also learned how you can leverage Feature Flags to reduce complexity by checking code early.</p>
			<p>In the next chapter, you'll learn about trunk-based development and the best Git workflow to support fast DevOps teams.</p>
			<h1 id="_idParaDest-248"><a id="_idTextAnchor248"/>Further reading</h1>
			<p>You can get more information on the topics here:</p>
			<ul>
				<li>Martin Fowler, <em class="italic">Feature-Toggles (aka Feature Flags)</em>, 2017: <a href="https://martinfowler.com/articles/feature-toggles.html">https://martinfowler.com/articles/feature-toggles.html</a></li>
				<li>Comparison of Feature Flag solutions: <a href="https://wulfland.github.io/FeatureFlags/">https://wulfland.github.io/FeatureFlags/</a></li>
				<li>LaunchDarkly: <a href="https://launchdarkly.com/">https://launchdarkly.com/</a></li>
				<li>Switchover: <a href="https://switchover.io/">https://switchover.io/</a></li>
				<li>VWO: <a href="https://vwo.com/">https://vwo.com/</a></li>
				<li>Split: <a href="https://www.split.io/">https://www.split.io/</a></li>
				<li>Flagship: <a href="https://www.flagship.io/">https://www.flagship.io/</a></li>
				<li>Unleash: <a href="https://www.getunleash.io/">https://www.getunleash.io/</a> and <a href="https://github.com/Unleash/unleash">https://github.com/Unleash/unleash</a></li>
			</ul>
		</div>
	</body></html>