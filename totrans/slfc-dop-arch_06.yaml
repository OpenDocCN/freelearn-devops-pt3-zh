- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring Packaging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many ways to deliver Salesforce changes between environments and still
    adhere to DevOps principles. One of the popular mechanisms is the use of Salesforce
    packages, which can be either managed, unmanaged, or unlocked packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll look at these three types of Salesforce packages, their
    use cases, and considerations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unmanaged packages** – Used to share customizations or applications with
    other organizations or users without any built-in versioning or upgrade capabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unlocked packages** – Designed for efficient application life cycle management,
    modular development, and versioning within a single organization. They are also
    a popular means of distributing open source solutions on the Salesforce platform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Managed packages** – Designed to distribute custom applications, extensions,
    or integrations built on the Salesforce platform to multiple organizations or
    customers, with protection of the code used to build them, versioning, and upgradability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will have a clear idea of not only the differences
    between these different types of packages but also when to use them and how to
    build them in Salesforce.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For unmanaged, unlocked, and 2GP-managed packages, there shouldn’t be any additional
    requirements other than your Salesforce environment – ideally either a **Sandbox**
    or a **Developer** Edition.
  prefs: []
  type: TYPE_NORMAL
- en: For 1GP-managed packages, you will need a separate packaging org when developing
    a managed package for distribution. A packaging org is a separate Salesforce org
    used to develop, package, and distribute managed packages.
  prefs: []
  type: TYPE_NORMAL
- en: For Salesforce ISV partners, this would typically be a **Partner Developer Edition**
    org, which has additional features and higher limits compared to a regular Developer
    Edition org. These are for use by Salesforce registered partners and aren’t for
    general everyday use by most Salesforce customers.
  prefs: []
  type: TYPE_NORMAL
- en: An example project for testing package commands is provided in the `Chapter6`
    folder of the GitHub repository associated with this book.
  prefs: []
  type: TYPE_NORMAL
- en: Unmanaged packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unmanaged packages form a part of Salesforce’s original implementation of packaging,
    and as such, form part of what is now known as **first-generation packaging**
    (**1GP**). They are used to bundle and share customizations, applications, or
    templates between different organizations or users. Unmanaged packages provide
    a way to distribute components, allowing developers to modify or build upon them
    as needed after installation.
  prefs: []
  type: TYPE_NORMAL
- en: Since unmanaged packages are part of 1GP, they follow a development and packaging
    process that is seldom source-driven. This means that the components within the
    package are typically selected from an org rather than a branch in a version control
    system. The lack of source-driven development with unmanaged packages makes it
    difficult to establish a streamlined and efficient DevOps process that involves
    version control, continuous integration, and continuous deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Another limitation of this approach is that unmanaged packages do not support
    versioning of the packages themselves or in-place upgrades. Any updates or changes
    to the components within an unmanaged package must be done manually in the target
    org after installation. This can lead to challenges in managing and maintaining
    customizations over time, especially in larger and more complex Salesforce implementations.
  prefs: []
  type: TYPE_NORMAL
- en: The absence of a package-specific namespace in unmanaged packages also means
    that their components merge into the target org’s metadata without any separation.
    This can lead to naming conflicts and potential issues during deployment, making
    it more difficult to manage dependencies and maintain a clean metadata structure
    in the target org. If an unmanaged package is installed into a namespaced org,
    the components will inherit the org’s namespace.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are several limitations to the original 1GP approach and
    this is why Salesforce replaced it with **second-generation packaging** (**2GP**),
    which is what is now recommended.
  prefs: []
  type: TYPE_NORMAL
- en: As we’ve discussed, unmanaged packages are not ideally suited for use as part
    of your DevOps strategy, so let’s look at unlocked packages, which were introduced
    with Salesforce’s 2GP implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Unlocked packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Salesforce unlocked packages are a modern, flexible, and modular packaging solution
    that allows developers and administrators to bundle, deploy, and manage customizations
    and applications built on the Salesforce platform. They are part of Salesforce’s
    source-driven development approach, which emphasizes version control systems and
    continuous integration pipelines for efficient development and deployment processes.
  prefs: []
  type: TYPE_NORMAL
- en: Unlocked packages address the challenges of managing and deploying customizations
    in large-scale and complex Salesforce implementations. By breaking down applications
    and customizations into modular units, they enable teams to manage and distribute
    these components more effectively. This modular approach promotes better collaboration,
    easier version control, and a streamlined development process. Unlocked packages
    are aimed at both developers and administrators who want to leverage best practices
    in application life cycle management, streamline their deployment processes, and
    reduce the complexity associated with metadata deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike managed packages, which are primarily used for distributing applications
    to multiple companies or customers, unlocked packages are designed for use within
    a single company. They are especially useful for enterprises with large Salesforce
    teams that require a structured and maintainable way to manage and deploy customizations
    across various environments, such as development, testing, and production. By
    providing a scalable and modular approach to Salesforce development, unlocked
    packages help organizations optimize their Salesforce implementations and drive
    better business outcomes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since unlocked packages are a source-driven approach to packaging, there is
    a greater reliance on the use of the command line to create them. You will need
    to be using the **Salesforce DX** (**SFDX**) approach to managing your metadata,
    and thus have a Dev Hub enabled. To do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to your Salesforce org.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the gear icon in the top-right corner and select **Setup**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Dev Hub` and select it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Toggle the **Enable Dev Hub** switch to **On** and enable **Unlocked Packages**
    on the same screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once this is enabled, you can then work with your Dev Hub org from the command
    line – whether that’s a standalone one or the embedded terminal in VS Code. To
    create a new unlocked package, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Replace `MyPackageName` with the name of your package and `MyDevHub` with the
    alias you used when authenticating with your Dev Hub org.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, it is assumed that you have a local project and that you have
    committed your code to Git. While source control of your changes is not essential
    for creating the package, as part of a DevOps process, this would be a good time
    to ensure your Git repository is up to date before creating your new package.
    With your updated metadata components in your local project, you can create a
    new package with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Replace `MyPackageName` with the name of your package, `MyPassword` with a password
    for the package (optional), and `MyDevHub` with the alias you used when authenticating
    with your Dev Hub org.
  prefs: []
  type: TYPE_NORMAL
- en: 'After creating a new package version, the added metadata components will be
    included in the unlocked package. You can install this package in your target
    Salesforce org with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Again, you will need to replace `MyPackageName@1.0.0` with the package name
    and version, and `MyTargetOrg` with the username or alias of your target org.
    It is worth noting that if a password was set in the preceding version creation,
    it will have to be supplied here with the `-k` flag for the installation to work.
  prefs: []
  type: TYPE_NORMAL
- en: Since unlocked packages have the foundation of a source-driven development approach
    rather than an org-driven approach, it is much better aligned to the use of DevOps
    throughout your entire process. By making use of source control and breaking down
    larger code bases into modular groups of functionality that could potentially
    be in their own separate Git repositories, you can be much more flexible in your
    approach to delivery using unlocked packages.
  prefs: []
  type: TYPE_NORMAL
- en: The one potential catch in this degree of modularization, however, is that there
    are sometimes situations in which there are pieces of metadata that overlap multiple
    packages. For example, if you have two distinct pieces of functionality that both
    make use of or depend upon the `Opportunity` object, you could potentially end
    up with a situation where there is a circular dependency on changes across packages.
  prefs: []
  type: TYPE_NORMAL
- en: A workaround to this could be to have a centralized `core` package that the
    other packages all reference. During the development of new functionality outside
    of this package, you would ensure you have installed the latest version of this
    core package in your development environment.
  prefs: []
  type: TYPE_NORMAL
- en: A better approach is to make good use of namespaces in your unlocked package
    development. Namespaces should be an integral part of creating Salesforce unlocked
    packages. They guarantee uniqueness – if someone already has an Apex class named
    `MyClass`, your `MyClass` won’t conflict with it, which avoids tricky naming clashes.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces also enable effective versioning of packages. Salesforce uses the
    namespace to manage multiple versions of a package, knowing which are compatible
    and how to handle upgrades or rollbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, namespaces provide another means to provide clear separation of
    package code. It becomes evident which components belong to a particular package,
    isolating its code from the rest of the org’s metadata. This aids in debugging
    and maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: At the code level, rather than at the point of packaging, there are some additional
    benefits to be found. Namespaces remove ambiguity when third-party systems integrate
    with your package’s APIs and components. References are clear even with dynamic
    SOQL or REST calls, and namespaces allow control over which components are globally
    accessible versus private. Boundaries can be set on what’s exposed for general
    use.
  prefs: []
  type: TYPE_NORMAL
- en: When creating a package, the first step is registering a unique namespace identifier.
    This ties all components to that namespace. Next, the namespace is included in
    the package metadata when building a new version – during installation, Salesforce
    leverages the namespace to separate incoming components, avoiding conflicts. In
    code and configuration, components can be referenced with their namespace prefix,
    such as `namespace__MyClass`.
  prefs: []
  type: TYPE_NORMAL
- en: However, namespaces also come with some downsides. They lock you into a permanent
    identifier that can’t easily change later. Complexity gets introduced by referencing
    namespaced components. Migrating existing `un-namespaced` code can require cumbersome
    adjustments. The availability of intuitive namespaces may be limited. Debugging
    across multiple namespaced packages can become complicated.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, the benefits outweigh the limitations, especially for manageability
    and version control. But it’s important to be aware of the cons and plan your
    naming and development accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, Salesforce also recognizes this challenge and provides another package
    type to cover this eventuality. Let’s explore these org-dependent packages a little
    further.
  prefs: []
  type: TYPE_NORMAL
- en: Org-dependent packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The other type of unlocked package that Salesforce provides, org-dependent packages,
    tackles the problem of dependencies by deferring compilation and validation of
    your changes until installation time. This means that these dependencies don’t
    necessarily need to be in your development org or in your source control for you
    to build the package – you can depend on metadata that exists in the target org.
  prefs: []
  type: TYPE_NORMAL
- en: This type of unlocked package is ideal for Salesforce orgs that are large, complex,
    and have been in use for a long time and thus have accumulated a lot of changes.
    Unpicking these changes into separate modules is lengthy, challenging work, but
    by having a package type that is able to depend on unpackaged metadata in the
    target org, you can defer (or even avoid) the need to refactor your entire org.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating an org-dependent package is incredibly simple, too – the command is
    the same as that for creating an unlocked package, but with the `--orgdependent`
    flag specified, such as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You might be tempted to make all your unlocked packages org-dependent to gain
    the advantage of just-in-time validation, but there are some key drawbacks to
    org-dependent packages that ultimately mean you should always assess the correct
    package type for your use case:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Feature** | **Unlocked packages** | **Org-dependent packages** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Installation flexibility** | You can install these packages in any org,
    regardless of the metadata they contain. | You can only install these packages
    in orgs that have the specific metadata that the package depends on. |'
  prefs: []
  type: TYPE_TB
- en: '| **Dependency** **validation time** | The package dependencies are checked
    when you create the package version. | The package dependencies are checked when
    you install the package in an org. |'
  prefs: []
  type: TYPE_TB
- en: '| **Dependency on** **other packages** | These packages can depend on other
    packages. | These packages cannot depend on other packages. |'
  prefs: []
  type: TYPE_TB
- en: '| **Dependency resolution** | You need to resolve all the dependencies before
    you can create the package. | You do not need to resolve any dependencies before
    you can create the package. |'
  prefs: []
  type: TYPE_TB
- en: '| **Supported** **metadata types** | Refer to the unlocked packaging channel
    of the Metadata Coverage report for the list of supported metadata types. | Refer
    to the unlocked packaging channel of the Metadata Coverage report for the list
    of supported metadata types. |'
  prefs: []
  type: TYPE_TB
- en: '| **Development and** **test environment** | Use scratch orgs to develop and
    test your unlocked packages. | Use a sandbox that has the dependent metadata.
    You can also enable Source Tracking in sandboxes to develop your org-dependent
    unlocked package. Test the package in a sandbox org before installing it in your
    production org. |'
  prefs: []
  type: TYPE_TB
- en: '| **Code** **coverage requirement** | You must have at least 75% code coverage
    for the Apex code in your package before you can promote and release it. | There
    is no code coverage calculation, but you should test your Apex code well. |'
  prefs: []
  type: TYPE_TB
- en: Table 6.1 – A comparison of unlocked and org-dependent packages
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’re going to look at the final type of packaging in Salesforce,
    managed packages.
  prefs: []
  type: TYPE_NORMAL
- en: Managed packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Salesforce managed packages are developed, packaged, and distributed by Salesforce
    partners – also known as **independent software vendors** (**ISVs**). These packages
    provide a way to extend the functionality of Salesforce by adding new features,
    processes, or applications without having to build them from scratch. Managed
    packages are distributed through the Salesforce AppExchange, which is an online
    marketplace for Salesforce applications, components, and services. AppExchange
    allows developers and partners to publish their managed packages for Salesforce
    customers to discover, evaluate, and install them directly into their Salesforce
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: Managed packages often can be customized to meet specific business needs while
    maintaining the core functionality provided by the package, but the level of customization
    possible will vary depending on the metadata contained within the package. The
    Salesforce DX Developer Guide has a section on what can and can’t be changed in
    managed packages and can be found at [https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/packaging_packageable_components.htm](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/packaging_packageable_components.htm).
  prefs: []
  type: TYPE_NORMAL
- en: The package provider is responsible for maintaining and upgrading the package,
    ensuring it stays compatible with the latest Salesforce releases and industry
    standards. This reduces the burden on the organization using the package, especially
    if it is using the package as installed with no further customizations or changes
    to the metadata in the package.
  prefs: []
  type: TYPE_NORMAL
- en: Salesforce stands out from other development platforms such as Java or C# due
    to its strong emphasis on backward compatibility and API stability for developers.
    When you build applications on top of the Salesforce platform, you can have confidence
    that the core APIs you rely on will not suddenly be deprecated or altered unexpectedly.
  prefs: []
  type: TYPE_NORMAL
- en: With languages such as Java or C#, core libraries or methods can be deprecated
    with just a notification that they will be removed in an upcoming release. This
    forces you, as a developer, to continually refactor your code to stay current.
    But Salesforce takes a very different approach to managing upgrades and keeping
    customers happy.
  prefs: []
  type: TYPE_NORMAL
- en: Once an Apex API is released as part of a managed package on Salesforce, its
    method signature is locked in place. The API functionality may evolve over time,
    even to the point of throwing new exceptions, but the original method and signature
    will remain intact. This prevents the common problem developers face of having
    to hastily refactor their own customizations just to install an upgrade to a dependent
    package.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, managed packages undergo a thorough security review process by
    Salesforce to ensure they meet the necessary standards for performance, data protection,
    and privacy. This provides an additional layer of trust for organizations using
    these packages.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, the life cycle of managed packages differs only in the approval and
    distribution stages. Managed packages are developed in scratch orgs and distributed
    through the Salesforce AppExchange. Participating in this marketplace requires
    you to enroll with Salesforce as an ISV partner with a valid business case for
    your package. Once approved, you can then move on to producing your package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how the distribution process typically works:'
  prefs: []
  type: TYPE_NORMAL
- en: Development
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Packaging
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Security review
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AppExchange listing
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Installation and configuration
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ongoing support and upgrades
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The package creator develops the managed package using Salesforce tools such
    as Apex, Visualforce, Lightning Components, and more, ensuring compatibility with
    Salesforce.
  prefs: []
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like any other piece of Salesforce development, the metadata and code for the
    package should be fully tested, not just to ensure that it is functionally complete
    but also to meet the stringent expectations for security that ISV partners should
    adhere to.
  prefs: []
  type: TYPE_NORMAL
- en: Salesforce provides several tools to help guide developers through this process,
    such as Salesforce Code Analyzer. This tool makes use of the Salesforce Graph
    Engine to do a deep walk through the code, following dependencies and looking
    for common security issues – particularly those around record access – using a
    technique called **data flow analysis** (**DFA**). DFA is a method that helps
    you to understand complicated parts of computer code better. It looks at the whole
    code all at once to figure out what’s going on in it. It does this by breaking
    down the code’s steps, including things such as evaluating conditions, creating
    classes, and calling methods and static calls. It also tries to guess the value
    of the variables and fields at each step along the way. This all helps to give
    a better picture of how the code works.
  prefs: []
  type: TYPE_NORMAL
- en: The analyzer also makes use of other open source analysis engines, such as PMD
    and ESLint, to round out the coverage of these checks.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Historically, managed packages followed a lengthy process along the lines of
    1GP, as discussed earlier, which involved the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the components to be included, such as Apex classes, Visualforce pages,
    Lightning Components, custom objects, and more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting the package properties, such as the package name, namespace, version
    number, and description
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining dependencies on other packages or Salesforce features, if any
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designating the package as managed to ensure versioning, upgradeability, and
    intellectual property protection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The package can then be uploaded to the Salesforce environment, generating an
    installation URL for distribution.
  prefs: []
  type: TYPE_NORMAL
- en: With the advent of 2GP, this process has become much more simplified. First,
    ensure that all components required for your package are in your project directory
    (typically in the `force-app` folder). This project should be linked to a corresponding
    scratch org and the required namespace should be specified in your `sfdx-project.json`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The process for creating the actual package is more straightforward than the
    old 1GP approach, differing from unlocked packages by one simple command-line
    parameter, `-t Managed`, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Security review
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before a managed package can be listed on the AppExchange, it must undergo
    a security review process. This process involves the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A comprehensive assessment of the package’s code and components to identify
    potential security vulnerabilities, such as injection attacks, insecure storage
    of sensitive data, and improper access controls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring that the package adheres to Salesforce’s security guidelines, best
    practices, and compliance requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Submitting a security review request to Salesforce, along with relevant documentation
    and test cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Addressing any security issues identified by Salesforce during the review process
    and resubmitting the package for approval
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the package passes the security review, it is granted the **Passed Security
    Review** status, signaling to customers that it meets Salesforce’s security standards.
  prefs: []
  type: TYPE_NORMAL
- en: AppExchange listing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After passing the security review, the package can be listed on the Salesforce
    AppExchange. Listing the package involves the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an AppExchange listing with essential information about the package,
    such as its name, description, features, pricing, and support details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding screenshots, videos, or other media that showcase the package’s functionality
    and benefits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Associating the listing with the managed package using the installation URL
    generated during the packaging process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Submitting the listing for approval by Salesforce, which will review it for
    quality, branding, and content guidelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the listing is approved, it becomes publicly available on the AppExchange,
    allowing customers to discover and evaluate the package.
  prefs: []
  type: TYPE_NORMAL
- en: Installation and configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Salesforce customers can find, evaluate, and install managed packages from
    the AppExchange by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Browsing the AppExchange to discover packages that address their specific needs
    using search, filters, and categories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Evaluating the package by reviewing its description, features, pricing, customer
    reviews, and any available demos or trials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing the package by clicking the **Get It Now** button on the AppExchange
    listing, which initiates the installation process in the customer’s Salesforce
    environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Granting access and setting up security settings for the package during installation,
    ensuring it aligns with the organization’s security policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the package post-installation by customizing settings, adjusting
    layouts, or setting up any required integrations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once installed and configured, the managed package becomes an integral part
    of the customer’s Salesforce environment, extending the platform’s functionality
    to address their specific needs and requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Ongoing support and upgrades
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After the package is installed and configured, the package provider is responsible
    for offering ongoing support and updates. This ensures that the package remains
    compatible with the latest Salesforce releases, industry standards, and customer
    expectations. The ongoing support and upgrade process typically involves the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring and addressing customer feedback, questions, and issues through support
    channels such as email, phone, or online forums.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regularly releasing updates to the package to fix bugs, enhance features, and
    add new functionality. These updates are created as new package versions that
    customers can choose to install at their convenience.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensuring compatibility with the latest Salesforce releases, making any necessary
    adjustments to maintain seamless integration with the platform.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Staying up to date with industry trends, customer needs, and technology advancements
    to ensure the package remains relevant and valuable to customers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Informing customers about important updates, new features, and best practices
    through communication channels such as newsletters, webinars, or in-app notifications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ongoing support and upgrades provided by the package provider contribute
    to the package’s long-term success, customer satisfaction, and overall value.
  prefs: []
  type: TYPE_NORMAL
- en: Packaging models’ pros and cons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Packaging serves as a distribution method for development updates in a broader
    DevOps process, aligning with source-driven software development principles. As
    various package types offer distinct use cases and strengths, selecting the most
    suitable delivery model is crucial to optimizing your workflow within the DevOps
    life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s remind ourselves of the differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Package type** | **Pros** | **Cons** | **Primary** **use cases** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| **Unmanaged** | Easy to customize | No version control | Sharing code and
    configurations for learning purposes |'
  prefs: []
  type: TYPE_TB
- en: '|  | Allows for code editing | No automatic upgrades | Sharing sample solutions
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | No namespace requirements | Security concerns due to editable code | Collaborative
    development |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | No support for managed package features | Can be used by Professional
    Services teams where there’s a common customization that many customers require,
    but which itself may need the odd tweak for each customer |'
  prefs: []
  type: TYPE_TB
- en: '| **Unlocked** | Easy to customize | No automatic upgrades | Deploying reusable
    components across multiple orgs |'
  prefs: []
  type: TYPE_TB
- en: '|  | Version control | Manual upgrade process | Sharing modular solutions |'
  prefs: []
  type: TYPE_TB
- en: '|  | Allows for code editing | Security concerns due to editable code | Facilitating
    internal collaboration and development |'
  prefs: []
  type: TYPE_TB
- en: '|  | Supports managed package features (e.g., namespaces) | Requires Salesforce
    DX and source-driven development |  |'
  prefs: []
  type: TYPE_TB
- en: '| **Managed** | Automatic upgrades | Limited customization | Commercial app
    distribution |'
  prefs: []
  type: TYPE_TB
- en: '|  | Version control | Code not editable | Distributing apps on the AppExchange
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | Enhanced security due to uneditable code | Requires namespaces | Protecting
    intellectual property |'
  prefs: []
  type: TYPE_TB
- en: '|  | Supports managed package features (e.g., namespaces) | 2GP requires Salesforce
    DX and source-driven development (although 1GP can still be done without DX patterns)
    |  |'
  prefs: []
  type: TYPE_TB
- en: Table 6.2 – The pros and cons of each package type
  prefs: []
  type: TYPE_NORMAL
- en: Breaking up an existing monolithic application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Migrating a mature, monolithic application to Salesforce’s package development
    model can be a major undertaking filled with complexities and challenges.
  prefs: []
  type: TYPE_NORMAL
- en: On the complexity side, code refactoring is often needed to break tight couplings
    and fit components into modular packages. Dependency management becomes critical
    to untangle interconnected components. Introducing namespaces can add complexity
    in updating all references. Data models may need reworking to fit the new packaged
    schema. Permission sets and profiles will likely require redefinition. Automation
    and CI/CD pipelines need adaptation to handle packaging, versioning, and dependencies.
    Keeping various org environments in sync with the correct package versions is
    complex to orchestrate.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of challenges, the transition will require extensive investment in
    resources and time. There will be a knowledge gap as teams learn the new model.
    Testing strategies need an overhaul, potentially including rewriting tests and
    scripts while setting up new test environments. Maintaining backward compatibility
    could limit changes, forcing the need for legacy system support. Once transitioned,
    version management across packages and customers multiplies the complexity. Stakeholders
    accustomed to quick deployments may resist the slower, more controlled package
    life cycle. Apart from staffing costs, expenses such as training, downtime, and
    tools will accumulate.
  prefs: []
  type: TYPE_NORMAL
- en: To smooth the transition, a phased, gradual approach can help. Extensive training
    and expert consulting will build the necessary skills. Detailed documentation
    provides a knowledge base. Feedback channels give early visibility of issues.
    Risk assessments and rollback plans mitigate pitfalls. Proper resource allocation,
    both human and computational, lays the groundwork.
  prefs: []
  type: TYPE_NORMAL
- en: While difficult, migrating a monolithic application to the package model can
    ultimately enable modular, scalable development and easier maintenance. With careful
    planning and execution, the long-term benefits may outweigh the complexities of
    getting there.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ve looked at packaging as a technique for deploying our
    code changes and compared the different types of packages available. For each
    type of package, we have seen the steps required to bundle our Salesforce changes
    into those packages for further distribution.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve also seen that these changes can follow a source-driven DevOps process
    if we select the appropriate type of package. Packaging by no means replaces DevOps
    processes; rather, it is a technique that forms part of DevOps on the Salesforce
    platform. Equally, it is not the only means of delivering your changes for scenarios
    outside of the ISV Partner space.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll start looking at bringing all the elements of our
    source-driven workflow together and adding some automation as we investigate the
    CI/CD automation of our processes. This represents an alternative delivery mechanism
    for our changes that doesn’t require packaging.
  prefs: []
  type: TYPE_NORMAL
