- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Docker Basics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 基础
- en: In this chapter, we introduce one of the building blocks of the DevOps toolkit
    – containers. We are going to explain the differences between virtualization and
    containers, and then present the advantages and disadvantages of both solutions.
    Additionally, we are going to present a way to choose between both solutions for
    a given workload.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们介绍 DevOps 工具包的一个基础构件——容器。我们将解释虚拟化和容器之间的区别，并展示这两种解决方案的优缺点。此外，我们还将展示如何根据工作负载选择适合的解决方案。
- en: 'The main topics covered in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章覆盖的主要主题如下：
- en: Virtualization versus containerization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟化与容器化
- en: Anatomy of Docker
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 架构
- en: Docker commands
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 命令
- en: Dockerfile
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dockerfile
- en: Docker image registries
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 镜像注册表
- en: Docker networking
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 网络
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you will need a Linux system with an installed Docker Engine.
    We are not going to cover the installation steps here. Different Linux distributions
    provide Docker in different ways. We are going to use Docker Engine 20.10.23 here.
    Since in this chapter all examples are very basic, older versions of Docker will
    most probably work. Still, if you run into issues with following our examples,
    updating Docker to our version should be your first step in troubleshooting.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章你需要一台安装了 Docker 引擎的 Linux 系统。我们这里不会涉及安装步骤。不同的 Linux 发行版提供 Docker 的方式不同。我们将使用
    Docker 引擎版本 20.10.23。由于本章的所有示例都非常基础，较旧版本的 Docker 很可能也能正常工作。不过，如果你在跟随我们的示例时遇到问题，更新
    Docker 到我们这个版本应当是排查问题的第一步。
- en: Virtualization versus containerization
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟化与容器化
- en: In this section, we are going to explain what virtualization and containerization
    are and what the major differences between them are.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本节我们将解释虚拟化和容器化是什么，它们之间的主要区别是什么。
- en: Virtualization
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟化
- en: 'Virtualization is a technique of running a complete simulated computer within
    another computer. Complete means that it mirrors everything a physical computer
    would have: motherboard, BIOS, processor, hard drives, USB ports, and so on. Simulated
    means that it is entirely a product of software. This computer does not exist
    physically, thus it is called virtual. To exist, the **virtual machine** (**VM**),
    as simulated computers are often called, needs a real, physical one to emulate
    it. The physical machine is called a host or hypervisor.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟化是一种在另一台计算机内运行完整模拟计算机的技术。完整意味着它模拟了物理计算机所具有的所有硬件：主板、BIOS、处理器、硬盘、USB 端口等。模拟意味着它完全是软件的产物。这台计算机在物理上并不存在，因此被称为虚拟计算机。为了存在，虚拟机（**VM**）需要一台真实的物理计算机来模拟它。物理计算机被称为宿主机或虚拟化管理程序（Hypervisor）。
- en: 'So, I have a physical computer. It is powerful. Why would I want to run a VM
    in it? For obvious reasons, the VM will be less powerful than the host: after
    all, the host requires RAM, CPU, and hard drive space for itself. There is also
    some small drop in performance (since we are actually running a program that emulates
    full hardware) when compared to the physical machine.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我有一台物理计算机。它非常强大。我为什么要在它上运行虚拟机呢？显而易见，虚拟机的性能会比主机差：毕竟，主机需要为自己分配 RAM、CPU 和硬盘空间。与物理机相比，虚拟机的性能也会有一些小幅下降（因为我们实际上是在运行一个模拟完整硬件的程序）。
- en: The reasons can vary depending on the use case, but there are a lot of them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 理由因使用场景而异，但有很多。
- en: You may want to run a full operating system different from your own to test
    some software, to run software unavailable for your operating system, or to dutifully
    recreate a development environment for your application. You may want to recreate,
    as closely as possible, a production environment for your application. All those
    are valid and pretty popular reasons for using VMs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要运行一个与你自己的操作系统不同的完整操作系统，用来测试一些软件，运行你当前操作系统中没有的软件，或者是为了忠实地重建你的应用程序开发环境。你可能想尽可能精确地重建一个生产环境来测试你的应用程序。这些都是使用虚拟机的有效且非常流行的理由。
- en: 'Let us see what the advantages of virtualization are:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看虚拟化的优势：
- en: '**Isolation**: VMs present themselves, as mentioned, as fully functional computers.
    To the running operating system, they create the illusion of being separate physical
    machines. Whatever we run in them shouldn’t be able to access the host computer
    (unless specifically allowed to) and, indeed, barring a few incidents where such
    things were possible (as a result of a programming error), VMs have provided secure
    environments. This isolation is a very good solution in malware analysis, running
    workloads that require separate servers, and so on. As an example, if a VM runs
    a single WWW server, the security vulnerability in the server may grant the attacker
    access to the operating system, thus allowing them a free run. But since other
    components of infrastructure, for example, databases, are run in separate VMs,
    the incident can be contained to the WWW server only.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离**：正如前面所提到的，虚拟机（VMs）表现为完全功能的计算机。对运行中的操作系统来说，它们创造了与物理机器分离的假象。我们在虚拟机中运行的任何程序都不应能访问主机计算机（除非明确允许），实际上，除了几个由于编程错误导致的事故，虚拟机一直提供安全的环境。这种隔离在恶意软件分析、运行需要独立服务器的工作负载等场景中是一个非常好的解决方案。举例来说，如果一个虚拟机运行一个单独的WWW服务器，那么服务器的安全漏洞可能会使攻击者获取操作系统的访问权限，从而让他们可以自由操作。但由于其他基础设施组件（例如数据库）是运行在独立的虚拟机中的，这个问题只能局限于WWW服务器。'
- en: '**Tuning**: With a sufficiently powerful host, it is possible to partition
    its resources so that each running VM has guaranteed RAM, hard disk space, and
    CPU.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调优**：借助足够强大的主机，可以对其资源进行分区，以确保每个运行中的虚拟机都有保证的内存、硬盘空间和CPU。'
- en: '**Operating system simplification**: When running various workloads, such as
    databases, WWW servers, and mail servers, the complexity of maintaining a single
    server running them all grows pretty fast. Every installed software requires additional
    software to be installed (such as libraries and helper programs). Libraries required
    by various programs may introduce incompatibilities (especially if we install
    software not distributed by operating system developers, so-called third-party
    programs). On rare occasions, even the software included in the distribution may
    be incompatible with each other to a degree that makes it impossible or very difficult
    to install them on one operating system. Maintenance of such a system can become
    troublesome and require a lot of detective work. Modern hypervisor software alleviates
    many system administration hurdles by means of clones, snapshots, golden images,
    and so on.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作系统简化**：当运行各种工作负载时，比如数据库、WWW服务器和邮件服务器，维持单一服务器同时运行这些服务的复杂性会迅速增加。每安装一个软件就需要安装额外的软件（例如库文件和辅助程序）。不同程序所需的库可能会引发不兼容的问题（尤其是当我们安装的不是操作系统开发者发布的软件，即所谓的第三方程序时）。在少数情况下，甚至操作系统自带的软件之间也可能存在不兼容的问题，使得在一个操作系统上安装它们变得不可能或非常困难。维护这样的系统可能会变得麻烦，并需要大量的排查工作。现代的虚拟机管理软件通过克隆、快照、黄金镜像等方式缓解了许多系统管理的难题。'
- en: '**Automation**: Modern virtualization software provides a lot of features that
    promote the automation of system management on many levels. Snapshots – a point-in-time
    capture of the whole system – allow a rollback at any given moment to a previous
    system state. This allows it to easily back out of unwanted changes to the last
    known good state. Clones let us provision new VMs based on another, already running
    and configured. Golden images are archived images of VMs that we can easily and
    quickly import and start – completely omitting installation and limiting configuration
    to the absolute minimum. This also allows for reliable environment recreation.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化**：现代虚拟化软件提供了许多功能，促进了多层次的系统管理自动化。快照——即系统的某一时刻快照——允许在任何时刻回滚到之前的系统状态。这使得轻松回退到最后一个已知的良好状态成为可能，避免了不想要的变化。克隆可以让我们基于另一个已经运行并配置好的虚拟机来配置新的虚拟机。黄金镜像是虚拟机的存档镜像，我们可以轻松快速地导入并启动，完全省略了安装过程，并将配置限制到绝对最小化。这也使得环境的可靠重建成为可能。'
- en: '**Speed up**: Properly setting up a workflow utilizing VMs allows us to start
    a new operating system complete with its own server or desktop hardware in a matter
    of minutes instead of hours. This opens new possibilities for testing environments,
    remote desktop solutions, and so on.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加速**：正确设置虚拟机工作流可以让我们在几分钟内启动一个新的操作系统，配备自己的服务器或桌面硬件，而不是几小时。这为测试环境、远程桌面解决方案等开辟了新的可能性。'
- en: The preceding list is not exhaustive but should easily demonstrate why virtualization
    became a darling of data centers and hosting companies. The availability of a
    wide variety of servers we can cheaply rent is a direct result of virtualization
    allowing companies to partition the hardware.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 上述列表并非详尽无遗，但应该能清楚地展示为什么虚拟化成为数据中心和托管公司宠爱的技术。我们可以廉价租用的各种服务器，正是虚拟化使公司能够对硬件进行分区的直接结果。
- en: As great as the solution is, it is not a panacea and not everything should be
    virtualized. More so, running a separate VM for every piece of software easily
    leads to resource utilization overhead. 100 virtual servers not only will use
    the CPU and RAM provided to the operating system in it but also, some percent
    will be used for housekeeping on the host machine. Each of those servers will
    utilize the disk space required by the operating system within, even though it
    probably will be an exact copy of the 99 other servers on the same server – a
    waste of space, RAM, and CPU. Also, bringing up a new VM will take some time.
    Granted, if you have everything configured and automated properly, it is going
    to be shorter than setting up a new hardware machine, but still.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这一解决方案非常出色，但它并不是万灵药，并不是所有东西都应该虚拟化。而且，为每个软件单独运行一个虚拟机，很容易导致资源利用率的开销。100个虚拟服务器不仅会使用分配给操作系统的CPU和RAM，还会有一部分被用来做主机机器的管理工作。每个虚拟服务器都会占用操作系统所需的磁盘空间，即使它可能与同一服务器上其他99个虚拟机是完全一样的——这是一种空间、RAM和CPU的浪费。而且，启动一个新的虚拟机也需要一些时间。诚然，如果一切配置和自动化得当，启动时间会比设置一台新硬件机器要短，但仍然需要时间。
- en: Before virtualization became widely available, operating system developers were
    trying to provide techniques that would allow system operators to isolate various
    workloads. The main targets were data centers, where one physical server was too
    much for one workload (a database or a WWW server), but running more than one
    posed a risk (security, stability, etc.). After the virtualization became widespread,
    it became obvious that using it was sometimes like using cannons against sparrows.
    It doesn’t make sense to procure a whole new server (even virtual) with the whole
    operating system when you want to run a small program. Thus, through a natural
    progression of innovating new features that allow for better process isolation,
    containers arose.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟化广泛普及之前，操作系统开发人员试图提供一些技术，使系统管理员能够隔离各种工作负载。主要目标是数据中心，在那里一个物理服务器对于一个工作负载（如数据库或WWW服务器）来说已经太多，但运行多个工作负载又存在风险（如安全性、稳定性等）。随着虚拟化的普及，人们很快意识到有时使用虚拟化就像用大炮打麻雀。当你只想运行一个小程序时，采购一个全新的服务器（即便是虚拟的）和整个操作系统是没有意义的。因此，通过不断创新出更好的进程隔离特性，容器应运而生。
- en: Containerization
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器化
- en: Containers are lightweight virtual environments that allow us to run a single
    process in an isolated manner. An ideally prepared container consists of only
    software and libraries required to run the application. The host operating system
    takes care of operating hardware, managing memory, and all other peripheral tasks.
    The main assumption of the container is that it doesn’t emulate being a separate
    operating system or a separate server. Processes or users within the container
    can easily find out they are enclosed there. The downside is that containers won’t
    emulate hardware. You cannot use them to test new drivers, for instance. The upside
    is that a single container can take as little as just a few megabytes of hard
    drive space and only the memory required for the process to run.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是轻量级的虚拟环境，允许我们以隔离的方式运行单个进程。一个理想配置的容器只包含运行应用程序所需的软件和库。主机操作系统负责操作硬件、管理内存和其他外围任务。容器的主要假设是它并不模拟一个独立的操作系统或独立的服务器。容器中的进程或用户可以轻松发现自己被隔离在其中。缺点是容器不会模拟硬件。例如，你不能用它们来测试新驱动程序。优点是单个容器的硬盘空间占用可能仅为几个兆字节，只需要运行进程所需的内存。
- en: As a consequence, starting up a container takes only the time that the application
    needs to start. The bootup time – the BIOS, hardware tests, and operating system
    boot time – is all shaved off. All the software not required by the application
    can, and should, be omitted. Given the small size of container images, their redistribution
    times became almost negligible, their start times almost instantaneous, and the
    build time and process largely simplified. This has led to much easier recreation
    of the environment. This, in turn, has led to easier test environment setup and
    very often deployments of new versions of the software – as often as several thousand
    times a day. The scaling of applications has become much easier and faster.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，启动一个容器只需要应用程序启动所需的时间。启动时间——BIOS、硬件测试和操作系统启动时间——都被缩短了。所有应用程序不需要的软件可以并且应该被省略。由于容器镜像的体积较小，它们的重新分发时间几乎可以忽略不计，启动时间几乎是瞬时的，构建时间和过程也大大简化。这使得环境的重建变得更加容易。反过来，这使得测试环境的设置变得更简单，而且通常会频繁地部署软件的新版本——有时一天可以进行几千次部署。应用程序的扩展变得更加容易和快速。
- en: The preceding brought another change in the approach to running applications.
    The logical consequence of the preceding change is that containers are not maintained
    the same way the operating system is. You do not upgrade software within the container
    – you deploy a container with a new version of software in place of the obsolete
    one. This leads to an assumption that you don’t keep data within a container but
    in a filesystem that you attach to the container during the run.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上述变化引入了另一种运行应用程序的方法。上述变化的逻辑结果是，容器的维护方式与操作系统不同。你不会在容器内升级软件——你会部署一个包含新版本软件的容器，替换掉过时的版本。这就导致了一个假设：你不应该在容器内保存数据，而是将数据保存在运行时挂载到容器的文件系统中。
- en: The poster child of Linux containerization is **Docker**. One thing that Docker
    did that has probably helped to bring the revolution is creating an ecosystem
    for easy sharing of container images.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 容器化的代表性技术是**Docker**。Docker 所做的一件事可能帮助推动了这场革命，那就是创建了一个容器镜像共享的生态系统。
- en: A container image is, in the case of Docker, a simple archive consisting of
    all the binaries and libraries that are required for the application and a few
    files with configuration information. Since the size tends to be rather small
    and the image never has any data within, it is logical to allow people to share
    the image they have built. Docker has an image hub (called Docker Hub) with a
    nice WWW UI, and command-line tools for searching, downloading, and uploading
    images. The hub allows rating images and giving comments and feedback to the authors.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker 中，容器镜像是一个简单的存档，包含了应用程序所需的所有二进制文件和库以及一些配置文件。由于镜像体积通常较小，且镜像内部从不包含数据，因此允许人们共享他们构建的镜像是合乎逻辑的。Docker
    有一个镜像中心（称为 Docker Hub），提供了一个漂亮的 WWW 界面，以及用于搜索、下载和上传镜像的命令行工具。这个中心允许对镜像进行评分，并给作者提供评论和反馈。
- en: Now that we know what containerization is, we can look deeper into how Docker
    works internally and what makes it tick. Let’s look into the anatomy of Docker.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道容器化是什么，我们可以更深入地了解 Docker 如何在内部工作以及它的运作原理。让我们来看看 Docker 的构成。
- en: Anatomy of Docker
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 的构成
- en: 'Docker comprises several components:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 包含多个组件：
- en: Command-line utility – Docker
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行工具 – Docker
- en: Host
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机
- en: Objects
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象
- en: Registries
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册表
- en: The Docker CLI tool – `docker` – is the main means of managing containers and
    images. It is used to build images, pull them from the registry, upload them to
    the registry, run containers, interact with them, set runtime options, and, finally,
    destroy them. It is a command-line tool that communicates with Docker hosts using
    an API. By default, it is assumed that the `docker` command is being invoked on
    the host, but it is not strictly necessary. One `docker` CLI tool can manage more
    than one host.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Docker CLI 工具——`docker`——是管理容器和镜像的主要工具。它用于构建镜像、从注册表中拉取镜像、上传镜像到注册表、运行容器、与容器互动、设置运行时选项，并最终销毁容器。它是一个命令行工具，通过
    API 与 Docker 主机进行通信。默认情况下，假设在主机上调用 `docker` 命令，但这并非严格要求。一个 `docker` CLI 工具可以管理多个主机。
- en: The host is more interesting. The host runs `dockerd` – a daemon responsible
    for actually performing the actions ordered via the `docker` tool. It is here
    that container images are stored. The host also provides resources such as networking,
    storage, and the containers themselves.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 主机更有趣。主机运行`dockerd`——一个负责实际执行通过`docker`工具下达的操作的守护进程。正是在这里存储容器镜像。主机还提供诸如网络、存储以及容器本身等资源。
- en: The `dockerd` daemon is the beating heart of the containers. It’s the background
    process that runs on a host machine and manages the containers. `dockerd` manages
    creating and managing containers, providing an API for interacting with the daemon,
    managing volumes, networks, and image distribution, providing an interface to
    manage images and containers, and storing and managing metadata for containers
    and images. It also manages communication between other processes in Docker Swarm
    mode.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`dockerd`守护进程是容器的心脏。它是一个在主机上运行的后台进程，负责管理容器。`dockerd`管理容器的创建与管理，提供与守护进程交互的API，管理卷、网络和镜像分发，提供管理镜像和容器的接口，并存储和管理容器与镜像的元数据。它还负责在Docker
    Swarm模式下管理其他进程之间的通信。'
- en: OverlayFS
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OverlayFS
- en: '**OverlayFS** was first released as a part of the Linux kernel version 3.18
    in August 2014\. It was initially developed as a means to provide a more efficient
    and flexible way to handle container storage in comparison to the previous storage
    driver, **Another UnionFS** (**AUFS**). OverlayFS was considered the next generation
    of UnionFS, which was the storage driver used by Docker at that time.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**OverlayFS**首次作为Linux内核版本3.18的一部分于2014年8月发布。最初它是为了提供一种比之前的存储驱动程序**Another
    UnionFS**（**AUFS**）更高效和灵活的方式来处理容器存储。OverlayFS被认为是UnionFS的下一代，而UnionFS是当时Docker使用的存储驱动程序。'
- en: This filesystem was included as a built-in storage driver in Docker starting
    from version 1.9.0\. Since then, OverlayFS has become the default storage driver
    for Docker on most Linux distributions, and it is widely used in various container
    orchestration platforms such as Kubernetes and OpenShift.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从Docker版本1.9.0开始，这个文件系统被作为内置存储驱动程序包含在Docker中。从那时起，OverlayFS成为大多数Linux发行版中Docker的默认存储驱动程序，并且在各种容器编排平台（如Kubernetes和OpenShift）中得到广泛使用。
- en: 'OverlayFS is a filesystem for Linux that allows for the overlay of one directory
    on top of another. It allows for the creation of a *virtual* filesystem that is
    composed of two different directories: a lower directory and an upper directory.
    The upper directory contains the files that are visible to the user, while the
    lower directory contains the *base* files that are hidden.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: OverlayFS是Linux的一个文件系统，允许一个目录覆盖另一个目录。它允许创建一个由两个不同目录组成的*虚拟*文件系统：一个下层目录和一个上层目录。上层目录包含用户可见的文件，而下层目录包含隐藏的*基础*文件。
- en: When a file or directory is accessed in the upper directory, OverlayFS first
    looks for it in the upper directory, and if it doesn’t find it, it looks in the
    lower directory. If the file or directory is found in the upper directory, that
    version is used. If it is found in the lower directory, that version is used.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问上层目录中的文件或目录时，OverlayFS首先在上层目录中查找，如果没有找到，再查找下层目录。如果在上层目录中找到该文件或目录，则使用该版本；如果在下层目录中找到，则使用该版本。
- en: This mechanism allows for the creation of *overlay* filesystems, where the upper
    directory can be used to add, modify, or delete files and directories in the lower
    directory, without modifying the lower directory itself. This is useful in scenarios
    such as containerization, where the upper layer can be used to store the changes
    made in a container, while the lower layer contains the base image for the container.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 该机制允许创建*覆盖*文件系统，在这种文件系统中，上层目录可以用于添加、修改或删除下层目录中的文件和目录，而无需修改下层目录本身。这在容器化场景中非常有用，其中上层可以用于存储在容器中所做的更改，而下层则包含容器的基础镜像。
- en: What is an image?
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是镜像？
- en: A **Docker image** is a pre-built package that contains all of the files and
    settings needed to run a piece of software in a container. It includes your application
    code or a binary, runtime, system tools, libraries, and all needed configuration
    files. Once an image is built, it can be used to start one or more containers,
    which are isolated environments that provide a consistent way to run the software.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker镜像**是一个预构建的包，包含了在容器中运行软件所需的所有文件和设置。它包括你的应用程序代码或二进制文件、运行时、系统工具、库和所有需要的配置文件。一旦镜像构建完成，它可以用于启动一个或多个容器，这些容器是提供一致方式运行软件的隔离环境。'
- en: When starting a container, you must select a program to run as a primary process
    of the container. If this process quits, the whole container will be terminated
    as well.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 启动容器时，你必须选择一个程序作为容器的主进程来运行。如果这个进程退出，整个容器也会被终止。
- en: Building a Docker image typically involves creating a Dockerfile, which is a
    script that contains instructions for building the image. The Dockerfile specifies
    the base image to use, any additional software to be installed, any files to be
    added to the image, and any configuration settings to be applied.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个Docker镜像通常涉及创建一个Dockerfile，这是一个包含构建镜像指令的脚本。Dockerfile指定了使用的基础镜像、需要安装的任何附加软件、需要添加到镜像中的文件以及需要应用的任何配置设置。
- en: When building an image, Docker reads the instructions in the Dockerfile and
    performs the steps we’ve prepared inside the Dockerfile.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建镜像时，Docker会读取Dockerfile中的指令并执行我们在Dockerfile中准备的步骤。
- en: Once the image is built, it can be saved and used to start one or more containers.
    The process of building an image can also be automated using a tool such as Jenkins,
    GitHub, or GitLab actions, which can automatically build and test new images whenever
    changes are made to the code base.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦镜像构建完成，它可以被保存并用于启动一个或多个容器。构建镜像的过程也可以通过使用Jenkins、GitHub或GitLab等工具来自动化，这些工具可以在每次对代码库进行更改时自动构建和测试新的镜像。
- en: The resulting image consists of a unique ID (SHA-256 hash), which is a hash
    of the image’s content and metadata, and it also can have a tag, which is a human-readable
    string that can be used to refer to a specific version of the image. UnionFS takes
    care of merging all content when running a container.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 结果镜像由一个唯一的ID（SHA-256哈希）组成，这是镜像内容和元数据的哈希值，它还可以有一个标签，这是一个可读的字符串，可以用来引用镜像的特定版本。UnionFS负责在运行容器时合并所有内容。
- en: 'To inspect the metadata and content parts of an image, you can run the following
    commands:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查镜像的元数据和内容部分，可以运行以下命令：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There’s a lot of information here, so we’ve stripped the output and left the
    information we want to focus on. You can see an image ID, all merged directories
    under the `GraphDriver` section, and the `RootFS sha256` layer. `RootFS` contains
    the whole filesystem created by UnionFS when we start a process within the container.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多信息，所以我们已经去除了不必要的输出，只保留了我们要关注的信息。你可以看到一个镜像ID，`GraphDriver`部分下合并的所有目录，以及`RootFS
    sha256`层。`RootFS`包含了当我们在容器内启动一个进程时，由UnionFS创建的整个文件系统。
- en: What is a container runtime?
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是容器运行时？
- en: A **container runtime** (or **container engine**) is a software component that
    runs containers on your system. Container runtimes load container images from
    a Docker registry, monitoring system resources, allocating system resources for
    a container, and managing its life cycle.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器运行时**（或**容器引擎**）是一个在你的系统上运行容器的软件组件。容器运行时从Docker注册表加载容器镜像，监控系统资源，为容器分配系统资源，并管理其生命周期。'
- en: There are a number of runtime containers that are being used. The most known
    and used on laptops – you probably have it installed on your system already –
    is `containerd`. It’s a high-performance container runtime that is designed to
    be embedded in a larger system. It is used by many cloud providers and is also
    the default runtime for Kubernetes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多正在使用的运行时容器。最著名并且在笔记本电脑上使用得最多的容器运行时是`containerd`——你可能已经在你的系统上安装了它。它是一个高性能的容器运行时，旨在嵌入到更大的系统中。许多云服务提供商使用它，它也是Kubernetes的默认运行时。
- en: LXC is a runtime that uses Linux namespaces and cgroups to provide isolation
    for containers. It is considered to be more lightweight and efficient than Docker
    (`containerd`). It’s also harder to use.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: LXC是一个使用Linux命名空间和cgroups提供容器隔离的运行时。它被认为比Docker（`containerd`）更加轻量级和高效，但也更难使用。
- en: Another interesting runtime is **Container Runtime Interface for OCI** (**CRI-O**).
    CRI-O is fully compliant with the **Open Container Initiative** (**OCI**) specification,
    which means that it can run any OCI-compliant container image. Also, it’s designed
    to work natively with Kubernetes Pods, which allows it to provide better integration
    with Kubernetes than other runtimes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '**Rocket** (**rkt**) is an alternative container runtime that is designed to
    be more secure and efficient than Docker. It uses the **App Container** (**appc**)
    image format and has a simpler architecture than Docker. It’s also not used very
    often.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Other container engines worth noting are **run Open Container** (**runC**),
    a low-level container engine that provides the basic functionality for creating
    and managing containers, and Firecracker developed by AWS.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: cgroups
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linux **cgroups** (short for **control groups**) are a Linux kernel feature
    that allows for the management and isolation of system resources for groups of
    processes. Cgroups allow the system administrator to allocate resources such as
    CPU, memory, and network bandwidth to specific groups of processes, and to monitor
    and control their usage.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: This can be used to limit the resources used by a particular application or
    user, or for isolating different types of workloads on a shared system.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Docker by default doesn’t limit either CPU or memory consumption for an application
    inside a container. It’s quite easy to enable without any direct interaction with
    cgroups or kernel settings – the Docker daemon will do it for us.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: You can limit the amount of memory a Docker container can use by using the `--memory`
    or `-m` option with the `docker` `run` command.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, use the following to run the `alpine` image with a memory limit
    of 500 MB:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can specify the memory limit in bytes, kilobytes, megabytes, or gigabytes
    by using the appropriate suffix (`b`, `k`, `m`, or `g`).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: When you limit the memory for a container, Docker will also limit the amount
    of memory swap that a container can use. By default, the memory swap limit is
    twice the value of the memory limit. It’s also possible to limit the memory swap
    by using the `--memory-swap` or `--``memory-swappiness` option.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Limiting usage of the CPU time that an application inside a Docker container
    can use can be done by using the CPU shares limit (`--cpus` or `-c` option). CPU
    shares are a relative measure of CPU time that a container can use. By default,
    a container is allocated a certain number of CPU shares, which it can use to consume
    CPU time proportional to its share. For example, if a container has 0.5 CPU shares,
    it can use up to 50% of the CPU time if no other containers are consuming CPU.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: 'Other options available are the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '`--cpuset-cpus`: This allows you to specify the range of CPU cores that the
    container can use, for example, `0-1` to use the first two cores, or `0,2` to
    use the first and third core.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--cpu-shares`: This allows you to set a CPU time limit for a Docker container.
    It specifies the amount of CPU time, in microseconds, that the container can use
    in a given period of time. The period of time is specified by the `--``cpu-period`
    option.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--cpu-shares`：允许你为 Docker 容器设置 CPU 时间限制。它指定了容器在给定时间内可以使用的 CPU 时间（以微秒为单位）。时间段由
    `--cpu-period` 选项指定。'
- en: '`--cpu-quota` and `--cpu-period`: `--cpu-quota` is the CPU time limit in microseconds
    and `--cpu-period` is the length of the CPU time period in microseconds.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--cpu-quota` 和 `--cpu-period`：`--cpu-quota` 是 CPU 时间限制（以微秒为单位），`--cpu-period`
    是 CPU 时间周期的长度（以微秒为单位）。'
- en: The `--cpu-quota` and `--cpu-period` options allow you to specify a more precise
    CPU time limit for a container compared to the `--cpus` and `--cpuset-cpus` options.
    It is useful if you need to limit the CPU time for a container more precisely
    to prevent performance issues or ensure that your application runs reliably.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`--cpu-quota` 和 `--cpu-period` 选项允许你为容器指定比 `--cpus` 和 `--cpuset-cpus` 选项更精确的
    CPU 时间限制。如果你需要更精确地限制容器的 CPU 时间，以防止性能问题或确保应用程序可靠运行，这些选项非常有用。'
- en: In this section, we went through the container runtime and how it works. Next,
    we will be looking into the command-line interface for the `containerd` daemon
    to interact with all Docker components in an easy and robust way.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们讲解了容器运行时及其工作原理。接下来，我们将探讨 `containerd` 守护进程的命令行界面，以便更轻松、强大地与所有 Docker
    组件交互。
- en: Docker commands
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 命令
- en: The `containerd` daemon using a socket file or network.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`containerd` 守护进程使用套接字文件或网络。'
- en: 'The most common commands you can use are the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用的最常见命令如下：
- en: '`build`: This allows you to build a new Docker image using a Dockerfile'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build`：允许你使用 Dockerfile 构建新的 Docker 镜像'
- en: '`run`: This starts a new container'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run`：启动一个新的容器'
- en: '`start`: This restarts one or more stopped containers'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`：重新启动一个或多个停止的容器'
- en: '`stop`: This will stop one or more running containers'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stop`：停止一个或多个正在运行的容器'
- en: '`login`: This is used to gain access to private registries'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`login`：用于访问私有注册表'
- en: '`pull`: This downloads an image or a repository from a registry'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pull`：从注册表下载镜像或仓库'
- en: '`push`: This uploads an image or a repository to a registry'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push`：将镜像或仓库上传到注册表'
- en: '`build`: This helps create an image from a provided Dockerfile'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build`：帮助从提供的 Dockerfile 创建镜像'
- en: '`images`: This lists all images on your machine'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`images`：列出你机器上的所有镜像'
- en: '`ps`: This lists all running containers'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ps`：列出所有正在运行的容器'
- en: '`exec`: This executes a command in a running container'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exec`：在正在运行的容器中执行命令'
- en: '`logs`: This shows the logs of a container'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logs`：显示容器的日志'
- en: '`rm`: This removes one or more containers'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rm`：删除一个或多个容器'
- en: '`rmi`: This removes one or more images'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rmi`：删除一个或多个镜像'
- en: '`network`: This is used to manage Docker networks'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`network`：用于管理 Docker 网络'
- en: '`volume`: This is used to manage volumes'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volume`：用于管理卷'
- en: docker build
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker build
- en: 'The `docker build` command is used to build a Docker image from a Dockerfile.
    The basic syntax is as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker build` 命令用于从 Dockerfile 构建 Docker 镜像。基本语法如下：'
- en: '[PRE2]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`PATH` is the path to the directory containing the Dockerfile.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`PATH` 是包含 Dockerfile 的目录路径。'
- en: '`URL` is the URL to a Git repository containing the Dockerfile.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`URL` 是指向包含 Dockerfile 的 Git 仓库的 URL。'
- en: '`-` (a dash) is used to build an image from the contents of `stdin`, so you
    could pipe Dockerfile content to it from the output of some previous command that
    would build a Dockerfile, for example, generate it from a template.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`-`（破折号）用于从 `stdin` 的内容构建镜像，因此你可以将 Dockerfile 内容从先前命令的输出管道传输给它，例如，从模板生成它。'
- en: 'To build an image from a Dockerfile located in the current directory, you would
    run the following command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要从当前目录中的 Dockerfile 构建镜像，你需要运行以下命令：
- en: '[PRE3]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can also use a specific tag for the build image, as in the following example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用一个特定标签来构建镜像，如以下示例所示：
- en: '[PRE4]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can also pass `--build-arg` to your build command to pass build-time variables
    to the Dockerfile:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将 `--build-arg` 参数传递给构建命令，以将构建时的变量传递给 Dockerfile：
- en: '[PRE5]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: docker run
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker run
- en: When you’re running a container, you’re essentially taking a Docker image and
    executing a process within that environment. An image is a blueprint or a snapshot
    of a container; it’s a read-only template with instructions for creating a container.
    A container that is running is an instance of that image but with its own state.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: 'The `docker run` command is used to start a container from a Docker image.
    For example, to start a container from the `myimage` image and run `/bin/bash`,
    you would run the following command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can also pass options to the `run` command, as in the following example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This command starts the container in detached mode (the `-d` option; it puts
    a container in the background), maps port `80` in the container to port `8080`
    on the host (`-p 8080:80`), and assigns the name `containername` to the container
    (`--``name containername`).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also pass environment variables to the container:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Docker containers don’t store data after they are killed. To make data persistent
    you would use storage external to the docker container itself. In the simplest
    setup, this would be a directory or a file on filesystem outside the container.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to do it: create a Docker volume:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To use this volume for data persistence you’d mount it when starting the container:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can also bind mount local folder (`-v` option. In this case you don’t run
    the Docker volume create command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can also specify the working directory inside the container using the `-``w`
    option:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Other options that are useful are as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: '`--rm`: This option will remove the container after it is stopped'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-P`, `--publish-all`: This option will publish all exposed ports (`EXPOSE`
    option in `Dockerfile`) to a random local port'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--network`: This option will connect the container to the Docker network specified'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find more available options to use by invoking the `docker run --``help`
    command.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: docker start
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `docker start` command is used to start one or more stopped Docker containers.
    For example, to start a container, you would run the following command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`mycontainer` is the name or ID of the container you want to start. You can
    check all running and stopped containers using the `docker ps` command; we will
    get into it a bit later. You can also start multiple containers at once. To do
    that, you can list their names or IDs separated by spaces.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'To start multiple containers, you would run the following command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To attach to the container’s process so that you can see its output, use the
    `-a` option while starting the container:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: docker stop
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This command is used to stop containers running in the background. The syntax
    for the command is the same as for starting the container. The difference lies
    in the available options you can use.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: To stop multiple containers at once, you can list their names or IDs separated
    by spaces.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To stop multiple containers, you would run the following command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can also use the `-t` option to specify the amount of time (in seconds)
    to wait for the container to stop before sending a `SIGKILL` signal. For example,
    to wait for `10` seconds before stopping a container, run the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can also use `--time` or `-t` to specify the amount of time to wait for
    the container to stop before sending a `SIGKILL` signal.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: By default, the `docker stop` command sends a `SIGTERM` signal to the container,
    which gives the process running in the container a chance to cleanly shut down.
    If the container does not stop after the default 10-second timeout, a `SIGKILL`
    signal will be sent to force it to stop.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: docker ps
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This command is used to list the running or stopped containers. When you run
    the `docker ps` command without any options, it will show you the list of running
    containers along with their container ID, names, image, command, created time,
    and status:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It’s possible to view all containers with the `-``a` option:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can use the `--quiet` or `-q` option to display only the container IDs,
    which might be useful for scripting:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can use the `--filter` or `-f` option to filter the output based on certain
    criteria:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To inspect how much disk space the container is utilizing, you will need to
    use the `-``s` option:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This container doesn’t use additional space on the disk, as it didn’t save any
    data.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: docker login
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `docker login` command is used to log in to a Docker registry. A registry
    is a place where you can store and distribute Docker images. The most commonly
    used registry is Docker Hub, but you can also use other registries, such as AWS
    **Elastic Container Registry** (**ECR**), Project Quay, or Google Container Registry.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `docker login` will connect to the Docker Hub registry. If you
    want to log in to a different registry, you can specify the server URL as an argument:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When you run the `docker login` command, it will prompt you for your username
    and password. If you don’t have an account on the registry, you can create one
    by visiting the registry’s website.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Once you are logged in, you will be able to push and pull images from the registry.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the `--username` or `-u` option to specify your username, and
    `--password` or `-p` to specify the password on the command line, but it is not
    recommended due to security reasons.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the `--password-stdin` or `-P` option to pass your password
    via `stdin`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It can be an output for any command. For example, to log in to AWS ECR, you
    would use the following command:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can also use the `--token` or `-t` option to specify your token:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Once you are logged in, you will be able to push and pull images from the registry.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: docker pull
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To pull a Docker image, you can use the `docker pull` command followed by the
    image name and a tag. By default, `pull` will pull a tag `latest` (latest is the
    name of the tag, or the version of the image).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, use the following to pull the latest version of the `alpine` image
    from Docker Hub:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Use the following to pull a specific version of the `alpine` image, such as
    version 3.12:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can also pull an image from a different registry by specifying the registry
    URL in the image name.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, use the following to pull an image from a private registry:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: docker push
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After you build a new image, you can push that image to the image registry.
    By default, `push` will try to upload it to the Docker Hub registry:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To push a specific version of the image, such as version 1.0, you will need
    to tag the image locally as version 1.0 and then push it to the registry:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can also push an image to a different registry by specifying the registry
    URL in the image name:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You need to be logged in to the registry to which you are pushing the image
    using the `docker login` command before pushing an image.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: docker image
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a command to manage images. The common use cases for `docker image`
    are shown in the following examples.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'To list available images on your machine, you can use the `docker image` `ls`
    command:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: REPOSITORY         TAG            IMAGE ID       CREATED        SIZE
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You can also use the `docker images` command to do the same action:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To pull an image from the Docker registry, use the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When you specify an image name, you can use either the full repository name
    (for example, `docker.io/library/alpine`) or just the image name (for example,
    `alpine`), if the image is in the default repository (Docker Hub). See also the
    `docker pull` command discussed in an earlier section.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also possible to build an image:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: See also the section on the `docker build` command for more details on building
    images.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a tag for an image, you should run the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, you can remove an image:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: See the section on the `docker rmi` command, which is an alias of this command.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Another option to remove images is the `docker image prune –` command. This
    command will remove all unused images (dangling images).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: docker exec
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`docker exec` allows you to run a command in a running Docker container. The
    basic syntax is as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the preceding example, the terms have the following meanings:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '`CONTAINER` is the name or ID of the container to run the command in'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COMMAND` is the command to run in the container'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ARGUMENTS` represents any additional arguments for the command (this is optional)'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, to run the `ls` command in the container named `my_container`,
    you can use the following command:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: docker logs
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`docker logs` is used to fetch logs generated by a Docker container:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Additional options you can pass to the command are as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '`--details, -a`: Show extra details provided to logs'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--follow, -f`: Follow log output'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--since, -t`: Only display logs since a certain date (e.g., 2013-01-02T13:23:37)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--tail, -t`: Number of lines to show from the end of the logs (default `all`)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of its use is as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: docker rm
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`docker rm` is used to remove one or more Docker containers:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'An example of its use is as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: To list all containers, use the `docker ps -``a` command.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: docker rmi
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Images that are pulled or built locally can take up a lot of space on your disk,
    so it’s useful to check and remove unused ones. `docker rmi` is used to remove
    one or more Docker images.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is its usage:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'An example of its use is as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: docker network
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `docker network` command is used to manage Docker networks. Apart from the
    usual actions (create, delete, and list), it’s possible to attach (and disconnect)
    a running Docker container to a different network.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also possible to extend Docker with a specialized network plugin of your
    choice. There are multiple options here, so we will just list some of the network
    plugins with a short description. Plugins can also be used with more advanced
    setups, such as Kubernetes clusters:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '**Contiv-VPP** ([https://contivpp.io/](https://contivpp.io/)) uses the **Vector
    Packet Processing** (**VPP**) technology to provide an efficient, scalable, and
    programmable networking solution for containers, suitable for use in enterprise
    and service provider environments, where high-performance and scalable networking
    are a requirement.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Weave Net** ([https://www.weave.works/docs/net/latest/overview/](https://www.weave.works/docs/net/latest/overview/))
    allows containers to communicate with each other, regardless of which host they
    are running on. Weave Net creates a virtual network that spans multiple hosts,
    making it possible to deploy containers in a highly available, redundant, and
    load-balanced manner.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Calico** ([https://www.tigera.io/tigera-products/calico/](https://www.tigera.io/tigera-products/calico/))
    is one of the most recognizable plugins out there. It uses a pure IP-based approach
    to networking, providing simplicity and scalability. Calico allows administrators
    to define and enforce network policies, such as allowing or denying specific traffic
    flows based on the source, destination, and port. Calico is designed for large-scale
    deployments and supports both virtual and physical networks.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are common operations when using the `docker` `network` command:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a new network:'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Inspecting a network:'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Removing a network:'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Listing networks:'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Connecting a container to a network:'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Disconnecting a container from a network:'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: docker volume
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `docker volume` command is used to manage volumes in Docker. With this single
    command, you’re able to list available volumes, clean unused ones, or create one
    for later use.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker supports multiple volume drivers, including the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '`local`: The default driver; stores data on the local filesystem using UnionFS'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`awslogs`: Makes it possible to store logs generated by your applications in
    Amazon CloudWatch Logs'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cifs`: Allows you to mount an SMB/CIFS (Windows) share as a Docker volume'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GlusterFS`: Mounts the GlusterFS distributed filesystem as a Docker volume'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NFS`: Mounts the **Network File System** (**NFS**) as a Docker volume'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Many more drivers are available. The list of available drivers can be found
    in the official Docker documentation: [https://docs.docker.com/engine/extend/legacy_plugins/](https://docs.docker.com/engine/extend/legacy_plugins/).'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are examples of its use:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '`docker` `volume ls`'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker volume` `create <volume-name>`'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker volume` `inspect <volume-name>`'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker volume` `rm <volume-name>`'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker volume` `create myvolume`'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker run -v` `myvolume:/opt/data alpine`'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this section, we’ve learned how to interact with all Docker components using
    a command-line interface. Up to now, we’ve been using publicly available Docker
    images, but it’s time to learn how to build your own images.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Dockerfile
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Dockerfile is essentially a text file with a predetermined structure that
    contains a set of instructions for building a Docker image. The instructions in
    the Dockerfile specify what base image to start with (for example, Ubuntu 20.04),
    what software to install, and how to configure the image. The purpose of a Dockerfile
    is to automate the process of building a Docker image so that the image can be
    easily reproduced and distributed.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: The structure of a Dockerfile is a list of commands (one per line) that Docker
    (`containerd` to be exact) uses to build an image. Each command creates a new
    layer in the image in UnionFS, and the resulting image is the union of all the
    layers. The fewer layers we manage to create, the smaller the resulting image.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'The most frequently used commands in a Dockerfile are the following:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '`FROM`'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COPY`'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ADD`'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXPOSE`'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMD`'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ENTRYPOINT`'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUN`'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LABEL`'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ENV`'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ARG`'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VOLUME`'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`USER`'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WORKDIR`'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find a complete list of commands on the official Docker documentation
    website: [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/).'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through the preceding list to understand which command does what and
    when it’s best to use it.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: FROM
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Dockerfile starts with a `FROM` command, which specifies the base image to
    start with:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You can also name this build using `as` keyword followed by a custom name:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`docker build` will try to download Docker images from the public Docker Hub
    registry, but it’s also possible to use other registries out there, or a private
    one.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: COPY and ADD
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `COPY` command is used to copy files or directories from the host machine
    to the container file system. Take the following example:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: You can also use the `ADD` command to add files or directories to your Docker
    image. `ADD` has additional functionality beyond `COPY`. It can extract a TAR
    archive file automatically and check for the presence of a URL in the source field,
    and if it finds one, it will download the file from the URL. Finally, the `ADD`
    command has a `--chown` option to set the ownership of the files in the destination.
    In general, it is recommended to use `COPY` in most cases, and only use `ADD`
    when the additional functionality it provides is needed.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: EXPOSE
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `EXPOSE` command in a Dockerfile informs Docker that the container listens
    on the specified network ports at runtime. It does not actually publish the ports.
    It is used to provide information to the user about which ports are intended to
    be published by the container.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if a container runs a web server on port `80`, you would include
    the following line in your Dockerfile:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You can specify whether the port listens on TCP or UDP – after specifying the
    port number, add a slash and a TCP or UDP keyword (for example, `EXPOSE 80/udp`).
    The default is TCP if you specify only a port number.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'The `EXPOSE` command does not publish the ports. To make ports available, you
    will need to publish them with the use of the `-p` or `--publish` option when
    running the `docker` `run` command:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This will map port `8080` on the host machine to port `80` in the container
    so that any incoming traffic on port `8080` will be forwarded to the web server
    running in the container on port `80`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the `EXPOSE` command, you can publish different ports when running
    a container. `EXPOSE` is used to inform the user about which ports are intended
    to be published by the container.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: ENTRYPOINT and CMD
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next on our list is the `ENTRYPOINT` command, which in a Dockerfile specifies
    the command that should always be run when the container starts. It cannot be
    overridden by any command-line options passed to the `docker` `run` command.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: The `ENTRYPOINT` command is used to configure the container as an executable.
    It is similar to the `CMD` command, but it is used to configure the container
    to run as an executable. It is typically used to specify the command that should
    be run when the container starts, such as a command-line tool or a script.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you have a container that runs a web server, you might use
    the `ENTRYPOINT` command to specify the command that starts the web server:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'If you want to run a container with different arguments, you can use the `CMD`
    command to set default arguments that can be overridden when the container is
    started:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '`CMD` is used to specify the command that should be run when a container is
    started from the image. Take the following example:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The rule of thumb here is that if you want your application to take custom arguments,
    you are free to use `ENTRYPOINT` to launch a process and `CMD` to pass arguments
    to it. This way, you can be flexible with what your process will do by passing
    different options via the command line.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: RUN
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `RUN` command in a Dockerfile is used to execute commands inside the container.
    It creates a new layer in the image each time it is executed.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: The `RUN` command is used to install software packages, create directories,
    set environment variables, and perform any other actions that are required to
    set up the environment inside the container.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can use the `RUN` command to install a package:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You can use the `RUN` command to create a directory:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'You can use the `RUN` command to set environment variables:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: It’s worth noting that the order of the `RUN` commands in the Dockerfile is
    important, as each command creates a new layer in the image, and the resulting
    image is the union of all the layers. So, if you’re expecting some packages to
    be installed later in the process, you need to do it before using them.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: LABEL
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `LABEL` command is used to add metadata to the image. It basically adds
    the key-value pairs of data to the image. Those can be used to store information
    such as the image’s version, maintainer, and other relevant information you might
    need in your organization. The following is an example of the command:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'You can also add multiple labels in one line:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The labels added to the image can be viewed using the `docker` `inspect` command:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The use of `LABEL` commands to add metadata to the image can help users understand
    what the image’s purpose is or who they should ask about the details, and help
    to manage the images.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: ENV and ARG
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ENV` command is used to set environment variables in the following format:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The `ARG` command, on the other hand, is used to define build-time variables.
    These variables can be passed to the `docker build` command using the `--build-arg`
    flag and their values can be used in the Dockerfile.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ARG` command is used to define build-time variables similar to the `ENV`
    format:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The `ARG` command creates a variable that is only accessible during the build
    process, whereas the `ENV` command creates an environment variable that is accessible
    to all processes running inside the container.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll get into more detail about the build process of the
    Docker image, where `ARG` and `ENV` are used together to persist `ENV` variables
    across build stages.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: VOLUME
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another command is `VOLUME`. With it, you can configure a container to create
    a mount point for a volume at a specific location. Volumes are a way to store
    data outside of the container’s filesystem, which means the data can persist even
    if the container is deleted or recreated. The following is the command:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Use the following to specify multiple directories:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Or, the following is also valid:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: If there is any data in the directory marked as `volume`, when running a Docker
    using the `docker run` command, a new volume will be created with the content
    of this directory. That way, you can ensure that data created while this Docker
    container is running won’t be lost when the container gets killed or stopped otherwise.
    It’s especially important for databases, as we suggested in the preceding example.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: USER
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `USER` command in a Dockerfile is used to set the default user that the
    container runs as. By default, the container runs as the root user; it is recommended
    to run the container as a custom user without root capabilities.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: 'The `USER` command is used to set the user and optionally the group that the
    container runs as. For example, you can use the `USER` command to run the container
    as the `webserver` user:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'You can also specify the user and group:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'It’s also possible to set the user ID and group ID instead of the name:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `USER` command only sets the default user for the container, but you can
    override it when running the container:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Running your application as a non-root user is a best practice for security
    reasons. It limits the potential damage that can be done if an attacker gains
    access to the container, as the process running with full permissions is also
    running with the same UID (here: `root`) on the host you are running the image.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: WORKDIR
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `WORKDIR` command in a Dockerfile is used to set the current working directory
    for the container. The working directory is the location in the container’s filesystem
    where all the subsequent `RUN`, `CMD`, `ENTRYPOINT`, `COPY`, and `ADD` commands
    will be executed.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `WORKDIR` command to set the working directory to `/usr/local/app`:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: When using `WORKDIR`, you won’t need to set full paths for the files while using
    any other commands and you could parameterize your application location (with
    `ARG` or `ENV`).
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve familiarized ourselves with Dockerfiles and how to build Docker
    images, it’s useful to know how to store this new image in some way. Docker image
    registries are used for that exact purpose. We will look into registries in the
    next section.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
- en: Docker image registries
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **Docker image registry** hosts Docker images. Docker images are organized
    by tags that can be accessed and downloaded by users. These images can be used
    to create and run containers on a host machine. Image repositories can be hosted
    either locally or on a remote server, such as on Docker Hub, which is a public
    repository provided by Docker. You can also create your own private image repositories
    to share and distribute your images within your organization.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
- en: When you pull an image from a Docker image repository, the image is composed
    of multiple layers. Each layer represents an instruction in the Dockerfile that
    was used to build the image. These layers are stacked on top of each other to
    create the final image. Each layer is read-only and has a unique ID.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to UnionFS, the Docker registry shares common layers between multiple
    images and containers, reducing the amount of disk space required. When a container
    modifies a file, it creates a new layer on top of the base image, rather than
    modifying the files in the base image. This allows for easy rollback to previous
    states of the container and makes the images highly portable.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple image repositories you could use depending on a cloud solution
    you’re using (ECR for AWS or Google Container Registry for GCP, for instance)
    or SaaS solutions (Docker Hub is the most popular – [https://hub.docker.com](https://hub.docker.com)).
    There are also a number of open source licensed solutions available:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
- en: '**Harbor**: This is available at [https://goharbor.io/](https://goharbor.io/)'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Portus**: This is available at [http://port.us.org/](http://port.us.org/)'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Registry**: This is available at [https://docs.docker.com/registry/](https://docs.docker.com/registry/)'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project Quay**: This is available at [https://quay.io](https://quay.io) and
    on GitHub at [https://github.com/quay/quay](https://github.com/quay/quay%20)'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we’ve familiarized ourselves with Docker registries to store
    our Docker images in a remote location. In the next section, we will look more
    into Docker networking and its extensions.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
- en: Docker networking
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are four types of Docker networking: none, bridge, host, and overlay.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
- en: '*Bridge* is the default network mode in Docker. Containers in the same bridge
    network can communicate with each other. Shortly, it creates a virtual network,
    in which containers are assigned IP addresses and can cummunicate using them,
    while anything outside of that network cannot reach any of those addresses. In
    the *Host* network, the container uses the host’s network stack. This means that
    the container shares your machine’s IP address and network interfaces.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
- en: '*Overlay* mode allows you to create a virtual network that spans multiple Docker
    hosts. Containers in different hosts can communicate with each other as if they
    are on the same host. It’s useful when running Docker Swarm.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: Using the Docker command line, you are able to create a custom network of any
    of those types.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
- en: None network
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **none network** in Docker is a special type of network mode that disables
    all networking for a container. When a container is run in *none* network mode,
    it does not have access to any network resources and cannot communicate with other
    containers or the host machine.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
- en: To run a container in *none* network mode, you can use the `--network none`
    option when running the `docker` `run` command.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to start a container running the `nginx` image in *none* network
    mode, you would run the following command:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The *none* network is useful for running workloads that aren’t supposed to use
    any network connections, for example, for processing data in a connected volume.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: Bridge mode
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using **bridge mode** on a container being created, a virtual interface
    is also created and attached to the virtual network. Each container is then assigned
    a unique IP address on the virtual network, allowing it to communicate with other
    containers and the host machine.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: The host machine acts as a gateway for the containers, routing traffic between
    the containers and the outside network. When a container wants to communicate
    with another container or the host machine, it sends the packet to the virtual
    network interface. The virtual network interface then routes the packet to the
    correct destination.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: By default, it’s a `172.17.0.0/16` network and it’s connected to a bridge device,
    `docker0`, in your machine. Within this network, all traffic between containers
    and the host machine is allowed.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: All containers are attached to the default bridge network if no network was
    selected using the `--network` option when executing the `docker` `run` command.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: 'You can list all available networks using the following command:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'To get more information about the network, you can use the following command:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Let’s move on to HOST mode.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
- en: Host mode
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In **host networking mode**, the container shares the host’s network stack and
    network interfaces. This means that the container uses your machine’s IP address
    and network settings, and can directly access the same network resources as the
    machine it runs on, including other containers.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: Containers running in host networking mode can also directly listen on a port
    of the host machine (bind to it).
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: One of the main advantages of host networking mode is that it provides better
    performance as the container doesn’t have to go through an additional network
    stack.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: This mode is less secure than the other networking mode as the container has
    direct access to the host’s network resources and can listen to connections on
    the host’s interface.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: Overlay
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An **overlay network** is created by a manager node, which is responsible for
    maintaining the network configuration and managing the membership of worker nodes.
    The manager node creates a virtual network switch and assigns IP addresses to
    each container on the network.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: Each worker node runs Docker Engine and a container network driver, which is
    responsible for connecting the containers on that host to the virtual network
    switch. The container network driver also ensures that packets are properly encapsulated
    and routed to the correct destination.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
- en: When a container on one host wants to communicate with a container on another
    host, it sends the packet to the virtual network switch. The switch then routes
    the packet to the correct host, where the container network driver decapsulates
    the packet and delivers it to the destination container.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
- en: The overlay network uses the **Virtual eXtensible Local Area Network** (**VXLAN**)
    protocol to encapsulate IP packets and make it possible to create a Layer 2 network
    between multiple hosts.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have introduced one of the major building blocks of modern
    DevOps-led infrastructure, that is, containers. We described the most prominent
    container technology – Docker. We have also introduced the basics of running Docker
    containers and building your own. In the next chapter, we are going to build on
    this knowledge and introduce more advanced Docker topics.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
