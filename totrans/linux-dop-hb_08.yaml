- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Docker Basics
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 基础
- en: In this chapter, we introduce one of the building blocks of the DevOps toolkit
    – containers. We are going to explain the differences between virtualization and
    containers, and then present the advantages and disadvantages of both solutions.
    Additionally, we are going to present a way to choose between both solutions for
    a given workload.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们介绍 DevOps 工具包的一个基础构件——容器。我们将解释虚拟化和容器之间的区别，并展示这两种解决方案的优缺点。此外，我们还将展示如何根据工作负载选择适合的解决方案。
- en: 'The main topics covered in this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章覆盖的主要主题如下：
- en: Virtualization versus containerization
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟化与容器化
- en: Anatomy of Docker
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 架构
- en: Docker commands
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 命令
- en: Dockerfile
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dockerfile
- en: Docker image registries
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 镜像注册表
- en: Docker networking
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 网络
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you will need a Linux system with an installed Docker Engine.
    We are not going to cover the installation steps here. Different Linux distributions
    provide Docker in different ways. We are going to use Docker Engine 20.10.23 here.
    Since in this chapter all examples are very basic, older versions of Docker will
    most probably work. Still, if you run into issues with following our examples,
    updating Docker to our version should be your first step in troubleshooting.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章你需要一台安装了 Docker 引擎的 Linux 系统。我们这里不会涉及安装步骤。不同的 Linux 发行版提供 Docker 的方式不同。我们将使用
    Docker 引擎版本 20.10.23。由于本章的所有示例都非常基础，较旧版本的 Docker 很可能也能正常工作。不过，如果你在跟随我们的示例时遇到问题，更新
    Docker 到我们这个版本应当是排查问题的第一步。
- en: Virtualization versus containerization
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟化与容器化
- en: In this section, we are going to explain what virtualization and containerization
    are and what the major differences between them are.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本节我们将解释虚拟化和容器化是什么，它们之间的主要区别是什么。
- en: Virtualization
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟化
- en: 'Virtualization is a technique of running a complete simulated computer within
    another computer. Complete means that it mirrors everything a physical computer
    would have: motherboard, BIOS, processor, hard drives, USB ports, and so on. Simulated
    means that it is entirely a product of software. This computer does not exist
    physically, thus it is called virtual. To exist, the **virtual machine** (**VM**),
    as simulated computers are often called, needs a real, physical one to emulate
    it. The physical machine is called a host or hypervisor.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟化是一种在另一台计算机内运行完整模拟计算机的技术。完整意味着它模拟了物理计算机所具有的所有硬件：主板、BIOS、处理器、硬盘、USB 端口等。模拟意味着它完全是软件的产物。这台计算机在物理上并不存在，因此被称为虚拟计算机。为了存在，虚拟机（**VM**）需要一台真实的物理计算机来模拟它。物理计算机被称为宿主机或虚拟化管理程序（Hypervisor）。
- en: 'So, I have a physical computer. It is powerful. Why would I want to run a VM
    in it? For obvious reasons, the VM will be less powerful than the host: after
    all, the host requires RAM, CPU, and hard drive space for itself. There is also
    some small drop in performance (since we are actually running a program that emulates
    full hardware) when compared to the physical machine.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我有一台物理计算机。它非常强大。我为什么要在它上运行虚拟机呢？显而易见，虚拟机的性能会比主机差：毕竟，主机需要为自己分配 RAM、CPU 和硬盘空间。与物理机相比，虚拟机的性能也会有一些小幅下降（因为我们实际上是在运行一个模拟完整硬件的程序）。
- en: The reasons can vary depending on the use case, but there are a lot of them.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 理由因使用场景而异，但有很多。
- en: You may want to run a full operating system different from your own to test
    some software, to run software unavailable for your operating system, or to dutifully
    recreate a development environment for your application. You may want to recreate,
    as closely as possible, a production environment for your application. All those
    are valid and pretty popular reasons for using VMs.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要运行一个与你自己的操作系统不同的完整操作系统，用来测试一些软件，运行你当前操作系统中没有的软件，或者是为了忠实地重建你的应用程序开发环境。你可能想尽可能精确地重建一个生产环境来测试你的应用程序。这些都是使用虚拟机的有效且非常流行的理由。
- en: 'Let us see what the advantages of virtualization are:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看虚拟化的优势：
- en: '**Isolation**: VMs present themselves, as mentioned, as fully functional computers.
    To the running operating system, they create the illusion of being separate physical
    machines. Whatever we run in them shouldn’t be able to access the host computer
    (unless specifically allowed to) and, indeed, barring a few incidents where such
    things were possible (as a result of a programming error), VMs have provided secure
    environments. This isolation is a very good solution in malware analysis, running
    workloads that require separate servers, and so on. As an example, if a VM runs
    a single WWW server, the security vulnerability in the server may grant the attacker
    access to the operating system, thus allowing them a free run. But since other
    components of infrastructure, for example, databases, are run in separate VMs,
    the incident can be contained to the WWW server only.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离**：正如前面所提到的，虚拟机（VMs）表现为完全功能的计算机。对运行中的操作系统来说，它们创造了与物理机器分离的假象。我们在虚拟机中运行的任何程序都不应能访问主机计算机（除非明确允许），实际上，除了几个由于编程错误导致的事故，虚拟机一直提供安全的环境。这种隔离在恶意软件分析、运行需要独立服务器的工作负载等场景中是一个非常好的解决方案。举例来说，如果一个虚拟机运行一个单独的WWW服务器，那么服务器的安全漏洞可能会使攻击者获取操作系统的访问权限，从而让他们可以自由操作。但由于其他基础设施组件（例如数据库）是运行在独立的虚拟机中的，这个问题只能局限于WWW服务器。'
- en: '**Tuning**: With a sufficiently powerful host, it is possible to partition
    its resources so that each running VM has guaranteed RAM, hard disk space, and
    CPU.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调优**：借助足够强大的主机，可以对其资源进行分区，以确保每个运行中的虚拟机都有保证的内存、硬盘空间和CPU。'
- en: '**Operating system simplification**: When running various workloads, such as
    databases, WWW servers, and mail servers, the complexity of maintaining a single
    server running them all grows pretty fast. Every installed software requires additional
    software to be installed (such as libraries and helper programs). Libraries required
    by various programs may introduce incompatibilities (especially if we install
    software not distributed by operating system developers, so-called third-party
    programs). On rare occasions, even the software included in the distribution may
    be incompatible with each other to a degree that makes it impossible or very difficult
    to install them on one operating system. Maintenance of such a system can become
    troublesome and require a lot of detective work. Modern hypervisor software alleviates
    many system administration hurdles by means of clones, snapshots, golden images,
    and so on.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**操作系统简化**：当运行各种工作负载时，比如数据库、WWW服务器和邮件服务器，维持单一服务器同时运行这些服务的复杂性会迅速增加。每安装一个软件就需要安装额外的软件（例如库文件和辅助程序）。不同程序所需的库可能会引发不兼容的问题（尤其是当我们安装的不是操作系统开发者发布的软件，即所谓的第三方程序时）。在少数情况下，甚至操作系统自带的软件之间也可能存在不兼容的问题，使得在一个操作系统上安装它们变得不可能或非常困难。维护这样的系统可能会变得麻烦，并需要大量的排查工作。现代的虚拟机管理软件通过克隆、快照、黄金镜像等方式缓解了许多系统管理的难题。'
- en: '**Automation**: Modern virtualization software provides a lot of features that
    promote the automation of system management on many levels. Snapshots – a point-in-time
    capture of the whole system – allow a rollback at any given moment to a previous
    system state. This allows it to easily back out of unwanted changes to the last
    known good state. Clones let us provision new VMs based on another, already running
    and configured. Golden images are archived images of VMs that we can easily and
    quickly import and start – completely omitting installation and limiting configuration
    to the absolute minimum. This also allows for reliable environment recreation.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化**：现代虚拟化软件提供了许多功能，促进了多层次的系统管理自动化。快照——即系统的某一时刻快照——允许在任何时刻回滚到之前的系统状态。这使得轻松回退到最后一个已知的良好状态成为可能，避免了不想要的变化。克隆可以让我们基于另一个已经运行并配置好的虚拟机来配置新的虚拟机。黄金镜像是虚拟机的存档镜像，我们可以轻松快速地导入并启动，完全省略了安装过程，并将配置限制到绝对最小化。这也使得环境的可靠重建成为可能。'
- en: '**Speed up**: Properly setting up a workflow utilizing VMs allows us to start
    a new operating system complete with its own server or desktop hardware in a matter
    of minutes instead of hours. This opens new possibilities for testing environments,
    remote desktop solutions, and so on.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加速**：正确设置虚拟机工作流可以让我们在几分钟内启动一个新的操作系统，配备自己的服务器或桌面硬件，而不是几小时。这为测试环境、远程桌面解决方案等开辟了新的可能性。'
- en: The preceding list is not exhaustive but should easily demonstrate why virtualization
    became a darling of data centers and hosting companies. The availability of a
    wide variety of servers we can cheaply rent is a direct result of virtualization
    allowing companies to partition the hardware.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 上述列表并非详尽无遗，但应该能清楚地展示为什么虚拟化成为数据中心和托管公司宠爱的技术。我们可以廉价租用的各种服务器，正是虚拟化使公司能够对硬件进行分区的直接结果。
- en: As great as the solution is, it is not a panacea and not everything should be
    virtualized. More so, running a separate VM for every piece of software easily
    leads to resource utilization overhead. 100 virtual servers not only will use
    the CPU and RAM provided to the operating system in it but also, some percent
    will be used for housekeeping on the host machine. Each of those servers will
    utilize the disk space required by the operating system within, even though it
    probably will be an exact copy of the 99 other servers on the same server – a
    waste of space, RAM, and CPU. Also, bringing up a new VM will take some time.
    Granted, if you have everything configured and automated properly, it is going
    to be shorter than setting up a new hardware machine, but still.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这一解决方案非常出色，但它并不是万灵药，并不是所有东西都应该虚拟化。而且，为每个软件单独运行一个虚拟机，很容易导致资源利用率的开销。100个虚拟服务器不仅会使用分配给操作系统的CPU和RAM，还会有一部分被用来做主机机器的管理工作。每个虚拟服务器都会占用操作系统所需的磁盘空间，即使它可能与同一服务器上其他99个虚拟机是完全一样的——这是一种空间、RAM和CPU的浪费。而且，启动一个新的虚拟机也需要一些时间。诚然，如果一切配置和自动化得当，启动时间会比设置一台新硬件机器要短，但仍然需要时间。
- en: Before virtualization became widely available, operating system developers were
    trying to provide techniques that would allow system operators to isolate various
    workloads. The main targets were data centers, where one physical server was too
    much for one workload (a database or a WWW server), but running more than one
    posed a risk (security, stability, etc.). After the virtualization became widespread,
    it became obvious that using it was sometimes like using cannons against sparrows.
    It doesn’t make sense to procure a whole new server (even virtual) with the whole
    operating system when you want to run a small program. Thus, through a natural
    progression of innovating new features that allow for better process isolation,
    containers arose.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在虚拟化广泛普及之前，操作系统开发人员试图提供一些技术，使系统管理员能够隔离各种工作负载。主要目标是数据中心，在那里一个物理服务器对于一个工作负载（如数据库或WWW服务器）来说已经太多，但运行多个工作负载又存在风险（如安全性、稳定性等）。随着虚拟化的普及，人们很快意识到有时使用虚拟化就像用大炮打麻雀。当你只想运行一个小程序时，采购一个全新的服务器（即便是虚拟的）和整个操作系统是没有意义的。因此，通过不断创新出更好的进程隔离特性，容器应运而生。
- en: Containerization
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器化
- en: Containers are lightweight virtual environments that allow us to run a single
    process in an isolated manner. An ideally prepared container consists of only
    software and libraries required to run the application. The host operating system
    takes care of operating hardware, managing memory, and all other peripheral tasks.
    The main assumption of the container is that it doesn’t emulate being a separate
    operating system or a separate server. Processes or users within the container
    can easily find out they are enclosed there. The downside is that containers won’t
    emulate hardware. You cannot use them to test new drivers, for instance. The upside
    is that a single container can take as little as just a few megabytes of hard
    drive space and only the memory required for the process to run.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是轻量级的虚拟环境，允许我们以隔离的方式运行单个进程。一个理想配置的容器只包含运行应用程序所需的软件和库。主机操作系统负责操作硬件、管理内存和其他外围任务。容器的主要假设是它并不模拟一个独立的操作系统或独立的服务器。容器中的进程或用户可以轻松发现自己被隔离在其中。缺点是容器不会模拟硬件。例如，你不能用它们来测试新驱动程序。优点是单个容器的硬盘空间占用可能仅为几个兆字节，只需要运行进程所需的内存。
- en: As a consequence, starting up a container takes only the time that the application
    needs to start. The bootup time – the BIOS, hardware tests, and operating system
    boot time – is all shaved off. All the software not required by the application
    can, and should, be omitted. Given the small size of container images, their redistribution
    times became almost negligible, their start times almost instantaneous, and the
    build time and process largely simplified. This has led to much easier recreation
    of the environment. This, in turn, has led to easier test environment setup and
    very often deployments of new versions of the software – as often as several thousand
    times a day. The scaling of applications has become much easier and faster.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，启动一个容器只需要应用程序启动所需的时间。启动时间——BIOS、硬件测试和操作系统启动时间——都被缩短了。所有应用程序不需要的软件可以并且应该被省略。由于容器镜像的体积较小，它们的重新分发时间几乎可以忽略不计，启动时间几乎是瞬时的，构建时间和过程也大大简化。这使得环境的重建变得更加容易。反过来，这使得测试环境的设置变得更简单，而且通常会频繁地部署软件的新版本——有时一天可以进行几千次部署。应用程序的扩展变得更加容易和快速。
- en: The preceding brought another change in the approach to running applications.
    The logical consequence of the preceding change is that containers are not maintained
    the same way the operating system is. You do not upgrade software within the container
    – you deploy a container with a new version of software in place of the obsolete
    one. This leads to an assumption that you don’t keep data within a container but
    in a filesystem that you attach to the container during the run.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 上述变化引入了另一种运行应用程序的方法。上述变化的逻辑结果是，容器的维护方式与操作系统不同。你不会在容器内升级软件——你会部署一个包含新版本软件的容器，替换掉过时的版本。这就导致了一个假设：你不应该在容器内保存数据，而是将数据保存在运行时挂载到容器的文件系统中。
- en: The poster child of Linux containerization is **Docker**. One thing that Docker
    did that has probably helped to bring the revolution is creating an ecosystem
    for easy sharing of container images.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 容器化的代表性技术是**Docker**。Docker 所做的一件事可能帮助推动了这场革命，那就是创建了一个容器镜像共享的生态系统。
- en: A container image is, in the case of Docker, a simple archive consisting of
    all the binaries and libraries that are required for the application and a few
    files with configuration information. Since the size tends to be rather small
    and the image never has any data within, it is logical to allow people to share
    the image they have built. Docker has an image hub (called Docker Hub) with a
    nice WWW UI, and command-line tools for searching, downloading, and uploading
    images. The hub allows rating images and giving comments and feedback to the authors.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker 中，容器镜像是一个简单的存档，包含了应用程序所需的所有二进制文件和库以及一些配置文件。由于镜像体积通常较小，且镜像内部从不包含数据，因此允许人们共享他们构建的镜像是合乎逻辑的。Docker
    有一个镜像中心（称为 Docker Hub），提供了一个漂亮的 WWW 界面，以及用于搜索、下载和上传镜像的命令行工具。这个中心允许对镜像进行评分，并给作者提供评论和反馈。
- en: Now that we know what containerization is, we can look deeper into how Docker
    works internally and what makes it tick. Let’s look into the anatomy of Docker.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道容器化是什么，我们可以更深入地了解 Docker 如何在内部工作以及它的运作原理。让我们来看看 Docker 的构成。
- en: Anatomy of Docker
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 的构成
- en: 'Docker comprises several components:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 包含多个组件：
- en: Command-line utility – Docker
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令行工具 – Docker
- en: Host
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主机
- en: Objects
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象
- en: Registries
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册表
- en: The Docker CLI tool – `docker` – is the main means of managing containers and
    images. It is used to build images, pull them from the registry, upload them to
    the registry, run containers, interact with them, set runtime options, and, finally,
    destroy them. It is a command-line tool that communicates with Docker hosts using
    an API. By default, it is assumed that the `docker` command is being invoked on
    the host, but it is not strictly necessary. One `docker` CLI tool can manage more
    than one host.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Docker CLI 工具——`docker`——是管理容器和镜像的主要工具。它用于构建镜像、从注册表中拉取镜像、上传镜像到注册表、运行容器、与容器互动、设置运行时选项，并最终销毁容器。它是一个命令行工具，通过
    API 与 Docker 主机进行通信。默认情况下，假设在主机上调用 `docker` 命令，但这并非严格要求。一个 `docker` CLI 工具可以管理多个主机。
- en: The host is more interesting. The host runs `dockerd` – a daemon responsible
    for actually performing the actions ordered via the `docker` tool. It is here
    that container images are stored. The host also provides resources such as networking,
    storage, and the containers themselves.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 主机更有趣。主机运行`dockerd`——一个负责实际执行通过`docker`工具下达的操作的守护进程。正是在这里存储容器镜像。主机还提供诸如网络、存储以及容器本身等资源。
- en: The `dockerd` daemon is the beating heart of the containers. It’s the background
    process that runs on a host machine and manages the containers. `dockerd` manages
    creating and managing containers, providing an API for interacting with the daemon,
    managing volumes, networks, and image distribution, providing an interface to
    manage images and containers, and storing and managing metadata for containers
    and images. It also manages communication between other processes in Docker Swarm
    mode.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`dockerd`守护进程是容器的心脏。它是一个在主机上运行的后台进程，负责管理容器。`dockerd`管理容器的创建与管理，提供与守护进程交互的API，管理卷、网络和镜像分发，提供管理镜像和容器的接口，并存储和管理容器与镜像的元数据。它还负责在Docker
    Swarm模式下管理其他进程之间的通信。'
- en: OverlayFS
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OverlayFS
- en: '**OverlayFS** was first released as a part of the Linux kernel version 3.18
    in August 2014\. It was initially developed as a means to provide a more efficient
    and flexible way to handle container storage in comparison to the previous storage
    driver, **Another UnionFS** (**AUFS**). OverlayFS was considered the next generation
    of UnionFS, which was the storage driver used by Docker at that time.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**OverlayFS**首次作为Linux内核版本3.18的一部分于2014年8月发布。最初它是为了提供一种比之前的存储驱动程序**Another
    UnionFS**（**AUFS**）更高效和灵活的方式来处理容器存储。OverlayFS被认为是UnionFS的下一代，而UnionFS是当时Docker使用的存储驱动程序。'
- en: This filesystem was included as a built-in storage driver in Docker starting
    from version 1.9.0\. Since then, OverlayFS has become the default storage driver
    for Docker on most Linux distributions, and it is widely used in various container
    orchestration platforms such as Kubernetes and OpenShift.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从Docker版本1.9.0开始，这个文件系统被作为内置存储驱动程序包含在Docker中。从那时起，OverlayFS成为大多数Linux发行版中Docker的默认存储驱动程序，并且在各种容器编排平台（如Kubernetes和OpenShift）中得到广泛使用。
- en: 'OverlayFS is a filesystem for Linux that allows for the overlay of one directory
    on top of another. It allows for the creation of a *virtual* filesystem that is
    composed of two different directories: a lower directory and an upper directory.
    The upper directory contains the files that are visible to the user, while the
    lower directory contains the *base* files that are hidden.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: OverlayFS是Linux的一个文件系统，允许一个目录覆盖另一个目录。它允许创建一个由两个不同目录组成的*虚拟*文件系统：一个下层目录和一个上层目录。上层目录包含用户可见的文件，而下层目录包含隐藏的*基础*文件。
- en: When a file or directory is accessed in the upper directory, OverlayFS first
    looks for it in the upper directory, and if it doesn’t find it, it looks in the
    lower directory. If the file or directory is found in the upper directory, that
    version is used. If it is found in the lower directory, that version is used.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当访问上层目录中的文件或目录时，OverlayFS首先在上层目录中查找，如果没有找到，再查找下层目录。如果在上层目录中找到该文件或目录，则使用该版本；如果在下层目录中找到，则使用该版本。
- en: This mechanism allows for the creation of *overlay* filesystems, where the upper
    directory can be used to add, modify, or delete files and directories in the lower
    directory, without modifying the lower directory itself. This is useful in scenarios
    such as containerization, where the upper layer can be used to store the changes
    made in a container, while the lower layer contains the base image for the container.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 该机制允许创建*覆盖*文件系统，在这种文件系统中，上层目录可以用于添加、修改或删除下层目录中的文件和目录，而无需修改下层目录本身。这在容器化场景中非常有用，其中上层可以用于存储在容器中所做的更改，而下层则包含容器的基础镜像。
- en: What is an image?
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是镜像？
- en: A **Docker image** is a pre-built package that contains all of the files and
    settings needed to run a piece of software in a container. It includes your application
    code or a binary, runtime, system tools, libraries, and all needed configuration
    files. Once an image is built, it can be used to start one or more containers,
    which are isolated environments that provide a consistent way to run the software.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker镜像**是一个预构建的包，包含了在容器中运行软件所需的所有文件和设置。它包括你的应用程序代码或二进制文件、运行时、系统工具、库和所有需要的配置文件。一旦镜像构建完成，它可以用于启动一个或多个容器，这些容器是提供一致方式运行软件的隔离环境。'
- en: When starting a container, you must select a program to run as a primary process
    of the container. If this process quits, the whole container will be terminated
    as well.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 启动容器时，你必须选择一个程序作为容器的主进程来运行。如果这个进程退出，整个容器也会被终止。
- en: Building a Docker image typically involves creating a Dockerfile, which is a
    script that contains instructions for building the image. The Dockerfile specifies
    the base image to use, any additional software to be installed, any files to be
    added to the image, and any configuration settings to be applied.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个Docker镜像通常涉及创建一个Dockerfile，这是一个包含构建镜像指令的脚本。Dockerfile指定了使用的基础镜像、需要安装的任何附加软件、需要添加到镜像中的文件以及需要应用的任何配置设置。
- en: When building an image, Docker reads the instructions in the Dockerfile and
    performs the steps we’ve prepared inside the Dockerfile.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建镜像时，Docker会读取Dockerfile中的指令并执行我们在Dockerfile中准备的步骤。
- en: Once the image is built, it can be saved and used to start one or more containers.
    The process of building an image can also be automated using a tool such as Jenkins,
    GitHub, or GitLab actions, which can automatically build and test new images whenever
    changes are made to the code base.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦镜像构建完成，它可以被保存并用于启动一个或多个容器。构建镜像的过程也可以通过使用Jenkins、GitHub或GitLab等工具来自动化，这些工具可以在每次对代码库进行更改时自动构建和测试新的镜像。
- en: The resulting image consists of a unique ID (SHA-256 hash), which is a hash
    of the image’s content and metadata, and it also can have a tag, which is a human-readable
    string that can be used to refer to a specific version of the image. UnionFS takes
    care of merging all content when running a container.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 结果镜像由一个唯一的ID（SHA-256哈希）组成，这是镜像内容和元数据的哈希值，它还可以有一个标签，这是一个可读的字符串，可以用来引用镜像的特定版本。UnionFS负责在运行容器时合并所有内容。
- en: 'To inspect the metadata and content parts of an image, you can run the following
    commands:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查镜像的元数据和内容部分，可以运行以下命令：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: There’s a lot of information here, so we’ve stripped the output and left the
    information we want to focus on. You can see an image ID, all merged directories
    under the `GraphDriver` section, and the `RootFS sha256` layer. `RootFS` contains
    the whole filesystem created by UnionFS when we start a process within the container.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多信息，所以我们已经去除了不必要的输出，只保留了我们要关注的信息。你可以看到一个镜像ID，`GraphDriver`部分下合并的所有目录，以及`RootFS
    sha256`层。`RootFS`包含了当我们在容器内启动一个进程时，由UnionFS创建的整个文件系统。
- en: What is a container runtime?
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是容器运行时？
- en: A **container runtime** (or **container engine**) is a software component that
    runs containers on your system. Container runtimes load container images from
    a Docker registry, monitoring system resources, allocating system resources for
    a container, and managing its life cycle.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**容器运行时**（或**容器引擎**）是一个在你的系统上运行容器的软件组件。容器运行时从Docker注册表加载容器镜像，监控系统资源，为容器分配系统资源，并管理其生命周期。'
- en: There are a number of runtime containers that are being used. The most known
    and used on laptops – you probably have it installed on your system already –
    is `containerd`. It’s a high-performance container runtime that is designed to
    be embedded in a larger system. It is used by many cloud providers and is also
    the default runtime for Kubernetes.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多正在使用的运行时容器。最著名并且在笔记本电脑上使用得最多的容器运行时是`containerd`——你可能已经在你的系统上安装了它。它是一个高性能的容器运行时，旨在嵌入到更大的系统中。许多云服务提供商使用它，它也是Kubernetes的默认运行时。
- en: LXC is a runtime that uses Linux namespaces and cgroups to provide isolation
    for containers. It is considered to be more lightweight and efficient than Docker
    (`containerd`). It’s also harder to use.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: LXC是一个使用Linux命名空间和cgroups提供容器隔离的运行时。它被认为比Docker（`containerd`）更加轻量级和高效，但也更难使用。
- en: Another interesting runtime is **Container Runtime Interface for OCI** (**CRI-O**).
    CRI-O is fully compliant with the **Open Container Initiative** (**OCI**) specification,
    which means that it can run any OCI-compliant container image. Also, it’s designed
    to work natively with Kubernetes Pods, which allows it to provide better integration
    with Kubernetes than other runtimes.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的运行时是 **Open Container 接口容器运行时**（**CRI-O**）。CRI-O 完全符合 **Open Container
    Initiative** (**OCI**) 规范，这意味着它可以运行任何符合 OCI 规范的容器镜像。此外，它设计为与 Kubernetes Pods 原生兼容，这使得它在与
    Kubernetes 的集成上优于其他运行时。
- en: '**Rocket** (**rkt**) is an alternative container runtime that is designed to
    be more secure and efficient than Docker. It uses the **App Container** (**appc**)
    image format and has a simpler architecture than Docker. It’s also not used very
    often.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**Rocket** (**rkt**) 是一种替代的容器运行时，旨在比 Docker 更加安全和高效。它使用 **App Container** (**appc**)
    镜像格式，并且架构比 Docker 更加简洁。它也不是很常用。'
- en: Other container engines worth noting are **run Open Container** (**runC**),
    a low-level container engine that provides the basic functionality for creating
    and managing containers, and Firecracker developed by AWS.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 其他值得注意的容器引擎包括 **run Open Container** (**runC**)，这是一个低级别的容器引擎，提供了创建和管理容器的基本功能，以及由
    AWS 开发的 Firecracker。
- en: cgroups
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: cgroups
- en: Linux **cgroups** (short for **control groups**) are a Linux kernel feature
    that allows for the management and isolation of system resources for groups of
    processes. Cgroups allow the system administrator to allocate resources such as
    CPU, memory, and network bandwidth to specific groups of processes, and to monitor
    and control their usage.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Linux **cgroups**（即 **控制组**）是 Linux 内核的一项功能，允许管理和隔离一组进程的系统资源。Cgroups 允许系统管理员为特定的进程组分配资源，如
    CPU、内存和网络带宽，并监控和控制它们的使用。
- en: This can be used to limit the resources used by a particular application or
    user, or for isolating different types of workloads on a shared system.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以用于限制特定应用程序或用户使用的资源，或者在共享系统上隔离不同类型的工作负载。
- en: Docker by default doesn’t limit either CPU or memory consumption for an application
    inside a container. It’s quite easy to enable without any direct interaction with
    cgroups or kernel settings – the Docker daemon will do it for us.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker 不会限制容器内应用程序的 CPU 或内存使用。启用此功能非常简单，不需要直接与 cgroups 或内核设置交互——Docker
    守护进程会为我们处理这些。
- en: You can limit the amount of memory a Docker container can use by using the `--memory`
    or `-m` option with the `docker` `run` command.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在 `docker` `run` 命令中使用 `--memory` 或 `-m` 选项来限制 Docker 容器可以使用的内存量。
- en: 'For example, use the following to run the `alpine` image with a memory limit
    of 500 MB:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用以下命令以 500 MB 的内存限制运行 `alpine` 镜像：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can specify the memory limit in bytes, kilobytes, megabytes, or gigabytes
    by using the appropriate suffix (`b`, `k`, `m`, or `g`).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用适当的后缀（`b`、`k`、`m` 或 `g`）来指定内存限制，单位可以是字节、千字节、兆字节或吉字节。
- en: When you limit the memory for a container, Docker will also limit the amount
    of memory swap that a container can use. By default, the memory swap limit is
    twice the value of the memory limit. It’s also possible to limit the memory swap
    by using the `--memory-swap` or `--``memory-swappiness` option.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当你限制容器的内存时，Docker 还会限制容器可以使用的交换内存量。默认情况下，交换内存的限制是内存限制的两倍。也可以通过使用 `--memory-swap`
    或 `--memory-swappiness` 选项来限制交换内存。
- en: Limiting usage of the CPU time that an application inside a Docker container
    can use can be done by using the CPU shares limit (`--cpus` or `-c` option). CPU
    shares are a relative measure of CPU time that a container can use. By default,
    a container is allocated a certain number of CPU shares, which it can use to consume
    CPU time proportional to its share. For example, if a container has 0.5 CPU shares,
    it can use up to 50% of the CPU time if no other containers are consuming CPU.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 CPU 配额限制（`--cpus` 或 `-c` 选项），可以限制 Docker 容器内应用程序可以使用的 CPU 时间。CPU 配额是容器可以使用的
    CPU 时间的相对度量。默认情况下，容器会被分配一定数量的 CPU 配额，容器可以根据其分配的份额来消耗 CPU 时间。例如，如果一个容器有 0.5 个 CPU
    配额，那么如果没有其他容器消耗 CPU，它最多可以使用 50% 的 CPU 时间。
- en: 'Other options available are the following:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可用的选项如下：
- en: '`--cpuset-cpus`: This allows you to specify the range of CPU cores that the
    container can use, for example, `0-1` to use the first two cores, or `0,2` to
    use the first and third core.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--cpuset-cpus`：此选项允许你指定容器可以使用的 CPU 核心范围，例如 `0-1` 表示使用前两个核心，或者 `0,2` 表示使用第一个和第三个核心。'
- en: '`--cpu-shares`: This allows you to set a CPU time limit for a Docker container.
    It specifies the amount of CPU time, in microseconds, that the container can use
    in a given period of time. The period of time is specified by the `--``cpu-period`
    option.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--cpu-shares`：允许你为 Docker 容器设置 CPU 时间限制。它指定了容器在给定时间内可以使用的 CPU 时间（以微秒为单位）。时间段由
    `--cpu-period` 选项指定。'
- en: '`--cpu-quota` and `--cpu-period`: `--cpu-quota` is the CPU time limit in microseconds
    and `--cpu-period` is the length of the CPU time period in microseconds.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--cpu-quota` 和 `--cpu-period`：`--cpu-quota` 是 CPU 时间限制（以微秒为单位），`--cpu-period`
    是 CPU 时间周期的长度（以微秒为单位）。'
- en: The `--cpu-quota` and `--cpu-period` options allow you to specify a more precise
    CPU time limit for a container compared to the `--cpus` and `--cpuset-cpus` options.
    It is useful if you need to limit the CPU time for a container more precisely
    to prevent performance issues or ensure that your application runs reliably.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`--cpu-quota` 和 `--cpu-period` 选项允许你为容器指定比 `--cpus` 和 `--cpuset-cpus` 选项更精确的
    CPU 时间限制。如果你需要更精确地限制容器的 CPU 时间，以防止性能问题或确保应用程序可靠运行，这些选项非常有用。'
- en: In this section, we went through the container runtime and how it works. Next,
    we will be looking into the command-line interface for the `containerd` daemon
    to interact with all Docker components in an easy and robust way.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们讲解了容器运行时及其工作原理。接下来，我们将探讨 `containerd` 守护进程的命令行界面，以便更轻松、强大地与所有 Docker
    组件交互。
- en: Docker commands
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 命令
- en: The `containerd` daemon using a socket file or network.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`containerd` 守护进程使用套接字文件或网络。'
- en: 'The most common commands you can use are the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用的最常见命令如下：
- en: '`build`: This allows you to build a new Docker image using a Dockerfile'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build`：允许你使用 Dockerfile 构建新的 Docker 镜像'
- en: '`run`: This starts a new container'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run`：启动一个新的容器'
- en: '`start`: This restarts one or more stopped containers'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`：重新启动一个或多个停止的容器'
- en: '`stop`: This will stop one or more running containers'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stop`：停止一个或多个正在运行的容器'
- en: '`login`: This is used to gain access to private registries'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`login`：用于访问私有注册表'
- en: '`pull`: This downloads an image or a repository from a registry'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pull`：从注册表下载镜像或仓库'
- en: '`push`: This uploads an image or a repository to a registry'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push`：将镜像或仓库上传到注册表'
- en: '`build`: This helps create an image from a provided Dockerfile'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build`：帮助从提供的 Dockerfile 创建镜像'
- en: '`images`: This lists all images on your machine'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`images`：列出你机器上的所有镜像'
- en: '`ps`: This lists all running containers'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ps`：列出所有正在运行的容器'
- en: '`exec`: This executes a command in a running container'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exec`：在正在运行的容器中执行命令'
- en: '`logs`: This shows the logs of a container'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logs`：显示容器的日志'
- en: '`rm`: This removes one or more containers'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rm`：删除一个或多个容器'
- en: '`rmi`: This removes one or more images'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rmi`：删除一个或多个镜像'
- en: '`network`: This is used to manage Docker networks'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`network`：用于管理 Docker 网络'
- en: '`volume`: This is used to manage volumes'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volume`：用于管理卷'
- en: docker build
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker build
- en: 'The `docker build` command is used to build a Docker image from a Dockerfile.
    The basic syntax is as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker build` 命令用于从 Dockerfile 构建 Docker 镜像。基本语法如下：'
- en: '[PRE2]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`PATH` is the path to the directory containing the Dockerfile.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`PATH` 是包含 Dockerfile 的目录路径。'
- en: '`URL` is the URL to a Git repository containing the Dockerfile.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`URL` 是指向包含 Dockerfile 的 Git 仓库的 URL。'
- en: '`-` (a dash) is used to build an image from the contents of `stdin`, so you
    could pipe Dockerfile content to it from the output of some previous command that
    would build a Dockerfile, for example, generate it from a template.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`-`（破折号）用于从 `stdin` 的内容构建镜像，因此你可以将 Dockerfile 内容从先前命令的输出管道传输给它，例如，从模板生成它。'
- en: 'To build an image from a Dockerfile located in the current directory, you would
    run the following command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要从当前目录中的 Dockerfile 构建镜像，你需要运行以下命令：
- en: '[PRE3]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can also use a specific tag for the build image, as in the following example:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用一个特定标签来构建镜像，如以下示例所示：
- en: '[PRE4]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can also pass `--build-arg` to your build command to pass build-time variables
    to the Dockerfile:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将 `--build-arg` 参数传递给构建命令，以将构建时的变量传递给 Dockerfile：
- en: '[PRE5]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: docker run
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker run
- en: When you’re running a container, you’re essentially taking a Docker image and
    executing a process within that environment. An image is a blueprint or a snapshot
    of a container; it’s a read-only template with instructions for creating a container.
    A container that is running is an instance of that image but with its own state.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行一个容器时，本质上是将一个 Docker 镜像拿来并在该环境中执行一个进程。镜像是一个容器的蓝图或快照；它是一个只读模板，包含创建容器的指令。正在运行的容器是该镜像的一个实例，但有自己的状态。
- en: 'The `docker run` command is used to start a container from a Docker image.
    For example, to start a container from the `myimage` image and run `/bin/bash`,
    you would run the following command:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker run`命令用于从 Docker 镜像启动一个容器。例如，要从`myimage`镜像启动一个容器并运行`/bin/bash`，你可以运行以下命令：'
- en: '[PRE6]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can also pass options to the `run` command, as in the following example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以向`run`命令传递选项，如下例所示：
- en: '[PRE7]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This command starts the container in detached mode (the `-d` option; it puts
    a container in the background), maps port `80` in the container to port `8080`
    on the host (`-p 8080:80`), and assigns the name `containername` to the container
    (`--``name containername`).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令以分离模式启动容器（`-d`选项；它将容器置于后台），将容器中的端口`80`映射到主机的端口`8080`（`-p 8080:80`），并将容器命名为`containername`（`--``name
    containername`）。
- en: 'You can also pass environment variables to the container:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以向容器传递环境变量：
- en: '[PRE8]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Docker containers don’t store data after they are killed. To make data persistent
    you would use storage external to the docker container itself. In the simplest
    setup, this would be a directory or a file on filesystem outside the container.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 容器在被终止后不会存储数据。为了使数据持久化，你需要使用容器本身以外的存储。在最简单的设置中，这可以是容器外部文件系统中的一个目录或文件。
- en: 'There are two ways to do it: create a Docker volume:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以实现：创建一个 Docker 卷：
- en: '[PRE9]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To use this volume for data persistence you’d mount it when starting the container:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此卷进行数据持久化，你需要在启动容器时挂载它：
- en: '[PRE10]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can also bind mount local folder (`-v` option. In this case you don’t run
    the Docker volume create command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以绑定挂载本地文件夹（`-v`选项。在这种情况下，你不需要运行 Docker 卷创建命令：
- en: '[PRE11]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can also specify the working directory inside the container using the `-``w`
    option:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`-``w`选项来指定容器内的工作目录：
- en: '[PRE12]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Other options that are useful are as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 其他有用的选项如下：
- en: '`--rm`: This option will remove the container after it is stopped'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--rm`：此选项将在容器停止后删除该容器'
- en: '`-P`, `--publish-all`: This option will publish all exposed ports (`EXPOSE`
    option in `Dockerfile`) to a random local port'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-P`，`--publish-all`：此选项将所有暴露的端口（`Dockerfile`中的`EXPOSE`选项）发布到一个随机的本地端口'
- en: '`--network`: This option will connect the container to the Docker network specified'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--network`：此选项将容器连接到指定的 Docker 网络'
- en: You can find more available options to use by invoking the `docker run --``help`
    command.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过执行`docker run --``help`命令来查看更多可用选项。
- en: docker start
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker start
- en: 'The `docker start` command is used to start one or more stopped Docker containers.
    For example, to start a container, you would run the following command:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker start`命令用于启动一个或多个已停止的 Docker 容器。例如，要启动一个容器，你可以运行以下命令：'
- en: '[PRE13]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`mycontainer` is the name or ID of the container you want to start. You can
    check all running and stopped containers using the `docker ps` command; we will
    get into it a bit later. You can also start multiple containers at once. To do
    that, you can list their names or IDs separated by spaces.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`mycontainer`是你想要启动的容器的名称或ID。你可以使用`docker ps`命令查看所有正在运行和已停止的容器；稍后我们会详细介绍。你也可以一次启动多个容器。为此，你可以列出它们的名称或ID，用空格隔开。'
- en: 'To start multiple containers, you would run the following command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要启动多个容器，你可以运行以下命令：
- en: '[PRE14]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To attach to the container’s process so that you can see its output, use the
    `-a` option while starting the container:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要附加到容器的进程，以便查看其输出，在启动容器时使用`-a`选项：
- en: '[PRE15]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: docker stop
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker stop
- en: This command is used to stop containers running in the background. The syntax
    for the command is the same as for starting the container. The difference lies
    in the available options you can use.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令用于停止后台运行的容器。该命令的语法与启动容器时相同，区别在于你可以使用的可用选项。
- en: To stop multiple containers at once, you can list their names or IDs separated
    by spaces.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要一次停止多个容器，你可以列出它们的名称或ID，用空格隔开。
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To stop multiple containers, you would run the following command:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止多个容器，你可以运行以下命令：
- en: '[PRE17]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You can also use the `-t` option to specify the amount of time (in seconds)
    to wait for the container to stop before sending a `SIGKILL` signal. For example,
    to wait for `10` seconds before stopping a container, run the following:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`-t`选项来指定等待容器停止的时间（以秒为单位），然后发送`SIGKILL`信号。例如，要在停止容器之前等待`10`秒，请运行以下命令：
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can also use `--time` or `-t` to specify the amount of time to wait for
    the container to stop before sending a `SIGKILL` signal.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用`--time`或`-t`来指定在发送`SIGKILL`信号之前等待容器停止的时间。
- en: By default, the `docker stop` command sends a `SIGTERM` signal to the container,
    which gives the process running in the container a chance to cleanly shut down.
    If the container does not stop after the default 10-second timeout, a `SIGKILL`
    signal will be sent to force it to stop.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`docker stop`命令会向容器发送`SIGTERM`信号，这样容器中的进程就有机会进行正常关闭。如果容器在默认的10秒超时后仍未停止，将会发送`SIGKILL`信号强制停止。
- en: docker ps
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker ps
- en: 'This command is used to list the running or stopped containers. When you run
    the `docker ps` command without any options, it will show you the list of running
    containers along with their container ID, names, image, command, created time,
    and status:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令用于列出正在运行或已停止的容器。当您没有任何选项地运行`docker ps`命令时，它将显示正在运行的容器列表，并附带它们的容器ID、名称、镜像、命令、创建时间和状态：
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It’s possible to view all containers with the `-``a` option:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`-a`选项查看所有容器：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You can use the `--quiet` or `-q` option to display only the container IDs,
    which might be useful for scripting:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`--quiet`或`-q`选项只显示容器ID，这在脚本编写中可能会很有用：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'You can use the `--filter` or `-f` option to filter the output based on certain
    criteria:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`--filter`或`-f`选项根据某些标准过滤输出：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To inspect how much disk space the container is utilizing, you will need to
    use the `-``s` option:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查容器使用的磁盘空间，您需要使用`-s`选项：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This container doesn’t use additional space on the disk, as it didn’t save any
    data.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个容器不会占用额外的磁盘空间，因为它没有保存任何数据。
- en: docker login
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker login
- en: The `docker login` command is used to log in to a Docker registry. A registry
    is a place where you can store and distribute Docker images. The most commonly
    used registry is Docker Hub, but you can also use other registries, such as AWS
    **Elastic Container Registry** (**ECR**), Project Quay, or Google Container Registry.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker login`命令用于登录Docker注册表。注册表是您存储和分发Docker镜像的地方。最常用的注册表是Docker Hub，但您也可以使用其他注册表，如AWS
    **Elastic Container Registry**（**ECR**）、Project Quay或Google Container Registry。'
- en: 'By default, `docker login` will connect to the Docker Hub registry. If you
    want to log in to a different registry, you can specify the server URL as an argument:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`docker login`会连接到Docker Hub注册表。如果您想登录到其他注册表，您可以将服务器URL作为参数指定：
- en: '[PRE24]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When you run the `docker login` command, it will prompt you for your username
    and password. If you don’t have an account on the registry, you can create one
    by visiting the registry’s website.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行`docker login`命令时，它会提示您输入用户名和密码。如果您在注册表中没有帐户，可以通过访问注册表的网站来创建一个帐户。
- en: Once you are logged in, you will be able to push and pull images from the registry.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，您将能够从注册表推送和拉取镜像。
- en: You can also use the `--username` or `-u` option to specify your username, and
    `--password` or `-p` to specify the password on the command line, but it is not
    recommended due to security reasons.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`--username`或`-u`选项来指定您的用户名，使用`--password`或`-p`来指定密码，但由于安全原因，不推荐在命令行中这样做。
- en: 'You can also use the `--password-stdin` or `-P` option to pass your password
    via `stdin`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用`--password-stdin`或`-P`选项通过`stdin`传递密码：
- en: '[PRE25]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It can be an output for any command. For example, to log in to AWS ECR, you
    would use the following command:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以是任何命令的输出。例如，要登录到AWS ECR，您可以使用以下命令：
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'You can also use the `--token` or `-t` option to specify your token:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`--token`或`-t`选项来指定您的令牌：
- en: '[PRE27]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Once you are logged in, you will be able to push and pull images from the registry.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，您将能够从注册表推送和拉取镜像。
- en: docker pull
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker pull
- en: To pull a Docker image, you can use the `docker pull` command followed by the
    image name and a tag. By default, `pull` will pull a tag `latest` (latest is the
    name of the tag, or the version of the image).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要拉取Docker镜像，您可以使用`docker pull`命令，后跟镜像名称和标签。默认情况下，`pull`会拉取标签`latest`（latest是标签的名称，或镜像的版本）。
- en: 'For example, use the following to pull the latest version of the `alpine` image
    from Docker Hub:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用以下命令从Docker Hub拉取`alpine`镜像的最新版本：
- en: '[PRE28]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Use the following to pull a specific version of the `alpine` image, such as
    version 3.12:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令拉取特定版本的`alpine`镜像，例如版本3.12：
- en: '[PRE29]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can also pull an image from a different registry by specifying the registry
    URL in the image name.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过在镜像名称中指定注册表URL来从不同的注册表拉取镜像。
- en: 'For example, use the following to pull an image from a private registry:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，使用以下命令从私有注册表拉取镜像：
- en: '[PRE30]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: docker push
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker push
- en: 'After you build a new image, you can push that image to the image registry.
    By default, `push` will try to upload it to the Docker Hub registry:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建新镜像后，你可以将该镜像推送到镜像注册表。默认情况下，`push`将尝试将其上传到Docker Hub注册表：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To push a specific version of the image, such as version 1.0, you will need
    to tag the image locally as version 1.0 and then push it to the registry:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 要推送特定版本的镜像，例如版本1.0，你需要在本地将镜像标记为版本1.0，然后推送到注册表：
- en: '[PRE32]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'You can also push an image to a different registry by specifying the registry
    URL in the image name:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以通过在镜像名称中指定注册表URL，将镜像推送到不同的注册表：
- en: '[PRE33]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You need to be logged in to the registry to which you are pushing the image
    using the `docker login` command before pushing an image.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在推送镜像之前，你需要使用`docker login`命令登录到你要推送镜像的注册表。
- en: docker image
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker image
- en: This is a command to manage images. The common use cases for `docker image`
    are shown in the following examples.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用于管理镜像的命令。`docker image`的常见用例如下所示：
- en: 'To list available images on your machine, you can use the `docker image` `ls`
    command:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出你机器上可用的镜像，可以使用`docker image` `ls`命令：
- en: '[PRE34]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: REPOSITORY         TAG            IMAGE ID       CREATED        SIZE
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: REPOSITORY          TAG              IMAGE ID       CREATED         SIZE
- en: '[PRE35]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You can also use the `docker images` command to do the same action:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`docker images`命令执行相同的操作：
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To pull an image from the Docker registry, use the following:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 要从Docker注册表拉取镜像，请使用以下命令：
- en: '[PRE37]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: When you specify an image name, you can use either the full repository name
    (for example, `docker.io/library/alpine`) or just the image name (for example,
    `alpine`), if the image is in the default repository (Docker Hub). See also the
    `docker pull` command discussed in an earlier section.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 当你指定镜像名称时，可以使用完整的仓库名称（例如，`docker.io/library/alpine`）或仅使用镜像名称（例如，`alpine`），如果镜像位于默认仓库（Docker
    Hub）中。另请参阅之前部分中讨论的`docker pull`命令。
- en: 'It’s also possible to build an image:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以构建镜像：
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: See also the section on the `docker build` command for more details on building
    images.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 另请参阅有关`docker build`命令的部分，了解更多关于构建镜像的详细信息。
- en: 'To create a tag for an image, you should run the following:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要为镜像创建标签，应运行以下命令：
- en: '[PRE39]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, you can remove an image:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以删除一个镜像：
- en: '[PRE40]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: See the section on the `docker rmi` command, which is an alias of this command.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅有关`docker rmi`命令的部分，它是此命令的别名。
- en: Another option to remove images is the `docker image prune –` command. This
    command will remove all unused images (dangling images).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种删除镜像的选项是`docker image prune –`命令。此命令将删除所有未使用的镜像（悬空镜像）。
- en: docker exec
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker exec
- en: '`docker exec` allows you to run a command in a running Docker container. The
    basic syntax is as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker exec`允许你在运行中的Docker容器中执行命令。基本语法如下：'
- en: '[PRE41]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the preceding example, the terms have the following meanings:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，术语的含义如下：
- en: '`CONTAINER` is the name or ID of the container to run the command in'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CONTAINER`是要在其中运行命令的容器的名称或ID'
- en: '`COMMAND` is the command to run in the container'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COMMAND`是要在容器中运行的命令'
- en: '`ARGUMENTS` represents any additional arguments for the command (this is optional)'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ARGUMENTS`表示命令的任何附加参数（这是可选的）'
- en: 'For example, to run the `ls` command in the container named `my_container`,
    you can use the following command:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要在名为`my_container`的容器中运行`ls`命令，可以使用以下命令：
- en: '[PRE42]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: docker logs
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker logs
- en: '`docker logs` is used to fetch logs generated by a Docker container:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker logs`用于获取Docker容器生成的日志：'
- en: '[PRE43]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Additional options you can pass to the command are as follows:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以传递给命令的其他选项如下：
- en: '`--details, -a`: Show extra details provided to logs'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--details, -a`：显示日志提供的额外详细信息'
- en: '`--follow, -f`: Follow log output'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--follow, -f`：跟踪日志输出'
- en: '`--since, -t`: Only display logs since a certain date (e.g., 2013-01-02T13:23:37)'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--since, -t`：仅显示自某个日期以来的日志（例如，2013-01-02T13:23:37）'
- en: '`--tail, -t`: Number of lines to show from the end of the logs (default `all`)'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--tail, -t`：从日志的末尾显示的行数（默认`all`）'
- en: 'An example of its use is as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 它的使用示例如下：
- en: '[PRE44]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: docker rm
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker rm
- en: '`docker rm` is used to remove one or more Docker containers:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker rm`用于删除一个或多个Docker容器：'
- en: '[PRE45]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'An example of its use is as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 它的使用示例如下：
- en: '[PRE46]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: To list all containers, use the `docker ps -``a` command.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出所有容器，请使用`docker ps -a`命令。
- en: docker rmi
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker rmi
- en: Images that are pulled or built locally can take up a lot of space on your disk,
    so it’s useful to check and remove unused ones. `docker rmi` is used to remove
    one or more Docker images.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 从本地拉取或构建的镜像可能会占用大量磁盘空间，因此检查和删除未使用的镜像是很有用的。`docker rmi`用于删除一个或多个Docker镜像。
- en: 'The following is its usage:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是它的用法：
- en: '[PRE47]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'An example of its use is as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 它的使用示例如下：
- en: '[PRE48]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: docker network
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker network
- en: The `docker network` command is used to manage Docker networks. Apart from the
    usual actions (create, delete, and list), it’s possible to attach (and disconnect)
    a running Docker container to a different network.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker network`命令用于管理Docker网络。除了常见的操作（创建、删除和列出），还可以将运行中的Docker容器连接（和断开连接）到不同的网络。'
- en: 'It’s also possible to extend Docker with a specialized network plugin of your
    choice. There are multiple options here, so we will just list some of the network
    plugins with a short description. Plugins can also be used with more advanced
    setups, such as Kubernetes clusters:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以通过选择专用的网络插件来扩展Docker。这里有多个选择，我们只列出一些网络插件及其简短描述。插件也可以用于更高级的设置，如Kubernetes集群：
- en: '**Contiv-VPP** ([https://contivpp.io/](https://contivpp.io/)) uses the **Vector
    Packet Processing** (**VPP**) technology to provide an efficient, scalable, and
    programmable networking solution for containers, suitable for use in enterprise
    and service provider environments, where high-performance and scalable networking
    are a requirement.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Contiv-VPP** ([https://contivpp.io/](https://contivpp.io/)) 使用**向量数据包处理**（**VPP**）技术，提供一个高效、可扩展和可编程的容器网络解决方案，适用于企业和服务提供商环境，在这些环境中，高性能和可扩展的网络是必需的。'
- en: '**Weave Net** ([https://www.weave.works/docs/net/latest/overview/](https://www.weave.works/docs/net/latest/overview/))
    allows containers to communicate with each other, regardless of which host they
    are running on. Weave Net creates a virtual network that spans multiple hosts,
    making it possible to deploy containers in a highly available, redundant, and
    load-balanced manner.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Weave Net** ([https://www.weave.works/docs/net/latest/overview/](https://www.weave.works/docs/net/latest/overview/))
    允许容器之间进行通信，无论它们在哪个主机上运行。Weave Net创建一个跨多个主机的虚拟网络，使得容器能够以高可用性、冗余和负载均衡的方式进行部署。'
- en: '**Calico** ([https://www.tigera.io/tigera-products/calico/](https://www.tigera.io/tigera-products/calico/))
    is one of the most recognizable plugins out there. It uses a pure IP-based approach
    to networking, providing simplicity and scalability. Calico allows administrators
    to define and enforce network policies, such as allowing or denying specific traffic
    flows based on the source, destination, and port. Calico is designed for large-scale
    deployments and supports both virtual and physical networks.'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Calico** ([https://www.tigera.io/tigera-products/calico/](https://www.tigera.io/tigera-products/calico/))
    是最知名的插件之一。它采用纯IP驱动的网络方式，提供了简洁性和可扩展性。Calico允许管理员定义和执行网络策略，例如根据源、目的地和端口允许或拒绝特定的流量。Calico设计用于大规模部署，并支持虚拟和物理网络。'
- en: 'The following are common operations when using the `docker` `network` command:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`docker network`命令时的常见操作如下：
- en: 'Creating a new network:'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新网络：
- en: '[PRE49]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Inspecting a network:'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查网络：
- en: '[PRE50]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Removing a network:'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除网络：
- en: '[PRE51]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Listing networks:'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出网络：
- en: '[PRE52]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Connecting a container to a network:'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接容器到网络：
- en: '[PRE53]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Disconnecting a container from a network:'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从网络中断开容器：
- en: '[PRE54]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: docker volume
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: docker volume
- en: The `docker volume` command is used to manage volumes in Docker. With this single
    command, you’re able to list available volumes, clean unused ones, or create one
    for later use.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker volume`命令用于管理Docker中的卷。通过这个命令，你可以列出可用的卷，清理未使用的卷，或者创建一个以便稍后使用。'
- en: 'Docker supports multiple volume drivers, including the following:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Docker支持多种卷驱动程序，包括以下几种：
- en: '`local`: The default driver; stores data on the local filesystem using UnionFS'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`local`：默认驱动程序；使用UnionFS将数据存储在本地文件系统上'
- en: '`awslogs`: Makes it possible to store logs generated by your applications in
    Amazon CloudWatch Logs'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`awslogs`：使应用程序生成的日志能够存储在Amazon CloudWatch Logs中'
- en: '`cifs`: Allows you to mount an SMB/CIFS (Windows) share as a Docker volume'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cifs`：允许你将SMB/CIFS（Windows）共享挂载为Docker卷'
- en: '`GlusterFS`: Mounts the GlusterFS distributed filesystem as a Docker volume'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GlusterFS`：将GlusterFS分布式文件系统挂载为Docker卷'
- en: '`NFS`: Mounts the **Network File System** (**NFS**) as a Docker volume'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NFS`：将**网络文件系统**（**NFS**）挂载为Docker卷'
- en: 'Many more drivers are available. The list of available drivers can be found
    in the official Docker documentation: [https://docs.docker.com/engine/extend/legacy_plugins/](https://docs.docker.com/engine/extend/legacy_plugins/).'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他驱动程序可供选择。可用驱动程序的列表可以在官方 Docker 文档中找到：[https://docs.docker.com/engine/extend/legacy_plugins/](https://docs.docker.com/engine/extend/legacy_plugins/)。
- en: 'The following are examples of its use:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是其使用示例：
- en: '`docker` `volume ls`'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker` `volume ls`'
- en: '`docker volume` `create <volume-name>`'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker volume` `create <volume-name>`'
- en: '`docker volume` `inspect <volume-name>`'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker volume` `inspect <volume-name>`'
- en: '`docker volume` `rm <volume-name>`'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker volume` `rm <volume-name>`'
- en: '`docker volume` `create myvolume`'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker volume` `create myvolume`'
- en: '`docker run -v` `myvolume:/opt/data alpine`'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`docker run -v` `myvolume:/opt/data alpine`'
- en: In this section, we’ve learned how to interact with all Docker components using
    a command-line interface. Up to now, we’ve been using publicly available Docker
    images, but it’s time to learn how to build your own images.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经学习了如何使用命令行界面与所有 Docker 组件进行交互。到目前为止，我们一直在使用公开可用的 Docker 镜像，但现在是时候学习如何构建自己的镜像了。
- en: Dockerfile
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dockerfile
- en: A Dockerfile is essentially a text file with a predetermined structure that
    contains a set of instructions for building a Docker image. The instructions in
    the Dockerfile specify what base image to start with (for example, Ubuntu 20.04),
    what software to install, and how to configure the image. The purpose of a Dockerfile
    is to automate the process of building a Docker image so that the image can be
    easily reproduced and distributed.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 本质上是一个具有预定结构的文本文件，包含一组构建 Docker 镜像的指令。Dockerfile 中的指令指定了从哪个基础镜像开始（例如，Ubuntu
    20.04），安装哪些软件以及如何配置镜像。Dockerfile 的目的是自动化构建 Docker 镜像的过程，以便镜像能够轻松重现和分发。
- en: The structure of a Dockerfile is a list of commands (one per line) that Docker
    (`containerd` to be exact) uses to build an image. Each command creates a new
    layer in the image in UnionFS, and the resulting image is the union of all the
    layers. The fewer layers we manage to create, the smaller the resulting image.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 的结构是一个命令列表（每行一个命令），Docker（准确来说是`containerd`）使用这些命令来构建镜像。每个命令在镜像的
    UnionFS 中创建一个新层，最终生成的镜像是所有层的联合体。我们管理的层越少，最终生成的镜像就越小。
- en: 'The most frequently used commands in a Dockerfile are the following:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 中最常用的命令如下：
- en: '`FROM`'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FROM`'
- en: '`COPY`'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`COPY`'
- en: '`ADD`'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ADD`'
- en: '`EXPOSE`'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EXPOSE`'
- en: '`CMD`'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CMD`'
- en: '`ENTRYPOINT`'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT`'
- en: '`RUN`'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RUN`'
- en: '`LABEL`'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LABEL`'
- en: '`ENV`'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENV`'
- en: '`ARG`'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ARG`'
- en: '`VOLUME`'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VOLUME`'
- en: '`USER`'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USER`'
- en: '`WORKDIR`'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WORKDIR`'
- en: 'You can find a complete list of commands on the official Docker documentation
    website: [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/).'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在官方 Docker 文档网站上找到完整的命令列表：[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)。
- en: Let’s go through the preceding list to understand which command does what and
    when it’s best to use it.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一了解上述列表，理解每个命令的作用以及何时使用它。
- en: FROM
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: FROM
- en: 'A Dockerfile starts with a `FROM` command, which specifies the base image to
    start with:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 从`FROM`命令开始，该命令指定要从哪个基础镜像开始：
- en: '[PRE55]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'You can also name this build using `as` keyword followed by a custom name:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`as`关键字为此构建命名，并跟上自定义名称：
- en: '[PRE56]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`docker build` will try to download Docker images from the public Docker Hub
    registry, but it’s also possible to use other registries out there, or a private
    one.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker build` 将尝试从公共 Docker Hub 注册表下载 Docker 镜像，但也可以使用其他注册表，或使用私有注册表。'
- en: COPY and ADD
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: COPY 和 ADD
- en: 'The `COPY` command is used to copy files or directories from the host machine
    to the container file system. Take the following example:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`COPY`命令用于将文件或目录从主机复制到容器文件系统。以下是一个示例：'
- en: '[PRE57]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: You can also use the `ADD` command to add files or directories to your Docker
    image. `ADD` has additional functionality beyond `COPY`. It can extract a TAR
    archive file automatically and check for the presence of a URL in the source field,
    and if it finds one, it will download the file from the URL. Finally, the `ADD`
    command has a `--chown` option to set the ownership of the files in the destination.
    In general, it is recommended to use `COPY` in most cases, and only use `ADD`
    when the additional functionality it provides is needed.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用`ADD`命令将文件或目录添加到 Docker 镜像中。`ADD`具有比`COPY`更多的功能。它可以自动解压 TAR 压缩文件，并检查源字段中是否有
    URL，如果找到 URL，它将从该 URL 下载文件。最后，`ADD`命令还具有`--chown`选项，用于设置目标中文件的所有权。通常情况下，建议在大多数情况下使用`COPY`，只有在需要`ADD`提供的附加功能时才使用它。
- en: EXPOSE
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: EXPOSE
- en: The `EXPOSE` command in a Dockerfile informs Docker that the container listens
    on the specified network ports at runtime. It does not actually publish the ports.
    It is used to provide information to the user about which ports are intended to
    be published by the container.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 中的 `EXPOSE` 命令告知 Docker 容器在运行时监听指定的网络端口。它并不会实际发布端口，而是用来向用户提供容器计划发布哪些端口的信息。
- en: 'For example, if a container runs a web server on port `80`, you would include
    the following line in your Dockerfile:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一个容器在端口 `80` 上运行 Web 服务器，你应该在 Dockerfile 中包含以下行：
- en: '[PRE58]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: You can specify whether the port listens on TCP or UDP – after specifying the
    port number, add a slash and a TCP or UDP keyword (for example, `EXPOSE 80/udp`).
    The default is TCP if you specify only a port number.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以指定端口是监听 TCP 还是 UDP – 在指定端口号后，添加一个斜杠和 TCP 或 UDP 关键字（例如，`EXPOSE 80/udp`）。如果只指定端口号，则默认使用
    TCP。
- en: 'The `EXPOSE` command does not publish the ports. To make ports available, you
    will need to publish them with the use of the `-p` or `--publish` option when
    running the `docker` `run` command:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPOSE` 命令并不实际发布端口。要使端口可用，你需要在运行 `docker` `run` 命令时使用 `-p` 或 `--publish` 选项来发布端口：'
- en: '[PRE59]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This will map port `8080` on the host machine to port `80` in the container
    so that any incoming traffic on port `8080` will be forwarded to the web server
    running in the container on port `80`.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把主机上的端口 `8080` 映射到容器中的端口 `80`，这样所有到达端口 `8080` 的流量都会被转发到容器中运行的 Web 服务器的端口 `80`。
- en: Regardless of the `EXPOSE` command, you can publish different ports when running
    a container. `EXPOSE` is used to inform the user about which ports are intended
    to be published by the container.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 不管 `EXPOSE` 命令如何，你都可以在运行容器时发布不同的端口。`EXPOSE` 用于告知用户容器计划发布哪些端口。
- en: ENTRYPOINT and CMD
  id: totrans-323
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ENTRYPOINT 和 CMD
- en: Next on our list is the `ENTRYPOINT` command, which in a Dockerfile specifies
    the command that should always be run when the container starts. It cannot be
    overridden by any command-line options passed to the `docker` `run` command.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `ENTRYPOINT` 命令，它在 Dockerfile 中指定容器启动时应始终执行的命令。它不能通过传递给 `docker` `run`
    命令的任何命令行选项来覆盖。
- en: The `ENTRYPOINT` command is used to configure the container as an executable.
    It is similar to the `CMD` command, but it is used to configure the container
    to run as an executable. It is typically used to specify the command that should
    be run when the container starts, such as a command-line tool or a script.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENTRYPOINT` 命令用于将容器配置为可执行文件。它类似于 `CMD` 命令，但用于配置容器作为可执行文件运行。通常用于指定容器启动时应运行的命令，例如命令行工具或脚本。'
- en: 'For example, if you have a container that runs a web server, you might use
    the `ENTRYPOINT` command to specify the command that starts the web server:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果你有一个运行 Web 服务器的容器，你可能会使用 `ENTRYPOINT` 命令来指定启动 Web 服务器的命令：
- en: '[PRE60]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'If you want to run a container with different arguments, you can use the `CMD`
    command to set default arguments that can be overridden when the container is
    started:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用不同的参数运行容器，可以使用 `CMD` 命令设置默认参数，这些参数可以在容器启动时被覆盖：
- en: '[PRE61]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '`CMD` is used to specify the command that should be run when a container is
    started from the image. Take the following example:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`CMD` 用于指定从镜像启动容器时应执行的命令。以下是一个例子：'
- en: '[PRE62]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The rule of thumb here is that if you want your application to take custom arguments,
    you are free to use `ENTRYPOINT` to launch a process and `CMD` to pass arguments
    to it. This way, you can be flexible with what your process will do by passing
    different options via the command line.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的经验法则是，如果你希望应用程序接受自定义参数，你可以使用 `ENTRYPOINT` 启动一个进程，使用 `CMD` 向其传递参数。这样，你可以通过命令行传递不同的选项，使进程更灵活地执行不同的操作。
- en: RUN
  id: totrans-333
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RUN
- en: The `RUN` command in a Dockerfile is used to execute commands inside the container.
    It creates a new layer in the image each time it is executed.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 中的 `RUN` 命令用于在容器内执行命令。每次执行时，它都会在镜像中创建一个新层。
- en: The `RUN` command is used to install software packages, create directories,
    set environment variables, and perform any other actions that are required to
    set up the environment inside the container.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN` 命令用于安装软件包、创建目录、设置环境变量，以及执行设置容器内环境所需的任何其他操作。'
- en: 'For example, you can use the `RUN` command to install a package:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以使用 `RUN` 命令来安装一个软件包：
- en: '[PRE63]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'You can use the `RUN` command to create a directory:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `RUN` 命令来创建一个目录：
- en: '[PRE64]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'You can use the `RUN` command to set environment variables:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `RUN` 命令设置环境变量：
- en: '[PRE65]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: It’s worth noting that the order of the `RUN` commands in the Dockerfile is
    important, as each command creates a new layer in the image, and the resulting
    image is the union of all the layers. So, if you’re expecting some packages to
    be installed later in the process, you need to do it before using them.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Dockerfile 中 `RUN` 命令的顺序很重要，因为每个命令都会在镜像中创建一个新层，最终的镜像是所有层的联合体。因此，如果你期望某些软件包在后续过程中安装，必须在使用它们之前进行安装。
- en: LABEL
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LABEL
- en: 'The `LABEL` command is used to add metadata to the image. It basically adds
    the key-value pairs of data to the image. Those can be used to store information
    such as the image’s version, maintainer, and other relevant information you might
    need in your organization. The following is an example of the command:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`LABEL` 命令用于向镜像添加元数据。它基本上是将数据的键值对添加到镜像中。这些数据可以用于存储信息，如镜像的版本、维护者以及你在组织中可能需要的其他相关信息。以下是该命令的示例：'
- en: '[PRE66]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'You can also add multiple labels in one line:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在一行中添加多个标签：
- en: '[PRE67]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The labels added to the image can be viewed using the `docker` `inspect` command:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `docker` `inspect` 命令可以查看添加到镜像上的标签：
- en: '[PRE68]'
  id: totrans-349
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The use of `LABEL` commands to add metadata to the image can help users understand
    what the image’s purpose is or who they should ask about the details, and help
    to manage the images.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `LABEL` 命令向镜像添加元数据可以帮助用户理解镜像的目的或他们应该向谁询问细节，并有助于管理镜像。
- en: ENV and ARG
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ENV 和 ARG
- en: 'The `ENV` command is used to set environment variables in the following format:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '`ENV` 命令用于以以下格式设置环境变量：'
- en: '[PRE69]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The `ARG` command, on the other hand, is used to define build-time variables.
    These variables can be passed to the `docker build` command using the `--build-arg`
    flag and their values can be used in the Dockerfile.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`ARG` 命令用于定义构建时变量。这些变量可以通过 `--build-arg` 标志传递给 `docker build` 命令，并且它们的值可以在
    Dockerfile 中使用。
- en: 'The `ARG` command is used to define build-time variables similar to the `ENV`
    format:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '`ARG` 命令用于定义类似于 `ENV` 格式的构建时变量：'
- en: '[PRE70]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The `ARG` command creates a variable that is only accessible during the build
    process, whereas the `ENV` command creates an environment variable that is accessible
    to all processes running inside the container.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '`ARG` 命令创建的变量仅在构建过程中可访问，而 `ENV` 命令创建的环境变量则可以被容器内运行的所有进程访问。'
- en: In the next chapter, we’ll get into more detail about the build process of the
    Docker image, where `ARG` and `ENV` are used together to persist `ENV` variables
    across build stages.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章节，我们将详细介绍 Docker 镜像的构建过程，其中 `ARG` 和 `ENV` 被一起使用，以便在构建阶段之间持久化 `ENV` 变量。
- en: VOLUME
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VOLUME
- en: 'Another command is `VOLUME`. With it, you can configure a container to create
    a mount point for a volume at a specific location. Volumes are a way to store
    data outside of the container’s filesystem, which means the data can persist even
    if the container is deleted or recreated. The following is the command:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个命令是 `VOLUME`。通过它，你可以配置容器在特定位置为卷创建挂载点。卷是一种将数据存储在容器文件系统外部的方式，这意味着即使容器被删除或重新创建，数据仍然可以保持。以下是该命令：
- en: '[PRE71]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Use the following to specify multiple directories:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下方式指定多个目录：
- en: '[PRE72]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Or, the following is also valid:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，以下方式也有效：
- en: '[PRE73]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: If there is any data in the directory marked as `volume`, when running a Docker
    using the `docker run` command, a new volume will be created with the content
    of this directory. That way, you can ensure that data created while this Docker
    container is running won’t be lost when the container gets killed or stopped otherwise.
    It’s especially important for databases, as we suggested in the preceding example.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 如果目录中有标记为 `volume` 的数据，当使用 `docker run` 命令运行 Docker 时，将使用该目录的内容创建一个新的卷。这样，即使容器被终止或以其他方式停止，确保在该
    Docker 容器运行期间创建的数据不会丢失。这对于数据库尤为重要，正如我们在前面的示例中所建议的那样。
- en: USER
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: USER
- en: The `USER` command in a Dockerfile is used to set the default user that the
    container runs as. By default, the container runs as the root user; it is recommended
    to run the container as a custom user without root capabilities.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 中的 `USER` 命令用于设置容器运行时的默认用户。默认情况下，容器以 root 用户身份运行；建议以没有 root 权限的自定义用户身份运行容器。
- en: 'The `USER` command is used to set the user and optionally the group that the
    container runs as. For example, you can use the `USER` command to run the container
    as the `webserver` user:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: '`USER` 命令用于设置容器运行时的用户，且可以选择设置用户所属的组。例如，你可以使用 `USER` 命令以 `webserver` 用户身份运行容器：'
- en: '[PRE74]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'You can also specify the user and group:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以指定用户和组：
- en: '[PRE75]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'It’s also possible to set the user ID and group ID instead of the name:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以设置用户 ID 和组 ID，而不是使用名称：
- en: '[PRE76]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The `USER` command only sets the default user for the container, but you can
    override it when running the container:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '`USER` 命令仅设置容器的默认用户，但你在运行容器时可以覆盖该设置：'
- en: '[PRE77]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Running your application as a non-root user is a best practice for security
    reasons. It limits the potential damage that can be done if an attacker gains
    access to the container, as the process running with full permissions is also
    running with the same UID (here: `root`) on the host you are running the image.'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 出于安全原因，以非 root 用户身份运行应用程序是最佳实践。如果攻击者获得容器访问权限，这样可以限制潜在的损害，因为运行具有完全权限的进程在宿主机上也会以相同的
    UID（此处为 `root`）运行。
- en: WORKDIR
  id: totrans-378
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WORKDIR
- en: The `WORKDIR` command in a Dockerfile is used to set the current working directory
    for the container. The working directory is the location in the container’s filesystem
    where all the subsequent `RUN`, `CMD`, `ENTRYPOINT`, `COPY`, and `ADD` commands
    will be executed.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile 中的 `WORKDIR` 命令用于设置容器的当前工作目录。工作目录是容器文件系统中所有后续 `RUN`、`CMD`、`ENTRYPOINT`、`COPY`
    和 `ADD` 命令执行的位置。
- en: 'You can use the `WORKDIR` command to set the working directory to `/usr/local/app`:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `WORKDIR` 命令将工作目录设置为 `/usr/local/app`：
- en: '[PRE78]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: When using `WORKDIR`, you won’t need to set full paths for the files while using
    any other commands and you could parameterize your application location (with
    `ARG` or `ENV`).
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `WORKDIR` 时，你在使用其他命令时无需设置文件的完整路径，还可以将应用程序位置参数化（使用 `ARG` 或 `ENV`）。
- en: Now that we’ve familiarized ourselves with Dockerfiles and how to build Docker
    images, it’s useful to know how to store this new image in some way. Docker image
    registries are used for that exact purpose. We will look into registries in the
    next section.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经熟悉了 Dockerfile 以及如何构建 Docker 镜像，接下来了解如何以某种方式存储这个新镜像是很有用的。Docker 镜像注册表正是用于这个目的。我们将在下一节讨论注册表。
- en: Docker image registries
  id: totrans-384
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 镜像注册表
- en: A **Docker image registry** hosts Docker images. Docker images are organized
    by tags that can be accessed and downloaded by users. These images can be used
    to create and run containers on a host machine. Image repositories can be hosted
    either locally or on a remote server, such as on Docker Hub, which is a public
    repository provided by Docker. You can also create your own private image repositories
    to share and distribute your images within your organization.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker 镜像注册表**用于托管 Docker 镜像。Docker 镜像通过标签组织，用户可以访问并下载这些标签。使用这些镜像可以在宿主机上创建并运行容器。镜像仓库可以托管在本地或远程服务器上，例如
    Docker Hub，这是 Docker 提供的公共仓库。你还可以创建自己的私有镜像仓库，在组织内共享和分发镜像。'
- en: When you pull an image from a Docker image repository, the image is composed
    of multiple layers. Each layer represents an instruction in the Dockerfile that
    was used to build the image. These layers are stacked on top of each other to
    create the final image. Each layer is read-only and has a unique ID.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从 Docker 镜像仓库拉取镜像时，镜像由多个层组成。每一层代表 Dockerfile 中用于构建镜像的一条指令。这些层按顺序叠加在一起，创建最终的镜像。每一层是只读的，并具有唯一的
    ID。
- en: Thanks to UnionFS, the Docker registry shares common layers between multiple
    images and containers, reducing the amount of disk space required. When a container
    modifies a file, it creates a new layer on top of the base image, rather than
    modifying the files in the base image. This allows for easy rollback to previous
    states of the container and makes the images highly portable.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 得益于 UnionFS，Docker 注册表在多个镜像和容器之间共享公共层，从而减少所需的磁盘空间。当容器修改文件时，它会在基础镜像上方创建一个新层，而不是修改基础镜像中的文件。这使得回滚到容器的先前状态变得容易，并且使镜像具有很高的可移植性。
- en: 'There are multiple image repositories you could use depending on a cloud solution
    you’re using (ECR for AWS or Google Container Registry for GCP, for instance)
    or SaaS solutions (Docker Hub is the most popular – [https://hub.docker.com](https://hub.docker.com)).
    There are also a number of open source licensed solutions available:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你使用的云解决方案（例如 AWS 的 ECR 或 GCP 的 Google Container Registry）或 SaaS 解决方案（Docker
    Hub 是最受欢迎的 - [https://hub.docker.com](https://hub.docker.com)），你可以使用多个镜像仓库。也有一些开放源代码的授权解决方案可用：
- en: '**Harbor**: This is available at [https://goharbor.io/](https://goharbor.io/)'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Harbor**：可以在[https://goharbor.io/](https://goharbor.io/)访问。'
- en: '**Portus**: This is available at [http://port.us.org/](http://port.us.org/)'
  id: totrans-390
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Portus**：可以在[http://port.us.org/](http://port.us.org/)访问。'
- en: '**Docker Registry**: This is available at [https://docs.docker.com/registry/](https://docs.docker.com/registry/)'
  id: totrans-391
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker Registry**：可以在[https://docs.docker.com/registry/](https://docs.docker.com/registry/)访问。'
- en: '**Project Quay**: This is available at [https://quay.io](https://quay.io) and
    on GitHub at [https://github.com/quay/quay](https://github.com/quay/quay%20)'
  id: totrans-392
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Project Quay**：可以在[https://quay.io](https://quay.io)访问，也可以在 GitHub 上访问：[https://github.com/quay/quay](https://github.com/quay/quay%20)'
- en: In this section, we’ve familiarized ourselves with Docker registries to store
    our Docker images in a remote location. In the next section, we will look more
    into Docker networking and its extensions.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经了解了 Docker 镜像注册表，便于将 Docker 镜像存储在远程位置。在下一节中，我们将深入探讨 Docker 网络及其扩展。
- en: Docker networking
  id: totrans-394
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 网络
- en: 'There are four types of Docker networking: none, bridge, host, and overlay.'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 网络有四种类型：none、bridge、host 和 overlay。
- en: '*Bridge* is the default network mode in Docker. Containers in the same bridge
    network can communicate with each other. Shortly, it creates a virtual network,
    in which containers are assigned IP addresses and can cummunicate using them,
    while anything outside of that network cannot reach any of those addresses. In
    the *Host* network, the container uses the host’s network stack. This means that
    the container shares your machine’s IP address and network interfaces.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '*Bridge*是 Docker 中的默认网络模式。处于同一桥接网络中的容器可以相互通信。简而言之，它创建了一个虚拟网络，在该网络中，容器被分配了 IP
    地址，并可以通过这些地址进行通信，而网络之外的任何事物都无法访问这些地址。在*Host*网络中，容器使用主机的网络栈。这意味着容器共享主机的 IP 地址和网络接口。'
- en: '*Overlay* mode allows you to create a virtual network that spans multiple Docker
    hosts. Containers in different hosts can communicate with each other as if they
    are on the same host. It’s useful when running Docker Swarm.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '*Overlay*模式允许你创建一个跨越多个 Docker 主机的虚拟网络。不同主机上的容器可以相互通信，就像它们在同一主机上一样。它在运行 Docker
    Swarm 时非常有用。'
- en: Using the Docker command line, you are able to create a custom network of any
    of those types.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker 命令行，你可以创建任何这些类型的自定义网络。
- en: None network
  id: totrans-399
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: None 网络
- en: A **none network** in Docker is a special type of network mode that disables
    all networking for a container. When a container is run in *none* network mode,
    it does not have access to any network resources and cannot communicate with other
    containers or the host machine.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '**None 网络**是 Docker 中的一种特殊网络模式，它禁用容器的所有网络功能。当容器在*none*网络模式下运行时，它无法访问任何网络资源，也不能与其他容器或主机进行通信。'
- en: To run a container in *none* network mode, you can use the `--network none`
    option when running the `docker` `run` command.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 要在*none*网络模式下运行容器，你可以在运行`docker run`命令时使用`--network none`选项。
- en: 'For example, to start a container running the `nginx` image in *none* network
    mode, you would run the following command:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要在*none*网络模式下启动一个运行`nginx`镜像的容器，你可以运行以下命令：
- en: '[PRE79]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: The *none* network is useful for running workloads that aren’t supposed to use
    any network connections, for example, for processing data in a connected volume.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '*None*网络适用于运行不需要任何网络连接的工作负载，例如在连接的卷中处理数据。'
- en: Bridge mode
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 桥接模式
- en: When using **bridge mode** on a container being created, a virtual interface
    is also created and attached to the virtual network. Each container is then assigned
    a unique IP address on the virtual network, allowing it to communicate with other
    containers and the host machine.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建容器时使用**bridge模式**时，还会创建一个虚拟接口，并将其附加到虚拟网络。每个容器将被分配一个唯一的 IP 地址，允许它与其他容器和主机进行通信。
- en: The host machine acts as a gateway for the containers, routing traffic between
    the containers and the outside network. When a container wants to communicate
    with another container or the host machine, it sends the packet to the virtual
    network interface. The virtual network interface then routes the packet to the
    correct destination.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 主机机器充当容器的网关，在容器与外部网络之间路由流量。当一个容器想要与另一个容器或主机机器通信时，它将数据包发送到虚拟网络接口。虚拟网络接口然后将数据包路由到正确的目的地。
- en: By default, it’s a `172.17.0.0/16` network and it’s connected to a bridge device,
    `docker0`, in your machine. Within this network, all traffic between containers
    and the host machine is allowed.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，它是一个`172.17.0.0/16`网络，并且与您机器中的桥接设备`docker0`连接。在这个网络中，容器与主机机器之间的所有流量都是允许的。
- en: All containers are attached to the default bridge network if no network was
    selected using the `--network` option when executing the `docker` `run` command.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在执行 `docker` `run` 命令时未使用 `--network` 选项选择网络，则所有容器都将附加到默认的桥接网络。
- en: 'You can list all available networks using the following command:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下命令列出所有可用的网络：
- en: '[PRE80]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'To get more information about the network, you can use the following command:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取更多关于网络的信息，您可以使用以下命令：
- en: '[PRE81]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Let’s move on to HOST mode.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进入 HOST 模式。
- en: Host mode
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主机模式
- en: In **host networking mode**, the container shares the host’s network stack and
    network interfaces. This means that the container uses your machine’s IP address
    and network settings, and can directly access the same network resources as the
    machine it runs on, including other containers.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **主机网络模式** 下，容器共享主机的网络栈和网络接口。这意味着容器使用您的机器的 IP 地址和网络设置，并且可以直接访问与其运行的机器相同的网络资源，包括其他容器。
- en: Containers running in host networking mode can also directly listen on a port
    of the host machine (bind to it).
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 运行在主机网络模式下的容器也可以直接监听主机机器的端口（绑定到它）。
- en: One of the main advantages of host networking mode is that it provides better
    performance as the container doesn’t have to go through an additional network
    stack.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 主机网络模式的主要优点之一是提供更好的性能，因为容器不需要经过额外的网络栈。
- en: This mode is less secure than the other networking mode as the container has
    direct access to the host’s network resources and can listen to connections on
    the host’s interface.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他网络模式相比，这种模式的安全性较低，因为容器可以直接访问主机的网络资源，并能够监听主机接口上的连接。
- en: Overlay
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 覆盖网络
- en: An **overlay network** is created by a manager node, which is responsible for
    maintaining the network configuration and managing the membership of worker nodes.
    The manager node creates a virtual network switch and assigns IP addresses to
    each container on the network.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '**覆盖网络**是由管理节点创建的，管理节点负责维护网络配置并管理工作节点的成员资格。管理节点创建一个虚拟网络交换机，并为网络中的每个容器分配 IP
    地址。'
- en: Each worker node runs Docker Engine and a container network driver, which is
    responsible for connecting the containers on that host to the virtual network
    switch. The container network driver also ensures that packets are properly encapsulated
    and routed to the correct destination.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 每个工作节点运行 Docker 引擎和容器网络驱动程序，负责将该主机上的容器连接到虚拟网络交换机。容器网络驱动程序还确保数据包被正确封装并路由到正确的目的地。
- en: When a container on one host wants to communicate with a container on another
    host, it sends the packet to the virtual network switch. The switch then routes
    the packet to the correct host, where the container network driver decapsulates
    the packet and delivers it to the destination container.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个主机上的容器想要与另一个主机上的容器通信时，它将数据包发送到虚拟网络交换机。交换机然后将数据包路由到正确的主机，容器网络驱动程序在目标主机上解封装数据包并将其传送到目标容器。
- en: The overlay network uses the **Virtual eXtensible Local Area Network** (**VXLAN**)
    protocol to encapsulate IP packets and make it possible to create a Layer 2 network
    between multiple hosts.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖网络使用 **虚拟扩展局域网**（**VXLAN**）协议来封装 IP 数据包，并使得在多个主机之间创建二层网络成为可能。
- en: Summary
  id: totrans-425
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have introduced one of the major building blocks of modern
    DevOps-led infrastructure, that is, containers. We described the most prominent
    container technology – Docker. We have also introduced the basics of running Docker
    containers and building your own. In the next chapter, we are going to build on
    this knowledge and introduce more advanced Docker topics.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了现代 DevOps 引领的基础设施的主要组成部分之一，那就是容器。我们描述了最突出的容器技术——Docker。我们还介绍了运行 Docker
    容器和构建自定义容器的基础知识。在下一章中，我们将基于这些知识，介绍更高级的 Docker 主题。
