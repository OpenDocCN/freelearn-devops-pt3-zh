- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduce one of the building blocks of the DevOps toolkit
    – containers. We are going to explain the differences between virtualization and
    containers, and then present the advantages and disadvantages of both solutions.
    Additionally, we are going to present a way to choose between both solutions for
    a given workload.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main topics covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Virtualization versus containerization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anatomy of Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dockerfile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker image registries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker networking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you will need a Linux system with an installed Docker Engine.
    We are not going to cover the installation steps here. Different Linux distributions
    provide Docker in different ways. We are going to use Docker Engine 20.10.23 here.
    Since in this chapter all examples are very basic, older versions of Docker will
    most probably work. Still, if you run into issues with following our examples,
    updating Docker to our version should be your first step in troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: Virtualization versus containerization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to explain what virtualization and containerization
    are and what the major differences between them are.
  prefs: []
  type: TYPE_NORMAL
- en: Virtualization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Virtualization is a technique of running a complete simulated computer within
    another computer. Complete means that it mirrors everything a physical computer
    would have: motherboard, BIOS, processor, hard drives, USB ports, and so on. Simulated
    means that it is entirely a product of software. This computer does not exist
    physically, thus it is called virtual. To exist, the **virtual machine** (**VM**),
    as simulated computers are often called, needs a real, physical one to emulate
    it. The physical machine is called a host or hypervisor.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, I have a physical computer. It is powerful. Why would I want to run a VM
    in it? For obvious reasons, the VM will be less powerful than the host: after
    all, the host requires RAM, CPU, and hard drive space for itself. There is also
    some small drop in performance (since we are actually running a program that emulates
    full hardware) when compared to the physical machine.'
  prefs: []
  type: TYPE_NORMAL
- en: The reasons can vary depending on the use case, but there are a lot of them.
  prefs: []
  type: TYPE_NORMAL
- en: You may want to run a full operating system different from your own to test
    some software, to run software unavailable for your operating system, or to dutifully
    recreate a development environment for your application. You may want to recreate,
    as closely as possible, a production environment for your application. All those
    are valid and pretty popular reasons for using VMs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us see what the advantages of virtualization are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Isolation**: VMs present themselves, as mentioned, as fully functional computers.
    To the running operating system, they create the illusion of being separate physical
    machines. Whatever we run in them shouldn’t be able to access the host computer
    (unless specifically allowed to) and, indeed, barring a few incidents where such
    things were possible (as a result of a programming error), VMs have provided secure
    environments. This isolation is a very good solution in malware analysis, running
    workloads that require separate servers, and so on. As an example, if a VM runs
    a single WWW server, the security vulnerability in the server may grant the attacker
    access to the operating system, thus allowing them a free run. But since other
    components of infrastructure, for example, databases, are run in separate VMs,
    the incident can be contained to the WWW server only.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tuning**: With a sufficiently powerful host, it is possible to partition
    its resources so that each running VM has guaranteed RAM, hard disk space, and
    CPU.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operating system simplification**: When running various workloads, such as
    databases, WWW servers, and mail servers, the complexity of maintaining a single
    server running them all grows pretty fast. Every installed software requires additional
    software to be installed (such as libraries and helper programs). Libraries required
    by various programs may introduce incompatibilities (especially if we install
    software not distributed by operating system developers, so-called third-party
    programs). On rare occasions, even the software included in the distribution may
    be incompatible with each other to a degree that makes it impossible or very difficult
    to install them on one operating system. Maintenance of such a system can become
    troublesome and require a lot of detective work. Modern hypervisor software alleviates
    many system administration hurdles by means of clones, snapshots, golden images,
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automation**: Modern virtualization software provides a lot of features that
    promote the automation of system management on many levels. Snapshots – a point-in-time
    capture of the whole system – allow a rollback at any given moment to a previous
    system state. This allows it to easily back out of unwanted changes to the last
    known good state. Clones let us provision new VMs based on another, already running
    and configured. Golden images are archived images of VMs that we can easily and
    quickly import and start – completely omitting installation and limiting configuration
    to the absolute minimum. This also allows for reliable environment recreation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Speed up**: Properly setting up a workflow utilizing VMs allows us to start
    a new operating system complete with its own server or desktop hardware in a matter
    of minutes instead of hours. This opens new possibilities for testing environments,
    remote desktop solutions, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding list is not exhaustive but should easily demonstrate why virtualization
    became a darling of data centers and hosting companies. The availability of a
    wide variety of servers we can cheaply rent is a direct result of virtualization
    allowing companies to partition the hardware.
  prefs: []
  type: TYPE_NORMAL
- en: As great as the solution is, it is not a panacea and not everything should be
    virtualized. More so, running a separate VM for every piece of software easily
    leads to resource utilization overhead. 100 virtual servers not only will use
    the CPU and RAM provided to the operating system in it but also, some percent
    will be used for housekeeping on the host machine. Each of those servers will
    utilize the disk space required by the operating system within, even though it
    probably will be an exact copy of the 99 other servers on the same server – a
    waste of space, RAM, and CPU. Also, bringing up a new VM will take some time.
    Granted, if you have everything configured and automated properly, it is going
    to be shorter than setting up a new hardware machine, but still.
  prefs: []
  type: TYPE_NORMAL
- en: Before virtualization became widely available, operating system developers were
    trying to provide techniques that would allow system operators to isolate various
    workloads. The main targets were data centers, where one physical server was too
    much for one workload (a database or a WWW server), but running more than one
    posed a risk (security, stability, etc.). After the virtualization became widespread,
    it became obvious that using it was sometimes like using cannons against sparrows.
    It doesn’t make sense to procure a whole new server (even virtual) with the whole
    operating system when you want to run a small program. Thus, through a natural
    progression of innovating new features that allow for better process isolation,
    containers arose.
  prefs: []
  type: TYPE_NORMAL
- en: Containerization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Containers are lightweight virtual environments that allow us to run a single
    process in an isolated manner. An ideally prepared container consists of only
    software and libraries required to run the application. The host operating system
    takes care of operating hardware, managing memory, and all other peripheral tasks.
    The main assumption of the container is that it doesn’t emulate being a separate
    operating system or a separate server. Processes or users within the container
    can easily find out they are enclosed there. The downside is that containers won’t
    emulate hardware. You cannot use them to test new drivers, for instance. The upside
    is that a single container can take as little as just a few megabytes of hard
    drive space and only the memory required for the process to run.
  prefs: []
  type: TYPE_NORMAL
- en: As a consequence, starting up a container takes only the time that the application
    needs to start. The bootup time – the BIOS, hardware tests, and operating system
    boot time – is all shaved off. All the software not required by the application
    can, and should, be omitted. Given the small size of container images, their redistribution
    times became almost negligible, their start times almost instantaneous, and the
    build time and process largely simplified. This has led to much easier recreation
    of the environment. This, in turn, has led to easier test environment setup and
    very often deployments of new versions of the software – as often as several thousand
    times a day. The scaling of applications has become much easier and faster.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding brought another change in the approach to running applications.
    The logical consequence of the preceding change is that containers are not maintained
    the same way the operating system is. You do not upgrade software within the container
    – you deploy a container with a new version of software in place of the obsolete
    one. This leads to an assumption that you don’t keep data within a container but
    in a filesystem that you attach to the container during the run.
  prefs: []
  type: TYPE_NORMAL
- en: The poster child of Linux containerization is **Docker**. One thing that Docker
    did that has probably helped to bring the revolution is creating an ecosystem
    for easy sharing of container images.
  prefs: []
  type: TYPE_NORMAL
- en: A container image is, in the case of Docker, a simple archive consisting of
    all the binaries and libraries that are required for the application and a few
    files with configuration information. Since the size tends to be rather small
    and the image never has any data within, it is logical to allow people to share
    the image they have built. Docker has an image hub (called Docker Hub) with a
    nice WWW UI, and command-line tools for searching, downloading, and uploading
    images. The hub allows rating images and giving comments and feedback to the authors.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what containerization is, we can look deeper into how Docker
    works internally and what makes it tick. Let’s look into the anatomy of Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Docker comprises several components:'
  prefs: []
  type: TYPE_NORMAL
- en: Command-line utility – Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Host
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Docker CLI tool – `docker` – is the main means of managing containers and
    images. It is used to build images, pull them from the registry, upload them to
    the registry, run containers, interact with them, set runtime options, and, finally,
    destroy them. It is a command-line tool that communicates with Docker hosts using
    an API. By default, it is assumed that the `docker` command is being invoked on
    the host, but it is not strictly necessary. One `docker` CLI tool can manage more
    than one host.
  prefs: []
  type: TYPE_NORMAL
- en: The host is more interesting. The host runs `dockerd` – a daemon responsible
    for actually performing the actions ordered via the `docker` tool. It is here
    that container images are stored. The host also provides resources such as networking,
    storage, and the containers themselves.
  prefs: []
  type: TYPE_NORMAL
- en: The `dockerd` daemon is the beating heart of the containers. It’s the background
    process that runs on a host machine and manages the containers. `dockerd` manages
    creating and managing containers, providing an API for interacting with the daemon,
    managing volumes, networks, and image distribution, providing an interface to
    manage images and containers, and storing and managing metadata for containers
    and images. It also manages communication between other processes in Docker Swarm
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: OverlayFS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**OverlayFS** was first released as a part of the Linux kernel version 3.18
    in August 2014\. It was initially developed as a means to provide a more efficient
    and flexible way to handle container storage in comparison to the previous storage
    driver, **Another UnionFS** (**AUFS**). OverlayFS was considered the next generation
    of UnionFS, which was the storage driver used by Docker at that time.'
  prefs: []
  type: TYPE_NORMAL
- en: This filesystem was included as a built-in storage driver in Docker starting
    from version 1.9.0\. Since then, OverlayFS has become the default storage driver
    for Docker on most Linux distributions, and it is widely used in various container
    orchestration platforms such as Kubernetes and OpenShift.
  prefs: []
  type: TYPE_NORMAL
- en: 'OverlayFS is a filesystem for Linux that allows for the overlay of one directory
    on top of another. It allows for the creation of a *virtual* filesystem that is
    composed of two different directories: a lower directory and an upper directory.
    The upper directory contains the files that are visible to the user, while the
    lower directory contains the *base* files that are hidden.'
  prefs: []
  type: TYPE_NORMAL
- en: When a file or directory is accessed in the upper directory, OverlayFS first
    looks for it in the upper directory, and if it doesn’t find it, it looks in the
    lower directory. If the file or directory is found in the upper directory, that
    version is used. If it is found in the lower directory, that version is used.
  prefs: []
  type: TYPE_NORMAL
- en: This mechanism allows for the creation of *overlay* filesystems, where the upper
    directory can be used to add, modify, or delete files and directories in the lower
    directory, without modifying the lower directory itself. This is useful in scenarios
    such as containerization, where the upper layer can be used to store the changes
    made in a container, while the lower layer contains the base image for the container.
  prefs: []
  type: TYPE_NORMAL
- en: What is an image?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **Docker image** is a pre-built package that contains all of the files and
    settings needed to run a piece of software in a container. It includes your application
    code or a binary, runtime, system tools, libraries, and all needed configuration
    files. Once an image is built, it can be used to start one or more containers,
    which are isolated environments that provide a consistent way to run the software.
  prefs: []
  type: TYPE_NORMAL
- en: When starting a container, you must select a program to run as a primary process
    of the container. If this process quits, the whole container will be terminated
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Docker image typically involves creating a Dockerfile, which is a
    script that contains instructions for building the image. The Dockerfile specifies
    the base image to use, any additional software to be installed, any files to be
    added to the image, and any configuration settings to be applied.
  prefs: []
  type: TYPE_NORMAL
- en: When building an image, Docker reads the instructions in the Dockerfile and
    performs the steps we’ve prepared inside the Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: Once the image is built, it can be saved and used to start one or more containers.
    The process of building an image can also be automated using a tool such as Jenkins,
    GitHub, or GitLab actions, which can automatically build and test new images whenever
    changes are made to the code base.
  prefs: []
  type: TYPE_NORMAL
- en: The resulting image consists of a unique ID (SHA-256 hash), which is a hash
    of the image’s content and metadata, and it also can have a tag, which is a human-readable
    string that can be used to refer to a specific version of the image. UnionFS takes
    care of merging all content when running a container.
  prefs: []
  type: TYPE_NORMAL
- en: 'To inspect the metadata and content parts of an image, you can run the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: There’s a lot of information here, so we’ve stripped the output and left the
    information we want to focus on. You can see an image ID, all merged directories
    under the `GraphDriver` section, and the `RootFS sha256` layer. `RootFS` contains
    the whole filesystem created by UnionFS when we start a process within the container.
  prefs: []
  type: TYPE_NORMAL
- en: What is a container runtime?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **container runtime** (or **container engine**) is a software component that
    runs containers on your system. Container runtimes load container images from
    a Docker registry, monitoring system resources, allocating system resources for
    a container, and managing its life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of runtime containers that are being used. The most known
    and used on laptops – you probably have it installed on your system already –
    is `containerd`. It’s a high-performance container runtime that is designed to
    be embedded in a larger system. It is used by many cloud providers and is also
    the default runtime for Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: LXC is a runtime that uses Linux namespaces and cgroups to provide isolation
    for containers. It is considered to be more lightweight and efficient than Docker
    (`containerd`). It’s also harder to use.
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting runtime is **Container Runtime Interface for OCI** (**CRI-O**).
    CRI-O is fully compliant with the **Open Container Initiative** (**OCI**) specification,
    which means that it can run any OCI-compliant container image. Also, it’s designed
    to work natively with Kubernetes Pods, which allows it to provide better integration
    with Kubernetes than other runtimes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Rocket** (**rkt**) is an alternative container runtime that is designed to
    be more secure and efficient than Docker. It uses the **App Container** (**appc**)
    image format and has a simpler architecture than Docker. It’s also not used very
    often.'
  prefs: []
  type: TYPE_NORMAL
- en: Other container engines worth noting are **run Open Container** (**runC**),
    a low-level container engine that provides the basic functionality for creating
    and managing containers, and Firecracker developed by AWS.
  prefs: []
  type: TYPE_NORMAL
- en: cgroups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linux **cgroups** (short for **control groups**) are a Linux kernel feature
    that allows for the management and isolation of system resources for groups of
    processes. Cgroups allow the system administrator to allocate resources such as
    CPU, memory, and network bandwidth to specific groups of processes, and to monitor
    and control their usage.
  prefs: []
  type: TYPE_NORMAL
- en: This can be used to limit the resources used by a particular application or
    user, or for isolating different types of workloads on a shared system.
  prefs: []
  type: TYPE_NORMAL
- en: Docker by default doesn’t limit either CPU or memory consumption for an application
    inside a container. It’s quite easy to enable without any direct interaction with
    cgroups or kernel settings – the Docker daemon will do it for us.
  prefs: []
  type: TYPE_NORMAL
- en: You can limit the amount of memory a Docker container can use by using the `--memory`
    or `-m` option with the `docker` `run` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, use the following to run the `alpine` image with a memory limit
    of 500 MB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You can specify the memory limit in bytes, kilobytes, megabytes, or gigabytes
    by using the appropriate suffix (`b`, `k`, `m`, or `g`).
  prefs: []
  type: TYPE_NORMAL
- en: When you limit the memory for a container, Docker will also limit the amount
    of memory swap that a container can use. By default, the memory swap limit is
    twice the value of the memory limit. It’s also possible to limit the memory swap
    by using the `--memory-swap` or `--``memory-swappiness` option.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting usage of the CPU time that an application inside a Docker container
    can use can be done by using the CPU shares limit (`--cpus` or `-c` option). CPU
    shares are a relative measure of CPU time that a container can use. By default,
    a container is allocated a certain number of CPU shares, which it can use to consume
    CPU time proportional to its share. For example, if a container has 0.5 CPU shares,
    it can use up to 50% of the CPU time if no other containers are consuming CPU.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other options available are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--cpuset-cpus`: This allows you to specify the range of CPU cores that the
    container can use, for example, `0-1` to use the first two cores, or `0,2` to
    use the first and third core.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--cpu-shares`: This allows you to set a CPU time limit for a Docker container.
    It specifies the amount of CPU time, in microseconds, that the container can use
    in a given period of time. The period of time is specified by the `--``cpu-period`
    option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--cpu-quota` and `--cpu-period`: `--cpu-quota` is the CPU time limit in microseconds
    and `--cpu-period` is the length of the CPU time period in microseconds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `--cpu-quota` and `--cpu-period` options allow you to specify a more precise
    CPU time limit for a container compared to the `--cpus` and `--cpuset-cpus` options.
    It is useful if you need to limit the CPU time for a container more precisely
    to prevent performance issues or ensure that your application runs reliably.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we went through the container runtime and how it works. Next,
    we will be looking into the command-line interface for the `containerd` daemon
    to interact with all Docker components in an easy and robust way.
  prefs: []
  type: TYPE_NORMAL
- en: Docker commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `containerd` daemon using a socket file or network.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most common commands you can use are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`build`: This allows you to build a new Docker image using a Dockerfile'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`run`: This starts a new container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start`: This restarts one or more stopped containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stop`: This will stop one or more running containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`login`: This is used to gain access to private registries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pull`: This downloads an image or a repository from a registry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`push`: This uploads an image or a repository to a registry'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`build`: This helps create an image from a provided Dockerfile'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`images`: This lists all images on your machine'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ps`: This lists all running containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exec`: This executes a command in a running container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logs`: This shows the logs of a container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rm`: This removes one or more containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rmi`: This removes one or more images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`network`: This is used to manage Docker networks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`volume`: This is used to manage volumes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: docker build
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `docker build` command is used to build a Docker image from a Dockerfile.
    The basic syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`PATH` is the path to the directory containing the Dockerfile.'
  prefs: []
  type: TYPE_NORMAL
- en: '`URL` is the URL to a Git repository containing the Dockerfile.'
  prefs: []
  type: TYPE_NORMAL
- en: '`-` (a dash) is used to build an image from the contents of `stdin`, so you
    could pipe Dockerfile content to it from the output of some previous command that
    would build a Dockerfile, for example, generate it from a template.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To build an image from a Dockerfile located in the current directory, you would
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use a specific tag for the build image, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also pass `--build-arg` to your build command to pass build-time variables
    to the Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: docker run
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you’re running a container, you’re essentially taking a Docker image and
    executing a process within that environment. An image is a blueprint or a snapshot
    of a container; it’s a read-only template with instructions for creating a container.
    A container that is running is an instance of that image but with its own state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `docker run` command is used to start a container from a Docker image.
    For example, to start a container from the `myimage` image and run `/bin/bash`,
    you would run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also pass options to the `run` command, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This command starts the container in detached mode (the `-d` option; it puts
    a container in the background), maps port `80` in the container to port `8080`
    on the host (`-p 8080:80`), and assigns the name `containername` to the container
    (`--``name containername`).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also pass environment variables to the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Docker containers don’t store data after they are killed. To make data persistent
    you would use storage external to the docker container itself. In the simplest
    setup, this would be a directory or a file on filesystem outside the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways to do it: create a Docker volume:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To use this volume for data persistence you’d mount it when starting the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also bind mount local folder (`-v` option. In this case you don’t run
    the Docker volume create command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also specify the working directory inside the container using the `-``w`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Other options that are useful are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--rm`: This option will remove the container after it is stopped'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-P`, `--publish-all`: This option will publish all exposed ports (`EXPOSE`
    option in `Dockerfile`) to a random local port'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--network`: This option will connect the container to the Docker network specified'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find more available options to use by invoking the `docker run --``help`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: docker start
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `docker start` command is used to start one or more stopped Docker containers.
    For example, to start a container, you would run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`mycontainer` is the name or ID of the container you want to start. You can
    check all running and stopped containers using the `docker ps` command; we will
    get into it a bit later. You can also start multiple containers at once. To do
    that, you can list their names or IDs separated by spaces.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start multiple containers, you would run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'To attach to the container’s process so that you can see its output, use the
    `-a` option while starting the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: docker stop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This command is used to stop containers running in the background. The syntax
    for the command is the same as for starting the container. The difference lies
    in the available options you can use.
  prefs: []
  type: TYPE_NORMAL
- en: To stop multiple containers at once, you can list their names or IDs separated
    by spaces.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To stop multiple containers, you would run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `-t` option to specify the amount of time (in seconds)
    to wait for the container to stop before sending a `SIGKILL` signal. For example,
    to wait for `10` seconds before stopping a container, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: You can also use `--time` or `-t` to specify the amount of time to wait for
    the container to stop before sending a `SIGKILL` signal.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the `docker stop` command sends a `SIGTERM` signal to the container,
    which gives the process running in the container a chance to cleanly shut down.
    If the container does not stop after the default 10-second timeout, a `SIGKILL`
    signal will be sent to force it to stop.
  prefs: []
  type: TYPE_NORMAL
- en: docker ps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This command is used to list the running or stopped containers. When you run
    the `docker ps` command without any options, it will show you the list of running
    containers along with their container ID, names, image, command, created time,
    and status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s possible to view all containers with the `-``a` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `--quiet` or `-q` option to display only the container IDs,
    which might be useful for scripting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `--filter` or `-f` option to filter the output based on certain
    criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'To inspect how much disk space the container is utilizing, you will need to
    use the `-``s` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This container doesn’t use additional space on the disk, as it didn’t save any
    data.
  prefs: []
  type: TYPE_NORMAL
- en: docker login
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `docker login` command is used to log in to a Docker registry. A registry
    is a place where you can store and distribute Docker images. The most commonly
    used registry is Docker Hub, but you can also use other registries, such as AWS
    **Elastic Container Registry** (**ECR**), Project Quay, or Google Container Registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, `docker login` will connect to the Docker Hub registry. If you
    want to log in to a different registry, you can specify the server URL as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When you run the `docker login` command, it will prompt you for your username
    and password. If you don’t have an account on the registry, you can create one
    by visiting the registry’s website.
  prefs: []
  type: TYPE_NORMAL
- en: Once you are logged in, you will be able to push and pull images from the registry.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the `--username` or `-u` option to specify your username, and
    `--password` or `-p` to specify the password on the command line, but it is not
    recommended due to security reasons.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the `--password-stdin` or `-P` option to pass your password
    via `stdin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be an output for any command. For example, to log in to AWS ECR, you
    would use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `--token` or `-t` option to specify your token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Once you are logged in, you will be able to push and pull images from the registry.
  prefs: []
  type: TYPE_NORMAL
- en: docker pull
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To pull a Docker image, you can use the `docker pull` command followed by the
    image name and a tag. By default, `pull` will pull a tag `latest` (latest is the
    name of the tag, or the version of the image).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, use the following to pull the latest version of the `alpine` image
    from Docker Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following to pull a specific version of the `alpine` image, such as
    version 3.12:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You can also pull an image from a different registry by specifying the registry
    URL in the image name.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, use the following to pull an image from a private registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: docker push
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After you build a new image, you can push that image to the image registry.
    By default, `push` will try to upload it to the Docker Hub registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To push a specific version of the image, such as version 1.0, you will need
    to tag the image locally as version 1.0 and then push it to the registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also push an image to a different registry by specifying the registry
    URL in the image name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: You need to be logged in to the registry to which you are pushing the image
    using the `docker login` command before pushing an image.
  prefs: []
  type: TYPE_NORMAL
- en: docker image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a command to manage images. The common use cases for `docker image`
    are shown in the following examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'To list available images on your machine, you can use the `docker image` `ls`
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: REPOSITORY         TAG            IMAGE ID       CREATED        SIZE
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `docker images` command to do the same action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To pull an image from the Docker registry, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: When you specify an image name, you can use either the full repository name
    (for example, `docker.io/library/alpine`) or just the image name (for example,
    `alpine`), if the image is in the default repository (Docker Hub). See also the
    `docker pull` command discussed in an earlier section.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also possible to build an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: See also the section on the `docker build` command for more details on building
    images.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a tag for an image, you should run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can remove an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: See the section on the `docker rmi` command, which is an alias of this command.
  prefs: []
  type: TYPE_NORMAL
- en: Another option to remove images is the `docker image prune –` command. This
    command will remove all unused images (dangling images).
  prefs: []
  type: TYPE_NORMAL
- en: docker exec
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`docker exec` allows you to run a command in a running Docker container. The
    basic syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, the terms have the following meanings:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CONTAINER` is the name or ID of the container to run the command in'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COMMAND` is the command to run in the container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ARGUMENTS` represents any additional arguments for the command (this is optional)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, to run the `ls` command in the container named `my_container`,
    you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: docker logs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`docker logs` is used to fetch logs generated by a Docker container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Additional options you can pass to the command are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--details, -a`: Show extra details provided to logs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--follow, -f`: Follow log output'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--since, -t`: Only display logs since a certain date (e.g., 2013-01-02T13:23:37)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--tail, -t`: Number of lines to show from the end of the logs (default `all`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An example of its use is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: docker rm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`docker rm` is used to remove one or more Docker containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of its use is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: To list all containers, use the `docker ps -``a` command.
  prefs: []
  type: TYPE_NORMAL
- en: docker rmi
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Images that are pulled or built locally can take up a lot of space on your disk,
    so it’s useful to check and remove unused ones. `docker rmi` is used to remove
    one or more Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is its usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'An example of its use is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: docker network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `docker network` command is used to manage Docker networks. Apart from the
    usual actions (create, delete, and list), it’s possible to attach (and disconnect)
    a running Docker container to a different network.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also possible to extend Docker with a specialized network plugin of your
    choice. There are multiple options here, so we will just list some of the network
    plugins with a short description. Plugins can also be used with more advanced
    setups, such as Kubernetes clusters:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Contiv-VPP** ([https://contivpp.io/](https://contivpp.io/)) uses the **Vector
    Packet Processing** (**VPP**) technology to provide an efficient, scalable, and
    programmable networking solution for containers, suitable for use in enterprise
    and service provider environments, where high-performance and scalable networking
    are a requirement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Weave Net** ([https://www.weave.works/docs/net/latest/overview/](https://www.weave.works/docs/net/latest/overview/))
    allows containers to communicate with each other, regardless of which host they
    are running on. Weave Net creates a virtual network that spans multiple hosts,
    making it possible to deploy containers in a highly available, redundant, and
    load-balanced manner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Calico** ([https://www.tigera.io/tigera-products/calico/](https://www.tigera.io/tigera-products/calico/))
    is one of the most recognizable plugins out there. It uses a pure IP-based approach
    to networking, providing simplicity and scalability. Calico allows administrators
    to define and enforce network policies, such as allowing or denying specific traffic
    flows based on the source, destination, and port. Calico is designed for large-scale
    deployments and supports both virtual and physical networks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are common operations when using the `docker` `network` command:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a new network:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Inspecting a network:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Removing a network:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Listing networks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Connecting a container to a network:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Disconnecting a container from a network:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: docker volume
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `docker volume` command is used to manage volumes in Docker. With this single
    command, you’re able to list available volumes, clean unused ones, or create one
    for later use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker supports multiple volume drivers, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`local`: The default driver; stores data on the local filesystem using UnionFS'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`awslogs`: Makes it possible to store logs generated by your applications in
    Amazon CloudWatch Logs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cifs`: Allows you to mount an SMB/CIFS (Windows) share as a Docker volume'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GlusterFS`: Mounts the GlusterFS distributed filesystem as a Docker volume'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NFS`: Mounts the **Network File System** (**NFS**) as a Docker volume'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Many more drivers are available. The list of available drivers can be found
    in the official Docker documentation: [https://docs.docker.com/engine/extend/legacy_plugins/](https://docs.docker.com/engine/extend/legacy_plugins/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are examples of its use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker` `volume ls`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker volume` `create <volume-name>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker volume` `inspect <volume-name>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker volume` `rm <volume-name>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker volume` `create myvolume`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker run -v` `myvolume:/opt/data alpine`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this section, we’ve learned how to interact with all Docker components using
    a command-line interface. Up to now, we’ve been using publicly available Docker
    images, but it’s time to learn how to build your own images.
  prefs: []
  type: TYPE_NORMAL
- en: Dockerfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Dockerfile is essentially a text file with a predetermined structure that
    contains a set of instructions for building a Docker image. The instructions in
    the Dockerfile specify what base image to start with (for example, Ubuntu 20.04),
    what software to install, and how to configure the image. The purpose of a Dockerfile
    is to automate the process of building a Docker image so that the image can be
    easily reproduced and distributed.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of a Dockerfile is a list of commands (one per line) that Docker
    (`containerd` to be exact) uses to build an image. Each command creates a new
    layer in the image in UnionFS, and the resulting image is the union of all the
    layers. The fewer layers we manage to create, the smaller the resulting image.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most frequently used commands in a Dockerfile are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FROM`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COPY`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ADD`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EXPOSE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CMD`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ENTRYPOINT`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RUN`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LABEL`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ENV`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ARG`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`VOLUME`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`USER`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WORKDIR`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find a complete list of commands on the official Docker documentation
    website: [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/).'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through the preceding list to understand which command does what and
    when it’s best to use it.
  prefs: []
  type: TYPE_NORMAL
- en: FROM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A Dockerfile starts with a `FROM` command, which specifies the base image to
    start with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also name this build using `as` keyword followed by a custom name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '`docker build` will try to download Docker images from the public Docker Hub
    registry, but it’s also possible to use other registries out there, or a private
    one.'
  prefs: []
  type: TYPE_NORMAL
- en: COPY and ADD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `COPY` command is used to copy files or directories from the host machine
    to the container file system. Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: You can also use the `ADD` command to add files or directories to your Docker
    image. `ADD` has additional functionality beyond `COPY`. It can extract a TAR
    archive file automatically and check for the presence of a URL in the source field,
    and if it finds one, it will download the file from the URL. Finally, the `ADD`
    command has a `--chown` option to set the ownership of the files in the destination.
    In general, it is recommended to use `COPY` in most cases, and only use `ADD`
    when the additional functionality it provides is needed.
  prefs: []
  type: TYPE_NORMAL
- en: EXPOSE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `EXPOSE` command in a Dockerfile informs Docker that the container listens
    on the specified network ports at runtime. It does not actually publish the ports.
    It is used to provide information to the user about which ports are intended to
    be published by the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if a container runs a web server on port `80`, you would include
    the following line in your Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: You can specify whether the port listens on TCP or UDP – after specifying the
    port number, add a slash and a TCP or UDP keyword (for example, `EXPOSE 80/udp`).
    The default is TCP if you specify only a port number.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `EXPOSE` command does not publish the ports. To make ports available, you
    will need to publish them with the use of the `-p` or `--publish` option when
    running the `docker` `run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This will map port `8080` on the host machine to port `80` in the container
    so that any incoming traffic on port `8080` will be forwarded to the web server
    running in the container on port `80`.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of the `EXPOSE` command, you can publish different ports when running
    a container. `EXPOSE` is used to inform the user about which ports are intended
    to be published by the container.
  prefs: []
  type: TYPE_NORMAL
- en: ENTRYPOINT and CMD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next on our list is the `ENTRYPOINT` command, which in a Dockerfile specifies
    the command that should always be run when the container starts. It cannot be
    overridden by any command-line options passed to the `docker` `run` command.
  prefs: []
  type: TYPE_NORMAL
- en: The `ENTRYPOINT` command is used to configure the container as an executable.
    It is similar to the `CMD` command, but it is used to configure the container
    to run as an executable. It is typically used to specify the command that should
    be run when the container starts, such as a command-line tool or a script.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you have a container that runs a web server, you might use
    the `ENTRYPOINT` command to specify the command that starts the web server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to run a container with different arguments, you can use the `CMD`
    command to set default arguments that can be overridden when the container is
    started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '`CMD` is used to specify the command that should be run when a container is
    started from the image. Take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The rule of thumb here is that if you want your application to take custom arguments,
    you are free to use `ENTRYPOINT` to launch a process and `CMD` to pass arguments
    to it. This way, you can be flexible with what your process will do by passing
    different options via the command line.
  prefs: []
  type: TYPE_NORMAL
- en: RUN
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `RUN` command in a Dockerfile is used to execute commands inside the container.
    It creates a new layer in the image each time it is executed.
  prefs: []
  type: TYPE_NORMAL
- en: The `RUN` command is used to install software packages, create directories,
    set environment variables, and perform any other actions that are required to
    set up the environment inside the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, you can use the `RUN` command to install a package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `RUN` command to create a directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `RUN` command to set environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: It’s worth noting that the order of the `RUN` commands in the Dockerfile is
    important, as each command creates a new layer in the image, and the resulting
    image is the union of all the layers. So, if you’re expecting some packages to
    be installed later in the process, you need to do it before using them.
  prefs: []
  type: TYPE_NORMAL
- en: LABEL
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `LABEL` command is used to add metadata to the image. It basically adds
    the key-value pairs of data to the image. Those can be used to store information
    such as the image’s version, maintainer, and other relevant information you might
    need in your organization. The following is an example of the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also add multiple labels in one line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The labels added to the image can be viewed using the `docker` `inspect` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The use of `LABEL` commands to add metadata to the image can help users understand
    what the image’s purpose is or who they should ask about the details, and help
    to manage the images.
  prefs: []
  type: TYPE_NORMAL
- en: ENV and ARG
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `ENV` command is used to set environment variables in the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The `ARG` command, on the other hand, is used to define build-time variables.
    These variables can be passed to the `docker build` command using the `--build-arg`
    flag and their values can be used in the Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ARG` command is used to define build-time variables similar to the `ENV`
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The `ARG` command creates a variable that is only accessible during the build
    process, whereas the `ENV` command creates an environment variable that is accessible
    to all processes running inside the container.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll get into more detail about the build process of the
    Docker image, where `ARG` and `ENV` are used together to persist `ENV` variables
    across build stages.
  prefs: []
  type: TYPE_NORMAL
- en: VOLUME
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another command is `VOLUME`. With it, you can configure a container to create
    a mount point for a volume at a specific location. Volumes are a way to store
    data outside of the container’s filesystem, which means the data can persist even
    if the container is deleted or recreated. The following is the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following to specify multiple directories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, the following is also valid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: If there is any data in the directory marked as `volume`, when running a Docker
    using the `docker run` command, a new volume will be created with the content
    of this directory. That way, you can ensure that data created while this Docker
    container is running won’t be lost when the container gets killed or stopped otherwise.
    It’s especially important for databases, as we suggested in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: USER
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `USER` command in a Dockerfile is used to set the default user that the
    container runs as. By default, the container runs as the root user; it is recommended
    to run the container as a custom user without root capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `USER` command is used to set the user and optionally the group that the
    container runs as. For example, you can use the `USER` command to run the container
    as the `webserver` user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also specify the user and group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'It’s also possible to set the user ID and group ID instead of the name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The `USER` command only sets the default user for the container, but you can
    override it when running the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Running your application as a non-root user is a best practice for security
    reasons. It limits the potential damage that can be done if an attacker gains
    access to the container, as the process running with full permissions is also
    running with the same UID (here: `root`) on the host you are running the image.'
  prefs: []
  type: TYPE_NORMAL
- en: WORKDIR
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `WORKDIR` command in a Dockerfile is used to set the current working directory
    for the container. The working directory is the location in the container’s filesystem
    where all the subsequent `RUN`, `CMD`, `ENTRYPOINT`, `COPY`, and `ADD` commands
    will be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the `WORKDIR` command to set the working directory to `/usr/local/app`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: When using `WORKDIR`, you won’t need to set full paths for the files while using
    any other commands and you could parameterize your application location (with
    `ARG` or `ENV`).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve familiarized ourselves with Dockerfiles and how to build Docker
    images, it’s useful to know how to store this new image in some way. Docker image
    registries are used for that exact purpose. We will look into registries in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Docker image registries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **Docker image registry** hosts Docker images. Docker images are organized
    by tags that can be accessed and downloaded by users. These images can be used
    to create and run containers on a host machine. Image repositories can be hosted
    either locally or on a remote server, such as on Docker Hub, which is a public
    repository provided by Docker. You can also create your own private image repositories
    to share and distribute your images within your organization.
  prefs: []
  type: TYPE_NORMAL
- en: When you pull an image from a Docker image repository, the image is composed
    of multiple layers. Each layer represents an instruction in the Dockerfile that
    was used to build the image. These layers are stacked on top of each other to
    create the final image. Each layer is read-only and has a unique ID.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to UnionFS, the Docker registry shares common layers between multiple
    images and containers, reducing the amount of disk space required. When a container
    modifies a file, it creates a new layer on top of the base image, rather than
    modifying the files in the base image. This allows for easy rollback to previous
    states of the container and makes the images highly portable.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple image repositories you could use depending on a cloud solution
    you’re using (ECR for AWS or Google Container Registry for GCP, for instance)
    or SaaS solutions (Docker Hub is the most popular – [https://hub.docker.com](https://hub.docker.com)).
    There are also a number of open source licensed solutions available:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Harbor**: This is available at [https://goharbor.io/](https://goharbor.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Portus**: This is available at [http://port.us.org/](http://port.us.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Registry**: This is available at [https://docs.docker.com/registry/](https://docs.docker.com/registry/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project Quay**: This is available at [https://quay.io](https://quay.io) and
    on GitHub at [https://github.com/quay/quay](https://github.com/quay/quay%20)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we’ve familiarized ourselves with Docker registries to store
    our Docker images in a remote location. In the next section, we will look more
    into Docker networking and its extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Docker networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are four types of Docker networking: none, bridge, host, and overlay.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Bridge* is the default network mode in Docker. Containers in the same bridge
    network can communicate with each other. Shortly, it creates a virtual network,
    in which containers are assigned IP addresses and can cummunicate using them,
    while anything outside of that network cannot reach any of those addresses. In
    the *Host* network, the container uses the host’s network stack. This means that
    the container shares your machine’s IP address and network interfaces.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Overlay* mode allows you to create a virtual network that spans multiple Docker
    hosts. Containers in different hosts can communicate with each other as if they
    are on the same host. It’s useful when running Docker Swarm.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the Docker command line, you are able to create a custom network of any
    of those types.
  prefs: []
  type: TYPE_NORMAL
- en: None network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **none network** in Docker is a special type of network mode that disables
    all networking for a container. When a container is run in *none* network mode,
    it does not have access to any network resources and cannot communicate with other
    containers or the host machine.
  prefs: []
  type: TYPE_NORMAL
- en: To run a container in *none* network mode, you can use the `--network none`
    option when running the `docker` `run` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to start a container running the `nginx` image in *none* network
    mode, you would run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The *none* network is useful for running workloads that aren’t supposed to use
    any network connections, for example, for processing data in a connected volume.
  prefs: []
  type: TYPE_NORMAL
- en: Bridge mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using **bridge mode** on a container being created, a virtual interface
    is also created and attached to the virtual network. Each container is then assigned
    a unique IP address on the virtual network, allowing it to communicate with other
    containers and the host machine.
  prefs: []
  type: TYPE_NORMAL
- en: The host machine acts as a gateway for the containers, routing traffic between
    the containers and the outside network. When a container wants to communicate
    with another container or the host machine, it sends the packet to the virtual
    network interface. The virtual network interface then routes the packet to the
    correct destination.
  prefs: []
  type: TYPE_NORMAL
- en: By default, it’s a `172.17.0.0/16` network and it’s connected to a bridge device,
    `docker0`, in your machine. Within this network, all traffic between containers
    and the host machine is allowed.
  prefs: []
  type: TYPE_NORMAL
- en: All containers are attached to the default bridge network if no network was
    selected using the `--network` option when executing the `docker` `run` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can list all available networks using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'To get more information about the network, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Let’s move on to HOST mode.
  prefs: []
  type: TYPE_NORMAL
- en: Host mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In **host networking mode**, the container shares the host’s network stack and
    network interfaces. This means that the container uses your machine’s IP address
    and network settings, and can directly access the same network resources as the
    machine it runs on, including other containers.
  prefs: []
  type: TYPE_NORMAL
- en: Containers running in host networking mode can also directly listen on a port
    of the host machine (bind to it).
  prefs: []
  type: TYPE_NORMAL
- en: One of the main advantages of host networking mode is that it provides better
    performance as the container doesn’t have to go through an additional network
    stack.
  prefs: []
  type: TYPE_NORMAL
- en: This mode is less secure than the other networking mode as the container has
    direct access to the host’s network resources and can listen to connections on
    the host’s interface.
  prefs: []
  type: TYPE_NORMAL
- en: Overlay
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An **overlay network** is created by a manager node, which is responsible for
    maintaining the network configuration and managing the membership of worker nodes.
    The manager node creates a virtual network switch and assigns IP addresses to
    each container on the network.
  prefs: []
  type: TYPE_NORMAL
- en: Each worker node runs Docker Engine and a container network driver, which is
    responsible for connecting the containers on that host to the virtual network
    switch. The container network driver also ensures that packets are properly encapsulated
    and routed to the correct destination.
  prefs: []
  type: TYPE_NORMAL
- en: When a container on one host wants to communicate with a container on another
    host, it sends the packet to the virtual network switch. The switch then routes
    the packet to the correct host, where the container network driver decapsulates
    the packet and delivers it to the destination container.
  prefs: []
  type: TYPE_NORMAL
- en: The overlay network uses the **Virtual eXtensible Local Area Network** (**VXLAN**)
    protocol to encapsulate IP packets and make it possible to create a Layer 2 network
    between multiple hosts.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have introduced one of the major building blocks of modern
    DevOps-led infrastructure, that is, containers. We described the most prominent
    container technology – Docker. We have also introduced the basics of running Docker
    containers and building your own. In the next chapter, we are going to build on
    this knowledge and introduce more advanced Docker topics.
  prefs: []
  type: TYPE_NORMAL
