<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer033">
			<h1 id="_idParaDest-57" class="chapter-number"><a id="_idTextAnchor061"/>3</h1>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor062"/>Understanding GitLab Components</h1>
			<p>GitLab is a huge, complicated web app that aims to be a “one-stop shop” for making every step of the software development life cycle easier: it helps you to plan, create, test, secure, and deploy software. And those are just the big tasks it covers! It also helps you track progress using a variety of workflows, document projects, create release notes, store Docker images or other types of software packages, host static web pages, monitor the performance of deployed applications, and watch for suspicious network traffic within Kubernetes clusters. This list could be much longer, but you get the picture: <em class="italic">GitLab helps with most of the tasks involved in the standard software development </em><span class="No-Break"><em class="italic">life cycle.</em></span></p>
			<p>In <a href="B18073_01.xhtml#_idTextAnchor013"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, we articulated key problems in the software development life cycle that GitLab was designed to solve. Now, we’ll introduce you to the key GitLab concepts and components that you’ll need to be familiar with in order to use it effectively. Once you understand these building blocks, you’ll be ready to start the work of setting up CI/CD pipelines, which we will begin to address in <a href="B18073_04.xhtml#_idTextAnchor084"><span class="No-Break"><em class="italic">Chapter 4</em></span></a><span class="No-Break">.</span></p>
			<p>In this chapter, we’ll discuss projects, groups, issues, branches, and merge requests. We’ll then bring those GitLab components to life by showing you how to create, manage, and use some of those concepts in the application’s GUI. When you’re comfortable with these fundamentals, you’ll learn how to use <strong class="bold">GitLab flow</strong>, which is a best practice workflow recommended by GitLab’s developers for effectively combining the tool’s various building blocks as you write, test, secure, and <span class="No-Break">deploy software.</span></p>
			<p>This is how the main topics appear in the chapter: </p>
			<ul>
				<li>Emphasizing the “why” over <span class="No-Break">the “how”</span></li>
				<li>Introducing the <span class="No-Break">GitLab platform</span></li>
				<li>Organizing work into projects <span class="No-Break">and groups</span></li>
				<li>Tracking work <span class="No-Break">with issues</span></li>
				<li>Editing files safely with commits, branches, and <span class="No-Break">merge requests</span></li>
				<li>Enabling DevOps practices with <span class="No-Break">GitLab flow</span></li>
			</ul>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor063"/>Technical requirements</h1>
			<p>You’ll benefit most from this chapter if you’re able to follow along by logging into an account on a GitLab instance. This account can be an account on the instance hosted at gitlab.com (also known as a <strong class="bold">Software-as-a-Service</strong> (<strong class="bold">SaaS</strong>) instance), or an account on an instance hosted by your company (known as a self-managed, a self-hosted, or an on-premises instance). You could even host GitLab on your own hardware at home or on a virtual machine in the cloud, using a service such as AWS EC2, Google Cloud Platform, or Microsoft Azure. </p>
			<p>Hosting your own instance is not as far-fetched as it sounds, thanks to surprisingly low hardware requirements—you can even host GitLab on a Raspberry Pi!—and a variety of “Omnibus” Linux packages that contain everything you need for an entire GitLab instance. We’ll refer you to the GitLab installation documentation at <a href="https://about.gitlab.com/install">https://about.gitlab.com/install</a> for more information if you want to go down <span class="No-Break">this path.</span></p>
			<p>If you’d prefer to let someone else take care of installation, administration, and upgrade tasks for you, head over to <a href="https://gitlab.com">https://gitlab.com</a> and sign up for a free account on their SaaS platform. Although there are minor feature differences between the SaaS and self-managed varieties of GitLab, they are so small that we won’t discuss them in this book. For all intents and purposes, the feature sets of SaaS GitLab and self-managed GitLab <span class="No-Break">are identical.</span></p>
			<p>As of early 2023, GitLab has three <strong class="bold">product tiers</strong>: Free, Premium, and Ultimate. The first of these tiers is open source and free for everyone to use. It also has the most limited feature set. The Premium tier requires a paid license but adds some extra features. The Ultimate tier costs more than Premium but unlocks the entire GitLab feature set. These tiers apply to both SaaS and <span class="No-Break">self-managed installations.</span></p>
			<p>This book will discuss some features that are available in the Free tier, some that are available only in the Premium and Ultimate tiers, and some that are only unlocked with an Ultimate license. If you are on a budget, don’t worry. GitLab has plenty of functionality to improve your life as a software developer, even with the lower tiers. Many people find the Free tier to be all they ever need, especially if they mainly use GitLab for personal <span class="No-Break">hobby projects.</span></p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor064"/>Emphasizing the “why” over the “how”</h1>
			<p>Before we get started, a word of warning. For the most part, this book will not lead you through step-by-step instructions on what to click in the GitLab GUI in order to perform <span class="No-Break">various operations.</span></p>
			<p>First, instructions for most operations are already well covered in GitLab’s official documentation, which is remarkably clear <span class="No-Break">and thorough.</span></p>
			<p>Second, because GitLab is in rapid development, its GUI often changes. These changes are rarely radical, workflow-breaking changes, but they are significant enough that screenshots, or even bullet-pointed instructions for how to perform operations, can quickly get stale. This means that any concrete instructions in this book could become confusing or impossible to follow, or potentially even lead to data loss, as the GitLab GUI drifts over time. To avoid that problem, we’ll mostly focus on <em class="italic">why</em> you might want to use different GitLab features. Although we’ll give you a general picture of <em class="italic">how</em> to use those features, we usually won’t provide detailed instructions for every configuration option <span class="No-Break">or workflow.</span></p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor065"/>Introducing the GitLab platform</h1>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor066"/>What is GitLab?</h2>
			<p>The company called GitLab makes a single product: a web application that is also called GitLab.Behind the scenes, the <a id="_idIndexMarker160"/>GitLab web application is a complicated collection of tools, databases, queues, and glue code holding it all together, but as far as the user is concerned, it’s just a single, web-based tool for <span class="No-Break">building software.</span></p>
			<p class="callout-heading">Different Meanings of “GitLab”</p>
			<p class="callout">Throughout this book, the term “GitLab” refers to the tool rather than the company, unless we explicitly <span class="No-Break">say otherwise.</span></p>
			<p>As we discussed in the first chapter, GitLab’s single-tool model is much easier to install, administer, and upgrade than any collection of separate, more focused tools. It requires only a single set of credentials per user. It offers a consistent GUI for all of its features. It integrates all the software development life cycle tools, allowing data to flow smoothly and without loss or distortion from one feature to the next. It provides a single location to learn about the status of your software as you plan, build, test, secure, and deploy it. To top it all off, it’s a lot<a id="_idIndexMarker161"/> cheaper than buying separate licenses for a collection of separate tools. And if you find that any of GitLab’s individual features don’t give you the flexibility or power that you need, you can almost always integrate other tools with GitLab to make it suit your technical needs and <span class="No-Break">preferred workflow.</span></p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor067"/>What problem does GitLab solve?</h2>
			<p>The purpose of GitLab—the <a id="_idIndexMarker162"/>problem it aims to solve—has shifted and broadened over the years. It was created in 2011 with a narrow focus: it wanted to make Git both easier to use and more powerful. In those days, it was not much more than a web-based GUI wrapper around Git and a centralized place to store projects’ golden <span class="No-Break">Git repositories.</span></p>
			<p>Since then, GitLab has widened its scope. It now aims not just at Git but at the entire software development <span class="No-Break">life cycle.</span></p>
			<p>To get a sense of how its mission has grown, you first need to understand Gitlab’s concept of “stages” in the software development life cycle. GitLab recognizes <span class="No-Break">10 stages:</span></p>
			<ul>
				<li><strong class="bold">Manage</strong>: Create audit<a id="_idIndexMarker163"/> and compliance reports, and restrict access <span class="No-Break">to resources.</span></li>
				<li><strong class="bold">Plan</strong>: Divide work into workable chunks that you can prioritize, weight, and assign to <span class="No-Break">team members.</span></li>
				<li><strong class="bold">Create</strong>: Commit, review, and approve file edits, whether they contain code, configuration information, or <span class="No-Break">other assets.</span></li>
				<li><strong class="bold">Verify</strong>: Run automated tests to make sure your software does what it’s <span class="No-Break">supposed to.</span></li>
				<li><strong class="bold">Package</strong>: Bundle your software into a <span class="No-Break">deployable format.</span></li>
				<li><strong class="bold">Secure</strong>: Find any security vulnerabilities in your software or <span class="No-Break">its dependencies.</span></li>
				<li><strong class="bold">Release</strong>: Deploy your software, optionally using sophisticated techniques such as feature flags and <span class="No-Break">canary deployments.</span></li>
				<li><strong class="bold">Configure</strong>: Set up the environments where your code will <span class="No-Break">be deployed.</span></li>
				<li><strong class="bold">Monitor</strong>: Report on performance metrics, incidents, <span class="No-Break">or errors.</span></li>
				<li><strong class="bold">Protect</strong>: Detect potential <a id="_idIndexMarker164"/>security problems in deployment environments such as <span class="No-Break">Kubernetes clusters.</span></li>
			</ul>
			<p>Note that there’s nothing magical about this division of the software development life cycle into stages. Another company might have divided it into 9 or 13 stages and might have drawn the <a id="_idIndexMarker165"/>boundaries between stages slightly differently. But GitLab’s division probably seems reasonable to anyone who has been involved in <span class="No-Break">software development.</span></p>
			<p>Let’s return to the question of what problem GitLab aims to solve. Since its humble beginnings as a solution to the difficulties of using Git (that is, early GitLab focused exclusively on the Create stage described previously), it now addresses problems faced by practitioners of all 10 of these software development life cycle stages. Because different stages present different problems, it’s hard to give a succinct description of the single problem GitLab is targeting. In fact, it’s probably impossible considering that GitLab now targets a myriad of problems from all 10 stages. The shortest, best answer we can give to the question of why GitLab exists is this: <em class="italic">it helps people write better software, more efficiently, and with </em><span class="No-Break"><em class="italic">less risk</em></span><span class="No-Break">.</span></p>
			<p>We’re the first to admit that GitLab is not yet equally effective at addressing the problems of all 10 stages. That is to say, some of the features that GitLab offers as solutions to various problems are more mature or more robust than others. As you might expect, the GitLab features that have been around the longest (such as the Git-related functionality) are generally the most mature, and more recently developed features (such as protecting your application from suspicious traffic within a Kubernetes cluster) are significantly more minimal. But GitLab is very transparent about its own assessment of the relative maturity of its solutions to the problems of the various stages, and which features it intends to focus on developing and improving in the near future. So, if you’re particularly curious about how full-featured GitLab’s solution to a particular software development life cycle problem is, a quick Google search for “GitLab maturity” will probably give you all the information you need to make an informed decision about whether GitLab offers enough power and flexibility to address the problems that trouble you <span class="No-Break">the most.</span></p>
			<p>At this point, you might be wondering how GitLab can compete with specialized tools that focus on just one of the software development life cycle stages. After all, can a single tool really replace a suite of 10 separate tools, each of which is considered “best in breed” for their <span class="No-Break">problem domain?</span></p>
			<p>First, you might find that you don’t need as many features or as much power as you initially think you do. One of the authors of this book once took a full-day training course on a Java performance<a id="_idIndexMarker166"/> profiling tool. He left the training with his head spinning from all the fantastic features the product offered and the detailed performance bottleneck reports that he would soon be able to present to his manager. But, it turned out his company only needed 2% of the power of that tool and could have gotten away with using a much simpler and cheaper alternative instead. The moral of this story? <em class="italic">GitLab might give you all the power you need, no matter which software development life cycle stage you’re </em><span class="No-Break"><em class="italic">concerned with</em></span><span class="No-Break">.</span></p>
			<p>Second, some of GitLab’s features are the result of integrating independently developed open source tools that truly are the best tools available for the problems they address. For example, many of GitLab’s security vulnerability scanners are highly regarded open source tools. It’s true that you could download and use these tools outside of GitLab, but GitLab makes it trivial to enable them in your workflow, and it integrates their output into existing GitLab dashboards in a familiar, easy-to-read format that’s consistent with all of GitLab’s <span class="No-Break">other reports.</span></p>
			<p>Finally, if you really do find that you need more than GitLab offers to solve a particular software development life cycle problem, you can almost always find a way to integrate outside tools into your GitLab workflow. Some of these integrations are explicitly supported by GitLab, and as a result, have virtually seamless results. Other integrations require more work on your part. But, virtually any tool that you can run from an operating system’s command line can be integrated into GitLab. Results may vary, but the number of tools that can’t talk to GitLab at all is <span class="No-Break">vanishingly small.</span></p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor068"/>The verify, secure, and release stages</h2>
			<p>Now that we’ve<a id="_idIndexMarker167"/> established that GitLab has ambitious goals for helping with all 10 stages of the software development life cycle, let’s scale things back a bit. This chapter focuses on the middle of the SDLC: the <strong class="bold">verify</strong>, <strong class="bold">secure</strong>, and <strong class="bold">release</strong> stages. These are<a id="_idIndexMarker168"/> among the most commonly used stages when writing software, and<a id="_idIndexMarker169"/> among the most problematic for all the reasons described in <a href="B18073_01.xhtml#_idTextAnchor013"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>. Fortunately, they are also the stages at which GitLab is most effective, and the feature it uses to solve the problems posed by those stages is, as you might guess, CI/CD pipelines. Now you know why so much of this book focuses on exactly <span class="No-Break">that topic!</span></p>
			<p>To understand how GitLab can help with the problems found in those three stages, you’ll need to know about a few concepts, terms, and GitLab components. Fortunately, everything you’re about to learn in the rest of this chapter will be relevant and useful to many of the other Gitlab stages as well. So, once you understand how to use these concepts, you’ll not only be able to move on to understanding GitLab CI/CD pipelines but you’ll also be better equipped to understand how GitLab tackles other SDLC stages that are not discussed in <span class="No-Break">this book.</span></p>
			<p>The rest of this chapter will focus on introducing those concepts, terms, and components. Let’s dive in, starting with a GitLab component called <span class="No-Break">a </span><span class="No-Break"><strong class="bold">project</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor069"/>Organizing work into projects and groups</h1>
			<p><strong class="bold">Projects</strong> are the fundamental <a id="_idIndexMarker170"/>building blocks of GitLab. A GitLab project represents a single software product that you are working on or a single non-software project that you are working on. Projects are <a id="_idIndexMarker171"/>where you store your files, and they are the starting point for navigating GitLab’s different features. In short, projects are where you spend most of your time as a <span class="No-Break">GitLab user.</span></p>
			<p>Here are some examples of typical projects, and who might <span class="No-Break">use them:</span></p>
			<ul>
				<li>A mobile phone app for finding a nearby car wash, used by development <span class="No-Break">team #1</span></li>
				<li>A desktop version of the same car wash app, used by development <span class="No-Break">team #2</span></li>
				<li>The documentation used by the technical <span class="No-Break">writing team</span></li>
				<li>An upcoming conference, used by the event <span class="No-Break">planning team</span></li>
				<li>Onboarding tasks for new employees, used by the <span class="No-Break">entire company</span></li>
			</ul>
			<p>As you can see, some of these examples are software-related, but others have nothing to do with software. You can use projects to plan, manage, and track the progress of any kind of work. Although it’s true that most GitLab projects are focused on developing software, your company might find many non-technical uses for projects <span class="No-Break">as well.</span></p>
			<p>There’s no hard-and-fast rule for how to chop up your work into projects. For example, one company might decide to put all its documentation in a separate, documentation-specific project as described in the previous example. Another company might include the documentation files <a id="_idIndexMarker172"/>for each software product within the projects created for those products. Use whatever structure works best for you. Often, this requires some trial-and-error experimentation, so don’t be afraid to rejigger your use <span class="No-Break">of projects.</span></p>
			<p>It’s easiest to understand what a project is by seeing a picture of one. It won’t surprise you to know that GitLab is developed using GitLab tools. Here’s the project for the open source portion <span class="No-Break">of GitLab:</span></p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/Figure_3.01_B18073.jpg" alt="Figure 3.1 – The project for GitLab’s open source code " width="1372" height="842"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – The project for GitLab’s open source code </p>
			<p>As you can see, the list of files takes up the largest part of a project’s screen. What might not be obvious from the screenshot is that those files are actually a Git repository. </p>
			<p>You can think of a GitLab project as being a “wrapper” around a Git repository. Furthermore, you can consider the repository that lives in GitLab to be the “golden” copy of the repository, as discussed in <a href="B18073_02.xhtml#_idTextAnchor035"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>. Because a project contains a Git repository, the project also gives you access to all the other things that a Git repository normally contains, including Git commits, Git tags, and Git branches. We’ll talk about how to view these components later in <span class="No-Break">this chapter.</span></p>
			<p>Sometimes, you’ll find <a id="_idIndexMarker173"/>that you have a collection of projects that all hang together in some way. Here are some <span class="No-Break">typical examples:</span></p>
			<ul>
				<li>Projects that all belong to the <span class="No-Break">same team</span></li>
				<li>Projects for macOS and Windows versions of the <span class="No-Break">same software</span></li>
				<li>Projects that are all related to <span class="No-Break">database management</span></li>
			</ul>
			<p>When this happens, you<a id="_idIndexMarker174"/> can use a <strong class="bold">GitLab group</strong> to gather those related projects so they all exist in a single place within GitLab. You can think of GitLab groups as being similar to directories or folders that hold collections <span class="No-Break">of projects.</span></p>
			<p>GitLab groups aren’t limited to holding GitLab projects: they can also hold other GitLab groups. You can have up to 20 levels of these subgroups within a GitLab group. You’re encouraged to use these subgroups in any way you want to organize your projects into <span class="No-Break">related collections.</span></p>
			<p>Here’s a sample structure of groups, subgroups, and projects that might help you understand the relationship between the three concepts. Imagine that there’s a company called Acme Anvils, whose IT team oversees developing software for selling its anvils. It also makes separate software that’s used for internal purposes such as inventory management. Their group hierarchy might look <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/Figure_3.02_B18073.jpg" alt="Figure 3.2 – A sample group and project hierarchy" width="779" height="432"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – A sample group and project hierarchy</p>
			<p>Groups are more than just a way to collect related projects. You can also use them to establish roles and<a id="_idIndexMarker175"/> permissions. Using groups, you can do the following: </p>
			<ul>
				<li>Invite other GitLab users to be members of <span class="No-Break">a group.</span></li>
				<li>Assign them a role within <span class="No-Break">that group.</span></li>
				<li>Grant a user, group, or role permission to view or edit any projects within <span class="No-Break">that group.</span></li>
			</ul>
			<p>Thus, groups provide a simple<a id="_idIndexMarker176"/> way to regulate access control to several users at once. </p>
			<p>A group will also roll up components from all the projects within that group. For example, you can go to a single screen to see all the issues in all of the projects within <span class="No-Break">a group.</span></p>
			<p>But, groups don’t have to be complicated, and you don’t have to use all of their features. They’re a great way to simply collect related projects into a single place. </p>
			<p>Enough theory about projects, groups, and subgroups. Now, it’s time to see those concepts <span class="No-Break">in action.</span></p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor070"/>Example – organizing your Hats for Cats work </h2>
			<p>Cast your mind all the way back to <a href="B18073_01.xhtml#_idTextAnchor013"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, where we introduced your idea for a Hats for Cats web store. It’s time to get serious about setting up GitLab to help you develop <span class="No-Break">that software.</span></p>
			<p>Let’s say that you<a id="_idIndexMarker177"/> decide that Hats for Cats needs to exist in three different forms: a web app, an iOS app, and an Android app. You decide that although some of the logic will be similar between these three products, there are enough implementation differences so that each deserves its own project. </p>
			<p>(Reminder: this chapter won’t tell you how to create, edit, or view projects or groups. As discussed at the start of this chapter, the official GitLab documentation is your best source of information for step-by-step instructions for working with any GitLab components or using the GUI. This chapter—and in fact the entire book—focuses on the <em class="italic">why</em> rather than <span class="No-Break">the </span><span class="No-Break"><em class="italic">how</em></span><span class="No-Break">.)</span></p>
			<p>Because iOS and Android are both mobile platforms, you decide that it makes sense to collect those under a single group dedicated to mobile development. Then, you decide to collect that group, together with the web app project, under an umbrella group that comprises your entire Hats for Cats concept. Finally, you decide it makes sense to provide online documentation that is entirely platform-agnostic: it should apply equally to the iOS, Android, and web versions of the app. Because it isn’t tied to any of the existing projects, you want to create a new project just to hold <span class="No-Break">the documentation.</span></p>
			<p>To realize this structure in GitLab, it’s often easiest to work from the top down, starting with groups and finishing with projects. You start by logging in to GitLab and creating the top-level <strong class="bold">Hats for Cats</strong> group, using all the default settings. (If you’d like to follow along, please take a look at the official GitLab documentation for explicit instructions on how to do this.) When that’s done, GitLab takes you to the home page for that group. Now you decide to create a subgroup called <strong class="bold">Mobile</strong> within the <strong class="bold">Hats for </strong><span class="No-Break"><strong class="bold">Cats</strong></span><span class="No-Break"> group.</span></p>
			<p>Now, it’s time to create the projects. (Again, GitLab documentation can explain the exact process for doing this, but fortunately, it’s very simple.) Imagine that you do the following in order to begin working on Hats <span class="No-Break">for Cats:</span></p>
			<ol>
				<li>Make a project called <strong class="bold">Documentation</strong> inside the <strong class="bold">Hats for Cats</strong> group. </li>
				<li>Make a project called <strong class="bold">Web</strong> inside the <strong class="bold">Hats for </strong><span class="No-Break"><strong class="bold">Cats</strong></span><span class="No-Break"> group.</span></li>
				<li>Make a project called <strong class="bold">iOS</strong> inside the <span class="No-Break"><strong class="bold">Mobile</strong></span><span class="No-Break"> subgroup.</span></li>
				<li>Make a project called <strong class="bold">Android</strong> inside the <span class="No-Break"><strong class="bold">Mobile</strong></span><span class="No-Break"> subgroup.</span></li>
			</ol>
			<p>When you’re done, you<a id="_idIndexMarker178"/> end up with a group and project structure that looks <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/Figure_3.03_B18073.jpg" alt="Figure 3.3 – Hats for Cats group and project hierarchy" width="643" height="328"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Hats for Cats group and project hierarchy</p>
			<p>Let’s do a quick review before <span class="No-Break">moving on:</span></p>
			<ul>
				<li>A project gives you a Git repository in which you can store <span class="No-Break">your code.</span></li>
				<li>A project is also the central place from which you’ll do most of your work <span class="No-Break">in GitLab.</span></li>
				<li>Several related projects can be collected within <span class="No-Break">a group.</span></li>
				<li>Groups can hold projects, other groups, or both. </li>
				<li>By organizing your projects within groups and possibly subgroups, you can keep them well organized and easy to find, but you also gain the ability to assign permissions to other team members at the group level and have those permissions apply to all projects within <span class="No-Break">the group.</span></li>
			</ul>
			<p>Time to move on to the<a id="_idIndexMarker179"/> next fundamental building block of <span class="No-Break">GitLab: </span><span class="No-Break"><strong class="bold">issues</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor071"/>Tracking work with issues</h1>
			<p>If a GitLab project is where a single product or initiative lives, a GitLab <strong class="bold">issue</strong> is where a single chunk of work<a id="_idIndexMarker180"/> lives. If you’ve used tools other than GitLab for planning and tracking work, you might have run across terms such as “story” or “ticket” to describe components that are similar to <span class="No-Break">GitLab issues.</span></p>
			<p>Issues live within GitLab projects, with each issue only belonging to one project (although they can be moved between projects). In addition to being linked to projects, issues are also linked to a huge number of other GitLab components, as you’ll see when we introduce you to those components. In fact, these linkages are a big part of what gives GitLab its power to reach across all 10 stages of <span class="No-Break">the SDLC.</span></p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor072"/>The structure of a GitLab issue</h2>
			<p>GitLab issues consist of <a id="_idIndexMarker181"/>several parts, of which these four are the most important: </p>
			<ul>
				<li><span class="No-Break">A </span><span class="No-Break"><strong class="bold">title</strong></span></li>
				<li><span class="No-Break">A </span><span class="No-Break"><strong class="bold">description</strong></span></li>
				<li>Several optional <span class="No-Break"><strong class="bold">metadata</strong></span><span class="No-Break"> fields</span></li>
				<li>A threaded <strong class="bold">discussion</strong>, where team members can comment on <span class="No-Break">the issue</span></li>
			</ul>
			<p>Let’s look at each of these issue components in <span class="No-Break">more detail.</span></p>
			<p>The title is a short description of what the issue is about. For example, <strong class="source-inline">Add a FAQ page</strong>, <strong class="source-inline">Fix bug #12</strong>, or <strong class="source-inline">Improve page load performance by 20%</strong> are all reasonable issue titles. You don’t need to provide all the details about a feature in its title; that’s what the <strong class="bold">description</strong> field <span class="No-Break">is for.</span></p>
			<p>The <strong class="bold">Description</strong> field can contain as little or as much text as you want. It can contain screenshots or links, and it makes full use of Markdown’s formatting features. It can also be edited later as more information comes to light or the exact direction of the <span class="No-Break">issue changes.</span></p>
			<p>Issues have several <a id="_idIndexMarker182"/>metadata fields. We won’t go over all of them, but here are some of the most <span class="No-Break">important ones:</span></p>
			<ul>
				<li><strong class="bold">Assignee</strong>: This field identifies the person or persons who own the issue, in the sense that they’re responsible<a id="_idIndexMarker183"/> for pushing it forward and serving as a point of contact if people have questions or comments about the issue that they don’t want to add to the issue’s <span class="No-Break">discussion section.</span></li>
				<li><strong class="bold">Due date</strong>: There are <a id="_idIndexMarker184"/>several ways to use due dates in GitLab, but the most straightforward is to assign a due date directly to <span class="No-Break">an issue.</span></li>
				<li><strong class="bold">Labels</strong>: We’ll discuss these in<a id="_idIndexMarker185"/> more detail later, but they serve to prioritize, route, or report on the progress of an issue, among <span class="No-Break">other uses.</span></li>
				<li><strong class="bold">Weight</strong>: This field <a id="_idIndexMarker186"/>describes how much work you expect the issue to require. If you’re familiar with the Scrum method of project management, you’ve used the similar concept of “story points.” When assigning a weight to an issue, you can either use a concrete metric ( for example, person-hours) or a more abstract metric (for example, tiny tasks get one point, medium tasks get two points, and large tasks get three points). Every team has their own philosophy about this, which they develop with time <span class="No-Break">and experience.</span></li>
			</ul>
			<p>In addition to these explicit metadata fields, there’s another important piece of metadata about the issue: whether it is open or closed. Every issue starts with a status of <strong class="bold">Open</strong>. When someone completes the work required by an issue, they will normally change its status <span class="No-Break">to </span><span class="No-Break"><strong class="bold">Closed</strong></span><span class="No-Break">.</span></p>
			<p>Finally, every issue has a discussion section that lets people participate in threaded discussions, as you’d find on Facebook or Instagram. Because it’s threaded, people can reply to individual messages, or they can add entirely new messages. Discussions can include emojis, links, <span class="No-Break">or images.</span></p>
			<p>Since a picture is worth a thousand words, here’s a sample issue from your Hats for <span class="No-Break">Cats project:</span></p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/Figure_3.04_B18073.jpg" alt="Figure 3.4 – Sample issue" width="1227" height="1124"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Sample issue</p>
			<p>Most projects contain many issues, with both <strong class="bold">Open</strong> and <strong class="bold">Closed</strong> statuses. GitLab makes it easy to see a list of all the issues in a project and to zoom in on any issues in the list to see the full <a id="_idIndexMarker187"/>details of that issue. You can also look at a list of issues from a group level instead of a project level. This view shows a list of all the issues that belong to any of the projects within that group. So, if you want to know how many issues are left to work on for both the iOS and Android versions of the Hats for Cats app, you can go up a level from the individual projects and look at a list of all the issues that have the <strong class="bold">Open</strong> status within the <span class="No-Break"><strong class="bold">Mobile</strong></span><span class="No-Break"> group.</span></p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor073"/>The kinds of tasks that issues can represent</h2>
			<p>You might think that issues <a id="_idIndexMarker188"/>are only used to capture work related to software development, but that’s just the tip of the issue iceberg. Let’s look at the broad range of tasks that you can describe and track with a <span class="No-Break">GitLab issue:</span></p>
			<ul>
				<li>Add <span class="No-Break">a feature.</span></li>
				<li>Fix <span class="No-Break">a bug.</span></li>
				<li>Write <span class="No-Break">automated tests.</span></li>
				<li>Set up <span class="No-Break">a database.</span></li>
				<li>Configure a tool for the whole team <span class="No-Break">to use.</span></li>
				<li>Research <span class="No-Break">technical options.</span></li>
				<li>Brainstorm solutions to <span class="No-Break">a problem.</span></li>
				<li>Plan <span class="No-Break">an event.</span></li>
				<li>Poll the team about preferences for <span class="No-Break">coding standards.</span></li>
				<li>Report and manage a <span class="No-Break">security incident.</span></li>
				<li>Propose an idea for a new product or a <span class="No-Break">new feature.</span></li>
				<li>Ask a question that anyone can provide an <span class="No-Break">opinion on.</span></li>
				<li>Request T-shirt designs for an upcoming <span class="No-Break">corporate outing.</span></li>
			</ul>
			<p>Of course, there are many more possible uses for issues than are included in this short list. As you can see, they can be used for technical or non-technical work, and they can be used by a single person or an entire company. </p>
			<p>To give one more possibly unexpected example, every new hire at GitLab is assigned an issue that includes <em class="italic">Welcome to the company</em> text and a long list of onboarding tasks for them to complete and check off. The employee’s manager and the company’s human resources department monitor this issue during the employee’s first few weeks to see how they are progressing through the onboarding process. Later, after onboarding is complete and the issue has been closed, the employee can use the issue as a reference source for company policies <span class="No-Break">and procedures.</span></p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor074"/>Labels</h2>
			<p>Before explaining how you might realistically use issues, we need to introduce you to <strong class="bold">labels</strong>. These are colored tags<a id="_idIndexMarker189"/> containing a short bit of text. You can apply labels to issues or other GitLab components, such as merge requests (which we’ll discuss later), and remove them when they are no longer useful. You can define whatever labels you need for your project or group, and you can always add more labels or delete existing labels. Then, you can apply one or more labels to an issue to “mark” that issue with the contents of <span class="No-Break">the label.</span></p>
			<p>Here are some examples of commonly <span class="No-Break">created labels:</span></p>
			<ul>
				<li><strong class="bold">High Priority</strong>: Indicates an issue that needs to be worked <span class="No-Break">on immediately</span></li>
				<li><strong class="bold">QA</strong>: Indicates an issue that is the responsibility of the quality <span class="No-Break">assurance team</span></li>
				<li><strong class="bold">Status::Healthy</strong>: Indicates an issue that is progressing according to <span class="No-Break">the schedule</span></li>
				<li><strong class="bold">Status::At Risk</strong>: Indicates an issue that has fallen behind and needs extra resources to be assigned <span class="No-Break">to it</span></li>
			</ul>
			<p>Notice that the last two labels have double colons inside their descriptive text. The double colons have a special meaning: they <a id="_idIndexMarker190"/>turn these labels into <strong class="bold">scoped labels</strong>, which means they are mutually exclusive. That is, an issue can have the <strong class="bold">Status::Healthy</strong> label or the <strong class="bold">Status::At Risk</strong> label applied to it, but not both. Non-scoped labels—labels that don’t contain a double colon—can be applied in any combination to any issue. For example, you could apply both the <strong class="bold">Front-end</strong> and <strong class="bold">DB</strong> labels to an issue that needs work from both your frontend developer and your <span class="No-Break">database administrator.</span></p>
			<p>GitLab uses hundreds of issues to prioritize, route, assign responsibility, and track work as it develops the GitLab product itself, so don’t be afraid to make and apply whatever issues you need; they’re free to create and easy <span class="No-Break">to manage.</span></p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor075"/>Issue workflows</h2>
			<p>As with many GitLab components, there’s no single workflow for using issues that works well for every team in every <a id="_idIndexMarker191"/>situation. You’re encouraged to experiment and discover the best way to use issues for yourself considering your needs and team culture. But, we can present a <em class="italic">typical</em> workflow for issues, which you can use as a starting point when exploring possibilities for working with <span class="No-Break">GitLab issues.</span></p>
			<p>Here’s a sample workflow for one of your Hats for <span class="No-Break">Cats projects:</span></p>
			<ol>
				<li value="1"><em class="italic">Think up some work that needs to be done and figure out which project that work belongs to</em>. For example, as part of the Hats for Cats iOS project, you need to research the Objective-C and Swift programming languages to figure out which you should use for writing the <span class="No-Break">iOS app.</span></li>
				<li><em class="italic">Create an issue in that project and describe the work inside that issue</em>. You create an issue titled <strong class="source-inline">Research languages for iOS</strong> and add a description of the possible languages and your initial feelings about which might be the best <span class="No-Break">to choose.</span></li>
				<li><em class="italic">Add a weight to the issue</em>. You decide to use a metric of the total person-days expected and assign this issue a weight <span class="No-Break">of two.</span></li>
				<li><em class="italic">Set a due date for the issue</em>. You set the issue to be due in <span class="No-Break">3 days.</span></li>
				<li><em class="italic">Assign labels to prioritize and route the issue</em>. You assign the <strong class="bold">iOS</strong> and <strong class="bold">High Priority</strong> labels to the issue. The former ensures that the right people monitor it, and the latter indicates that work on the issue needs to <span class="No-Break">begin immediately.</span></li>
				<li><em class="italic">Discuss the issue</em>. People who are working on the Hats for Cats iOS app chime in with their past experiences with the different iOS languages. Other people ask clarifying questions. Someone adds links to outside blog posts that discuss Swift and Objective-C. You add a screenshot of a language comparison table from a <span class="No-Break">developer-focused website.</span></li>
				<li><em class="italic">Assign the issue</em>. In the discussion, you ask your most experienced developer whether they’re willing to tackle this task. When they agree, you assign the issue to them so that everyone knows that they’re responsible for working on this issue and updating <span class="No-Break">its progress.</span></li>
				<li><em class="italic">Update labels</em>. As work progresses, the person to whom you assigned the issue updates its labels. For example, they might remove the <strong class="bold">High Priority</strong> label once it’s underway, and add a <strong class="bold">Status::At Risk</strong> scoped label when they realize that they’re unlikely to complete the research by the issue’s <span class="No-Break">due date.</span></li>
				<li><em class="italic">Close the issue when it is complete</em>. The developer to whom the issue was assigned completes<a id="_idIndexMarker192"/> their research and posts their findings in the issue’s discussion section. Then they close it, signifying that no more work remains to be done on <span class="No-Break">the issue.</span></li>
			</ol>
			<p>This wraps up your introduction to GitLab issues. You’ve seen what kinds of work you can describe in an issue, what data goes into an issue, and what workflow you might use when working on an issue. It’s hard to be an effective GitLab user without creating and using lots of issues, so it’s a great idea to practice creating, viewing, and editing issues as you get comfortable <span class="No-Break">with GitLab.</span></p>
			<h1 id="_idParaDest-72"><a id="_idTextAnchor076"/>Editing files safely with commits, branches, and merge requests</h1>
			<p>In the last chapter, you learned about using branches and commits in Git, where a branch is a series of commits, and a commit is a snapshot that consists of edits to one or more files. Because GitLab is in some senses a wrapper around a Git repository (although of course, it’s much more<a id="_idIndexMarker193"/> than that), branches and commits are also an important part of using GitLab. There’s a third, related concept that you’ll use frequently in GitLab: the <strong class="bold">merge request</strong> (often referred to as an <strong class="bold">MR</strong>). In this section, we’ll explain what an MR is and show you how to work with all three components <span class="No-Break">in GitLab.</span></p>
			<p>GitLab often gives you more than one way to do something, and that’s true of working with commits and branches. You can either type commands into a terminal or use the GitLab GUI to perform most of the operations you’re likely to need for these two components. Because MRs are a concept that’s specific to GitLab and not Git, you’ll see that MRs require you to use the <span class="No-Break">GitLab GUI.</span></p>
			<p>Before you can commit edits to a branch, you need to create the branch. Thinking back to the last chapter, you’ll remember that you can make a branch with the <strong class="source-inline">git branch &lt;BRANCH-NAME&gt;</strong> command followed by some form of the <strong class="source-inline">git push</strong> command to copy your branch up to the golden copy of your project’s repository. Alternatively, you can work primarily in the GUI by creating a new branch right inside GitLab and then copying that branch to your local copy of the repository (assuming you have a local copy) with a combination of <strong class="source-inline">git fetch</strong> and some form of <strong class="source-inline">git pull</strong>. Because the exact command depends on your situation, you should consult your favorite dedicated Git reference material for <span class="No-Break">full information.</span></p>
			<p>Although normally we won’t lead you through explicit instructions for using the GitLab GUI, creating branches, commits, and MRs is so fundamental to working effectively with GitLab that we’ll give you an overview of exactly how to work with these through the GUI. </p>
			<p>Let’s start by creating a branch. Because a <a id="_idIndexMarker194"/>branch is a part of a Git repository, and a GitLab project is nothing more than a GitLab repository with a ton of extra features, it makes sense to create a branch within a GitLab project. For example, imagine that you want to add an <strong class="source-inline">allow-password-change</strong> branch to the Hats for Cats Android app so your developers can add a feature that lets users manage their passwords. </p>
			<p>Here’s how to add <span class="No-Break">that branch:</span></p>
			<ol>
				<li value="1">Navigate<a id="_idIndexMarker195"/> through your group structure and open the <span class="No-Break"><strong class="bold">Android</strong></span><span class="No-Break"> project.</span></li>
				<li>In the navigation pane on the left-hand side of the page, click <strong class="bold">Repository</strong> &gt; <strong class="bold">Branches</strong>. This takes you to a list of branches that exist in the project’s repository. </li>
				<li>Click the <strong class="bold">New branch</strong> button, fill in the branch’s name, hit the <strong class="bold">Create branch</strong> button, and <span class="No-Break">you’re done:</span></li>
			</ol>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/Figure_3.05_B18073.jpg" alt="Figure 3.5 – List of branches within a project" width="1235" height="847"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – List of branches within a project</p>
			<p>After you’ve created a <a id="_idIndexMarker196"/>branch, you can commit edits to it. Once again, there are two ways to do this. You’ve already learned about the three-command sequence that you can use in a terminal: <strong class="source-inline">git add &lt;FILE-NAME&gt;</strong> followed by <strong class="source-inline">git commit --message "&lt;MESSAGE&gt;"</strong> followed by <strong class="source-inline">git push</strong>. But, if you’d rather work within GitLab, here’s what you need <span class="No-Break">to do:</span></p>
			<ol>
				<li value="1">Navigate to the project’s repository by clicking <strong class="bold">Repository</strong> &gt; <strong class="bold">Files</strong> in the left-hand <span class="No-Break">navigation pane.</span></li>
				<li>Make sure you’re working in the right branch by clicking the branch name dropdown near the top left of <span class="No-Break">the page:</span></li>
			</ol>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/Figure_3.06_B18073.jpg" alt="Figure 3.6 – Selecting a branch in a project" width="1232" height="784"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – Selecting a branch in a project</p>
			<ol>
				<li value="3">Within the repository’s list of files, click the name of the file you want to edit. This will<a id="_idIndexMarker197"/> display <span class="No-Break">its contents.</span></li>
				<li>Click <strong class="bold">Edit in Web IDE</strong> to open an in-browser editor, and make any changes needed to <span class="No-Break">the file.</span></li>
				<li>If you’d like to edit more files within this commit, click on the next file’s name in the file browser toward the left of the page and make any edits you want to <span class="No-Break">its contents.</span></li>
				<li>When you’re done making changes, click <strong class="bold">Commit…</strong> and enter a commit message. If you haven’t created a merge request for this branch yet, it’s usually a good idea to check the <strong class="bold">Start a new merge request</strong> checkbox. Click <strong class="bold">Commit</strong> and <span class="No-Break">you’re done.</span></li>
				<li>If you’ve cloned the repository to your local machine, you might want to use <strong class="source-inline">git checkout &lt;BRANCH-NAME&gt;</strong> followed by <strong class="source-inline">git pull</strong> to copy the commit you just made to your local repository, but you can often get away with doing this<a id="_idIndexMarker198"/> occasionally instead of after <span class="No-Break">every commit.</span></li>
			</ol>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/Figure_3.07_B18073.jpg" alt="Figure 3.7 – Commit your edits" width="1211" height="710"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.7 – Commit your edits</p>
			<p>Editing files and committing changes directly to your project’s repository without ever touching a terminal is<a id="_idIndexMarker199"/> one of the great joys of using GitLab, so it’s well worth practicing this feature until it becomes a part of your <span class="No-Break">normal workflow.</span></p>
			<p>Making branches doesn’t do you any good unless you can switch between them, so you can view or edit the contents of whichever branch you want. You’ve seen how to do this from the command line using <strong class="source-inline">git checkout &lt;BRANCH-NAME&gt;</strong> or <strong class="source-inline">git switch &lt;BRANCH-NAME&gt;</strong>. It’s just as easy to switch branches within the GUI: just find the branch dropdown that exists at the top left of many pages and switch to your preferred branch. It can be easy to forget which branch you’re on, so it’s good to get in the habit of quickly checking this dropdown from time to time to keep <span class="No-Break">yourself oriented.</span></p>
			<p class="callout-heading">Tip </p>
			<p class="callout">It probably goes without saying, but we’ll say it anyway: switching the branch using a terminal command only changes the branch that you’re on in your local repository and not the branch that you’re on in the golden copy of the repository hosted on GitLab. Similarly, changing the branch in the GitLab GUI only changes the branch that you’re on in the GitLab-hosted repository, not the branch that you’re on in your local repository. So, don’t switch in one location and assume that you’ve also switched on the other; the local and remote copies of your repository are completely independent when it comes to keeping track of which branch <span class="No-Break">you’re on.</span></p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor077"/>Commit history</h2>
			<p>One of the most<a id="_idIndexMarker200"/> common operations with a Git repository is to look at the history of the commits on a particular branch, as seen in <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.8</em>. As you learned in <a href="B18073_02.xhtml#_idTextAnchor035"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, running <strong class="source-inline">git log</strong> in a terminal will show you a reverse-chronological history of all commits made to whatever branch you’re on in the local repository, along with the <a id="_idIndexMarker201"/>author, timestamp, <strong class="bold">Secure Hash Algorithm</strong> (<strong class="bold">SHA</strong>), and commit message of each commit. You can do the same thing in the GitLab GUI by navigating to the main page of a project, selecting the branch you’re interested in from the branch dropdown, and clicking the <span class="No-Break"><strong class="bold">History</strong></span><span class="No-Break"> button:</span></p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/Figure_3.08_B18073.jpg" alt="Figure 3.8 – List of commits on a branch" width="1187" height="786"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.8 – List of commits on a branch</p>
			<p>The history is a list of commits on this branch, with the most recent at the top of the list. This list includes the same <a id="_idIndexMarker202"/>information about each commit as you would get from the <strong class="source-inline">git log</strong> command. A nice bonus of using a GUI such as this is that you can click on any commit within the list to see every edit made to every file in the commit, displayed in an easy-to-read side-by-side format (switchable to an inline format, if you find that easier to parse visually). Of course, you can get this same information within a terminal with the <strong class="source-inline">git diff</strong> command, but that output is not nearly as easy to read as the output shown in the <span class="No-Break">GitLab GUI.</span></p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor078"/>Merging one Git branch into another</h2>
			<p>Merging a branch<a id="_idIndexMarker203"/> into another branch is the first action that’s performed significantly differently in the GUI versus in a terminal. As you will remember, you can merge <strong class="source-inline">branch-a</strong> into <strong class="source-inline">main</strong> (to pick two sample branch names) from the command line using <strong class="source-inline">git checkout main</strong> followed by <strong class="source-inline">git merge branch-a</strong>. But, doing this same operation in the GitLab GUI requires an MR. This is one of the most important and often used parts of GitLab, so it’s a critical thing to understand and get practice with. It’s important to understand that a merge request is the <em class="italic">only</em> way to merge one <a id="_idIndexMarker204"/>branch into another from within the GitLab GUI. Here’s a sample merge request from one of your Hats for <span class="No-Break">Cats projects:</span></p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="image/Figure_3.09_B18073.jpg" alt="Figure 3.9 – Sample merge request" width="1288" height="1093"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.9 – Sample merge request</p>
			<h3>Merge requests</h3>
			<p>A merge request is exactly what it sounds like: a GitLab component that represents a request that somebody (maybe you, maybe somebody else) merge one branch into another in the<a id="_idIndexMarker205"/> golden copy of the repository on a GitLab instance. A merge request looks a lot like an issue. It contains many of the same fields, including a title, a description, an assignee, and a threaded discussion. </p>
			<p>But, merge requests add a few extra fields that don’t exist in issues. These include the <strong class="bold">source branch</strong> and <strong class="bold">target branch</strong> fields. The<a id="_idIndexMarker206"/> source branch is the branch that<a id="_idIndexMarker207"/> contains new commits that you have been working on, and the target branch is the branch that you want to add those new commits to. For example, if you wanted to merge <strong class="source-inline">branch-a</strong> into <strong class="source-inline">main</strong>, the source branch would be <strong class="source-inline">branch-a</strong> and the target branch would <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break">.</span></p>
			<p>Merge requests also display the Git commits that are on the source branch, and collect all the edits from each commit into a single screen within the MR. This lets you see exactly how merging the source into the target would affect the files of the <span class="No-Break">target branch.</span></p>
			<p>Another aspect of merge requests that separates them from issues is that they contain a special pane that displays the results of the automated tests and scans that the CI/CD pipeline has performed on the code in the branch. We’ll talk about this pane in more detail later, but you can think of it as a one-stop shop for showing the overall status of the code that you’re developing. Is it doing what it’s supposed to do? Does it have security vulnerabilities? Is it introducing dependencies that use unacceptable software licenses? In short, by looking at this pane, you can quickly see whether the work you’re doing on the branch is making the overall software product better or worse. This is a very handy feature, <span class="No-Break">for sure!</span></p>
			<p>Finally, merge requests contain a big, impossible-to-miss <strong class="bold">Merge</strong> button. The mission of a merge request is to merge one branch’s commits into another branch, so it would be useless if it didn’t give users a way to perform the merge. There are many reasons this button might be grayed-out and unclickable, thereby blocking the merge from happening. </p>
			<p>The following list is some examples of why a merge might be blocked. Note that most of these blocking behaviors are configurable, so you can decide which works best for <span class="No-Break">your team:</span></p>
			<ul>
				<li>The merge request title starts with <strong class="source-inline">Draft</strong>. This indicates that the branch associated with the merge request is still a work in progress, and the developer does not intend for it to be <span class="No-Break">merged yet.</span></li>
				<li>GitLab’s license <a id="_idIndexMarker208"/>scanner (more about this in a later chapter) detects that the merge request is introducing a dependency with a license that’s incompatible with the overall <span class="No-Break">project’s license.</span></li>
				<li>Automated tests fail for the most recent commit to the branch associated with the <span class="No-Break">merge request.</span></li>
				<li>One or more discussion threads in the merge request <span class="No-Break">are unresolved.</span></li>
				<li>The merge request hasn’t received enough approvals, or approvals from the right people, to satisfy the approval rules. We’ll describe this in more <span class="No-Break">detail next.</span></li>
			</ul>
			<h3>Reviewing and approving code in merge requests</h3>
			<p>Because merge <a id="_idIndexMarker209"/>requests have the power to alter the files in the target branch, and the target branch is almost always <strong class="source-inline">main</strong>, <strong class="source-inline">master</strong>, or whatever branch holds your stable, production-ready code, it’s critical that every MR is scrutinized by members of the development team. Fortunately, merge requests have several features to enable <span class="No-Break">code reviews:</span></p>
			<ul>
				<li>You can <strong class="bold">link comments directly to one or more lines in a file</strong>, so it’s obvious which lines of code you’re referring to when you make suggestions for improving them (or when you <span class="No-Break">praise them).</span></li>
				<li>You can <strong class="bold">propose alternative code</strong> right in the discussion section. These proposals even include a button that allows the original author to accept your suggestions with a single click on <span class="No-Break">the GUI.</span></li>
				<li>You can <strong class="bold">assign reviewers</strong> from your team. They will receive notifications via email saying that you’d like them to review the edits in your merge request. These reviewers are listed in a metadata field in the MR, so everyone on your team knows who has been asked to review <span class="No-Break">the files.</span></li>
				<li>Team members can <strong class="bold">approve your code</strong>. This is a separate concept from reviewing your code. Reviewing is usually a repeated process that consists of a review, followed by the original author making fixes in response to your review, followed by another review, followed by more fixes, and so on. An approval is a single, one-time “thumbs up” that means that the approver considers your edits to be ready <span class="No-Break">to merge.</span></li>
				<li>You can create <strong class="bold">rules for who must approve your MR</strong> before it can be merged. These<a id="_idIndexMarker210"/> rules can become quite complicated and can involve several groups of people. Here are three sample rules for who must approve a merge request in order for it to <span class="No-Break">be unblocked:</span><ul><li><strong class="bold">Rule 1</strong>: Either the tech lead or the architect for <span class="No-Break">your team</span></li><li><strong class="bold">Rule 2</strong>: Your development <span class="No-Break">team manager</span></li><li><strong class="bold">Rule 3</strong>: Any one of the three members of the quality assurance team, plus any one of two members from the security team, plus two of the <span class="No-Break">three architects</span></li></ul></li>
			</ul>
			<p>As you can see, MRs are critical to getting your edits reviewed, approved, and merged into the <span class="No-Break">right branch.</span></p>
			<h3>Creating a merge request before you commit code</h3>
			<p>There are several ways to<a id="_idIndexMarker211"/> create merge requests, including a few shortcuts that GitLab provides in possibly unexpected (but helpful) places. As we’ve done previously when describing other GitLab components, we’ll ask you to look at the official GitLab documentation for up-to-date instructions on how to use the GUI to create, view, and manage <span class="No-Break">merge requests.</span></p>
			<p>However, we should definitely give you some guidance on <em class="italic">when</em> to create merge requests. This might sound odd or counterintuitive, but <em class="italic">we recommend that you create a merge request for a branch immediately after creating the branch, before you’ve committed any code to </em><span class="No-Break"><em class="italic">the branch</em></span><span class="No-Break">.</span></p>
			<p>This advice probably sounds especially<a id="_idIndexMarker212"/> strange if you’ve used tools like GitHub before. GitHub’s merge requests (known as <strong class="bold">pull requests</strong>) are usually created <em class="italic">after</em> you’ve committed all the code you intend to put on a branch. After all, if the purpose of a merge request is to merge the source branch’s edits into the target branch, what’s the point of opening a merge<a id="_idIndexMarker213"/> request when there isn’t any code on the source branch <span class="No-Break">to merge?</span></p>
			<h3>Using a merge request as a dashboard for your code</h3>
			<p>There are two<a id="_idIndexMarker214"/> reasons why making MRs early in the workflow is such a widely accepted best practice among GitLab users. First, an MR serves as a “dashboard” that lets you know about the overall quality of the code you’re adding to the branch. The dashboard answers questions like <span class="No-Break">the following:</span></p>
			<ul>
				<li>Are automated tests passing? </li>
				<li>Does your code meet performance requirements? </li>
				<li>Has your code introduced any security vulnerabilities? </li>
				<li>If it adds any new third-party dependencies, do they use licenses that are compatible with your overall <span class="No-Break">project license?</span></li>
				<li>Does your code satisfy style and <span class="No-Break">quality requirements?</span></li>
				<li>If you distribute your app as a Docker image, are there any known security vulnerabilities in the base Docker image that your code is <span class="No-Break">packaged with?</span></li>
			</ul>
			<p>These results are all available for viewing in other parts of the GitLab GUI, but it’s convenient to see them all neatly presented within an MR. </p>
			<p>More importantly, when you view the results within the MR, you see a “delta” view of these results. In other words, the results in the MR will tell you how the test and scan results for the MR’s associated branch <em class="italic">differ</em> from the results of the same test and scans as run against your default branch. This is incredibly valuable because it lets you know whether the code that you are contributing to the branch is headed in the right direction. To put it simply, <em class="italic">are your commits to the branch making your software better or worse?</em> </p>
			<p>Of course, if you wait to create a merge request until you’re all done coding, you won’t benefit from this constant guidance on whether you’re on the right track with your commits. This is, all by itself, a great reason to create an MR before you’ve committed any code to <span class="No-Break">your</span><span class="No-Break"><a id="_idIndexMarker215"/></span><span class="No-Break"> branch.</span></p>
			<h3>Merge requests improve collaboration</h3>
			<p>But, there’s another compelling reason to create your MR early in the development workflow: <em class="italic">merge requests encourage collaboration among team members</em>. By providing an area for threaded discussions, they let your coworkers review and comment on every<a id="_idIndexMarker216"/> commit you make. Are you introducing subtle bugs? Your coworkers can spot them and alert you when they’re still easy to fix. Are you starting to code an algorithm that’s not as fast as an alternative? Someone can let you know before you commit many hours and lines of code to build the wrong thing. Are you misusing certain idioms in your programming language? If a senior developer can point that out early in the process, you can adjust your style before committing any more code to the branch. </p>
			<p>These scenarios all share a common theme: by collaborating early and often, by reviewing small pieces of code that arrive in a single commit, problems become easier to spot and cheaper to fix. MRs are exactly the place where this kind of collaboration <span class="No-Break">can occur.</span></p>
			<p>Anyone who has been asked to review a completed feature that consists of 3,000 lines of code knows the sinking feeling of being unsure where even to begin. Or the despair you feel when you realize that the developer has misunderstood the specifications and not built the feature that the product owner intended. Or the awkwardness that comes from pointing out a programming or style error that the developer has made hundreds of times throughout the feature’s code. All these situations can be avoided by frequent reviews of small pieces of code. And, that’s only possible when you have a merge request ready to go before the first <span class="No-Break">commit lands.</span></p>
			<p>The frequent collaboration enabled by merge requests not only helps the folks who are reviewing the code but also helps the author of that code. In the same way that automated test failures are easier to troubleshoot and fix when the commit that caused the failures consists of small pieces of code, it’s also easier to fix style problems, suboptimal algorithms, or bugs when a code reviewer spots those problems in a 12-line piece of code than it is when they call out those problems in 3,000 lines of code that make up the completed feature or bug fix. It’s far better and easier to adjust your coding practices early in the development process than it is to have to go back and make potentially complicated or even destabilizing fixes after you thought you were <span class="No-Break">done coding.</span></p>
			<p>These principles apply to security vulnerabilities as well. A truism in software is that you must take security into account throughout the entire development workflow; you can’t just tack it on at the end. The frequent security scan results that show up in merge requests help make it possible to honor this principle by “baking in” security from the very beginning of the development workflow. Code reviews by experienced developers or members of <a id="_idIndexMarker217"/>your security team also help achieve this goal, and the MR discussion pane is exactly where that sort of code review takes place. This principle of “shifting left”—which we’ve discussed earlier in this book—is especially important when it comes to security. This is because security problems sometimes require extensive rethinking and reworking of basic architectural decisions in your software. This kind of repair is much easier, cheaper, and less disruptive when the code base is smaller and simpler, as it tends to be when work has just begun on a <span class="No-Break">new feature.</span></p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor079"/>The three amigos – issues, branches, and merge requests</h2>
			<p>You now know quite a bit about issues, branches, and merge requests. It’s important to understand that these three GitLab components are closely related when they’re used to plan and accomplish a programming task. </p>
			<p>GitLab recommends a particular workflow for these three components. They suggest that you first create an issue as soon as you’ve identified work to be done. As soon as that issue is assigned to a developer, the developer should immediately make a branch to work on, and then create a merge request for that branch. The issue, branch, and merge request should all have similar (or sometimes even identical) titles to show that they are related to each other. For example, if you saw these components, you’d know from their titles that they<a id="_idIndexMarker218"/> all address the <span class="No-Break">same task:</span></p>
			<ul>
				<li><strong class="bold">Issue</strong>: <strong class="source-inline">simplify the </strong><span class="No-Break"><strong class="source-inline">login process</strong></span></li>
				<li><span class="No-Break"><strong class="bold">Branch</strong></span><span class="No-Break"><a id="_idIndexMarker219"/></span><span class="No-Break">: </span><span class="No-Break"><strong class="source-inline">simplify-login-process</strong></span></li>
				<li><strong class="bold">Merge </strong><a id="_idIndexMarker220"/><strong class="bold">request</strong>: <strong class="source-inline">simplify the </strong><span class="No-Break"><strong class="source-inline">login process</strong></span></li>
			</ul>
			<p>Because issues, branches, and merge requests are so closely related, and because all three are usually required when <a id="_idIndexMarker221"/>completing any coding work with GitLab, you’ll sometimes <a id="_idIndexMarker222"/>see them referred to as the <strong class="bold">three amigos</strong>. If you’re not sure how to start work on a programming task, a good rule of thumb is to make sure you have the three amigos all lined up before you write <span class="No-Break">any code.</span></p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor080"/>When two amigos are enough</h2>
			<p>However, it’s also worth mentioning that you don’t <em class="italic">have</em> to have all three components for every task. If a task <a id="_idIndexMarker223"/>doesn’t require you to edit any files in your repository, there’s no need for a branch, which means there’s also no need for a merge request. You might remember that, earlier, we said that a possible use case for an issue would be to solicit T-shirt designs for an upcoming corporate event. Those T-shirt designs could all be added directly to the issue’s discussion section. You don’t need to edit any files to satisfy the requirements of that task, so you could get away with not making a branch, and not making an associated merge request. In fact, making a branch and merge request issue would probably be confusing to your coworkers because it suggests that you <em class="italic">do</em> expect files to be edited while completing <span class="No-Break">this work.</span></p>
			<p>Similarly, there are cases where you need a branch and merge request, but don’t need an issue. For example, imagine that you need to fix a tiny, trivial typo in your code. You <em class="italic">could</em> make an issue describing the problem, but that’s probably overkill for such a small edit. It seems more appropriate in this case to simply make a branch and merge request, then make a single commit that fixes the typo, and then ask for review and approval of the MR. Most GitLab users would probably agree that no issue is needed (although no harm would come from making one). Having said that, some organizations might decide that every MR requires a related issue, which is also a perfectly acceptable policy, even if it occasionally leads to some <span class="No-Break">extra work.</span></p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor081"/>How are issues and merge requests different?</h2>
			<p>You might find yourself <a id="_idIndexMarker224"/>wondering how issues and merge requests differ. We’ve already discussed the extra kinds of information that merge requests contain, but there’s a philosophical difference between the two components that’s helpful to keep<a id="_idIndexMarker225"/> in mind. Think of issues as being the place to present and discuss <strong class="bold">ideas</strong>. A merge request, on the other hand, is where you present and discuss <strong class="bold">code</strong>. If you use this concept to distinguish the two, that will help you understand when just one of them is needed versus when both are needed. It also helps you understand whether any comments you might have are better suited to the discussion section in the issue (if you’re talking about the general idea of the work) or the discussion section in the merge request (if you’re talking about the specific code delivered by <span class="No-Break">a developer).</span></p>
			<p>Another difference between issues and merge requests is the different status values they can have. Issues can be <strong class="bold">open</strong> or <strong class="bold">closed</strong>, whereas merge requests can be <strong class="bold">open</strong>, <strong class="bold">closed</strong>, or <strong class="bold">merged</strong>. In fact, closed merge requests are somewhat rare, as that status is only used when you abort a merge request instead of following through with the merge. That does happen sometimes, but the far more common outcome for a merge request is for it to transition to the <strong class="bold">merged</strong> status once its associated branch <span class="No-Break">is merged.</span></p>
			<p>Now, you’ve seen how to use the GitLab GUI to deal with fundamental concepts such as commits, branches, and <a id="_idIndexMarker226"/>merge requests. You’ve also been shown how issues and merge requests may look similar at first glance, but serve importantly different roles within GitLab. You understand <a id="_idIndexMarker227"/>why it’s important to create a merge request before you’ve committed any edits to merge, and how merge requests support close, frequent collaboration among team members. Finally, you know about the three amigos of issues, branches, and merge requests, and you understand how they work together to help you plan work, complete work, and merge any code changes that result from that work. In other words, you’ve been exposed to all of the fundamental building blocks of using GitLab to write software, even if you’re still in the dark about how GitLab verifies, secures, packages, and deploys the software once you’ve written it. But, we’ll get there soon, <span class="No-Break">we promise!</span></p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor082"/>Enabling DevOps practices with GitLab flow</h1>
			<p>Let’s end this chapter by seeing how issues, branches, and merge requests fit together in a realistic example. This <a id="_idIndexMarker228"/>shows GitLab’s recommended best practice for how to use all the components you’ve been introduced to in a smooth workflow that works for most situations. In fact, this workflow is so strongly<a id="_idIndexMarker229"/> recommended and so well proven over time that GitLab even has a name for this workflow: <strong class="bold">GitLab flow</strong>. As always, you’re encouraged to treat this workflow as a starting point when developing your own processes and procedures; feel free to tinker with it as needed for your team, product, and <span class="No-Break">organizational culture.</span></p>
			<p>While working on the Hats for Cats web app, you decide to add a feature that lets you filter the hats by cat breed. After all, a cowboy hat for a large-headed Maine Coon might swamp the dainty head of a Devon Rex. Here are all the steps prescribed by GitLab flow to bring that feature <span class="No-Break">into existence:</span></p>
			<ol>
				<li value="1">In the <strong class="bold">Web</strong> project under the <strong class="bold">Hats for Cats</strong> group, you make an issue titled <strong class="source-inline">Filter hats by breed</strong>, leaving all metadata <span class="No-Break">fields empty.</span></li>
				<li>In the issue’s discussion section, you mention two people who you think might have opinions on whether this feature is a <span class="No-Break">good idea.</span></li>
				<li>Both those people add replies to the discussion section. One just leaves a thumbs-up emoji. The other expresses support for the idea but asks whether the app should filter by other criteria <span class="No-Break">as well.</span></li>
				<li>You decide that filtering by other criteria is a good idea, but you’re not sure what those criteria should be. You make another issue titled <strong class="source-inline">Question: what criteria should we use when filtering hats?</strong> You set this issue aside to deal with later and return your focus to the <strong class="source-inline">Filter hats by breed</strong> issue because you’re confident that breed should be one of <span class="No-Break">the criteria.</span></li>
				<li>At a team-wide planning<a id="_idIndexMarker230"/> meeting, the group decides to <a id="_idIndexMarker231"/>assign the issue a weight of 8, which for your team means it’s expected to be a 1-week task. You assign the issue to a backend developer named Elizabeth, and you set its due date field to 2 weeks <span class="No-Break">from today.</span></li>
				<li>Elizabeth applies a <em class="italic">scoped</em> <strong class="bold">Status::In Progress</strong> label and an <em class="italic">unscoped</em> <strong class="bold">Back-end</strong> label to the issue. This will help the team keep track of whether the issue is on track and understand who is responsible <span class="No-Break">for it.</span></li>
				<li>Elizabeth makes a temporary branch called <strong class="source-inline">filter-hats-by-breed</strong> to hold <span class="No-Break">her commits.</span></li>
				<li>Elizabeth creates a merge request titled <strong class="source-inline">Draft: Filter hats by breed</strong>. She assigns teammates Alice and Bob to review the merge request. They have nothing to do yet since Elizabeth hasn’t added any code to the <span class="No-Break">MR’s branch.</span></li>
				<li>Now that Elizabeth has the three amigos of issue, branch, and merge request set up, she <span class="No-Break">starts coding.</span></li>
				<li>After she finishes a small, testable chunk of code, she commits it to <span class="No-Break">her branch.</span></li>
				<li>Elizabeth looks at the<a id="_idIndexMarker232"/> MR to see the results of the automated tests, code quality scans, license scans, and security scans that ran <a id="_idIndexMarker233"/>against her first commit. They don’t report any problems, so she celebrates with a mug of Assam tea with <span class="No-Break">extra sugar.</span></li>
				<li>Alice and Bob get email notifications that Elizabeth has committed code to the MR’s branch. They look at the MR and review her changes. Both add some comments about what parts of her code they like, and what parts can <span class="No-Break">be improved.</span></li>
				<li>Some of the suggestions seem wrong to Elizabeth, so she adds comments in the MR’s discussion section explaining her point of view. She continues to talk it out until they all reach an agreement about how she should proceed. Elizabeth adds a new commit with the agreed-upon fixes. </li>
				<li>Once again, Elizabeth looks in the MR to see the results of automated tests and scans against her last commit. One of the security scans points out a vulnerability that she unwittingly introduced. She quickly adds a new commit that fixes the vulnerability. The scans run again on this fixed code, and this time it’s <span class="No-Break">smooth sailing.</span></li>
				<li>Elizabeth gets a thumbs-up review from both Alice and Bob on all the code she’s committed so far, so her work is done. She removes the <strong class="bold">Back-end</strong> label, adds a <strong class="bold">Front-end</strong> label, and re-assigns the issue to a frontend engineer <span class="No-Break">named George.</span></li>
				<li>George writes some frontend code and adds a few commits to the same <strong class="source-inline">filter-by-breed</strong> branch that Elizabeth was using. Each commit triggers a new run of automated tests and scans, and each is reviewed by Alice <span class="No-Break">and Bob.</span></li>
				<li>George realizes that the work is falling behind schedule, so he adds an <strong class="bold">At Risk</strong> label to the original issue. The development manager responds to this by assigning another frontend developer named Helen to help George. </li>
				<li>The cycle of commit-then-review-then-inspect-automated-test-and-scan-results continues for a few more rounds until George and Helen complete the feature. They remove the <strong class="bold">At Risk</strong> label. Alice and Bob are satisfied with the code, and both add thumbs-up emojis to <span class="No-Break">the discussion.</span></li>
				<li>George removes <strong class="source-inline">Draft:</strong> from the title of the issue, indicating that he considers the code ready to <span class="No-Break">be merged.</span></li>
				<li>George mentions the security and QA teams in the MR’s discussion so they can approve it. Until they do, the <strong class="bold">Web</strong> project’s approval rules block the MR from <span class="No-Break">being merged.</span></li>
				<li>One member of the <a id="_idIndexMarker234"/>security team and two members<a id="_idIndexMarker235"/> of the QA team mark the MR as “approved.” This re-activates the MR’s merge button. With great glee and a feeling of accomplishment, George removes the <strong class="bold">Front-end</strong> and <strong class="bold">Status::In Progress</strong> labels and clicks the MR’s <span class="No-Break">merge button.</span></li>
				<li>The whole team goes out to a pub to celebrate and eats an uncomfortable quantity <span class="No-Break">of pizza.</span></li>
			</ol>
			<p>Here’s a diagram showing this flow, but with some steps removed <span class="No-Break">for clarity:</span></p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="image/Figure_3.10_B18073.jpg" alt="Figure 3.10 – Major steps in GitLab flow" width="680" height="218"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.10 – Major steps in GitLab flow</p>
			<h1 id="_idParaDest-79"><a id="_idTextAnchor083"/>Summary</h1>
			<p>You’ve been exposed to an awful lot of concepts and terminology in this chapter, so let’s do a <span class="No-Break">quick review.</span></p>
			<p>GitLab is a web application whose mission is to solve many of the problems faced by people involved with any of the 10 stages of the SDLC. So, GitLab doesn’t solve just one problem; it solves many problems that exist in many different facets of <span class="No-Break">software development.</span></p>
			<p>Working with GitLab happens mostly within a GitLab project, which represents one software product, one portion of your org chart, or one initiative. Projects that share a similar theme can be collected within GitLab groups, and groups can also <span class="No-Break">contain subgroups.</span></p>
			<p>Each individual task or chunk of work is recorded in a GitLab issue. Issues describe the work to be done, allow team members to participate in a discussion about the issue, and include many fields to store metadata about the issue. Issues usually represent software-related tasks, but can (and should) be used to describe, plan, and track non-technical work <span class="No-Break">as well.</span></p>
			<p>You can create <em class="italic">scoped</em> or <em class="italic">unscoped</em> labels to highlight issue statuses or health, or to indicate which person or team is responsible for doing work on the issue. You can assign labels to merge requests as well <span class="No-Break">as issues.</span></p>
			<p>A GitLab merge request is the component you use for merging one branch into another within the GitLab GUI. Each merge request lists a source branch and a target branch, and merging the merge request will cause any commits that were only on the source branch to be added to the target branch. Merge requests look similar to issues, but they serve different purposes: the former is used for describing, discussing, and merging code. The latter is used for describing and discussing ideas <span class="No-Break">and tasks.</span></p>
			<p>You can also use the GitLab GUI for performing many common Git-related tasks besides managing merge requests. For example, you can use the GUI to create a branch, add a commit, show a list of commits on a branch, or assign a tag to <span class="No-Break">a commit.</span></p>
			<p>GitLab flow is the best practice workflow for using all of the GitLab components in a proven, reliable way to build software. You’re not required to use GitLab flow, but it’s a great starting point for figuring out what workflow and policies work best for your organization <span class="No-Break">or team.</span></p>
			<p>So far, we’ve been dancing around a central part of GitLab flow: the <strong class="bold">CI/CD pipelines</strong> that run countless different checks on your code once you’ve committed it to a repository. In the next chapter, we’ll tackle it head-on, and get to the heart of what is possibly GitLab’s most powerful and most <span class="No-Break">helpful feature.</span></p>
		</div>
	</div>
</div>
</body></html>