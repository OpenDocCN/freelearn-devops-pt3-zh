- en: 'Chapter 1: Go Language Basics'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章：Go 语言基础
- en: '**DevOps** is a concept that has been floating around since the early 2000s.
    It is a popularization of an operations discipline that relies on programming
    skills with *development psychology* popularized by Agile.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**DevOps** 是一个自 2000 年代初以来就存在的概念。它是依赖于编程技能的运维学科的普及，结合了 *由敏捷开发推广的开发心理学*。'
- en: '**Site reliability engineering** (**SRE**) is now considered a subdiscipline
    of DevOps, though it is likely the precursor to DevOps and relies more heavily
    on software skills and **Service - Level Obligation** (**SLO**)/**Service - Level
    Agreement** (**SLA**) modeling.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**站点可靠性工程** (**SRE**) 现在被认为是 DevOps 的一个子学科，尽管它可能是 DevOps 的前身，并且更加依赖软件技能和 **服务级义务**
    (**SLO**)/**服务级协议** (**SLA**) 建模。'
- en: During my early time at Google, like many of today's DevOps shops, we used Python
    heavily. I think C++ was too painful for many SREs, and we had Python celebrities
    in *Guido van Rossum* and *Alex Martelli*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在我早期在 Google 的工作中，像今天许多 DevOps 团队一样，我们大量使用 Python。我认为 C++ 对许多 SRE 来说太痛苦了，而我们有
    Python 大腕 *Guido van Rossum* 和 *Alex Martelli*。
- en: But, as time wore on, many of the groups working in Python started having scaling
    issues. This included everything from Python running out of memory (requiring
    us to hack in our own `malloc`) to the **Global Interpreter Lock** (**GIL**) preventing
    us from true multithreading. At scale, we found that the lack of static types
    was giving us an abundance of errors that should have been caught at compile time.
    This mirrored what production services had seen years before.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 但随着时间的推移，许多使用 Python 的团队开始遇到扩展性问题。这些问题包括从 Python 内存耗尽（需要我们自己实现 `malloc`）到 **全局解释器锁**
    (**GIL**) 阻止我们真正的多线程处理。在大规模应用中，我们发现缺乏静态类型导致了大量本应在编译时捕获的错误。这与生产环境中的服务多年前遇到的问题相似。
- en: But, Python came with more than compile-time and service-scaling issues. Simply
    moving to a new version of Python in the fleet might cause a service to stop working.
    The Python version run on Google machines would often get upgraded and expose
    bugs in your code that the previous version did not. Unlike a compiled binary,
    you could not just roll back to an old version.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 但 Python 带来的问题不仅仅是编译时和服务扩展的问题。仅仅将 Python 版本升级到新版本，就可能导致服务停止工作。Google 机器上运行的
    Python 版本经常被升级，并暴露出旧版本中没有的代码 bug。与编译后的二进制文件不同，你不能仅仅回滚到旧版本。
- en: Several of us in different organizations were looking to solve these types of
    problems without having to use C++. For my personal journey, I heard about **Go**
    from my colleagues in our Sydney office (*Hey, Ross!*). It was the pre-1.0 days,
    but they said it was already showing a lot of promise. I can't say I was even
    remotely convinced that what we needed was another language.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们中有几位来自不同组织的人，正在寻找不必使用 C++ 的方法来解决这些问题。就我个人的经历来说，我从我们悉尼办公室的同事那里听说了 **Go**（*嘿，Ross!*）。那时
    Go 还在 1.0 之前，但他们说它已经显示出很多潜力。我不能说我当时完全相信我们需要的是另一种语言。
- en: About 6 months later, however, I had bought Go *hook, line, and sinker*. It
    had everything we needed without everything we didn't. Now, it was still pre-1.0
    days, so there was a certain amount of churn back then that was unpleasant (such
    as finding that Russ Cox had changed the `time` package over the weekend, so I
    had to rewrite a bunch of code). But, the benefits after writing my first service
    were undeniable.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，大约 6 个月后，我已经完全接受了 Go *一见钟情*。它拥有我们所需的一切，而没有我们不需要的东西。虽然那时还处于 1.0 之前的阶段，所以也有一些不太愉快的变化（比如发现
    Russ Cox 在周末更改了 `time` 包，所以我不得不重写一大堆代码）。但是，在我写完第一个服务后，其好处是不可否认的。
- en: I spent the next 4 years moving my department from a complete Python shop to
    almost a complete Go shop. I started teaching classes in Go across the world,
    targeted at operations engineers, rewriting core libraries for Go, and evangelizing
    to what was probably an annoying amount. Just because Go was invented at Google,
    it didn't mean that the engineers wanted to throw away their Python code and learn
    something new; there was more than a little resistance.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的 4 年里，我带领我的部门从完全使用 Python 转变为几乎完全使用 Go。我开始在全球范围内开设 Go 课程，面向运维工程师，重写 Go 的核心库，并做了相当多的推广。仅仅因为
    Go 是在 Google 发明的，并不意味着工程师们愿意抛弃他们的 Python 代码并学习新的东西；有很多反对的声音。
- en: Now, Go has become the *de facto* language for cloud orchestration and software
    in the larger world (from Kubernetes to Docker). Go comes with all the tools you
    need to make huge strides in the reliability of your tooling and ability to scale.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，Go 已经成为云编排和软件（从 Kubernetes 到 Docker）中的*事实标准*语言。Go 自带了所有你需要的工具，可以显著提高你工具的可靠性和可扩展性。
- en: Because many of these cloud services are written in Go, their parts are available
    to you by accessing their packages for your own tooling needs. This can make writing
    tooling for the cloud an easier experience.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 因为许多云服务都是用 Go 编写的，你可以通过访问它们的包来满足自己的工具需求。这可以使为云编写工具变得更加简单。
- en: For the next two chapters, I will be sharing my 10+ years' experience of teaching
    Go to engineers around the world to give you the basics and essentials of the
    Go language. Much of what you will read here is based on my free Go basics video
    training course, [https://www.golangbasics.com](https://www.golangbasics.com).
    This course will differ slightly from that one in that it is more condensed. As
    you work your way through the book, we will continue to extend your knowledge
    of the Go language's standard library and third-party packages.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两章中，我将分享我在全球工程师中教授 Go 语言的 10+ 年经验，为你介绍 Go 语言的基础和要点。大部分内容基于我免费的 Go 基础视频培训课程
    [https://www.golangbasics.com](https://www.golangbasics.com)。这本书稍有不同，更为精简。随着你阅读本书，我们将继续扩展你对
    Go 语言标准库和第三方包的了解。
- en: 'This chapter will cover the following main topics:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: Using the Go Playground
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Go Playground
- en: Utilizing Go packages
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用 Go 包
- en: Using Go's variable types
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Go 的变量类型
- en: Looping in Go
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Go 中进行循环
- en: Using conditionals
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用条件语句
- en: Learning about functions
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习函数
- en: Defining public and private
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义公共和私有
- en: Using arrays and slices
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数组和切片
- en: Getting to know about structs
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解结构体
- en: Understanding Go pointers
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Go 指针
- en: Comprehending Go interfaces
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Go 接口
- en: Now, let's get the basics down and get you on your way!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们把基础知识掌握好，让你上路！
- en: Technical requirements
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The only technical requirement for this chapter is a modern web browser for
    using the **Go Playground**.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 本章唯一的技术要求是使用**Go Playground**的现代 Web 浏览器。
- en: Using the Go Playground
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Go Playground
- en: The Go Playground, which you can find at [https://play.golang.org/](https://play.golang.org/),
    is an online code editor and compiler that allows you to run Go code without installing
    Go on your machine. This is the perfect tool for our introductory chapters, allowing
    you to save your work online without the initial fuss of installing the Go tooling,
    or finding a code editor, for example.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://play.golang.org/](https://play.golang.org/) 找到的 Go Playground
    是一个在线代码编辑器和编译器，允许你在没有在本地安装 Go 的情况下运行 Go 代码。这是我们介绍章节的完美工具，让你可以在线保存你的工作，避免了安装 Go
    工具和寻找代码编辑器的初期麻烦。
- en: 'There are four important parts of the Go Playground:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Go Playground 有四个重要部分：
- en: The code editing pane
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码编辑窗格
- en: The console window
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制台窗口
- en: The **Run** button
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行**按钮'
- en: The **Share** button
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分享**按钮'
- en: The code editing pane, which is the yellow portion of the page, allows you to
    type in the Go code for your program. When you hit the **Run** button, the code
    will be compiled and then run with the output sent to the console, which is the
    white portion of the page below the code editor.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 代码编辑窗格是页面上黄色部分，允许你输入你的程序的 Go 代码。当你点击**运行**按钮时，代码将被编译并在控制台输出白色部分显示。
- en: 'The following screen shows a glimpse of what the Go Playground does:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的屏幕截图展示了 Go Playground 的功能：
- en: '![Figure 1.1 – Go Playground code editor'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.1 – Go Playground 代码编辑器'
- en: '](img/B17626_01_001.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17626_01_001.jpg)'
- en: Figure 1.1 – Go Playground code editor
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – Go Playground 代码编辑器
- en: Clicking the `play.golang.org` into a shareable link, such as `play.golang.org/p/HmnNoBf0p1z`.
    This link is a unique URL that you can bookmark and share with others. The code
    in this link cannot be changed, but if you hit the **Share** button again, it
    will create a new link with any changes.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 `play.golang.org` 生成一个可共享的链接，比如 `play.golang.org/p/HmnNoBf0p1z`。这个链接是一个唯一的
    URL，你可以收藏并分享给其他人。该链接中的代码不能被修改，但如果再次点击**分享**按钮，将会生成一个带有任何修改的新链接。
- en: Later chapters, starting with [*Chapter 4*](B17626_04.xhtml#_idTextAnchor289),
    *Filesystem Interaction*, will require installing the Go tooling for your platform.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 后续章节，从 [*第四章*](B17626_04.xhtml#_idTextAnchor289)，*文件系统交互*，将需要为你的平台安装 Go 工具。
- en: This section taught you about the Go Playground and how to use it to write,
    view, share, and run your Go code. The Playground will be used extensively throughout
    the book to share runnable code examples.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 本节向你介绍了 Go Playground，以及如何使用它编写、查看、分享和运行你的 Go 代码。Playground 将在本书中广泛使用，用于分享可运行的代码示例。
- en: Now, let's jump into writing Go code, starting with how Go defines packages.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们开始编写 Go 代码，从 Go 如何定义包开始。
- en: Utilizing Go packages
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Go 包
- en: Go provides reusable blocks of code that can be imported into other code using
    packages. Packages in Go are synonymous with libraries or modules in other languages.
    Packages are the building blocks of Go programs that divide the content into understandable
    parts.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Go 提供了可以重复使用的代码块，可以通过包导入到其他代码中。Go 中的包等同于其他语言中的库或模块。包是 Go 程序的构建块，将内容划分为可理解的部分。
- en: This section will cover how to declare and import a package. We will discuss
    how to deal with package name conflicts, explore rules around packages, and we
    will write our first main package.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将讲解如何声明和导入包。我们将讨论如何处理包名冲突，探索包相关的规则，并将编写我们的第一个主包。
- en: Declaring a package
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明包
- en: Go divides programs into **packages**, sometimes called *modules* or *libraries*
    in other languages. Packages live on a path, and the path is made to look like
    a path to a directory on a Unix-like filesystem.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Go 将程序划分为 **包**，在其他语言中有时称为 *模块* 或 *库*。包位于一个路径上，这个路径看起来像 Unix 类文件系统中的目录路径。
- en: All Go files in a directory must belong to the same package. The package is
    most commonly named the same as the directory it lives in.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 目录中的所有 Go 文件必须属于同一个包。包通常被命名为它所在目录的名称。
- en: 'Declaring a package happens at the top of the file, and should only be preceded
    by a comment. Declaring a package is as simple as the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件的顶部声明包，并且只应当被注释所先行。声明包就像下面这样简单：
- en: '[PRE0]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`package main` is special. All other package names declare a package that must
    be imported into another package to be used. `package main` will declare `func
    main()`, which is the starting point for a binary to run.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`package main` 是特别的。其他所有包名声明的包必须导入到另一个包中才能使用。`package main` 将声明 `func main()`，这是二进制程序运行的起点。'
- en: All Go files in a directory must have the same package header (compiler-enforced).
    These files, for most practical purposes, act as if they are concatenated together.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 目录中的所有 Go 文件必须具有相同的包头（由编译器强制执行）。这些文件在大多数实际应用中，作用上好像它们是连接在一起的。
- en: 'Let''s say you have a directory structure as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有以下的目录结构：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, `file1.go` and `file2.go` should have the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`file1.go` 和 `file2.go` 应该具有以下内容：
- en: '[PRE2]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When `mypackage` is imported by another package, it will include everything
    declared in all files in the `mypackage` directory.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `mypackage` 被另一个包导入时，它将包含 `mypackage` 目录中所有文件中声明的内容。
- en: Importing a package
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入包
- en: 'There are two general types of packages:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 包大致分为两种类型：
- en: The **standard library** (**stdlib**) packages
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准库** (**stdlib**) 包'
- en: All other packages
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有其他包
- en: 'Standard library packages stand out because they don''t list some repository
    information in their path, such as the following:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 标准库包之所以显得特别，是因为它们的路径中不包含一些仓库信息，例如以下内容：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'All other packages generally have repository information preceding them, as
    follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他包通常会在路径前面列出仓库信息，如下所示：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'A complete listing of `stdlib` packages can be found at the following link:
    [https://golang.org/pkg/](https://golang.org/pkg/).'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 `stdlib` 包列表可以在以下链接找到：[https://golang.org/pkg/](https://golang.org/pkg/)。
- en: 'To import packages, we use the `import` keyword. So, let''s import the standard
    library `fmt` package and the `mypackage` package, which lives at `github.com/devopsforgo/mypackage`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入包，我们使用 `import` 关键字。那么，让我们导入标准库中的 `fmt` 包和位于 `github.com/devopsforgo/mypackage`
    的 `mypackage` 包：
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It is important to note that the filenames are not part of the package path,
    but simply the directory path.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，文件名不是包路径的一部分，只是目录路径的一部分。
- en: Using a package
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用包
- en: Once you've imported a package, you can start accessing functions, types, or
    variables declared in the package by prefacing what you want to access with the
    name of the package and a period.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你导入了一个包，你可以通过在你想要访问的内容前加上包名和一个点，开始访问该包中声明的函数、类型或变量。
- en: 'For example, the `fmt` package has a function called `Println()` that can be
    used to print a line to *stdout*. If we want to use it, it is as simple as the
    following:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`fmt` 包中有一个名为 `Println()` 的函数，可以用来打印一行到 *stdout*。如果我们想使用它，代码就像下面这样简单：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Package name conflicts
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包名冲突
- en: 'Let''s say you have two packages named `mypackage`. They both have the same
    name, so our program won''t be able to tell which one we are referring to. You
    can rename a package import into whatever name you want:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有两个名为 `mypackage` 的包。它们的名称相同，因此我们的程序无法判断我们在引用哪个包。你可以将包的导入重命名为任何你想要的名字：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`jpackage` declares that in this package, we will refer to `github.com/johnsiilver/mypackage`
    as `jpackage`.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`jpackage` 声明在这个包中，我们将 `github.com/johnsiilver/mypackage` 称为 `jpackage`。'
- en: 'This ability allows us to use two similarly named packages as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能使我们能够像下面这样使用两个同名的包：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now, we will look at an important rule around packages that improves compile-time
    and binary size.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来看一下与包相关的一个重要规则，这个规则能改善编译时间和二进制文件大小。
- en: Packages must be used
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 包必须被使用
- en: 'Let''s introduce you to the following rule: *If you import a package, you must
    use it*.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们向你介绍以下规则：*如果你导入了一个包，你必须使用它*。
- en: One of the things that the Go authors noticed about many of the other programming
    languages being used at Google was that they often had unused imports.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Go 的作者注意到，谷歌使用的许多其他编程语言常常有未使用的导入包。
- en: This was leading to compile times that were longer than needed and, in some
    cases, binary sizes that were much bigger than required. Python files were packaged
    in a proprietary format to ship around production, and some of these unused imports
    were adding hundreds of megabytes to the files.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致了编译时间比实际需要的更长，在某些情况下，二进制文件的大小比要求的要大得多。Python 文件会打包成专有格式以便在生产环境中传输，其中一些未使用的导入会增加几百兆字节的文件大小。
- en: 'To prevent these types of problems, Go will not compile a program that imports
    a package but doesn''t use it, as shown here:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这些问题，Go 不会编译导入了一个包但没有使用它的程序，如下所示：
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The preceding code outputs the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码输出如下内容：
- en: '[PRE10]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In certain rare circumstances, you may need to do a *side effects* import,
    in which just loading the package causes something to happen, but you don''t use
    the package. This should *always* be done in `package main` and requires prepending
    with an underscore (`_`):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些罕见情况下，你可能需要做一个 *副作用* 导入，即仅仅加载该包就会引发某些事情发生，但你并不直接使用该包。这应该 *总是* 在 `package
    main` 中完成，并且需要用下划线 (`_`) 前缀：
- en: '[PRE11]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Next, we will declare a main package and discuss the basics of writing a Go
    program that imports a package.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将声明一个主包并讨论编写 Go 程序的基本知识，程序将导入一个包。
- en: A Go Hello World
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个 Go 的 Hello World
- en: 'Let''s write a simple **hello world** program that is similar to the default
    program in the Go Playground. This example will demonstrate the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们写一个简单的 **Hello World** 程序，类似于 Go Playground 中的默认程序。这个示例将演示以下内容：
- en: Declaring a package
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个包
- en: Importing the `fmt` package from the standard library, which can print to our
    screen
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从标准库中导入 `fmt` 包，它可以将内容打印到我们的屏幕上
- en: Declaring the `main()` function of a program
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个程序的 `main()` 函数
- en: Declaring a string variable using the `:=` operator
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `:=` 运算符声明一个字符串变量
- en: Printing the variable to the screen
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印变量到屏幕
- en: 'Let''s see what this looks like:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这是什么样子的：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In our first line, we declared the name of our package using the `package` keyword.
    The entrance point for any Go binary is a package named `main` that has a function
    called `main()`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行中，我们使用 `package` 关键字声明了我们的包名。任何 Go 二进制文件的入口点都是一个名为 `main` 的包，其中有一个名为 `main()`
    的函数。
- en: In our third line, we import the `fmt` package. `fmt` has functions for doing
    string formatting and writing to various outputs.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三行，我们导入了 `fmt` 包。`fmt` 包含一些函数，用于做字符串格式化和写入各种输出。
- en: On our fifth line, we declare a function called `main` that takes no arguments
    and returns no values. `main()` is special, as when a binary is run, it starts
    by running the `main()` function.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在第五行，我们声明了一个名为 `main` 的函数，它不接收任何参数，也不返回任何值。`main()` 是特殊的，因为当二进制文件运行时，它会从运行 `main()`
    函数开始。
- en: Go uses `{}` to show where a function starts and where a function ends (similar
    to C).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Go 使用 `{}` 来标明函数的开始和结束位置（类似于 C 语言）。
- en: The sixth line declares a variable named `hello` using the `:=` operator. This
    operator indicates that we wish to create a new variable and assign it a value
    in a single line. This is the most common, but not the only, way to declare a
    variable.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第六行使用 `:=` 操作符声明了一个名为 `hello` 的变量。这个操作符表示我们希望在一行代码中创建一个新变量并为其赋值。这是最常见的声明变量的方式，但不是唯一的方式。
- en: As Go is typed, so `:=` will assign the type based on the value. In this case,
    it will be a string, but if the value was an `3`), it would be the `in`t type,
    and if a `2.4`), it would be the `float64` type. If we wanted to declare a specific
    type, such as `int8` or `float32`, we would need some modifications (which we
    will talk about later).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Go 是类型化的，`:=` 将根据值来推断变量的类型。在这种情况下，它将是一个字符串，但如果值是 `3`，则会是 `int` 类型，如果是 `2.4`，则会是
    `float64` 类型。如果我们想声明一个特定类型，比如 `int8` 或 `float32`，我们需要做一些修改（稍后我们会讨论）。
- en: On the seventh line, we call a function that is in the `fmt` package called
    `Println`. `Println()` will print the contents of the `hello` variable to `stdout`
    followed by a new line character (`\n`).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在第七行，我们调用了 `fmt` 包中的一个名为 `Println` 的函数。`Println()` 将打印 `hello` 变量的内容到 `stdout`，并附加一个换行符（`\n`）。
- en: You will notice that the way to use a function declared in another package is
    to use the *package name (without quotes)* + *a period* + *the name of the function*.
    In this case, `fmt.Println()`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，使用另一个包中声明的函数的方式是使用*包名（不带引号）* + *一个句点* + *函数名*。在这个例子中，就是 `fmt.Println()`。
- en: In this section, you have learned how to declare a package, import a package,
    what the function of the `main` package is, and how to write a basic Go program
    with a variable declaration. In the next section, we will go into some depth on
    declaring and using variables.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，你已经学会了如何声明一个包、导入一个包、`main` 包的功能是什么，以及如何编写一个基本的 Go 程序并声明变量。在下一部分，我们将深入探讨如何声明和使用变量。
- en: Using Go's variable types
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Go 的变量类型
- en: Modern programming languages are built with primitives called **types**. When
    you hear that a variable is a *string* or *integer*, you are talking about the
    variable's type.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现代编程语言是基于称为**类型**的原始数据类型构建的。当你听到某个变量是 *字符串* 或 *整数* 时，你是在谈论变量的类型。
- en: 'With today''s programming languages, there are two common type systems used:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在当今的编程语言中，有两种常见的类型系统：
- en: '**Dynamic types** (also called duck typing)'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态类型**（也称为鸭子类型）'
- en: '**Static types**'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态类型**'
- en: Go is a **statically typed** language. For many of you who might be coming from
    languages such as Python, Perl, and PHP, then those languages are **dynamically
    typed**.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Go 是一种**静态类型**语言。对于许多可能来自 Python、Perl 和 PHP 等语言的开发者来说，这些语言是**动态类型**语言。
- en: 'In a dynamically typed language, you can create a variable and store anything
    in it. In those languages, the type simply indicates what is stored in the variable.
    Here is an example in Python:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在动态类型语言中，你可以创建一个变量并存储任何内容。在这些语言中，类型仅表示存储在变量中的内容。这里是一个 Python 的示例：
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this case, `v` can store anything, and the type held by `v` is unknown without
    using some runtime checks (*runtime* meaning that it can't be checked at compile
    time).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`v` 可以存储任何内容，而 `v` 持有的类型在没有使用运行时检查的情况下是未知的（*运行时*意味着它无法在编译时检查）。
- en: 'In a statically typed language, the type of the variable is set when it is
    created. That type cannot change. In this type of language, the type is both what
    *is* stored in the variable and what *can* be stored in the variable. Here is
    a Go example:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态类型语言中，变量的类型在创建时就已确定，并且该类型不能更改。在这种语言中，类型既表示变量中*存储的内容*，也表示*可以存储的内容*。这里是 Go
    的示例：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `v` value cannot be set to any other type than a string.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`v` 的值不能被设置为除了字符串之外的其他类型。'
- en: It might seem like Python is superior because it can store anything in its variable.
    But in practice, this lack of being specific means that Python must wait until
    a program is running before it can find out there is a problem (what we call a
    **runtime error**). It is better to find the problem when the software is compiled
    than when it is deployed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 可能看起来 Python 更优，因为它可以在变量中存储任何内容。但实际上，这种不具特定性的缺点是，Python 必须等到程序运行时才能发现问题（我们称之为**运行时错误**）。与其在软件部署后才发现问题，最好在编译时就能找出问题。
- en: Let's take a look at a function to add two numbers together as an example.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个函数示例来加法运算两个数字。
- en: 'Here is the Python version:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Python 版本的示例：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here is the Go version:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Go 版本的示例：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the Python version, we can see that `a` and `b` will be added together. But,
    what types are `a` and `b`? What is the result type? What happens if I pass an
    integer and a float or an integer and a string?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Python 版本中，我们可以看到 `a` 和 `b` 会被加在一起。但是，`a` 和 `b` 是什么类型呢？结果类型是什么？如果我传递一个整数和一个浮点数，或者一个整数和一个字符串，会发生什么？
- en: In some cases, two types cannot be added together in Python, which will cause
    a runtime exception, and you can never be sure of what the result type will be.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，Python 中的两种类型不能相加，这将导致运行时异常，而且你永远无法确定结果类型会是什么。
- en: Note
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Python has added **type hints** to the language to help avoid these problems.
    But, practical experience has taught us with JavaScript/Dart/TypeScript/Closure
    that while it can help, optional type support means that a lot of problems fall
    through the cracks.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Python 已经为语言添加了 **类型提示**，以帮助避免这些问题。但实践经验告诉我们，像 JavaScript/Dart/TypeScript/Closure
    这样的语言，虽然类型支持有时能提供帮助，但可选的类型支持意味着许多问题会被忽视。
- en: Our Go version defines the exact types for our arguments and our result. You
    cannot pass an integer and a float or an integer and a string. You will only ever
    receive an integer as a return. This allows our compiler to find any errors with
    variable types when the program is compiled. In Python, this error could show
    up at any time, from the instant it ran to 6 months later when a certain code
    path was executed.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Go 版本为参数和结果定义了确切的类型。你不能传递整数和浮点数，或者整数和字符串。你只会收到整数作为返回值。这允许我们的编译器在程序编译时发现任何类型错误。在
    Python 中，这种错误可能会在任何时间出现，从程序运行的瞬间到 6 个月后，当某个代码路径被执行时才会发现。
- en: Note
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A few years ago, there was a study done on the *Rosetta Code* repository for
    some of the top languages in use to see how they fared in processing time, memory
    use, and runtime failures. For runtime failures, Go had the least failures, with
    Python towards the bottom of the ranking. Static typing would have certainly played
    into that.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 几年前，曾经进行过一项关于 *Rosetta Code* 仓库的研究，评估了几种主要编程语言在处理时间、内存使用和运行时故障方面的表现。在运行时故障方面，Go
    的故障最少，Python 排名靠后。静态类型系统显然在其中起了作用。
- en: 'The study can be found here: [https://arxiv.org/pdf/1409.0252.pdf](https://arxiv.org/pdf/1409.0252.pdf).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 该研究可以在此找到：[https://arxiv.org/pdf/1409.0252.pdf](https://arxiv.org/pdf/1409.0252.pdf)。
- en: Go's types
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Go 的类型
- en: Go has a rich type system that not only specifies that a type might be an integer
    but also the size of the integer. This allows a Go programmer to reduce the size
    of a variable both in memory and when encoding for network transport.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Go 拥有丰富的类型系统，不仅指定类型可能是整数，还指定了整数的大小。这使得 Go 程序员能够减少变量在内存中的大小，并在进行网络传输时进行编码。
- en: 'The following table shows the most common types used in Go:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了 Go 中最常用的类型：
- en: '![Table 1.1 – Common types used in Go and their descriptions'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 1.1 – Go 中常用类型及其描述'
- en: '](img/011.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/011.jpg)'
- en: Table 1.1 – Common types used in Go and their descriptions
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.1 – Go 中常用类型及其描述
- en: 'We will be keeping our discussion mostly to the preceding types; however, the
    following table is the full list of types that can be used:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将主要讨论上述类型；不过，以下表格列出了可以使用的类型的完整列表：
- en: '![Table 1.2 – Full list of types that you can use in Go'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 1.2 – Go 中可用类型的完整列表'
- en: '](img/02.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/02.jpg)'
- en: Table 1.2 – Full list of types that you can use in Go
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 表 1.2 – Go 中可用类型的完整列表
- en: Go doesn't just provide these types; you can also create new types based on
    these basic types. These custom types become their own type and can have methods
    attached to them.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Go 不仅提供这些基本类型；你还可以基于这些基本类型创建新的类型。这些自定义类型会成为自己的类型，并可以附加方法。
- en: Declaring a custom type is done with the `type` keyword and will be discussed
    during the section on the `struct` type. For now, we are going to move on to the
    basics of declaring variables.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 声明自定义类型使用 `type` 关键字，并将在讨论 `struct` 类型时讲解。目前，我们将继续讨论声明变量的基本知识。
- en: Now that we've talked about our variable types, let's have a look at how we
    can create them.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了变量类型，让我们看看如何创建它们。
- en: Declaring variables
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明变量
- en: As in most languages, declaring a variable allocates storage that will hold
    some type of data. In Go, that data is typed so that only that type can be stored
    in the allocated storage. As Go has multiple ways to declare a variable, the next
    parts will talk about the different ways this can be done.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数语言一样，声明变量会分配存储空间，用于存储某种类型的数据。在 Go 中，这些数据是有类型的，因此只能存储该类型的数据。由于 Go 提供了多种声明变量的方式，接下来的部分将讨论这些不同的声明方式。
- en: The long way to declare a variable
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 声明变量的长方式
- en: 'The most specific way to declare a variable is using the `var` keyword. You
    can use `var` to declare a variable both at the package level (meaning not inside
    a function) and within a function. Let''s look at some examples of ways to declare
    variables using `var`:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 声明变量最具体的方式是使用`var`关键字。你可以在包级（即不在函数内部）和函数内部使用`var`声明变量。让我们来看一些使用`var`声明变量的示例：
- en: '[PRE17]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This declares an `i` variable that can hold an `int64` type. No value is assigned,
    so the value is assigned the *zero value* of an integer, which is `0`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这声明了一个`i`变量，它可以保存`int64`类型的值。由于没有赋值，因此它被赋予了整数的*零值*，即`0`：
- en: '[PRE18]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This declares an `i` variable that can hold an `int` type. The value `3` is
    assigned to `i`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这声明了一个`i`变量，它可以保存`int`类型的值。值`3`被赋给了`i`。
- en: 'Note that the `int` and `int64` types are distinct. You cannot use an `int`
    type as an `int64` type, and vice versa. However, you can do type conversions
    to allow interchanging these types. This is discussed later:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`int`和`int64`类型是不同的。你不能将`int`类型作为`int64`类型使用，反之亦然。然而，你可以进行类型转换以允许这两种类型的互换。稍后会讨论这个话题：
- en: '[PRE19]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Using `()`, we group together a set of declarations. `i` can hold an `int` type
    and has the integer zero value, `0`. `word` doesn't declare the type, but it is
    inferred by the string value on the right side of the equal (`=`) operator.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`()`，我们将一组声明放在一起。`i`可以保存`int`类型，并且其整数零值是`0`。`word`没有声明类型，但它的类型由右侧等号（`=`）运算符中的字符串值推断出来。
- en: The shorter way
  id: totrans-161
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更简洁的方式
- en: In the previous example, we used the `var` keyword to create a variable and
    the `=` operator to assign values. If we do not have an `=` operator, the compiler
    assigns the *zero value* for the type (more on this later).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用`var`关键字来创建变量，并使用`=`运算符赋值。如果没有`=`运算符，编译器会为该类型分配*零值*（稍后会详细讲解）。
- en: 'The important concept is as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的概念如下：
- en: '`var` created the variable but did not make an assignment.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var`创建了变量，但没有赋值。'
- en: '`=` assigned a value to the variable.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`=`将一个值赋给变量。'
- en: 'Within a function (not at the package level), we can do a *create and assign*
    by using the `:=` operator. This both creates a new variable and assigns a value
    to it:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数内（而不是在包级别），我们可以通过使用`:=`运算符进行*创建并赋值*。这既创建了一个新变量，又赋值给它：
- en: '[PRE20]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The important thing to remember when using `:=` is that it means *create and
    assign*. If the variable already exists, you cannot use `:=`, but must use `=`,
    which just does an assignment.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`:=`时需要记住的重要一点是，它意味着*创建并赋值*。如果变量已经存在，不能使用`:=`，而必须使用`=`，它仅仅是进行赋值操作。
- en: Variable scopes and shadowing
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量作用域和变量遮蔽
- en: 'A **scope** is the part of the program in which a variable can be seen. In
    Go, we have the following variable scopes:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**作用域**是程序中变量可见的部分。在Go语言中，我们有以下几种变量作用域：'
- en: '**Package scoped**: Can be seen by the entire package and is declared outside
    a function'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包级作用域**：可以被整个包访问，在函数外部声明'
- en: '`{}` which defines the function'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '定义函数的`{}` '
- en: '`{}` of a statement in a function (`for` loop, `if`/`else`)'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数中的语句`{}`（如`for`循环、`if`/`else`）
- en: 'In the following program, the `word` variable is declared at the package level.
    It can be used by any function defined in the package:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的程序中，`word`变量在包级声明。它可以被包内定义的任何函数使用：
- en: '[PRE21]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the following program, the `word` variable is defined inside the `main()`
    function and can only be used inside `{}` which defines `main`. Outside, it is
    undefined:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的程序中，`word`变量在`main()`函数内定义，只能在定义`main`的`{}`内使用。它在外部是未定义的：
- en: '[PRE22]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, in this program, `i` is statement scoped. It can be used on the line
    starting our `for` loop and inside `{}` of the loop, but it doesn''t exist outside
    the loop:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在这个程序中，`i`是语句作用域的。它可以在启动`for`循环的那一行和循环中的`{}`内使用，但在循环外不存在：
- en: '[PRE23]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The best way to think of this is that if your variable is declared on a line
    that has `{`or within a set of `{}`, it can only be seen within those `{}`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的理解方式是，如果你的变量声明在包含`{`的那一行或位于一组`{}`内，那么它只能在这些`{}`内看到。
- en: Cannot redeclare a variable in the same scope
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不能在同一作用域中重新声明一个变量
- en: The rule for this, *You cannot declare two variables with the same name within
    the same scope*.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这一规则是，*在同一作用域内不能声明两个同名的变量*。
- en: 'This means that no two variables within the same scope can have the same name:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着在同一作用域内，两个变量不能有相同的名字：
- en: '[PRE24]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This program is invalid and will generate a compile error. Once you have declared
    the `word` variable, you cannot recreate it within the same scope. You can change
    the value to a new value, but you cannot create a second variable with the same
    name.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序是无效的，会生成编译错误。一旦声明了`word`变量，你不能在相同的作用域内重新创建它。你可以将其值更改为新的值，但不能创建第二个同名的变量。
- en: 'To assign `word` a new value, simply remove `var` from the line. `var` says
    *create variable where we want to only do an assignment*:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要给`word`赋新值，只需从这一行中去掉`var`。`var`表示*在我们只想做赋值的地方创建变量*：
- en: '[PRE25]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Next, we will look at what happens when you declare two variables with the same
    name in the same scope, but within separate code blocks.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看在相同作用域内，但在不同代码块中声明两个相同名称的变量时会发生什么。
- en: Variable shadowing
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量遮蔽
- en: '**Variable shadowing** occurs when a variable that is within your variable
    scope, but not in your local scope, is redeclared. This causes the local scope
    to lose access to the **outer scoped variable**:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**变量遮蔽**发生在一个变量在你的变量作用域内，但不在你的局部作用域内时被重新声明。这导致局部作用域无法访问**外部作用域的变量**：'
- en: '[PRE26]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, `word` is declared at the package level. But inside `main`,
    we define a new `word` variable, which overshadows the package level variable.
    When we refer to `word` now, we are using the one defined inside `main()`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`word`在包级别声明。但在`main`内部，我们定义了一个新的`word`变量，它遮蔽了包级别的变量。当我们现在引用`word`时，我们使用的是在`main()`中定义的那个。
- en: '`printOutter()` is called, but it doesn''t have a locally shadowed `word` variable
    (one declared between its `{}`), so it used the one at the package level.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 调用了`printOutter()`，但它没有一个局部遮蔽的`word`变量（即在其`{}`之间声明的变量），因此使用了包级别的`word`变量。
- en: 'Here''s the output of this program:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该程序的输出：
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is one of the more common bugs for Go developers.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Go开发者中比较常见的一个bug。
- en: Zero values
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 零值
- en: In some older languages, a variable declaration without an assignment has an
    unknown value. This is because the program creates a place in memory to store
    the value but doesn't put anything in it. So, the bits representing the value
    are set to whatever happened to be in that memory space before you created the
    variable.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些旧语言中，未赋值的变量声明具有未知的值。这是因为程序创建了一个内存位置来存储该值，但没有向其中放入任何东西。所以，表示该值的位被设置为在你创建变量之前，该内存空间中随机存在的内容。
- en: 'This has led to many unfortunate bugs. So, in Go, declaring a variable without
    an assignment automatically assigns a value called the *zero value*. Here is a
    list of the zero values for Go types:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经导致了许多不幸的bug。因此，在Go中，声明一个变量但不进行赋值时，会自动赋一个被称为*零值*的值。以下是Go类型的零值列表：
- en: '![Table 1.3 – Zero values for Go types'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![表1.3 – Go类型的零值'
- en: '](img/03.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/03.jpg)'
- en: Table 1.3 – Zero values for Go types
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.3 – Go类型的零值
- en: Now that we understand what zero values are, let's see how Go prevents unused
    variables in our code.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解了什么是零值，让我们来看一下Go如何在我们的代码中防止未使用的变量。
- en: Function/statement variable must be used
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数/语句变量必须被使用
- en: The rule here is that if you create a variable within a function or statement,
    it must be used. This is much for the same reason as package imports; declaring
    a variable that isn't used is almost always a mistake.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的规则是，如果你在函数或语句中创建一个变量，它必须被使用。这与包导入的原因差不多；声明一个没有使用的变量几乎总是一个错误。
- en: 'This can be relaxed in much the same way as an import, using `_`, but is far
    less common. This assigns the value stored in `someVar` to nothing:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这种写法可以像导入一样放宽，使用`_`，但这种情况远不如前者常见。这将`someVar`中存储的值赋给了一个什么也不使用的变量：
- en: '[PRE28]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This assigns the value returned by `someFunc()` to nothing:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这将`someFunc()`返回的值赋给了什么也不使用的东西：
- en: '[PRE29]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The most common use for this is when a function returns multiple values, but
    you only need one:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这种用法最常见的场景是当一个函数返回多个值，但你只需要其中一个：
- en: '[PRE30]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here, we create and assign to the `needed` variable, but the second value isn't
    something we use, so we drop it.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们创建并赋值给`needed`变量，但第二个值是我们不使用的，所以我们将其丢弃。
- en: This section has provided the knowledge of Go's basic types, the different ways
    to declare a variable, the rules around variable scopes and shadows, and Go's
    *zero values*.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 本节提供了Go的基本类型知识、不同的变量声明方式、变量作用域和遮蔽规则，以及Go的*零值*。
- en: Looping in Go
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Go中的循环
- en: 'Most languages have a few different types of loop statements: `for`, `while`,
    and `do while`.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数语言都有几种不同类型的循环语句：`for`、`while`和`do while`。
- en: Go differs in that there is a single loop type, `for`, that can implement the
    functionality of all the loop types in other languages.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: Go语言不同之处在于，只有一种循环类型，即`for`，它可以实现其他语言中所有类型的循环功能。
- en: In this section, we will discuss the `for` loop and its many uses.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将讨论`for`循环及其多种用法。
- en: C style
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C风格
- en: 'The most basic form of a loop is similar to C syntax:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 循环的最基本形式类似于C语言的语法：
- en: '[PRE31]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This declares an `i` variable that is an integer scoped to live only for this
    loop statement. `i := 0;` is the loop initialization statement; it only happens
    once before the loop starts. `i < 10;` is the conditional statement; it happens
    at the start of each loop and must evaluate to `true` or the loop ends.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这声明了一个`i`变量，它是一个整数，只在这个循环语句中有效。`i := 0;`是循环初始化语句；它只在循环开始前执行一次。`i < 10;`是条件语句；它在每次循环开始时执行，必须评估为`true`，否则循环结束。
- en: '`i++` is the `post` statement; it occurs at the end of every loop. `i++` says
    to increment the `i` variable by `1`. Go also has common statements, such as `i
    += 1` and `i--`.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`i++`是`post`语句；它会在每次循环结束时执行。`i++`表示将`i`变量增加`1`。Go语言也有常见的语句，如`i += 1`和`i--`。'
- en: Removing the init statement
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除`init`语句
- en: 'We don''t need to have an `init` statement, as shown in this example:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要`init`语句，如下面的例子所示：
- en: '[PRE32]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this, we declared `i` outside the loop. This means that `i` will be accessible
    outside the loop once the loop is finished, unlike our previous example.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在循环外部声明了`i`。这意味着`i`将在循环结束后仍然可以在外部访问，而不像我们之前的例子那样只能在循环内访问。
- en: Remove the post statement too and you have a while loop
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 也可以去掉`post`语句，这样就变成了一个`while`循环
- en: 'Many languages have a `while` loop that simply evaluates whether a statement
    is true or not. We can do the same by eliminating our `init` and `post` statements:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 许多语言有`while`循环，用来简单地判断某个语句是否为真。我们可以通过去掉`init`和`post`语句来实现相同的功能：
- en: '[PRE33]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: You might be asking, *how do we make a loop that runs forever?* The `for` loop
    has you covered.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，*我们如何创建一个永远运行的循环？* `for`循环可以解决这个问题。
- en: Creating an infinite loop
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个无限循环
- en: 'Sometimes you want a **loop** to run forever or until some internal condition
    inside the loop occurs. Creating an infinite loop is as simple as removing all
    statements:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你希望一个**循环**永远运行，或者直到循环内部的某些条件满足。创建一个无限循环只需去掉所有语句：
- en: '[PRE34]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is usually useful for things such as servers that need to process some
    incoming stream forever.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常对一些需要永远处理输入流的服务器很有用。
- en: Loop control
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环控制
- en: With loops, you occasionally need to control the execution of the loop from
    within the loop. This could be because you want to exit the loop or stop the execution
    of this iteration of the loop and start from the top.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 使用循环时，你有时需要从循环内部控制循环的执行。这可能是因为你想退出循环，或者停止当前迭代并从顶部重新开始。
- en: 'Here''s an example of a loop where we call a function called `doSomething()`
    that returns an error if the loop should end. What `doSomething()`does is not
    important for this example:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个循环的示例，我们调用一个名为`doSomething()`的函数，如果循环需要结束，`doSomething()`将返回一个错误。在这个例子中，`doSomething()`做什么并不重要：
- en: '[PRE35]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `break` function here will break out of the loop. `break` is also used to
    break out of other statements, such as `select` or `switch`, so it's important
    to know that `break` breaks out of the first statement it is nested inside of.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的`break`函数将会跳出循环。`break`也用于跳出其他语句，例如`select`或`switch`，所以重要的是要知道，`break`会跳出它所在的第一个语句。
- en: 'If we want to stop the loop on a condition and continue with the next loop,
    we can use the `continue` statement:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望在某个条件下停止循环并继续执行下一次循环，可以使用`continue`语句：
- en: '[PRE36]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This loop will print out the odd numbers from zero to nine. `i % 2` means *i
    modulus 2*. Modulus divides the first number by the second number and returns
    the remainder.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环将打印出从零到九的奇数。`i % 2`表示*i对2取模*。取模操作是将第一个数字除以第二个数字，并返回余数。
- en: Loop braces
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 循环的大括号
- en: 'Here is the introduction of this rule: A `for` loop’s open brace must be on
    the same line as the `for` keyword.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规则的介绍是：`for`循环的左大括号必须与`for`关键字位于同一行。
- en: 'With many languages, there are arguments about where to put the braces for
    loops/conditionals. With Go, the authors decided to pre-empt those arguments with
    compiler checks. In Go, you can do the following:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多编程语言中，关于循环/条件语句的大括号应该放在哪里一直存在争议。而在Go语言中，作者通过编译器检查来预防这些争论。在Go语言中，你可以这样做：
- en: '[PRE37]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'However, the following is incorrect as the opening brace of the `for` loop
    is on its own line:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，下面的写法是错误的，因为`for`循环的左大括号单独占一行：
- en: '[PRE38]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this section we learned to use `for` loops as C style loops, as `while` loops.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们学会了使用`for`循环作为C风格循环，也作为`while`循环使用。
- en: Using conditionals
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用条件语句
- en: 'Go supports two types of conditionals, as follows:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Go支持两种类型的条件语句，如下所示：
- en: '`if`/`else` blocks'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`if`/`else`块'
- en: '`switch` blocks'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`switch`块'
- en: The standard `if` statement is similar to other languages with the addition
    of an optional `init` statement borrowed from the standard C-style `for` loop
    syntax.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 标准的`if`语句与其他语言类似，额外增加了一个可选的`init`语句，它是从标准C风格的`for`循环语法中借用来的。
- en: '`switch` statements provide a sometimes-cleaner alternative to `if`. So, let''s
    jump into the `if` conditional.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句提供了一个有时更简洁的替代方案来替代`if`。所以，让我们来深入了解`if`条件语句。'
- en: if statements
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if语句
- en: '`if` statements start with a familiar format that is recognizable in most languages:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`语句以一个在大多数语言中都能识别的熟悉格式开始：'
- en: '[PRE39]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here''s a simple example:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子：
- en: '[PRE40]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The statements within `{}` in `if` will execute if `x` has a value greater than
    `2`.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`x`的值大于`2`，`if`中的`{}`内的语句将被执行。
- en: 'Unlike most languages, Go has the ability to execute a statement within the
    `if` scope before the evaluation is made:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数语言不同，Go有能力在进行条件判断之前，在`if`作用域内执行一条语句：
- en: '[PRE41]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Here is a simple example that is similar to the init statement in a `for` loop:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，类似于`for`循环中的初始化语句：
- en: '[PRE42]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, we initialize a variable called `err`. It has a scope of the `if` block.
    If the `err` variable does not equal the `nil` value (a special value that indicates
    certain types are not set – more on this later), it will print the error.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们初始化了一个名为`err`的变量。它的作用域是`if`块。如果`err`变量不等于`nil`值（一个特殊的值，表示某些类型未被设置——稍后会详细介绍），它将打印出错误。
- en: else
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: else
- en: 'If you need to execute something when the condition of an `if` statement is
    not met, you can use the `else` keyword:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在`if`语句的条件不满足时执行某些操作，可以使用`else`关键字：
- en: '[PRE43]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this example, if the `if` condition is true, `function1` will be executed.
    Otherwise, `function2` occurs.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，如果`if`条件为真，`function1`将被执行。否则，`function2`将被执行。
- en: It should be noted that most uses of `else` can generally be eliminated for
    cleaner code. If your `if` condition results in returning from a function using
    the `return` keyword, you can eliminate `else`.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 应该注意的是，大多数情况下，`else`的使用可以被省略，以获得更简洁的代码。如果你的`if`条件通过使用`return`关键字从函数返回，你可以省略`else`。
- en: 'An example is as follows:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个例子：
- en: '[PRE44]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This can be simplified to the following:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以简化为以下内容：
- en: '[PRE45]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Sometimes, you want to only execute code if the `if` condition is not met and
    another condition is. Let's look at that next.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你只希望在`if`条件不满足而另一个条件满足时才执行代码。我们接下来来看看这种情况。
- en: else if
  id: totrans-277
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: else if
- en: An `if` block can also contain `else if`, providing multiple levels of execution.
    The first `if` or `else if` that is matched in order is executed.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`if`块也可以包含`else if`，提供多层次的执行。第一个匹配的`if`或`else if`语句将被执行。
- en: Note that often Go developers choose the `switch` statement as a cleaner version
    of this type of conditional.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Go开发者通常选择使用`switch`语句作为这种类型条件语句的更简洁版本。
- en: 'An example is as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个例子：
- en: '[PRE46]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now that we have seen the basics of this conditional, we need to talk about
    brace style.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了这个条件语句的基础，接下来我们需要讨论一下大括号风格。
- en: if/else braces
  id: totrans-283
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: if/else的大括号
- en: 'It''s time to introduce this rule: Opening braces for `if`/`else` must be on
    the line with the associated keyword. If there is another statement in the chain,
    it must start on the same line as the previous close brace.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候介绍这个规则了：`if`/`else`的左大括号必须与相关的关键字在同一行。如果链中有其他语句，它必须与前一个右大括号在同一行开始。
- en: With many languages, there are arguments about where to put the braces for loops/conditionals.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多语言中，关于循环/条件语句的大括号放置位置有很多争论。
- en: 'With Go, the authors decided to pre-empt those arguments with compiler checks.
    In Go, you can''t do the following:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在Go语言中，作者决定通过编译器检查来预防这些问题。在Go中，你不能这样做：
- en: '[PRE47]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: So, with the arguments on bracing style in Go settled, let's look at an alternative
    to `if`/`else`, the `switch` statement.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，随着Go中关于大括号风格的争论已经解决，让我们来看看替代`if`/`else`的一个选项——`switch`语句。
- en: The switch statement
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: switch语句
- en: '`switch` statements are more elegant `if`/`else` blocks that are very flexible
    in their use. They can be used for doing exact matching and multiple true/false
    evaluations.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`语句比`if`/`else`块更优雅，它在使用上非常灵活。它可以用于精确匹配和多个真假评估。'
- en: Exact match switch
  id: totrans-291
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 精确匹配的switch
- en: 'The following is an exact match `switch`:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个精确匹配的`switch`：
- en: '[PRE48]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`[value]` is matched against each `case` statement. If it matches, the `case`
    statement executes. Unlike some languages, once a match occurs, no other case
    is considered. If no match occurs, the `default` statement executes. The `default`
    statement is optional.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`[value]`会与每个`case`语句进行匹配。如果匹配，`case`语句就会执行。与某些语言不同，一旦匹配成功，其他的`case`将不会再被考虑。如果没有匹配，`default`语句就会执行。`default`语句是可选的。'
- en: 'This has a nicer syntax than `if`/`else` for handling cases where your value
    can be several values:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这种语法比`if`/`else`更简洁，适合处理值可以是多个值的情况：
- en: '[PRE49]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'switch can also have an `init` statement, similar to `if`:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`switch`也可以有一个`init`语句，类似于`if`语句：'
- en: '[PRE50]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: True/false evaluation switch
  id: totrans-299
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 真/假评估开关
- en: 'We can also eliminate `[match]` so that each `case` statement isn''t an exact
    match, but a true/false evaluation (as with `if` statements):'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以省略`[match]`，这样每个`case`语句就不再是精确匹配，而是一个真/假评估（就像`if`语句一样）：
- en: '[PRE51]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: At the end of this section, you should be able to use Go's conditional statements
    to branch code execution in your program based on some criteria and handle cases
    where no statement was matched. As conditionals are one of the standard building
    blocks of software, we will use these in many of the remaining sections.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节结束时，你应该能够使用 Go 的条件语句根据某些标准在程序中分支代码执行，并处理没有匹配语句的情况。由于条件语句是软件的标准构建块之一，我们将在接下来的许多章节中使用它们。
- en: Learning about functions
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 学习函数
- en: '**Functions** in Go are what you''d expect from a modern programming language.
    There are only a few things that make Go functions different:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的**函数**符合现代编程语言的预期。使Go函数与众不同的只有少数几个特性：
- en: Multiple return values are supported
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持多个返回值
- en: Variadic arguments
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可变参数
- en: Named return values
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名返回值
- en: 'The basic function signature is as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 基本的函数签名如下：
- en: '[PRE52]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s make a basic function that adds two numbers together and returns the
    result:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个基本的函数，它将两个数字相加并返回结果：
- en: '[PRE53]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As you can see, this takes in two integers, `x` and `y`, adds them together,
    and returns the result (which is an integer). Let''s show how we can call this
    function and print its output:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个函数接收两个整数，`x`和`y`，将它们相加并返回结果（这是一个整数）。让我们展示如何调用这个函数并打印它的输出：
- en: '[PRE54]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We can simplify this function signature by declaring both `x` and `y` types
    with a single `int` keyword:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用单一的`int`关键字来简化函数签名，声明`x`和`y`的类型：
- en: '[PRE55]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This is equivalent to the previous one.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这与之前的内容是等效的。
- en: Returning multiple values and named results
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 返回多个值和命名结果
- en: 'In Go, we can **return multiple values**. For example, consider a function
    that divides two integers and returns two variables, the result and the remainder,
    as follows:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Go 中，我们可以**返回多个值**。例如，考虑一个将两个整数相除并返回两个变量（结果和余数）的函数，如下所示：
- en: '[PRE56]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'This code demonstrates a few new features in our function:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码演示了我们函数中的一些新特性：
- en: Argument `num` is the number to be divided
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数`num`是被除数
- en: Argument `div` is the number to divide by
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参数`div`是被除数
- en: Return value `res` is the result of the division
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值`res`是除法的结果
- en: Return value `rem` is the remainder of the division
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回值`rem`是除法的余数
- en: First is `res` and `rem`). These variables are automatically created and ready
    for use inside the function.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是`res`和`rem`。这些变量会自动创建，并且可以在函数内使用。
- en: Notice I use `=` and not `:=` when doing assignments to those variables. This
    is because the variable already exists, and we want to assign a value (`=`). `:=`
    means **create and assign**. You can only create a new variable that doesn't exist.
    You will also notice that now the return type is in parenthesis. You will need
    to use parenthesis if you use more than one return value or named returns (or
    in this case, both).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我在为这些变量赋值时使用的是`=`而不是`:=`。这是因为这些变量已经存在，我们要做的是赋值（`=`）。`:=`表示**创建并赋值**，它只适用于创建不存在的新变量。你还会注意到，返回类型现在放在括号中。如果你使用多个返回值或命名返回值（或者在此情况中，两者都有），你将需要使用括号。
- en: 'Calling this function is just as simple as calling `add()` before, as shown
    here:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 调用这个函数和之前调用`add()`一样简单，如下所示：
- en: '[PRE57]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Strickly speaking, you don't have to use `return` to return the values. However,
    doing so will prevent some ugly bugs that you will eventually encounter.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，你不必使用`return`来返回值。然而，使用它会防止一些你最终会遇到的难看的错误。
- en: Next, we will look at how we can have a variable number of arguments as function
    input that allows us to create functions such as `fmt.Println()`, which you have
    been using in this chapter.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看看如何使函数接受可变数量的参数，从而创建像 `fmt.Println()` 这样的函数，你在本章中已经使用过它。
- en: Variadic arguments
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变参
- en: 'A `0` to infinite arguments. A good example would be calculating a sum of integers.
    Without variadic arguments, you might use a slice (a *growable array type*, which
    we will talk about later), as follows:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '`0` 到无限个参数。一个好的例子是计算整数的总和。如果没有变参，你可能会使用一个切片（*可增长的数组类型*，我们稍后会谈到），如下所示：'
- en: '[PRE58]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'While this is fine, using it is cumbersome:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这样做是可以的，但使用起来有些繁琐：
- en: '[PRE59]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We can accomplish this same thing by using the variadic (`...`) notation:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用变参（`...`）符号完成相同的事情：
- en: '[PRE60]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '`numbers` is still `[]int`, but has a different calling convention that is
    more elegant:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '`numbers` 仍然是 `[]int`，但具有一种更优雅的调用约定：'
- en: '[PRE61]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Note
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can use variadic arguments with other arguments, but it must be the last
    argument in the function.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将变参与其他参数一起使用，但它必须是函数中的最后一个参数。
- en: Anonymous functions
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 匿名函数
- en: Go has a concept of **anonymous functions**, which means a function without
    a name (also called a **function closure**).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: Go 具有**匿名函数**的概念，即没有名称的函数（也称为**函数闭包**）。
- en: 'This can be useful to take advantage of special statements that honor function
    boundaries, such as `defer`, or in `goroutines`. We will show how to take advantage
    of these for `goroutines` later, but for now let''s show how to execute an anonymous
    function. This is a contrived example that is only useful in teaching the concept:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于利用一些特殊语句非常有用，这些语句尊重函数边界，例如 `defer` 或 `goroutines`。我们稍后将展示如何在 `goroutines`
    中利用这些语句，但现在我们先展示如何执行匿名函数。这是一个人为的示例，仅用于教学概念：
- en: '[PRE62]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This code does the following:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码执行了以下操作：
- en: Defines a single-use function (`func(word1, word2 string) string`)
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个一次性函数（`func(word1, word2 string) string`）
- en: Executes the function with the `hello` and `world` arguments
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `hello` 和 `world` 参数执行该函数
- en: Assigns the `string` return value to the `result` variable
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `string` 返回值赋给 `result` 变量
- en: Prints `result`
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打印 `result`
- en: Now that we have arrived at the end of this section, we have learned about how
    Go functions are declared, the use of multiple return values, variadic arguments
    for simplified function calling, and anonymous functions. Multiple return values
    will be important in future chapters where we deal with errors, and anonymous
    functions are key components of our future `defer` statements and for use with
    concurrency.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经到达了这一部分的结尾，我们学习了如何声明 Go 函数，如何使用多个返回值，如何简化函数调用的变参，以及匿名函数。多个返回值在后续章节中处理错误时非常重要，而匿名函数是我们未来
    `defer` 语句和并发使用的关键组件。
- en: In the next section, we will explore public and private types.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将探讨公共和私有类型。
- en: Defining public and private
  id: totrans-353
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义公共和私有
- en: Many modern languages provide a set of options when declaring constants/variables/functions/methods
    that detail when a method can be called.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代编程语言在声明常量/变量/函数/方法时提供了一组选项，详细说明了何时可以调用某个方法。
- en: 'Go simplifies these *visibility* choices down to two types:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: Go 将这些*可见性*选择简化为两种类型：
- en: '**Public** (exported)'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共**（已导出）'
- en: '**Private** (not exported)'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有**（未导出）'
- en: '**Public types** are types that can be referred to outside of the package.
    **Private types** can only be referred to inside the package. To be public, the
    constant/variable/function/method must simply start with an uppercase letter.
    If it starts with a lowercase letter, it is private.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '**公共类型**是可以在包外引用的类型。**私有类型**只能在包内引用。为了使常量/变量/函数/方法为公共，必须以大写字母开头。如果以小写字母开头，它就是私有的。'
- en: 'There is a third type of visibility that we don''t cover here: `internal/`.
    Those packages can only be used by packages within a parent directory. You can
    read about this here: [https://golang.org/doc/go1.4#internalpackages](https://golang.org/doc/go1.4#internalpackages).'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 还有第三种可见性类型我们没有在这里讨论：`internal/`。这些包只能被父目录中的其他包使用。你可以在这里阅读相关内容：[https://golang.org/doc/go1.4#internalpackages](https://golang.org/doc/go1.4#internalpackages)。
- en: 'Let''s declare a package and create some public and private methods:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们声明一个包并创建一些公共和私有方法：
- en: '[PRE63]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'We have three function calls, two public (`PrintHello()` and `PrintHelloWorld()`)
    and one private (`printWorld()`). Now, let''s create `package main`, import the
    `say` package, and call our functions:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三个函数调用，其中两个是公共的（`PrintHello()` 和 `PrintHelloWorld()`），一个是私有的（`printWorld()`）。现在，让我们创建
    `package main`，导入 `say` 包，并调用我们的函数：
- en: '[PRE64]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Now, let''s compile and run it:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编译并运行它：
- en: '[PRE65]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: These work because `PrintHello()` and `PrintHelloWorld()` are both `PrintHelloWorld()`
    calls the private `printWorld()`, but that is legal because they are in the same
    package.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 之所以有效，是因为 `PrintHello()` 和 `PrintHelloWorld()` 都是 `PrintHelloWorld()` 调用了私有的
    `printWorld()`，但这是合法的，因为它们位于同一个包中。
- en: 'If we try to add `say.printWorld()` to `func main()` and run it, we will get
    the following:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试将 `say.printWorld()` 添加到 `func main()` 中并运行，我们将得到以下结果：
- en: '[PRE66]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Public and private apply to variables declared outside functions/methods and
    type declarations.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 公共和私有作用域适用于在函数/方法和类型声明外声明的变量。
- en: By the end of this short and sweet section, you've acquired the knowledge of
    Go's public and private types. This will be useful in code where you do not want
    to expose types in your public API. Next, we will look at arrays and slices.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 到这节结束时，你已经掌握了 Go 语言的公共和私有类型。这将在你不希望在公共 API 中暴露类型的代码中非常有用。接下来，我们将学习数组和切片。
- en: Using arrays and slices
  id: totrans-371
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用数组和切片
- en: Languages require more than the basic types to hold data. The `array` type is
    one of the core building blocks in lower-level languages, providing the base sequential
    data type. For most day-to-day use, Go's `slice` type provides a flexible **array**
    that can grow as data needs grow and can be sliced into sections in order to share
    views of the data.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 编程语言需要比基本类型更多的类型来存储数据。`array` 类型是底层语言中的核心构建块之一，提供基础的顺序数据类型。对于大多数日常使用，Go 的 `slice`
    类型提供了一种灵活的**数组**，它可以根据数据需求增长，并且可以被切分成多个部分，以便共享数据的视图。
- en: In this section, we will talk about arrays as the building blocks of **slices**,
    the difference between the two, and how to utilize them in your code.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我们将讨论数组作为**切片**的构建块，二者的区别以及如何在代码中使用它们。
- en: Arrays
  id: totrans-374
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: The base sequential type in Go is the array (important to know, but rarely used).
    Arrays are statically sized (if you create one that holds 10 `int` types, it will
    always hold exactly 10 `int` types).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: Go 语言中的基础顺序类型是数组（这很重要，但很少使用）。数组的大小是静态的（如果你创建一个可以容纳 10 个 `int` 类型的数组，它将始终容纳恰好
    10 个 `int` 类型）。
- en: Go provides an `array` type designated by putting `[size]` before the type you
    wish to create an array of. For example, `var x [5]int or x := [5]int{}` creates
    an array holding five integers, indexed from `0` to `4`.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: Go 提供了一个 `array` 类型，方法是在你希望创建数组的类型前加上 `[size]`。例如，`var x [5]int` 或 `x := [5]int{}`
    创建一个包含五个整数的数组，索引从 `0` 到 `4`。
- en: An assignment into an array is as easy as choosing the index. `x[0] = 3` assigns
    `3` to index `0`. Retrieving that value is as simple as referring to the index;
    `fmt.Println(x[0] + 2)` will output `5`.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 向数组赋值像选择索引一样简单。`x[0] = 3` 将 `3` 赋给索引 `0`。检索该值同样简单，只需引用该索引；`fmt.Println(x[0]
    + 2)` 将输出 `5`。
- en: 'Arrays, unlike slices, are *not* pointer wrapper types. Passing an array as
    a function argument passes a copy:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 数组与切片不同，*不是*指针包装类型。将数组作为函数参数传递时会传递一个副本：
- en: '[PRE67]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Arrays present the following two problems in Go:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 数组在 Go 语言中存在以下两个问题：
- en: Arrays are typed by size – `[2]int` is distinct from `[3]int`. You cannot use
    `[3]int` where `[2]int` is required.
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组的类型由大小决定——`[2]int` 与 `[3]int` 是不同的。在需要 `[2]int` 的地方不能使用 `[3]int`。
- en: Arrays are a set size. If you need more room, you must make a new array.
  id: totrans-382
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数组的大小是固定的。如果你需要更多空间，必须创建一个新的数组。
- en: While it is important to know what arrays are, the most common sequential type
    used in Go is the slice.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然了解数组是什么很重要，但在 Go 语言中最常用的顺序类型是切片。
- en: Slices
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切片
- en: 'The easiest way to understand a slice is to see it as a type that is built
    on top of arrays. A slice is a *view* into an array. Changing what you can see
    in your slice''s view changes the underlying array''s value. The most basic use
    of slices acts like arrays, with two exceptions:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 理解切片的最简单方法是将其看作是一种构建在数组之上的类型。切片是对数组的*视图*。在切片的视图中改变你能看到的内容会改变底层数组的值。切片的最基本用途像数组一样，但有两个例外：
- en: A slice is not statically sized.
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切片不是静态大小的。
- en: A slice can grow to accommodate new values.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 切片可以增长以容纳新的值。
- en: A slice tracks its array, and when it needs more room, it will create a new
    array that can accommodate the new values and copies the values from the current
    array into the new array. This happens invisibly to the user.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 切片会追踪它的数组，当需要更多空间时，它会创建一个新数组来容纳新值，并将当前数组中的值复制到新数组中。这个过程对用户是不可见的。
- en: Creating a slice can be done similarly to an array, `var x = []int` or `x :=
    []int{}` . This creates a slice of integers with a length of `0` (which has no
    room to store values). You can retrieve the size of the slice using `len(x)`.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个切片与创建数组类似，`var x = []int`或`x := []int{}`。这会创建一个长度为`0`的整数切片（没有空间存储值）。你可以使用`len(x)`来获取切片的大小。
- en: 'We can create a slice with initial values easily: `x := []int{8,4,5,6}`. Now,
    we have `len(x) == 4`, indexed from `0` to `3`.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松创建一个具有初始值的切片：`x := []int{8,4,5,6}`。现在，我们的`len(x) == 4`，索引范围从`0`到`3`。
- en: Similar to arrays, we can change a value at an index by simply referencing the
    index. `x[2] = 12` will change the preceding slice to `[]int{8,4,12,6}`.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于数组，我们可以通过简单地引用索引来更改某个值。`x[2] = 12`会将前面的切片改为`[]int{8,4,12,6}`。
- en: Unlike arrays, we can add a new value to the slice using the `append` command.
    `x = append(x, 2)` will cause the underlying `x` array references to be copied
    to a new array and assigns the new view of the array back to `x`. The new value
    is `[]int{8,4,12,6,2}`. You may append multiple values by just putting more comma-delimited
    values in `append` (that is, `x = append(x, 2, 3, 4, 5)`).
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 与数组不同，我们可以使用`append`命令向切片中添加新值。`x = append(x, 2)`将导致底层的`x`数组引用被复制到一个新的数组中，并将新的数组视图返回给`x`。新值为`[]int{8,4,12,6,2}`。你也可以通过在`append`中添加多个用逗号分隔的值来追加多个值（例如，`x
    = append(x, 2, 3, 4, 5)`）。
- en: Remember that slices are simply *views* into a trackable array. We can create
    new limited views of the array. `y := x[1:3]` creates a view (`y`) of the array,
    yielding `[]int{4, 12}` (`1` is inclusive and `3` is exclusive in `[1:3]`). Changing
    the value at `y[0]` will change `x[1]`. Appending a single value to `y` via `y
    = append(y, 10)`will change `x[3]`, yielding `[]int{8,4,12,10,2}`.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，切片只是数组的*视图*。我们可以创建数组的新有限视图。`y := x[1:3]`创建了数组的一个视图（`y`），返回`[]int{4, 12}`（`1`是包含的，`3`是不包含的，即`[1:3]`）。更改`y[0]`的值会改变`x[1]`。通过`y
    = append(y, 10)`将一个新值附加到`y`，这会改变`x[3]`，结果是`[]int{8,4,12,10,2}`。
- en: This kind of use isn't common (and is confusing), but the important part is
    to understand that slices are simply views into an array.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 这种用法并不常见（而且容易混淆），但重要的是要理解，切片只是数组的视图。
- en: While slices are a pointer-wrapped type (values in a slice passed to a function
    that are changed will change in the caller as well), a slice's view will not change.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然切片是一个指针封装类型（传递给函数并更改切片中的值也会在调用者中发生变化），切片的视图本身不会发生改变。
- en: '[PRE68]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'In this example, the `sl` and `x` variables both use the same underlying array
    (which has changed in both), but the view for `x` does not get updated in `doAppend()`.
    To update `x` to see the addition to the slice would require passing a pointer
    to the slice (pointers are covered in a future chapter) or returning the new slice
    as seen here:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`sl`和`x`变量都使用相同的底层数组（在两者中都发生了变化），但`x`的视图并没有在`doAppend()`中更新。要更新`x`以查看切片的变化，需要传递切片的指针（指针将在后续章节中讲解）或者像这里一样返回新的切片：
- en: '[PRE69]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Now that you see how to create and add to a slice, let's look at how to extract
    the values.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何创建和添加到切片，接下来我们来看如何提取切片中的值。
- en: Extracting all values
  id: totrans-400
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取所有值
- en: To extract values from a slice, we can use the older C-type `for` loop or the
    more common `for`...`range` syntax.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 要从切片中提取值，我们可以使用旧的C型`for`循环或更常见的`for`...`range`语法。
- en: 'The older C style is as follows:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 旧的C风格如下：
- en: '[PRE70]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The more common approach in Go uses `range`:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: Go中更常见的方法是使用`range`：
- en: '[PRE71]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'With `range`, we often want to use only the value, but not the index. In Go,
    you must use variables that are declared in a function, or the compiler will complain
    with the following:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`range`时，我们通常只想使用值，而不关心索引。在Go中，你必须使用在函数中声明的变量，否则编译器会报错，提示如下：
- en: '[PRE72]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'To only extract the values, we can use `_,` (which tells the compiler not to
    store the output), as follows:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 为了只提取值，我们可以使用`_,`（这告诉编译器不要存储输出），如下所示：
- en: '[PRE73]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'On very rare occasions, you may want to only print out indexes and not values.
    This is uncommon because it will simply count from zero to the number of items.
    However, this can be achieved by simply removing `val` from the `for` statement:
    `for index := range someSlice`.'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 在非常罕见的情况下，您可能只想打印出索引而不是值。这是不常见的，因为它只会从零开始计数到项目数。然而，这可以通过简单地从`for`语句中删除`val`来实现：`for
    index := range someSlice`。
- en: In this section, you have discovered what arrays are, how to create them, and
    how they relate to slices. In addition, you've acquired the skills to create slices,
    add data to slices, and extract data from slices. Let's move on to learning about
    maps next.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您已经了解了数组是什么，如何创建它们以及它们与切片的关系。此外，您已经掌握了创建切片、向切片添加数据和从切片中提取数据的技能。接下来让我们学习一下关于映射的知识。
- en: Understanding maps
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解映射
- en: '**Maps** are a collection of key-value pairs that a user can use to store some
    data and retrieve it with a key. In some languages, these are called **dictionaries**
    (*Python*) or **hashes** (*Perl*). In contrast to an array/slice, finding an entry
    in a map requires a single lookup versus iterating over the entire slice comparing
    values. With a large set of items, this can give you significant time savings.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '**映射**是用户可以使用的一组键值对，用于存储一些数据并使用键检索它。在某些语言中，这些被称为**字典**（*Python*）或**哈希**（*Perl*）。与数组/切片不同，映射中查找条目只需单个查找而不是迭代整个切片比较值。对于大量项目，这可以节省大量时间。'
- en: Declaring a map
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明映射
- en: 'There are several ways to declare a map. Let''s first look at using `make`:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种声明映射的方法。让我们首先看看使用`make`：
- en: '[PRE74]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: The example just shared creates a map with `string` keys and stores data that
    is an `int` type. `10` signifies that we want to pre-size for 10 entries. The
    map can grow beyond 10 entries and the `10` can be omitted.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 刚刚分享的示例创建了一个具有`string`键并存储数据类型为`int`的映射。`10`表示我们要为10个条目预设大小。映射可以超过10个条目，而`10`可以省略。
- en: 'Another way of declaring a map is by using a **composite literal**:'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种声明映射的方法是使用**复合文字**：
- en: '[PRE75]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This creates a map with `string` keys and stores the `string` data. We also
    pre-populate the entry with two key-value entries. You can omit the entries to
    have an empty map.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个具有`string`键并存储`string`数据的映射。我们还会预先填充两个键值对的条目。您可以省略条目以获得空映射。
- en: Accessing values
  id: totrans-421
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 访问值
- en: 'You can retrieve a value as follows:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以按以下方式检索值：
- en: '[PRE76]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: This assigns the `chevy` value to `carMake`.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把`chevy`的值赋给`carMake`。
- en: 'But what happens if the key isn''t in the map? In that case, we will receive
    the zero value of the data type:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 但是如果键不在映射中会发生什么呢？在这种情况下，我们将收到数据类型的零值：
- en: '[PRE77]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The preceding code will print an empty string, which is the zero value of the
    string type that is used as values in our map.
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将打印一个空字符串，这是作为我们映射中值使用的字符串类型的零值。
- en: 'We can also detect if the value is in the map:'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以检测值是否在映射中：
- en: '[PRE78]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Here we assign two values. The first (`carMake`) is the data stored in the key
    (or zero value if not set), and the second (`ok`) is a Boolean that indicates
    if the key was found.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们分配了两个值。第一个（`carMake`）是存储在键中的数据（如果未设置，则为零值），第二个（`ok`）是一个布尔值，指示是否找到了键。
- en: Adding new values
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加新值
- en: 'Adding a new key-value pair or updating a key''s value, is done the same way:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新的键值对或更新键的值，方式是相同的：
- en: '[PRE79]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Now that we can change a key-value pair, let's look at extracting values from
    a map.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以更改键值对，让我们看看如何从映射中提取值。
- en: Extracting all values
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提取所有值
- en: 'To extract values from a map, we can use the `for`...`range` syntax that we
    used for slices. There are a few key differences with maps:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 要从映射中提取值，我们可以使用我们用于切片的`for`...`range`语法。与映射相关的有几个关键区别：
- en: Instead of an index, you will get the map's key.
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您将获得映射的键而不是索引。
- en: Maps have a non-deterministic order.
  id: totrans-438
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 映射具有非确定性顺序。
- en: Non-deterministic order means that iterating over the data will return the same
    data but not in the same order.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 非确定性顺序意味着迭代数据将返回相同的数据，但顺序不同。
- en: 'Let''s print out all the values in our `carMake` map:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打印出我们的`carMake`映射中的所有值：
- en: '[PRE80]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'This will yield the following, but maybe not in the same order:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 这将产生以下结果，但可能顺序不同：
- en: '[PRE81]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Note
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Similar to a slice, if you don't need the key, you may use `_` instead. If you
    simply want the keys, you can omit the value `val` variable, such as `for key
    := range modelToMake`.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 与切片类似，如果您不需要键，可以使用`_`。如果只需键，可以省略值`val`变量，例如`for key := range modelToMake`。
- en: In this section, you have learned about the `map` type, how to declare them,
    add values to them, and finally how to extract values from them. Let's dive into
    learning about pointers.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你已经了解了`map`类型，如何声明它们，如何向其中添加值，最后如何从中提取值。现在让我们深入学习指针。
- en: Understanding Go pointers
  id: totrans-447
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Go中的指针
- en: '`dict`, `list`, and `object` types are reference types.'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '`dict`、`list`和`object`类型是引用类型。'
- en: In this section, we will cover what pointers are, how to declare them, and how
    to use them.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讲解指针是什么，如何声明它们，以及如何使用它们。
- en: Memory addresses
  id: totrans-450
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存地址
- en: In an earlier chapter, we talked about variables for storing data of some type.
    For example, if we want to create a variable called `x` that stores an `int` type
    with a value of `23`, we can write `var x int = 23`.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们讨论了用于存储某种类型数据的变量。例如，如果我们想创建一个名为`x`的变量来存储一个值为`23`的`int`类型，可以写作`var
    x int = 23`。
- en: Under the hood, the memory allocator allocates us space to store the value.
    The space is referenced by a unique memory address that looks like `0xc000122020`.
    This is similar to how a home address is used; it is the reference to where the
    data lives.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，内存分配器为我们分配了存储值的空间。这个空间通过一个唯一的内存地址来引用，看起来像`0xc000122020`。这有点类似于一个家庭地址；它是数据所在位置的引用。
- en: 'We can see the memory address where a variable is stored by prepending `&`
    to a variable name:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在变量名之前加上`&`来查看变量存储的内存地址：
- en: '[PRE82]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: This would print `0xc000122020`, the memory address of where `x` is stored.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印出`0xc000122020`，即`x`存储的内存地址。
- en: 'This leads to an important concept: functions always make a copy of the arguments
    passed.'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 这引出了一个重要的概念：函数总是会复制传入的参数。
- en: Function arguments are copies
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数参数是副本
- en: When we call a function and pass a variable as a function argument, inside the
    function you get a copy of that variable. This is important because when you change
    the variable, you are only affecting the copy inside the function.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用一个函数并将一个变量作为函数参数传递时，函数内部得到的是该变量的副本。这个概念很重要，因为当你修改变量时，实际上只是在修改函数内的副本。
- en: '[PRE83]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: In this code, `word` is a copy of the value that was passed. `word` will stop
    existing at the end of this function call.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，`word`是传入值的副本。`word`会在函数调用结束时不再存在。
- en: '[PRE84]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: This prints `"hello"`. Passing the string and changing it in the function doesn't
    work, because inside the function we are working with a copy. Think of every *function
    call* as making a copy of the variable with a copy machine. Editing the copy that
    came out of the copy machine does not affect the original.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 这会打印出`"hello"`。将字符串传递并在函数中更改它不起作用，因为在函数内部我们操作的是副本。可以把每次*函数调用*看作是用复印机复制变量。编辑复印机出来的副本不会影响原始的变量。
- en: Pointers to the rescue
  id: totrans-463
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指针来救场
- en: Pointers in Go are types that store the address of a value, not the value. So,
    instead of storing `23`, it would store `0xc000122020`, which is where in memory
    `23` is stored.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: Go中的指针是存储值地址的类型，而不是值本身。所以，指针存储的是像`0xc000122020`这样的内存地址，而不是直接存储`23`，`23`在内存中的存储位置就是这个地址。
- en: 'A pointer type can be declared by prepending the type name with `*`. If we
    want to create an `intPtr` variable that stores a pointer to `int`, we can do
    the following:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 指针类型可以通过在类型名前加上`*`来声明。如果我们想创建一个`intPtr`变量来存储指向`int`的指针，可以这样做：
- en: '[PRE85]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: You cannot store `int` in `intPtr`; you can only store the address of `int`.
    To get the address of an existing `int`, you can use the `&` symbol on a variable
    representing `int`.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能将`int`存储在`intPtr`中；你只能存储`int`的地址。要获取一个现有`int`的地址，可以在表示`int`的变量前使用`&`符号。
- en: 'Let''s assign `intPtr` the address of our `x` variable from previously:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将`intPtr`赋值为之前`x`变量的地址：
- en: '[PRE86]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: Now for the big question, *how is this useful?* This lets us refer to a value
    in memory and change that value. We do that through what is called `*` operator
    on the variable.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是大问题，*这有什么用？* 通过指针，我们可以引用内存中的一个值并改变它。我们通过对变量使用`*`操作符来实现这一点。
- en: 'We can view or change the value held at `x` by dereferencing the pointer. The
    following is an example:'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过解引用指针来查看或更改存储在`x`中的值。下面是一个示例：
- en: '[PRE87]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'This also works across functions. Let''s alter `changeValue()` to work with
    pointers:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 这在函数之间也同样适用。让我们修改`changeValue()`使其与指针一起工作：
- en: '[PRE88]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Note that operators such as `*` are called `*` indicates a pointer type, `var
    intPtr *int`. When used on a variable, `*` means dereference, `fmt.Println(*intPtr)`.
    When used between two numbers, it means multiply, `y := 10 * 2`. It takes time
    to remember what a symbol means when used in certain contexts.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，像 `*` 这样的操作符被称为 `*` 表示指针类型，`var intPtr *int`。当用于变量时，`*` 表示解引用，`fmt.Println(*intPtr)`。当用于两个数字之间时，它表示乘法，`y
    := 10 * 2`。需要时间去记住在某些上下文中符号的含义。
- en: '*But, didn''t you say every argument is a copy?!*'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '*但是，你不是说每个参数都是副本吗？！*'
- en: I did indeed. When you pass a pointer to a function, a copy of the pointer is
    made, but the copy still holds the same memory address. Therefore, it still refers
    to the same piece of memory. It is a lot like making a copy of a treasure map
    on the copy machine; the copy still points to the place in the world where you
    will find the treasure. Some of you are probably thinking, *But maps and slices
    can have their values changed, what gives?*
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 我确实理解了。当你将指针传递给函数时，会创建指针的副本，但副本仍然持有相同的内存地址。因此，它仍然引用相同的内存。这就像是用复印机复制一张藏宝图；副本仍然指向你能找到宝藏的地方。你们中的一些人可能在想，*但是地图和切片可以修改它们的值，那怎么回事？*
- en: They are a special type called a **pointer-wrapped** type. A pointer-wrapped
    type hides internal pointers.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 它们是一种特殊类型，叫做 **指针包装** 类型。指针包装类型隐藏了内部的指针。
- en: Don't go crazy with pointers
  id: totrans-479
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不要过于疯狂地使用指针
- en: While in our examples we used pointers for basic types, typically pointers are
    used on long-lived objects or for storage of large data that is expensive to copy.
    Go's memory model uses the stack/heap model. **Stack** memory is created for exclusive
    use by a function/method call. Allocation on the stack is significantly faster
    than on the **heap**.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在我们的例子中我们使用了基础类型的指针，但通常指针用于长生命周期的对象或存储大量数据的地方，因为复制这些数据非常昂贵。Go的内存模型使用栈/堆模型。**栈**内存是为函数/方法调用专门创建的。栈上的分配比在**堆**上分配要快得多。
- en: '**Heap allocation** occurs in Go when a reference or pointer cannot be determined
    to live exclusively within a function''s call stack. This is determined by the
    compiler doing **escape analysis**.'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '**堆分配**发生在Go中，当一个引用或指针无法被确定仅在函数调用栈中生存时。编译器通过**逃逸分析**来确定这一点。'
- en: Generally, it is much cheaper to pass copies into a function via an argument
    and another copy in the return value than it is to use a pointer. Finally, be
    careful with the number of pointers. Unlike C, it is uncommon in Go to see pointers
    to pointers, such as `**someType`, and, in over 10 years of coding Go, I have
    only once seen a single use for `***someType` that was valid. Unlike in the movie
    *Inception*, there is no reason to go deeper.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，将副本通过参数传递到函数中并返回另一个副本，比使用指针要便宜得多。最后，要小心指针的数量。与C语言不同，在Go中很少看到指向指针的指针，比如 `**someType`，而且在超过10年的Go编码经验中，我只见过一次有效的
    `***someType` 用法。与电影《盗梦空间》不同，实际上没有理由深入下去。
- en: To sum up this section, you have gained an understanding of pointers, how to
    declare them, how to use them in your code, and where you should probably use
    them. You will use them on long-lived objects or types holding large amounts of
    data where copies are expensive. Next, let's explore structs.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 总结这一部分，你已经理解了指针、如何声明指针、如何在代码中使用它们以及你可能应该在哪里使用它们。你将使用它们在长生命周期的对象或存储大量数据的类型中，因为复制这些数据的成本很高。接下来，让我们探索结构体。
- en: Getting to know about structs
  id: totrans-484
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解结构体
- en: '`string`, `int`, and `float64`) and are grouped together. That grouping would
    be a struct in Go.'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '`string`、`int` 和 `float64`）被归为一组。这个分组在Go中就是一个结构体。'
- en: Declaring a struct
  id: totrans-486
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明一个结构体
- en: 'There are two methods for declaring a struct. The first way is uncommon except
    in tests, as it doesn''t allow us to reuse the struct''s definition to create
    more variables. But, as we will see it later in tests, we will cover it here:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以声明一个结构体。第一种方法在测试中比较常见，因为它不允许我们重用结构体的定义来创建更多的变量。但是，正如我们稍后在测试中看到的那样，我们在这里也会涵盖它：
- en: '[PRE89]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Here, we created a struct that contains two fields:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个包含两个字段的结构体：
- en: '`Name` (`string`)'
  id: totrans-490
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Name`（`string`）'
- en: '`Age` (`int`)'
  id: totrans-491
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Age`（`int`）'
- en: 'We then created an instance of that struct that has those values set. To access
    those fields, we can use the dot `.` operator:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们创建了该结构体的一个实例，并设置了这些字段的值。要访问这些字段，我们可以使用点（`.`）操作符：
- en: '[PRE90]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: This prints `"John Doak is 100 years old"`.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出 `"John Doak is 100 years old"`。
- en: Declaring single-use structs, as we have here, is rarely done. Structs become
    more useful when they are used to create custom types in Go that are reusable.
    Let's have a look at how we can do that next.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 声明一次性结构体，像我们这里所做的，是很少见的。当结构体用于在 Go 中创建可重用的自定义类型时，它们变得更加有用。接下来我们来看一下如何实现这一点。
- en: Declaring a custom type
  id: totrans-496
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明自定义类型
- en: So far, we have created a single-use struct, which generally is not useful.
    Before we talk about the more common way to do this, let's talk about creating
    **custom types**.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们创建了一个一次性结构体，这通常不是很有用。在我们讨论更常见的做法之前，让我们先讨论一下如何创建**自定义类型**。
- en: 'Up until this point, we''ve seen the basic and pointer-wrapped types that are
    defined by the language: `string`, `bool`, `map`, and `slice`, for example. We
    can create our own types based on these basic types using the `type` keyword.
    Let''s create a new type called `CarModel` that is based on the `string` type:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了语言中定义的基本类型和指针包装类型，例如：`string`、`bool`、`map` 和 `slice`。我们可以使用 `type`
    关键字基于这些基本类型创建我们自己的类型。让我们创建一个基于 `string` 类型的新类型，叫做 `CarModel`：
- en: '[PRE91]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '`CarModel` is now its own type, just like `string`. While `CarModel` is based
    on a `string` type, it is a distinct type. You cannot use `CarModel` in place
    of a string or vice versa.'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '`CarModel` 现在是一个独立的类型，就像 `string` 一样。虽然 `CarModel` 是基于 `string` 类型的，但它是一个独立的类型。你不能用
    `CarModel` 替代 `string`，反之亦然。'
- en: 'Creating a variable of `CarModel` can be done similar to a `string` type:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `CarModel` 变量的方式与创建 `string` 类型变量类似：
- en: '[PRE92]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Or, by using type conversion, as shown here:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，通过使用类型转换，如下所示：
- en: '[PRE93]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Because `CarModel` is based on `string`, we can convert `CarModel` back to
    `string` with type conversion:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `CarModel` 是基于 `string` 的，所以我们可以通过类型转换将 `CarModel` 转换回 `string`：
- en: '[PRE94]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: We can create new types based on any other type, including maps, slices, and
    functions. This can be useful for naming purposes or adding custom methods to
    a type (we will talk about this in a moment).
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以基于任何其他类型创建新类型，包括映射、切片和函数。这对于命名或为类型添加自定义方法非常有用（稍后我们会讨论这个问题）。
- en: Custom struct types
  id: totrans-508
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义结构体类型
- en: 'The most common way to declare a struct is using the `type` keyword. Let''s
    create that record again, but this time let''s make it reusable by declaring a
    type:'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 声明结构体最常见的方式是使用 `type` 关键字。让我们再次创建那个记录，但这次通过声明一个类型来使它可重用：
- en: '[PRE95]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: By using `type`, we have made a new type called `Record` that we can use again
    and again to create variables holding `Name` and `Age`.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `type`，我们创建了一个名为 `Record` 的新类型，可以重复使用它来创建保存 `Name` 和 `Age` 的变量。
- en: Note
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Similar to how you may define two variables with the same type on a single line,
    you may do the same within a `struct` type, such as `First, Last string`.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 与在一行中定义两个相同类型的变量类似，你也可以在 `struct` 类型中做同样的事，比如 `First, Last string`。
- en: Adding methods to a type
  id: totrans-514
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向类型添加方法
- en: A method is similar to a function, but instead of being independent, it is bound
    to a type. For example, we have been using the `fmt.Println()` function. That
    function is independent of any variable that has been declared.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 方法类似于函数，但它与类型绑定在一起，而不是独立的。例如，我们一直在使用 `fmt.Println()` 函数。那个函数独立于任何已声明的变量。
- en: 'A method is a function that is attached to a variable. It can only be used
    on a variable of a type. Let''s create a method that returns a string representation
    of the `Record` type we created earlier:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 方法是绑定到变量上的函数。它只能用于某种类型的变量。让我们创建一个方法，返回我们之前创建的 `Record` 类型的字符串表示：
- en: '[PRE96]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Notice `func (r Record)`, which attaches the function as a method onto the `Record`
    struct. You can access the fields of `Record` within this method by using `r.<field>`,
    such as `r.Name` or `r.Age`.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `func (r Record)`，它将函数作为方法附加到 `Record` 结构体上。在这个方法内，你可以通过 `r.<field>` 访问 `Record`
    的字段，例如 `r.Name` 或 `r.Age`。
- en: 'This method cannot be used outside of a `Record` object. Here''s an example
    of using it:'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法不能在 `Record` 对象之外使用。以下是一个使用它的示例：
- en: '[PRE97]'
  id: totrans-520
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Let's look at how we change a field's value.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何更改字段的值。
- en: Changing a field's value
  id: totrans-522
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更改字段值
- en: 'Struct values can be changed by using the variable attribute followed by `=`
    and the new value. Here is an example:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体的值可以通过使用变量属性后跟 `=` 和新值来更改。以下是一个示例：
- en: '[PRE98]'
  id: totrans-524
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'It is important to remember that a struct is not a reference type. If you pass
    a variable representing a struct to a function and change a field in the function,
    it will not change on the outside. Here is an example:'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住，结构体不是引用类型。如果你将一个表示结构体的变量传递给函数并在函数中更改一个字段，这个字段在外部不会发生变化。以下是一个示例：
- en: '[PRE99]'
  id: totrans-526
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'This will output the following:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出如下内容：
- en: '[PRE100]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'As we learned in the section on **pointers**, this is because the variable
    is copied, and we are changing the copy. For struct types that need to have fields
    that change, we normally pass in a pointer. Let''s try this again, using pointers:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 **指针** 部分所学到的那样，这是因为变量是被复制的，我们在修改的是该副本。对于需要更改字段的结构体类型，我们通常会传递一个指针。让我们再试一次，使用指针：
- en: '[PRE101]'
  id: totrans-530
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'This will output the following:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出如下内容：
- en: '[PRE102]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: Note that `.` is a *magic* operator that works on `struct` or `*struct`.
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`.` 是一个 *魔术* 操作符，它适用于 `struct` 或 `*struct`。
- en: When I declared the `rec` variable, I did not set the `age`. Non-set fields
    are set to the zero value of the type. In the case of `Age`, which is `int`, this
    would be `0`.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 当我声明 `rec` 变量时，我没有设置 `age`。未设置的字段会被设为该类型的零值。对于 `Age` 类型（`int`），其零值为 `0`。
- en: Changing a field's value in a method
  id: totrans-535
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在方法中更改字段值
- en: 'In the same way that a function cannot alter a non-pointer struct, neither
    can a method. If we had a method called `IncrAge()` that increased the age on
    the record by one, this would not do what you wanted:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 与函数不能修改非指针结构体类似，方法也不能修改它。如果我们有一个名为 `IncrAge()` 的方法，用于将记录中的年龄加一，这将不会达到你想要的效果：
- en: '[PRE103]'
  id: totrans-537
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The preceding code passes a copy of `Record`, adds one to the copy's `Age`,
    and returns.
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码传递了 `Record` 的副本，将副本的 `Age` 加一，然后返回。
- en: 'To actually increment the age, simple make `Record` a pointer, as follows:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际增加年龄，只需将 `Record` 变为指针，如下所示：
- en: '[PRE104]'
  id: totrans-540
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: This will work as expected.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就能按预期工作。
- en: Tip
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Here is a basic rule that will keep you out of trouble, especially when you
    are new to the language. If the `struct` type should be a pointer, then make all
    methods pointer methods. If it shouldn't be, then make them all non-pointers.
    Don't mix and match.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一条基本规则，能帮助你避免一些常见问题，尤其是当你刚开始学习这门语言时。如果 `struct` 类型应该是指针类型，那么所有的方法都应该是指针方法；如果不应该是指针类型，那么所有方法都应为非指针方法。不要混合使用。
- en: Constructors
  id: totrans-544
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构造函数
- en: In many languages, **constructors** are specially-declared methods or syntax
    that are used to initialize fields in an object and sometimes run internal methods
    as setup. Go doesn't provide any specialized code for that, instead, we use a
    **constructor pattern** using simple functions.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多编程语言中，**构造函数**是特别声明的方法或语法，用于初始化对象的字段，并有时会执行一些内部方法作为设置过程。Go 并没有提供专门的构造代码，而是使用简单的函数，通过
    **构造函数模式** 来实现。
- en: Constructors are commonly either called `New()` or `New[Type]()` when declaring
    a public constructor. Use `New()` if there are no other types in the package (and
    most likely won't be in the future).
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数通常被命名为 `New()` 或 `New[Type]()`，当声明公共构造函数时使用。如果包中没有其他类型（并且未来可能也不会有），使用 `New()`。
- en: 'If we wanted to create a constructor that made our `Record` from the previous
    section, it might look like the following:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要创建一个构造函数，用来生成前面部分的 `Record`，它可能看起来像这样：
- en: '[PRE105]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'This constructor takes in a `name` and `age` argument and returns a pointer
    to `Record` with those fields set. If we pass bad values for those fields, it
    instead returns the pointer''s zero value (`nil`) and an error. Using this looks
    like the following:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构造函数接受 `name` 和 `age` 参数，并返回一个指向 `Record` 的指针，且这些字段已被设置。如果我们为这些字段传递无效值，它将返回指针的零值（`nil`）和一个错误。使用这个构造函数的方式如下：
- en: '[PRE106]'
  id: totrans-550
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Don't worry about the error, as we will discuss it in the course of the book's
    journey.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 不用担心这个错误，我们将在本书的后续部分讨论它。
- en: By now, you have learned how to use `struct`, Go's base object type. This included
    creating a struct, creating custom structs, adding methods, changing field values,
    and creating constructor functions. Now, let's look at using Go interfaces to
    abstract types.
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你已经学习了如何使用 `struct`，Go 的基础对象类型。这包括创建结构体、创建自定义结构体、添加方法、修改字段值以及创建构造函数。接下来，让我们看看如何使用
    Go 接口来抽象类型。
- en: Comprehending Go interfaces
  id: totrans-553
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Go 接口
- en: Go provides a type called an **interface** that stores any value that declares
    a set of methods. The implementing value must have declared this set of methods
    to implement the interface. The value may also have other methods besides the
    set declared in the interface type.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: Go 提供了一种名为 **interface** 的类型，用于存储声明了一组方法的任何值。实现该接口的值必须声明并实现这一组方法。该值还可以有接口类型声明之外的其他方法。
- en: If you are new to interfaces, understand that they can be a little confusing.
    Therefore, we will take it one step at a time.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是第一次接触接口，理解它们可能会有些混乱。因此，我们将一步步进行讲解。
- en: Defining an interface type
  id: totrans-556
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义一个接口类型
- en: 'Interfaces are most commonly defined using the `type` keyword that we discussed
    in the earlier section on structs. The following defines an interface that returns
    a string representing the data:'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 接口最常见的定义方式是使用我们在之前结构体部分讨论过的`type`关键字。以下定义了一个返回表示数据的字符串的接口：
- en: '[PRE107]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: Note
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`Stringer` is a real type defined in the standard library''s `fmt` package.
    Types that implement `Stringer` will have their `String()` method called when
    passed to `print` functions in the `fmt` package. Don''t let the similar names
    confuse you; `Stringer` is the interface type''s name, and it defines a method
    called `String()` (which is uppercase to distinguish it from the `string` type,
    which is lowercase). That method returns a `string` type that should provide some
    human-readable representation of your data.'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stringer`是标准库`fmt`包中定义的一个真实类型。实现了`Stringer`的类型将在传递给`fmt`包中的`print`函数时调用它们的`String()`方法。不要让相似的名字让你困惑；`Stringer`是接口类型的名字，它定义了一个名为`String()`的方法（大写字母区分于小写的`string`类型）。该方法返回一个`string`类型，应该提供数据的某种人类可读表示。'
- en: 'Now, we have a new type called `Stringer`. Any variable that has the `String()`
    `string` method can be stored in a variable of type `Stringer`. The following
    is an example:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了一个新类型叫做`Stringer`。任何具有`String()` `string`方法的变量都可以存储在`Stringer`类型的变量中。以下是一个示例：
- en: '[PRE108]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '`Person` represents a record of a person, first and last name. We define `String()
    string` on it, so `Person` implements `Stringer`:'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person`代表一个人的记录，包括名字和姓氏。我们为其定义了`String() string`方法，因此`Person`实现了`Stringer`接口：'
- en: '[PRE109]'
  id: totrans-564
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '`StrList` is a slice of strings. It also implements `Stringer`. The `strings.Join()`
    function used here takes a slice of strings and creates a single string with each
    entry from the slice separated by a comma:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '`StrList`是一个字符串切片。它也实现了`Stringer`接口。这里使用的`strings.Join()`函数接受一个字符串切片，并将切片中的每个条目通过逗号连接成一个单一的字符串：'
- en: '[PRE110]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '`PrintStringer()` allows us to print the output of `Stringer.String()` of any
    type that implements `Stringer`. Both the types we created above implement `Stringer`.'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '`PrintStringer()`允许我们打印任何实现了`Stringer`接口类型的`String()`方法的输出。我们上面创建的两个类型都实现了`Stringer`。'
- en: 'Let''s see this in action:'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看实际效果：
- en: '[PRE111]'
  id: totrans-569
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: Without interfaces, we would have to write a separate `Print[Type]` function
    for every type we wanted to print. Interfaces allow us to pass values that can
    do common operations defined by their methods.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有接口，我们将不得不为每个我们想打印的类型编写一个单独的`Print[Type]`函数。接口使我们能够传递能够执行其方法中定义的常见操作的值。
- en: Important things about interfaces
  id: totrans-571
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口的重要事项
- en: The first thing to note about interfaces is that values *must* implement every
    method defined in the interface. Your value can have methods not defined for the
    interface, but it doesn't work the other way.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: 关于接口，首先要注意的是，值*必须*实现接口中定义的每个方法。你的值可以有接口中未定义的方法，但反过来则不行。
- en: Another common issue new Go developers encounter is that once the type is stored
    in an interface, you cannot access its fields, or any methods not defined on the
    interface.
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 新手Go开发者常遇到的另一个问题是，一旦类型存储在接口中，你就无法访问其字段，或者接口中未定义的任何方法。
- en: The blank interface – Go's universal value
  id: totrans-574
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 空接口——Go的通用值
- en: 'Let''s define a blank interface variable: `var i interface{}. i` is an interface
    with no defined methods. So, what can you store in that?'
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个空接口变量：`var i interface{}`。`i`是一个没有定义任何方法的接口。那么，您可以将什么存储在其中呢？
- en: That's right, you can store *anything*.
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 没错，你可以存储*任何东西*。
- en: '`interface{}` is Go''s universal value container that can be used to pass any
    value to a function and then figure out what it is and what to do with it later.
    Let''s put some things in `i`:'
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: '`interface{}`是Go的通用值容器，可以用来将任何值传递给函数，然后再弄清楚它是什么以及如何处理它。让我们将一些东西放入`i`：'
- en: '[PRE112]'
  id: totrans-578
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'This is all legal because each of those values has types that define all the
    methods that the interface defined (which were no methods). This allows us to
    pass around values in a universal container. This is actually how `fmt.Printf()`
    and `fmt.Println()` work. Here are their definitions from the `fmt` package:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都是合法的，因为这些值的类型都定义了接口所定义的所有方法（但接口没有方法）。这使我们能够在通用容器中传递值。这实际上是`fmt.Printf()`和`fmt.Println()`的工作方式。以下是它们在`fmt`包中的定义：
- en: '[PRE113]'
  id: totrans-580
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: However, as the interface did not define any methods, `i` is not useful in this
    form. So, this is great for passing around values, but not using them.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于接口没有定义任何方法，`i`在这种形式下并不有用。所以，这非常适合传递值，但不适合使用它们。
- en: 'Note about interface{} in 1.18:'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 关于1.18版本中的`interface{}`的注意事项：
- en: Go 1.18 has introduced an alias for the blank `interface{}`, called `any`. The
    Go standard library now uses `any` in place of `interface{}`. However, all packages
    prior to 1.18 will still use `interface{}`. Both are equivalent and can be used
    interchangeably.
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: Go 1.18 引入了一个别名，替代了空的 `interface{}`，称为 `any`。Go 标准库现在使用 `any` 代替 `interface{}`。然而，1.18
    之前的所有包仍然使用 `interface{}`。两者是等价的，可以互换使用。
- en: Type assertion
  id: totrans-584
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型断言
- en: Interfaces can have their values *asserted* to either another interface type
    or to their original type. This is different than **type conversion**, where you
    change the type from one to another. In this case, we are saying *it already is
    this type*.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 接口可以通过 *断言* 将其值转换为另一个接口类型或其原始类型。这与**类型转换**不同，后者是将类型从一种类型转换为另一种类型。在这种情况下，我们是在说
    *它已经是这种类型了*。
- en: '`interface{}` value into a value that we can do something with.'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `interface{}` 值转换为我们可以操作的值。
- en: 'There are two common ways to do this. The first uses the `if` syntax, as follows:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 这是两种常见方式中的第一种，使用 `if` 语法，如下所示：
- en: '[PRE114]'
  id: totrans-588
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '`i.(string)` is asserting that `i` is a `string` value. If it is not, `ok ==
    false`. If `ok == true`, then `v` will be the `string` value.'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: '`i.(string)` 是在断言 `i` 是一个 `string` 类型的值。如果不是，`ok == false`。如果 `ok == true`，那么
    `v` 将是 `string` 类型的值。'
- en: 'The more common way is with a `switch` statement and another use of the `type`
    keyword:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 更常见的方式是使用 `switch` 语句和另一个 `type` 关键字的用法：
- en: '[PRE115]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Our `default` statement prints out the underlying type of `i` if it did not
    match any of the other cases. `%T` is used to print the type information.
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `default` 语句在没有匹配其他任何 case 时，会打印出 `i` 的底层类型。`%T` 用于打印类型信息。
- en: In this section, we learned about Go's `interface` type, how it can be used
    to provide type abstraction, and converting an interface into its concrete type
    for use.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们学习了 Go 的 `interface` 类型，了解了它如何用于提供类型抽象，并将接口转换为其具体类型以便使用。
- en: Summary
  id: totrans-594
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, you have learned the basics of the Go language. This includes
    variable types, functions, loops, methods, pointers, and interfaces. The skills
    acquired in this chapter provide the basic foundation needed to explore more advanced
    features of the Go language in our next chapter.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你已经学习了 Go 语言的基础知识。这包括变量类型、函数、循环、方法、指针和接口。本章所学的技能为接下来深入探索 Go 语言的高级特性奠定了基础。
- en: Next, we will be looking at essential capabilities of the Go language, such
    as handling errors, using concurrency, and Go's testing framework.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将研究 Go 语言的核心功能，例如错误处理、使用并发以及 Go 的测试框架。
