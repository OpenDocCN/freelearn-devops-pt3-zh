- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Non-Relational DMSs with DevOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will navigate the intricate yet fascinating landscape of
    integrating non-relational database management systems (also known as NoSQL) with
    DevOps. We will begin by examining the pivotal role that data modeling plays in
    NoSQL databases, shedding light on how it differs from its counterpart in relational
    databases.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we will explore schema management. As NoSQL databases offer flexible schemas,
    we’ll delve into how this flexibility can be both an asset and a challenge when
    managed within a DevOps framework. From there, we’ll move on to the crucial topic
    of deployment automation, where we will discuss how automated tools and workflows
    can greatly streamline the deployment process.
  prefs: []
  type: TYPE_NORMAL
- en: Performance tuning will also command our attention. As the scale of data grows
    exponentially, we’ll learn how to fine-tune our NoSQL databases to meet the demanding
    performance criteria that modern applications require. Subsequently, data consistency
    in a distributed, NoSQL environment will come under the lens, and we’ll learn
    strategies to maintain it effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Security, an ever-pressing concern, will not be left out of our discussion.
    We’ll scrutinize the best practices and mechanisms that can safeguard our data
    and infrastructure, aligning them seamlessly with DevOps protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, but just as importantly, we’ll look at anti-patterns, or what not to
    do when combining NoSQL and DevOps. This section will serve as a cautionary tale,
    guiding us away from common pitfalls and steering us toward successful implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, you will gain actionable insights and real-world applications
    of each key milestone. The aim is not just to inform but also to equip you with
    practical knowledge that you can readily apply to your own systems. Let’s embark
    on this educational journey to discover how non-relational Database Managements
    Systems (DMSs) and DevOps can work in harmony to create robust, scalable, and
    efficient systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Activities and challenges
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data modeling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Schema management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance tuning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data consistency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Anti-patterns (what not to do…)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Activities and challenges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As part of the DevOps team, some of the main activities and challenges when
    working with non-relational databases include data modeling, schema management,
    and deployment automation, as detailed here, along with other examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data modeling**: When working with non-relational databases, data modeling
    requires a different approach compared to traditional relational databases. One
    example of this is choosing the right data structure for the type of data being
    stored. For instance, if storing hierarchical data, a document-based database
    such as MongoDB may be more suitable than a relational database. In a relational
    database, this could be handled using a recursive query, but this would be less
    efficient and more complicated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Schema management**: Unlike relational databases, non-relational databases
    don’t require a fixed schema, which can make schema management more challenging.
    One example of this is handling schema migrations, which can be trickier to manage
    when there isn’t a predefined schema to work with. In a relational database, schema
    migrations can be handled through SQL scripts that update the schema, but in a
    non-relational database, you may be required to write custom code or use third-party
    tools.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment automation**: Automating the deployment of non-relational databases
    can be more complex than for relational databases. One example of this is configuring
    the database for high availability and disaster recovery. In a relational database,
    this can be achieved using replication, but in a non-relational database, it may
    require setting up a distributed system or using a cloud-based service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance tuning**: Non-relational databases often require specific performance
    tuning, depending on the use case. For example, in a document-based database,
    indexes need to be optimized based on the data access patterns. In contrast, a
    relational database typically relies on query optimization and table design to
    achieve optimal performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data consistency**: Unlike relational databases, non-relational databases
    may not enforce strict data consistency across multiple nodes in a distributed
    system. For example, in a document-based database, data may be replicated asynchronously,
    which could result in data inconsistencies. To address this challenge, non-relational
    databases often provide mechanisms to maintain eventual consistency, such as conflict
    resolution algorithms or read-after-write consistency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: Non-relational databases may have different security concerns
    than relational databases, such as preventing unauthorized access to specific
    documents or collections. For example, in a graph database, access control may
    need to be implemented at the node or edge level. In contrast, a relational database
    typically uses role-based access control at the database or table level.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s dive deeper into each of these points.
  prefs: []
  type: TYPE_NORMAL
- en: Data modeling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s review together three unique challenges around data modeling that are
    specific to non-relational databases.
  prefs: []
  type: TYPE_NORMAL
- en: Denormalization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In non-relational databases, it’s common to use denormalized data models where
    data is duplicated across multiple documents or collections. This is done to improve
    query performance and avoid expensive joins. In contrast, relational databases
    emphasize normalization, where data is organized into separate tables to avoid
    duplication and maintain data integrity.
  prefs: []
  type: TYPE_NORMAL
- en: Denormalization can introduce unique challenges around data consistency and
    update anomalies. When data is denormalized, it can lead to redundant or inconsistent
    data, which can be difficult to manage. For example, if a customer’s address is
    stored in multiple documents, updating the address in one document may not propagate
    to all the other documents, leading to inconsistent data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a denormalized data model in MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the book’s title and author are duplicated across multiple
    documents, and the book’s genres and reviews are stored as arrays within the same
    document. This makes it easier to retrieve all the relevant information about
    a book in a single query, but it also introduces the risk of inconsistent data
    if one of the reviews is updated or deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Nested and dynamic data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Non-relational databases are designed to handle nested and dynamic data structures,
    such as JSON or XML documents. This makes it easier to store and retrieve complex
    data structures, but it also introduces unique challenges around indexing and
    querying. In contrast, relational databases have fixed column definitions, which
    makes it more difficult to store and query nested or dynamic data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Nested data structures are common in non-relational databases, where data is
    stored as a hierarchical tree-like structure. Here’s an example of a nested document
    in MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `name` and `address` fields are nested within the document,
    which makes it easier to query and update data as a single entity. However, querying
    nested data can be challenging, as it requires traversing the entire tree to find
    the desired data. To address this, non-relational databases often use indexes
    to speed up queries on nested data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dynamic data structures are also common in non-relational databases, where
    data can have varying types and properties. For example, a document-based database
    such as MongoDB can store documents with different structures in the same collection.
    Here’s an example of a dynamic document in MongoDB:'
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `address` field is optional, and the document can contain
    any combination of the `name`, `age`, `email`, `phone`, and `address` fields.
    This flexibility can make it easier to store and retrieve data, but it also introduces
    challenges around data validation and indexing.
  prefs: []
  type: TYPE_NORMAL
- en: Data denormalization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Non-relational databases often use data denormalization to avoid expensive joins
    and improve query performance. Data denormalization involves duplicating data
    across multiple documents or collections so that related data can be retrieved
    together, without having to perform a join operation.
  prefs: []
  type: TYPE_NORMAL
- en: However, denormalization can introduce unique challenges around data consistency
    and update anomalies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of data denormalization in a document-based database:'
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `similar_books` field is denormalized, with the title and
    author of related books stored within the same document. This makes it easier
    to retrieve related data without performing a separate join operation, but it
    also introduces the risk of inconsistent data if one of the related books is updated
    or deleted.
  prefs: []
  type: TYPE_NORMAL
- en: To address these challenges, non-relational databases offer several features
    and techniques, such as schemaless design, document validation, indexing, and
    sharding.
  prefs: []
  type: TYPE_NORMAL
- en: Schemaless design means that non-relational databases do not require a predefined
    schema, which makes it easier to store and retrieve data with varying structures.
    Document validation can be used to ensure that data conforms to a specific schema,
    preventing inconsistencies and improving data quality.
  prefs: []
  type: TYPE_NORMAL
- en: Indexing can be used to speed up queries on nested and dynamic data, by creating
    indexes on specific fields or sub-fields. Sharding can be used to scale non-relational
    databases horizontally across multiple nodes, improving performance and availability.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, non-relational databases offer unique advantages and challenges
    around data modeling, compared to relational databases. While non-relational databases
    offer more flexibility and scalability, they also require a different approach
    to data modeling and management. DevOps teams working with non-relational databases
    need to be familiar with these unique challenges and techniques, ensuring that
    their infrastructure is stable and scalable.
  prefs: []
  type: TYPE_NORMAL
- en: Schema management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s review together three unique challenges around schema management that
    are specific to non-relational databases.
  prefs: []
  type: TYPE_NORMAL
- en: Schemaless data modeling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the main characteristics of non-relational databases is that they offer
    a schemaless data modeling approach. This means that they don’t enforce a fixed
    schema on the data and allow for flexible and dynamic data structures. While this
    can provide many benefits, such as faster iteration and easier scalability, it
    can also present some challenges in schema management.
  prefs: []
  type: TYPE_NORMAL
- en: In a schemaless database, there may not be a standard way to define or enforce
    the structure of data. This can make it difficult to ensure data consistency and
    quality across different documents. Additionally, it can be challenging to maintain
    compatibility and manage schema changes over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in a document-oriented database such as Couchbase, data can be
    stored in JSON documents with any arbitrary structure. Here’s an example of a
    JSON document:'
  prefs: []
  type: TYPE_NORMAL
- en: JSON
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the document has a top-level field called `type` that denotes
    the type of document, as well as a nested `address` field that represents a complex
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: To address the challenges of schemaless data modeling, non-relational databases
    provide features such as schema validation, which allows developers to define
    and enforce the structure of data. This can help ensure data consistency and quality
    across different documents.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic schema evolution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Non-relational databases also often allow for dynamic schema evolution, which
    means that a schema can change over time to adapt to new requirements or data
    models. This can present some challenges in schema management, especially if the
    schema changes are not carefully planned and managed.
  prefs: []
  type: TYPE_NORMAL
- en: In a dynamically evolving schema, the structure of the data can change frequently,
    which can make it challenging to maintain backward and forward compatibility.
    Additionally, it can be difficult to ensure that all documents conform to the
    latest schema version.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in a graph database such as Neo4j, the structure of data can change
    over time as new nodes and relationships are added. Here’s an example of schema
    evolution in Neo4j:'
  prefs: []
  type: TYPE_NORMAL
- en: Neo4j
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, an initial schema is created for a social network, with a `User`
    node and a `Post` node connected by a `POSTED` relationship. The `User` node does
    not have an `email` field.
  prefs: []
  type: TYPE_NORMAL
- en: To evolve the schema, a new `email` field is added to the `User` node, using
    the `ALTER` command. Additionally, a new label called `Article` is added to the
    `Post` node, and the `Post` label is removed using the `CREATE LABEL` and `REMOVE`
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: To address the challenges of dynamic schema evolution, non-relational databases
    provide features such as versioning and migration tools. These tools can help
    manage changes to the schema and ensure that all documents conform to the latest
    schema version.
  prefs: []
  type: TYPE_NORMAL
- en: Consistency and concurrency control
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another challenge in non-relational schema management is ensuring consistency
    and concurrency control in a distributed environment. Non-relational databases
    often use distributed architectures to achieve scalability and availability, which
    can create challenges in ensuring that data is consistent across different nodes.
  prefs: []
  type: TYPE_NORMAL
- en: In a distributed database environment, different nodes may have different versions
    of the same data, which can lead to conflicts and inconsistency. Additionally,
    concurrency control can be challenging in a distributed environment, as multiple
    nodes can access and update the same data simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in a key-value store such as Redis, concurrency control can be
    achieved through the use of optimistic locking. Here’s an example of optimistic
    locking in Redis:'
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the value of a counter is retrieved from Redis using the `get`
    method. The counter is then incremented using optimistic locking, which involves
    using the `watch` method to monitor the `counter` key for changes. If the `counter`
    key is modified by another process, the optimistic locking loop retries the transaction.
  prefs: []
  type: TYPE_NORMAL
- en: To address the challenges of consistency and concurrency control, non-relational
    databases provide features such as distributed locking, versioning, and conflict
    resolution. These features can help ensure that data is consistent and up to date
    across different nodes in a distributed environment.
  prefs: []
  type: TYPE_NORMAL
- en: Non-relational databases present unique challenges around schema management
    compared to relational databases. These challenges include schemaless data modeling,
    dynamic schema evolution, and consistency and concurrency control in a distributed
    environment. To address these challenges, non-relational databases provide features
    such as schema validation, versioning, migration tools, and distributed locking.
    DevOps teams working with non-relational databases need to be familiar with these
    unique challenges and techniques, ensuring that their infrastructure is stable
    and scalable.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deployment automation is an important aspect of DevOps for both relational and
    non-relational databases, but there are some unique challenges around deployment
    automation for non-relational databases. Here are three challenges specific to
    non-relational databases, along with explanations and code snippets.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment of multiple database engines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Non-relational databases often have different database engines, each with its
    own set of deployment and management requirements. For example, a NoSQL database
    such as Cassandra may have different deployment requirements than a document-oriented
    database such as MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying and managing multiple database engines can be challenging, as it requires
    specialized knowledge and expertise for each engine. Additionally, it can be difficult
    to maintain consistency across different database engines, especially if they
    have different APIs and query languages.
  prefs: []
  type: TYPE_NORMAL
- en: To address this challenge, DevOps teams may use configuration management tools
    such as Ansible or Chef to automate the deployment and management of different
    database engines. These tools allow for the automation of tasks such as installing
    software, configuring servers, and deploying databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of deploying Cassandra using Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: YAML
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, Ansible is used to add the Cassandra repository to the APT
    package manager, install the Cassandra package, and start the Cassandra service.
  prefs: []
  type: TYPE_NORMAL
- en: Backup and disaster recovery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Non-relational databases often require specialized backup and disaster recovery
    strategies, due to the different data structures and distributed architectures
    used by these databases. For example, a key-value store, such as Redis, may use
    a distributed architecture that requires different backup and recovery strategies
    than a document-oriented database, such as Couchbase.
  prefs: []
  type: TYPE_NORMAL
- en: Backing up and restoring data in a non-relational database can be complex, as
    it often involves managing data across multiple nodes and ensuring that it is
    consistent and up to date. Additionally, disaster recovery can be challenging
    in a distributed environment, as different nodes may have different versions of
    the same data.
  prefs: []
  type: TYPE_NORMAL
- en: To address this challenge, DevOps teams may use specialized backup and recovery
    tools for non-relational databases, such as the AWS Backup service for Amazon
    DynamoDB. These tools allow for the automated backup and recovery of data across
    different nodes, and they can help ensure data consistency and up-to-date backups.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of backing up and restoring data in DynamoDB using the AWS
    Backup service:'
  prefs: []
  type: TYPE_NORMAL
- en: AWS CLI
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'apiVersion: autoscaling/v2beta2'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: HorizontalPodAutoscaler'
  prefs: []
  type: TYPE_NORMAL
- en: 'metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: cassandra'
  prefs: []
  type: TYPE_NORMAL
- en: 'spec:'
  prefs: []
  type: TYPE_NORMAL
- en: 'scaleTargetRef:'
  prefs: []
  type: TYPE_NORMAL
- en: 'apiVersion: apps/v1'
  prefs: []
  type: TYPE_NORMAL
- en: 'kind: StatefulSet'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: cassandra'
  prefs: []
  type: TYPE_NORMAL
- en: 'minReplicas: 3'
  prefs: []
  type: TYPE_NORMAL
- en: 'maxReplicas: 10'
  prefs: []
  type: TYPE_NORMAL
- en: 'metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '- type: Resource'
  prefs: []
  type: TYPE_NORMAL
- en: 'resource:'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: cpu'
  prefs: []
  type: TYPE_NORMAL
- en: 'target:'
  prefs: []
  type: TYPE_NORMAL
- en: 'type: Utilization'
  prefs: []
  type: TYPE_NORMAL
- en: 'averageUtilization: 70'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: // Create an index on the Person node's name property
  prefs: []
  type: TYPE_NORMAL
- en: CREATE INDEX ON :Person(name)
  prefs: []
  type: TYPE_NORMAL
- en: // Query for all people with the name "Alice"
  prefs: []
  type: TYPE_NORMAL
- en: 'MATCH (p:Person {name: ''Alice''})'
  prefs: []
  type: TYPE_NORMAL
- en: RETURN p
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: // Create a table with a partition key and clustering columns
  prefs: []
  type: TYPE_NORMAL
- en: CREATE TABLE users (
  prefs: []
  type: TYPE_NORMAL
- en: id UUID PRIMARY KEY,
  prefs: []
  type: TYPE_NORMAL
- en: name TEXT,
  prefs: []
  type: TYPE_NORMAL
- en: email TEXT,
  prefs: []
  type: TYPE_NORMAL
- en: created_at TIMESTAMP
  prefs: []
  type: TYPE_NORMAL
- en: ) WITH CLUSTERING ORDER BY (created_at DESC)
  prefs: []
  type: TYPE_NORMAL
- en: // Query for all users with a specific email address
  prefs: []
  type: TYPE_NORMAL
- en: SELECT * FROM users WHERE email = 'example@example.com'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: // Get a value from the cache
  prefs: []
  type: TYPE_NORMAL
- en: var cachedValue = await redis.get('key');
  prefs: []
  type: TYPE_NORMAL
- en: // If the value is not in the cache, fetch it from the database and store it
    in the cache
  prefs: []
  type: TYPE_NORMAL
- en: if (cachedValue === null) {
  prefs: []
  type: TYPE_NORMAL
- en: var result = await db.query('SELECT * FROM my_table WHERE id = ?', [id]);
  prefs: []
  type: TYPE_NORMAL
- en: if (result.length > 0) {
  prefs: []
  type: TYPE_NORMAL
- en: cachedValue = result[0];
  prefs: []
  type: TYPE_NORMAL
- en: await redis.set('key', JSON.stringify(cachedValue), 'EX', 600);
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: console.log('Result is', cachedValue);
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: // Update the user's email address if the current email address matches the
    expected value
  prefs: []
  type: TYPE_NORMAL
- en: db.users.update(
  prefs: []
  type: TYPE_NORMAL
- en: '{ _id: ''123'' },'
  prefs: []
  type: TYPE_NORMAL
- en: '{ $set: { email: ''newemail@example.com'' } },'
  prefs: []
  type: TYPE_NORMAL
- en: '{ multi: false, upsert: false, writeConcern: { w: ''majority'' } },'
  prefs: []
  type: TYPE_NORMAL
- en: function(err, result) {
  prefs: []
  type: TYPE_NORMAL
- en: if (err) {
  prefs: []
  type: TYPE_NORMAL
- en: console.log(err);
  prefs: []
  type: TYPE_NORMAL
- en: '} else if (result.n === 0) {'
  prefs: []
  type: TYPE_NORMAL
- en: console.log('User not found');
  prefs: []
  type: TYPE_NORMAL
- en: '} else if (result.nModified === 0) {'
  prefs: []
  type: TYPE_NORMAL
- en: console.log('Update failed - email address did not match expected value');
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: console.log('Update successful');
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: // Create a Cassandra table with a quorum-based consistency level
  prefs: []
  type: TYPE_NORMAL
- en: CREATE TABLE users (
  prefs: []
  type: TYPE_NORMAL
- en: id UUID PRIMARY KEY,
  prefs: []
  type: TYPE_NORMAL
- en: name TEXT,
  prefs: []
  type: TYPE_NORMAL
- en: email TEXT,
  prefs: []
  type: TYPE_NORMAL
- en: created_at TIMESTAMP
  prefs: []
  type: TYPE_NORMAL
- en: ) WITH read_repair_chance = 0.2 AND dclocal_read_repair_chance = 0.1 AND CL
    = QUORUM
  prefs: []
  type: TYPE_NORMAL
- en: // Query for all users with a specific email address using a quorum-based consistency
    level
  prefs: []
  type: TYPE_NORMAL
- en: SELECT * FROM users WHERE email = 'example@example.com' AND CL = QUORUM
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: // Create a Riak bucket with consistent hashing enabled
  prefs: []
  type: TYPE_NORMAL
- en: curl -XPUT http://localhost:8098/buckets/my_bucket/props \
  prefs: []
  type: TYPE_NORMAL
- en: '-H ''Content-Type: application/json'' \'
  prefs: []
  type: TYPE_NORMAL
- en: '-d ''{ "props": { "consistent_hashing": true } }'''
  prefs: []
  type: TYPE_NORMAL
- en: // Store a value in the Riak bucket with a key
  prefs: []
  type: TYPE_NORMAL
- en: curl -XPUT http://localhost:8098/buckets/my_bucket/keys/my_key \
  prefs: []
  type: TYPE_NORMAL
- en: '-H ''Content-Type: application/json'' \'
  prefs: []
  type: TYPE_NORMAL
- en: '-d ''{ "value": "my_value" }'''
  prefs: []
  type: TYPE_NORMAL
- en: // Retrieve the value from the Riak bucket using consistent hashing
  prefs: []
  type: TYPE_NORMAL
- en: curl -XGET http://localhost:8098/buckets/my_bucket/keys/my_key \
  prefs: []
  type: TYPE_NORMAL
- en: '-H ''Content-Type: application/json'' \'
  prefs: []
  type: TYPE_NORMAL
- en: '-H ''X-Riak-Consistent-Hashing: true'''
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: // Create a user with a specific role in MongoDB
  prefs: []
  type: TYPE_NORMAL
- en: db.createUser({
  prefs: []
  type: TYPE_NORMAL
- en: 'user: ''myuser'','
  prefs: []
  type: TYPE_NORMAL
- en: 'pwd: ''mypassword'','
  prefs: []
  type: TYPE_NORMAL
- en: 'roles: [ { role: ''readWrite'', db: ''mydatabase'' } ]'
  prefs: []
  type: TYPE_NORMAL
- en: '});'
  prefs: []
  type: TYPE_NORMAL
- en: // Authenticate with MongoDB using the created user
  prefs: []
  type: TYPE_NORMAL
- en: db.auth('myuser', 'mypassword');
  prefs: []
  type: TYPE_NORMAL
- en: // Query for data in MongoDB using the authenticated user
  prefs: []
  type: TYPE_NORMAL
- en: db.my_collection.find({});
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: // Configure Redis to use a maximum memory limit of 1GB
  prefs: []
  type: TYPE_NORMAL
- en: maxmemory 1gb
  prefs: []
  type: TYPE_NORMAL
- en: // Enable Redis rate limiting for incoming requests
  prefs: []
  type: TYPE_NORMAL
- en: redis.config set lua-time-limit 1000
  prefs: []
  type: TYPE_NORMAL
- en: redis.config set maxmemory-samples 10
  prefs: []
  type: TYPE_NORMAL
- en: redis.eval("local c=redis.call('incr',KEYS[1]);if tonumber(c)==1 then redis.call('expire',KEYS[1],ARGV[1])
    end;return c",{1,"rate_limiter"},1)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: // Enable network-level encryption for Cassandra
  prefs: []
  type: TYPE_NORMAL
- en: 'server_encryption_options:'
  prefs: []
  type: TYPE_NORMAL
- en: 'internode_encryption: all'
  prefs: []
  type: TYPE_NORMAL
- en: 'keystore: /path/to/keystore.jks'
  prefs: []
  type: TYPE_NORMAL
- en: 'keystore_password: password'
  prefs: []
  type: TYPE_NORMAL
- en: 'truststore: /path/to/truststore.jks'
  prefs: []
  type: TYPE_NORMAL
- en: 'truststore_password: password'
  prefs: []
  type: TYPE_NORMAL
- en: 'client_encryption_options:'
  prefs: []
  type: TYPE_NORMAL
- en: 'enabled: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'optional: false'
  prefs: []
  type: TYPE_NORMAL
- en: 'keystore: /path/to/keystore.jks'
  prefs: []
  type: TYPE_NORMAL
- en: 'keystore_password: password'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: // Example of overusing denormalization in MongoDB
  prefs: []
  type: TYPE_NORMAL
- en: // Embedding order data within each product document
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"_id": "product123",'
  prefs: []
  type: TYPE_NORMAL
- en: '"name": "iPhone",'
  prefs: []
  type: TYPE_NORMAL
- en: '"description": "Apple iPhone 12 Pro",'
  prefs: []
  type: TYPE_NORMAL
- en: '"price": 999,'
  prefs: []
  type: TYPE_NORMAL
- en: '"orders": ['
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"_id": "order456",'
  prefs: []
  type: TYPE_NORMAL
- en: '"customer_id": "customer789",'
  prefs: []
  type: TYPE_NORMAL
- en: '"quantity": 2,'
  prefs: []
  type: TYPE_NORMAL
- en: '"price": 1998'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"_id": "order789",'
  prefs: []
  type: TYPE_NORMAL
- en: '"customer_id": "customer123",'
  prefs: []
  type: TYPE_NORMAL
- en: '"quantity": 1,'
  prefs: []
  type: TYPE_NORMAL
- en: '"price": 999'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: ']'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: // Example of underestimating data consistency in Cassandra
  prefs: []
  type: TYPE_NORMAL
- en: // Using low consistency levels for reads and writes
  prefs: []
  type: TYPE_NORMAL
- en: CREATE TABLE posts (
  prefs: []
  type: TYPE_NORMAL
- en: post_id UUID PRIMARY KEY,
  prefs: []
  type: TYPE_NORMAL
- en: user_id UUID,
  prefs: []
  type: TYPE_NORMAL
- en: text TEXT
  prefs: []
  type: TYPE_NORMAL
- en: );
  prefs: []
  type: TYPE_NORMAL
- en: INSERT INTO posts (post_id, user_id, text) VALUES (
  prefs: []
  type: TYPE_NORMAL
- en: uuid(), uuid(), 'Hello, world!'
  prefs: []
  type: TYPE_NORMAL
- en: ) USING CONSISTENCY ONE;
  prefs: []
  type: TYPE_NORMAL
- en: SELECT * FROM posts WHERE post_id = uuid() USING CONSISTENCY ONE;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: // Example of failing to secure the database in Elasticsearch
  prefs: []
  type: TYPE_NORMAL
- en: // Using default settings without authentication
  prefs: []
  type: TYPE_NORMAL
- en: curl -XPUT 'http://localhost:9200/my_index/my_type/1' -d '
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"name": "John Doe",'
  prefs: []
  type: TYPE_NORMAL
- en: '"age": 35,'
  prefs: []
  type: TYPE_NORMAL
- en: '"email": "john.doe@example.com"'
  prefs: []
  type: TYPE_NORMAL
- en: '}'''
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: // Example of overlooking performance tuning in Couchbase
  prefs: []
  type: TYPE_NORMAL
- en: // Using default settings without optimization
  prefs: []
  type: TYPE_NORMAL
- en: // Query for all shipments
  prefs: []
  type: TYPE_NORMAL
- en: SELECT * FROM shipments;
  prefs: []
  type: TYPE_NORMAL
- en: // Query for shipments with a specific status
  prefs: []
  type: TYPE_NORMAL
- en: SELECT * FROM shipments WHERE status = "delivered";
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: // Example of neglecting to plan for growth in DynamoDB
  prefs: []
  type: TYPE_NORMAL
- en: // Using a single partition key for all users
  prefs: []
  type: TYPE_NORMAL
- en: '{'
  prefs: []
  type: TYPE_NORMAL
- en: '"user_id": "1234567890",'
  prefs: []
  type: TYPE_NORMAL
- en: '"name": "John Doe",'
  prefs: []
  type: TYPE_NORMAL
- en: '"score": 1000,'
  prefs: []
  type: TYPE_NORMAL
- en: '"level": 5'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
