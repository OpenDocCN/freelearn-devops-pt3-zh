- en: '[*Chapter 6*](B17124_06_Final_SK_ePub.xhtml#_idTextAnchor122): AWS Networking
    Services – VPCs, Route53, and CloudFront'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Networking is a fundamental component of any IT infrastructure, whether on-premises
    on in the cloud. Without networking, it would not have been possible to architect
    the complex world of communications that we live in today. In the absence of networking,
    there would be no internet in the modern world.
  prefs: []
  type: TYPE_NORMAL
- en: Almost every business today needs to have some form of network connectivity
    if it is to collaborate with partners and end customers. In this chapter, we look
    at some of the core building blocks of designing a network. We will also look
    at network services offered on AWS and, specifically, how **Virtual Private Cloud**
    (**VPC**) enables customers to build multiple isolated and secure networks within
    their AWS accounts, allowing them to isolate workloads and applications.
  prefs: []
  type: TYPE_NORMAL
- en: We examine AWS Route53, which is Amazon's **Domain Name System** (**DNS**) that
    enables the routing of network traffic across the AWS ecosystem and the wider
    internet. Finally, we look at Amazon CloudFront, which is a **Content Delivery
    Network** (**CDN**), designed to help customers distribute their content to their
    customers much more effectively and with low latency.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the key topics we discuss in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to on-premises networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fundamentals of IP addressing, port numbers, subnet masks, and CIDRs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Amazon **VPC**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basics of DNS and global routing with Amazon Route53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation of a robust CDN with Amazon CloudFront
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to API Gateway
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete this chapter, you will need access to your AWS account. You will
    be creating a simple VPC in your AWS account for which you will need to be logged
    into your AWS account using the IAM user account `Alice` that we created in [*Chapter
    4*](B17124_04_Final_SK_ePub.xhtml#_idTextAnchor068), *Identity and Access Management*.
    Remember, to log in using an IAM user account, you will need to provide your AWS
    account ID or account alias.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to on-premises networks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Almost every business will have some form of an on-premises network. Even if
    you are a self-employed "one-man band," you are likely to have a home office that
    also boasts a private network environment. Your home office may look something
    like the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Home network components'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17124_06_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – Home network components
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, the devices on the home network communicate with each
    other over the Wi-Fi connection. If you send a print request from the computer
    desktop to the printer, then your document will get printed. This communication
    is made possible via the connectivity established over the Wi-Fi network. For
    devices to communicate with each other, they each require a unique IP address.
    If the IP addressing element is correctly defined, each device on the network
    will be able to see the other. The Wi-Fi service also connects the devices to
    the internet via a router/modem device that has established a connection with
    an internet service provider. This connection is usually via some form of physical
    cabling or cellular network connectivity through your telecom provider.
  prefs: []
  type: TYPE_NORMAL
- en: Basic corporate networks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Companies will also have their own corporate networks, and you have probably
    worked in an office setting that has an IT network infrastructure in place. Corporate
    networks require more careful planning since many of them will also allow access
    to applications from outside the network. For example, your business may be publishing
    a website from within the corporate network to showcase its products and services
    to potential customers on the internet. The use of firewall routers that allow
    only specific types of traffic to enter the network from the internet and be directed
    to the appropriate server is all part of the secure planning for connectivity
    with the outside world.
  prefs: []
  type: TYPE_NORMAL
- en: 'A corporate network would usually be divided into multiple smaller networks—each
    being used for a specific purpose. At its very basic level, a corporate network
    would consist of two subnetworks: one for internal backend purposes and another
    to place services that are accessible from the internet.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, a corporate network has been divided into two separate
    networks: one called the internal network, and another called the **demilitarized
    zone** (**DMZ**). The DMZ is an area where services are deployed that can be exposed
    on the internet, for example, a web server. Traffic to services deployed in this
    zone is restricted with strict inbound rules to ensure high levels of security.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Basic office network'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17124_06_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.2 – Basic office network
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding diagram, the corporate network is divided into three
    separate subnetworks. This ensures that we can configure rules that define the
    type of traffic that can enter each subnetwork and from which source. For example,
    we could configure inbound rules from the internet to grant access to our web
    servers over HTTP/HTTPS traffic. This will allow members of the public to access
    our corporate website and review our service offerings. On the other hand, we
    would not expect to allow direct inbound traffic from the internet into the **End
    User Computing** (**EUC**) **Virtual LAN** (**VLAN**), as there is no requirement
    for such inbound connection, and it ensures our corporate network is secure. Traffic
    from the workstations to the internet would, however, be permitted to allow members
    of staff to access online services and tools.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, when building solutions on AWS, we need to configure virtual networks
    in the cloud that would allow us to host our applications in a manner that offers
    security, isolation, and inbound access only where it is needed. However, before
    examining the details of how we build cloud networks, it is important to understand
    how devices on a network communicate with each other and how we create networks
    and subnetworks.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we review some fundamentals of IP addressing, which will
    enable us to understand how we build such networks.
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentals of IP addressing and CIDRs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For devices on your network to communicate with each other, an **Internet Protocol
    address** (**IP address**) is required. Each network device, whether it is a computer,
    laptop, mobile phone, printer, or network router, will need to be assigned an
    IP address that is routable in each network.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, each device's IP address must be unique – you cannot have more
    than one device with the same IP address. This is just how telephones work. Each
    telephone has a unique number assigned to it. To call someone on the phone, you
    need to first know their telephone number and then, dial that number, which results
    in your call getting connected. In *Figure 6.1*, you would have noticed that each
    of the internal devices in the home network had an IP address.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of IP address: IPv4 and IPv6\. We will discuss the key
    differences between them.'
  prefs: []
  type: TYPE_NORMAL
- en: IP address version 4 – IPv4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IPv4 was the first version of the IP addressing system that was widely deployed
    and that ultimately formed the backbone of the internet.
  prefs: []
  type: TYPE_NORMAL
- en: The standard IPv4 address format that you are familiar with and as depicted
    in the previous diagrams follows the structure of four decimal numbers separated
    by dots. An example of this is `192.168.1.6`. Each decimal notation in an IP address
    is called an `0` and `255`, base `10` (decimal). As you are probably aware, computers
    use binary numbers rather than decimal numbers. Each decimal number, when converted
    into binary, comprises 8 bits, ones and zeros. In both cases, whether decimal
    or binary, an IPv4 address is 32 bits in length.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take an example of an IP address of `192.168.1.6`. In binary, each octet
    would be between 8 zeros and 8 ones (`00000000` to `11111111`). The individual
    decimal numbers in the IP address can be converted to its equivalent binary representation,
    which would comprise a combination of ones and zeros in each 8-bit octet. In the
    following diagram, the IP address `192.168.1.6` in decimal is the same as `11000000.10101000.00000001.00000110`
    in binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – IP address to binary conversion'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17124_06_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.3 – IP address to binary conversion
  prefs: []
  type: TYPE_NORMAL
- en: While understanding how this conversion takes place is not a requirement to
    pass the Cloud Practitioner exam, I wanted to give you a quick overview here to
    further help you build your networking knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: Conversion of decimal notation into binary requires remembering the place value
    of the individual bits in each 8-bit octet. You can also calculate the place values
    if you do not want to simply remember them by heart.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take the example of the last octet in the IP address `192.168.1.6`, which
    in this case is the decimal number 6.
  prefs: []
  type: TYPE_NORMAL
- en: 'In binary, you have 8 bits of zeros and ones to represent this decimal number.
    In the following table, we can see each of those bits and their place values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – IP address place values'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17124_06_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.4 – IP address place values
  prefs: []
  type: TYPE_NORMAL
- en: 'For each octet, starting from right to left, the following applies:'
  prefs: []
  type: TYPE_NORMAL
- en: The first value of the first bit is always equal to `1`. It is `2` to the power
    of `0` (*2^0*), that is, `1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second bit is double the first bit and equals `2` (*2 to the power of 1*
    – that is, `2`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third bit is double the second bit and equals `4` (*2 to the power of 2*
    – that is, `4`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fourth bit is double the third bit and equals `8` (*2 to the power of 3*
    – that is, `8`) and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Calculating the decimal value of a binary representation is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Decimal = *(X*128) + (X*64) + (X*32) + (X*16) + (X*8) + (X*4) + (X*2) + (X*1)*
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, to convert the decimal number *6* from the IP address `192.168.1.6` into
    binary requires identifying which of the "Xs" should be converted to zeros and
    which to ones. You want to convert the minimum number of bits to ones to get your
    decimal representation, and furthermore, you should continue to convert only those
    bits to ones whose value is less than your decimal number. So, for example, as
    shown in *Figure 6.5, we have the following*:'
  prefs: []
  type: TYPE_NORMAL
- en: You would not convert the bit on the far left to a *1* because 128 is greater
    than the last octet, *6* in our IP address. Similarly, you would not convert the
    next bit from the far left to a *1* in binary because 64 is also greater than
    the last octet, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You would convert the third bit from the far right to a *1* because its placeholder
    value is equal to *4*, which is less than *6* in our IP address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You would also convert the second bit from the far right to a *1* because its
    placeholder value is equal to *2*, which is also less than *6* in our IP address.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that you want to convert the fewest bits to ones to get your decimal
    representation. So, in this case, *4* plus *2* equals the last octet, *6* in our
    IP address. As such, we should not convert the last bit to a *1* as the total
    would then add up to *7*, which is more than *6*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Converting an IP address to its equivalent binary representation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17124_06_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.5 – Converting an IP address to its equivalent binary representation
  prefs: []
  type: TYPE_NORMAL
- en: Hence, the binary representation of *6* is `00000110`. Similarly, converting
    the IP address `192.168.1.6` to binary would give you `11000000.10101000.00000001.00000110`.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of IPv4 addresses
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the primary limitations of an IPv4 address is that it is only 32 bits
    in length. This means that the maximum number of addresses you can have in an
    IPv4 addressing scheme is *2^32*, which is 4,294,967,294 addresses in total. Four-billion-odd
    addresses might seem like a large number, but the fact is that we have exhausted
    this range simply because of the vast number of devices that now need an IP address
    to participate on any given network.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, the largest network on the planet is the internet. Every device that
    needs to communicate on the internet also requires an IP address. Furthermore,
    every device on a given network must have a unique IP address. You cannot have
    two devices in the same network using the same IP address as this would result
    in a conflict. Given that the four-billion-odd addresses are not sufficient to
    handle the huge volumes of devices, the **Internet Assigned Numbers Authority**
    (**IANA**) devised a brilliant plan to allocate a range of IP address for private
    use only. These address ranges are not routable on the internet, which means that
    businesses (and homes) can configure their internal private networks using these
    addresses without any possibility of them conflicting with other businesses' networks,
    particularly if those businesses do not plan to connect their networks together.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following IP address ranges are designed for private use:'
  prefs: []
  type: TYPE_NORMAL
- en: '`10.0.0.0/8` IP addresses: `10.0.0.0 – 10.255.255.255`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`172.16.0.0/12` IP addresses: `172.16.0.0 – 172.31.255.255`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`192.168.0.0/16` IP addresses: `192.168.0.0 – 192.168.255.255`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Another range of private IP addresses is `169.254.0.0` to `169.254.255.255`,
    but those addresses are for **Automatic Private IP Addressing** (**APIPA**) use
    only, designed for internal Microsoft networks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The remaining addresses are considered public, and thus are routable on the
    global internet. To illustrate how this helps, let''s look at the next diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Private IP address ranges used by businesses'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17124_06_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.6 – Private IP address ranges used by businesses
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, you will note that the three companies are able to
    use the same IP addresses for their internal devices. Since these businesses are
    not connected to each other, there is no possibility of an IP address conflict.
    Private IP addresses such as the ones designated by the IANA have helped businesses
    build internal networks without the need to procure any of the public addresses.
    The private IP address space also enhances internal network security because these
    addresses are not routable on the internet. We can also allow more devices to
    be networked, as the address ranges can be repeated among companies that do not
    need to be connected to each other over the same network.
  prefs: []
  type: TYPE_NORMAL
- en: Businesses need internet access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding illustration, we see that businesses can define internal network
    IP address ranges that are not routable over the internet. These businesses will
    still require access to the internet, whether to send and receive emails from
    their customers or host e-commerce applications that their clients would need
    access to from the internet. To facilitate internet connectivity, public IP addresses
    are required. However, having to assign each device on the internet with a public
    IP address would defeat the purpose of private IP ranges and pose a security risk.
    Instead, the internal network can be configured to access the internet via a service
    called **Network Address Translation** (**NAT**).
  prefs: []
  type: TYPE_NORMAL
- en: In the following diagram, we can see that businesses are now able to access
    the internet via a NAT service configured on their external router. The NAT service
    requires a minimum of one single public IP address and relays requests from the
    internal devices to the internet, acting as a proxy in between. Replies to those
    requests are also handled by the NAT service, ensuring that they are correctly
    redirected to the internal device that made the original request.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Private IP address ranges used by businesses with internet via
    NAT services'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17124_06_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.7 – Private IP address ranges used by businesses with internet via
    NAT services
  prefs: []
  type: TYPE_NORMAL
- en: Given the limitation of IPv4, IPv6 was developed by the **Internet Engineering
    Task Force** (**IETF**) in the 1990s. We take a look at IPv6 next and discuss
    how it overcomes the 32-bit address limitation of IPv4.
  prefs: []
  type: TYPE_NORMAL
- en: What about IPv6?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To address the limitations of IPv4, IPv6 was developed by the IETF. IPv6 uses
    a 128-bit address, which would give us *2^128* addresses. IPv6 is also denoted
    in hexadecimal format rather than the standard decimal format. With IPv6, technically,
    each device could have its own public IP address. In fact, **Amazon Web Services**
    (**AWS**) offers IPv6 as an option to set up cloud networks. Even if you need
    to protect devices from the public internet, you can still use an IPv6 address
    for a virtual server in the cloud and allow it to send traffic over the internet
    using an egress-only internet gateway.
  prefs: []
  type: TYPE_NORMAL
- en: However, many companies continue to use IPv4, partly due to the capabilities
    of NAT services and partly to ensure interoperability with legacy devices that
    may not be IPv6-aware.
  prefs: []
  type: TYPE_NORMAL
- en: Network sizes and classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Originally, the IETF designed different classes of IPv4 addresses to help define
    different network sizes and use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Classes A to C represent generic unicast IP addresses (with a few exceptions)
    that members of the public can use to build networks of different sizes. Class
    D comprises multicast addresses, and class E has been reserved for experimental
    use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way these classes help define network sizes is by splitting the IP address
    into a network portion and a host portion. Let''s look at this individually by
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`1` (a one in binary) and host bits are denoted by `0` (zeroes). Also, the
    far-left bit of a class A address is set to `0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`10`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`11`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To better illustrate how these three classes of networks actually look, let''s
    look at the next diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.8 – IP address classes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17124_06_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.8 – IP address classes
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, you can identify which class a particular IP address
    belongs to and instantly identify the potential number of host IP addresses that
    IP block would have. So, for example, if we take the IP address `192.168.1.6`,
    we can confirm that it is a class C address.
  prefs: []
  type: TYPE_NORMAL
- en: What this means is that the network portion of the IP address is `192.168.1.x`.
    In this example, x can be any number between 1 and 254\. That gives you a total
    of 254 IP addresses in the host portion of the IP block. Although the total number
    of IP addresses you can have in any one octet is 256 (2^8, which equals 256),
    it is important to remember that the first and last IP addresses are unusable.
    The first IP address is always known as the network ID, which in this case is
    `192.168.1.``00000000`). The last IP address is `192.168.1.``11111111`).
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple formula to work out the number of usable IP addresses in an IP block
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Number of Usable IP Addresses = 2^Number of Host Bits - 2*'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, we have an IP address of `192.168.1.6`, which belongs
    to an IP block that can only contain 254 usable IP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: So far, you have taken our word for it that the IP address `192.168.1.6` belongs
    to a class C network and there are 254 IP addresses in the block of `192.168.1.x`.
    Let's look at how this works next, when we discuss subnet masks.
  prefs: []
  type: TYPE_NORMAL
- en: What are subnet masks?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Subnet masks allow you to split an IP address block into a network portion and
    a host portion. Host devices on the same network portion can easily talk to one
    another and will need some form of routing to talk to hosts in other networks.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding class C network, the first three octets belong to the network
    portion and only the last octet (last 8 bits) belongs to the host portion.
  prefs: []
  type: TYPE_NORMAL
- en: A subnet is a 32-bit number created by setting host bits to all zeroes and setting
    network bits to all ones. A logical `AND` operation is then performed with a corresponding
    IP address block to define the number of host IP addresses that can be available
    in each block.
  prefs: []
  type: TYPE_NORMAL
- en: So, for example, we can check that the IP address `192.168.1.6` belongs to a
    class C address because a class C masks the first three octets (first 24 bits
    in binary) as the network portion and leaves the last octet (last 8 bits) for
    the host bits.
  prefs: []
  type: TYPE_NORMAL
- en: 'In binary, the IP address `192.168.1.6` and its associated subnet mask are
    represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.9 – IP address and subnet mask conversion for 192.168.1.6'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17124_06_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.9 – IP address and subnet mask conversion for 192.168.1.6
  prefs: []
  type: TYPE_NORMAL
- en: 'A logical `AND` operation is calculated using the following process:'
  prefs: []
  type: TYPE_NORMAL
- en: A `0` and `0` equals `0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `0` and `1` equals `0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `1` and `0` equals `0`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `1` and `1` equals `1`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on the result of the preceding logical `AND` operation, you will note
    if any of the first three octets of the IP address were to change, for example,
    if instead of `192` we used `193`, then that would yield a different result for
    the corresponding logical `AND` operation block. Since the first three octets
    represent the network portion of an IP address, the resulting change would effectively
    denote a different network.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, because the host portion in the subnet mask is set to all zeroes
    and is only represented by the last octet (last 8 bits), any variation in this
    octet will keep the IP address within the same network.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s look at the IP address `192.168.1.12`. Depicting this in
    the following diagram while performing a logical `AND` operation with the subnet
    mask would yield the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.10 – IP address and subnet mask conversion for 192.168.1.12'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17124_06_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.10 – IP address and subnet mask conversion for 192.168.1.12
  prefs: []
  type: TYPE_NORMAL
- en: 'What you will note from the preceding two diagrams is that the logical `AND`
    operation yields the same pattern of binary numbers, indicating the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Both IP addresses belong to the same network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The network portion in both cases is the same, derived by the subnet mask of
    `255.255.255.0` (or `11111111 11111111 11111111 00000000`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know how subnet masks are used to *mask* portions of an IP address
    as a network portion and host portion, let's examine the concept of subnetting.
  prefs: []
  type: TYPE_NORMAL
- en: What is subnetting?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding discussion on subnet masks, we defined three classes of networks.
    The networks are derived by using subnet masks with fixed lengths to create these
    classes. So, for example, in a class A network, the first octet of an IP block
    represents the network portion and the remaining three octets the host portion.
  prefs: []
  type: TYPE_NORMAL
- en: This is made possible by using what we call subnet masks. Specifically, we use
    a subnet mask of `255.0.0.0` to carve off the first octet for the network portion.
    Any change in the first octet of an IP address with a subnet mask of `255.0.0.0`
    would yield a different network. For example, `10.0.0.0` is on a different network
    to `31.0.0.0`.
  prefs: []
  type: TYPE_NORMAL
- en: Subnetting is the process by which you can create subnetworks within a larger
    network. In each network, you may need to create smaller, isolated portions of
    the network, such as one portion for hosting all backend servers and another for
    hosting frontend web servers. Subnetting allows us to break up a large network
    into these smaller subnets.
  prefs: []
  type: TYPE_NORMAL
- en: The process of creating subnets involves *borrowing* additional bits from the
    host portion of an IP address range. These borrowed bits are used to create smaller
    subnetworks within a larger primary network.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we have a business requirement for eight subnetworks, each
    capable of hosting 30 IP addresses for 30 devices, then using a standard class
    C address, we could use the following IP blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Network 1 – `192.168.1.0` (subnet mask: `255.255.255.0`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Network 2 – `192.168.2.0` (subnet mask: `255.255.255.0`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Network 3 – `192.168.3.0` (subnet mask: `255.255.255.0`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Network 4 – `192.168.4.0` (subnet mask: `255.255.255.0`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Network 5 – `192.168.5.0` (subnet mask: `255.255.255.0`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Network 6 – `192.168.6.0` (subnet mask: `255.255.255.0`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Network 7 – `192.168.7.0` (subnet mask: `255.255.255.0`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Network 8 – `192.168.8.0` (subnet mask: `255.255.255.0`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While this network design works perfectly, we have a lot of wastage in terms
    of the number of IP addresses available versus the number of IP addresses required.
    Each of these eight networks contain 254 usable IP addresses, but we only need
    30 addresses per network as per the requirement.
  prefs: []
  type: TYPE_NORMAL
- en: When using private IP ranges, this may not matter so much, but when we consider
    applying the same approach to the limited public IP address range, it becomes
    impossible to achieve. Also, note that you generally must pay for public IPs.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of this approach, we can use subnetting and subnet masks to break up
    a single network into smaller networks, conserving and efficiently using the available
    IP address space within a given network.
  prefs: []
  type: TYPE_NORMAL
- en: So, for example, we can take the class C network of `192.168.1.0` with a subnet
    mask of `255.255.255.0` and break this up into smaller subnets. To do this, we
    borrow additional bits from the host portion of the IP address block to represent
    our subnets in the network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the next diagram to illustrate this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.11 – IP class C network'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17124_06_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.11 – IP class C network
  prefs: []
  type: TYPE_NORMAL
- en: In a standard class C network, the preceding IP address block of `192.168.1.0`
    with a subnet mask of `255.255.255.0` would yield a single network with 254 IP
    addresses.
  prefs: []
  type: TYPE_NORMAL
- en: This is because we have used the first three octets (24 bits) to represent the
    network portion and the last octet (8 bits) to represent the host portion.
  prefs: []
  type: TYPE_NORMAL
- en: Because we have 8 bits to represent host bits, we can use the formula 2^8, which
    equals 256\. However, remember the first and last IP addresses are not usable,
    so that is 256-2, which gives us 254 usable IP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now if we borrow the first 3 bits from the host portion of the IP address block
    to build subnetworks, we will have the following representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.12 – Creating subnets by borrowing bits from the host portion of
    the IP address'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17124_06_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.12 – Creating subnets by borrowing bits from the host portion of the
    IP address
  prefs: []
  type: TYPE_NORMAL
- en: 'By borrowing 3 bits from the far left of the fourth octet (the host portion),
    we can effectively create eight subnet networks. This is derived by the following
    formula:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Number of subnets = 2^number of host bits borrowed*'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, *2^3 = 8* and so, this gives us 8 subnetworks. Furthermore, because
    we now only have 5 bits remaining to represent the host portion, we can work out
    the number of IP addresses we have per subnetwork. The formula is *Number of Hosts
    = 2^Number of Host Bits Remaining*. In this case, it is *2^5* (because there are
    5 remaining host bits) = 32 IP addresses. In addition, as previously discussed,
    the first and the last IP addresses are not usable and as a result, we subtract
    2 from the number of IP addresses (32-2), which gives us our 30 IP addresses,
    as required.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look at the subnet mask representation of the borrowed 3 bits, we will
    have a new subnet mask as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13 – Creating subnets resulting in a new subnet mask'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17124_06_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.13 – Creating subnets resulting in a new subnet mask
  prefs: []
  type: TYPE_NORMAL
- en: Using a subnet mask of `255.255.255.224`, we can see that we have eight individual
    subnetworks that can be created.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14 – Creation of eight subnetworks'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17124_06_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.14 – Creation of eight subnetworks
  prefs: []
  type: TYPE_NORMAL
- en: 'You will note the pattern difference in the IP blocks shown in binary. Specifically,
    the different combination of *ones* and *zeros* in the borrowed bits define the
    eight different networks. The following IP address blocks are the eight subnetworks
    that can be created by borrowing 3 bits from the host portion of the IP address
    block `192.168.1.0`. Each subnetwork has 30 usable IP addresses. The eight networks
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`192.168.1.0 (192.168.1.0 to 192.168.1.31)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`192.168.1.32 (192.168.1.32 to 192.168.1.63)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`192.168.1.64 (192.168.1.64 to 192.168.1.95)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`192.168.1.96 (192.168.1.96 to 192.168.1.127)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`192.168.1.128 (192.168.1.128 to 192.168.1.159)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`192.168.1.160 (192.168.1.160 to 192.168.1.191)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`192.168.1.192 (192.168.1.192 to 192.168.1.223)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`192.168.1.224 (192.168.1.224 to 192.168.1.255)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using subnet masking, you are then able to identify which network a particular
    IP address block belongs to. So, for example, the IP address `192.168.1.130` would
    belong to the IP block `192.168.1.128` with a subnet mask of `255.255.255.224`.
    This is made clearer when we look at the binary representation and perform the
    logical `AND` operation, as shown in the following diagram. You can see that the
    results of the logical `AND` operation match IP address block 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15 – Illustrating how IP addresses fall in a given subnetwork range'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17124_06_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.15 – Illustrating how IP addresses fall in a given subnetwork range
  prefs: []
  type: TYPE_NORMAL
- en: This binary depiction and logical `AND` operation show how IP address block
    5 falls in the same network as IP address block 1, as shown in the yellow cells.
  prefs: []
  type: TYPE_NORMAL
- en: Classless Interdomain Routing (CIDR)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instead of using subnet masks and the complexity discussed previously, we can
    use CIDR. With CIDR, you can create networks of different sizes like how you use
    subnet masks. CIDR is essentially another way to represent subnet masks but offers
    more flexibility. The size of your network will determine how many IP addresses
    you can have in that network. You can also divide your network into multiple smaller
    networks (subnets) by configuring specific subsets of the IP block using CIDR
    blocks.
  prefs: []
  type: TYPE_NORMAL
- en: When defining a network, CIDR blocks are displayed as part of the IP address
    block with a slash (/) followed by a decimal number between `/8` and `/32`. For
    example, the IP address `192.168.1.6` could belong to a network `192.168.1.0/24`.
    Let's look at how this works.
  prefs: []
  type: TYPE_NORMAL
- en: In a network with a CIDR block of `/24`, we can work out the number of IP addresses
    that the network can host and therefore, the number of devices that can be placed
    in the network. Given that the total number of bits in an IPv4 range is 32, then
    for a `/24` CIDR, we simply subtract the 24 from 32, which gives us 8 bits. These
    8 bits represent the total number of IP addresses we can have in that network.
    Specifically, *2^8* equals 256\. So, the total number of IP addresses in network
    `192.168.1.0/24` is 256 IP addresses. Remember, that on any given network, the
    first and last IP addresses are not usable. So, the total number of usable IP
    addresses is 256 - 2, which equals 254.
  prefs: []
  type: TYPE_NORMAL
- en: An important point to note here is that the IP network with a CIDR block of
    `192.168.1.0/24` is one single network and within this network, you can host up
    to 254 devices that would each need an IP address. The IP address range would
    be from `192.168.1.1` to `192.168.1.254` (remember that the first IP `192.168.1.0`
    and the last IP `192.168.1.255` are not usable).
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at another example. We will use the IP range of `10.0.0.0` to `10.0.255.255`,
    which is a private range for our internal network. Let's say that you choose a
    network IP with a CIDR block of `10.0.0.0/16`. In this network, your CIDR block
    is a `/16`. In this network, you can have a total of 65,536 IP addresses. Remember
    that to work out the number of IP addresses, you must subtract the value of 32
    from the CIDR block notation, in this case, 16\. This gives you 16 bits that can
    be used by devices in your network. Two to the power of *16 (2^16)* equals 65,536
    IP addresses. Remember to subtract another 2 from the total number of IP addresses,
    which gives you a total number of 65,534 usable IP addresses. This is a very large
    network, and you may wish to divide this larger network into smaller subnetworks
    (subnets) for resource isolation and separation. Using the same network IP block,
    you can create subnetworks by increasing the CIDR block value. For example, in
    the primary network of `10.0.0.0/16`, you can create several subnetworks using
    the CIDR block of `/20`. This means that you have 12 bits remaining for the hosts
    portion of your IP address block (32 bits – 20 bits for the network).
  prefs: []
  type: TYPE_NORMAL
- en: So, within the `10.0.0.0/16` network, you can have subnetworks with the IP block
    of `10.0.0.0/20`. Each subnetwork would have a total of 4,096 IP addresses (*2^12*
    hosts bits remaining) or 4,094 usable IP addresses (subtracting the 2 IPs that
    cannot be used).
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have looked at how IP addresses are configured and how they can be
    represented in both binary and decimal notation.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at how you can create a large network and subsequently, multiple
    smaller networks using CIDR blocks.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we start to look at VPCs, which are virtual networks you
    can build on AWS similarly to how you would define networks on-premises. Many
    services require a VPC within which you can launch resources. VPCs also help you
    protect your resources through firewall technologies, which we will also discuss
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual Private Clouds (VPCs)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A VPC is a virtual network in the cloud. You choose the Region in which to create
    your VPC and define its network parameters such as the IP address range and any
    subnetworks within it, for resource isolation.
  prefs: []
  type: TYPE_NORMAL
- en: Resources deployed in your VPC can then access services on the internet or can
    grant inbound access from the internet, for example, if you are hosting an e-commerce
    web server.
  prefs: []
  type: TYPE_NORMAL
- en: AWS already provides you with a default VPC in each Region. These default VPCs
    are designed to get you up and running with the ability to deploy EC2 instances
    so that they can access the internet and, where necessary, be configured to allow
    direct inbound access from the internet.
  prefs: []
  type: TYPE_NORMAL
- en: You can also configure custom VPCs to suit your business requirements. When
    configuring a new VPC, you need to define an IP address block from one of the
    private IP ranges. Your VPC spans the entire Region in which you deploy it. This
    means that you can place workloads in different Availability Zones within the
    VPC to design for high availability.
  prefs: []
  type: TYPE_NORMAL
- en: All about subnets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Depending on your requirements, you can configure your non-default VPCs with
    multiple subnetworks (subnets).
  prefs: []
  type: TYPE_NORMAL
- en: A subnet is a subset of the VPC, and this is defined in the IP address block
    of the subnet. So, for example, if the IP address block of your VPC is `10.0.0.0/16`,
    public `Subnet-1` could be configured with a network IP address CIDR block of
    `10.0.1.0/24`. Each subnet you define in each VPC would also need to be configured
    with non-overlapping subsets of IP ranges from your primary VPC's IP address block.
    So, for example, if you build another subnet, say `Subnet-2`, you could use an
    IP address CIDR block of `10.0.2.0/24`.
  prefs: []
  type: TYPE_NORMAL
- en: The IP address CIDR block of `Subnet-1` (`10.0.1.0/24`) and the IP address CIDR
    block of `Subnet-2` (`10.0.2.0/24`) as shown in *Figure 6.8* are not overlapping.
    Nevertheless, both `Subnet-1` and `Subnet-2` belong to the same VPC's IP address
    CIDR block of `10.0.0.0/16`. This is because the IP address CIDR blocks of both
    the subnets are direct subsets of the VPC's IP address CIDR block.
  prefs: []
  type: TYPE_NORMAL
- en: Subnets are also restricted to a single Availability Zone. This means you can
    recreate multiple subnets across multiple Availability Zones, which would host
    replica resources to offer high availability. If a single Availability Zone (and
    therefore, the subnet contained within) were to go offline, you can redirect traffic
    to a replica resource in the alternative subnet that resides in another Availability
    Zone. The following diagram shows two subnets, one in each Availability Zone,
    that belong to the VPC. If `Subnet-1` were to go offline due to an Availability
    Zone outage, requests can still continue to be served by the database instance
    in `Subnet-2.`
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16 – VPCs and subnets with non-overlapping IP addresses'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17124_06_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.16 – VPCs and subnets with non-overlapping IP addresses
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, we have deployed two database instances across two
    subnets within two Availability Zones.
  prefs: []
  type: TYPE_NORMAL
- en: Internet access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, your custom VPCs need to be configured with internet access if you
    want the EC2 instances in the VPC to send traffic to the internet. Furthermore,
    if you deploy servers that require direct inbound access from the internet, then
    you need to deploy them in subnets that have a direct route to the internet.
  prefs: []
  type: TYPE_NORMAL
- en: As depicted in *Figure 6.9*, you can define which subnetworks have direct access
    to the public internet, called public subnets (for example, the DMZ) and which
    subnets are private, called private subnets (for backend operations).
  prefs: []
  type: TYPE_NORMAL
- en: To configure a VPC with internet access, you need to deploy an internet gateway.
    This is a free component that can be attached to your VPC to grant the VPC internet
    access. In addition, you would need to configure route tables associated with
    the public subnet to have direct access to the internet gateway. EC2 instances,
    which are then deployed in the public subnet, can send traffic to the internet
    and be configured to receive direct inbound traffic from the internet. An additional
    requirement, however, is that your EC2 instances in the public subnet must also
    have a public IP address. This can be dynamically assigned by AWS to the EC2 instances.
    Note that the public IP address is dynamic, which means that if the EC2 instance
    is stopped and then restarted, the IP address is likely to change. In most cases,
    this is acceptable because you generally will place your EC2 instances behind
    a load balancer (a service we discuss in a later chapter). However, if you need
    a static public IP address – one that does not change – then you can configure
    your EC2 instances with an elastic IP address.
  prefs: []
  type: TYPE_NORMAL
- en: Elastic IP addresses are static and remain in your account until you release
    them. They are ideally suited for those EC2 instances that must always have the
    same public IP address over time. Elastic IP addresses can also be reassigned
    from one EC2 instance to another. This can be helpful if, for example, an EC2
    instance fails, and you need to spin up a new server as a replacement that must
    have the same IP address. Elastic IP addresses, therefore, can help you design
    for the high availability of services by automatically being reassigned to a standby
    EC2 instance in case of a failure on the primary EC2 instance.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of cost, it is important to remember that elastic IP addresses are
    free only while they are associated with an EC2 instance that is in the running
    state. If you have an EC2 instance in the stopped (shutdown) state, you will incur
    charges for that elastic IP address on an hourly basis. The following diagram
    illustrates how traffic from the internet can be routed to web servers deployed
    in public subnets of the VPC. Note that in this case, the web servers would also
    need public IP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17 – VPCs and public and private subnets'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17124_06_17.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.17 – VPCs and public and private subnets
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, if Availability Zone 1A were to have a major outage,
    our users can be redirected to the web servers in public `Subnet-2` of Availability
    Zone 1B and continue operations.
  prefs: []
  type: TYPE_NORMAL
- en: VPC security
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the primary reasons for building a VPC on AWS is to implement firewall
    security to ensure that access to the resources deployed within the VPC is carefully
    managed. For example, some resources, such as web servers, would require inbound
    access from members of the public on the internet. By contrast, if an application
    running on those web servers needed to update a backend database (for example,
    confirmation of customer orders), then you would want to ensure that only the
    web servers can make those updates to the backend database. You would not want
    members of the public to have direct access to the backend databases.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon offers two types of security service to enable you to build a highly
    secure environment, ensuring that only the required level of access and traffic
    is permitted.
  prefs: []
  type: TYPE_NORMAL
- en: Security groups
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A security group is a firewall that is designed to allow you to configure what
    type of traffic you permit, inbound and outbound, to your EC2 instances. When
    you launch an EC2 instance, you must assign at least one security group to it,
    which must contain the necessary rules for any inbound and outbound traffic you
    wish to allow. Note that you can associate up to five security groups with an
    instance. Security groups act at the instance level and not the subnet level.
  prefs: []
  type: TYPE_NORMAL
- en: Each VPC comes with a default security group that allows all traffic inbound,
    *but only where the source of that traffic is the security group itself*. This
    means that if you have two EC2 instances associated with the same security group,
    then one EC2 instance will accept traffic initiated by the other EC2 instance.
    In addition, all outbound traffic to any destination is permitted. This means
    that an EC2 instance associated with the default security group can initiate communication
    outbound. This is based on the idea that you can trust your EC2 instances to make
    any necessary outbound requests, for example, to download operating system updates.
  prefs: []
  type: TYPE_NORMAL
- en: However, security groups do not allow any traffic to inbound from other sources
    (other than itself) until you create necessary rules. This is to prevent any unsolicited
    traffic reaching your instance. So, if you are configuring a web server that needs
    to serve web pages on the standard HTTP protocol, then you would need to configure
    an appropriate inbound rule for HTTP and specify the source of the traffic in
    terms of an IP address range. In addition to the default security group, you can
    also create your own security groups.
  prefs: []
  type: TYPE_NORMAL
- en: An important feature to consider about security groups is that even though you
    may not have configured any inbound rules, response traffic to any outbound requests
    will be permitted inbound by the security group. Conversely, if you configured
    any inbound rules, responses to any inbound traffic that are allowed in because
    of those rules are permitted outbound regardless of any explicit outbound rules.
    This feature is what makes security groups **stateful**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some additional key features include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: You can configure *allow* rules, but you cannot configure explicit *deny* rules.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can specify separate rules for inbound and outbound traffic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can filter traffic based on protocols and port numbers. You can also specify
    sources and destinations that can be other security groups, thus offering a layered
    security approach.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security groups therefore protect your EC2 instances and enable you to define
    what inbound traffic you will allow to the instances.
  prefs: []
  type: TYPE_NORMAL
- en: Network Access Control Lists (NACLs)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: NACLs are another type of firewall service that are designed to protect entire
    subnets. Rather than offer protection at the instance level, they can be configured
    to allow or deny traffic from reaching subnets, within which you deploy your EC2
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: A default NACL is configured in every VPC, which is configured to allow all
    inbound and outbound traffic. This is acceptable because traffic must still be
    permitted via security groups, which, by default, block all inbound connections.
  prefs: []
  type: TYPE_NORMAL
- en: Incidentally, you can configure your subnets with custom NACLs, which, by default,
    block both inbound and outbound traffic, and additional configuration will be
    required to create any necessary inbound and outbound rules.
  prefs: []
  type: TYPE_NORMAL
- en: NACLs are also stateless, meaning that you have to configure both the inbound
    rules and corresponding outbound rules for traffic to flow and be responded to.
  prefs: []
  type: TYPE_NORMAL
- en: Network Address Translation (NAT)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the start of this chapter, we discussed how a typical corporate network is
    usually divided into smaller subnetworks. Certain resources will be deployed in
    the DMZ (called public subnets on AWS) and others will be deployed in backend
    private subnets. By deploying resources in a private subnet, we ensured that there
    was no direct connection to them from the public internet. Such resources include
    database servers or application servers that should be accessible only via frontend
    web services or load balancers. This ensures that any traffic to those backend
    services is proxied via those frontend web services and without exposing them
    on the public internet.
  prefs: []
  type: TYPE_NORMAL
- en: Application servers may, however, require access to the internet, for example,
    to download product updates or patches. Since these servers will not have a public
    IP address and will be placed in private subnets, we need a mechanism for them
    to access the internet and to allow inbound responses to those servers. To fulfill
    this requirement, we can set up and configure a NAT service. As depicted in *Figure
    6.10*, this NAT service needs to be placed in the public subnet of your VPC and
    have an elastic IP address attached to it. Your route table is then configured
    with a rule to allow internet-bound traffic from EC2 instances in the private
    subnets to access the internet via this NAT service. The NAT service relays requests
    from the EC2 instances in the private subnet to the internet, acting as a proxy.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, if you need to enable EC2 instances with private IPv4 address access
    to the internet without directly exposing them on the internet (for example, with
    a public IP address), then on AWS, you can configure a NAT gateway to relay internet
    requests on behalf of those devices.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using IPv6, as discussed earlier in this chapter, and you want to
    ensure that EC2 instances with IPv6 can access the internet without being directly
    exposed on the internet, you need to route traffic from those instances via an
    **egress-only internet gateway**.
  prefs: []
  type: TYPE_NORMAL
- en: VPC peering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A VPC peering connection is a private network connection between two VPCs. The
    service allows you to connect multiple VPCs so that instances in one VPC can access
    resources in another VPC. This means that traffic between VPCs over a peering
    connection does not traverse the public internet and offers greater levels of
    bandwidth, as well as security. Furthermore, the connections between the peers
    are highly available and there is no single point of failure.
  prefs: []
  type: TYPE_NORMAL
- en: You can create VPC peering connections between VPCs in one AWS account or between
    AWS accounts. Peering connections can also be configured between VPCs in the same
    Region or across different Regions. This means that if you have VPCs across different
    Regions, for example, to facilitate the deployment of resources closer to your
    global branch offices, those resources can access each other across Regions.
  prefs: []
  type: TYPE_NORMAL
- en: VPC transit gateway
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier, we discussed how VPC peering can help you connect multiple VPCs together.
    The problem with VPC peering, however, is that every VPC must establish a one-to-one
    connection with its peer. Once the connections have been established, you also
    need to configure your route tables in each of the peered VPCs to direct appropriate
    traffic across the peering connection. If you have multiple VPCs that need to
    connect to each other, it can become very difficult to manage the individual connections
    and numerous route table entries.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, you will note the complexity of the various peering
    connections to connect each VPC:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.18 – Multiple VPC peering connections'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17124_06_18.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.18 – Multiple VPC peering connections
  prefs: []
  type: TYPE_NORMAL
- en: With AWS Transit Gateway, you can connect your individual VPCs together via
    the gateway in a hub-and-spoke model. This greatly simplifies your network architecture,
    as each new VPC that is peered to the gateway needs just a single connection to
    be able to route traffic to the other VPCs, as long as necessary route table configurations
    permit it to do so.
  prefs: []
  type: TYPE_NORMAL
- en: 'This simplified model is depicted in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.19 – AWS Transit Gateway'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17124_06_19.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.19 – AWS Transit Gateway
  prefs: []
  type: TYPE_NORMAL
- en: Transit gateways help to reduce the architectural design overhead when trying
    to connect many VPCs together. Transit gateways achieve this design by using a
    hub-and-spoke architectural model.
  prefs: []
  type: TYPE_NORMAL
- en: Virtual Private Networks (VPNs)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Your VPC is hosted on the AWS platform. You can deploy various resources within
    your VPC, which you can access via the public internet, if you configure an internet
    gateway and the necessary security groups and NACLs. However, you can also connect
    your VPC to your corporate network (on-premises or a co-location data center).
    This type of connection is known as VPN. A VPN is a secure encrypted site-to-site
    tunnel established between two endpoints over the public internet. It offers AES
    128 or 256-bit **Internet Protocol security (IPsec)** encryption, which means
    that you can transfer data between the two endpoints securely.
  prefs: []
  type: TYPE_NORMAL
- en: To set up a VPN connection between your on-premises network and the VPC, you
    need to create a **Virtual Private Gateway** (**VPG**) and attach it to your VPC.
    You will also need to configure a customer gateway, which is a physical or virtual
    device located in the on-premises network that connects to the VPG over the internet.
    The setup is illustrated in *Figure 6.12*.
  prefs: []
  type: TYPE_NORMAL
- en: AWS supports a wide range of customer gateway devices, including Cisco, Juniper,
    and Check Point devices. Once the VPN connection has been established, you still
    need to configure your route tables on both the internal network and the VPC to
    direct appropriate traffic over the tunnel, as required.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.20 – Amazon VPNs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17124_06_20.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.20 – Amazon VPNs
  prefs: []
  type: TYPE_NORMAL
- en: While VPN connections enable you to encrypt traffic between the local network
    and the VPC, as depicted by the diagram, the bandwidth is limited to what your
    internet service provider offers. Furthermore, on AWS, there is a hard limit of
    1.26 Gbps. With a VPN connection you are also dependent on the routing mechanism
    of the public internet. If you require a more dedicated connection that bypasses
    the public internet altogether, then Amazon offers a service called Direct Connect,
    which we will look at next.
  prefs: []
  type: TYPE_NORMAL
- en: Direct Connect
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Direct Connect** is a service that enables you to connect your corporate
    data center to your VPC and the public services offered by AWS via a dedicated
    private connection that bypasses the internet altogether.'
  prefs: []
  type: TYPE_NORMAL
- en: This is a more expensive solution than standard VPN setups due to the requirement
    to lay down necessary fiber optic cabling between your corporate office (or data
    center) and a local Amazon Direct Connect partner. Nevertheless, the service can
    offer dedicated links that operate at 1 Gbps, 10 Gbps, and up to 100 Gbps. Direct
    Connect thus gives you ultra-high-speed connectivity as well as a secure private
    connection.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we examined the core features and components of Amazon VPCs.
    VPCs enable you to build secure, isolated network areas within the AWS cloud that
    can be configured to allow only authorized connections into them. VPCs offer two
    types of firewall solutions – security groups and NACLs. The former can be configured
    to allow only specific types of traffic and acts as a firewall at the instance
    level, whereas the latter protects the entire subnet. Security groups are stateful,
    whereas NACLs are stateless; however, NACLs also provide the ability to deny specific
    types of traffic from specific sources. For example, if you host a web server
    and want to allow public access to the server from the internet, but also want
    to block access from a certain IP range (perhaps because you have discovered a
    potential attack from that range), NACLs can help you configure necessary deny
    rules as well.
  prefs: []
  type: TYPE_NORMAL
- en: You can use both NACLs and security groups to build a layered, secure architecture.
    NACLs will protect your entire subnets by letting you explicitly define the type
    of traffic that can enter the subnet. Next, you define security groups for different
    groups of EC2 instances that may reside in a subnet, ensuring that only the necessary
    traffic is permitted to connect to the application running on those EC2 instances.
  prefs: []
  type: TYPE_NORMAL
- en: We then examined features such as VPC peering, AWS Transit Gateway, VPN connections,
    and the Direct Connect service. In the next section, we will learn about the AWS
    global DNS, Amazon Route53\. AWS Route53 enables you to direct traffic to resources
    both in your VPC and on the public internet using DNS name resolution, but also
    helps you shape traffic for high availability and fault tolerance.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about DNS and global routing with Amazon Route53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS Route53 is Amazon's global DNS, which is a service to help translate human-readable
    names into an IP address because, ultimately, computers connect to each other
    over IP addresses. DNS servers across the internet host billions of such name-to-IP
    address records, among other types of records. When you use your favorite browser
    to visit a particular website, such as `example.com`, your browser sends a request
    to your local DNS service provider, which, if necessary, refers the query to that
    domain's (`example.com`) authoritative DNS server. This authoritative DNS server
    responds with the IP address of the website you are trying to access, and your
    browser is then able to establish a connection with the website (in this case,
    `example.com`). This process of translating domain names to IP addresses is called
    name resolution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Amazon Route53 offers three primary functions:'
  prefs: []
  type: TYPE_NORMAL
- en: Domain registration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DNS routing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Health checks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at each of the functions next.
  prefs: []
  type: TYPE_NORMAL
- en: Domain registration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you can use a domain name for your website or web application that members
    of the public can access, you need to register a name of your choice with a domain
    registrar. Amazon Route53 offers complete domain name registration services. When
    you choose a name to register, you do so under a `.com`, `.co.uk`, `.org,` or
    `.net`. If the name of your choice under a particular TLD is not available, you
    can try a different TLD. For example, if `example.com` is not available because
    someone else has already registered it, then you can try `example.co.uk` or `example.net`.
    There are hundreds of TLD names to choose from.
  prefs: []
  type: TYPE_NORMAL
- en: As part of the registration, you purchase a lease duration for your domain name,
    which can be from anywhere between 1 year and 10 years. You need to renew this
    lease before expiry, or you risk someone else registering the name, which will
    affect your ability to offer your web services using the same domain name.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have registered your domain name, you then need to host it with a DNS
    hosting service provider. Often, the registration and hosting service is offered
    by the same company, in this case, Amazon Route53\. The hosting service offers
    you the ability to create resource records for your domain, for example, configuring
    the domain name to point to an IP address of a web server. When users on the internet
    type the domain name in their browser, they are directed to your web server, which
    hosts your website.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several types of resource records you can create. Some types of resource
    records are displayed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 6.1 – Example resource records for iaasacademy.com'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_6.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 6.1 – Example resource records for iaasacademy.com
  prefs: []
  type: TYPE_NORMAL
- en: When configuring your domain names, you also need to define a zone file, which
    will host resource records for your domain name. It is in a zone file that you
    would create resource records, such as the A record, which are standard name-to-IP
    address resolution records. Next, we look at how zone files are created on AWS
    Route53.
  prefs: []
  type: TYPE_NORMAL
- en: Hosted zones
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create the necessary resource records for your domain name, you need to set
    up a hosted zone on Route53\. A hosted zone is a container that is used to store
    and manage your resource records and allows you to define how traffic is routed
    for your domain (`example.com`) and any sub-domains (such as `portal.example.com`).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of hosted zones you can set up on Route53:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://bucket-name.s3-website-Region.amazonaws.com`. You could provide this
    S3 website endpoint URL to your users to access your web pages that are hosted
    on the S3 bucket. However, a much better option would be to create an alias record
    that points your company domain name (`example.com`) to the S3 website endpoint.
    Your users would find it much easier to remember your domain name than the original
    S3 endpoint name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`devserver.example.com` that points to an EC2 instance within your VPCs, which
    other resources in the VPC may need to connect to. This is a much better option
    than having to remember IP addresses of your EC2 instances and means you do not
    need to hardcode those IP addresses in your application code, which can become
    difficult to manage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DNS hostnames
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'AWS provides a DNS server (Amazon Route53 Resolver) for your VPC. This enables
    AWS to configure DNS hostnames for the instances you deploy in your VPC. DNS hostnames
    comprise a hostname and a domain name, such as `myserver.mycompany.com`. DNS hostnames
    enable you to create unique names for your EC2 instances. In addition, AWS provides
    two types of DNS hostnames:'
  prefs: []
  type: TYPE_NORMAL
- en: '`private-ipv4-address` is the reverse lookup IP address.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Public DNS hostnames** – These resolve a public DNS hostname to the public
    IPv4 address of the instance outside the network of the instance, and to the private
    IPv4 address of the instance from within the network of the instance. The DNS
    hostname can take one of the following two forms, depending on the Region:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: While Route53 offers a fully functional DNS, it also enables you to design how
    traffic is routed across resources placed within a Region and across Regions.
    Next, we look at the different routing policies offered by Amazon Route53.
  prefs: []
  type: TYPE_NORMAL
- en: Routing policies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to standard name resolution services, such as pointing your domain
    name to a specific IP address, Amazon Route53 also offers several complex routing
    policies and configurations. These routing policies enable you to define various
    rules that offer the ability to build highly available solutions or redirect customers
    to resources that are closer to their location and thus reduce latency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine the various routing policies available with Amazon Route53:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple routing policy**: The most basic and default routing policy. This
    resource record enables you to map a domain name to a single resource, such as
    an IP address of a web server or a DNS endpoint of an elastic load balancer. The
    policy engine will not check whether the resource is functioning and available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Failover routing policy**: To offer high availability, you can host two copies
    of your resources ideally across different Regions. One set of resources will
    be designated as your primary resource and the other as a secondary resource.
    Route53 performs health checks (discussed later) to determine whether the primary
    resource is available and in the event of a failure to connect to the primary
    resource, Route53 will redirect all traffic to the secondary resource. This failover
    routing policy enables you to design your solution with an active-passive failover.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Geolocation routing policy**: This routing policy enables you to route traffic
    based on the geographical location of your users – such as continent, country,
    or state (in the United States). Your users'' location is determined from the
    source of the DNS queries for your web service. This routing policy is particularly
    useful when you need to ensure that your content is accessible only in locations
    where you have distribution rights. For example, if your end users are based in
    Europe, you may wish to direct them to a copy of your resources deployed in the
    Frankfurt Region.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Latency routing policy**: This routing policy is particularly useful when
    you have resources deployed in multiple Regions and you wish to route your users''
    traffic to the Region that offers the lowest latency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Weighted routing policy**: This routing policy enables you to route different
    ratios of your total traffic to different resources associated with a single domain.
    For example, you can choose to route three-quarters of your traffic to one copy
    of your resource and the remaining one-quarter to another. This is also particularly
    useful when you want to perform a gradual migration of your total traffic from
    one resource to another, such as a new version of your website. You can gradually
    alter the weights to migrate your total traffic over a short period of time from
    the old version of your website to the new version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When creating certain routing policies, such as the failover routing policy,
    you also need to define health checks so that Route53 can determine whether a
    failover to the secondary site is required. We look at health checks in detail
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Health checks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use Route53 to perform health checks against your resources, such as
    web servers, elastic load balancers, and S3 static websites. Depending on the
    results of your checks, you can then take appropriate actions and redirect traffic
    as necessary to ensure the high availability of services. There are three types
    of health checks you can perform:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Health checks that monitor an endpoint**: This monitors an endpoint you specify,
    such as an IP address or domain name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Health checks that monitor other health checks**: You can choose to monitor
    multiple resources and determine the overall health of your collection of resources
    based on some minimum number of resources that are healthy. If the number of available
    resources drops below a specified threshold, Route53 health checks can then take
    appropriate action.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ALARM` state either, as it independently determines the health based on the
    metric data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to routing policies and health checks, you can also build complex
    routing rules, and for this, we look at traffic flow and traffic policies next.
  prefs: []
  type: TYPE_NORMAL
- en: Traffic flow and traffic policies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may need to create complex routing of traffic using a combination of resource
    records and Route53 routing policies. For example, you may create configuration
    in which you set up latency routing policies across several Regions, which then
    reference weighted records in each Region for your resources. Each configuration
    is known as a **traffic policy**, and you use a visual editor to help you build
    your routing architecture, which Route53 uses to design your traffic flow. Using
    the visual editor, you can also create multiple versions of your traffic policy
    so that you can quickly adapt to changes. Note that you can only use a traffic
    flow to create records in public hosted zones:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Geoproximity routing policy**: In addition to the standard Route53 routing
    policies, you can also configure geoproximity routing policies (available only
    when you use Route53 Traffic Flow). This routing policy enables you to route traffic
    based on the location of your resources. You can also shift traffic from resources
    in one location to resources in another location using a *bias* value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Route53 Resolver**: Route53 also enables you to perform DNS resolution between
    Route53 Resolver and DNS resolvers on your network by configuring forwarding rules.
    In this case, *your network* can comprise your VPC, other peered VPCs, or even
    your on-premises corporate data centers connected to AWS either via a VPN or AWS
    Direct Connect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we learned about the Amazon DNS service offered by Route53\.
    Route53 enables you to register domain names, create public and private hosted
    zones to manage your resource records, define routing policies for different use
    cases, and perform health checks against your resources. Route53 also enables
    you to build complex routing rules using multiple resource records, along with
    traffic flow and traffic policies.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we look at AWS CloudFront, which is Amazon's **Content
    Delivery Network** (**CDN**) solution. CDNs are often used to distribute content
    globally from a source location and, with the help of caching services, offer
    reliable, low-latency access to your content.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a robust CDN with Amazon CloudFront
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Amazon CloudFront is a CDN that helps you to distribute your static and dynamic
    digital content globally with low-latency connections. AWS CloudFront uses AWS
    edge locations and regional edge caches to cache content closer to your end users'
    locations. This means that you can host your content in one specific Region and
    a user who attempts to access it from another Region will retrieve the content
    via the edge location over the AWS backbone network. Furthermore, as content is
    retrieved, it is cached at a local edge location closer to the user for a period
    (known as a **time-to-live** or **TTL**), further improving network latency in
    subsequent requests for the same content.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.21 – A typical CloudFront distribution'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17124_06_21.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.21 – A typical CloudFront distribution
  prefs: []
  type: TYPE_NORMAL
- en: To configure Amazon CloudFront, you create a distribution endpoint that defines
    the types of content you want to serve and the source of that content. The source
    can be an S3 bucket, an S3 bucket configured as a static website, an Amazon EC2
    instance, or an elastic load balancer, among others. As part of your configuration,
    you get a CloudFront URL, which you provide to your users to access your content
    via CloudFront. You can also use custom URLs, which allows you to define your
    distribution with a company-branded domain name.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you configure your CloudFront distributions, you can choose to serve your
    content over HTTP and HTTPS. Some examples of types of content that can be served
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Static and dynamic content, for example, HTML, CSS, JavaScript, and images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Video on demand in different formats, for example, Apple **HTTP Live Streaming**
    (**HLS**) and Microsoft Smooth Streaming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Live events and conferences
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CloudFront ultimately enables you to architect a CDN for your web application.
    Next, we look at how CloudFront is priced.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing a price class for your CloudFront distribution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Amazon charges you for distributing your content via its edge locations. Rather
    than charge you on a per-edge location basis, however, Amazon have clubbed several
    edge locations across Regions into three specific price classes. The most expensive
    price class is where your content is accessible via all edge locations globally.
    This also happens to be the default price class when you create your distribution,
    but ultimately offers the best performance. If you are looking to reduce cost
    and if you know that the consumers of your content are from specific Regions,
    you can choose two alternative price classes:'
  prefs: []
  type: TYPE_NORMAL
- en: United States; Canada; Europe; Hong Kong, Philippines, South Korea, Taiwan,
    Singapore; Japan; India; South Africa; and Middle East regions – This class excludes
    the most expensive regions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: United States, Canada, and Europe regions – This class is the least expensive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we examined the services offered by the AWS CloudFront service
    and how it can be used to distribute your content globally over AWS backbone networks,
    offering lower latency and better performance.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we provide a brief introduction to Amazon API Gateway,
    which allows you to architect serverless applications by creating, publishing,
    and managing REST, HTTP, and WebSocket APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Amazon API Gateway
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Amazon API Gateway helps you design application solutions that favor the microservices
    architecture in place of monolith designs. Your backend developers can build a
    series of microservices that work with each other. For example, in an e-commerce
    application, you can have several microservices, such as cart-service, catalog-service,
    user-profile and user-session services, inventory-management-service, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Without an API gateway, your frontend developer (who builds the frontend user
    interface) would need to be made aware of all the backend APIs and build the application
    to call several microservices, to provide complete functionality. Imagine, then,
    your backend developer later needs to refactor one of the microservices, such
    as splitting one microservice into two separate microservices, each with its own
    API. This would result in having to recode some components of the frontend user
    interface too.
  prefs: []
  type: TYPE_NORMAL
- en: With an API gateway, you essentially create an abstraction layer. This API gateway
    can be used to expose all the APIs that need to be made available to external
    clients to call backend services. Requests from those clients can then be routed
    to the various backend microservices. As per the following diagram, Amazon API
    Gateway acts as a "front door" for your applications to access backend data, Lambda
    functions, databases, and more. It handles all the incoming traffic and is capable
    of processing thousands of concurrent API calls.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.22 – Amazon API Gateway'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17124_06_22.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.22 – Amazon API Gateway
  prefs: []
  type: TYPE_NORMAL
- en: Amazon API Gateway offers features that also help you protect your backend services,
    such as authorization, access control, and monitoring, and help protect backend
    resources from **Distributed Denial of Service** (**DDoS**) attacks.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of designing your software architecture, adding this abstraction layer
    creates an additional hop for your clients to access backend resources. To improve
    application responsiveness, Amazon API Gateway offers features to optimize your
    APIs such as response caching and payload compression.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we provided a brief introduction to Amazon API Gateway, which
    is a fully managed service that enables you to create, publish, maintain, monitor,
    and secure APIs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you have the opportunity to build out your own Amazon VPC
    as part of the exercises in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 6.1 – setting up a public subnet VPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this exercise, you will create your own custom VPC that will contain a public
    subnet. In later chapters, you will expand this VPC to add private subnets for
    different use case:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to your AWS account as the IAM user `Alice` you created in [*Chapter
    4*](B17124_04_Final_SK_ePub.xhtml#_idTextAnchor068), *Identity and Access Management*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the main AWS Management Console, search for `VPC` in the search box.![Figure
    6.23 – Configuring a new VPC
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B17124_06_23.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 6.23 – Configuring a new VPC
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select **VPC** from the filtered list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: VPCs are Region-specific, so make sure you select the US-East-1 Region from
    the top right-hand corner of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the main VPC console screen, click on the **Launch VPC Wizard** button. This
    will launch the VPC wizard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, select the first option, **VPC with a Single Public Subnet.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In *Step 2*, provide the following details for your VPC.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `10.0.0.0/16`. This IP block represents your VPC network.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For `ProductionVPC`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The wizard gets you to create a single public subnet. Later, you will expand
    this VPC for future use, but for now, set the `10.0.1.0/24`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For **Availability Zone**, select **us-east-1a** from the drop-down list. Remember
    that while VPCs span the entire Region, each subnet you create spans a single
    Availability Zone. In this case, we are creating a single public subnet in **us-east-1a.**
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, rename the subnet name to **Public Subnet One**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, click the **Create VPC** button in the bottom right-hand corner of the
    screen. Review the following screenshot for the preceding steps:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.24 – VPC with public subnet configuration page'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B17124_06_24.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 6.24 – VPC with public subnet configuration page
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The wizard runs through the parameters you specified and creates your first
    VPC.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **OK** on the **VPC Successfully Created** status page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the list of VPCs, you will note that your newly created **ProductionVPC**
    has been successfully created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.25 – Newly created ProductionVPC'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17124_06_25.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.25 – Newly created ProductionVPC
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we demonstrated how to create your first public subnet VPC
    using the AWS VPC wizard. Later in the training guide, you will expand the VPC
    to include private subnets and deploy servers within our VPCs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter examined Amazon's core network services, comprising VPCs, Amazon's
    DNS service offering with Route53, and Amazon's CDN solution with Amazon CloudFront.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned how computers communicate with each other via IP
    addresses. You also learned that using IP addressing and CIDR block ranges, you
    can build isolated networks and subnetworks. We then discussed how you can build
    the same network architecture in the cloud using the Amazon VPC service. As part
    of setting up your VPC, you examined the use cases to build private and public
    subnets and explored tools for defining security rules and limiting the types
    of traffic that can enter and leave your VPC. We also looked at additional VPC
    services that enable you to interconnect multiple VPCs using VPC peering and how
    to build complex connections more easily across VPCs using AWS Transit Gateway.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we learned about the AWS Route53 service, a DNS offering that provides
    domain name registration, a route policy configuration service, and health checks.
    You learned that by using a routing policy, you can customize your solutions for
    a wide range of use cases. These include offering an active-passive failover service
    with the Route53 latency routing policy, and the ability to slowly migrate your
    users from one resource to another using the weighted routing policy.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you learned about Amazon CloudFront and how to use AWS's edge locations
    to distribute your digital assets and content globally from a single Region over
    a high-speed low-latency connection.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about the **Elastic Cloud Compute** (**EC2**)
    service and how you can deploy compute services such as virtual servers running
    Linux or Windows operating systems in the cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which VPC component enables to you grant internet access to servers in the public
    subnet deployed in the VPC?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: NAT gateway
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Internet gateway
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: VPC peering
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Security group
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following statements are true?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: NACLs protect entire subnets, whereas security groups protect the individual
    instance.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: NACLs protect the individual instance, whereas security groups protect the entire
    subnet.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: NACLs enable instances in the private subnet to access the internet and act
    as a NAT device, whereas security groups are used to assign IAM policies to servers
    that need access to S3 buckets.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: NACLs enable instances in the private subnet to access the internet and act
    as a NAT device, whereas security groups are used to assign IAM policies to servers
    that need access to S3 buckets.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which AWS service enables you to purchase and register new domain names that
    can be used to publish your website on the internet?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Route53
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: VPC
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: RDS
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Elastic Beanstalk
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which AWS service enables you to distribute your digital assets such that it
    is cached locally to users who attempt to access this content for a time to live,
    and thus helps to reduce network latency?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AWS CloudFront
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: AWS CloudTrail
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: AWS CloudWatch
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: AWS CloudScape
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Your organization hosts multiple AWS accounts with multiple VPCs. You would
    like to connect these VPCs together and centrally manage connectivity policies.
    Which AWS service enables you to connect multiple VPCs configured as a hub that
    controls how traffic is routed among all the connected networks, which act like
    spokes?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AWS Transit Gateway
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: AWS Global Accelerator
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: AWS VPC Peering
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: AWS Virtual Private Gateway
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which AWS service enables you to grant internet access to EC2 instances configured
    with IPv4, and located in the private subnet of your VPC?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Egress-only internet gateway
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: NAT gateway
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: VPC endpoint
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: VPN tunnel
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You company has a primary production website in the US and a DR site in Sydney.
    You need to configure DNS such that if your primary site becomes unavailable,
    you can fail DNS over to the secondary site. Which DNS routing policy can you
    configure to achieve this?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Weighted Routing
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Geolocation Routing
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Latency Routing
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Failover Routing
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: You plan to set up DNS failover using Amazon Route53\. Which feature of Route53
    can you use to test your web application's availability and reachability?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Private DNS
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: CloudWatch
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Health checks
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: DNS ping
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which VPC firewall solution enables you to deny inbound traffic from a specific
    IP address, which can be used to prevent malicious attacks?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AWS Firewall
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: AWS Security Groups
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: AWS **Network Access Control Lists** (**NACLs**)
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: AWS CloudFront
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which AWS service enables you to connect your private data center to your Amazon
    VPC with up to 100 Gbps network connectivity?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Snowball
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Direct Connect
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Virtual Private Network** (**VPN**)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Virtual Satellite Network** (**VSN**)'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
