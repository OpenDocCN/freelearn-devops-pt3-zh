- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mobile DevOps Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in the previous chapters, it is essential to use the mobile DevOps
    process in order to develop and release quality mobile applications frequently
    and quickly to your customers. It is possible to speed up the development and
    distribution of mobile applications by combining the best practices of developers,
    test engineers, release experts, and other stakeholders. As a result of the shorter
    delivery times, quality and user experience will also be improved.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we will explore a range of essential topics that will
    empower mobile app developers and DevOps teams to implement efficient and effective
    **continuous integration/continuous delivery** (**CI/CD**) pipelines; we will
    delve into the fundamental practices that drive successful mobile app development.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Best practices for CI/CD in mobile app development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing mobile app versions and releases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing mobile app infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The A/B testing and feature flags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote and dependency caching for mobile apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execution of CI builds and tests in parallel
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automating build, test, and release with fastlane
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mock APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ChatOps for mobile DevOps collaboration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices for CI/CD in mobile app development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Keeping your mobile DevOps processes effective, efficient, and aligned with
    your overall strategy for developing mobile apps requires you and your team to
    review and refine them regularly. There is no silver bullet, so we should always
    refine our mobile DevOps processes based on team and business growth.
  prefs: []
  type: TYPE_NORMAL
- en: There are various practices that can be added to mobile DevOps processes to
    optimize CI/CD pipelines, code review processes, development speed, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: We discussed, in the previous chapters, the different stages when implementing
    CI/CD pipelines or workflows for mobile apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some best practices to ensure a successful CI/CD pipeline for mobile
    apps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automate as much as possible**: Automate building, testing, code analysis,
    releasing, and other tasks to reduce manual intervention, minimize errors, and
    accelerate the development process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implement a testing strategy:** Use a mix of unit tests, integration tests,
    UI tests, and end-to-end tests to ensure high-quality code. Test various devices,
    screen sizes, and operating systems using emulators or real devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimize build and test times:** Use caching, parallelization, and incremental
    builds to reduce build times. Parallelize test execution and prioritize critical
    tests to speed up test runs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adopt a well-defined branching strategy**: When dealing with large or complex
    code, it’s helpful to use a branching strategy such as GitFlow or trunk-based
    development. This can maintain a tidy commit history and make integration and
    deployment easier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enforce good commit practices**: This includes atomic commits, descriptive
    commit messages, and frequent code reviews to maintain code quality and ensure
    easy traceability of changes. This helps ensure the code’s quality and correctness
    and can improve collaboration among team members. There are different tools that
    can be used to improve and automate the code review process, such as the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**What The Diff** ([https://whatthediff.ai/](https://whatthediff.ai/)): This
    is an AI-powered code that acts as a review assistant. Its purpose is to assist
    your team in writing better pull request descriptions, and it can even help to
    speed up the reviewing and merging process. Additionally, it can keep your non-technical
    team members informed and involved.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Danger** ([https://github.com/danger/danger](https://github.com/danger/danger)):
    This is an incredible tool that can help your team automate code review conventions.
    By adding another logical step to the process, Danger can assist with linting
    those routine tasks during your daily code review.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MergeQueue** ([https://mergequeue.com/](https://mergequeue.com/)): A faster
    way to automate merge workflows, manage queues in large teams, and never worry
    about build failures again.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Keep an eye on essential CI/CD metrics**: It is important to monitor the
    CI/CD metrics such as build times, test execution times, deployment frequency,
    and code quality. These metrics will be discussed further in this chapter to help
    identify bottlenecks and areas for improvement.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Incorporate security measures into your CI/CD pipeline**: To ensure safety
    in your CI/CD pipeline, it is important to include security measures. This can
    be done by utilizing both static and dynamic code analysis tools, scanning dependencies
    for any vulnerabilities, and enforcing access control through the principle of
    least privilege.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prepare a well-defined rollback strategy**: It is important to have a clear
    and defined plan in place for rolling back to a previous stable version in the
    event of any issues during deployment. This may require submitting a new update
    to the app store for mobile applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Establish clear communication channels**: It is important to establish clear
    communication channels among team members in order to keep everyone informed about
    the project’s progress and any potential issues that may arise.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collaborate with cross-functional teams**: Work together with cross-functional
    teams to ensure all aspects of the development and deployment processes are taken
    into consideration. This involves collaborating with designers, developers, testers,
    and operations teams.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition, we should keep an eye on the performance of our CI builds and CI
    servers overall as we improve our mobile DevOps processes and CI/CD implementation.
    Let’s look at a few metrics to track the CI/CD.
  prefs: []
  type: TYPE_NORMAL
- en: Key metrics to track for CI/CD in mobile app development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tracking key metrics in your CI/CD pipeline can help you measure the effectiveness
    of your development and deployment process, identify bottlenecks, and optimize
    the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some essential metrics to track for CI/CD in mobile app development:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Build success rate**: Measure the time taken for each build, including compilation,
    packaging, and any other build-related tasks. Tracking this metric can help you
    identify inefficiencies and improve build performance – for example, you have
    the option to incorporate caching steps to decrease the build time of the app
    in case the app modules haven''t undergone any changes from the previous build.
    This will prevent the app from being built from scratch and start the process
    from where it last left off. We will discuss caching later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment frequency**: Track how often you deploy new releases or updates
    to your mobile app. High deployment frequency indicates a mature CI/CD process
    and faster delivery of features and bug fixes to users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lead time for changes**: Measure the time a code change takes from commit
    to production. Shorter lead times can indicate an efficient pipeline and faster
    value delivery to users; we will discuss different tools that help in the code
    commit process later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Change failure rate**: Monitor the percentage of changes that results in
    failures or require rollbacks. A low change failure rate indicates that your testing
    and release processes effectively catch issues before they reach production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mean time to recovery** (**MTTR**): Measure the average time it takes to
    fix issues or recover from a failure in production. A short MTTR indicates that
    your team effectively identifies and addresses problems quickly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test execution time**: Monitor the time taken to execute your test suite.
    Long test execution times can slow down the development process. Identifying slow
    tests or optimizing test parallelization can reduce execution time. We will discuss
    parallelization later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test coverage**: Track the percentage of your code base covered by tests
    to ensure that you have adequate testing in place to catch issues and maintain
    high code quality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test pass/fail rate**: Monitor the percentage of tests that pass or fail
    in each build. A high pass rate indicates a stable code base, while a high failure
    rate may indicate issues with the code or testing process. Flaky tests produce
    inconsistent results, passing in some runs and failing in others without any apparent
    reason. Address flaky tests as soon as possible to avoid false negatives and maintain
    confidence in your test suite. Here is an example of how Slack teams handle the
    flaky tests art scale: [https://slack.engineering/handling-flaky-tests-at-scale-auto-detection-suppression/](https://slack.engineering/handling-flaky-tests-at-scale-auto-detection-suppression/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code quality metrics**: Track metrics related to code quality, such as code
    complexity, code duplication, and adherence to coding standards. These metrics
    can help you maintain a clean and maintainable code base.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tracking key metrics for CI/CD in mobile app development is crucial for evaluating
    the efficiency of the development and deployment process. By monitoring these
    metrics, teams can identify bottlenecks, optimize their pipeline, and ensure a
    smooth and reliable delivery of features and updates to users.
  prefs: []
  type: TYPE_NORMAL
- en: These metrics provide valuable insights into the overall health and effectiveness
    of the CI/CD pipeline, enabling teams to make data-driven improvements and maintain
    a stable and high-quality code base.
  prefs: []
  type: TYPE_NORMAL
- en: With a well-monitored CI/CD pipeline and a clear understanding of key metrics,
    let’s explore together the essential strategies for managing mobile app versions
    and releases.
  prefs: []
  type: TYPE_NORMAL
- en: Managing mobile app versions and releases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Managing versions and releases of a mobile app can be a complicated task, but
    there are some best practices that can help simplify it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Follow semantic versioning**: It’s essential to adopt a clear and consistent
    version numbering system. Semantic versioning ([https://semver.org/](https://semver.org/))
    is a widely recognized standard used by developers. A version number consists
    of three parts: **MAJOR.MINOR.PATCH**. **MAJOR** version changes indicate breaking
    changes, **MINOR** version changes introduce new features, and **PATCH** version
    changes address bugs and issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Comprehensive release notes**: Provide thorough release notes for each release,
    including new features, bug fixes, known issues, and additional instructions or
    requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Streamlined branching strategy**: Adopt a clear and well-defined branching
    strategy, such as **GitFlow** or **trunk-based development**, to avoid confusion
    and maintain a clean commit history. This will help ensure a smooth integration
    and deployment process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s examine the two strategies for organizing and managing source code
    in version control systems: *monorepo* and *multi-repo*.'
  prefs: []
  type: TYPE_NORMAL
- en: Monorepo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **monorepo** ([https://monorepo.tools/](https://monorepo.tools/)) is a single
    repository containing multiple distinct projects with well-defined relationships.
    This approach is designed to make it easier to manage and develop large, complex
    software systems by providing a single, unified source of truth for all the code
    and resources required by the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'There’s a difference between a *monolith* and a *monorepo*; a good monorepo
    is the opposite of a monolith, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – Monolith versus multi-repo versus monorepo](img/Figure_09.1_B18113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – Monolith versus multi-repo versus monorepo
  prefs: []
  type: TYPE_NORMAL
- en: 'A monorepo offers several benefits for project development:'
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, storing all code in a single repository makes it easier to understand
    how different system pieces fit together and depend on one another. This also
    simplifies dependency management, reducing complexity in the development process
    and facilitating seamless building and deployment of changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A monorepo enhances collaboration between developers by providing a centralized
    location for all relevant code and resources. This improves communication, minimizes
    conflicts, and enables smoother collaboration on the project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, there are some challenges associated with monorepos:'
  prefs: []
  type: TYPE_NORMAL
- en: They can become large in size, making it more difficult to clone and work with
    the repository due to increased disk space requirements and longer cloning times
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be more complex, particularly for large and complex projects, as changes
    impact the entire repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security enforcement may pose difficulties as well, as all code is stored in
    a single location and accessible to multiple developers. This can be particularly
    challenging for sensitive projects, necessitating careful authorization processes.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-repo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Multi-repo is a development approach where each component of a project is stored
    in its own separate repository. It promotes modularity and allows teams to work
    independently on specific components. While it offers flexibility, coordinating
    changes across repositories can be challenging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some characteristics and challenges associated with multi-repo:'
  prefs: []
  type: TYPE_NORMAL
- en: In a multi-repo approach, each project, library, or module has its own separate
    repository. This keeps the code base for each project isolated and independent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each repository has its own version control history, allowing projects to be
    versioned independently. This provides flexibility in managing release cycles
    and updates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependencies between projects must be explicitly managed and versioned, enhancing
    visibility and control over inter-project dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each repository contains only the code for a specific project, keeping the repository
    size smaller and potentially improving performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The multi-repo approach allows for a more decentralized development process,
    as each team can manage its repositories independently.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing dependencies, versions, and configurations across multiple repositories
    can be more complex and time-consuming compared to a monorepo.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making changes across multiple projects can be challenging, as it may require
    coordinating commits and releases across multiple repositories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a result, the choice between monorepo and multi-repo depends on factors such
    as team size, project complexity, development processes, and tooling preferences.
    Some organizations prefer the simplicity and unified approach of a monorepo, while
    others prefer a multi-repo setup’s independence and decentralized nature.
  prefs: []
  type: TYPE_NORMAL
- en: Since mobile applications rely on backend services, databases, and configuration
    management, the team should consider automating the release and managing of these
    to prevent any issues. Let’s examine the concepts behind managing mobile app infrastructure
  prefs: []
  type: TYPE_NORMAL
- en: Managing mobile app infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing mobile app infrastructure is a critical aspect of successful app development
    and deployment. It involves overseeing the underlying systems, servers, databases,
    and cloud resources that support the app’s functionality and user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Efficient infrastructure management ensures scalability, reliability, and performance.
    Tasks include provisioning and configuring servers, setting up databases, monitoring
    resource utilization, and implementing security measures. Embracing modern **infrastructure-as-code**
    (**IaC**) practices allows teams to automate infrastructure provisioning and configuration,
    making it easier to maintain consistency and deploy changes seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: A well-managed mobile app infrastructure is vital for delivering a smooth and
    reliable user experience while efficiently handling increasing user demands and
    scaling with the growth of the app. Let’s discuss how to manage the infrastructure
    of mobile apps.
  prefs: []
  type: TYPE_NORMAL
- en: IaC for mobile apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**IaC** is a powerful approach that allows you to define and manage your app’s
    infrastructure using code, bringing benefits such as reproducibility and scalability.
    While IaC is commonly associated with server-based infrastructure, it can also
    be applied to mobile apps, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – IaC](img/Figure_09.2_B18113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – IaC
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how you can utilize IaC for mobile apps in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: IaC enables you to create reproducible environments easily. You can spin up
    identical infrastructure setups for different environments such as development,
    testing, staging, and production. By using the same infrastructure code, you ensure
    consistency across environments, reducing the chances of configuration drift and
    environment-related issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define the infrastructure components required to support your mobile app. This
    may include server resources, databases, storage services, **content delivery
    networks** (**CDNs**), and other necessary resources. Determine the configuration
    settings, dependencies, and relationships between these components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select an IaC tool that supports mobile app infrastructure provisioning. Popular
    options include Terraform and AWS CloudFormation. These tools allow you to describe
    and manage your IaC and support various cloud providers and services.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store your infrastructure code in a version control system (e.g., Git) to track
    changes, enable collaboration, and maintain a history of infrastructure modifications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilize IaC to define auto-scaling capabilities for your mobile app’s infrastructure.
    This allows your app to automatically scale resources up or down based on demand,
    ensuring optimal performance and cost efficiency. Specify scaling policies and
    thresholds within your infrastructure code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With IaC, you can manage configuration settings and variables as code, making
    it easier to maintain consistency and avoid manual errors. For example, you can
    define environment-specific configuration values (e.g., API endpoints and database
    credentials) within your infrastructure code and use them consistently across
    different environments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With IaC, you can version and track these changes, ensuring transparency and
    simplifying deployment. Instead of manually modifying resources, you modify the
    infrastructure code and apply the changes, and the IaC tool handles the updates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apply testing principles to your infrastructure code. Write automated tests
    to validate the correctness and integrity of your infrastructure definitions.
    This helps catch potential issues before provisioning or modifying the infrastructure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrate your infrastructure code into your CI/CD pipeline. This allows you
    to automate the provisioning and updating of your mobile app’s infrastructure
    alongside your application code, ensuring consistent and reliable deployments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After IaC, let’s explore configuration management for mobile apps and how to
    use it.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration management for mobile apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Manage configuration settings and variables for different environments to ensure
    consistency and avoid manual errors with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify the configuration settings and variables your mobile app requires.
    These can include API endpoints, database connection strings, feature flags, logging
    levels, credentials, and any other values that may vary across environments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separate the configuration settings from your application code. Hardcoding configuration
    values directly into the code can make it challenging to update them when moving
    between environments. Instead, abstract the configuration values into separate
    configuration files or externalize them through environment variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use configuration files specific to each environment. For example, you can have
    separate configuration files for development, testing, staging, and production
    environments. These files can be JSON, XML, YAML, or properties files. Each file
    contains the corresponding values for that environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leverage environment variables to store configuration values. Environment variables
    are set at the system level and can be accessed by your mobile app during runtime.
    This approach provides flexibility and allows for easy configuration changes without
    modifying files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a centralized configuration management solution to store and manage your
    configuration settings. Solutions include AWS Secrets Manager secrets, Parameter
    Store parameters, or HashiCorp Vault for configuration values. They allow you
    to store different configurations for each environment and provide APIs for retrieving
    values at runtime.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automate the deployment of configuration settings to different environments
    as part of your CI/CD pipeline. This ensures that the correct configuration values
    are deployed with your mobile app, reducing the risk of human error during manual
    configuration updates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store your configuration files or scripts in version control to track changes,
    maintain a history, and enable collaboration. This allows you to revert to previous
    configurations if needed and provides an audit trail of configuration modifications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid storing sensitive information directly in configuration files or environment
    variables. Instead, use secure storage mechanisms provided by your chosen configuration
    management solution or encrypt the sensitive values before storing them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include configuration testing as part of your automated testing strategy. Write
    tests that validate the correctness and integrity of your configuration settings.
    This helps catch configuration-related issues early in development and ensures
    that the app behaves as expected in different environments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Establish a change management process for modifying configuration settings.
    Implement approval workflows to ensure that changes are reviewed and approved
    by the appropriate stakeholders before being applied to production environments.
    This helps maintain control and prevent unauthorized or unplanned changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimize your build process to reduce build times, as long as it can slow the
    development cycle and increase developer waiting times. Use techniques such as
    caching, parallelization, and incremental builds to speed up the process. In the
    next section, we’ll dive into remote and dependency caching for mobile apps and
    explore the benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Remote and dependency caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building and releasing mobile apps often involves downloading dependencies and
    assets to the CI servers or the local machines to be able to build the apps, which
    can be time-consuming and data-intensive. However, with the advent of remote and
    dependency caching solutions, developers now have a powerful tool to enhance their
    productivity.
  prefs: []
  type: TYPE_NORMAL
- en: Remote and dependency caching for mobile apps refers to *storing and retrieving
    frequently used dependencies and assets from a remote server*. Instead of downloading
    these resources every time an app is built, developers can leverage caching to
    significantly reduce the time and bandwidth required for the build process. This
    optimization technique can significantly streamline app development workflows,
    resulting in faster build times, improved iteration cycles, and reduced data consumption.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some benefits of remote and dependency caching:'
  prefs: []
  type: TYPE_NORMAL
- en: It eliminates the need to download the same resources repeatedly, enabling developers
    to save valuable time during the build process. This acceleration can be particularly
    noticeable when working on large-scale projects with numerous dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Caching facilitates collaboration among team members by ensuring that everyone
    has access to the same set of dependencies and assets. This helps avoid versioning
    conflicts and ensures consistent development environments across the team.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developers can rapidly iterate on their apps without waiting for resource downloads,
    enabling quicker testing and debugging cycles.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some caching solutions provide offline support, allowing developers to continue
    working on their projects even when an internet connection is unavailable. This
    feature is particularly useful for developers on the go or in areas with intermittent
    connectivity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But depending on the caching solution chosen, developers may need to monitor
    and manage the cache to prevent it from growing too large or becoming cluttered
    with outdated resources. Efficient cache management strategies are crucial to
    maintain optimal performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to remote and dependency caching for mobile apps, several tools
    and platforms offer similar functionality, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Gradle''s build cache** ([https://docs.gradle.org/current/userguide/build_cache.html](https://docs.gradle.org/current/userguide/build_cache.html)):
    Gradle is a popular build automation system that provides a build cache feature
    that can be leveraged to cache dependencies and resources. It integrates seamlessly
    with Gradle-based Android projects and is well suited to large-scale builds.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`npm` package manager includes a caching mechanism that allows for efficient
    dependency resolution and retrieval. npm’s cache significantly reduces the time
    required to fetch and install frequently used packages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Bazel.build` utilizes a sophisticated dependency graph and caching mechanism
    to intelligently determine what needs to be rebuilt, significantly reducing build
    times and improving developer productivity. You can read examples of how Reddit
    uses Bazel with the iOS app ([https://www.reddit.com/r/RedditEng/comments/syz5dw/ios_and_bazel_at_reddit_a_journey/](https://www.reddit.com/r/RedditEng/comments/syz5dw/ios_and_bazel_at_reddit_a_journey/))
    and how Square uses Bazel with Apple Silicon ([https://developer.squareup.com/blog/getting-squares-ios-build-ready-for-apple-silicon-with-bazel/](https://developer.squareup.com/blog/getting-squares-ios-build-ready-for-apple-silicon-with-bazel/)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tuist** ([https://tuist.io/](https://tuist.io/)): Tuist is a command-line
    tool that simplifies the process of setting up and maintaining iOS projects using
    a declarative approach. Tuist caching ([https://docs.tuist.io/building-at-scale/caching](https://docs.tuist.io/building-at-scale/caching))
    optimizes build times by storing and reusing previously built dependencies, assets,
    and intermediate build artifacts. This caching mechanism can greatly reduce the
    time required to build and iterate on iOS projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**BuildBuddy** ([https://www.buildbuddy.io/](https://www.buildbuddy.io/)):
    BuildBuddy is a cloud-based build execution platform that helps developers offload
    and distribute their builds to remote machines. It offers a user-friendly interface,
    extensive build insights, and collaboration features to streamline the development
    workflow. By utilizing BuildBuddy, teams can reduce build times, save infrastructure
    costs, and enhance developer efficiency. Here is an example of how to use Remote
    Build Execution with GitHub Actions: [https://www.buildbuddy.io/docs/rbe-github-actions](https://www.buildbuddy.io/docs/rbe-github-actions).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**XCRemoteCache** ([https://github.com/spotify/XCRemoteCache](https://github.com/spotify/XCRemoteCache)):
    XCRemoteCache is a remote cache tool for Xcode projects. It reuses target artifacts
    generated on a remote machine, served from a simple REST server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Carthage cache**: Carthage, a dependency manager for iOS apps, offers a caching
    feature to speed up dependency retrieval and build times. It provides compatibility
    with Xcode and simplifies sharing dependencies across team members. Additionally,
    you can use Rome ([https://github.com/tmspzz/Rome](https://github.com/tmspzz/Rome)),
    the shared cache for frameworks built with Carthage that allows developers on
    Apple platforms to use Amazon’s S3, a local folder, or your own custom engine.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also use the Cocoapods cache ([https://cocoapods.org/pods/Cache](https://cocoapods.org/pods/Cache))
    or the **Swift Package Manager** (**SPM**) ([https://github.com/apple/swift-package-manager](https://github.com/apple/swift-package-manager))
    cache if you are using it in your iOS apps.
  prefs: []
  type: TYPE_NORMAL
- en: Remote and dependency caching for mobile apps is a game-changer in mobile app
    development and mobile DevOps, offering tangible benefits in terms of time savings,
    bandwidth conservation, collaboration, and iteration efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile CI/CD systems use caching to transfer data between isolated builds. As
    CI builds run in ephemeral, isolated virtual machines, a typical CI workflow must
    take extra steps to bootstrap the local environment ordinarily available to the
    developer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Caching these operations will make your CI workflows faster since installing
    CLI tools and downloading third-party dependencies take time, as shown in the
    following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Caching between the CI builds machines](img/Figure_09.3_B18113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Caching between the CI builds machines
  prefs: []
  type: TYPE_NORMAL
- en: While there may be some initial setup complexities and considerations around
    cache management, the overall advantages make caching a valuable addition to any
    developer’s toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how you can use GitHub Actions to set up a simple Gradle
    cache pipeline for an Android app build to speed up build times:'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `.github/workflows` directory, create a YAML file – for example,
    `android_build.yml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `android_build.yml` file: [https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-9/.github/android_build.yml](https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-9/.github/android_build.yml).
    The workflow caches the Gradle dependencies based on the contents of your Gradle
    files.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Depending on your app’s complexity and needs, you might want to add more steps,
    such as running tests, deploying artifacts, or integrating with other services.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s look at an example of how to use caching in the CI/CD workflow on Bitrise.
  prefs: []
  type: TYPE_NORMAL
- en: Bitrise offers features known as **Cache Pull Step** and **Cache Push Step**,
    which enable you to cache and retrieve particular directories or files between
    builds, based on the app dependencies in your apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up caching for your iOS project, you need to add these steps to your
    Bitrise workflow: [https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-9/bitrise.yml](https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-9/bitrise.yml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about Bitrise dependencies and caching at the following
    link: [https://devcenter.bitrise.io/en/dependencies-and-caching.html](https://devcenter.bitrise.io/en/dependencies-and-caching.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, by comparing and selecting the most suitable caching solution based
    on your project’s requirements, you can optimize your app development process
    and unlock greater productivity.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to always search for the appropriate caching solution for both
    your mobile app and CI provider.
  prefs: []
  type: TYPE_NORMAL
- en: Execution of CI builds and tests in parallel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Leveraging parallel execution for CI builds and tests in mobile app development
    can significantly enhance developer productivity, shorten feedback loops, and
    improve overall efficiency. Consider the capabilities of tools such as Fastlane,
    Firebase Test Lab, and CI tools to achieve optimal parallelization and accelerate
    your mobile app development process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the benefits of parallel execution for mobile app CI builds are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Faster feedback**: Parallel execution reduces the time required to build
    steps and test suites, providing quicker feedback on code changes. This enables
    developers to iterate faster and catch issues early in the development cycle.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved efficiency**: By utilizing parallel execution, you can fully utilize
    available resources and distribute the workload across multiple agents or devices.
    This improves resource efficiency and maximizes the utilization of your CI infrastructure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: Parallel execution allows your CI pipeline to scale seamlessly
    as your mobile app project grows. It enables you to handle larger code bases,
    increased test suites, and support for multiple platforms and configurations without
    sacrificing speed or performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time and cost savings**: By reducing build and test times through parallel
    execution, you save valuable developer time and potentially reduce costs associated
    with maintaining CI infrastructure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the CI/CD tools support parallel builds or splitting the CI pipeline
    or workflow into small patches or tasks to run in parallel to save the build time.
    For example, with GitHub Actions, you can use Matrix ([https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs](https://docs.github.com/en/actions/using-jobs/using-a-matrix-for-your-jobs))
    to test your code in multiple versions of a language or on multiple operating
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: With Bitrise, you can use Build Pipelines ([https://bitrise.io/why/features/pipeline](https://bitrise.io/why/features/pipeline)),
    which helps you organize your entire mobile CI/CD build process and allows you
    to set up advanced configurations with multiple tasks and tests running in parallel
    and/or sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: 'In parallel execution, multiple UI tests are executed simultaneously on different
    devices or simulators, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 9.4 – Parallel \uFEFFUI tests execution](img/Figure_09.4_B18113.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Parallel UI tests execution
  prefs: []
  type: TYPE_NORMAL
- en: Parallel execution for mobile app UI testing helps improve the speed and quality
    of your testing process, leading to more reliable and robust mobile applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some benefits of parallel execution for mobile app UI testing:'
  prefs: []
  type: TYPE_NORMAL
- en: By running UI tests in parallel, you can significantly reduce the overall execution
    time. Instead of executing tests sequentially, parallel execution allows multiple
    tests concurrently on different devices or simulators. This helps save time and
    improves the efficiency of your testing process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With parallel execution, you can execute tests on multiple devices or simulators
    simultaneously. This allows you to cover a broader range of device configurations,
    operating systems, and screen sizes in less time. It helps ensure your app is
    tested on various devices and increases the likelihood of catching device-specific
    issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel execution provides scalability for your UI testing process. As your
    test suite grows, executing tests in parallel allows you to handle more tests
    without significantly increasing execution time. You can easily add more devices
    or simulators to your testing infrastructure and distribute the test workload
    across them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel execution makes efficient use of available resources. By utilizing
    multiple devices or simulators concurrently, you can maximize the utilization
    of your testing infrastructure. This helps optimize resource allocation and ensures
    tests are executed without unnecessary wait times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel execution is well suited for integration into CI/CD pipelines. You
    can achieve faster feedback cycles and builds by executing tests in parallel.
    It allows you to integrate UI testing seamlessly into your CI/CD workflows and
    ensure that your app remains stable and functional with each code change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is possible to run parallel Android and iOS tests using Flank ([https://flank.github.io/flank/](https://flank.github.io/flank/)),
    which is compatible with the gcloud CLI. Flank provides extra features to accelerate
    velocity and increase quality.
  prefs: []
  type: TYPE_NORMAL
- en: One useful practice for mobile teams to safely release features quickly is to
    implement feature flags. Let’s discuss this concept and how it can be utilized.
  prefs: []
  type: TYPE_NORMAL
- en: A/B testing and feature flags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A/B testing and feature flags are powerful techniques used in mobile app development
    to experiment, validate, and roll out new features or variations to a subset of
    users. Let’s delve into how A/B testing and feature flags can benefit mobile apps
    and the tools available for implementing them.
  prefs: []
  type: TYPE_NORMAL
- en: A/B testing for mobile apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A/B testing involves presenting different versions of an app or specific features
    to different user groups to evaluate their impact on user experience, engagement,
    or **key performance** **indicators** (**KPIs**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Experimentation**: A/B testing tools enable developers to define experiments,
    create alternative variations (A and B), and assign users randomly to each variation.
    For example, you might test different app layouts, navigation structures, or button
    placements.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Measurement**: Metrics and analytics are essential for evaluating the success
    of A/B tests. By monitoring user interactions, conversions, or other relevant
    KPIs, you can assess which variation performs better and drives the desired user
    behavior.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Analysis and iteration**: Analyzing the test results helps you make data-driven
    decisions. You can refine and iterate on the tested features or versions based
    on the insights gained to improve the app’s performance and user experience, as
    shown in the following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.5 – How A/B testing works](img/Figure_09.5_B18113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – How A/B testing works
  prefs: []
  type: TYPE_NORMAL
- en: Feature flags for mobile apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Feature flags, or toggles, enable developers to control the visibility and behavior
    of specific features or code sections within an app. Feature flags provide flexibility,
    allowing developers to roll out new features gradually, test them in production,
    or enable/disable them dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how feature flags work:'
  prefs: []
  type: TYPE_NORMAL
- en: Feature flag libraries or SDKs are integrated into the app’s code base to enable
    runtime control over feature availability. Flags can be configured to turn features
    on or off based on predefined conditions, such as user segments, device types,
    or app versions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Feature flags enable developers to conduct targeted tests by selecting features
    for specific user groups. This helps assess feature performance, gather feedback,
    and make data-driven decisions before releasing the features to a broader audience,
    as shown in the following figure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 9.6 – How feature flags work](img/Figure_09.6_B18113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – How feature flags work
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of the most popular tools for flagging features in mobile apps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**LaunchDarkly** ([https://launchdarkly.com](https://launchdarkly.com)) is
    a feature management platform that provides robust feature flagging capabilities.
    It allows you to control feature availability, target specific user segments,
    and easily manage flags through a web-based dashboard.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ConfigCat** ([https://configcat.com/](https://configcat.com/)) offers a feature
    flag and configuration management platform that supports mobile app development.
    It allows you to create feature flags, control their visibility, and dynamically
    update configurations without requiring app updates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flagsmith** ([https://flagsmith.com/](https://flagsmith.com/)) is an open
    source feature flagging and remote configuration platform. It provides a range
    of features, including A/B testing, targeting rules, and integration with various
    development frameworks for mobile app implementation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Firebase Remote Config** ([https://firebase.google.com/products/remote-config](https://firebase.google.com/products/remote-config))
    is a cloud-based service that allows developers to dynamically configure and customize
    their applications without requiring a new release or an app update. It enables
    developers to remotely control and personalize various aspects of their app, such
    as text, images, colors, and behavior, allowing for targeted content delivery
    and A/B testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Optimizely** ([https://www.optimizely.com](https://www.optimizely.com)) is
    a powerful experimentation and personalization platform that enables businesses
    to make data-driven decisions and enhance their digital experiences.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some of the benefits of A/B testing and feature flags for mobile apps are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: They help you make informed decisions based on real user data, improving the
    chances of successful feature launches and updates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By gradually rolling out features or enabling them for specific user segments,
    you mitigate risks associated with bugs, performance issues, or negative user
    reactions. This ensures a smoother and safer deployment process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They allow for quick iteration and refinement of features based on user feedback
    and measurable results. This iterative process enhances the development cycle
    and speeds up feature delivery.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feature flags enable personalized experiences by tailoring app features to specific
    user groups or individual users. This customization enhances user satisfaction
    and engagement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A/B testing and feature flags offer mobile app developers valuable techniques
    for experimentation, validation, and controlled rollouts. Consider using tools
    such as Firebase Remote Config, Optimizely, LaunchDarkly, ConfigCat, or Flagsmith
    to implement these strategies and unlock the benefits of data-driven decision-making
    and flexible feature management in your mobile app development process.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will examine the use of mock APIs for mobile UI testing, which can
    save you time and effort by allowing you to test your app’s UI without setting
    up a real API or waiting for network responses. It can also help you test the
    app’s behavior in different scenarios and conditions that may be difficult to
    set up with a real API.
  prefs: []
  type: TYPE_NORMAL
- en: Mock APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Mock APIs** are vital in simplifying mobile app development by decoupling
    backend dependencies, speeding up development cycles, and enhancing testability.'
  prefs: []
  type: TYPE_NORMAL
- en: When selecting a mock API solution, consider its integration with your development
    workflow, customization options, documentation, and community support. By leveraging
    mock APIs, mobile app developers can streamline development, improve app quality,
    and iterate more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: A mock API for mobile UI testing is a simulated API that allows you to test
    the UI of your mobile app without having to connect to a real API. It can be helpful
    in a number of different situations, such as when the real API is not yet available,
    when you want to test the app’s behavior in different scenarios that may not be
    possible to set up with a real API, or when you want to test the app’s performance
    without being slowed down by network latency.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.7 – How a mock server works](img/Figure_09.7_B18113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – How a mock server works
  prefs: []
  type: TYPE_NORMAL
- en: You can create a mock API for mobile UI testing using several tools, such as
    **WireMock** ([https://wiremock.org/](https://wiremock.org/)), the open source
    tool that allows you to create a mock API by defining the HTTP requests and responses
    it should return. It can be run as a standalone server, or it can be used as a
    Java library in your test code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of setting up a simple mock API endpoint that returns a JSON
    response: [https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-9/mockTest.kt](https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-9/mockTest.kt).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how you can incorporate the WireMock server into your
    Android test setup: [https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-9/MyApiTest.kt](https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-9/MyApiTest.kt).'
  prefs: []
  type: TYPE_NORMAL
- en: Run the Android tests. The requests made to the specified API endpoint on the
    local mock server (e.g., `http://localhost:8080/api/endpoint` or `http://mock-server.com/api/endpoint`)
    will be intercepted by WireMock, which will respond with the configured mock response.
  prefs: []
  type: TYPE_NORMAL
- en: Building, testing, and releasing with fastlane
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**fastlane** ([https://fastlane.tools/](https://fastlane.tools/)) is a powerful
    automation tool specifically designed to streamline the process of building, testing,
    and releasing mobile apps. It provides different features and integrations to
    automate repetitive tasks, saving mobile developers valuable time and effort.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s dive into the key aspects of using fastlane for building, testing, and
    releasing mobile apps:'
  prefs: []
  type: TYPE_NORMAL
- en: fastlane simplifies the build configuration process. You can define your build
    settings, such as code signing, provisioning profiles, and build flavors, in a
    readable manner using fastlane’s configuration files (Fastfile) ([https://docs.fastlane.tools/advanced/Fastfile/](https://docs.fastlane.tools/advanced/Fastfile/)).
    This eliminates the need for manual configuration and reduces the chances of errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: fastlane integrates with popular testing frameworks such as XCTest and Espresso,
    enabling you to run unit, UI, and other custom tests as part of your build process.
    It can also handle test reporting and generate comprehensive test result reports.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: fastlane seamlessly integrates with popular CI/CD platforms such as GitHub Actions,
    Codemagic, and Bitrise. It provides dedicated plugins and integrations that facilitate
    the smooth incorporation of fastlane into your CI workflows. This ensures the
    consistent and automated building, testing, and releasing of your mobile apps
    as part of your CI pipeline.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: fastlane simplifies releasing your app to app stores. With its App Store Connect
    and Google Play plugins, you can automate the entire release process, including
    versioning, code signing, metadata management, and uploading your app bundles
    or APKs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: fastlane’s extensibility allows you to extend its functionality by creating
    custom actions or utilizing numerous existing plugins. fastlane’s plugin ecosystem
    ([https://docs.fastlane.tools/plugins/available-plugins/](https://docs.fastlane.tools/plugins/available-plugins/))
    provides a wide range of pre-built plugins that integrate with third-party services
    such as Slack, Firebase App Distribution, Sentry, BrowserStack, and more. These
    plugins enable you to incorporate additional functionality, such as crash reporting,
    beta testing, or analytics, into your fastlane workflows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: fastlane has a vibrant and active community that actively contributes to its
    development. Regular updates, new features, and bug fixes are released, ensuring
    you have access to the latest improvements and enhancements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Getting started with fastlane is relatively straightforward. Here’s a step-by-step
    guide to help get you up and running with fastlane:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure you have Ruby installed on your system. You can check this by running
    `ruby -v` in your Terminal. If Ruby is not installed, you can install it using
    a package manager such as **Homebrew** (for macOS) or **Chocolatey** (for Windows).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install fastlane by running `gem install fastlane` in your Terminal. This command
    will fetch and install the latest version of fastlane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to your mobile app project’s directory using the Terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `fastlane init` in the project directory. This command initializes fastlane
    and creates a new fastlane folder with configuration files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: fastlane uses a Fastfile to define and manage automation tasks. Open the Fastfile
    located in the fastlane directory using a text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: fastlane provides a wide range of built-in actions that cover common tasks.
    For example, you can use the scan action to run tests, and the delivery action
    to upload your app to the App Store.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: fastlane allows you to store sensitive information, such as code-signing certificates
    and API keys, securely. Create a new `.env file` in the fastlane directory and
    add the necessary environment variables for your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the `Appfile` located in the fastlane directory with relevant information,
    such as your app’s bundle identifier and Apple Developer account details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To execute a specific lane, run `fastlane <lane_name>` in the terminal. For
    example, fastlane beta will execute the beta lane defined in your Fastfile.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here’s an example of a Fastfile for an iOS app that includes lanes for building,
    testing, and releasing the app to TestFlight and the App Store ([https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-9/fastlane/Fastfile%20](https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-9/fastlane/Fastfile%20)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a basic example of how to use fastlane with GitHub Actions to automate
    your iOS app deployment process:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `.github/workflows` directory in your GitHub repository if it doesn’t
    exist. Inside this directory, create a YAML file (e.g., `i0S-fastlane.yml`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Configure a GitHub Actions workflow such as this example: [https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-9/.github/iOS-fastlane.yml](https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-9/.github/iOS-fastlane.yml).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace `./path/to/your/project` with the actual path to your iOS project directory,
    and replace `your_lane` with the fastlane lane you want to run (e.g., beta, release,
    etc.).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, whenever you push changes to the `main` branch, the GitHub Actions workflow
    will be triggered, and it will execute the defined steps, which include setting
    up the environment, installing dependencies, and running your fastlane lane.
  prefs: []
  type: TYPE_NORMAL
- en: This is a basic example, and you might need to adapt it to your specific project
    setup and requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure to review the fastlane and GitHub Actions documentation ([https://docs.fastlane.tools/best-practices/continuous-integration/github/](https://docs.fastlane.tools/best-practices/continuous-integration/github/))
    for more advanced configurations and options.
  prefs: []
  type: TYPE_NORMAL
- en: When using Bitrise, Codemagic, or any other CI providers, the process is similar.
    You will need to replace the pipeline steps with the fastlane commands and ensure
    that the necessary prerequisites for fastlane are installed on the VMs.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that fastlane is highly customizable, so feel free to adapt it to your
    specific project requirements. Don’t hesitate to refer to the official fastlane
    documentation ([https://docs.fastlane.tools](https://docs.fastlane.tools)) for
    more detailed information and examples.
  prefs: []
  type: TYPE_NORMAL
- en: The next section will explore ChatOps and how to include chat tools in team
    conversations in order to accelerate the mobile DevOps life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: ChatOps for mobile DevOps collaboration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In today’s fast-paced world of software development, effective collaboration
    and communication are key to achieving seamless mobile DevOps. With the rise of
    remote work and distributed teams, having a reliable and feature-rich platform
    that fosters real-time interaction is crucial.
  prefs: []
  type: TYPE_NORMAL
- en: 'ChatOps is a collaborative approach that brings together development, operations,
    and other teams by using chat platforms as the central hub for communication and
    automation. It enables seamless collaboration and integrates various tools, making
    it easier to manage the software development and deployment processes, as shown
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.8 – How ChatOps works](img/Figure_09.8_B18113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – How ChatOps works
  prefs: []
  type: TYPE_NORMAL
- en: Collaborating on mobile DevOps projects can be made more efficient and transparent
    by implementing ChatOps. This will improve communication and enable faster decision-making
    within the development team.
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefits that can be derived from ChatOps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Communication and the deployment of bots for automated tasks improve the agility
    of cross-functional teams, resulting in a shorter time to resolution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ChatOps allows us to combine skilled workers across various fields into a team
    without affecting organizational structures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Automation: Integrating bots is one of the most important achievements. They
    are our helpers that perform tasks according to programmed commands. In this way,
    bots can be assigned functions such as the search and deployment of code, and
    server reset, drastically reducing the time spent on an issue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Together, let’s explore various tools and services that can aid in implementing
    ChatOps for our mobile DevOps processes.
  prefs: []
  type: TYPE_NORMAL
- en: Slack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Slack** ([https://slack.com/](https://slack.com/)) is a popular communication
    tool known for its versatility and integration capabilities. Slack proves to be
    a powerful tool for ChatOps in mobile DevOps collaboration. Utilizing Slack for
    DevOps, also known as **SlackOps**, is the practice of utilizing the popular team
    collaboration tool Slack to streamline and enhance communication, collaboration,
    and automation within DevOps processes. DevOps is an approach that combines software
    **development** (**Dev**) and IT **operations** (**Ops**) to foster a culture
    of collaboration, CI/CD, and automation. SlackOps takes advantage of Slack’s real-time
    messaging, channels, integrations, and bots to improve the efficiency and effectiveness
    of DevOps teams. Here are a few benefits of using Slack with DevOps:'
  prefs: []
  type: TYPE_NORMAL
- en: It provides a centralized space for teams to communicate, share ideas, and discuss
    project updates. It offers real-time messaging and voice and video calling, allowing
    quick and efficient collaboration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of Slack’s greatest strengths is its extensive integration ecosystem. It
    seamlessly connects with various tools and platforms used in the DevOps ecosystem,
    such as GitHub Actions for CI/CD pipelines, GitHub for version control systems,
    Jira for project management tools, and monitoring services. This integration capability
    allows for automated notifications and updates, reducing the need for context-switching
    across different applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slack’s mobile app delivers a smooth user experience, enabling team members
    to stay connected and engaged. It provides push notifications, intuitive navigation,
    and access to all essential features, ensuring uninterrupted collaboration regardless
    of location.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mobile DevOps teams can use Slack to simplify workflows, automate the release
    process, share the test results, and stay productive.
  prefs: []
  type: TYPE_NORMAL
- en: AWS Chatbot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**AWS Chatbot** ([https://aws.amazon.com/chatbot/](https://aws.amazon.com/chatbot/)),
    a service provided by **Amazon Web Services** (**AWS**), aims to streamline these
    processes by integrating them with popular chat platforms. It can integrate with
    popular messaging services such as Slack, Microsoft Teams, and Amazon Chime. You
    need to choose the messaging service you want to use and connect AWS Chatbot to
    it. This will enable you to receive notifications and alerts from AWS services
    in your messaging service.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, it’s important to create an AWS Chatbot within your AWS account.
    This can easily be done by accessing the AWS Management Console and selecting
    the AWS Chatbot service. From there, you can create a new chatbot and customize
    its settings according to your needs. Keep in mind that AWS Chatbot offers several
    advantages, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Integrates seamlessly with popular chat platforms such as Slack, Microsoft Teams,
    and Amazon Chime. This integration lets teams receive real-time notifications,
    alerts, and updates directly in their preferred chat environment, reducing context
    switching and keeping everyone informed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Teams can define custom workflows for ChatOps, automating repetitive tasks and
    facilitating collaboration. By using chat commands, team members can perform actions
    on AWS resources, retrieve information, initiate deployments, and execute predefined
    scripts. This capability empowers teams to efficiently manage their infrastructure
    without leaving the chat environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, adopting mobile DevOps best practices is a crucial step toward
    achieving streamlined and high-quality mobile application development. By combining
    the expertise of developers, test engineers, release specialists, and other stakeholders,
    organizations can accelerate the development and deployment process, resulting
    in faster delivery times and improved user experiences.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we focused on the best practices of mobile DevOps to accelerate
    the development and release process of high-quality mobile applications. By combining
    the expertise of developers, test engineers, release experts, and other stakeholders,
    organizations can streamline the mobile app development process and deliver frequent
    updates to customers, thereby enhancing both speed and quality.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you gained essential skills in the best practices for CI/CD,
    mobile app versioning, IaC, configuration management, A/B testing, remote and
    dependency caching, parallel CI builds, fastlane automation, API mocking, and
    ChatOps collaboration. These skills will empower you to excel in mobile app development
    and streamline your processes effectively.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll discuss how platform engineering and **developer
    experience** (**DevX**) can increase productivity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 4: Moving Beyond Mobile DevOps and the Future of DevOps'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The future of Mobile DevOps is likely to involve a continued focus on improving
    the speed and quality of mobile app development. This will likely involve the
    use of newer technologies and practices that help to improve the speed and quality
    of mobile app development.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B18113_10.xhtml#_idTextAnchor377)*, Improving Productivity with
    Developer Experience and Platform Engineering*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B18113_11.xhtml#_idTextAnchor410)*, Predicting the Future of
    Mobile DevOps*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
