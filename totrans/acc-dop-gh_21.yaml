- en: '*Chapter 17*: Empower Your Teams'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If my customers are not content with their architecture, I let them explain
    the organizational structure of their product and draw a diagram of it. If you
    compare this organizational chart with their architecture diagram, you always
    can find a lot of similarities. This correlation between the organizational structure
    and software architecture is called **Conway's law**.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you'll learn how you can leverage this correlation to improve
    your architecture, organization structure, and software delivery performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the core topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Conway's law
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The two-pizza team
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inverse Conway Maneuver
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delivery cadence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A mono- or multi-repo strategy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conway's law
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Conway''s law goes back to an essay from 1968 (*Conway, Melvin, 1968*, p31):'
  prefs: []
  type: TYPE_NORMAL
- en: '"Organizations which design systems (…) are constrained to produce designs
    which are copies of the communication structure of the organizations."'
  prefs: []
  type: TYPE_NORMAL
- en: – Melvin E. Conway
  prefs: []
  type: TYPE_NORMAL
- en: The law is not specific to software or system architecture but to the design
    of any system. Note that it is not referring to an organization's management structure
    but its communication structure. These might be the same thing – but in some cases,
    it's not. Normally, if the organizational chart does not match the software design,
    you can look for the communication flow, and it is different from the organizational
    chart.
  prefs: []
  type: TYPE_NORMAL
- en: 'If, for example, you have many small teams or individual developers that receive
    requirements from different customers or consultants, they will probably talk
    to each other without any organizational boundaries. The system they are working
    on will reflect that and consist of many modules with a high cohesion that reference
    each other – a so-called *spaghetti architecture*. Whereas teams that work together
    and receive their input through one communication channel – for example, a product
    owner – will build a system with a high cohesion in the modules that the team
    works on. But the parts of the system the other teams work on will have fewer
    references. To put it in the words of *Eric S. Raymond*, "*if three teams are
    working on a compiler, you''ll get a three-pass compiler*" (see *Raymond, Eric
    S. 1996*, p124). *Figure 17.1* visualizes these two examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.1 – Examples of the different software designs based on a communication
    structure'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_17_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.1 – Examples of the different software designs based on a communication
    structure
  prefs: []
  type: TYPE_NORMAL
- en: But what is the desired communication structure that will lead to a system design
    that helps teams to accelerate their engineering velocity?
  prefs: []
  type: TYPE_NORMAL
- en: The two-pizza team
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the most discussed microservice-based architectures that allows thousands
    of deployments per day at a large scale is the architecture of **Amazon**. They
    use the **two-pizza rule** for their team setup (*Amazon, 2020*):'
  prefs: []
  type: TYPE_NORMAL
- en: '"We try to create teams that are no larger than can be fed by two pizzas."'
  prefs: []
  type: TYPE_NORMAL
- en: – Jeff Bezos
  prefs: []
  type: TYPE_NORMAL
- en: 'But how many people exactly can you feed with two pizzas? In our user groups,
    we always calculate one party pizza for three to four people. That would make
    a team size of six to eight people. At Giordano''s in the US, they use the 3/8
    rule – the number of pizzas you order should be three times the number of people
    to feed divided by eight:'
  prefs: []
  type: TYPE_NORMAL
- en: This would result in a maximum of 5 to 6 people in each team. So, the size of
    a two-pizza team is not very well defined – and I think it has nothing to do with
    the hunger of the team members. The rule just means that the team should be small.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem with big teams is that the number of links in the team grows rapidly
    with every team member added. You can calculate the number of links using the
    following formula:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, *n* is the number of people in the team. This means that a team with
    6 members has 15 links between the members – whereas a team of 12 already has
    66 links (see *Figure 17.2*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.2 – The number of links between the members of a team'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_17_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.2 – The number of links between the members of a team
  prefs: []
  type: TYPE_NORMAL
- en: 'If people work in teams, they experience a positive synergy. The diversity
    and communication help to increase quality as well as the outcome. But if you
    add more people to the team, communication overhead and slower decision-making
    lead to a negative synergy (see *Figure 17.3*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.3 – Effectiveness of collaboration and team size'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_17_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.3 – Effectiveness of collaboration and team size
  prefs: []
  type: TYPE_NORMAL
- en: But what is the magic number – the optimum number of people for a team?
  prefs: []
  type: TYPE_NORMAL
- en: The US Navy Seals state that four is the optimal size for a combat team (*Willink,
    J. and Leif Babin, L., 2017*). They also rely on high-frequency communication
    in a complex environment. But the skills of a combat team are probably more linear
    than those of a cross-functional development team. So, there is no evidence that
    the number is also optimum for development teams.
  prefs: []
  type: TYPE_NORMAL
- en: In Scrum, **Miller's law** states that the magical number seven, plus or minus
    two (*Miller, G.A., 1956*), is used to define the recommended team size. Miller's
    law is an essay from 1956 on the limitations of our short memory that was associated
    with communication capabilities. But Miller's law was scientifically refuted,
    and the reason that Scrum still uses the numbers is that five to nine is simply
    a good team size in many circumstances – but without any scientific substantiation.
    There are also high-performance scrum teams with only 3 members – and others with
    14 members.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a study from QSM analyzing 491 development projects. The study concludes
    that smaller teams have higher productivity, less development effort, and a better
    development schedule (*QSM, 2011*). The clusters of a team with 1.5 to 3 people,
    3 to 5 people, and 5 to 7 people were close together. More than seven people led
    to a dramatic increase in development effort (see *Figure 17.4*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.4 – A summary of the results of the QSM study'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_17_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.4 – A summary of the results of the QSM study
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several reasons why smaller teams perform better than larger teams
    (see *Cohn M., 2009*, pp177–180):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Social loafing**: Social loafing is a phenomenon where persons tend to exert
    less effort to achieve a goal when they work in a group where individual performance
    cannot be measured (*Karau, S.J., and Williams, K.D., 1993*). Smaller groups tend
    to be less affected by social loafing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cohesion and ownership**: Smaller teams have more constructive interactions,
    and it is easier for the members to build feelings of trust, mutual ownership,
    and cohesiveness (*Robbins S., 2005*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Coordination effort**: In a smaller team, there is less time spent on coordination.
    Simple things – such as coordinating a meeting – tend to be much more complex
    in larger teams.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**More rewarding**: The contributions of an individual are more visible in
    smaller teams. This, and the better social cohesiveness, lead to a more rewarding
    environment if the team size is smaller (*Steiner, I.D., 1972*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, smaller teams have also some disadvantages. The biggest is the risk
    of **losing one or more team members**, which is much harder to be compensated
    for in smaller teams. Another disadvantage is **the lack of certain expert skills**.
    If you need deep expertise in five areas, it is nearly impossible to deliver it
    with a three-member team.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at this data, the optimal size for a two-pizza team is somewhere between
    three and seven – balancing the advantages and disadvantages, depending on your
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Inverse Conway Maneuver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know the optimal size for our teams, we can perform something that
    is called the **Inverse Conway Maneuver** (*Forsgren N., Humble, J., and Kim,
    G., 2018*, page 102). If you evolve your organization structure to autonomous
    two-pizza teams, your architecture evolves into a more loosely coupled one.
  prefs: []
  type: TYPE_NORMAL
- en: 'But it''s not just the team size! If you create your teams around functionalities,
    it will result in a layered or multi-tier architecture. If you put frontend developers
    and database specialists in teams, your architecture will decouple at these communication
    points (see *Figure 17.5*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.5 – Functional teams lead to a layered architecture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_17_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.5 – Functional teams lead to a layered architecture
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve a deployable and testable architecture that empowers the teams,
    you must create cross-functional teams responsible for business outcomes. This
    will lead to the desired architecture that helps you to move fast (see *Figure
    17.6*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.6 – Cross-functional teams aligned around business capabilities
    for fast value delivery'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_17_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.6 – Cross-functional teams aligned around business capabilities for
    fast value delivery
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four types of team topologies that have a positive impact on system
    architecture and, therefore, software delivery performance (*Skelton M., and Pais
    M., 2019*):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Value stream-aligned**: This is the most important team topology – cross-functional
    teams that can deliver significant value to their customers without relying on
    other teams to do so. These teams need all required skills to deliver value –
    for example, UX, QA, DBA, and operational skills.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Platform teams**: Teams that build the platform that enables the value stream-aligned
    teams to deliver value by reducing complexity and simplifying the software delivery
    process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enabling teams**: Teams that enable other teams to take responsibility as
    part of an onboarding, transitional, or training phase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subsystem team**: This team type should only be created if absolutely necessary!
    If a subsystem is too complicated to be handled by stream-aligned teams or platform
    teams, it might be preferable to have a functional team that handles this subsystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important that each team has a clear responsibility and can deliver value
    without relying on other teams to finish certain tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'But to achieve the desired effect on performance, you have to limit how the
    teams interact to one of the following three **modes of interaction**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Collaboration**: Two or more teams work closely together for a certain time
    and share the responsibility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Self-service**: A team provides its value to another team as a service. The
    responsibilities are clearly separated, and the service can be consumed as easily
    and automated as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Facilitating**: One team enables another team and helps them for a certain
    time to learn new things or develop new habits.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building an effective team topology with good, well-defined communication and
    interaction has a huge influence – not only on the system architecture but also
    on the engineering velocity.
  prefs: []
  type: TYPE_NORMAL
- en: Delivery cadence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even with cross-functional, autonomous teams, you'll still have some interdependencies
    and communication flow occurring between the teams. In the first chapters of this
    book, when I explained the flow of work and metrics, I focused on efficiency,
    flow, batch size, and a continuous delivery value. But you still need some cadence
    to control your flow. In Scrum, this is called **empirical process control**.
    After a certain time, you pause to **inspect** and **adopt** – not only what you
    deliver but also your process and team dynamics. This time span is called a **sprint**
    in Scrum. I don't like that term because it implies a fast pace, and development
    should have a constant, steady pace. You don't sprint if you want to run a marathon
    – and product development is a marathon and not a series of sprints (but a marathon
    does not match with the analogy of rugby, of course). But no matter what you call
    these intervals, they are important for continuous learning and adoption and team
    building. These intervals are also important to communicate – to stakeholders
    and other teams.
  prefs: []
  type: TYPE_NORMAL
- en: That's why these intervals should be aligned across all teams. They should determine
    the steady cadence and act as the heartbeat of the engineering organization.
  prefs: []
  type: TYPE_NORMAL
- en: 'The intervals should not be too long and not too short. A month would be the
    maximum and a minimum of 2 weeks for most companies. That does not mean that teams
    can''t do smaller iterations or sprints. They can still do 1-week sprints; they
    just would align them with the global cadence. You can have a faster pace and
    align it to a slower cadence – but not vice versa (see *Figure 17.7*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.7 – Aligning faster iterations with the delivery cadence'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_17_007.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.7 – Aligning faster iterations with the delivery cadence
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, *x* does not necessarily have to be measured in weeks. When defining
    the cadence, think about the **pulse of the entire organization**. If everything
    in your organization runs on a monthly basis, then a 3-week cadence would not
    be in sync with the rest of your company. In this case, defining a monthly cadence
    – or a fraction of it – is the better choice and causes less friction. If your
    company is publicly traded and uses the 4-4-5 calendar, a fiscal quarter might
    be your pulse. Have a look at the organization pulse and sync your sprint cadence
    with it so that the intervals are in harmony with the organization pulse (see
    *Figure 17.8*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.8 – Align your cadence to be in sync with the organization pulse'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_17_008.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.8 – Align your cadence to be in sync with the organization pulse
  prefs: []
  type: TYPE_NORMAL
- en: If your cadence is not in sync with your organization, it will generate friction.
    Meetings will conflict, and feedback and numbers might not be available when you
    need them. A consistent cadence in sync with your organizational pulse will help
    to smooth out flow and improve communication (*Reinertsen D., 2009*, pp176–78).
  prefs: []
  type: TYPE_NORMAL
- en: A mono- or multi-repo strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Besides team size and cadence, the way you structure your code has also an
    impact on your architecture if you want to perform the Inverse Conway Maneuver.
    There are two strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: '**A mono-repo strategy**: There is only one repository that contains all modules
    (or microservices) that are needed by an application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A multi-repo strategy**: Each module or microservice lives in its own repository,
    and you must deploy multiple repositories to get a complete working application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both strategies have advantages and disadvantages. The biggest advantage of
    the mono-repo strategy is that it is easy to deploy and debug the entire application.
    But mono repos tend to get very large very fast, and that reduces the performance
    of Git. Also, deploying and testing different parts of the application independently
    becomes difficult with a growing repository. This leads to a tighter coupling
    of the architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Working with large mono repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What does big repo mean in the context of Git? The repo of the Linux kernel
    is about 3 GB. It takes quite some time to clone, and the individual Git commands
    are slow – but still in an acceptable range. The Windows repository has about
    300 GB – 100 times the Linux kernel. Performing certain Git actions on the Windows
    repository takes some time:'
  prefs: []
  type: TYPE_NORMAL
- en: '`git clone`: About 12 hours'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git checkout`: About 3 hours'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git status`: About 8 minutes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git add and git commit`: About 3 minutes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That''s why Microsoft maintains its own fork of the Git client ([https://github.com/microsoft/git](https://github.com/microsoft/git)).
    This fork contains a lot of optimizations for large repositories. It includes
    the **scalar CLI** ([https://github.com/microsoft/git/blob/HEAD/contrib/scalar/docs/index.md](https://github.com/microsoft/git/blob/HEAD/contrib/scalar/docs/index.md))
    that can be used to set advanced Git config settings, maintain the repository
    in the background, and help to reduce data sent across the network. These improvements
    reduce the time for the Git actions in the Windows repository enormously:'
  prefs: []
  type: TYPE_NORMAL
- en: '`git clone`: 12 hours to 90 seconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git checkout`: 3 hours to 30 seconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git status`: 8 minutes to 3 seconds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many of these optimizations are already part of the Git client now. You can
    use, for example, `git sparse-checkout` ([https://git-scm.com/docs/git-sparse-checkout](https://git-scm.com/docs/git-sparse-checkout)),
    which allows you to only download the parts of your repository that you need.
  prefs: []
  type: TYPE_NORMAL
- en: You only need the Microsoft fork if your repository is really huge; otherwise,
    you can probably optimize using the normal Git features.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing your repos with topics and star lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The biggest advantage of the multi-repo strategy is that you reduce the complexity
    of the individual repositories. Each repository can be maintained and deployed
    autonomously. The biggest disadvantage is that it is hard to build and test the
    entire application. But to get feedback from real users or to debug complex bugs,
    it is normally not enough to deploy an individual service or module – you need
    to update the entire application. This means coordinating multiple deployments
    across your repo boundaries.
  prefs: []
  type: TYPE_NORMAL
- en: If you choose the multi-repo strategy, you'll end up with many small repositories.
    A good naming convention can help to structure them. You can also use **topics**
    to organize your repos. Topics can be set at the top-right corner of your repo
    (see *Figure 17.9*).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.9 – You can set topics for your repositories for better discoverability'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_17_009.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.9 – You can set topics for your repositories for better discoverability
  prefs: []
  type: TYPE_NORMAL
- en: 'You can filter your repositories using the `topic`: keyword (see *Figure 17.10*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.10 – Filter repositories based on topics'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_17_010.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.10 – Filter repositories based on topics
  prefs: []
  type: TYPE_NORMAL
- en: 'Another feature that you can use to organize large numbers of repositories
    is **star lists**. This is a personal feature and cannot be shared. In your GitHub
    profile, you can create lists and organize your starred repositories (see *Figure
    17.11*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 17.11 – Organize your starred repositories in lists'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_17_011.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 17.11 – Organize your starred repositories in lists
  prefs: []
  type: TYPE_NORMAL
- en: You can use these features like favorites in your browser, but they do not solve
    the problem of deploying, debugging, or testing your entire application.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using Kubernetes for your microservices, you can use the **Bridge
    to Kubernetes** plugin ([https://marketplace.visualstudio.com/items?itemName=mindaro.mindaro](https://marketplace.visualstudio.com/items?itemName=mindaro.mindaro))
    in Visual Studio Code to debug a local service in the context of a production
    or test cluster (see *Medina A. M., 2021*). But if you rely on building and deploying
    all services at once, the best solution is to have a meta-repository that references
    all services as a submodule.
  prefs: []
  type: TYPE_NORMAL
- en: Using Git submodules to structure your code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use a meta-repository that contains all other repositories as submodules.
    This allows you to clone all repositories with one command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, to update the meta-repository if you already have it cloned,
    use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The repository can contain the scripts or workflows to deploy the application
    as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use this meta-repository to do the release management and bundle the
    stable versions together. If you use branches for releases, then you can set your
    submodule to a certain branch and update it before you release the latest version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you use tags for releases, then you can set each submodule to a specific
    version and commit this to your meta-repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Other people can then pull the changes and update the submodules to the version
    corresponding to the tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Git submodules are a nice way to work in multi-repos and deploy independently
    while still being able to manage an application as a whole. But be aware that
    the more interdependencies you have, the more complex the maintenance of the meta-repos
    and keeping them in a deployable state will be.
  prefs: []
  type: TYPE_NORMAL
- en: What's the right strategy?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the mono-repo strategy or the multi-repo strategy are better suited for your
    teams it tightly couples to [*Chapter 16*](B17827_16_Epub.xhtml#_idTextAnchor335),
    *Loosely C**oupled Architecture and Microservices*, when we talked about **evolutionary
    design**. Mono-repos are good for small products and greenfield projects. With
    growing size and complexity, it's best to split microservices or modules up and
    move them to their own repos. But always have testability and deployability in
    mind – for the individual service/module and for the application as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: Case study
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'After the first three successful sprints, more teams at **Tailwind Gears**
    are moved to a new platform. The first teams have been selected to own a product
    that is already independently testable and deployable. With the scrum master,
    product owner, and QA member, they are a little big for the two-pizza rule, but
    this will be addressed later. The teams to follow are way too big, and they work
    on big monolith applications with a lot of interdependencies. To perform the Inverse
    Conway Maneuver, all the teams come together and self-organize the next teams
    to be moved to the new platform. The constraints are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: No bigger than a two-pizza team
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Responsible for a business capability (a `StranglerFigApplication` pattern and
    be tested and deployed autonomously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This helps to evolve the design of the applications. The new microservices are
    cloud-native and have their own cloud-native data store. They get integrated into
    the existing applications using an API and event-driven architecture. The microservices
    are moved to their own repositories on the new platform because they get deployed
    independently most of the time. Synchronization with the other teams is done using
    feature flags.
  prefs: []
  type: TYPE_NORMAL
- en: For embedded software, this does not work. The teams need a way to build and
    deploy the application as a whole. But they also want to deploy and test individual
    modules. That's why the teams decide to split the application into different repositories
    and have one meta-repository that includes the other repos as submodules. This
    allows the individual teams to deploy their module to test hardware at any time
    to test new features in real-world scenarios – but it keeps the product in state,
    where it can be released at any time.
  prefs: []
  type: TYPE_NORMAL
- en: When the first teams were moved to the new platform, they kept their existing
    **sprint cadence** of 3 weeks. Since the teams could work more or less autonomously,
    this was not a problem. With more teams coming to the new platform, the cadence
    gets aligned with the other teams. Tailwind Gears is a public traded company and
    used to do all its business reporting on a quarterly basis. They also report on
    a weekly basis and have a normalized 4-4-5 calendar. There are a lot of meetings
    at the end and beginning of each quarter that often collide with sprint meetings.
    The teams decide to adjust their cadence to this rhythm. The quarter consists
    of 13 weeks – but one week has the quarterly meeting, so this week is stripped
    from the sprint calendar. This week is also used for the quarterly big-room planning.
    The remaining 12 weeks are divided into 6 two-week sprints.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you've learned how to use the influence of your team structure
    and communication flow on your software and system architecture to perform the
    Inverse Conway Maneuver. This helps you to achieve a loosely coupled architecture
    of autonomously testable and deployable units that have a positive impact on your
    software delivery performance.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapters, we'll focus more on what to build and less on how to build
    it. You'll learn about lean product development and how to incorporate customer
    feedback in your work.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are the references from this chapter that you can also use to get more
    information on the topics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Conway, Melvin (1968). *How do committees invent*: [http://www.melconway.com/Home/pdf/committees.pdf](http://www.melconway.com/Home/pdf/committees.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raymond, Eric S. (1996). *The New Hacker's Dictionary* [3rd ed.]. MIT Press
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Amazon (2020): *Introduction to DevOps on AWS* - *Two-Pizza Teams*: [https://docs.aws.amazon.com/whitepapers/latest/introduction-devops-aws/two-pizza-teams.html](https://docs.aws.amazon.com/whitepapers/latest/introduction-devops-aws/two-pizza-teams.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Willink, J. and Leif Babin, L. (2017). *Extreme Ownership: How U.S. Navy SEALs
    Lead and Win*. Macmillan'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Miller, G.A. (1956). *The magical number seven, plus or minus two: Some limits
    on our capacity for processing information*: [http://psychclassics.yorku.ca/Miller/](http://psychclassics.yorku.ca/Miller/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cohn M. (2009). *Succeeding with Agile: Software Development Using Scrum*.
    Addison-Wesley'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'QSM (2011). *Team Size Can Be the Key to a Successful Software Project*: [https://www.qsm.com/process_improvement_01.html](https://www.qsm.com/process_improvement_01.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Karau, S. J. and Williams, K. D. (1993). *Social loafing: A meta-analytic review
    and theoretical integration*. *Journal of Personality and Social Psychology*,
    65(4), 681–706\. [https://doi.org/10.1037/0022-3514.65.4.681](https://doi.org/10.1037/0022-3514.65.4.681)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Robbins S. (2005). *Essentials of organizational behavior*. Prentice Hall
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Steiner, I.D. (1972). *Group process and productivity*. Academic Press Inc.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Forsgren N., Humble, J., and Kim, G. (2018). *Accelerate: The Science of Lean
    Software and DevOps: Building and Scaling High Performing Technology Organizations*
    (1st ed.) [E-book]. IT Revolution Press'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Skelton M. and Pais M. (2019). *Team Topologies: Organizing Business and Technology
    Teams for Fast Flow*. IT Revolution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Reinertsen D. (2009). *The Principles of Product Development Flow: Second Generation
    Lean Product Development*. Celeritas Publishing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Medina A. M. (2021). *Remote debugging on Kubernetes using VS Code*: [https://developers.redhat.com/articles/2021/12/13/remote-debugging-kubernetes-using-vs-code](https://developers.redhat.com/articles/2021/12/13/remote-debugging-kubernetes-using-vs-code)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
