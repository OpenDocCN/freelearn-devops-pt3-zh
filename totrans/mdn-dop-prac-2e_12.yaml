- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Continuous Deployment/Delivery with Argo CD
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Argo CD进行持续部署/交付
- en: In the previous chapter, we looked at one of the key aspects of modern DevOps
    – **continuous integration** (**CI**). CI is the first thing most organizations
    implement when they embrace DevOps, but things don’t end with CI, which only delivers
    a tested build in an artifact repository. Instead, we would also want to deploy
    the artifact to our environments. In this chapter, we’ll implement the next part
    of the DevOps toolchain – **continuous** **deployment/delivery** (**CD**).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了现代DevOps的一个关键方面——**持续集成**（**CI**）。CI是大多数组织在采用DevOps时首先实施的内容，但事情并不止于CI，CI只会将经过测试的构建交付到工件仓库。而我们还希望将工件部署到我们的环境中。在本章中，我们将实现DevOps工具链的下一部分——**持续**
    **部署/交付**（**CD**）。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主要内容：
- en: The importance of CD and automation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CD和自动化的重要性
- en: CD models and tools
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CD模型和工具
- en: The Blog App and its deployment configuration
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 博客应用及其部署配置
- en: Continuous declarative IaC using an Environment repository
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用环境仓库进行持续声明式IaC
- en: Introduction to Argo CD
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Argo CD简介
- en: Installing and setting up Argo CD
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装和设置Argo CD
- en: Managing sensitive configurations and secrets
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理敏感配置和密钥
- en: Deploying the sample Blog App
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署示例博客应用
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, we will spin up a cloud-based Kubernetes cluster, **Google
    Kubernetes Engine** (**GKE**), for the exercises. At the time of writing, **Google
    Cloud Platform** (**GCP**) provides a free $300 trial for 90 days, so you can
    go ahead and sign up for one at [https://console.cloud.google.com/](https://console.cloud.google.com/).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将启动一个基于云的Kubernetes集群，**Google Kubernetes Engine**（**GKE**），用于练习。写作时，**Google
    Cloud Platform**（**GCP**）提供免费的300美元试用，时效为90天，因此你可以在[https://console.cloud.google.com/](https://console.cloud.google.com/)注册一个账号。
- en: 'You will also need to clone the following GitHub repository for some exercises:
    [https://github.com/PacktPublishing/Modern-DevOps-Practices](https://github.com/PacktPublishing/Modern-DevOps-Practices).'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要克隆以下GitHub仓库来进行一些练习：[https://github.com/PacktPublishing/Modern-DevOps-Practices](https://github.com/PacktPublishing/Modern-DevOps-Practices)。
- en: 'Run the following command to clone the repository into your home directory,
    and `cd` into the `ch12` directory to access the required resources:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令将仓库克隆到你的主目录，并进入`ch12`目录以访问所需资源：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: So, let’s get started!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们开始吧！
- en: The importance of CD and automation
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CD和自动化的重要性
- en: CD forms the Ops part of your DevOps toolchain. So, while your developers are
    continuously building and pushing code and your CI pipeline is building, testing,
    and publishing the builds to your artifact repository, the Ops team will deploy
    the build to the test and staging environments. The QA team is the gatekeeper
    that will ensure that the code meets a certain quality, and only then will the
    Ops team deploy the code to production.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: CD构成了你DevOps工具链中的Ops部分。因此，在你的开发人员不断构建和推送代码，而CI管道负责构建、测试并将构建发布到工件仓库时，Ops团队将把构建部署到测试和暂存环境。QA团队是把关人，确保代码符合一定质量标准，只有通过后，Ops团队才会将代码部署到生产环境。
- en: Now, for organizations implementing only the CI part, the rest of the activities
    are manual. For example, operators will pull the artifacts and run commands to
    do the deployments manually. Therefore, your deployment’s velocity will depend
    on the availability of your Ops team to do it. As the deployments are manual,
    the process is error-prone, and human beings tend to make mistakes in repeatable
    jobs.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，对于只实施CI部分的组织，其余活动仍然是手动的。例如，操作员需要拉取工件并手动运行命令来进行部署。因此，部署的速度将取决于Ops团队的可用性。由于部署是手动的，流程容易出错，人类在重复性工作中容易犯错。
- en: One of the essential principles of modern DevOps is to avoid **toil**. Toil
    is nothing but repeatable jobs that developers and operators do day in and day
    out, and all of that toil can be removed by automation. This will help your team
    focus on the more important things at hand.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现代DevOps的一个基本原则是避免**繁琐工作**。繁琐工作就是开发人员和运维人员日复一日进行的重复性工作，而这些工作可以通过自动化消除。这将帮助你的团队专注于更重要的事情。
- en: With **continuous delivery**, standard tooling can deploy code to higher environments
    based on certain gate conditions. CD pipelines will trigger when a tested build
    arrives at the artifact repository or, in the case of GitOps, if any changes are
    detected in the Environment repository. The pipeline then decides, based on a
    set configuration, where and how to deploy the code. It also establishes whether
    manual checks are required, such as raising a change ticket and checking whether
    it’s approved.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 通过**持续交付**，标准工具可以基于某些门控条件将代码部署到更高环境。CD流水线将在测试构建到达工件库时触发，或者在GitOps的情况下，当检测到环境库中有任何变更时。然后，流水线会根据预设的配置决定在哪里以及如何部署代码。它还会确定是否需要手动检查，例如提出变更请求并检查是否已批准。
- en: While **continuous deployment** and delivery are often confused with being the
    same thing, there is a slight difference between them. Continuous delivery enables
    your team to deliver tested code in your environment based on a human trigger.
    So, while you don’t have to do anything more than click a button to do a deployment
    to production, it would still be initiated by someone at a convenient time (a
    maintenance window). Continuous deployments go a step further when they integrate
    with the CI process and will start the deployment process as soon as a new tested
    build is available for them to consume. There is no need for manual intervention,
    and continuous deployment will only stop in case of a failed test.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然**持续部署**和持续交付经常被混淆为相同的概念，但它们之间是有细微区别的。持续交付允许你的团队基于人工触发将经过测试的代码交付到你的环境中。因此，尽管你只需点击按钮就能将代码部署到生产环境中，但仍然需要某人在合适的时机（如维护窗口）发起部署。持续部署则更进一步，当它与CI过程集成时，一旦新的经过测试的构建可供使用，它会自动启动部署过程。不需要人工干预，持续部署只会在测试失败时停止。
- en: The monitoring tool forms the next part of the DevOps toolchain. The Ops team
    can learn from managing their production environment and provide developers with
    feedback regarding what they need to do better. That feedback ends up in the development
    backlog, and they can deliver it as features in future releases. That completes
    the cycle, and now you have your team churning out a technology product continuously.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 监控工具构成了DevOps工具链的下一部分。运维团队可以通过管理他们的生产环境来获得反馈，并向开发人员提供改进的建议。这些反馈最终会进入开发的待办事项列表，开发人员可以在未来的发布中将其作为新特性交付。这样就完成了一个周期，现在你的团队可以持续不断地推出技术产品。
- en: 'CD offers several advantages. Some of them are as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: CD提供了几个优势，其中一些如下：
- en: '**Faster time to market**: CD and CI reduce the time it takes to deliver new
    features, enhancements, and bug fixes to end users. This agility can give your
    organization a competitive edge by allowing you to respond quickly to market demands.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更快的市场响应时间**：CD和CI减少了将新特性、增强功能和修复程序交付给最终用户的时间。这种敏捷性可以使你的组织在市场需求面前具有竞争优势，快速做出反应。'
- en: '**Reduced risk**: By automating the deployment process and frequently pushing
    small code changes, you minimize the risk of large, error-prone deployments. Bugs
    and issues are more likely to be caught early, and rollbacks can be less complex.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**降低风险**：通过自动化部署过程并频繁推送小规模的代码变更，你可以最小化大型、易出错部署的风险。漏洞和问题更容易被早期发现，并且回滚操作也可以更简单。'
- en: '**Improved code quality**: Frequent automated testing and quality checks are
    an integral part of CD and CI. This results in higher code quality as developers
    are encouraged to write cleaner, more maintainable code. Any issues are caught
    and addressed sooner in the development process.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高代码质量**：频繁的自动化测试和质量检查是CD和CI的重要组成部分。这能提高代码质量，因为开发人员会被鼓励编写更简洁、更易维护的代码。任何问题都能更早地被发现和解决。'
- en: '**Enhanced collaboration**: CD and CI encourage collaboration between development
    and operations teams. It breaks down traditional silos and encourages cross-functional
    teamwork, leading to better communication and understanding.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强协作**：CD和CI促进了开发和运维团队之间的协作。它打破了传统的壁垒，鼓励跨职能团队合作，从而提升了沟通和理解。'
- en: '**Efficiency and productivity**: Automation of repetitive tasks, such as testing,
    building, and deployment, frees up developers’ time to focus on more valuable
    tasks, such as creating new features and improvements.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**提高效率和生产力**：自动化重复性的任务，例如测试、构建和部署，使开发人员能够腾出时间专注于更有价值的任务，例如创建新特性和改进。'
- en: '**Customer feedback**: CD allows you to gather feedback from real users more
    quickly. By deploying small changes frequently, you can gather user feedback and
    adjust your development efforts accordingly, ensuring that your product better
    meets user needs.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**客户反馈**：CD允许您更快速地从真实用户那里收集反馈。通过频繁部署小的更改，您可以收集用户反馈并相应地调整开发工作，确保您的产品更好地满足用户需求。'
- en: '**Continuous improvement**: CD promotes a culture of continuous improvement.
    By analyzing data on deployments and monitoring, teams can identify areas for
    enhancement and iterate on their processes.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续改进**：CD促进了持续改进的文化。通过分析部署和监控的数据，团队可以识别出需要改进的领域，并对其流程进行迭代。'
- en: '**Better security**: Frequent updates mean that security vulnerabilities can
    be addressed promptly, reducing the window of opportunity for attackers. Security
    checks can be automated and integrated into the CI/CD pipeline.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**更好的安全性**：频繁的更新意味着可以及时解决安全漏洞，减少攻击者的机会窗口。安全检查可以自动化并集成到CI/CD流水线中。'
- en: '**Reduced manual intervention**: CD minimizes the need for manual intervention
    in the deployment process. This reduces the potential for human error and streamlines
    the release process.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**减少人工干预**：CD减少了在部署过程中对人工干预的需求。这降低了人为错误的可能性，并简化了发布流程。'
- en: '**Scalability**: As your product grows and the number of developers and your
    code base complexity increases, CD can help maintain a manageable development
    process. It scales effectively by automating many of the release and testing processes.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：随着产品的增长，开发人员数量的增加以及代码库复杂性的提高，CD可以帮助保持可管理的开发流程。通过自动化许多发布和测试过程，它能够有效地扩展。'
- en: '**Cost savings**: Although implementing CI/CD requires an initial investment
    in tools and processes, it can lead to cost savings in the long run by reducing
    the need for extensive manual testing, lowering deployment-related errors, and
    improving resource utilization.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**节省成本**：虽然实现CI/CD需要在工具和流程上进行初期投资，但从长远来看，它可以通过减少大量的手动测试需求、降低与部署相关的错误并提高资源利用率，从而实现成本节省。'
- en: '**Compliance and auditing**: For organizations with regulatory requirements,
    CD can improve compliance by providing a detailed history of changes and deployments,
    making it easier to track and audit code changes.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**合规性和审计**：对于有监管要求的组织，CD可以通过提供详细的更改和部署历史记录来改善合规性，使得跟踪和审计代码变更变得更加容易。'
- en: It’s important to note that while CD and CI offer many advantages, they also
    require careful planning, infrastructure, and cultural changes to be effective.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，虽然CD和CI提供了许多优势，但它们也需要精心的规划、基础设施和文化变革才能发挥作用。
- en: There are several models and tools available to implement CD. We’ll have a look
    at some of them in the next section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种模型和工具可以实现CD。我们将在下一节中详细介绍其中的一些。
- en: CD models and tools
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CD模型和工具
- en: 'A typical CI/CD workflow looks as described in the following figure and the
    subsequent steps:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的CI/CD工作流如以下图所示，以及随后的步骤：
- en: '![Figure 12.1 – CI/CD workflow](img/B19877_12_1.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – CI/CD工作流](img/B19877_12_1.jpg)'
- en: Figure 12.1 – CI/CD workflow
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – CI/CD工作流
- en: Your developers write code and push it to a code repository (typically a Git
    repository).
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发人员编写代码并将其推送到代码仓库（通常是Git仓库）。
- en: Your CI tool builds the code, runs a series of tests, and pushes the tested
    build to an artifact repository. Your CD tool then picks up the artifact and deploys
    it to your test and staging environments. Based on whether you want to do continuous
    deployment or delivery, it automatically deploys the artifact to the production
    environment.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的CI工具构建代码，运行一系列测试，并将测试通过的构建推送到工件仓库。然后，您的CD工具获取该工件，并将其部署到测试和暂存环境中。根据您是否希望进行持续部署或交付，它会自动将工件部署到生产环境中。
- en: Well, what do you choose for a delivery tool? Let’s look at the example we covered
    in [*Chapter 11*](B19877_11.xhtml#_idTextAnchor1412), *Continuous Integration*.
    We picked up the **posts** microservice app and used a CI tool such as GitHub
    Actions/Jenkins that uses **Docker** to create a container out of it and push
    it to our **Docker Hub** container registry. Well, we could have used the same
    tool for deploying to our environment.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，您选择什么样的交付工具呢？让我们回顾一下我们在[*第11章*](B19877_11.xhtml#_idTextAnchor1412)中讨论的例子，*持续集成*。我们选择了**posts**微服务应用，并使用如GitHub
    Actions/Jenkins这样的CI工具，利用**Docker**将其打包成容器并推送到我们的**Docker Hub**容器注册表。嗯，我们本可以使用相同的工具来部署到我们的环境中。
- en: For example, if we wanted to deploy to `kubectl apply`. We could easily do this
    with any of those tools, but we chose not to do it. Why? The answer is simple
    – CI tools are meant for CI, and if you want to use them for anything else, you’ll
    get stuck at a certain point. That does not mean that you cannot use these tools
    for CD. It will only suit a few use cases based on the deployment model you follow.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想要部署到`kubectl apply`。我们可以使用任何这些工具来轻松完成，但我们选择不这么做。为什么？答案很简单——CI工具是为了CI而设计的，如果你想用它们做其他事情，最终会遇到瓶颈。这并不意味着你不能用这些工具来做CD，它仅适用于基于你所遵循的部署模型的某些用例。
- en: Several deployment models exist based on your application, technology stack,
    customers, risk appetite, and cost consciousness. Let’s look at some of the popular
    deployment models that are used within the industry.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的应用、技术栈、客户需求、风险承受度和成本意识，存在多种部署模型。让我们来看一看一些业界常用的部署模型。
- en: Simple deployment model
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单部署模型
- en: 'The **simple deployment model** is one of the most straightforward of all:
    you deploy the required version of your application after removing the old one.
    It completely replaces the previous version, and rolling back involves redeploying
    the older version after removing the deployed one:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单部署模型**是所有模型中最直接的一种：你在移除旧版本后，部署所需版本的应用程序。它完全替换了之前的版本，回滚则涉及在移除已部署版本后重新部署旧版本：'
- en: '![Figure 12.2 – Simple deployment model](img/B19877_12_2.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.2 – 简单部署模型](img/B19877_12_2.jpg)'
- en: Figure 12.2 – Simple deployment model
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – 简单部署模型
- en: As it is a simple way of deploying things, you can manage this using a CI tool
    such as **Jenkins** or **GitHub Actions**. However, the simple deployment model
    is not the most desired deployment method because of some inherent risks. This
    kind of change is disruptive and typically needs downtime. This means your service
    would remain unavailable to your customers for the upgrade period. It might be
    OK for organizations that do not have users 24/7, but disruptions eat into the
    **service-level objectives**(**SLOs**) and **service-level agreements** (**SLAs**)
    of global organizations. Even if there isn’t one, they hamper customer experience
    and the organization’s reputation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一种简单的部署方式，你可以使用像**Jenkins**或**GitHub Actions**这样的CI工具来管理它。然而，简单部署模型并不是最理想的部署方法，因为它有一些固有的风险。这种变更具有破坏性，通常需要停机时间。这意味着在升级期间，你的服务会暂时无法提供给客户。对于没有24/7用户的组织来说，这可能是可以接受的，但中断会影响**服务水平目标**(**SLOs**)和**服务水平协议**(**SLAs**)的履行，特别是对于全球化的组织。即便没有相关协议，它们也会影响客户体验并损害组织声誉。
- en: Therefore, to manage such kinds of situations, we have some complex deployment
    models.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了应对这种情况，我们有一些复杂的部署模型。
- en: Complex deployment models
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复杂部署模型
- en: '**Complex deployment models**, unlike simple deployment models, try to minimize
    disruptions and downtimes within the application and make rolling out releases
    more seamless to the extent that most users don’t even notice when the upgrade
    is being conducted. Two main kinds of complex deployments are prevalent in the
    industry; let’s take a look.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**复杂部署模型**与简单部署模型不同，试图最小化应用中的中断和停机时间，使得发布过程更加顺畅，以至于大多数用户甚至没有注意到升级正在进行。业界流行的两种复杂部署方式是：让我们来看一看。'
- en: Blue/Green deployments
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 蓝绿部署
- en: '**Blue/Green deployments** (also known as **Red/Black deployments**) roll out
    the new version (*Green*) in addition to the existing version (*Blue*). You can
    then do sanity checks and other activities with the latest version to ensure that
    everything is good to go. Then, you can switch traffic from the old to the new
    version and monitor for any issues. If you encounter problems, you switch back
    traffic to the old version. Otherwise, you keep the latest version running and
    remove the old version:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**蓝绿部署**（也称为**红黑部署**）是将新版本（*绿*）与现有版本（*蓝*）一起推出。然后，你可以进行完整性检查和其他活动，以确保一切正常。接着，你可以将流量从旧版本切换到新版本，并监控是否出现问题。如果遇到问题，你可以将流量切换回旧版本。否则，你可以继续运行最新版本并移除旧版本：'
- en: '![Figure 12.3 – Blue/Green deployments](img/B19877_12_3.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.3 – 蓝绿部署](img/B19877_12_3.jpg)'
- en: Figure 12.3 – Blue/Green deployments
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 – 蓝绿部署
- en: You can take Blue/Green deployments to the next level using canary deployments.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过金丝雀部署将蓝绿部署提升到下一个层次。
- en: Canary deployments and A/B testing
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 金丝雀部署和A/B测试
- en: '**Canary deployments** are similar to Blue/Green deployments but are generally
    utilized for risky upgrades. So, like Blue/Green deployments, we deploy the new
    version alongside the existing one. Instead of switching all traffic to the latest
    version at once, we only switch traffic to a small subset of users. As we do that,
    we can understand from our logs and user behaviors whether the switchover is causing
    any issues. This is called **A/B testing**. When we do A/B testing, we can target
    a specific group of users based on location, language, age group, or users who
    have opted to test Beta versions of a product. That will help organizations gather
    feedback without disrupting general users and make changes to the product once
    they’re satisfied with what they are rolling out. You can make the release generally
    available by switching over the total traffic to the new version and getting rid
    of the old version:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**金丝雀部署**与蓝绿部署类似，但通常用于高风险的升级。因此，像蓝绿部署一样，我们将新版本与现有版本一起部署。不同的是，我们不会立即将所有流量切换到最新版本，而是仅将流量切换给一小部分用户。在切换的过程中，我们可以通过日志和用户行为了解切换是否引起了问题。这就是所谓的
    **A/B 测试**。在进行 A/B 测试时，我们可以根据位置、语言、年龄段或选择测试产品 Beta 版本的用户来针对特定的用户群体进行测试。这有助于组织收集反馈，而不会打扰到普通用户，并在对新版本满意后做出调整。你可以通过将所有流量切换到新版本并删除旧版本来使发布普遍可用：'
- en: '![Figure 12.4 – Canary deployments](img/B19877_12_4.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.4 – 金丝雀部署](img/B19877_12_4.jpg)'
- en: Figure 12.4 – Canary deployments
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4 – 金丝雀部署
- en: While complex deployments cause the least disruption to users, they are generally
    complex to manage using traditional CI tools such as Jenkins. Therefore, we need
    to get the tooling right on it. Several CD tools are available in the market,
    including **Argo CD**, **Spinnaker**, **Circle CI**, and **AWS Code Deploy**.
    As this entire book is focused on GitOps, and Argo CD is a GitOps native tool,
    for this chapter, we will focus on Argo CD. Before we delve into deploying the
    application, let’s revisit what we want to deploy.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然复杂的部署对用户的干扰最小，但通常使用传统的 CI 工具（如 Jenkins）来管理时非常复杂。因此，我们需要在这一点上正确配置工具。市场上有几种
    CD 工具可供选择，包括 **Argo CD**、**Spinnaker**、**Circle CI** 和 **AWS Code Deploy**。由于本书的重点是
    GitOps，而 Argo CD 是一个 GitOps 原生工具，因此在本章中，我们将重点讨论 Argo CD。在深入应用部署之前，让我们回顾一下我们要部署的内容。
- en: The Blog App and its deployment configuration
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 博客应用及其部署配置
- en: 'Since we discussed the Blog App in the last chapter, let’s look at the services
    and their interactions again:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在上一章中讨论了博客应用，让我们再次看看这些服务及其交互：
- en: '![Figure 12.5 – The Blog App and its services and interactions](img/B19877_12_5.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.5 – 博客应用及其服务和交互](img/B19877_12_5.jpg)'
- en: Figure 12.5 – The Blog App and its services and interactions
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.5 – 博客应用及其服务和交互
- en: 'So far, we’ve created CI pipelines for building, testing, and pushing our Blog
    App microservice containers. These microservices need to run somewhere. So, we
    need an environment for this. We will deploy the application in a `posts` microservice
    as an example in the previous chapter, and I also left building the rest of the
    services as an exercise for you. Assuming you’ve built them, we will need the
    following resources for the application to run seamlessly:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了用于构建、测试和推送博客应用微服务容器的 CI 流水线。这些微服务需要在某个地方运行。因此，我们需要一个环境来运行它们。我们将在上一章中的
    `posts` 微服务中部署该应用程序，我也将其余服务的构建作为一个练习留给你。假设你已经构建了它们，我们将需要以下资源以确保应用程序顺利运行：
- en: '**MongoDB**: We will deploy an auth-enabled MongoDB database with root credentials.
    The credentials will be injected via environment variables sourced from a Kubernetes
    **Secret** resource. We also need to persist our database data, so for that, we
    need a **PersistentVolume** mounted to the container, which we will provision
    dynamically using a **PersistentVolumeClaim**. As the container is stateful, we
    will use a **StatefulSet** to manage it and, therefore, a headless **Service**
    to expose the database.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**MongoDB**：我们将部署一个启用了认证的 MongoDB 数据库，且拥有 root 凭据。凭据将通过环境变量注入，这些环境变量来自 Kubernetes
    **Secret** 资源。我们还需要持久化我们的数据库数据，因此我们需要一个挂载到容器的 **PersistentVolume**，该卷将通过 **PersistentVolumeClaim**
    动态提供。由于容器是有状态的，我们将使用 **StatefulSet** 来管理它，并因此使用一个无头 **Service** 来暴露数据库。'
- en: '`posts`, `reviews`, `ratings`, `and` `users` microservices will interact with
    MongoDB through the root credentials injected via environment variables sourced
    from the same **Secret** as MongoDB. We will deploy them using their respective
    **Deployment** resources and expose all of them via individual **ClusterIP Services**.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`posts`、`reviews`、`ratings`、和`users`微服务将通过环境变量注入的根凭证与MongoDB进行交互，这些凭证来自与MongoDB相同的**Secret**。我们将使用各自的**Deployment**资源来部署它们，并通过单独的**ClusterIP
    Services**来暴露它们。'
- en: '**Frontend**: The *frontend* microservice does not need to interact with MongoDB,
    so there will be no interaction with the Secret resource. We will also deploy
    this service using a **Deployment** resource. As we want to expose the service
    on the internet, we will create a **LoadBalancer Service** for it.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前端**：*前端*微服务不需要与MongoDB交互，因此不会与Secret资源交互。我们还将使用**Deployment**资源来部署该服务。由于我们希望将此服务暴露到互联网上，我们将为其创建一个**LoadBalancer
    Service**。'
- en: 'We can summarize these aspects with the following diagram:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下图示总结这些方面：
- en: '![Figure 12.6 – The Blog App – Kubernetes resources and interactions](img/B19877_12_6.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图12.6 – 博客应用 – Kubernetes资源与交互](img/B19877_12_6.jpg)'
- en: Figure 12.6 – The Blog App – Kubernetes resources and interactions
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 – 博客应用 – Kubernetes资源与交互
- en: Now, as we’re following the GitOps model, we need to store the manifests of
    all the resources on Git. However, since Kubernetes Secrets are not inherently
    secure, we cannot store their manifests directly on Git. Instead, we will use
    another resource called **SealedSecrets** to manage this securely.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，由于我们遵循GitOps模型，我们需要将所有资源的清单存储在Git上。然而，由于Kubernetes Secrets本身并不安全，我们不能将它们的清单直接存储在Git上。相反，我们将使用另一个名为**SealedSecrets**的资源来安全地管理这些信息。
- en: In [*Chapter 2*](B19877_02.xhtml#_idTextAnchor134), *Source Code Management
    with Git and GitOps*, we discussed application and environment repositories forming
    the fundamental building blocks of GitOps-based CI and CD, respectively. In the
    previous chapter, we created an application repository on GitHub and used GitHub
    Actions (and Jenkins) to build, test, and push our application container to Docker
    Hub. As CD focuses on the Ops part of DevOps, we will need an **Environment repository**
    to implement it, so let’s go ahead and create our Environment repository in the
    next section.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第2章*](B19877_02.xhtml#_idTextAnchor134)，*使用Git和GitOps的源代码管理*中，我们讨论了应用程序和环境仓库作为GitOps驱动的CI和CD的基础构建块。在前一章中，我们在GitHub上创建了一个应用程序仓库，并使用GitHub
    Actions（以及Jenkins）来构建、测试并将我们的应用程序容器推送到Docker Hub。由于CD专注于DevOps中的Ops部分，我们需要一个**环境仓库**来实现这一点，所以接下来我们将创建我们的环境仓库。
- en: Continuous declarative IaC using an Environment repository
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用环境仓库进行持续声明式IaC
- en: As we know by now, we must create a GKE cluster to host our microservices. So
    far, we’ve been using `gcloud` commands to do this; however, because `gcloud`
    commands are not declarative, using them is not ideal when implementing GitOps.
    Instead, we’ll use **Terraform** to create the GKE cluster for us. This will ensure
    we can deploy and manage the cluster declaratively using a Git Environment repository.
    So, let’s go ahead and create one.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，我们已经知道，必须创建一个GKE集群来托管我们的微服务。到目前为止，我们一直在使用`gcloud`命令来完成此任务；然而，由于`gcloud`命令并不是声明式的，因此在实施GitOps时使用它们并不是理想的做法。相反，我们将使用**Terraform**来为我们创建GKE集群。这样可以确保我们能够使用Git环境仓库声明性地部署和管理集群。接下来，我们就来创建一个集群。
- en: Creating and setting up our Environment repository
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和设置我们的环境仓库
- en: 'Navigate to [https://github.com](https://github.com) and create a repository
    using a name of your choice. For this exercise, we will use `mdo-environments`.
    Once you have done that, navigate to Google Cloud Shell, generate a `ssh-key`
    pair using the `ssh-keygen` command, copy the public key to GitHub (refer to [*Chapter
    2*](B19877_02.xhtml#_idTextAnchor134)*, Source Code Management with Git and GitOps*,
    for step-by-step instructions), and clone the repository using the following commands:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 访问[https://github.com](https://github.com)，并使用您选择的名称创建一个仓库。对于本练习，我们将使用`mdo-environments`。完成后，访问Google
    Cloud Shell，使用`ssh-keygen`命令生成一个`ssh-key`对，将公钥复制到GitHub（参见[*第2章*](B19877_02.xhtml#_idTextAnchor134)，*使用Git和GitOps的源代码管理*，获取逐步说明），然后使用以下命令克隆该仓库：
- en: '[PRE1]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let’s copy a `.gitignore` file for Terraform to ensure that we do not unexpectedly
    check in Terraform state, backend, or `.tfvars` files by using the following command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们复制一个Terraform的`.gitignore`文件，确保我们不会意外地提交Terraform状态、后端文件或`.tfvars`文件，使用以下命令：
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let’s push this code to GitHub using the following commands:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用以下命令将代码推送到 GitHub：
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that we’ve pushed our first file and initialized our repository, let’s
    structure our repository according to our environments. We will have two branches
    within the Environment repository – **dev** and **prod**. All configurations in
    the **dev** branch will apply to the **development environment**, and those on
    **prod** will apply to the **production environment**. The following diagram illustrates
    this approach in detail:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经推送了第一个文件并初始化了仓库，让我们根据环境来构建仓库结构。在环境仓库中我们将有两个分支——**dev** 和 **prod**。**dev**
    分支中的所有配置将应用于 **开发环境**，而 **prod** 中的配置将应用于 **生产环境**。下图详细说明了这种方法：
- en: '![Figure 12.7 – CD process](img/B19877_12_7.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.7 – CD 流程](img/B19877_12_7.jpg)'
- en: Figure 12.7 – CD process
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.7 – CD 流程
- en: The existing repository has a single branch called `master`. However, since
    we will be managing multiple environments in this repository, it would be good
    to rename the `master` branch to `prod`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的仓库只有一个名为 `master` 的分支。然而，由于我们将在此仓库中管理多个环境，因此最好将 `master` 分支重命名为 `prod`。
- en: Go to `https://github.com/<your_user>/mdo-environments/branches` and click the
    pencil icon beside `prod` and click on **Rename Branch**.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 `https://github.com/<your_user>/mdo-environments/branches`，点击 `prod` 旁边的铅笔图标，然后点击
    **重命名分支**。
- en: 'Now that we’ve renamed the branch, let’s remove the existing local repository
    and clone the repository again using the following commands:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经重命名了分支，让我们移除现有的本地仓库，并使用以下命令重新克隆仓库：
- en: '[PRE4]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We want to start with the dev environment, so it will be good to create a branch
    called `dev` from the `prod` branch. Run the following command to do so:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想从开发环境开始，因此最好从 `prod` 分支创建一个名为 `dev` 的分支。运行以下命令来实现：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we can start writing the Terraform configuration within this directory.
    The configuration is available in `~/modern-devops/ch12/mdo-environments/environments`.
    Copy everything from that directory to the current directory using the following
    commands:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以开始在此目录中编写 Terraform 配置。配置文件位于 `~/modern-devops/ch12/mdo-environments/environments`。使用以下命令将该目录中的所有内容复制到当前目录：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Within the `terraform` directory, there are several Terraform files.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `terraform` 目录中，有几个 Terraform 配置文件。
- en: 'The `cluster.tf` file contains the configuration to create the Kubernetes cluster.
    It looks like this:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`cluster.tf` 文件包含了创建 Kubernetes 集群的配置。它大致如下：'
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It creates two resources – a `cloud platform` **OAuth scope**.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 它创建了两个资源——一个 `cloud platform` **OAuth 范围**。
- en: We name the service account with a combination of the `cluster_name` and `branch`
    variables. This is necessary as we need to distinguish clusters between environments.
    So, if the cluster name is `mdo-cluster` and the Git branch is `dev`, we will
    have a service account called `gke-mdo-cluster-dev-sa`. We will use the same naming
    convention on the GKE cluster. Therefore, the cluster’s name would be `mdo-cluster-dev`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将服务账户命名为 `cluster_name` 和 `branch` 变量的组合。这是必要的，因为我们需要区分不同环境中的集群。所以，如果集群名称是
    `mdo-cluster`，而 Git 分支是 `dev`，我们将有一个名为 `gke-mdo-cluster-dev-sa` 的服务账户。我们将在 GKE
    集群上使用相同的命名约定。因此，集群名称将为 `mdo-cluster-dev`。
- en: 'We have a `provider.tf` file that contains the `provider` and `backend` configuration.
    We’re using a remote backend here as we want to persist the Terraform state remotely.
    In this scenario, we will use a `provider.tf` file looks like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个 `provider.tf` 文件，包含了 `provider` 和 `backend` 配置。我们在这里使用的是远程后端，因为我们希望将 Terraform
    状态存储在远程。此场景下，`provider.tf` 文件大致如下：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we’ve specified our default `region` and `zone` within the `provider`
    config. Additionally, we’ve declared the `gcs` backend, which only contains the
    `prefix` attribute with a value of `mdo-terraform`. We can separate configurations
    using the prefixes to store multiple Terraform states in a single bucket. We have
    purposefully not supplied the `bucket` name, which we will do at runtime using
    `-backend-config` during `terraform init`. The bucket name will be `tf-state-mdo-terraform-<PROJECT_ID>`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在 `provider` 配置中指定了默认的 `region` 和 `zone`。此外，我们声明了 `gcs` 后端，只包含了 `prefix`
    属性，值为 `mdo-terraform`。我们可以使用前缀来分离配置，以便在一个存储桶中存储多个 Terraform 状态。我们故意没有提供 `bucket`
    名称，那个我们会在运行时通过 `-backend-config` 在 `terraform init` 时提供。存储桶名称将是 `tf-state-mdo-terraform-<PROJECT_ID>`。
- en: Tip
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: As GCS buckets should have a globally unique name, it is good to use something
    such as `tf-state-mdo-terraform-<PROJECT_ID>` as the project ID is globally unique.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 GCS 存储桶应该具有全球唯一的名称，因此建议使用类似`tf-state-mdo-terraform-<PROJECT_ID>`这样的名称，因为项目
    ID 是全球唯一的。
- en: 'We also have the `variables.tf` file, which declares the `project_id`, `branch`,
    `cluster_name`, and `location` variables, as follows:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还有一个 `variables.tf` 文件，声明了 `project_id`、`branch`、`cluster_name` 和 `location`
    变量，如下所示：
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now that we have the Terraform configuration ready, we need a workflow file
    that can be applied to our GCP project. For that, we’ve created the following
    GitHub Actions workflow file – that is, `.github/workflows/create-cluster.yml`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好 Terraform 配置文件，接下来我们需要一个工作流文件，可以应用到我们的 GCP 项目。为此，我们创建了以下 GitHub Actions
    工作流文件，即 `.github/workflows/create-cluster.yml`：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is a two-step build file. The first step installs Terraform, while the
    second step applies the Terraform configuration. Apart from that, we’ve specified
    `./terraform` as the working directory at the global level. Additionally, we’re
    using a few secrets in this file, namely `GCP_CREDENTIALS`, which is the key file
    of the service account that Terraform uses to authenticate and authorize the GCP
    API, and the Google Cloud `PROJECT_ID`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个两步的构建文件。第一步安装 Terraform，第二步应用 Terraform 配置。除此之外，我们在全局层面指定了`./terraform`作为工作目录。此外，我们在此文件中使用了一些秘密变量，即
    `GCP_CREDENTIALS`，它是 Terraform 用来进行身份验证和授权 GCP API 的服务帐户密钥文件，以及 Google Cloud 的
    `PROJECT_ID`。
- en: We’ve also supplied the bucket name as `tf-state-mdo-terraform-${{ secrets.PROJECT_ID
    }}` to ensure that we have a unique bucket name.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将存储桶名称提供为 `tf-state-mdo-terraform-${{ secrets.PROJECT_ID }}`，以确保我们有一个唯一的存储桶名称。
- en: As we’ve used Terraform workspaces to manage multiple environments, the preceding
    code selects an existing Terraform workspace with the branch name denoted by `${GITHUB_REF##*/}`
    or creates a new one. Workspaces are important here as we want to use the same
    configuration with different variable values for different environments. The Terraform
    workspaces correspond to environments, and environments correspond to the Git
    branch. So, as we have the `dev` and `prod` environments, we have the corresponding
    Terraform workspaces and Git branches.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用 Terraform 工作区来管理多个环境，上述代码选择一个现有的 Terraform 工作区，工作区的名称由 `${GITHUB_REF##*/}`
    表示的分支名称决定，或者创建一个新的工作区。工作区在这里很重要，因为我们希望使用相同的配置，但为不同的环境使用不同的变量值。Terraform 工作区对应于环境，而环境对应于
    Git 分支。所以，既然我们有 `dev` 和 `prod` 环境，我们也有对应的 Terraform 工作区和 Git 分支。
- en: 'From the Terraform and workflow configuration, we can deduce that we will need
    the following:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Terraform 和工作流配置中，我们可以推断出我们将需要以下内容：
- en: A **service account** for Terraform to authenticate and authorize the GCP API
    and a JSON key file that we need to add as a GitHub secret
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于 Terraform 进行身份验证和授权 GCP API 的 **服务账户**，以及我们需要添加为 GitHub 秘密的 JSON 密钥文件
- en: The **project ID** that we’ll configure as a GitHub secret
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将配置为 GitHub 秘密的 **项目 ID**
- en: A **GCS bucket** that we’ll use as a backend for Terraform
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用作 Terraform 后端的 **GCS 存储桶**
- en: 'So, let’s go ahead and create a service account within GCP so that Terraform
    can use it to authenticate and authorize with the Google APIs. Use the following
    commands to create the service account, provide relevant **Identity and Access
    Management** (**IAM**) permissions, and download the credentials file:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们继续在 GCP 中创建一个服务账户，这样 Terraform 就可以使用它来进行身份验证并授权访问 Google API。使用以下命令创建服务账户，提供相关的
    **身份与访问管理**（**IAM**）权限，并下载凭证文件：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You will see a file called `key-file` within your working directory. Now, navigate
    to `https://github.com/<your_github_user>/mdo-environments/settings/secrets/actions/new`
    and create a secret named `GCP_CREDENTIALS`. For the value, print the `key-file`
    file, copy its contents, and paste it into the **values** field of the GitHub
    secret.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的工作目录中，你会看到一个名为`key-file`的文件。现在，前往 `https://github.com/<your_github_user>/mdo-environments/settings/secrets/actions/new`，创建一个名为`GCP_CREDENTIALS`的秘密。在“值”字段中，打印出`key-file`文件，复制其内容并粘贴到
    GitHub 秘密的 **values** 字段中。
- en: Next, create another secret, `PROJECT_ID`, and specify your GCP project ID within
    the **values** field.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建另一个秘密，`PROJECT_ID`，并在 **values** 字段中指定你的 GCP 项目 ID。
- en: 'The next thing we need to do is create a GCS bucket for Terraform to use as
    a remote backend. To do this, run the following command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们需要做的是为 Terraform 创建一个 GCS 存储桶，作为远程后端使用。为此，请运行以下命令：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Additionally, we need to enable the GCP APIs that Terraform will use to create
    the resources. To do this, run the following command:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们需要启用 Terraform 用于创建资源的 GCP API。为此，运行以下命令：
- en: '[PRE13]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'So, now that all the prerequisites have been met, we can push our code to the
    repository. Run the following commands to do this:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，现在所有先决条件都已经满足，我们可以将代码推送到仓库。运行以下命令来执行此操作：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As soon as we push the code, we’ll see that the GitHub Actions workflow has
    been triggered. Soon, the workflow will apply the configuration and create the
    Kubernetes cluster. This should appear as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们推送代码，GitHub Actions 工作流就会被触发。很快，工作流将应用配置并创建 Kubernetes 集群。结果应该如下所示：
- en: '![Figure 12.8 – GitOps with GitHub Actions and Terraform](img/B19877_12_8.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.8 – 使用 GitHub Actions 和 Terraform 的 GitOps](img/B19877_12_8.jpg)'
- en: Figure 12.8 – GitOps with GitHub Actions and Terraform
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.8 – 使用 GitHub Actions 和 Terraform 的 GitOps
- en: 'To verify whether the cluster has been created successfully, run the following
    command:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要验证集群是否已成功创建，运行以下命令：
- en: '[PRE15]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, the `mdo-cluster-dev` cluster is running successfully in the
    environment. If we make any changes to the Terraform configuration, the changes
    will automatically be applied. We’ve successfully created our Environment using
    an Environment repository. That is the *push model GitOps* in action for you.
    Now, we need to run our application in the environment; to manage and deploy the
    application, we will need a dedicated CD tool. As stated previously, we will use
    Argo CD for this, so let’s look at it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`mdo-cluster-dev` 集群已经在环境中成功运行。如果我们对 Terraform 配置进行任何更改，这些更改将会自动应用。我们已经成功使用环境仓库创建了环境。这就是
    *推送模型 GitOps* 的应用。现在，我们需要在环境中运行应用程序；为了管理和部署应用程序，我们将需要一个专用的 CD 工具。如前所述，我们将使用 Argo
    CD，因此让我们来了解一下它。
- en: Introduction to Argo CD
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Argo CD 简介
- en: Argo CD is an open source, declarative, GitOps-based CD tool designed to automate
    deploying and managing applications and infrastructure on Kubernetes clusters.
    Argo CD serves as a robust application controller, efficiently managing and ensuring
    the smooth and secure operation of your applications. Argo CD works in the *pull-based
    GitOps model* and, therefore, polls the Environment repository regularly to detect
    any configuration drift. Suppose it finds any drift between the state in Git and
    the actual state of applications running in the environment. In that case, it
    will make corrective changes to reflect the desired configuration declared in
    the Git repository.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD 是一个开源的声明式、基于 GitOps 的持续交付（CD）工具，旨在自动化在 Kubernetes 集群上部署和管理应用程序及基础设施。Argo
    CD 作为一个强大的应用程序控制器，高效地管理并确保您的应用程序顺利、安全地运行。Argo CD 采用 *基于拉取的 GitOps 模型*，因此会定期轮询环境仓库，检测任何配置漂移。如果它发现
    Git 中的状态与实际运行在环境中的应用程序状态之间有任何漂移，它将进行修正，更改以反映 Git 仓库中声明的期望配置。
- en: Argo CD is tailored explicitly to Kubernetes environments, making it a popular
    choice for managing applications on Kubernetes clusters.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Argo CD 明确针对 Kubernetes 环境进行定制，使其成为管理 Kubernetes 集群上应用程序的流行选择。
- en: 'In addition to the traditional Kubernetes manifest YAML files, Argo CD offers
    support for various alternative methods of defining Kubernetes configurations:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 除了传统的 Kubernetes 清单 YAML 文件外，Argo CD 还支持多种替代方法来定义 Kubernetes 配置：
- en: Helm charts
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helm 图表
- en: Kustomize
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kustomize
- en: Ksonnet
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ksonnet
- en: Jsonnet files
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jsonnet 文件
- en: Plain YAML/JSON manifest files
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 普通的 YAML/JSON 清单文件
- en: Integration with other customized configuration management tools through plugins
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过插件与其他定制化的配置管理工具进行集成
- en: Within Argo CD, you can define applications encompassing both a *source* and
    a *target*. The source specifies details about the associated Git repository,
    the location of the manifests, helm charts, or kustomize files, and then applies
    these configurations to designated target environments. This empowers you to monitor
    changes within a specific branch, tag, or watch particular versions within your
    Git repository. Diverse tracking strategies are also at your disposal.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Argo CD 中，您可以定义包含 *源* 和 *目标* 的应用程序。源指定与之关联的 Git 仓库的详细信息、清单、helm 图表或 kustomize
    文件的位置，然后将这些配置应用到指定的目标环境。这使您能够监控 Git 仓库中特定分支、标签的变化，或跟踪特定版本。您还可以使用多种跟踪策略。
- en: You can access a user-friendly web-based UI and a **command-line interface**
    (**CLI**) to interact with Argo CD. Moreover, Argo CD facilitates reporting on
    the application’s status via sync hooks and app actions. If any modifications
    are made directly within the cluster that deviate from the GitOps approach, Argo
    CD can promptly notify your team, perhaps through a Slack channel.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以访问一个用户友好的基于 Web 的 UI 和 **命令行接口**（**CLI**）与 Argo CD 进行交互。此外，Argo CD 通过同步钩子和应用操作提供应用程序状态报告。如果集群内直接进行的任何修改偏离了
    GitOps 方法，Argo CD 会及时通知您的团队，可能通过 Slack 渠道。
- en: 'The following diagram provides an overview of the Argo CD architecture:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表概述了 Argo CD 的架构：
- en: '![Figure 12.9 – Argo CD architecture](img/B19877_12_9.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.9 – Argo CD 架构](img/B19877_12_9.jpg)'
- en: Figure 12.9 – Argo CD architecture
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.9 – Argo CD 架构
- en: So, without further ado, let’s spin up Argo CD.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，废话不多说，我们开始启动 Argo CD。
- en: Installing and setting up Argo CD
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装和设置 Argo CD
- en: Installing Argo CD is simple – we need to apply the `install.yaml` manifest
    bundle that’s available online at [https://github.com/argoproj/argo-cd/blob/master/manifests/install.yaml](https://github.com/argoproj/argo-cd/blob/master/manifests/install.yaml)
    on the Kubernetes cluster where we wish to install it. For a more customized installation,
    you can refer to [https://argo-cd.readthedocs.io/en/stable/operator-manual/installation/](https://argo-cd.readthedocs.io/en/stable/operator-manual/installation/).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Argo CD 非常简单——我们只需将在线提供的 `install.yaml` 清单包应用到我们希望安装它的 Kubernetes 集群中，清单包地址为
    [https://github.com/argoproj/argo-cd/blob/master/manifests/install.yaml](https://github.com/argoproj/argo-cd/blob/master/manifests/install.yaml)。如需更个性化的安装，请参考
    [https://argo-cd.readthedocs.io/en/stable/operator-manual/installation/](https://argo-cd.readthedocs.io/en/stable/operator-manual/installation/)。
- en: As we’re using GitOps for this chapter, we will not deploy Argo CD manually.
    Instead, we will use Terraform to set it up using the Environment repository.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们本章使用的是 GitOps，因此不会手动部署 Argo CD。相反，我们将使用 Terraform 通过环境仓库来设置它。
- en: The resources for this section are present in `~/modern-devops/ch12/environments-argocd-app`.
    We will use the same Environment repository as before for managing this environment.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的资源位于 `~/modern-devops/ch12/environments-argocd-app`。我们将使用与之前相同的环境仓库来管理这个环境。
- en: 'Therefore, let’s `cd` into the `mdo-environments` local repository and run
    the following commands:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们 `cd` 进入 `mdo-environments` 本地仓库，并运行以下命令：
- en: '[PRE16]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now, let’s look at the directory structure to understand what we’re doing:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看目录结构，理解我们正在做什么：
- en: '[PRE17]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As we can see, the structure is similar to before, except for a few changes.
    Let’s look at the Terraform configuration first.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，结构与之前类似，只是做了一些改动。首先让我们看一下 Terraform 配置。
- en: Terraform changes
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Terraform 修改
- en: 'The `terraform` directory now contains two more files:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`terraform` 目录下新增了两个文件：
- en: '`argocd.tf`: This contains the Terraform configuration for deploying Argo CD'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`argocd.tf`：这包含了部署 Argo CD 的 Terraform 配置。'
- en: '`app.tf`: This contains the Terraform configuration for configuring Argo CD
    apps'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app.tf`：这包含了配置 Argo CD 应用程序的 Terraform 配置。'
- en: Let’s explore both files in detail.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细探讨这两个文件。
- en: argocd.tf
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: argocd.tf
- en: 'This files starts with the `time_sleep` resource with an explicit dependency
    on the `google_container_cluster` resource. It will sleep for 30 seconds after
    the cluster is created so that it is ready to serve requests:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件以 `time_sleep` 资源开始，并显式依赖 `google_container_cluster` 资源。集群创建后，它会休眠 30 秒，以便做好准备响应请求：
- en: '[PRE18]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To connect with GKE, we will use the `gke_auth` module provided by `terraform-google-modules/kubernetes-engine/google//modules/auth`.
    We will add an explicit dependency to the `time_sleep` module so that authentication
    happens 30 seconds after the cluster is created:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要连接 GKE，我们将使用由 `terraform-google-modules/kubernetes-engine/google//modules/auth`
    提供的 `gke_auth` 模块。我们将显式添加对 `time_sleep` 模块的依赖，以确保身份验证在集群创建后 30 秒发生：
- en: '[PRE19]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now that we’ve authenticated with the GKE cluster, we need to apply manifests
    to deploy Argo CD to the cluster. We will use the `gavinbunney/kubectl` plugin
    ([https://registry.terraform.io/providers/gavinbunney/kubectl/latest/docs](https://registry.terraform.io/providers/gavinbunney/kubectl/latest/docs))
    for that.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过 GKE 集群进行了身份验证，接下来需要应用清单将 Argo CD 部署到集群中。为此，我们将使用 `gavinbunney/kubectl`
    插件 ([https://registry.terraform.io/providers/gavinbunney/kubectl/latest/docs](https://registry.terraform.io/providers/gavinbunney/kubectl/latest/docs))。
- en: 'We start by defining some data sources to help generate Kubernetes manifests
    that we will apply to install Argo CD. We will create two `kubectl_file_documents`
    data sources for the namespace and Argo CD app that point to the corresponding
    `namespace.yaml` and `install.yaml` files within the `manifests/argocd` directory:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Using these data sources, we can create two `kubectl_manifest` resources for
    the namespace and Argo CD app. These resources will apply the manifests within
    the GKE cluster:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now that we’ve added the configuration to install Argo CD, we also need to configure
    argo CD Applications. To do that, we have the `app.tf` file.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: app.tf
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Similar to the Argo CD configuration, we have a `kubectl_file_documents` data
    source reading from the `manifests/argocd/apps.yaml` file; the `kubectl_manifest`
    resource will apply the manifest to the Kubernetes cluster:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We’ve also modified the `provider.tf` file, so we’ll explore that next.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: provider.tf
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Within this file, we have included the `kubectl` provider, as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Now, let’s inspect the manifests directory.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: The Kubernetes manifests
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The manifests directory contains Kubernetes manifests that we will apply to
    the Kubernetes cluster. As we’re setting up Argo CD first, it only contains the
    `argocd` directory at the moment; however, we will extend this to add further
    directories later in this chapter.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'The `manifests/argocd` directory contains the following files:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '`namespace.yaml`: The manifest to create the `argocd` namespace where Argo
    CD will run.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`install.yaml`: The manifest to create the Argo CD application. The manifest
    is downloaded from the official Argo CD release URL.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apps.yaml`: This contains an Argo CD **ApplicationSet** configuration.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While the `namespace.yaml` and `install.yaml` files are self-explanatory, let’s
    discuss the `apps.yaml` file and the Argo CD ApplicationSet resource in more detail.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: Argo CD Application and ApplicationSet
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To manage applications declaratively, Argo CD uses the `source` attribute and
    where it needs to apply them using the `target` attribute. An Application resource
    caters to one application. For example, to deploy our Blog App, we will need to
    create an Application resource like the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This manifest defines an Argo CD Application resource with the following sections:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: '`project`: We can organize applications into distinct projects. In this case,
    we will stick to the `default` project.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`source`: This section defines the configuration Argo CD requires to track
    and pull the application configuration from the Git repository. It typically contains
    `repoURL`, `targetRevision`, and the `path` value where the application manifests
    are located.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`destination`: This section defines the `target` value to which we want to
    apply the manifest. It typically contains the `server` section and contains the
    Kubernetes cluster’s URL.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`syncPolicy`: This section defines any policies Argo CD should apply while
    syncing the Blog App from the Git repository and what to do when it detects a
    drift. In the preceding configuration, it would try to correct any drift from
    the Git repository automatically as `selfHeal` is set to `true`.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can very well go ahead and define multiple application manifests for each
    application. However, for larger projects, it might turn out to be an overhead.
    To manage this, Argo CD provides a generic way of creating and managing applications
    via the `ApplicationSet` resource.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ApplicationSet` resource provides us with a way to dynamically generate
    Application resources by using a defined pattern. In our case, we have the following
    structure:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: So, logically, for every subdirectory of the `manifests` directory, we would
    need to create a new application with the directory name. The respective application
    configuration should source all manifests from the subdirectory.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ve defined the following `ApplicationSet` within the `apps.yaml` file:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '`ApplicationSet` has the following sections:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '`generators`: This section defines how Argo CD should generate Application
    resources. We’ve used the `git` generator, which contains the `repoURL`, `revision`,
    and `directories` sections. The `directories` section defines the directory from
    where we would want to source our applications. We’ve set that to `manifests/*`.
    So, it will look for every subdirectory within the `manifests` directory. We have
    also defined an exclude directory called `manifests/argocd`. This is because we
    don’t want Argo CD to manage the configuration to deploy itself.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`templates`: This section defines the template for creating the application.
    As we can see, the contents are very similar to an Application resource definition.
    For `metadata.name`, we specified `{{path.basename}}`, which means it will create
    Application resources with the subdirectory name as we intended. The `template.spec.source.path`
    attribute contains the source path of the corresponding application manifests,
    so we’ve set that to `{{path}}` – that is, the subdirectory. So, we will have
    `blog-app` and `<other-app>` applications based on the preceding directory structure.
    The rest of the attributes are the same as those for the Application resource
    we discussed previously.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we’ve configured everything we need to install and set up Argo CD,
    let’s commit and push this configuration to the remote repository by using the
    following commands:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We will see that GitHub will run the Actions workflow on update and deploy Argo
    CD. Once the workflow is successful, we can go ahead and access the Argo CD Web
    UI.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the Argo CD Web UI
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we can access the Argo CD Web UI, we must authenticate with the GKE
    cluster. To do so, run the following command:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To utilize the Argo CD Web UI, you will require the external IP address of
    the `argo-server` service. To get that, run the following command:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We now know that Argo CD is accessible at [https://34.122.51.25/](https://34.122.51.25/).
    Upon visiting this link, you’ll notice that username and password are required
    for authentication:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.10 – Argo CD Web UI – login page](img/B19877_12_10.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
- en: Figure 12.10 – Argo CD Web UI – login page
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: 'Argo CD provides an initial `admin` user by default, and the password for this
    user is stored in the `argocd-initial-admin-secret` **Secret** resource as plaintext.
    While you can use this default setup, it’s worth noting that it is generated from
    the publicly available YAML manifest. Therefore, it’s advisable to update it.
    To do so, execute the following command:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now, allow two minutes for the new credentials to be generated. After that,
    execute the following command to retrieve the password:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now that you have the necessary credentials, log in and you will see the following
    page:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.11 – Argo CD Web UI – home page](img/B19877_12_11.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
- en: Figure 12.11 – Argo CD Web UI – home page
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: We’ve successfully set up Argo CD. The next step is to deploy our application;
    however, as we know that our application uses Kubernetes Secrets, which we cannot
    store on Git, we will have to find a mechanism to store it securely. To solve
    that problem, we have Bitnami’s **SealedSecret** resource. We’ll look at that
    in the next section.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Managing sensitive configurations and Secrets
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Sealed Secrets** solves the problem of *I can manage all my Kubernetes config
    in Git, except Secrets*. Sealed Secrets function as secure containers for your
    sensitive information. When you require a storage solution for secrets, such as
    passwords or keys, you place them in these specialized packages. Only the Sealed
    Secrets controller within Kubernetes can unlock and access the contents. This
    ensures the utmost security and protection for your valuable secrets. Created
    by *Bitnami Labs* and open sourced, they help you encrypt your Kubernetes Secrets
    into Sealed Secrets using asymmetric cryptography that only the Sealed Secrets
    controller running on the cluster can decrypt. This means you can store the Sealed
    Secrets in Git and use GitOps to set up everything, including Secrets.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: 'Sealed Secrets comprises two components:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: A client-side utility called `kubeseal` helps us generate Sealed Secrets from
    standard Kubernetes Secret YAML
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A cluster-side Kubernetes controller/operator unseals your secrets and provides
    the key certificate to the client-side utility
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The typical workflow when using Sealed Secrets is illustrated in the following
    diagram:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.12 – Sealed Secrets workflow](img/B19877_12_12.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
- en: Figure 12.12 – Sealed Secrets workflow
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s go ahead and install the Sealed Secrets operator.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Sealed Secrets operator
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To install the **Sealed Secrets operator**, all you need to do is download the
    controller manifest from the latest release at [https://github.com/bitnami-labs/sealed-secrets/releases](https://github.com/bitnami-labs/sealed-secrets/releases).
    At the time of writing this book, [https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.23.1/controller.yaml](https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.23.1/controller.yaml)
    is the latest controller manifest.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new directory called `sealed-secrets` within the `manifest` directory
    and download `controller.yaml` using the following commands:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, commit and push the changes to the remote repository. After about five
    minutes, Argo CD will create a new application called **sealed-secrets** and deploy
    it. You can visualize this in the Argo CD Web UI as follows:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.13 – Argo CD Web UI – Sealed Secrets](img/B19877_12_13.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
- en: Figure 12.13 – Argo CD Web UI – Sealed Secrets
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Kubernetes cluster, `sealed-secrets-controller` will be visible in the
    `kube-system` namespace. Run the following command to check this:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As we can see, the controller is running and ready. We can now install the client-side
    utility – `kubeseal`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Installing kubeseal
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To install the client-side utility, you can go to [https://github.com/bitnami-labs/sealed-secrets/releases](https://github.com/bitnami-labs/sealed-secrets/releases)
    and get the `kubeseal` installation binary link from that page. The following
    commands will install `kubeseal` `0.23.1` on your system:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'To check whether `kubeseal` has been installed successfully, run the following
    command:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Since `kubeseal` has been installed, let’s go ahead and create a Sealed Secret
    for the `blog-app`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Creating Sealed Secrets
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To create a Sealed Secret, we have to define the Kubernetes Secret resource.
    The `mongodb-creds` Secret should contain some key-value pairs with the `MONGO_INITDB_ROOT_USERNAME`
    key with a value of `root` and the `MONGO_INITDB_ROOT_PASSWORD` key with any value
    you want as the password.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: 'As we don’t want to store the plaintext Secret as a file, we will first create
    the Kubernetes secret manifest called `mongodb-creds` using the `--dry-run` and
    `-o yaml` flags and then pipe the output directly to `kubeseal` to generate the
    `SealedSecret` resource using the following command:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This generates the `mongodb-creds-sealed.yaml` Sealed Secret, which looks like
    this:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As you can see, the Sealed Secret is very similar to the Secret manifest. Still,
    instead of containing a Base64-encoded secret value, it has encrypted it so that
    only the Sealed Secrets controller can decrypt it. You can easily check this file
    into source control. Let’s go ahead and do that. Move the Sealed Secret YAML file
    to the `manifests/blog-app` directory using the following command:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now that we’ve successfully generated the Sealed Secret and moved it to the
    `manifests/blog-app` directory, we’ll set up the rest of our application in the
    next section.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the sample Blog App
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To deploy the sample Blog App, we need to define application resources. We’ve
    already discussed what our app is composed of. We have defined the application
    bundle as a Kubernetes manifest file called `blog-app.yaml`. We need to copy this
    YAML to the `manifests/blog-app` directory using the following command:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: I’ve prebuilt the microservices and used the required `git-sha` as the tag,
    as we did in the previous chapter. You can edit the YAML and replace it with your
    image for each application.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: Once done, commit and push the changes to the `mdo-environments` repository.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'As soon as you push the changes, you should notice that the `blog-app` application
    starts appearing in the Argo CD UI in less than five minutes:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 12.14 – Argo CD Web UI – Applications](img/B19877_12_14.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
- en: Figure 12.14 – Argo CD Web UI – Applications
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'Wait for the application to progress. Once it turns green, you should see the
    following within the application:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.15 – Argo CD Web UI – blog-app](img/B19877_12_15.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
- en: Figure 12.15 – Argo CD Web UI – blog-app
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the application is all synced up, we can check the resources that
    were created within the `blog-app` namespace. Let’s list the Services first using
    the following command:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: As we can see, it lists all the Services that we’ve defined. Note that the *frontend*
    service is of the `LoadBalancer` type and has an **External IP**. Note down this
    External IP as we will use it to access our application.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s list the **pods** to see whether all the microservices are running
    fine:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As we can see, all pods are running fine. Note that the `mongodb-0` pod contains
    a numeric prefix, but the rest of the pods have random UUIDs. You might recall
    that when we created a `mongodb-creds` secret has been created:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, we can see that the `mongodb-creds` Secret has been created. This shows
    us that SealedSecret is working fine.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s go ahead and access our application by opening `http://<frontend-svc-external-ip>`.
    If you see the following page, the application was deployed correctly:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.16 – Blog App home page](img/B19877_12_16.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
- en: Figure 12.16 – Blog App home page
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: 'As an exercise, play around with the application by clicking on **Sign In**
    > **Not a user? Create an Account** and then fill in the details to register.
    You can *create* a new **Post**, add **Reviews**, and provide **Ratings**. You
    can also *update* your reviews, *delete* them, update ratings, and more. Try out
    the app to see whether all aspects are working correctly. You should be able to
    see something like the following:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.17 – Blog App posts](img/B19877_12_17.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
- en: Figure 12.17 – Blog App posts
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: As we’re happy with the application, we can raise a pull request from the `dev`
    branch to the `prod` branch. Once you merge the pull request, you will see that
    similar services will emerge in the production environment. You can use pull request-based
    gating for CD as well. This ensures that your environments remain independent
    while being sourced from the same repository, albeit from different branches.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has covered continuous deployment and delivery, and we understood
    the need for CD and the basic CD workflow for a container application. We discussed
    several modern deployment strategies and how CI tools cannot fulfill those responsibilities.
    Using the GitOps principles, we created an Environment repository and deployed
    our GKE-based environment using GitHub Actions by employing the push-based model.
    Then, we looked at using Argo CD as our CD tool and installed it. To avoid committing
    sensitive information in Git, such as secrets, we discussed Bitnami’s Sealed Secrets.
    We then deployed the sample Blog App using Argo CD, using GitOps all the while.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore another vital aspect of modern DevOps –
    securing the deployment pipeline.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following are CD tools? (Choose three)
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. Spinnaker
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: B. GitHub
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: C. Argo CD
  id: totrans-297
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: D. AWS Code Deploy
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: CD requires human input for deployment to production. (True/False)
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Argo CD supports Blue/Green deployments out of the box. (True/False)
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What would you use to initiate deployment using Argo CD?
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. Trigger the pipeline manually
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: B. Check in changes to your Git repository
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: C. Use CI to trigger Argo CD pipelines
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: D. Argo CD pipelines don’t react to external stimuli
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: An Argo CD ApplicationSet helps generate applications based on templates. (True/False)
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What branch names should you prefer for your Environment repository?
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. `dev`, `staging`, and `prod`
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: B. `feature`, `develop`, and `master`
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: C. `release` and `main`
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Which of the following deployment models does Argo CD use?
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. Push model
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: B. Pull model
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: C. Staggering model
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You should use Terraform to install Argo CD as you can store all configurations
    in Git. (True/False)
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Argo CD can sync resources from which of the following sources? (Choose two)
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. Git repository
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: B. Container Registry
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: C. JFrog Artifactory’s raw repository
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: What would Argo CD do if you manually changed a resource outside Git?
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A. Argo CD would change the resource so that it matches the Git configuration
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: B. Argo CD would notify you that a resource has changed outside Git
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: C. Argo CD would do nothing
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can check in Sealed Secrets to a Git repository. (True/False)
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the answers to this chapter’s questions:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: A, C, and D
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  id: totrans-329
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: B
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A, B
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
