- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Practicing Basic Git Commands
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习基本的 Git 命令
- en: The **GitLab** product is built around a separate tool called **Git**. GitLab
    makes Git easier to use and gives you a central place to store all the files that
    Git is looking after, in addition to providing many other non-Git-related features.
    We like to think of GitLab as a *wrapper* around Git, making it more pleasant
    to use and more powerful.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**GitLab** 产品是围绕一个名为 **Git** 的独立工具构建的。GitLab 使 Git 更易于使用，并为你提供了一个中央位置来存储 Git
    所管理的所有文件，此外还提供了许多与 Git 无关的功能。我们喜欢将 GitLab 看作是 Git 的一个*包装器*，使其使用起来更愉快，也更强大。'
- en: 'Although GitLab and Git are different tools, GitLab borrows many concepts from
    Git. This means that to understand GitLab, you need to understand Git. Fortunately,
    you only need to get to grips with the very basics of Git. We say “fortunately”
    because Git is an enormous and complicated tool and learning all of its nooks
    and crannies would take a huge effort. But trust us: if you understand the first
    10% of Git, you can use GitLab effectively. That 10% is exactly what we’re going
    to introduce you to in this chapter.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 GitLab 和 Git 是不同的工具，但 GitLab 借鉴了 Git 的许多概念。这意味着，要理解 GitLab，你需要理解 Git。幸运的是，你只需要掌握
    Git 的基础知识即可。我们之所以说“幸运”，是因为 Git 是一个庞大且复杂的工具，学习它的所有细节需要付出巨大的努力。但相信我们：如果你理解 Git 的前
    10%，你就能有效地使用 GitLab。那 10% 正是我们将在本章中介绍给你的内容。
- en: First, we’ll show you why version control systems such as Git are such a useful
    part of software development. Then, we’ll explain how you can store your code
    in Git, including any edits that you or your team members make to that code. We’ll
    also show you how to develop your code in a safe place called a branch, which
    is isolated from other team members. This ensures that you don’t step on other
    people’s toes and overwrite their code. You’ll learn how to mark a particular
    version of your code so that you can easily refer to it later or release it to
    customers. Finally, you’ll learn about storing code in remote locations. You’ll
    learn how to sync local and remote copies of files, and you’ll understand how
    this architecture enables an entire team to work on a single code base at the
    same time.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将向你展示为什么像 Git 这样的版本控制系统是软件开发中如此有用的一部分。然后，我们将解释如何将你的代码存储在 Git 中，包括你或你的团队成员对该代码所做的任何编辑。我们还将向你展示如何在一个叫做分支的安全空间中开发代码，该分支与其他团队成员隔离开来。这确保了你不会干扰到他人的工作，也不会覆盖他们的代码。你将学习如何标记代码的特定版本，以便以后可以轻松引用它或将其发布给客户。最后，你将了解如何在远程位置存储代码。你将学习如何同步本地和远程文件的副本，并且你将理解这种架构如何使整个团队能够同时在同一个代码库上工作。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Why use Git?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么使用 Git？
- en: Committing code to keep it safe
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交代码以保持其安全
- en: Tagging commits to identify versions of code
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了标记提交以识别代码版本
- en: Branching code for developing in an isolated space
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了在一个隔离空间中开发代码进行分支
- en: Syncing local and remote copies of repositories
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步本地和远程仓库的副本
- en: Additional resources for learning Git
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习 Git 的额外资源
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you need to have Git installed on your local computer. Git
    works on Linux, macOS, and Windows, as well as many Unix variants. There are easy-to-follow
    instructions for installing Git on any of these operating systems at [https://git-scm.com/downloads](https://git-scm.com/downloads).
    If you’re asked to set configuration options during installation, it’s safe to
    accept all the default values.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要在本地计算机上安装 Git。Git 可以在 Linux、macOS、Windows 以及许多 Unix 变种系统上运行。在 [https://git-scm.com/downloads](https://git-scm.com/downloads)
    上有易于遵循的安装指南，适用于这些操作系统中的任何一个。如果在安装过程中要求设置配置选项，接受所有默认值是安全的。
- en: To type the Git commands that you’ll see in this chapter, use your favorite
    terminal application on Linux or macOS. If you’re a Windows user, you can type
    them in Command Shell, PowerShell, or Git Bash. The default configuration options
    while installing Git on Windows should make Git available on any of these types
    of Windows terminals, and they should all produce identical results when you run
    Git commands in them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要输入你将在本章中看到的 Git 命令，请在 Linux 或 macOS 上使用你喜欢的终端应用程序。如果你是 Windows 用户，你可以在命令提示符、PowerShell
    或 Git Bash 中输入这些命令。在 Windows 上安装 Git 时，默认的配置选项应该会使 Git 在这些 Windows 终端中可用，而且它们在运行
    Git 命令时应产生相同的结果。
- en: 'The Git examples you’ll see in this book are operating system-agnostic: *Git
    works the same no matter where you* *run it*.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中你将看到的 Git 示例是操作系统无关的：*Git 无论在什么地方运行，表现都一样*。
- en: 'To see if it’s already installed, or to verify that you installed it correctly,
    open the appropriate terminal for your operating system and run the following
    command. If the output shows a version number instead of an error, Git has been
    installed properly on your computer:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 Git 是否已安装，或者验证是否正确安装了 Git，打开适合你操作系统的终端并运行以下命令。如果输出显示版本号而不是错误信息，说明 Git 已正确安装在你的计算机上：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Don’t worry about seeing a particular version number; virtually any version
    of Git will perform identically for the simple commands we use in this book.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 不必担心看到特定的版本号；几乎任何版本的 Git 都能在我们在本书中使用的简单命令上表现一致。
- en: Before using Git, you must tell it your name and email address. This information
    is added to every edit you store in Git so that other team members know which
    edits you are responsible for.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Git 之前，你必须告诉 Git 你的名字和电子邮件地址。这些信息会被添加到你存储在 Git 中的每一条编辑记录里，以便其他团队成员知道哪些编辑是你负责的。
- en: 'First, check if Git is already configured with this information:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，检查 Git 是否已经配置了这些信息：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'If the output includes entries for `user.email` and `user.name`, you’re all
    set and can skip the following two commands. Otherwise, let Git know who you are
    by running these two one-time commands, replacing the email address and name with
    your information:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输出中包含 `user.email` 和 `user.name` 的条目，那么你已经配置好了，可以跳过接下来的两个命令。否则，通过运行这两个一次性的命令告诉
    Git 你的身份，替换掉电子邮件地址和名字为你的信息：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'An optional but recommended step is to configure Git to use `main` instead
    of `master` as the name of the default branch in new projects. We haven’t discussed
    what branches are yet, so this may not make much sense. For now, it’s enough for
    you to know that many software companies are shifting to `main` as the name for
    the place where a project’s stable code base lives. You’ll see both terms in use
    in the wild (and even in this book), but if you’d like to configure your computer
    so that new projects use `main`, run the following command once:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可选但推荐的步骤是将 Git 配置为在新项目中使用 `main` 作为默认分支的名称，而不是 `master`。我们还没有讨论什么是分支，所以这可能现在看起来没有太大意义。现在，你只需要知道，许多软件公司正在将
    `main` 作为项目稳定代码库所在位置的名称。你会在现实中（甚至在本书中）看到这两个术语的使用，但如果你想将你的计算机配置为新项目使用 `main`，可以运行以下命令一次：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With all the technical requirements done and dusted, let us begin!
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 所有技术要求都完成后，让我们开始吧！
- en: Why use Git?
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么要使用 Git？
- en: Just like it was helpful to understand how we built software before automation
    tools such as GitLab CI/CD pipelines came along (as discussed in [*Chapter 1*](B18073_01.xhtml#_idTextAnchor013)),
    it’s helpful to know how teams coordinated the complicated process of making edits
    to the same files before Git or similar tools came along.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在自动化工具如 GitLab CI/CD 管道出现之前，了解我们是如何构建软件的（如在[*第1章*](B18073_01.xhtml#_idTextAnchor013)中讨论的那样），了解在
    Git 或类似工具出现之前，团队如何协调编辑同一文件的复杂过程也是很有帮助的。
- en: These tools are designed to solve many problems that developers face, but let’s
    look at just one. Imagine that you and your teammate Elizabeth are working on
    the same code base and both of you want to edit some of the same files. Furthermore,
    imagine that this is a time before the advent of Git or any other **version control
    system** (**VCS**). The only way to write software in this pre-Git era is for
    you to edit a file and then email it, put it on a shared network drive, or copy
    it to a portable disk. Then, you must let Elizabeth know that she’s free to edit
    it. She *checks it out* in some sense (maybe by adding an entry to a spreadsheet
    saying that she’s got control of the file, or maybe through some other mechanism),
    and she retains control of the file for as long as she needs it. If you have new
    ideas and want to edit the file again, you need to ask her to stop editing it
    and transfer it back to you. When she does, you need to scan through the whole
    file to see what changes she’s made, in the hope that they don’t conflict with
    the changes you want to make. Then, you repeat this process for each file the
    two of you are working on, every time either of you wants to edit any of those
    files. You can imagine how slow and cumbersome this process is, and how many chances
    there are to mess something up during all the transfers of ownership!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具旨在解决开发人员面临的许多问题，但我们这里只看其中一个。假设你和你的队友伊丽莎白在同一个代码库上工作，并且你们都想编辑一些相同的文件。进一步假设这是在Git或任何其他**版本控制系统**（**VCS**）出现之前的时代。那时编写软件的唯一方法是你编辑文件，然后通过电子邮件发送，或者把文件放在共享的网络驱动器上，或者复制到便携磁盘中。然后，你必须让伊丽莎白知道她可以开始编辑这个文件。她以某种方式（也许是通过在电子表格中添加一项条目，表明她控制了文件，或者通过其他机制）“签出”文件，并且只要她需要，就一直保留文件的控制权。如果你有了新的想法，想再次编辑文件，你需要让她停止编辑并将文件转交给你。当她做到了，你需要浏览整个文件，查看她所做的更改，以确保这些更改不会与您想做的更改冲突。然后，你需要为你们两个人正在编辑的每一个文件重复这个过程，每当你们中的任何一个想要编辑这些文件时。你可以想象这个过程有多么缓慢和繁琐，以及在所有文件所有权转移过程中出错的机会有多少！
- en: With this understanding of how things worked in the bad old days, we can look
    at what a VCS is, how it solves this problem, and in what other ways it makes
    developers’ lives easier.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 通过了解过去的工作方式，我们可以看看VCS是什么，它是如何解决这个问题的，以及它还以其他方式简化了开发人员的工作。
- en: What is a version control system?
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是版本控制系统？
- en: A VCS is a tool designed to make it easier for one or more developers to work
    with a set of files. It does this by making snapshots of all the files in your
    project at a particular time and letting you view, compare, and restore files
    in different snapshots.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: VCS（版本控制系统）是一种工具，旨在让一个或多个开发人员更方便地处理一组文件。它通过在特定时间对项目中的所有文件进行快照，允许你查看、比较和恢复不同快照中的文件来实现这一目标。
- en: 'Each VCS has slightly different functionality, but here are some features that
    most offer:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 每个VCS的功能略有不同，但以下是大多数VCS提供的一些功能：
- en: Provides backups of files in case current versions are lost or accidentally
    overwritten.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供文件备份，以防当前版本丢失或被意外覆盖。
- en: Shows how a file’s contents have changed over time.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示文件内容随时间的变化。
- en: Shows who made which changes to which files, and when.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示了谁在什么时候对哪些文件进行了哪些更改。
- en: Labels certain file snapshots for future reference.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为未来参考标记某些文件快照。
- en: Provides a human-readable description of each set of changes so that team members
    can understand why changes were made.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供每一组更改的人类可读描述，以便团队成员理解更改的原因。
- en: Allows developers to edit files in a way that’s compatible with other developers
    editing the same files at the same time.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许开发人员以与其他开发人员同时编辑相同文件的方式进行文件编辑。
- en: There have been many competing VCSs over the years, both open source and proprietary.
    Some of the best-known examples are Microsoft Visual SourceSafe, CVS, Apache Subversion,
    and now Git. For reasons we’ll explain shortly, Git has largely taken over the
    VCS space and now serves as the default VCS for any team that doesn’t have a company
    mandate to use one of Git’s competitors. In other words, Git has *won* the VCS
    competition, to the extent that such a victory is possible.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，有许多不同的VCS出现了，包括开源和专有的版本。其中一些最著名的例子包括微软的Visual SourceSafe、CVS、Apache Subversion，现在还有Git。由于一些原因，我们将在稍后解释，Git已经在很大程度上接管了VCS领域，并成为任何没有公司规定使用Git竞争对手的团队的默认VCS。换句话说，Git在VCS的竞争中已经*获胜*，在这样的胜利是可能的情况下。
- en: 'VCSs work with any computer language. For example, you could use the same VCS
    to manage files in separate Java, Python, and Ruby projects. And although we typically
    think of a VCS as helping you work with source code files in a computer language,
    they can be used with *any* file in a software project, including (but not limited
    to) the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: VCS 可以与任何计算机语言一起使用。例如，你可以使用同一个 VCS 来管理独立的 Java、Python 和 Ruby 项目中的文件。虽然我们通常认为
    VCS 主要用于帮助处理计算机语言中的源代码文件，但它们可以与软件项目中的 *任何* 文件一起使用，包括（但不限于）以下内容：
- en: Documentation, such as Markdown or PDF files
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文档，例如 Markdown 或 PDF 文件
- en: Configuration, such as JSON or YAML files
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置文件，例如 JSON 或 YAML 文件
- en: Test code and data
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试代码和数据
- en: Metadata or configuration information for your **integrated development** **environment**
    (**IDE**)
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你**集成开发环境**（**IDE**）的元数据或配置信息
- en: Other project assets, such as pictures, video, or sound files
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他项目资产，如图片、视频或音频文件
- en: There’s no need to limit VCSs to just software projects! You could use Git or
    any VCS to manage the poems in an anthology, recipes in a cookbook, or chapters
    in a novel. VCSs are useful for literally any project that involves files on a
    computer.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 不必将 VCS 限于软件项目！你可以使用 Git 或任何 VCS 来管理诗集中的诗歌、食谱书中的食谱，或者小说中的章节。VCS 对于任何涉及计算机文件的项目都很有用。
- en: What problems does a VCS solve?
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本控制系统（VCS）解决了哪些问题？
- en: Now that you understand what kinds of features a VCS such as Git offers, your
    mind is probably spinning with all the possible ways a VCS could solve everyday
    problems faced by software developers. Here are just some scenarios, but you can
    no doubt think up more.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你了解了像 Git 这样的 VCS 提供的功能，你的脑海里可能充满了各种可能性，想象着 VCS 如何解决软件开发者日常遇到的问题。以下是一些场景，但你无疑能想到更多。
- en: Why was this code changed?
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 为什么要修改这段代码？
- en: You may open some source code in your text editor one morning only to discover
    that a method that you’re familiar with now uses an entirely different algorithm.
    Why was it changed? Was the old algorithm broken? Is the new algorithm faster?
    Is the code that implements it shorter or easier to read? By looking at the *commit
    message* of your VCS, you can read a description of why the change was made. Some
    of these messages are more complete than others, depending on how conscientious
    the developer who made the commit was, but you can usually get the general picture
    of what motivated the change.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 你某天早晨在文本编辑器中打开源代码，发现一个你熟悉的方法现在使用了完全不同的算法。为什么要修改它？旧算法是坏掉了吗？新算法更快吗？实现新算法的代码是否更短或更易读？通过查看
    VCS 的 *提交信息*，你可以阅读到为什么进行这次更改的描述。这些信息的完整程度因开发者的细心程度而异，但你通常能大致了解这次更改的动机。
- en: When was this code changed?
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 这段代码是什么时候修改的？
- en: Imagine that you revisit a Java class that you haven’t looked at in a few months,
    and notice that it has had some features added and others removed. When did these
    changes take place? More importantly, did they take place before or after the
    last deployment to production? Your VCS’s commit log will tell you each time that
    class was touched, and even what lines were modified each time it was edited.
    That will let you pinpoint which changes were made when so that you know which
    version of the class is being used by customers today.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你重新访问一个几个月没看过的 Java 类，发现它添加了一些新功能，也删除了一些旧的功能。这些变化是什么时候发生的？更重要的是，它们是在上次部署到生产环境之前还是之后发生的？你的
    VCS 的提交日志会告诉你每次该类被修改的时间，甚至每次编辑时修改了哪些行。这样，你就能准确地定位哪些变化是何时做出的，从而知道当前客户使用的是该类的哪个版本。
- en: Who added this buggy code?
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 是谁添加了这段有 bug 的代码？
- en: 'Git has a feature called *blame* that tells you which developer edited which
    lines of a file. This is helpful when you discover that some newly added code
    is buggy or slow because you know exactly whom to ask to fix it! But it also has
    a positive use case: if you spot an especially clever piece of code, your VCS
    can let you know whom you should praise and, hopefully, learn from. So, the *blame*
    feature provides a great way to improve professional relationships between developers
    and strengthen team morale.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Git 有一个名为 *blame* 的功能，它会告诉你是哪位开发者编辑了文件中的哪些行。当你发现一些新加入的代码有 bug 或者运行缓慢时，这个功能很有用，因为你知道应该找谁修复它！但是它也有一个积极的用途：如果你发现了一段特别聪明的代码，VCS
    会告诉你该向谁表示赞赏，并且希望你能从中学习。所以，*blame* 功能为改善开发者之间的职业关系和增强团队士气提供了一个很好的方式。
- en: I need to restore my copy of Foo.java
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我需要恢复我的 Foo.java 文件的副本
- en: 'I’m sure *you’ve* never accidentally deleted a file after working on it all
    day, but we sure have. And I’m sure *you* are scrupulous about making backups
    for exactly that sort of event, but we sure aren’t. But since we always use a
    VCS, restoring a lost file is easy: every VCS gives you a simple way to view and
    restore the last version of any file that it manages.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我敢肯定*你*从来没有在工作一整天后不小心删除过文件，但我们确实有过这种经历。我也敢肯定*你*非常小心地为这种情况做备份，但我们可没有。但是，由于我们总是使用VCS，恢复丢失的文件变得非常简单：每个VCS都提供了一种简单的方式来查看和恢复它所管理的任何文件的最后一个版本。
- en: I want to revert to this morning’s version of all the files in the test directory
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我想恢复今天早上测试目录中所有文件的版本
- en: You’re not limited to restoring just the last version of a file; you can restore
    *any* version of a file, no matter how old it might be, so long as you added a
    snapshot that includes that version. For example, imagine that you spent hours
    rewriting automated tests to make them run faster, only to discover that your
    new tests are either slower or don’t work at all. Your VCS will let you replace
    just one file, all the files in a directory, or all the files in a project, with
    any old version of those files. Go ahead and edit whatever files you want, as
    often as you want. If you’re careful to regularly check your changes into your
    VCS, you can quit worrying about losing work or reverting to old code if the new
    code doesn’t work out.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅可以恢复文件的最新版本；你可以恢复*任何*版本的文件，无论它有多旧，只要你添加了包含该版本的快照。例如，假设你花了几个小时重写自动化测试，以使它们运行得更快，却发现你的新测试要么更慢，要么根本无法工作。你的VCS会让你替换单个文件、目录中的所有文件，或者项目中的所有文件，恢复为任何旧版本。尽管可以随意编辑任何文件，但只要你小心定期将更改提交到VCS，就不必担心丢失工作或在新代码不可用时恢复到旧代码。
- en: A colleague and I want to edit Foo.java at the same time
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我和同事想同时编辑Foo.java
- en: Probably the most frequently used feature of VCSs is their ability to safely
    partition the edits you’re making in a file so that they don’t overwrite work
    that other people are doing in the same file. Each developer has a *branch* of
    the code, where they can edit whatever files they want, even if other people are
    editing the same files on their branches. As each developer finishes their work,
    they *merge* their branch into the project’s stable code base. In this way, multiple
    developers can all edit the same file at the same time without anyone losing any
    work or having to coordinate ownership of the file.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: VCS最常用的功能可能是它们能够安全地划分你在文件中所做的修改，以防止它们覆盖其他人在同一文件中所做的工作。每个开发人员都有一个*分支*，可以在其中编辑任何想编辑的文件，即使其他人也在他们的分支上编辑相同的文件。当每个开发人员完成工作后，他们会将自己的分支*合并*到项目的稳定代码库中。通过这种方式，多个开发人员可以同时编辑同一个文件，而不会丢失任何工作，也不需要协调文件的所有权。
- en: I need to deploy last Friday’s version of the code to the production environment
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我需要将上周五的代码版本部署到生产环境
- en: VCSs let you *tag* specific versions of your files so that it’s easy to view
    or restore those versions. For example, you may tag your entire code base before
    undertaking a major refactoring project so that it will be easy to revert to a
    known-good state if the refactoring doesn’t work out. More commonly, development
    teams often tag a specific version of the code so that they know exactly which
    code was deployed with a particular release. For example, you may apply a `version-6-1-0`
    tag to code that you deployed as version 6.1.0 of your product. When someone reports
    a bug in that version of your product, you know which version of your product’s
    files to troubleshoot.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: VCS（版本控制系统）允许你*标记*特定版本的文件，这样就可以轻松查看或恢复这些版本。例如，你可以在进行大规模重构项目之前标记整个代码库，这样如果重构没有成功，你就可以轻松恢复到已知的良好状态。更常见的是，开发团队通常会标记代码的特定版本，以便准确知道某个发布版本中部署的是哪一版代码。例如，你可以给你部署的产品版本6.1.0的代码打上`version-6-1-0`标签。当有人报告该版本的产品存在bug时，你就知道该检查产品文件的哪个版本。
- en: I want all my coworkers to have access to my edited code
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我希望我的所有同事都能访问我编辑过的代码
- en: When you edit a file, your team members must know that you’ve edited it and
    be able to see your edits. VCSs make it easy for you to *push up* your edits to
    a centralized location. Then other team members can *pull down* those changes
    onto their local computers, keeping the entire team in sync.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编辑一个文件时，你的团队成员必须知道你已经编辑了它，并且能够看到你的编辑。VCS让你可以轻松地将编辑内容*推送*到集中式位置。然后，其他团队成员可以将这些更改*拉取*到他们的本地计算机，确保整个团队保持同步。
- en: Why Git is popular
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么Git这么受欢迎
- en: We’ve already mentioned that Git has become the dominant VCS. Why is that? Different
    Git users would give different explanations for its rise to the top, but here
    are some characteristics that probably helped.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到过 Git 成为了主流的版本控制系统。那是为什么呢？不同的 Git 用户会给出不同的解释，但以下是一些可能帮助它登顶的特点。
- en: Pedigree
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 血统
- en: 'Git was invented by Linus Torvalds as a tool for storing and managing the source
    code for the Linux kernel. The fact that Git was originally used to store high-profile,
    successful, and widely adopted code such as the Linux kernel no doubt gave it
    instant credibility and cachet: if it’s robust and reliable enough for Linus and
    Linux, it’s good enough for you.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Git 是由 Linus Torvalds 发明的，用于存储和管理 Linux 内核的源代码。Git 最初用于存储像 Linux 内核这样高知名度、成功且广泛采用的代码，这无疑赋予了它即时的信誉和声望：如果它足够强大和可靠，能满足
    Linus 和 Linux 的需求，那么它也足够适合你。
- en: 'As an aside, it’s amazing that one programmer is responsible for launching
    two major software projects: Linux and Git. It’s as if Shakespeare invented the
    pencil just to make his plays easier to write.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便提一下，一个程序员负责启动两个重要的软件项目：Linux 和 Git，真是令人惊讶。就好像莎士比亚发明了铅笔，只是为了让他的剧本更容易写一样。
- en: Simple branch management
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单的分支管理
- en: As you’ll learn shortly, branches are one of the most important components of
    any VCS. Git was designed from the beginning to make it simple to create, use,
    and merge branches. The ease with which developers can work with branches encourages
    them to use lots of branches, which promotes safe and rapid development workflows.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你很快就会了解到的，分支是任何版本控制系统中最重要的组成部分之一。Git 从一开始就设计得非常简单，方便创建、使用和合并分支。开发者可以轻松地使用分支，这促使他们使用大量的分支，从而促进安全和快速的开发工作流程。
- en: Speed
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 速度
- en: Git is fast. Adding new files, checking in changes, reverting to old code, and
    syncing files to incorporate coworkers’ edits – these operations all happen in
    just a few seconds, even with large projects. In particular, creating, using,
    and merging branches are all lightning-fast operations, and that’s one of the
    key reasons why developers love working with Git so much.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Git 非常快速。添加新文件、提交更改、恢复旧代码以及同步文件以纳入同事的编辑——这些操作都在几秒钟内完成，即使是大型项目。特别是创建、使用和合并分支的操作速度非常快，这也是开发者如此喜爱使用
    Git 的关键原因之一。
- en: Reliability
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可靠性
- en: 'You may think that reliability would be basic table stakes for any VCS: if
    the VCS loses your files or edits, it’s useless at its role. But a surprising
    number of VCSs over the years have been less than 100% reliable. A hundred-person
    development team that one of us worked on in the early 2000s used the dominant
    proprietary VCS of the time, and even though it was thought of as the best-in-breed
    of that sort of tool, it frequently lost or scrambled our edits.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能认为，可靠性应该是任何版本控制系统的基本要求：如果 VCS 丢失了你的文件或编辑，它就无法履行其职责。但令人吃惊的是，许多版本控制系统多年来并不是
    100% 可靠的。我们在 2000 年代初期曾参与的一个一百人的开发团队使用了当时主流的专有版本控制系统，尽管它被认为是这一类工具中的最佳，但它经常丢失或弄乱我们的编辑。
- en: Git is famously reliable. It’s a complex tool, and if you don’t understand exactly
    how to use its commands, you could inadvertently lose data through human error.
    But it’s virtually unheard of for Git to suffer from technical glitches that result
    in data loss. It’s trusted by countless teams of skeptical software engineers
    around the world, and that trust is well-earned.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: Git 以其可靠性而闻名。它是一个复杂的工具，如果你不完全理解如何使用它的命令，可能会因为人为错误而丢失数据。但 Git 出现技术故障导致数据丢失的情况几乎闻所未闻。全球无数怀疑的程序员团队信任它，而这种信任是经过长期实践验证的。
- en: Distributed architecture
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分布式架构
- en: Before Git, many VCSs used a *centralized* architecture. That means that to
    work on a file, you needed to fetch its latest version from a central server,
    make edits, and then resubmit that file to the central server so that other team
    members could access it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Git 之前，许多版本控制系统（VCS）采用了*集中式*架构。这意味着要在文件上工作，你需要从中央服务器获取文件的最新版本，进行编辑，然后再将文件重新提交到中央服务器，以便其他团队成员能够访问。
- en: There are a few problems with a centralized architecture. First, some (but not
    all) centralized VCSs *lock* any files that you’ve checked out, so no one else
    can make changes to those files while you’re editing them. This results in a lot
    of “*Hey, are you done with* `Foo.java` *yet?*” conversations in the workplace,
    which creates an awkward, inconvenient, and annoying workflow.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 集中式架构存在一些问题。首先，一些（但不是所有）集中式VCS会*锁定*你已签出的文件，因此在你编辑这些文件时，其他人无法对它们进行修改。这会导致很多“*嘿，你做完`Foo.java`了吗？*”这样的对话，这会创造出一种尴尬、不便且令人烦恼的工作流程。
- en: The second problem with using a VCS with a centralized architecture is that
    it requires you to be connected to that central server whenever you need to check
    out a file or check in edits. You can’t work effectively without internet connectivity.
    This is less of a problem than it used to be, but there are still times when you’re
    between hot spots and still want to get work done.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用集中式架构的VCS的第二个问题是，它要求你每次需要签出文件或提交编辑时都必须连接到那个中央服务器。没有网络连接，你无法高效工作。尽管这种问题不如以前那么严重，但仍然会有一些时刻，你处于热点之间，仍然想继续工作。
- en: Centralized architectures also create a single point of failure. If the server
    goes down, all the developers are dead in the water. If it loses data or is physically
    destroyed, it could be days before the data is restored or the hardware is rebuilt.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 集中式架构也会创建一个单点故障。如果服务器出现故障，所有开发人员的工作都会陷入停滞。如果数据丢失或服务器被物理摧毁，恢复数据或重建硬件可能需要几天时间。
- en: Finally, centralized architectures don’t always scale well as development teams
    grow. Rapidly growing teams that rely on an underpowered VCS server can find their
    work blocked as they queue to access that server.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，随着开发团队的增长，集中式架构的扩展性往往较差。依赖性能不足的VCS服务器的快速增长的团队，可能会在排队访问该服务器时被阻塞。
- en: Fortunately, the distributed architecture that Git is built around solves all
    these problems. These problems vanish when you have many copies of the project’s
    files on different computers. When using a distributed VCS, each developer has
    a copy of the entire project on their local computer. This includes all the files,
    edit history, tags, commit messages, and other metadata needed to let them work
    on the files without any connection to a central server.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Git所依赖的分布式架构解决了所有这些问题。当你在不同的计算机上拥有项目文件的多个副本时，这些问题便消失了。在使用分布式VCS时，每个开发人员的本地计算机上都有整个项目的副本。包括所有文件、编辑历史、标签、提交消息以及其他元数据，这些都使得开发人员可以在没有连接到中央服务器的情况下继续工作。
- en: 'How does this strategy help with the problems faced by centralized VCSs? First,
    if every developer has a local copy of all the files in the project, there’s no
    concept of *locking* a file that you’re editing: anyone can edit their local copy
    of any files at any time. Second, there’s no need to contact a central server
    to check out files, and there’s no need to contact a server to check in your edits.
    You can work locally for as long as you want. It’s true that, eventually, you’ll
    need to sync your edits to a server so that your coworkers can see your edits
    (and you can see theirs), but you can do that as often or as infrequently as makes
    sense for your team. Third, since there’s a copy of the entire project’s files
    on every developer’s machine, there’s no longer a single point of failure. If
    the central server that you use to sync changes goes down, you can designate any
    developer’s machine as a temporary central server while you rebuild the original
    server. Finally, because developers who use a distributed VCS sync their code
    with the central server far less often than developers who use a centralized VCS
    to check files in and out of that server, distributed VCSs scale much better than
    their centralized competitors. Most teams who use Git experience no VCS-related
    scaling problems as they add new team members.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略如何帮助解决集中式版本控制系统所面临的问题呢？首先，如果每个开发者都有项目中所有文件的本地副本，就不存在*锁定*你正在编辑的文件的概念：任何人都可以随时编辑他们本地的任何文件。其次，不需要联系中央服务器来检出文件，也不需要联系服务器来提交修改。你可以在本地工作，直到你愿意。确实，最终你需要将你的修改同步到服务器上，以便同事能看到你的修改（而你也能看到他们的修改），但你可以根据团队的需要，决定同步的频率。第三，由于每个开发者的机器上都有整个项目文件的副本，所以不再有单一的故障点。如果你用来同步更改的中央服务器出现故障，你可以将任何开发者的机器指定为临时中央服务器，同时重建原始服务器。最后，因为使用分布式版本控制系统的开发者与中央服务器同步代码的频率远低于使用集中式版本控制系统的开发者，所以分布式版本控制系统在扩展性方面比集中式版本控制系统更具优势。大多数使用Git的团队在增加新成员时不会遇到版本控制相关的扩展问题。
- en: Drawbacks of Git
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Git的缺点
- en: 'Remember how we mentioned that Git gained credibility by being invented by
    Linus Torvalds? Unfortunately, there’s a downside to this: it was designed to
    fit Linus’s mind, not yours. This means that its commands can be inconsistent,
    confusing, and counterintuitive. To give just one example, let’s look at how one
    command uses three different ways to modify its behavior:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 记得我们提到过Git之所以有信誉，是因为它是由Linus Torvalds发明的吗？不幸的是，这里有一个问题：它是为Linus的思维方式设计的，而不是为你的。这意味着它的命令可能不一致、令人困惑，并且违反直觉。举个例子，让我们看看一个命令如何通过三种不同的方式来修改它的行为：
- en: '`git branch` lists all available branches.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git branch` 列出所有可用的分支。'
- en: '`git branch foo` makes a new branch called *foo*.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git branch foo` 创建一个名为*foo*的新分支。'
- en: '`git branch --delete foo` deletes a branch called *foo*.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git branch --delete foo` 删除一个名为*foo*的分支。'
- en: 'You might expect these commands to be the following instead:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会期待这些命令应该是这样的：
- en: '`git branch --list` (this does work but isn’t necessary and no one uses it)'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git branch --list`（这有效，但不必要，也没有人使用它）'
- en: '`git branch --``create foo`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git branch --``create foo`'
- en: '`git branch --``delete foo`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`git branch --``delete foo`'
- en: But that’s not the case; you must remember the different option syntaxes instead.
    And that’s just for one command.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 但情况并非如此；你必须记住不同的选项语法。仅仅是一个命令就需要这样做。
- en: The other big problem with Git is that it’s so big. It has so many features
    and options and configurable settings that it can seem overwhelming. The official
    reference documentation, a book called *Pro Git*, is 511 pages long! When you’re
    getting started with the tool, it’s easy to get the sense that you’ll never know
    enough about Git’s concepts and commands to be able to use it productively, and
    you may wonder how anyone is ever able to get to grips with something so complicated.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Git的另一个大问题是它太庞大了。它有很多功能、选项和可配置的设置，可能让人觉得不知从何入手。官方参考文档，《*Pro Git*》一书，长达511页！当你刚开始使用这个工具时，很容易产生一种感觉，觉得自己永远也学不够Git的概念和命令，无法有效使用它，你可能会想，怎么会有人能够掌握这么复杂的东西。
- en: Fortunately, you don’t need to know all the ins and outs of Git’s inconsistencies
    and syntactical complexities, and you don’t need to know all the features that
    Git provides. You just need to know a handful of common commands and their variants
    to perform 95% of the Git-related tasks you need. Most Git users learn 20 or so
    common operations, commit those to memory over time, and look up the details of
    other Git operations only as needed. *So, don’t panic, and don’t try to learn
    and memorize all of Git.* If you feel comfortable with the simple commands and
    concepts described in this chapter, you’re equipped to do real work with Git.
    It may turn out to be all you’ll ever need from the tool.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你不需要了解 Git 的所有不一致性和语法复杂性，也不需要知道 Git 提供的所有功能。你只需要掌握一些常用的命令及其变种，就能完成 95%
    需要的 Git 相关任务。大多数 Git 用户学习大约 20 个常见操作，随着时间的推移将其记住，其他 Git 操作的细节只在需要时查阅。*所以，不要慌张，也不要试图学习并记住所有的
    Git 知识。* 如果你对本章描述的简单命令和概念感到舒服，你已经具备了使用 Git 做实际工作的能力。这可能就是你从这个工具中所需的全部。
- en: That’s enough of an introduction to Git. Now, it’s time to look at some actual
    commands.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是对 Git 的介绍，现在是时候查看一些实际的命令了。
- en: Committing code to keep it safe
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提交代码以保持它的安全。
- en: To benefit from all the advantages described previously, you need to know how
    to add files to Git. How do you do that?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了享受前面所描述的所有优势，你需要知道如何将文件添加到 Git 中。你该如何做到呢？
- en: First, let’s discuss the concept of a **repository**, which is often shortened
    to **repo** A repository is a place where Git stores a project’s files and a history
    of all the changes made to those files. It’s the bank vault where it puts files
    to keep them safe.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们讨论一下**仓库**的概念，它通常简写为**repo**。仓库是 Git 存储项目文件和所有文件更改历史的地方。它是一个保险库，用来保存文件以确保其安全。
- en: 'There are two main ways to create a repository. The first way is to convert
    an ordinary directory on your Linux, macOS, or Windows filesystem into a Git repository.
    This is easy: use the `git init` command from inside the directory, and voilà
    – it turns into a Git repository. Then, you can use the `git status` command to
    prove that it’s a repo.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 创建仓库有两种主要方式。第一种方式是将 Linux、macOS 或 Windows 文件系统中的普通目录转换为 Git 仓库。这非常简单：在该目录中使用
    `git init` 命令，完成后它就变成了一个 Git 仓库。然后，你可以使用 `git status` 命令来证明它是一个仓库。
- en: 'Let’s use those commands to create a new repository for our Hats for Cats project.
    First, make a new directory that will become a repository, and move into that
    directory (the example in this chapter is using a Linux Terminal, so the prompt
    and output may look slightly different if you use another terminal or OS, but
    the concepts will be the same):'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用这些命令为我们的“猫帽子”项目创建一个新的仓库。首先，创建一个新的目录，将其变成一个仓库，并进入该目录（本章中的示例使用的是 Linux 终端，如果你使用的是其他终端或操作系统，提示符和输出可能会稍有不同，但概念是相同的）：
- en: '[PRE4]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Prove that it’s not a Git repo yet:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 证明它还不是一个 Git 仓库：
- en: '[PRE5]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Turn the directory into a Git repo with the `git` `init` command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `git` `init` 命令将该目录转变为 Git 仓库：
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, watch how `git status` doesn’t explicitly tell us that we’re in a repo,
    but it does provide information that only makes sense if the directory has been
    turned into a repository. It tells us that we’re on the `main` branch, that Git
    is not tracking any files in the repository, and that we haven’t edited any files
    in this directory that we may want to ask Git to manage:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，观察 `git status` 如何没有明确告诉我们我们是否在一个仓库中，但它确实提供了只有在目录被转变为仓库时才有意义的信息。它告诉我们我们在
    `main` 分支上，Git 没有跟踪仓库中的任何文件，并且我们没有编辑任何可能希望 Git 管理的文件：
- en: '[PRE7]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The second, and probably more common, way to create a repository is to copy
    an existing repository from another computer using the `git clone` command. Earlier
    in this chapter, we talked about how Git’s distributed architecture means that
    each team member has a full copy of their project’s Git repository on their computer.
    Cloning is how you download a new copy of that repo from someone else’s computer
    to your computer. We’ll talk about this process in detail later when we discuss
    remote repositories. For now, just understand that if you’re working as a member
    of a software development team, most of the time, you’ll be cloning a repository
    from another computer instead of creating a new repository just on your computer.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 创建仓库的第二种方式，可能也是更常见的一种方式，是使用`git clone`命令从另一台计算机复制现有的仓库。在本章之前，我们提到过Git的分布式架构意味着每个团队成员都在自己的计算机上拥有项目Git仓库的完整副本。克隆是从其他计算机下载该仓库副本到你计算机的方式。稍后我们会在讨论远程仓库时详细介绍这一过程。目前，理解作为软件开发团队的一员，你大多数时候会从其他计算机克隆仓库，而不是仅在自己的计算机上创建新仓库。
- en: 'Now that we have a repository, let’s add a file to it. For this example, let’s
    add a to-do list. First, use the `touch` command or a text editor to create a
    file called `todo.txt` in the `hats-for-cats/` directory. Fill the file with whatever
    content you want or leave it empty. Git can manage empty files just fine:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一个仓库，接下来我们来添加一个文件。以这个例子为例，添加一个待办事项列表。首先，使用`touch`命令或文本编辑器在`hats-for-cats/`目录中创建一个名为`todo.txt`的文件。可以在文件中填写任何内容，或者让它保持为空。Git可以很好地管理空文件：
- en: '[PRE8]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Your directory contains a file, but Git is not tracking that file yet, since
    you haven’t officially added it to the repository. Doing so is a two-step process:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你的目录中包含一个文件，但Git还没有跟踪该文件，因为你还没有正式将其添加到仓库中。这个过程分为两步：
- en: Move one or more files into something called the *staging area.*
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个或多个文件移动到称为*暂存区*的地方。
- en: '*Commit* all the files in the staging area.'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*提交*暂存区中的所有文件。'
- en: It’s important to understand that a file is not stored in Git, meaning that
    Git will not manage the versions of that file until *you stage it and then* *commit
    it*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这一点很重要：文件在Git中并不存储，意味着Git不会管理该文件的版本，直到*你将它暂存并提交*。
- en: Remember how we talked about VCSs making “snapshots” of the state of your files
    at a particular time? This stage-and-commit process is how you make a new snapshot
    with Git. This means you are in complete control of when to make snapshots, and
    also of what files are included in each snapshot. If you’re editing `foo.py` and
    `bar.py` but only want to snapshot `foo.py` right now, just add that file to your
    staging area and commit it. When it’s time to make a snapshot with edits to `bar.py`,
    add that file to the staging area, optionally add `foo.py` as well if you want
    to snapshot any edits you made to it since the last time you snapshotted it, and
    then commit the file(s) that is in the staging area.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 还记得我们谈到过版本控制系统（VCS）如何在特定时间对文件状态进行“快照”吗？这个暂存和提交过程就是你用Git创建新快照的方式。这意味着你完全控制何时创建快照，以及每个快照包含哪些文件。如果你正在编辑`foo.py`和`bar.py`，但此时只想对`foo.py`进行快照，那么只需将该文件添加到暂存区并提交。当你准备好对`bar.py`进行编辑并创建快照时，将该文件添加到暂存区，当然如果你希望记录自上次创建快照以来对`foo.py`所做的任何更改，也可以将`foo.py`一并添加，然后提交暂存区中的文件。
- en: 'You may have noticed that we’ve talked about staging and committing both new
    files and edits to existing files. That’s because you use the same stage-and-commit
    process for both cases. You may find it easiest to think of staging and committing
    as something you do to capture *any changes to files*, where changes can take
    four different forms:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我们讨论过暂存和提交新文件以及编辑现有文件。之所以这样，是因为无论是新文件还是修改文件，你都使用相同的暂存和提交过程。你可以将暂存和提交看作是用来捕捉*文件的任何更改*，而更改可以有四种不同的形式：
- en: Creating a new file
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新文件
- en: Editing the content of an existing file
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑现有文件的内容
- en: Renaming or moving a file (as far as the filesystem is concerned, these are
    the same operation)
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重命名或移动文件（就文件系统而言，这两者是相同的操作）
- en: Deleting a file
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除文件
- en: No matter which of these operations you perform, when you add one or more files
    to the staging area and then commit, you’re making a new Git snapshot of the state
    of whatever files were in the staging area.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你执行哪种操作，当你将一个或多个文件添加到暂存区并提交时，你实际上是在为暂存区中的文件创建一个新的Git快照。
- en: You might be wondering why the stage-and-commit dance contains two separate
    steps. Couldn’t Git just provide a single command to make a new snapshot of a
    file? The reason for this extra complication is to allow you to include *multiple
    files in a single commit*. For example, you may edit a source code file, edit
    some associated test code that lives in a different file, and finally edit a documentation
    file, all as part of one bug fix. You’d want to include all three of these files
    in a single commit since the edits to all the files logically belong together.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，为什么暂存和提交的步骤需要分开？Git 难道不能提供一个命令来直接创建文件的快照吗？这样做的原因是为了让你能够在一个提交中包含*多个文件*。例如，你可能编辑了一个源代码文件、修改了一些位于不同文件中的关联测试代码，并最终编辑了一个文档文件，这些都是修复一个
    bug 的一部分。你会希望把这三个文件都包含在一个提交中，因为对所有文件的修改在逻辑上是关联的。
- en: 'First, let’s stage your new `todo.txt` file using the `git add` command. This
    doesn’t move or copy the file anywhere. Rather, it adds an invisible label to
    the file saying that it is in the staging area:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们使用 `git add` 命令来暂存你的新 `todo.txt` 文件。这并不会移动或复制文件，而是给文件添加了一个看不见的标签，表示它已经进入暂存区：
- en: '[PRE9]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If you run `git status` again, you’ll see that `todo.txt` is now included in
    a list of *changes to be committed*, which means that it’s been added to the staging
    area but hasn’t been committed yet:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次运行 `git status`，你会看到 `todo.txt` 已经包含在*待提交更改*的列表中，这意味着它已经被添加到暂存区，但还没有提交：
- en: '[PRE10]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, you can commit it with the `git commit` command. But first, a word about
    commit messages. An important part of every commit is the human-readable commit
    message that the committer must provide. The easiest way to add this message is
    as a parameter to `git commit`, using the `--``message` option:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以使用 `git commit` 命令提交它了。但在此之前，关于提交信息，有几点需要说明。每个提交的重要组成部分就是提交者提供的可读提交信息。最简单的添加方法是作为
    `git commit` 命令的一个参数，使用 `--message` 选项：
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If you run `git status` again, you’ll see that no files are waiting to be committed,
    which means your to-do list has been safely stashed in the repository, and all
    future edits to it will be tracked by Git. Congratulations, you’ve just performed
    your first work with Git!
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次运行 `git status`，你会看到没有文件等待提交，这意味着你的待办事项列表已经安全地存储在仓库中，且所有未来的修改都将被 Git 跟踪。恭喜你，你刚刚完成了第一次使用
    Git 的操作！
- en: 'Let’s pause for a minute and talk about what Git includes with every commit.
    You’ve already learned that a commit contains the contents of any file(s) included
    in that commit and a message that describes the purpose of the commit, but there
    are a few other pieces of information it includes as well. Here’s the complete
    list:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们暂停一下，谈谈 Git 每次提交时包含的信息。你已经了解到，提交包含了提交文件的内容和描述提交目的的信息，但它还包含其他一些信息。以下是完整的列表：
- en: Any changes made to the file’s contents (or the filename or location in the
    filesystem).
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对文件内容（或文件名或文件系统中的位置）所做的任何更改。
- en: 'A 40-character string of hexadecimal digits that’s called a **Secure Hash Algorithm**
    (**SHA**), which is the code that generates this string based on the contents
    of the committed files. A commit’s SHA uniquely identifies that commit; think
    of it as a unique *name* for that commit. SHAs are not sequential: each SHA is
    completely different from the SHA of the previous commit.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个由 40 个十六进制字符组成的字符串，称为**安全哈希算法**（**SHA**），该代码根据提交文件的内容生成这个字符串。一个提交的 SHA 唯一标识该提交；你可以把它看作是该提交的唯一*名称*。SHA
    不是按顺序排列的：每个 SHA 都与前一个提交的 SHA 完全不同。
- en: The name and email of the person who made the commit.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交者的姓名和电子邮件。
- en: A timestamp of when they made the commit.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交时间戳。
- en: A human-readable message describing why they made the commit.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 描述为什么进行这次提交的易读信息。
- en: A pointer to the previous commit (or parent commit) on the branch. We’ll introduce
    the concept of branches in the next section and talk about this pointer more then.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指向当前分支上前一个提交（或父提交）的指针。我们将在下一节介绍分支的概念，并进一步讨论这个指针。
- en: 'The `git log` command shows you all this information for all the commits on
    your current branch (again, we’ll explain branches in more detail later). Let’s
    imagine that you’ve made two commits: one to create an empty to-do list and another
    to add an item to that list. Running `git log` gives an output similar to the
    following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`git log` 命令会显示当前分支上所有提交的信息（我们稍后会更详细地解释分支）。假设你已经进行了两次提交：一次是创建一个空的待办事项列表，另一次是往列表中添加了一项内容。运行
    `git log` 会输出类似以下内容：'
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This output includes information for your two commits, with the most recent
    commit at the top. Can you spot the SHA, author information, timestamps, and commit
    message for each commit? If you’re running these commands on your computer, you’ll
    see different details for each commit, but the format of the output will be the
    same.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出包括您的两个提交的信息，最近的提交位于顶部。您能找到每个提交的 SHA、作者信息、时间戳和提交信息吗？如果您在自己的电脑上运行这些命令，您将看到每个提交的不同细节，但输出的格式将保持一致。
- en: In this example, all the commit information is for commits that you’ve made.
    But that’s simply because you’re the only person who has added commits to this
    branch. If other people had made commits to the same branch, you would see information
    for their commits in this output as well.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，所有提交信息都来自您自己的提交。这仅仅是因为只有您一个人向这个分支添加了提交。如果其他人也向同一个分支提交了内容，您将看到他们的提交信息也会出现在此输出中。
- en: Excluding files from a repository
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从仓库中排除文件
- en: 'At this point, you might be thinking that it would be wise to stage and commit
    *all* the files in a project. But there are a few types of files that you usually
    do not want to store in Git or any other VCS. These include, but are not limited
    to, the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，您可能会认为将项目中的*所有*文件都暂存并提交是明智的做法。但实际上，有几类文件您通常不希望存储在 Git 或任何其他版本控制系统中。这些文件包括但不限于以下几类：
- en: Files that are generated from other files
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从其他文件生成的文件
- en: Extremely big files
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 极大的文件
- en: Files that contain secrets
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含敏感信息的文件
- en: The first category includes files such as executables that are compiled from
    source code, or PDFs that are generated from the source text that’s stored in
    Markdown. Since you can always regenerate these files from their sources, there’s
    no need to store them in Git. Also, putting them in Git introduces the possibility
    of *drift*, where the source files and the generated files are out of sync with
    each other. For example, the source file may contain code from last week, while
    the compiled executable may contain code from last month. This can cause all sorts
    of unexpected problems.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 第一类文件包括从源代码编译而来的可执行文件，或从存储在 Markdown 中的源文本生成的 PDF 文件。由于您可以随时从源文件重新生成这些文件，因此无需将它们存储在
    Git 中。此外，将它们放入 Git 可能会引入*漂移*问题，即源文件和生成的文件不同步。例如，源文件可能包含上周的代码，而编译后的可执行文件可能包含上个月的代码。这会导致各种意想不到的问题。
- en: Big files pose a different sort of problem. If you add a 5 GB ISO file or a
    10 GB dataset, then anyone who copies your project’s repository to their local
    machine will be forced to download that file. We mentioned earlier that Git is
    fast, but there’s nothing it can do about congested or slow networks. Since copying
    repositories is a fairly common operation among Git users, including enormous
    files in your repository is something you’d generally like to avoid. It often
    makes more sense to put these files outside of Git, on a shared drive or some
    other accessible data storage system. Removing a large file after you’ve added
    it won’t solve the problem. Because Git keeps a record of the entire edit history
    of every file ever added to the repository, that large file will stick around
    in your repository forever, annoying you and your coworkers every time someone
    copies the repo to their local computer.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 大文件提出了另一种问题。如果您添加了一个 5 GB 的 ISO 文件或一个 10 GB 的数据集，那么任何将您的项目仓库复制到本地的用户都将不得不下载该文件。我们之前提到过，Git
    很快，但它无法解决拥挤或缓慢的网络问题。由于复制仓库在 Git 用户中是一个相当常见的操作，因此通常希望避免在仓库中包含巨大的文件。将这些文件放在 Git
    外部，例如共享驱动器或其他可访问的数据存储系统上，通常是更合适的做法。即使您删除了一个已经添加的大文件，也无法解决问题。因为 Git 会记录每个添加到仓库中的文件的完整编辑历史，所以该大文件会永远留在您的仓库中，每当有人将仓库复制到本地时，都会给您和您的同事带来困扰。
- en: Finally, secrets such as deploy keys, SSH private keys, or passwords usually
    should not be stored in Git. As explained in the previous paragraph, any secrets
    that you commit to a repository will be there forever. Unless your IT and Git
    administrators are extremely careful about limiting permissions to repositories,
    this means they can be viewed by anyone with access to your repository. So, these
    sorts of things are normally stored not in Git, but in a specially designed system
    that’s dedicated to keeping sensitive data safe.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: This is an important topic, so let’s investigate it further by looking at a
    concrete example. Imagine that your `hats-for-cats/` directory contains a file
    called `personal-notes.txt` and a directory called `.ide-config/`. The former
    is where you store ideas for project features as they occur to you, while the
    latter holds several files that your IDE uses to configure the project on your
    local machine. You may not want to share either of these with the other members
    of your development team since the ideas are meant just for your eyes and the
    configuration files will only work with your computer setup.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: 'You can keep this file and directory private simply by never using the `git
    add` command to add them to your project’s Git repository. That works, but there’s
    a problem with this approach. Whenever you run `git status` to find out if there
    are any edited files that you should add and commit, Git will always point out
    that `personal-notes.txt` and `.ide-config/` are not in the repository:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There’s a simple solution to this problem: create a new file called `.gitignore`
    in the root of your project’s directory. For the content of this file, add the
    names of any files or directories that you’d like Git to ignore. You can add explanatory
    comments by starting a line with a hash character. The following code in `.gitignore`
    instructs Git to exclude the files we’ve been talking about:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You need to add this `.gitignore` file to the repository, just like any other
    file you want Git to track:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Thanks to `.gitignore`, Git no longer warns you about uncommitted files and
    directories when you run `git status`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: It’s not unusual for large projects to end up with tens or even hundreds of
    entries in `.gitignore`, and we encourage you to use this feature to keep your
    Git repository clean and your `git status` output uncluttered.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s review the commands and concepts you’ve learned about in this section
    for keeping code safe by committing it to a Git repository:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Use `git init` or `git clone` to create a Git repository on your computer.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `git add` to add one or more files to Git’s staging area.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `git commit --message "<MESSAGE>"` to make a new Git commit (or snapshot)
    that includes any files that were in the staging area.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `git status` to see if you have edited files waiting to be moved to the
    staging area, or staged files waiting to be committed.
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `git log` to see information about all the commits that have been made to
    your current branch.
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a `.gitignore` file to exclude certain files or directories from the repository.
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `.gitignore` 文件排除仓库中的某些文件或目录。
- en: Now, let’s learn how to *tag* a particular version of the files that you so
    carefully committed to Git so that you can easily view or revert to that version
    in the future.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们学习如何*标记*你在 Git 中精心提交的文件的特定版本，以便你将来可以轻松查看或恢复到该版本。
- en: Tagging commits to identify versions of code
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为了标记提交，识别代码版本
- en: 'Now that you understand how and why developers commit code to Git, we can explain
    tagging. Tagging is simple: it’s a way to add a permanent label to a commit. There
    are many reasons to tag, but the two most common are to mark the exact version
    of code that is released to customers and to have a convenient way to return to
    a particular version of the code if you need to revert a large batch of changes.
    Let’s look at an example of each.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经理解了开发者如何以及为什么将代码提交到 Git，我们可以解释标记。标记很简单：它是一种给提交添加永久标签的方式。有很多原因会用到标记，但最常见的两种原因是标记发布给客户的代码的确切版本，以及在需要回滚大量更改时，能够方便地返回到特定版本的代码。我们来看看这两种情况的例子。
- en: 'Imagine that Hats for Cats is ready to release version `git tag` command to
    add a tag representing the version number to the latest commit on your branch:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 假设《Cats for Hats》已经准备好发布版本，你可以使用 `git tag` 命令为分支上的最新提交添加一个表示版本号的标签：
- en: '[PRE17]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If you run `git log`, you’ll see that Git has applied the tag to your latest
    commit.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行 `git log`，你会看到 Git 已经将标签应用到你的最新提交上。
- en: 'As a separate example, imagine that you decide to undertake a major refactoring
    to change your classes to use a more complicated class inheritance structure.
    You know how easy it is to mess up this kind of large-scale change, and you want
    an easy way to return to today’s version of pre-refactored code in case everything
    goes sideways. Tagging is just the solution:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个单独的例子，假设你决定进行一次大规模重构，将你的类改为使用更复杂的类继承结构。你知道这种大规模更改很容易搞砸，所以你希望有一种简单的方式在一切出问题时返回到今天的重构前版本。标记正是解决方案：
- en: '[PRE18]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Tagging has many options, but two of the most useful are `--delete` and `--list`,
    both of which do exactly what you would expect. Try them and see:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 标记有很多选项，但其中两个最有用的是 `--delete` 和 `--list`，它们的功能和你预期的一样。试试它们，看看效果：
- en: '[PRE19]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: That’s tagging in a nutshell. As with most Git commands, there’s much more you
    can do with tagging, but this covers the basics. Fortunately, you now know as
    much about tagging as most Git users, so don’t worry about exploring `git tag`
    further unless you need more flexibility or features when it comes to marking
    versions of your files.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是标记的概述。和大多数 Git 命令一样，标记功能有很多其他操作可以做，但这部分内容涵盖了基础。幸运的是，现在你对标记的理解已经和大多数 Git 用户一样，所以除非你需要更多的灵活性或功能来标记文件的版本，否则不必担心进一步探索
    `git tag`。
- en: You’ve now mastered the fundamentals of storing your files in Git for safekeeping,
    excluding files that you don’t want to store in Git, and labeling certain commits
    for easy future reference. Now, it’s time to learn how to edit, store, and label
    files in a way that doesn’t step on the toes of other developers who might be
    working on the same files. It’s time to look at Git branches!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经掌握了将文件保存在 Git 中以供保存、排除不想保存在 Git 中的文件，并为某些提交加上标签以便将来参考的基本知识。现在，是时候学习如何编辑、存储和标记文件，同时避免与其他可能在相同文件上工作的开发者发生冲突。是时候了解
    Git 分支了！
- en: Branching code for developing in an isolated space
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为了在隔离的空间中开发，进行代码分支
- en: After commits, **branches** are probably the most important concept in Git.
    Strictly speaking, you don’t need to know anything about branches and branching
    to use Git. This is especially true if you’re a solo developer. But any non-trivial
    software development effort that involves more than one person will generally
    make heavy use of branches. Let’s figure out what they are and why we need them.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 提交后，**分支**可能是 Git 中最重要的概念。严格来说，你并不需要了解分支和分支操作就能使用 Git，尤其如果你是一个独立开发者。但任何涉及多人合作的软件开发工作通常都会大量使用分支。让我们来弄清楚它们是什么，以及为什么我们需要它们。
- en: A branch is just a series of ordered commits. Remember when we said that each
    commit includes a backward pointer to the previous commit? If you follow those
    backward pointers from the latest commit back to the first commit ever made to
    the repository, you’ve just described the branch that your commit is on. *Again,
    a branch is just a series of commits, assembled in a particular order, linked
    by* *backward-pointing arrows*.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you’re working on files within a Git repository, you’re *on* exactly
    one branch. This means that you can only see the versions of files that are on
    that branch, and any commits you make will only be added to that branch. Or, more
    technically, any commits you make while on that branch will include a backward-pointing
    arrow that links the commit to the previous commit on that same branch.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'You can think of being on a branch as analogous to driving down a street. Imagine
    a town with only two streets. Main Street runs south to north. First Street forks
    off Main Street, runs parallel to it for a few blocks, and then eventually merges
    back into Main Street. Your car must be on exactly one of these two streets at
    any time. To stretch the analogy a little, imagine there’s a helicopter with a
    huge magnet that can pick your car up and move it between Main Street and First
    Street whenever you want. To make the analogy even stranger, pretend there’s a
    child in the back seat of your car who throws marbles out of the open window onto
    the street every block or so. In this analogy, the streets represent *branches*,
    the car represents *a developer*, the marbles represent *commits* that the developer
    adds to whatever branch they’re on, and the helicopter represents a *Git command*
    (which we’ll learn about soon) that lets the developer switch to any branch they
    want, whenever they want:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Streets and marbles, representing branches and commits](img/B18073_Fig_2.1.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Streets and marbles, representing branches and commits
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: Every repository has at least one branch, informally referred to as the **default
    branch**. Branches have formal names, and the default branch is almost always
    formally named **main** or **master**, with the former now generally preferred.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: 'For reasons explained earlier, drawings of branches usually include arrows
    from each commit to the previous commit on the branch. In other words, the arrows
    point backward in time, from later branches to earlier branches. So, if your repository
    has one branch called **main** with three commits on it (called **A**, **B**,
    and **C**), and another branch called **branch-a** with two commits on it (called
    **D** and **E**), and **branch-a** branched off from **main**, you could draw
    your repository’s state like this:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Branches and commits](img/B18073_Fig_2.2.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Branches and commits
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'Why do you need branches? *They let you develop code that is safely isolated
    from the stable code base until it’s ready to be added to that code base*. Here’s
    a typical workflow to demonstrate how this happens:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么需要分支？*它们让你在代码准备好被加入到稳定的代码库之前，将开发中的代码与稳定的代码库隔离开来*。以下是一个典型的工作流程，展示了这一过程是如何发生的：
- en: Your product code lives in a Git repository. The stable version of that code
    lives in a branch within that repo called **main**.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的产品代码存储在一个Git仓库中。该代码的稳定版本存储在该仓库中的一个名为**main**的分支里。
- en: You are assigned to write a feature for your product that lets users log in.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你被指派为你的产品编写一个让用户能够登录的功能。
- en: You create a branch called **login-feature**.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你创建了一个名为**login-feature**的分支。
- en: You switch to the **login-feature** branch.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你切换到**login-feature**分支。
- en: You edit files and add one or more commits to that branch.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你编辑文件并向该分支添加一个或多个提交。
- en: Other team members review the edits in those commits and give you feedback.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其他团队成员审核这些提交中的编辑内容并给你反馈。
- en: You add another commit that incorporates the feedback.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你添加了另一个提交来合并反馈。
- en: Your team lead approves your work, declaring that the login feature has been
    implemented properly. Your QA team may also sign off on your work.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的团队负责人批准了你的工作，声明登录功能已正确实现。你的QA团队也可能会签署你的工作。
- en: You *merge* the **login-feature** branch into the **main** branch. This means
    that all the commits you made to the **login-feature** branch are now part of
    the **main** branch as well. Your login feature is now part of the product’s main
    code base.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将**login-feature**分支*合并*到**main**分支中。这意味着你对**login-feature**分支所做的所有提交，现在也成为了**main**分支的一部分。你的登录功能现在已经成为产品主代码库的一部分。
- en: Since the **login-feature** branch has been merged and no longer serves any
    purpose, you can safely delete it.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于**login-feature**分支已经合并且不再有任何用途，你可以安全地删除它。
- en: The important thing to notice in this workflow is that while you were developing
    the login feature, your partially complete code was *not* available in the main
    code base (that is, in the **main** branch). Your incomplete code was safely separated
    from your product’s stable code so that your code couldn’t destabilize it. The
    login feature wasn’t added to the main code base until it was formally reviewed,
    approved, and was passing all its tests. That’s what we mean by saying that branches
    let you develop your code in an isolated environment, away from other developers’
    work and away from the stable code base.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个工作流程中，重要的是要注意，在你开发登录功能的过程中，你的部分完成的代码*并未*出现在主代码库中（即**main**分支）。你的不完整代码与产品的稳定代码安全地隔离开来，避免了它破坏稳定性。登录功能直到经过正式审查、批准并通过所有测试后，才会被加入到主代码库中。这就是我们所说的分支让你在隔离的环境中开发代码，远离其他开发者的工作和稳定的代码库。
- en: This example involved just one developer, but typically, several developers
    will work on separate branches at the same time. For example, two developers might
    be working on branches to add new features (each on their own branches), and two
    other developers might be working on separate branches to fix bugs (each on their
    own branches). One particular developer may switch back and forth between multiple
    branches in a single day, as the focus of their work shifts from one task to another.
    The point is that branches are all separate from each other – when you’re on one
    branch, you can’t see or change code on the other branches until they are all
    eventually merged into the **main** branch.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子只涉及一个开发者，但通常，多个开发者会同时在不同的分支上工作。例如，两个开发者可能会在各自的分支上工作以添加新功能，另外两个开发者可能会在各自的分支上工作以修复bug。某个开发者可能在一天内在多个分支之间切换，因为他们的工作重点从一个任务转移到另一个任务。重点是，分支之间是彼此独立的——当你在一个分支上时，无法查看或修改其他分支上的代码，直到所有分支最终合并到**main**分支。
- en: Git commands for managing branches
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于管理分支的Git命令
- en: Let’s learn the Git commands that you need to follow the workflow described
    previously.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习一下你需要用到的Git命令，以便按照之前描述的工作流程操作。
- en: 'Here’s how to create a new branch called `login-feature`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何创建一个名为`login-feature`的新分支：
- en: '[PRE20]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This command shows a list of all the branches that exist in this repository,
    with an asterisk next to the branch that you’re currently on:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令会显示该仓库中所有分支的列表，当前所在的分支会用星号标记：
- en: '[PRE21]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'There are two different commands you can use to switch to a different branch.
    They do the same thing, and you’ll see both in use. In this case, they switch
    you to the`login-feature` branch:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It takes two commands to merge one branch (called the *source branch*) into
    another branch (called the *target branch*) so that all the commits on the source
    branch become part of the target branch. To merge all the commits that are in
    `login-feature` into `main`, first, make sure you are on the *target* branch:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, perform the merge while specifying the *source* branch:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Some organizations like to keep all branches around forever as a matter of
    historical record, but most organizations ask you to delete a branch once you’ve
    merged it into `main`. Here’s how to delete the `login-feature` branch:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If you haven’t merged a branch before you try to delete it, Git will warn you
    and will *not* delete that branch. You can force the branch to be deleted (for
    example, if you’ve created an experimental branch and want to delete it without
    merging), like this:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Handling merge conflicts
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you try to merge one branch into another, you will sometimes run into what’s
    called a *merge conflict*. This means that someone else has edited the same lines
    of the same file that you have, and that they’ve already merged their branch into
    `main` before you got a chance to merge your branch into `main`. When you try
    to merge your branch, Git isn’t sure whether to keep the edits made by the other
    developer or the edits that you’re trying to merge.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: 'To continue with your merge, you first need to resolve the merge conflict.
    There are several ways to do this. Many people find dedicated Git GUI tools such
    as Sourcetree (macOS and Windows) or Sublime Merge (Linux, macOS, and Windows)
    to be the easiest and most intuitive way to handle merge conflicts. Other people
    prefer to resolve merge conflicts manually, using Git terminal commands and a
    text editor. GitLab users have another option: you can use GitLab’s built-in graphical
    merge conflict resolution tool. Regardless of what approach you take, you’ll have
    to somehow tell Git which changes to accept, which changes to throw away, and
    when to continue with the merge.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how the GitLab merge conflict resolution tool works. Imagine that
    you’re working on the `login.py` file on the `new-login-message` branch. After
    creating a merge request for that branch and committing some edits, you return
    to the merge request so that you can merge the branch, only to discover that the
    MR is blocked by a merge conflict:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Merge request blocked by a merge conflict](img/B18073_Fig_2.3.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Merge request blocked by a merge conflict
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Since you only edited one file, you know that someone else must have edited
    the same lines of the same file and merged their edits into the `main` branch
    before you had a chance to do so yourself. Now, Git is understandably confused
    about whether to accept your edits, their edits, or some hybrid. Until that gets
    straightened out, it can’t merge your `new-login-message` branch into `main`.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'GitLab gives you two options to proceed: you can either click **Resolve conflicts**
    to use the built-in GUI tool to resolve the merge conflict, or you can click **Resolve
    locally** to manually instruct Git on how to handle the merge by editing files
    on your computer’s copy of the repository and then pushing those edits back up
    to GitLab. The second of these strategies is beyond the scope of this book, so
    let’s focus on the first strategy: using GitLab to resolve the merge conflict.
    Note that this option only appears in the GUI during simple merge conflicts such
    as the one in this example. If you need to resort to complicated edits to combine
    parts of two separate commits, you will probably need to resolve the merge conflict
    locally and then push the resolution back up to GitLab.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: In this example, you will want to use GitLab’s built-in merge conflict tool,
    so you must click **Resolve conflicts**. You will be taken to a page that shows
    which lines have conflicting edits. You will see that there’s only one line with
    conflicting edits, with your edit highlighted in green and the edit already made
    by someone else highlighted in blue. Let’s say you’ve changed the line “We’re
    glad you’re here” to “We’re really glad you’re here,” whereas the existing edit
    changes the same line to “We’re super glad you’re here!”.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Resolving a merge conflict within GitLab](img/B18073_Fig_2.4.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Resolving a merge conflict within GitLab
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: You decide that you like your edit better, so you click the `new-login-message`
    branch that resolves the merge conflict. This new commit triggers a pipeline run
    on your branch. Once that finishes, you’re free to merge the MR just like you
    normally would. Congratulations – the merge conflict has been successfully resolved
    and the merge is complete!
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Merge conflict is resolved and MR is unblocked](img/B18073_Fig_2.5.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Merge conflict is resolved and MR is unblocked
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be irresponsible to pretend that all merge conflicts are as straightforward
    to resolve as this example, but the general approach remains the same no matter
    how complicated things get: you tell GitLab which edits to keep, which edits to
    throw away, and how to combine edits when you want to mix and match edits on the
    same line of code or text. Many third-party, GUI-based Git tools have more powerful
    merge conflict resolution tools than GitLab offers, so don’t be afraid to try
    a different tool for this task if you find you need more firepower or just a different
    view of what’s going on.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our explanation of creating, committing to, and merging branches.
    We hope you now have an idea of why branches are one of Git’s most essential and
    popular features! But branches become even more powerful when you share them with
    other developers on your team, and when you can get access to branches that they’ve
    been working on. In the next section, you’ll learn how to work collaboratively
    with branches.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Syncing local and remote copies of repositories
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Git can be a useful tool for solo developers, but it’s most often used within
    a team of developers. As we’ve already discussed, Git’s distributed architecture
    means that every developer on the team has a complete copy of the project’s repository,
    including all its commits, commit messages, branches, and all the other data and
    metadata that is included in a repository. Keeping these repositories synced,
    so that they all have the same information in them, is critically important. If
    my copy of the repository and your copy of the repository contain different files
    or different edits to the same files, then I can’t see what work you’ve done and
    vice versa. And if my copy of the repository doesn’t contain the branches that
    you’re adding commits to, I can’t review and approve your work. Synchronizing
    repositories isn’t an automatic process: it involves active participation by the
    developers. This section will explain how to do this.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: The “golden” repository
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before showing you the commands for syncing repositories, we need to partially
    retract something we said earlier. Remember how we explained that one of the advantages
    of Git’s distributed architecture is that there’s no central server that all developers
    need to talk to when doing their work? That’s not strictly true. Git’s distributed
    architecture does require every developer to have a complete copy of the project’s
    repository, but the team needs to designate one of those repository copies as
    what we’ll call the **golden** repository. That’s the repository that is considered
    to contain the *latest version of the stable code base* and is the repository
    where your team releases software. I might be working on a feature on a branch
    on my computer, and you might be working on a bug fix on a branch on your computer,
    and we might have completed all of the edits needed to finish those tasks, but
    until we put our edits into the golden repository, they aren’t officially part
    of the project’s stable code base. Because of the special role that this golden
    repository has, I tend to think of it as a “first among equals” or the “repository
    of record.”
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '*The golden repository is the copy of the repository that lives on the GitLab
    instance*. If your team of 20 developers uses GitLab, there will be at least 21
    copies of your project’s repository: one on each developer’s computer and the
    golden copy on the GitLab instance. If the computer that hosts your GitLab instance
    is unavailable for some reason, you could temporarily designate the repository
    that’s on any developer’s computer as the team’s golden repository. But you would
    want to revert to using the GitLab instance’s copy as the golden repository as
    soon as it’s available again.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: When we talk about syncing edits between different copies of the repository,
    this syncing always happens via the GitLab instance. In other words, if I’ve made
    commits to the repository on my local computer and want to make them available
    to my coworkers, I would *not* send those commits directly to each of their computers.
    Instead, I would send my commits to the golden repository, and then each developer
    would retrieve my commits from the golden repository.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows a workflow that allows one developer to share their
    commits with another developer by pushing and pulling the branch that contains
    those commits to and from the golden repo:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Sharing commits with coworkers via the golden repo](img/B18073_Fig_2.6.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – Sharing commits with coworkers via the golden repo
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Configuring remote repositories
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you can sync your repository with the golden repository, Git needs to
    know that the golden repository exists. Any repository copy that’s not on your
    local computer is called a “remote,” so an important prerequisite for syncing
    commits is to configure remotes.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following command to see a list of the names and URLs for any
    remotes that Git knows about:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Earlier, we described two ways to get a repository onto your computer: `git
    init` and `git clone`. If you’re in a repository that you created with `git init`,
    and you ask Git to give you a list of remotes, it will return no output. It doesn’t
    know about any remotes yet, because you haven’t told it about any. But if you
    copied a repository to your machine using `git clone`, then Git already knows
    about one remote: the copy of the repository that you cloned from.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Before we get ahead of ourselves, let’s discuss how to clone a repository. As
    we mentioned previously, that’s the most common way to get a repository onto your
    computer, so it’s an important practice to be familiar with.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: You can clone a repository from a computer that your local computer has network
    access to, but let’s concentrate on cloning a repository that’s hosted on a GitLab
    instance. This example assumes that the repository is hosted by the instance of
    GitLab that lives at [www.gitlab.com](https://www.gitlab.com). If you’re using
    a self-hosted version of GitLab instead of the **Software-as-a-Service** (**SaaS**)
    version that we’re using in this example, the cloning process is the same, except
    that the address of the repository you’re cloning will look slightly different.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: 'To clone a GitLab-hosted repository, you need to know the address of that repository.
    There are several forms this address can take, but the two most common forms use
    the **HTTPS** protocol or the **SSH** protocol. Although either protocol will
    work, using the SSH protocol is generally preferred. It requires you to configure
    SSH keys to get started, but then you never need to enter credentials when interacting
    with that remote: the key infrastructure takes care of all authentications automatically.
    The HTTPS protocol, on the other hand, requires you to enter a username and password
    every time you use a Git command that talks to that remote.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: You’ve already seen how to create a repository for our Hats for Cats project
    using `git init`, but now, let’s change gears and assume that there’s already
    a Hats for Cats repository on a GitLab instance, and you want to clone that repository
    to your computer.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to create public and private SSH keys using the `ssh-keygen`
    command in your computer’s terminal, and then upload the public key to your GitLab
    instance. GitLab has excellent documentation on how to do this that’s available
    at [https://docs.gitlab.com/ee/ssh](https://docs.gitlab.com/ee/ssh), so we’ll
    refer you to that instead of rehashing the instructions here. Note that you only
    have to do this process once, and then you’ll be authenticated whenever you’re
    interacting with any project on that GitLab instance from your same local computer.
    If you change to a different GitLab instance or a different local computer, you’ll
    need to repeat the process.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: Now, you need to find the SSH address of the project. Log in to GitLab and navigate
    to the project. We haven’t formally introduced you to the GitLab GUI yet, so the
    instructions and the following screenshot may seem a little mysterious, but they’ll
    make more sense later when you’re more familiar with GitLab components and navigation.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'On the main page for your project, as shown in *Figure 2**.7,* click the **Clone**
    button. In the dropdown that appears, copy the address next to the **Clone with**
    **SSH** label:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Cloning a repository from GitLab](img/B18073_Fig_2.7.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Cloning a repository from GitLab
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you’ve set up a key pair and have the project’s SSH address on your
    clipboard, navigate to the directory on the local filesystem that you want to
    contain the repository, and clone the remote repository to your computer using
    `git clone` and the repository’s SSH address. Your SSH address will look different
    from the one shown here:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The process of cloning defines a remote repository for you: it lets your local
    copy of the repo know that a remote copy exists at whatever URL you cloned it
    from. You can see this remote copy listed in the output of `git` `remote -–verbose`:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here, two remotes have been defined: the first is for getting other people’s
    commits, while the other is for sending your commits. Don’t worry about the distinction
    between these two; you can think of them as a single remote. You’ll also notice
    the word “origin” in the output. The golden copy of any repo is usually referred
    to as the “origin,” for reasons known only to the designers of Git.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: If you created a repository using `git init` instead of `git clone`, you’ll
    need to create a Git project and repository on your GitLab instance to serve as
    the remote repository; then, you can use the `git remote add` command to let your
    local repo know that this remote repo exists. Because this is a much less common
    workflow than using `git clone`, we’ll let you look up the syntax for this command
    if you ever need it.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Pushing
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we’ve used the word “send” to describe the process of copying your local
    commits to the golden repo. But the official Git term is “push.” And the command
    you use to push commits is, unsurprisingly, `git push`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go back to the scenario where you created a branch on your local repository
    called **login-feature**. Imagine that you’ve added a few commits to that branch
    and now, you want to push that branch up to the golden repository on the GitLab
    instance so that your teammates can look at the branch and the commits you made
    to it. To do this, make sure you’re in the branch you want to push, and then push
    it.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we show you the command for that, we should explain that there’s one
    wrinkle whenever you push a branch to a remote repository *for the first time*:
    you must tell the remote repository what to name its copy of your branch. Almost
    always, you will want the remote copy of the branch to have the same name as the
    local copy of the branch. The remote copy of your branch on the golden repo is
    sometimes informally called the “upstream” branch. To tell the remote repo to
    name the upstream branch `login-feature`, change to the branch you want to push,
    and then pass a few extra options to `git push`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Notice that the word `origin` is included in these options. This tells Git which
    remote to push to, even though you only have one remote defined at this point.
    Also, it’s important to understand that you only have to set the upstream branch
    name once. From that point on, you can just run `git push` without any additional
    options to push the commits of your current branch up to the remote golden copy
    of the repo.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Fetching
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, you’ve seen how to push your edits up to the golden repo so that your
    coworkers can see them. But how do you get their edits into your local repo? The
    first command you need to know is `git fetch`. This command talks to the golden
    repo and finds out if anyone has pushed any new branches or commits to existing
    branches up to the golden repo. Then, it relays that information to your local
    repository. *It does not update any branches or files on your local computer*.
    It simply collects metadata about any edits that have been made on the golden
    repo and tells your local repo about them, without making any changes to your
    local repo. This means that `git fetch` is a non-destructive, completely safe
    command that you can run whenever you want, as often as you want.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'This command is useful because it lets you know if your branch is “behind”
    the golden repo’s copy of that branch: is it missing commits that are on the golden
    repo’s copy of the branch? This lets you know if you may experience a merge conflict
    if you try to push your changes up to the golden repo. If someone else has already
    changed the same files on the same branch on the golden repo, there’s no way you
    could know that unless you use `git fetch` to learn about changes that have happened
    there. So, if you’re wondering whether you’ve got all the latest edits on a branch,
    or you want to know if anyone has added any brand-new branches to the golden repo,
    `git fetch` is the way to get that information.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth repeating that `git fetch` gives you up-to-date information about
    the state of branches on the golden repo, but it doesn’t update any files on your
    local computer. To update your local files, you need to learn about one final
    Git command.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: Pulling
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To replace all the files on a local branch with updated versions of those files
    that may exist on the golden repo’s copy of that branch, switch to the appropriate
    branch and then *pull* the changes:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: If any edits have been made to that branch since you last ran `git pull`, Git
    will replace any local files on that branch with updated files from the golden
    repo’s copy of that same branch.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Remember that `git pull` only operates on one branch at a time. That is, it
    will only grab updated files from the golden repo *for the branch that you’re
    currently on*. There’s no way to grab all the edits from all the branches with
    a single use of `git pull`, but there’s also no obvious reason why you’d want
    to.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s combine all the sync-related Git commands into a single workflow, to
    show you how you would keep your copy of the project’s repository in sync with
    the golden copy of the repository:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: On your local computer, use `git switch` to switch to the branch that you want
    to do your work on.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `git fetch` to grab information about whether the golden repo’s copy of
    your branch has any new edits.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `git status` to see if your local branch is “behind” the golden repo’s copy
    of the same branch.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is, update your local files with `git pull`.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make and commit edits to the local copy of the branch.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send all the commits on your local copy of the branch up to the golden copy
    of the branch with `git push`.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Having completed this explanation of syncing repository branches, you’re now
    equipped with all you need to know to do real work with Git! But if you find that
    you need to learn about concepts and commands we haven’t covered here, or if you’d
    like to see these same topics addressed with different explanations and examples,
    there are plenty of other places you can look for more information. Now, let’s
    take a look at some of the best alternative resources.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Additional resources for learning Git
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A word of caution is needed at this point. You’ve only seen the most basic usages
    of the Git commands introduced in this chapter. There are *many* options available
    to change the behavior of these commands, and there are many different wrinkles
    and nuances to using them correctly in different situations. We’ve already mentioned
    that the important concept of resolving merge conflicts is beyond the scope of
    this lightning-fast introduction to Git, but some other important concepts and
    practices are likely to crop up in daily Git usage that we don’t have space to
    cover here, including **rebasing** and choosing between **fast-forward merges**
    and **commit merges**. We also can’t describe common troubleshooting processes
    when you find your files in an unwanted or unfamiliar condition while using Git.
    What we can do, however, is point you to some other resources that you can use
    to continue to expand your knowledge of Git and your repertoire of Git commands
    and practices.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in mind, here are our favorite Git references and learning materials:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: 'GitLab has a very good four-page PDF cheat sheet that covers the most common
    Git concepts and commands. This is the first place we look when we need to remember
    how a basic command works: [https://about.gitlab.com/images/press/git-cheat-sheet.pdf](https://about.gitlab.com/images/press/git-cheat-sheet.pdf).'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ry’s Git Tutorial*, by Ryan Hodson, is a fantastic tutorial for learning Git
    or refreshing your knowledge of its commands and concepts. It’s only available
    as a free Kindle ebook on Amazon.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Pro Git*, by Scott Chacon and Ben Straub, is too dense and dry to use as a
    tutorial, but it is a good reference. It’s where we turn when we need to look
    up an exotic command or find out all the options available for a common command
    such as `git commit`. It’s a free ebook available on the Git website: [https://git-scm.com/book/en/v2](https://git-scm.com/book/en/v2).'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Dangit Git!?!* is a website that shows you how to get out of a dozen or so
    of the most common Git jams. When we’ve made a mistake with Git commands and need
    to fix what we broke, this is where we look for guidance: [https://dangitgit.com/](https://dangitgit.com/).'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that there’s no way you can learn or remember all of Git’s commands
    and options. We believe that it’s best to learn a handful of commands that you
    use every day, and then look up the additional commands and syntax for more complicated
    operations only as the need arises. A reference source such as *Pro Git* or the
    Git man pages will dazzle you with all the different ways you can configure these
    commands to make them work differently, and with all the additional commands that
    Git provides for unlocking the tool’s advanced features. But only wade into those
    waters if you want to; there’s no need to understand all the commands or options
    available to use Git productively. Even if you could somehow learn all of Git,
    the effort required would be far beyond the point of diminishing returns. Get
    comfortable with the concepts and commands presented here, practice with throwaway
    repositories, dip into reference sources as needed, and you’ll be all set to be
    a happy and effective Git user.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pause, take a deep breath, and pat yourself on the back. You’ve learned a lot
    about a complicated tool in a very short time.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: You now understand how and why programmers use VCSs to handle a wide variety
    of daily tasks and problems, and why Git’s features and architecture have helped
    it become the preferred VCS. You also know about the most used Git concepts and
    commands.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve completed this chapter, you can create new Git repositories
    using `git init` and `git clone`; add file edits with `git add` and `git commit`;
    tag commits for future reference with `git tag`; list, create, or delete branches
    with `git branch`; merge branches with `git merge` and resolve any merge conflicts
    that arise; and sync local branches with branches on the golden repo with `git
    push`, `git fetch`, and `get pull`.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: You also know where to look to learn more about Git, whether you need tutorial
    steps, reference material, or troubleshooting help.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: With this background in Git under your belt, it’s time to move from Git to GitLab.
    In the next chapter, you’ll learn how GitLab can make Git easier and more powerful.
    We’ll give you a basic understanding of GitLab’s components and GUI so that we
    can introduce you to the powerful concept of GitLab CI/CD pipelines.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
