- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Practicing Basic Git Commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **GitLab** product is built around a separate tool called **Git**. GitLab
    makes Git easier to use and gives you a central place to store all the files that
    Git is looking after, in addition to providing many other non-Git-related features.
    We like to think of GitLab as a *wrapper* around Git, making it more pleasant
    to use and more powerful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although GitLab and Git are different tools, GitLab borrows many concepts from
    Git. This means that to understand GitLab, you need to understand Git. Fortunately,
    you only need to get to grips with the very basics of Git. We say “fortunately”
    because Git is an enormous and complicated tool and learning all of its nooks
    and crannies would take a huge effort. But trust us: if you understand the first
    10% of Git, you can use GitLab effectively. That 10% is exactly what we’re going
    to introduce you to in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll show you why version control systems such as Git are such a useful
    part of software development. Then, we’ll explain how you can store your code
    in Git, including any edits that you or your team members make to that code. We’ll
    also show you how to develop your code in a safe place called a branch, which
    is isolated from other team members. This ensures that you don’t step on other
    people’s toes and overwrite their code. You’ll learn how to mark a particular
    version of your code so that you can easily refer to it later or release it to
    customers. Finally, you’ll learn about storing code in remote locations. You’ll
    learn how to sync local and remote copies of files, and you’ll understand how
    this architecture enables an entire team to work on a single code base at the
    same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why use Git?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Committing code to keep it safe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tagging commits to identify versions of code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Branching code for developing in an isolated space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Syncing local and remote copies of repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional resources for learning Git
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you need to have Git installed on your local computer. Git
    works on Linux, macOS, and Windows, as well as many Unix variants. There are easy-to-follow
    instructions for installing Git on any of these operating systems at [https://git-scm.com/downloads](https://git-scm.com/downloads).
    If you’re asked to set configuration options during installation, it’s safe to
    accept all the default values.
  prefs: []
  type: TYPE_NORMAL
- en: To type the Git commands that you’ll see in this chapter, use your favorite
    terminal application on Linux or macOS. If you’re a Windows user, you can type
    them in Command Shell, PowerShell, or Git Bash. The default configuration options
    while installing Git on Windows should make Git available on any of these types
    of Windows terminals, and they should all produce identical results when you run
    Git commands in them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Git examples you’ll see in this book are operating system-agnostic: *Git
    works the same no matter where you* *run it*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To see if it’s already installed, or to verify that you installed it correctly,
    open the appropriate terminal for your operating system and run the following
    command. If the output shows a version number instead of an error, Git has been
    installed properly on your computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Don’t worry about seeing a particular version number; virtually any version
    of Git will perform identically for the simple commands we use in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Before using Git, you must tell it your name and email address. This information
    is added to every edit you store in Git so that other team members know which
    edits you are responsible for.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, check if Git is already configured with this information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If the output includes entries for `user.email` and `user.name`, you’re all
    set and can skip the following two commands. Otherwise, let Git know who you are
    by running these two one-time commands, replacing the email address and name with
    your information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'An optional but recommended step is to configure Git to use `main` instead
    of `master` as the name of the default branch in new projects. We haven’t discussed
    what branches are yet, so this may not make much sense. For now, it’s enough for
    you to know that many software companies are shifting to `main` as the name for
    the place where a project’s stable code base lives. You’ll see both terms in use
    in the wild (and even in this book), but if you’d like to configure your computer
    so that new projects use `main`, run the following command once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With all the technical requirements done and dusted, let us begin!
  prefs: []
  type: TYPE_NORMAL
- en: Why use Git?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just like it was helpful to understand how we built software before automation
    tools such as GitLab CI/CD pipelines came along (as discussed in [*Chapter 1*](B18073_01.xhtml#_idTextAnchor013)),
    it’s helpful to know how teams coordinated the complicated process of making edits
    to the same files before Git or similar tools came along.
  prefs: []
  type: TYPE_NORMAL
- en: These tools are designed to solve many problems that developers face, but let’s
    look at just one. Imagine that you and your teammate Elizabeth are working on
    the same code base and both of you want to edit some of the same files. Furthermore,
    imagine that this is a time before the advent of Git or any other **version control
    system** (**VCS**). The only way to write software in this pre-Git era is for
    you to edit a file and then email it, put it on a shared network drive, or copy
    it to a portable disk. Then, you must let Elizabeth know that she’s free to edit
    it. She *checks it out* in some sense (maybe by adding an entry to a spreadsheet
    saying that she’s got control of the file, or maybe through some other mechanism),
    and she retains control of the file for as long as she needs it. If you have new
    ideas and want to edit the file again, you need to ask her to stop editing it
    and transfer it back to you. When she does, you need to scan through the whole
    file to see what changes she’s made, in the hope that they don’t conflict with
    the changes you want to make. Then, you repeat this process for each file the
    two of you are working on, every time either of you wants to edit any of those
    files. You can imagine how slow and cumbersome this process is, and how many chances
    there are to mess something up during all the transfers of ownership!
  prefs: []
  type: TYPE_NORMAL
- en: With this understanding of how things worked in the bad old days, we can look
    at what a VCS is, how it solves this problem, and in what other ways it makes
    developers’ lives easier.
  prefs: []
  type: TYPE_NORMAL
- en: What is a version control system?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A VCS is a tool designed to make it easier for one or more developers to work
    with a set of files. It does this by making snapshots of all the files in your
    project at a particular time and letting you view, compare, and restore files
    in different snapshots.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each VCS has slightly different functionality, but here are some features that
    most offer:'
  prefs: []
  type: TYPE_NORMAL
- en: Provides backups of files in case current versions are lost or accidentally
    overwritten.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shows how a file’s contents have changed over time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shows who made which changes to which files, and when.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Labels certain file snapshots for future reference.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provides a human-readable description of each set of changes so that team members
    can understand why changes were made.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allows developers to edit files in a way that’s compatible with other developers
    editing the same files at the same time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There have been many competing VCSs over the years, both open source and proprietary.
    Some of the best-known examples are Microsoft Visual SourceSafe, CVS, Apache Subversion,
    and now Git. For reasons we’ll explain shortly, Git has largely taken over the
    VCS space and now serves as the default VCS for any team that doesn’t have a company
    mandate to use one of Git’s competitors. In other words, Git has *won* the VCS
    competition, to the extent that such a victory is possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'VCSs work with any computer language. For example, you could use the same VCS
    to manage files in separate Java, Python, and Ruby projects. And although we typically
    think of a VCS as helping you work with source code files in a computer language,
    they can be used with *any* file in a software project, including (but not limited
    to) the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Documentation, such as Markdown or PDF files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration, such as JSON or YAML files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test code and data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metadata or configuration information for your **integrated development** **environment**
    (**IDE**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other project assets, such as pictures, video, or sound files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s no need to limit VCSs to just software projects! You could use Git or
    any VCS to manage the poems in an anthology, recipes in a cookbook, or chapters
    in a novel. VCSs are useful for literally any project that involves files on a
    computer.
  prefs: []
  type: TYPE_NORMAL
- en: What problems does a VCS solve?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that you understand what kinds of features a VCS such as Git offers, your
    mind is probably spinning with all the possible ways a VCS could solve everyday
    problems faced by software developers. Here are just some scenarios, but you can
    no doubt think up more.
  prefs: []
  type: TYPE_NORMAL
- en: Why was this code changed?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may open some source code in your text editor one morning only to discover
    that a method that you’re familiar with now uses an entirely different algorithm.
    Why was it changed? Was the old algorithm broken? Is the new algorithm faster?
    Is the code that implements it shorter or easier to read? By looking at the *commit
    message* of your VCS, you can read a description of why the change was made. Some
    of these messages are more complete than others, depending on how conscientious
    the developer who made the commit was, but you can usually get the general picture
    of what motivated the change.
  prefs: []
  type: TYPE_NORMAL
- en: When was this code changed?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imagine that you revisit a Java class that you haven’t looked at in a few months,
    and notice that it has had some features added and others removed. When did these
    changes take place? More importantly, did they take place before or after the
    last deployment to production? Your VCS’s commit log will tell you each time that
    class was touched, and even what lines were modified each time it was edited.
    That will let you pinpoint which changes were made when so that you know which
    version of the class is being used by customers today.
  prefs: []
  type: TYPE_NORMAL
- en: Who added this buggy code?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Git has a feature called *blame* that tells you which developer edited which
    lines of a file. This is helpful when you discover that some newly added code
    is buggy or slow because you know exactly whom to ask to fix it! But it also has
    a positive use case: if you spot an especially clever piece of code, your VCS
    can let you know whom you should praise and, hopefully, learn from. So, the *blame*
    feature provides a great way to improve professional relationships between developers
    and strengthen team morale.'
  prefs: []
  type: TYPE_NORMAL
- en: I need to restore my copy of Foo.java
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I’m sure *you’ve* never accidentally deleted a file after working on it all
    day, but we sure have. And I’m sure *you* are scrupulous about making backups
    for exactly that sort of event, but we sure aren’t. But since we always use a
    VCS, restoring a lost file is easy: every VCS gives you a simple way to view and
    restore the last version of any file that it manages.'
  prefs: []
  type: TYPE_NORMAL
- en: I want to revert to this morning’s version of all the files in the test directory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You’re not limited to restoring just the last version of a file; you can restore
    *any* version of a file, no matter how old it might be, so long as you added a
    snapshot that includes that version. For example, imagine that you spent hours
    rewriting automated tests to make them run faster, only to discover that your
    new tests are either slower or don’t work at all. Your VCS will let you replace
    just one file, all the files in a directory, or all the files in a project, with
    any old version of those files. Go ahead and edit whatever files you want, as
    often as you want. If you’re careful to regularly check your changes into your
    VCS, you can quit worrying about losing work or reverting to old code if the new
    code doesn’t work out.
  prefs: []
  type: TYPE_NORMAL
- en: A colleague and I want to edit Foo.java at the same time
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Probably the most frequently used feature of VCSs is their ability to safely
    partition the edits you’re making in a file so that they don’t overwrite work
    that other people are doing in the same file. Each developer has a *branch* of
    the code, where they can edit whatever files they want, even if other people are
    editing the same files on their branches. As each developer finishes their work,
    they *merge* their branch into the project’s stable code base. In this way, multiple
    developers can all edit the same file at the same time without anyone losing any
    work or having to coordinate ownership of the file.
  prefs: []
  type: TYPE_NORMAL
- en: I need to deploy last Friday’s version of the code to the production environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: VCSs let you *tag* specific versions of your files so that it’s easy to view
    or restore those versions. For example, you may tag your entire code base before
    undertaking a major refactoring project so that it will be easy to revert to a
    known-good state if the refactoring doesn’t work out. More commonly, development
    teams often tag a specific version of the code so that they know exactly which
    code was deployed with a particular release. For example, you may apply a `version-6-1-0`
    tag to code that you deployed as version 6.1.0 of your product. When someone reports
    a bug in that version of your product, you know which version of your product’s
    files to troubleshoot.
  prefs: []
  type: TYPE_NORMAL
- en: I want all my coworkers to have access to my edited code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you edit a file, your team members must know that you’ve edited it and
    be able to see your edits. VCSs make it easy for you to *push up* your edits to
    a centralized location. Then other team members can *pull down* those changes
    onto their local computers, keeping the entire team in sync.
  prefs: []
  type: TYPE_NORMAL
- en: Why Git is popular
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve already mentioned that Git has become the dominant VCS. Why is that? Different
    Git users would give different explanations for its rise to the top, but here
    are some characteristics that probably helped.
  prefs: []
  type: TYPE_NORMAL
- en: Pedigree
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Git was invented by Linus Torvalds as a tool for storing and managing the source
    code for the Linux kernel. The fact that Git was originally used to store high-profile,
    successful, and widely adopted code such as the Linux kernel no doubt gave it
    instant credibility and cachet: if it’s robust and reliable enough for Linus and
    Linux, it’s good enough for you.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an aside, it’s amazing that one programmer is responsible for launching
    two major software projects: Linux and Git. It’s as if Shakespeare invented the
    pencil just to make his plays easier to write.'
  prefs: []
  type: TYPE_NORMAL
- en: Simple branch management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you’ll learn shortly, branches are one of the most important components of
    any VCS. Git was designed from the beginning to make it simple to create, use,
    and merge branches. The ease with which developers can work with branches encourages
    them to use lots of branches, which promotes safe and rapid development workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Speed
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Git is fast. Adding new files, checking in changes, reverting to old code, and
    syncing files to incorporate coworkers’ edits – these operations all happen in
    just a few seconds, even with large projects. In particular, creating, using,
    and merging branches are all lightning-fast operations, and that’s one of the
    key reasons why developers love working with Git so much.
  prefs: []
  type: TYPE_NORMAL
- en: Reliability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You may think that reliability would be basic table stakes for any VCS: if
    the VCS loses your files or edits, it’s useless at its role. But a surprising
    number of VCSs over the years have been less than 100% reliable. A hundred-person
    development team that one of us worked on in the early 2000s used the dominant
    proprietary VCS of the time, and even though it was thought of as the best-in-breed
    of that sort of tool, it frequently lost or scrambled our edits.'
  prefs: []
  type: TYPE_NORMAL
- en: Git is famously reliable. It’s a complex tool, and if you don’t understand exactly
    how to use its commands, you could inadvertently lose data through human error.
    But it’s virtually unheard of for Git to suffer from technical glitches that result
    in data loss. It’s trusted by countless teams of skeptical software engineers
    around the world, and that trust is well-earned.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed architecture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before Git, many VCSs used a *centralized* architecture. That means that to
    work on a file, you needed to fetch its latest version from a central server,
    make edits, and then resubmit that file to the central server so that other team
    members could access it.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few problems with a centralized architecture. First, some (but not
    all) centralized VCSs *lock* any files that you’ve checked out, so no one else
    can make changes to those files while you’re editing them. This results in a lot
    of “*Hey, are you done with* `Foo.java` *yet?*” conversations in the workplace,
    which creates an awkward, inconvenient, and annoying workflow.
  prefs: []
  type: TYPE_NORMAL
- en: The second problem with using a VCS with a centralized architecture is that
    it requires you to be connected to that central server whenever you need to check
    out a file or check in edits. You can’t work effectively without internet connectivity.
    This is less of a problem than it used to be, but there are still times when you’re
    between hot spots and still want to get work done.
  prefs: []
  type: TYPE_NORMAL
- en: Centralized architectures also create a single point of failure. If the server
    goes down, all the developers are dead in the water. If it loses data or is physically
    destroyed, it could be days before the data is restored or the hardware is rebuilt.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, centralized architectures don’t always scale well as development teams
    grow. Rapidly growing teams that rely on an underpowered VCS server can find their
    work blocked as they queue to access that server.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, the distributed architecture that Git is built around solves all
    these problems. These problems vanish when you have many copies of the project’s
    files on different computers. When using a distributed VCS, each developer has
    a copy of the entire project on their local computer. This includes all the files,
    edit history, tags, commit messages, and other metadata needed to let them work
    on the files without any connection to a central server.
  prefs: []
  type: TYPE_NORMAL
- en: 'How does this strategy help with the problems faced by centralized VCSs? First,
    if every developer has a local copy of all the files in the project, there’s no
    concept of *locking* a file that you’re editing: anyone can edit their local copy
    of any files at any time. Second, there’s no need to contact a central server
    to check out files, and there’s no need to contact a server to check in your edits.
    You can work locally for as long as you want. It’s true that, eventually, you’ll
    need to sync your edits to a server so that your coworkers can see your edits
    (and you can see theirs), but you can do that as often or as infrequently as makes
    sense for your team. Third, since there’s a copy of the entire project’s files
    on every developer’s machine, there’s no longer a single point of failure. If
    the central server that you use to sync changes goes down, you can designate any
    developer’s machine as a temporary central server while you rebuild the original
    server. Finally, because developers who use a distributed VCS sync their code
    with the central server far less often than developers who use a centralized VCS
    to check files in and out of that server, distributed VCSs scale much better than
    their centralized competitors. Most teams who use Git experience no VCS-related
    scaling problems as they add new team members.'
  prefs: []
  type: TYPE_NORMAL
- en: Drawbacks of Git
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Remember how we mentioned that Git gained credibility by being invented by
    Linus Torvalds? Unfortunately, there’s a downside to this: it was designed to
    fit Linus’s mind, not yours. This means that its commands can be inconsistent,
    confusing, and counterintuitive. To give just one example, let’s look at how one
    command uses three different ways to modify its behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '`git branch` lists all available branches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git branch foo` makes a new branch called *foo*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git branch --delete foo` deletes a branch called *foo*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You might expect these commands to be the following instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '`git branch --list` (this does work but isn’t necessary and no one uses it)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git branch --``create foo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`git branch --``delete foo`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But that’s not the case; you must remember the different option syntaxes instead.
    And that’s just for one command.
  prefs: []
  type: TYPE_NORMAL
- en: The other big problem with Git is that it’s so big. It has so many features
    and options and configurable settings that it can seem overwhelming. The official
    reference documentation, a book called *Pro Git*, is 511 pages long! When you’re
    getting started with the tool, it’s easy to get the sense that you’ll never know
    enough about Git’s concepts and commands to be able to use it productively, and
    you may wonder how anyone is ever able to get to grips with something so complicated.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, you don’t need to know all the ins and outs of Git’s inconsistencies
    and syntactical complexities, and you don’t need to know all the features that
    Git provides. You just need to know a handful of common commands and their variants
    to perform 95% of the Git-related tasks you need. Most Git users learn 20 or so
    common operations, commit those to memory over time, and look up the details of
    other Git operations only as needed. *So, don’t panic, and don’t try to learn
    and memorize all of Git.* If you feel comfortable with the simple commands and
    concepts described in this chapter, you’re equipped to do real work with Git.
    It may turn out to be all you’ll ever need from the tool.
  prefs: []
  type: TYPE_NORMAL
- en: That’s enough of an introduction to Git. Now, it’s time to look at some actual
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: Committing code to keep it safe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To benefit from all the advantages described previously, you need to know how
    to add files to Git. How do you do that?
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s discuss the concept of a **repository**, which is often shortened
    to **repo** A repository is a place where Git stores a project’s files and a history
    of all the changes made to those files. It’s the bank vault where it puts files
    to keep them safe.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main ways to create a repository. The first way is to convert
    an ordinary directory on your Linux, macOS, or Windows filesystem into a Git repository.
    This is easy: use the `git init` command from inside the directory, and voilà
    – it turns into a Git repository. Then, you can use the `git status` command to
    prove that it’s a repo.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use those commands to create a new repository for our Hats for Cats project.
    First, make a new directory that will become a repository, and move into that
    directory (the example in this chapter is using a Linux Terminal, so the prompt
    and output may look slightly different if you use another terminal or OS, but
    the concepts will be the same):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Prove that it’s not a Git repo yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Turn the directory into a Git repo with the `git` `init` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, watch how `git status` doesn’t explicitly tell us that we’re in a repo,
    but it does provide information that only makes sense if the directory has been
    turned into a repository. It tells us that we’re on the `main` branch, that Git
    is not tracking any files in the repository, and that we haven’t edited any files
    in this directory that we may want to ask Git to manage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The second, and probably more common, way to create a repository is to copy
    an existing repository from another computer using the `git clone` command. Earlier
    in this chapter, we talked about how Git’s distributed architecture means that
    each team member has a full copy of their project’s Git repository on their computer.
    Cloning is how you download a new copy of that repo from someone else’s computer
    to your computer. We’ll talk about this process in detail later when we discuss
    remote repositories. For now, just understand that if you’re working as a member
    of a software development team, most of the time, you’ll be cloning a repository
    from another computer instead of creating a new repository just on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a repository, let’s add a file to it. For this example, let’s
    add a to-do list. First, use the `touch` command or a text editor to create a
    file called `todo.txt` in the `hats-for-cats/` directory. Fill the file with whatever
    content you want or leave it empty. Git can manage empty files just fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Your directory contains a file, but Git is not tracking that file yet, since
    you haven’t officially added it to the repository. Doing so is a two-step process:'
  prefs: []
  type: TYPE_NORMAL
- en: Move one or more files into something called the *staging area.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Commit* all the files in the staging area.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It’s important to understand that a file is not stored in Git, meaning that
    Git will not manage the versions of that file until *you stage it and then* *commit
    it*.
  prefs: []
  type: TYPE_NORMAL
- en: Remember how we talked about VCSs making “snapshots” of the state of your files
    at a particular time? This stage-and-commit process is how you make a new snapshot
    with Git. This means you are in complete control of when to make snapshots, and
    also of what files are included in each snapshot. If you’re editing `foo.py` and
    `bar.py` but only want to snapshot `foo.py` right now, just add that file to your
    staging area and commit it. When it’s time to make a snapshot with edits to `bar.py`,
    add that file to the staging area, optionally add `foo.py` as well if you want
    to snapshot any edits you made to it since the last time you snapshotted it, and
    then commit the file(s) that is in the staging area.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that we’ve talked about staging and committing both new
    files and edits to existing files. That’s because you use the same stage-and-commit
    process for both cases. You may find it easiest to think of staging and committing
    as something you do to capture *any changes to files*, where changes can take
    four different forms:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing the content of an existing file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Renaming or moving a file (as far as the filesystem is concerned, these are
    the same operation)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No matter which of these operations you perform, when you add one or more files
    to the staging area and then commit, you’re making a new Git snapshot of the state
    of whatever files were in the staging area.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering why the stage-and-commit dance contains two separate
    steps. Couldn’t Git just provide a single command to make a new snapshot of a
    file? The reason for this extra complication is to allow you to include *multiple
    files in a single commit*. For example, you may edit a source code file, edit
    some associated test code that lives in a different file, and finally edit a documentation
    file, all as part of one bug fix. You’d want to include all three of these files
    in a single commit since the edits to all the files logically belong together.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s stage your new `todo.txt` file using the `git add` command. This
    doesn’t move or copy the file anywhere. Rather, it adds an invisible label to
    the file saying that it is in the staging area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you run `git status` again, you’ll see that `todo.txt` is now included in
    a list of *changes to be committed*, which means that it’s been added to the staging
    area but hasn’t been committed yet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can commit it with the `git commit` command. But first, a word about
    commit messages. An important part of every commit is the human-readable commit
    message that the committer must provide. The easiest way to add this message is
    as a parameter to `git commit`, using the `--``message` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If you run `git status` again, you’ll see that no files are waiting to be committed,
    which means your to-do list has been safely stashed in the repository, and all
    future edits to it will be tracked by Git. Congratulations, you’ve just performed
    your first work with Git!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s pause for a minute and talk about what Git includes with every commit.
    You’ve already learned that a commit contains the contents of any file(s) included
    in that commit and a message that describes the purpose of the commit, but there
    are a few other pieces of information it includes as well. Here’s the complete
    list:'
  prefs: []
  type: TYPE_NORMAL
- en: Any changes made to the file’s contents (or the filename or location in the
    filesystem).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A 40-character string of hexadecimal digits that’s called a **Secure Hash Algorithm**
    (**SHA**), which is the code that generates this string based on the contents
    of the committed files. A commit’s SHA uniquely identifies that commit; think
    of it as a unique *name* for that commit. SHAs are not sequential: each SHA is
    completely different from the SHA of the previous commit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The name and email of the person who made the commit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A timestamp of when they made the commit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A human-readable message describing why they made the commit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pointer to the previous commit (or parent commit) on the branch. We’ll introduce
    the concept of branches in the next section and talk about this pointer more then.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `git log` command shows you all this information for all the commits on
    your current branch (again, we’ll explain branches in more detail later). Let’s
    imagine that you’ve made two commits: one to create an empty to-do list and another
    to add an item to that list. Running `git log` gives an output similar to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This output includes information for your two commits, with the most recent
    commit at the top. Can you spot the SHA, author information, timestamps, and commit
    message for each commit? If you’re running these commands on your computer, you’ll
    see different details for each commit, but the format of the output will be the
    same.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, all the commit information is for commits that you’ve made.
    But that’s simply because you’re the only person who has added commits to this
    branch. If other people had made commits to the same branch, you would see information
    for their commits in this output as well.
  prefs: []
  type: TYPE_NORMAL
- en: Excluding files from a repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, you might be thinking that it would be wise to stage and commit
    *all* the files in a project. But there are a few types of files that you usually
    do not want to store in Git or any other VCS. These include, but are not limited
    to, the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Files that are generated from other files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extremely big files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Files that contain secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first category includes files such as executables that are compiled from
    source code, or PDFs that are generated from the source text that’s stored in
    Markdown. Since you can always regenerate these files from their sources, there’s
    no need to store them in Git. Also, putting them in Git introduces the possibility
    of *drift*, where the source files and the generated files are out of sync with
    each other. For example, the source file may contain code from last week, while
    the compiled executable may contain code from last month. This can cause all sorts
    of unexpected problems.
  prefs: []
  type: TYPE_NORMAL
- en: Big files pose a different sort of problem. If you add a 5 GB ISO file or a
    10 GB dataset, then anyone who copies your project’s repository to their local
    machine will be forced to download that file. We mentioned earlier that Git is
    fast, but there’s nothing it can do about congested or slow networks. Since copying
    repositories is a fairly common operation among Git users, including enormous
    files in your repository is something you’d generally like to avoid. It often
    makes more sense to put these files outside of Git, on a shared drive or some
    other accessible data storage system. Removing a large file after you’ve added
    it won’t solve the problem. Because Git keeps a record of the entire edit history
    of every file ever added to the repository, that large file will stick around
    in your repository forever, annoying you and your coworkers every time someone
    copies the repo to their local computer.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, secrets such as deploy keys, SSH private keys, or passwords usually
    should not be stored in Git. As explained in the previous paragraph, any secrets
    that you commit to a repository will be there forever. Unless your IT and Git
    administrators are extremely careful about limiting permissions to repositories,
    this means they can be viewed by anyone with access to your repository. So, these
    sorts of things are normally stored not in Git, but in a specially designed system
    that’s dedicated to keeping sensitive data safe.
  prefs: []
  type: TYPE_NORMAL
- en: This is an important topic, so let’s investigate it further by looking at a
    concrete example. Imagine that your `hats-for-cats/` directory contains a file
    called `personal-notes.txt` and a directory called `.ide-config/`. The former
    is where you store ideas for project features as they occur to you, while the
    latter holds several files that your IDE uses to configure the project on your
    local machine. You may not want to share either of these with the other members
    of your development team since the ideas are meant just for your eyes and the
    configuration files will only work with your computer setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can keep this file and directory private simply by never using the `git
    add` command to add them to your project’s Git repository. That works, but there’s
    a problem with this approach. Whenever you run `git status` to find out if there
    are any edited files that you should add and commit, Git will always point out
    that `personal-notes.txt` and `.ide-config/` are not in the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'There’s a simple solution to this problem: create a new file called `.gitignore`
    in the root of your project’s directory. For the content of this file, add the
    names of any files or directories that you’d like Git to ignore. You can add explanatory
    comments by starting a line with a hash character. The following code in `.gitignore`
    instructs Git to exclude the files we’ve been talking about:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You need to add this `.gitignore` file to the repository, just like any other
    file you want Git to track:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Thanks to `.gitignore`, Git no longer warns you about uncommitted files and
    directories when you run `git status`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It’s not unusual for large projects to end up with tens or even hundreds of
    entries in `.gitignore`, and we encourage you to use this feature to keep your
    Git repository clean and your `git status` output uncluttered.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s review the commands and concepts you’ve learned about in this section
    for keeping code safe by committing it to a Git repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Use `git init` or `git clone` to create a Git repository on your computer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `git add` to add one or more files to Git’s staging area.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `git commit --message "<MESSAGE>"` to make a new Git commit (or snapshot)
    that includes any files that were in the staging area.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `git status` to see if you have edited files waiting to be moved to the
    staging area, or staged files waiting to be committed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `git log` to see information about all the commits that have been made to
    your current branch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a `.gitignore` file to exclude certain files or directories from the repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s learn how to *tag* a particular version of the files that you so
    carefully committed to Git so that you can easily view or revert to that version
    in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Tagging commits to identify versions of code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you understand how and why developers commit code to Git, we can explain
    tagging. Tagging is simple: it’s a way to add a permanent label to a commit. There
    are many reasons to tag, but the two most common are to mark the exact version
    of code that is released to customers and to have a convenient way to return to
    a particular version of the code if you need to revert a large batch of changes.
    Let’s look at an example of each.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that Hats for Cats is ready to release version `git tag` command to
    add a tag representing the version number to the latest commit on your branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you run `git log`, you’ll see that Git has applied the tag to your latest
    commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a separate example, imagine that you decide to undertake a major refactoring
    to change your classes to use a more complicated class inheritance structure.
    You know how easy it is to mess up this kind of large-scale change, and you want
    an easy way to return to today’s version of pre-refactored code in case everything
    goes sideways. Tagging is just the solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Tagging has many options, but two of the most useful are `--delete` and `--list`,
    both of which do exactly what you would expect. Try them and see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: That’s tagging in a nutshell. As with most Git commands, there’s much more you
    can do with tagging, but this covers the basics. Fortunately, you now know as
    much about tagging as most Git users, so don’t worry about exploring `git tag`
    further unless you need more flexibility or features when it comes to marking
    versions of your files.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve now mastered the fundamentals of storing your files in Git for safekeeping,
    excluding files that you don’t want to store in Git, and labeling certain commits
    for easy future reference. Now, it’s time to learn how to edit, store, and label
    files in a way that doesn’t step on the toes of other developers who might be
    working on the same files. It’s time to look at Git branches!
  prefs: []
  type: TYPE_NORMAL
- en: Branching code for developing in an isolated space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After commits, **branches** are probably the most important concept in Git.
    Strictly speaking, you don’t need to know anything about branches and branching
    to use Git. This is especially true if you’re a solo developer. But any non-trivial
    software development effort that involves more than one person will generally
    make heavy use of branches. Let’s figure out what they are and why we need them.
  prefs: []
  type: TYPE_NORMAL
- en: A branch is just a series of ordered commits. Remember when we said that each
    commit includes a backward pointer to the previous commit? If you follow those
    backward pointers from the latest commit back to the first commit ever made to
    the repository, you’ve just described the branch that your commit is on. *Again,
    a branch is just a series of commits, assembled in a particular order, linked
    by* *backward-pointing arrows*.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you’re working on files within a Git repository, you’re *on* exactly
    one branch. This means that you can only see the versions of files that are on
    that branch, and any commits you make will only be added to that branch. Or, more
    technically, any commits you make while on that branch will include a backward-pointing
    arrow that links the commit to the previous commit on that same branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can think of being on a branch as analogous to driving down a street. Imagine
    a town with only two streets. Main Street runs south to north. First Street forks
    off Main Street, runs parallel to it for a few blocks, and then eventually merges
    back into Main Street. Your car must be on exactly one of these two streets at
    any time. To stretch the analogy a little, imagine there’s a helicopter with a
    huge magnet that can pick your car up and move it between Main Street and First
    Street whenever you want. To make the analogy even stranger, pretend there’s a
    child in the back seat of your car who throws marbles out of the open window onto
    the street every block or so. In this analogy, the streets represent *branches*,
    the car represents *a developer*, the marbles represent *commits* that the developer
    adds to whatever branch they’re on, and the helicopter represents a *Git command*
    (which we’ll learn about soon) that lets the developer switch to any branch they
    want, whenever they want:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Streets and marbles, representing branches and commits](img/B18073_Fig_2.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Streets and marbles, representing branches and commits
  prefs: []
  type: TYPE_NORMAL
- en: Every repository has at least one branch, informally referred to as the **default
    branch**. Branches have formal names, and the default branch is almost always
    formally named **main** or **master**, with the former now generally preferred.
  prefs: []
  type: TYPE_NORMAL
- en: 'For reasons explained earlier, drawings of branches usually include arrows
    from each commit to the previous commit on the branch. In other words, the arrows
    point backward in time, from later branches to earlier branches. So, if your repository
    has one branch called **main** with three commits on it (called **A**, **B**,
    and **C**), and another branch called **branch-a** with two commits on it (called
    **D** and **E**), and **branch-a** branched off from **main**, you could draw
    your repository’s state like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Branches and commits](img/B18073_Fig_2.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Branches and commits
  prefs: []
  type: TYPE_NORMAL
- en: 'Why do you need branches? *They let you develop code that is safely isolated
    from the stable code base until it’s ready to be added to that code base*. Here’s
    a typical workflow to demonstrate how this happens:'
  prefs: []
  type: TYPE_NORMAL
- en: Your product code lives in a Git repository. The stable version of that code
    lives in a branch within that repo called **main**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You are assigned to write a feature for your product that lets users log in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You create a branch called **login-feature**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You switch to the **login-feature** branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You edit files and add one or more commits to that branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Other team members review the edits in those commits and give you feedback.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You add another commit that incorporates the feedback.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Your team lead approves your work, declaring that the login feature has been
    implemented properly. Your QA team may also sign off on your work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You *merge* the **login-feature** branch into the **main** branch. This means
    that all the commits you made to the **login-feature** branch are now part of
    the **main** branch as well. Your login feature is now part of the product’s main
    code base.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since the **login-feature** branch has been merged and no longer serves any
    purpose, you can safely delete it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The important thing to notice in this workflow is that while you were developing
    the login feature, your partially complete code was *not* available in the main
    code base (that is, in the **main** branch). Your incomplete code was safely separated
    from your product’s stable code so that your code couldn’t destabilize it. The
    login feature wasn’t added to the main code base until it was formally reviewed,
    approved, and was passing all its tests. That’s what we mean by saying that branches
    let you develop your code in an isolated environment, away from other developers’
    work and away from the stable code base.
  prefs: []
  type: TYPE_NORMAL
- en: This example involved just one developer, but typically, several developers
    will work on separate branches at the same time. For example, two developers might
    be working on branches to add new features (each on their own branches), and two
    other developers might be working on separate branches to fix bugs (each on their
    own branches). One particular developer may switch back and forth between multiple
    branches in a single day, as the focus of their work shifts from one task to another.
    The point is that branches are all separate from each other – when you’re on one
    branch, you can’t see or change code on the other branches until they are all
    eventually merged into the **main** branch.
  prefs: []
  type: TYPE_NORMAL
- en: Git commands for managing branches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s learn the Git commands that you need to follow the workflow described
    previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how to create a new branch called `login-feature`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This command shows a list of all the branches that exist in this repository,
    with an asterisk next to the branch that you’re currently on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'There are two different commands you can use to switch to a different branch.
    They do the same thing, and you’ll see both in use. In this case, they switch
    you to the`login-feature` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'It takes two commands to merge one branch (called the *source branch*) into
    another branch (called the *target branch*) so that all the commits on the source
    branch become part of the target branch. To merge all the commits that are in
    `login-feature` into `main`, first, make sure you are on the *target* branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, perform the merge while specifying the *source* branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Some organizations like to keep all branches around forever as a matter of
    historical record, but most organizations ask you to delete a branch once you’ve
    merged it into `main`. Here’s how to delete the `login-feature` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If you haven’t merged a branch before you try to delete it, Git will warn you
    and will *not* delete that branch. You can force the branch to be deleted (for
    example, if you’ve created an experimental branch and want to delete it without
    merging), like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Handling merge conflicts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you try to merge one branch into another, you will sometimes run into what’s
    called a *merge conflict*. This means that someone else has edited the same lines
    of the same file that you have, and that they’ve already merged their branch into
    `main` before you got a chance to merge your branch into `main`. When you try
    to merge your branch, Git isn’t sure whether to keep the edits made by the other
    developer or the edits that you’re trying to merge.
  prefs: []
  type: TYPE_NORMAL
- en: 'To continue with your merge, you first need to resolve the merge conflict.
    There are several ways to do this. Many people find dedicated Git GUI tools such
    as Sourcetree (macOS and Windows) or Sublime Merge (Linux, macOS, and Windows)
    to be the easiest and most intuitive way to handle merge conflicts. Other people
    prefer to resolve merge conflicts manually, using Git terminal commands and a
    text editor. GitLab users have another option: you can use GitLab’s built-in graphical
    merge conflict resolution tool. Regardless of what approach you take, you’ll have
    to somehow tell Git which changes to accept, which changes to throw away, and
    when to continue with the merge.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how the GitLab merge conflict resolution tool works. Imagine that
    you’re working on the `login.py` file on the `new-login-message` branch. After
    creating a merge request for that branch and committing some edits, you return
    to the merge request so that you can merge the branch, only to discover that the
    MR is blocked by a merge conflict:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Merge request blocked by a merge conflict](img/B18073_Fig_2.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Merge request blocked by a merge conflict
  prefs: []
  type: TYPE_NORMAL
- en: Since you only edited one file, you know that someone else must have edited
    the same lines of the same file and merged their edits into the `main` branch
    before you had a chance to do so yourself. Now, Git is understandably confused
    about whether to accept your edits, their edits, or some hybrid. Until that gets
    straightened out, it can’t merge your `new-login-message` branch into `main`.
  prefs: []
  type: TYPE_NORMAL
- en: 'GitLab gives you two options to proceed: you can either click **Resolve conflicts**
    to use the built-in GUI tool to resolve the merge conflict, or you can click **Resolve
    locally** to manually instruct Git on how to handle the merge by editing files
    on your computer’s copy of the repository and then pushing those edits back up
    to GitLab. The second of these strategies is beyond the scope of this book, so
    let’s focus on the first strategy: using GitLab to resolve the merge conflict.
    Note that this option only appears in the GUI during simple merge conflicts such
    as the one in this example. If you need to resort to complicated edits to combine
    parts of two separate commits, you will probably need to resolve the merge conflict
    locally and then push the resolution back up to GitLab.'
  prefs: []
  type: TYPE_NORMAL
- en: In this example, you will want to use GitLab’s built-in merge conflict tool,
    so you must click **Resolve conflicts**. You will be taken to a page that shows
    which lines have conflicting edits. You will see that there’s only one line with
    conflicting edits, with your edit highlighted in green and the edit already made
    by someone else highlighted in blue. Let’s say you’ve changed the line “We’re
    glad you’re here” to “We’re really glad you’re here,” whereas the existing edit
    changes the same line to “We’re super glad you’re here!”.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Resolving a merge conflict within GitLab](img/B18073_Fig_2.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Resolving a merge conflict within GitLab
  prefs: []
  type: TYPE_NORMAL
- en: You decide that you like your edit better, so you click the `new-login-message`
    branch that resolves the merge conflict. This new commit triggers a pipeline run
    on your branch. Once that finishes, you’re free to merge the MR just like you
    normally would. Congratulations – the merge conflict has been successfully resolved
    and the merge is complete!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Merge conflict is resolved and MR is unblocked](img/B18073_Fig_2.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Merge conflict is resolved and MR is unblocked
  prefs: []
  type: TYPE_NORMAL
- en: 'It would be irresponsible to pretend that all merge conflicts are as straightforward
    to resolve as this example, but the general approach remains the same no matter
    how complicated things get: you tell GitLab which edits to keep, which edits to
    throw away, and how to combine edits when you want to mix and match edits on the
    same line of code or text. Many third-party, GUI-based Git tools have more powerful
    merge conflict resolution tools than GitLab offers, so don’t be afraid to try
    a different tool for this task if you find you need more firepower or just a different
    view of what’s going on.'
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our explanation of creating, committing to, and merging branches.
    We hope you now have an idea of why branches are one of Git’s most essential and
    popular features! But branches become even more powerful when you share them with
    other developers on your team, and when you can get access to branches that they’ve
    been working on. In the next section, you’ll learn how to work collaboratively
    with branches.
  prefs: []
  type: TYPE_NORMAL
- en: Syncing local and remote copies of repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Git can be a useful tool for solo developers, but it’s most often used within
    a team of developers. As we’ve already discussed, Git’s distributed architecture
    means that every developer on the team has a complete copy of the project’s repository,
    including all its commits, commit messages, branches, and all the other data and
    metadata that is included in a repository. Keeping these repositories synced,
    so that they all have the same information in them, is critically important. If
    my copy of the repository and your copy of the repository contain different files
    or different edits to the same files, then I can’t see what work you’ve done and
    vice versa. And if my copy of the repository doesn’t contain the branches that
    you’re adding commits to, I can’t review and approve your work. Synchronizing
    repositories isn’t an automatic process: it involves active participation by the
    developers. This section will explain how to do this.'
  prefs: []
  type: TYPE_NORMAL
- en: The “golden” repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before showing you the commands for syncing repositories, we need to partially
    retract something we said earlier. Remember how we explained that one of the advantages
    of Git’s distributed architecture is that there’s no central server that all developers
    need to talk to when doing their work? That’s not strictly true. Git’s distributed
    architecture does require every developer to have a complete copy of the project’s
    repository, but the team needs to designate one of those repository copies as
    what we’ll call the **golden** repository. That’s the repository that is considered
    to contain the *latest version of the stable code base* and is the repository
    where your team releases software. I might be working on a feature on a branch
    on my computer, and you might be working on a bug fix on a branch on your computer,
    and we might have completed all of the edits needed to finish those tasks, but
    until we put our edits into the golden repository, they aren’t officially part
    of the project’s stable code base. Because of the special role that this golden
    repository has, I tend to think of it as a “first among equals” or the “repository
    of record.”
  prefs: []
  type: TYPE_NORMAL
- en: '*The golden repository is the copy of the repository that lives on the GitLab
    instance*. If your team of 20 developers uses GitLab, there will be at least 21
    copies of your project’s repository: one on each developer’s computer and the
    golden copy on the GitLab instance. If the computer that hosts your GitLab instance
    is unavailable for some reason, you could temporarily designate the repository
    that’s on any developer’s computer as the team’s golden repository. But you would
    want to revert to using the GitLab instance’s copy as the golden repository as
    soon as it’s available again.'
  prefs: []
  type: TYPE_NORMAL
- en: When we talk about syncing edits between different copies of the repository,
    this syncing always happens via the GitLab instance. In other words, if I’ve made
    commits to the repository on my local computer and want to make them available
    to my coworkers, I would *not* send those commits directly to each of their computers.
    Instead, I would send my commits to the golden repository, and then each developer
    would retrieve my commits from the golden repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows a workflow that allows one developer to share their
    commits with another developer by pushing and pulling the branch that contains
    those commits to and from the golden repo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Sharing commits with coworkers via the golden repo](img/B18073_Fig_2.6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – Sharing commits with coworkers via the golden repo
  prefs: []
  type: TYPE_NORMAL
- en: Configuring remote repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before you can sync your repository with the golden repository, Git needs to
    know that the golden repository exists. Any repository copy that’s not on your
    local computer is called a “remote,” so an important prerequisite for syncing
    commits is to configure remotes.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the following command to see a list of the names and URLs for any
    remotes that Git knows about:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Earlier, we described two ways to get a repository onto your computer: `git
    init` and `git clone`. If you’re in a repository that you created with `git init`,
    and you ask Git to give you a list of remotes, it will return no output. It doesn’t
    know about any remotes yet, because you haven’t told it about any. But if you
    copied a repository to your machine using `git clone`, then Git already knows
    about one remote: the copy of the repository that you cloned from.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we get ahead of ourselves, let’s discuss how to clone a repository. As
    we mentioned previously, that’s the most common way to get a repository onto your
    computer, so it’s an important practice to be familiar with.
  prefs: []
  type: TYPE_NORMAL
- en: You can clone a repository from a computer that your local computer has network
    access to, but let’s concentrate on cloning a repository that’s hosted on a GitLab
    instance. This example assumes that the repository is hosted by the instance of
    GitLab that lives at [www.gitlab.com](https://www.gitlab.com). If you’re using
    a self-hosted version of GitLab instead of the **Software-as-a-Service** (**SaaS**)
    version that we’re using in this example, the cloning process is the same, except
    that the address of the repository you’re cloning will look slightly different.
  prefs: []
  type: TYPE_NORMAL
- en: 'To clone a GitLab-hosted repository, you need to know the address of that repository.
    There are several forms this address can take, but the two most common forms use
    the **HTTPS** protocol or the **SSH** protocol. Although either protocol will
    work, using the SSH protocol is generally preferred. It requires you to configure
    SSH keys to get started, but then you never need to enter credentials when interacting
    with that remote: the key infrastructure takes care of all authentications automatically.
    The HTTPS protocol, on the other hand, requires you to enter a username and password
    every time you use a Git command that talks to that remote.'
  prefs: []
  type: TYPE_NORMAL
- en: You’ve already seen how to create a repository for our Hats for Cats project
    using `git init`, but now, let’s change gears and assume that there’s already
    a Hats for Cats repository on a GitLab instance, and you want to clone that repository
    to your computer.
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to create public and private SSH keys using the `ssh-keygen`
    command in your computer’s terminal, and then upload the public key to your GitLab
    instance. GitLab has excellent documentation on how to do this that’s available
    at [https://docs.gitlab.com/ee/ssh](https://docs.gitlab.com/ee/ssh), so we’ll
    refer you to that instead of rehashing the instructions here. Note that you only
    have to do this process once, and then you’ll be authenticated whenever you’re
    interacting with any project on that GitLab instance from your same local computer.
    If you change to a different GitLab instance or a different local computer, you’ll
    need to repeat the process.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you need to find the SSH address of the project. Log in to GitLab and navigate
    to the project. We haven’t formally introduced you to the GitLab GUI yet, so the
    instructions and the following screenshot may seem a little mysterious, but they’ll
    make more sense later when you’re more familiar with GitLab components and navigation.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the main page for your project, as shown in *Figure 2**.7,* click the **Clone**
    button. In the dropdown that appears, copy the address next to the **Clone with**
    **SSH** label:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Cloning a repository from GitLab](img/B18073_Fig_2.7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Cloning a repository from GitLab
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you’ve set up a key pair and have the project’s SSH address on your
    clipboard, navigate to the directory on the local filesystem that you want to
    contain the repository, and clone the remote repository to your computer using
    `git clone` and the repository’s SSH address. Your SSH address will look different
    from the one shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The process of cloning defines a remote repository for you: it lets your local
    copy of the repo know that a remote copy exists at whatever URL you cloned it
    from. You can see this remote copy listed in the output of `git` `remote -–verbose`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, two remotes have been defined: the first is for getting other people’s
    commits, while the other is for sending your commits. Don’t worry about the distinction
    between these two; you can think of them as a single remote. You’ll also notice
    the word “origin” in the output. The golden copy of any repo is usually referred
    to as the “origin,” for reasons known only to the designers of Git.'
  prefs: []
  type: TYPE_NORMAL
- en: If you created a repository using `git init` instead of `git clone`, you’ll
    need to create a Git project and repository on your GitLab instance to serve as
    the remote repository; then, you can use the `git remote add` command to let your
    local repo know that this remote repo exists. Because this is a much less common
    workflow than using `git clone`, we’ll let you look up the syntax for this command
    if you ever need it.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we’ve used the word “send” to describe the process of copying your local
    commits to the golden repo. But the official Git term is “push.” And the command
    you use to push commits is, unsurprisingly, `git push`.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go back to the scenario where you created a branch on your local repository
    called **login-feature**. Imagine that you’ve added a few commits to that branch
    and now, you want to push that branch up to the golden repository on the GitLab
    instance so that your teammates can look at the branch and the commits you made
    to it. To do this, make sure you’re in the branch you want to push, and then push
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we show you the command for that, we should explain that there’s one
    wrinkle whenever you push a branch to a remote repository *for the first time*:
    you must tell the remote repository what to name its copy of your branch. Almost
    always, you will want the remote copy of the branch to have the same name as the
    local copy of the branch. The remote copy of your branch on the golden repo is
    sometimes informally called the “upstream” branch. To tell the remote repo to
    name the upstream branch `login-feature`, change to the branch you want to push,
    and then pass a few extra options to `git push`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the word `origin` is included in these options. This tells Git which
    remote to push to, even though you only have one remote defined at this point.
    Also, it’s important to understand that you only have to set the upstream branch
    name once. From that point on, you can just run `git push` without any additional
    options to push the commits of your current branch up to the remote golden copy
    of the repo.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, you’ve seen how to push your edits up to the golden repo so that your
    coworkers can see them. But how do you get their edits into your local repo? The
    first command you need to know is `git fetch`. This command talks to the golden
    repo and finds out if anyone has pushed any new branches or commits to existing
    branches up to the golden repo. Then, it relays that information to your local
    repository. *It does not update any branches or files on your local computer*.
    It simply collects metadata about any edits that have been made on the golden
    repo and tells your local repo about them, without making any changes to your
    local repo. This means that `git fetch` is a non-destructive, completely safe
    command that you can run whenever you want, as often as you want.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command is useful because it lets you know if your branch is “behind”
    the golden repo’s copy of that branch: is it missing commits that are on the golden
    repo’s copy of the branch? This lets you know if you may experience a merge conflict
    if you try to push your changes up to the golden repo. If someone else has already
    changed the same files on the same branch on the golden repo, there’s no way you
    could know that unless you use `git fetch` to learn about changes that have happened
    there. So, if you’re wondering whether you’ve got all the latest edits on a branch,
    or you want to know if anyone has added any brand-new branches to the golden repo,
    `git fetch` is the way to get that information.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth repeating that `git fetch` gives you up-to-date information about
    the state of branches on the golden repo, but it doesn’t update any files on your
    local computer. To update your local files, you need to learn about one final
    Git command.
  prefs: []
  type: TYPE_NORMAL
- en: Pulling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To replace all the files on a local branch with updated versions of those files
    that may exist on the golden repo’s copy of that branch, switch to the appropriate
    branch and then *pull* the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If any edits have been made to that branch since you last ran `git pull`, Git
    will replace any local files on that branch with updated files from the golden
    repo’s copy of that same branch.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that `git pull` only operates on one branch at a time. That is, it
    will only grab updated files from the golden repo *for the branch that you’re
    currently on*. There’s no way to grab all the edits from all the branches with
    a single use of `git pull`, but there’s also no obvious reason why you’d want
    to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s combine all the sync-related Git commands into a single workflow, to
    show you how you would keep your copy of the project’s repository in sync with
    the golden copy of the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: On your local computer, use `git switch` to switch to the branch that you want
    to do your work on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `git fetch` to grab information about whether the golden repo’s copy of
    your branch has any new edits.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run `git status` to see if your local branch is “behind” the golden repo’s copy
    of the same branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it is, update your local files with `git pull`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make and commit edits to the local copy of the branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send all the commits on your local copy of the branch up to the golden copy
    of the branch with `git push`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Having completed this explanation of syncing repository branches, you’re now
    equipped with all you need to know to do real work with Git! But if you find that
    you need to learn about concepts and commands we haven’t covered here, or if you’d
    like to see these same topics addressed with different explanations and examples,
    there are plenty of other places you can look for more information. Now, let’s
    take a look at some of the best alternative resources.
  prefs: []
  type: TYPE_NORMAL
- en: Additional resources for learning Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A word of caution is needed at this point. You’ve only seen the most basic usages
    of the Git commands introduced in this chapter. There are *many* options available
    to change the behavior of these commands, and there are many different wrinkles
    and nuances to using them correctly in different situations. We’ve already mentioned
    that the important concept of resolving merge conflicts is beyond the scope of
    this lightning-fast introduction to Git, but some other important concepts and
    practices are likely to crop up in daily Git usage that we don’t have space to
    cover here, including **rebasing** and choosing between **fast-forward merges**
    and **commit merges**. We also can’t describe common troubleshooting processes
    when you find your files in an unwanted or unfamiliar condition while using Git.
    What we can do, however, is point you to some other resources that you can use
    to continue to expand your knowledge of Git and your repertoire of Git commands
    and practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that in mind, here are our favorite Git references and learning materials:'
  prefs: []
  type: TYPE_NORMAL
- en: 'GitLab has a very good four-page PDF cheat sheet that covers the most common
    Git concepts and commands. This is the first place we look when we need to remember
    how a basic command works: [https://about.gitlab.com/images/press/git-cheat-sheet.pdf](https://about.gitlab.com/images/press/git-cheat-sheet.pdf).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ry’s Git Tutorial*, by Ryan Hodson, is a fantastic tutorial for learning Git
    or refreshing your knowledge of its commands and concepts. It’s only available
    as a free Kindle ebook on Amazon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Pro Git*, by Scott Chacon and Ben Straub, is too dense and dry to use as a
    tutorial, but it is a good reference. It’s where we turn when we need to look
    up an exotic command or find out all the options available for a common command
    such as `git commit`. It’s a free ebook available on the Git website: [https://git-scm.com/book/en/v2](https://git-scm.com/book/en/v2).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Dangit Git!?!* is a website that shows you how to get out of a dozen or so
    of the most common Git jams. When we’ve made a mistake with Git commands and need
    to fix what we broke, this is where we look for guidance: [https://dangitgit.com/](https://dangitgit.com/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember that there’s no way you can learn or remember all of Git’s commands
    and options. We believe that it’s best to learn a handful of commands that you
    use every day, and then look up the additional commands and syntax for more complicated
    operations only as the need arises. A reference source such as *Pro Git* or the
    Git man pages will dazzle you with all the different ways you can configure these
    commands to make them work differently, and with all the additional commands that
    Git provides for unlocking the tool’s advanced features. But only wade into those
    waters if you want to; there’s no need to understand all the commands or options
    available to use Git productively. Even if you could somehow learn all of Git,
    the effort required would be far beyond the point of diminishing returns. Get
    comfortable with the concepts and commands presented here, practice with throwaway
    repositories, dip into reference sources as needed, and you’ll be all set to be
    a happy and effective Git user.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pause, take a deep breath, and pat yourself on the back. You’ve learned a lot
    about a complicated tool in a very short time.
  prefs: []
  type: TYPE_NORMAL
- en: You now understand how and why programmers use VCSs to handle a wide variety
    of daily tasks and problems, and why Git’s features and architecture have helped
    it become the preferred VCS. You also know about the most used Git concepts and
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve completed this chapter, you can create new Git repositories
    using `git init` and `git clone`; add file edits with `git add` and `git commit`;
    tag commits for future reference with `git tag`; list, create, or delete branches
    with `git branch`; merge branches with `git merge` and resolve any merge conflicts
    that arise; and sync local branches with branches on the golden repo with `git
    push`, `git fetch`, and `get pull`.
  prefs: []
  type: TYPE_NORMAL
- en: You also know where to look to learn more about Git, whether you need tutorial
    steps, reference material, or troubleshooting help.
  prefs: []
  type: TYPE_NORMAL
- en: With this background in Git under your belt, it’s time to move from Git to GitLab.
    In the next chapter, you’ll learn how GitLab can make Git easier and more powerful.
    We’ll give you a basic understanding of GitLab’s components and GUI so that we
    can introduce you to the powerful concept of GitLab CI/CD pipelines.
  prefs: []
  type: TYPE_NORMAL
