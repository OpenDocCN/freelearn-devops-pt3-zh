["```\n// Package main is the entrance point for our binary.\n// The double slashes provides a comment until the end of the line.\n/*\nThis is a comment that lasts until the closing star slash.\n*/\npackage main\n```", "```\nmypackage/\n  file1.go\n  file2.go\n```", "```\npackage mypackage\n```", "```\n\"fmt\"\n\"encoding/json\"\n\"archive/zip\"\n```", "```\n\"github.com/johnsiilver/golib/lru\"\n\"github.com/kylelemons/godebug/pretty\"\n```", "```\npackage main\nimport (\n     \"fmt\"\n     \"github.com/devopsforgo/mypackage\"\n)\n```", "```\nfmt.Println(\"Hello!\")\n```", "```\nimport(\n     \"github.com/devopsforgo/mypackage\"\n     jpackage \"github.com/johnsiilver/mypackage\"\n)\n```", "```\nmypackage.Print()\njpackage.Send()\n```", "```\npackage main\nimport (\n     \"fmt\"\n     \"sync\"\n)\nfunc main() {\n     fmt.Println(\"Hello, playground\")\n}\n```", "```\n./prog.go:5:2: imported and not used: \"sync\"\n```", "```\npackage main\nimport (\n     \"fmt\"\n     _ \"sync\" //Just an example \n)\nfunc main() {\n     fmt.Println(\"Hello, playground\")\n}\n```", "```\n1 package main\n2 \n3 import \"fmt\"\n4\n5 func main() {\n6    hello := \"Hello World!\" fmt.Println(hello) \n7          \n8 }\n```", "```\nv = \"hello\"\nv = 8\nv = 2.5\n```", "```\nv := \"hello\" // also can do: var v string = \"hello\"\n```", "```\ndef add(a, b):\n     return a+b\n```", "```\nfunc add(a int, b int) int {\n     return a + b\n}\n```", "```\nvar i int64\n```", "```\nvar i int = 3\n```", "```\nvar (\n     i int\n     word = \"hello\"\n)\n```", "```\ni := 1                       // i is the int type \nword := \"hello\"              // word is the string type \nf := 3.2                     // f is the float64 type \n```", "```\npackage main\nimport \"fmt\"\nvar word = \"hello\"\nfunc main() {\n\tfmt.Println(word)\n}\n```", "```\npackage main\nimport \"fmt\"\nfunc main() {\n\tvar word string = \"hello\"\n\tfmt.Println(word)\n}\n```", "```\npackage main\nimport \"fmt\"\nfunc main() {\n\tfor i := 0; i < 10; i++ {\n\t\tfmt.Println(i)\n\t}\n}\n```", "```\nfunc main() {\n     var word = \"hello\"\n     var word = \"world\"\n     fmt.Println(word)\n}\n```", "```\nfunc main() {\n     var word = \"hello\"\n     word = \"world\"\n     fmt.Println(word)\n}\n```", "```\npackage main\nimport \"fmt\"\nvar word = \"hello\"\nfunc main() {\n\tvar word = \"world\"\n\tfmt.Println(\"inside main(): \", word)\n\tprintOutter()\n}\nfunc printOutter() {\n\tfmt.Println(\"the package level 'word' var: \", word)\n}\n```", "```\ninside main():  world\nthe package level 'word' var:  hello\n```", "```\n_ = someVar\n```", "```\n_ = someFunc()\n```", "```\nneeded, _ := someFunc()\n```", "```\nfor i := 0; i < 10; i++ {\n     fmt.Println(i)\n}\n```", "```\nvar i int\nfor ;i < 10;i++ {\n     fmt.Println(i)\n}\nfmt.Println(\"i's final value: \", i)\n```", "```\nvar i int\nfor i < 10 {\n     i++\n}\nb := true\nfor b { // This will loop forever\n     fmt.Println(\"hello\")\n}\n```", "```\nfor {\n     fmt.Println(\"Hello World\")\n}\n```", "```\nfor {\n     if err := doSomething(); err != nil {\n          break\n     }\n     fmt.Println(\"keep going\")\n}\n```", "```\nfor i := 0; i < 10; i++ {\n     if i % 2 == 0 { // Only 0 for even numbers\n           continue\n     }\n     fmt.Println(\"Odd number: \", i)\n}\n```", "```\nfor {\n     fmt.Println(\"hello world\")\n}\n```", "```\nfor\n{\n     fmt.Println(\"hello world\")\n}\n```", "```\nif [expression that evaluates to boolean] {\n     ...\n} \n```", "```\nif x > 2 { \n    fmt.Println(\"x is greater than 2\") \n}\n```", "```\nif [init statement];[statement that evaluates to boolean] {\n     ...\n}\n```", "```\nif err := someFunction(); err != nil { \n    fmt.Println(err) \n}\n```", "```\nif condition {\n     function1()\n}else {\n     function2()\n}\n```", "```\nif v, err := someFunc(); err != nil {\n     return err\n}else{\n     fmt.Println(v)\n     return nil\n}\n```", "```\nv, err := someFunc()\nif err != nil {\n     return err \n}\nfmt.Println(v)\nreturn nil\n```", "```\nif x > 0 {\n     fmt.Println(\"x is greater than 0\")\n} else if x < 0 {\n     fmt.Println(\"x is less than 0\")\n} else{\n     fmt.Println(\"x is equal to 0\")\n}\n```", "```\nif x > 0 \n{ // This must go up on the previous line\n     fmt.Println(\"hello\")\n}\nelse { // This line must start on the previous line\n     fmt.Println(\"world\")\n}\n```", "```\nswitch [value] {\ncase [match]:\n     [statement]\ncase [match], [match]:\n     [statement]\ndefault:\n     [statement]\n}\n```", "```\nswitch x {\ncase 3:\n     fmt.Println(\"x is 3\")\ncase 4, 5:  // executes if x is 4 or 5\n     fmt.Println(\"x is 4 or 5\")\ndefault:\n     fmt.Println(\"x is unknown\")\n}\n```", "```\nswitch x := someFunc(); x {\ncase 3:\n     fmt.Println(\"x is 3\")\n} \n```", "```\nswitch {\ncase x > 0:\n     fmt.Println(\"x is greater than 0\")\ncase x < 0:\n     fmt.Println(\"x is less than 0\")\ndefault:\n     fmt.Println(\"x must be 0\")\n}\n```", "```\nfunc functionName([varName] [varType], ...) ([return value], [return value], ...){\n}\n```", "```\nfunc add(x int, y int) int {\n     return x + y\n}\n```", "```\nresult := add(2, 2)\nfmt.Println(result)\n```", "```\nfunc add(x, y int) int {\n     return x + y\n}\n```", "```\nfunc divide(num, div int) (res, rem int) {\n\tresult = num / div\n\tremainder = num % div\n\treturn res, rem\n}\n```", "```\nresult, remainder := divide(3, 2)\nfmt.Printf(\"Result: %d, Remainder %d\", result, remainder)\n```", "```\nfunc sum(numbers []int) int {\n     sum := 0\n     for _, n := range numbers {\n          sum += n\n     }\n     return sum\n}\n```", "```\nargs := []int{1,2,3,4,5}\nfmt.Println(sum(args))\n```", "```\nfunc sum(numbers ...int) int {\n     // Same code\n}\n```", "```\nfmt.Println(sum(1,2,3,4,5))\n```", "```\nfunc main() {\n     result := func(word1, word2 string) string {\n          return word1 + \" \" + word2\n     }(\"hello\", \"world\")\n     fmt.Println(result)\n}\n```", "```\npackage say\nimport \"fmt\"\nfunc PrintHello() {\n\tfmt.Println(\"Hello\")\n}\nfunc printWorld() {\n\tfmt.Println(\"World\")\n}\nfunc PrintHelloWorld() {\n\tPrintHello()\n\tprintWorld()\n}\n```", "```\npackage main\nimport \"github.com/repo/examples/say\"\nfunc main() {\n\tsay.PrintHello()\n\tsay.PrintHelloWorld()\n}\n```", "```\n$ go run main.go\nHello\nHello\nWorld\n```", "```\n./main.go:8:2: cannot refer to unexported name say.printWorld\n```", "```\nfunc changeValueAtZeroIndex(array [2]int) {\n     array[0] = 3\n     fmt.Println(\"inside: \", array[0]) // Will print 3\n}\nfunc main() {\n     x := [2]int{}\n     changeValueAtZeroIndex(x)\n     fmt.Println(x) // Will print 0\n}\n```", "```\nfunc doAppend(sl []int) {\n     sl = append(sl, 100)\n     fmt.Println(\"inside: \", sl) // inside:  [1 2 3 100]\n}\nfunc main() { \n     x := []int{1, 2, 3}\n     doAppend(x)\n     fmt.Println(\"outside: \", x) // outside:  [1 2 3]\n}\n```", "```\nfunc doAppend(sl []int) []int {\n     return append(sl, 100)\n}\nfunc main() {\n     x := []int{1, 2, 3}\n     x = doAppend(x)\n     fmt.Println(\"outside: \", x) // outside:  [1 2 3 100]\n}\n```", "```\nfor i := 0; i < len(someSlice); i++{\n     fmt.Printf(\"slice entry %d: %s\\n\", i, someSlice[i])\n}\n```", "```\nfor index, val := range someSlice {\n     fmt.Printf(\"slice entry %d: %s\\n\", index, val)\n}\n```", "```\nindex declared but not used\n```", "```\nfor _, val := range someSlice {\n     fmt.Printf(\"slice entry: %s\\n\", val)\n}\n```", "```\nvar counters = make(map[string]int, 10)\n```", "```\nmodelToMake := map[string]string{\n     \"prius\": \"toyota\",\n     \"chevelle\": \"chevy\",\n}\n```", "```\ncarMake := modelToMake[\"chevelle\"]\nfmt.Println(carMake) // Prints \"chevy\"\n```", "```\ncarMake := modelToMake[\"outback\"]\nfmt.Println(carMake)\n```", "```\nif carMake, ok := modelToMake[\"outback\"]; ok {\n     fmt.Printf(\"car model \\\"outback\\\" has make %q\", carMake)\n}else{\n     fmt.Printf(\"car model \\\"outback\\\" has an unknown make\")\n}\n```", "```\nmodelToMake[\"outback\"] = \"subaru\"\ncounters[\"pageHits\"] = 10\n```", "```\nfor key, val := range modelToMake {\n     fmt.Printf(\"car model %q has make %q\\n\", key, val)\n}\n```", "```\ncar model \"prius\" has make \"toyota\"\ncar model \"chevelle\" has make \"chevy\"\ncar model \"outback\" has make \"subaru\"\n```", "```\nfmt.Println(&x)\n```", "```\nfunc changeValue(word string) {\n     word += \"world\" \n}\n```", "```\nfunc main() {\n     say := \"hello\"\n     changeValue(say)\n     fmt.Println(say)\n}\n```", "```\nvar intPtr *int\n```", "```\nintPtr = &x\nintPtr now stores 0xc000122020\\. \n```", "```\nfmt.Println(x)             // Will print 23 \nfmt.Println(*intPtr)       // Will print 23, the value at x \n*intPtr = 80               // Changes the value at x to 80 \nfmt.Println(x)             // Will print 80 \n```", "```\nfunc changeValue(word *string) {\n     // Add \"world\" to the string pointed to by 'word'\n     *word += \"world\"\n}\nfunc main() {\n     say := \"hello\"\n     changeValue(&say) // Pass a pointer\n     fmt.Println(say) // Prints \"helloworld\"\n}\n```", "```\nvar record = struct{\n     Name string\n     Age int\n}{\n     Name: \"John Doak\",\n     Age: 100, // Yeah, not publishing the real one\n}\n```", "```\nfmt.Printf(\"%s is %d years old\\n\", record.Name, record.Age)\n```", "```\ntype CarModel string\n```", "```\nvar myCar CarModel = \"Chevelle\"\n```", "```\nmyCar = CarModel(\"Chevelle\") \n```", "```\nmyCarAsString := string(myCar)\n```", "```\ntype Record struct{\n     Name string\n     Age int\n}\nfunc main() {\n     david := Record{Name: \"David Justice\", Age: 28}\n     sarah := Record{Name: \"Sarah Murphy\", Age: 28}\n     fmt.Printf(\"%+v\\n\", david)\n     fmt.Printf(\"%+v\\n\", sarah)\n}\n```", "```\ntype Record struct{\n     Name string\n     Age int\n}\n// String returns a csv representing our record.\nfunc (r Record) String() string {\n     return fmt.Sprintf(\"%s,%d\", r.Name, r.Age)\n}\n```", "```\njohn := Record{Name: \"John Doak\", Age: 100}\nfmt.Println(john.String())\n```", "```\nmyRecord.Name = \"Peter Griffin\"\nfmt.Println(myRecord.Name) // Prints: Peter Griffin\n```", "```\nfunc changeName(r Record) {\n     r.Name = \"Peter\"\n     fmt.Println(\"inside changeName: \", r.Name)\n}\nfunc main() {\n     rec := Record{Name: \"John\"}\n     changeName(rec)\n     fmt.Println(\"main: \", rec.Name)\n}\n```", "```\nInside changeName: Peter \nMain: John\n```", "```\nfunc changeName(r *Record) {\n\tr.Name = \"Peter\"\n\tfmt.Println(\"inside changeName: \", r.Name)\n}\nfunc main() {\n\t// Create a pointer to a Record\n\trec := &Record{Name: \"John\"}\n\tchangeName(rec)\n\tfmt.Println(\"main: \", rec.Name)\n}\nInside changeName: Peter\nMain: Peter\n```", "```\nInside changeName: Peter \nMain: Peter\n```", "```\nfunc (r Record) IncrAge() {\n     r.Age++\n}\n```", "```\nfunc (r *Record) IncrAge() {\n     r.Age++\n}\n```", "```\nfunc NewRecord(name string, age int) (*Record, error) {\n     if name == \"\" {\n          return nil, fmt.Errorf(\"name cannot be the empty string\")\n     }\n     if age <= 0 {\n          return nil, fmt.Errorf(\"age cannot be <= 0\")\n     }\n     return &Record{Name: name, Age: age}, nil\n}\n```", "```\n     rec, err := NewRecord(\"John Doak\", 100)\n     if err != nil {\n          return err\n     }\n```", "```\ntype Stringer interface {\n          String() string\n}\n```", "```\ntype Person struct {\n     First, Last string\n}\nfunc (p Person) String() string {\n     return fmt.Sprintf(\"%s,%s\", p.Last, p.First)\n}\n```", "```\ntype StrList []string\nfunc (s StrList) String() string {\n     return strings.Join(s, \",\")\n}\n```", "```\n// PrintStringer prints the value of a Stringer to stdout.\nfunc PrintStringer(s Stringer) {\n     fmt.Println(s.String())\n}\n```", "```\nfunc main() { \n    john := Person{First: \"John\", Last: \"Doak\"} \n    var nameList Stringer = StrList{\"David\", \"Sarah\"} \n    PrintStringer(john)     // Prints: Doak,John \n    PrintStringer(nameList) // Prints: David,Sarah \n} \n```", "```\ni = 3\ni = \"hello world\"\ni = 3.4\ni = Person{First: \"John\"}\n```", "```\nfunc Println(a ...interface{}) (n int, err error)\nfunc Printf(format string, a ...interface{}) (n int, err error)\n```", "```\nif v, ok := i.(string); ok {\n     fmt.Println(v)\n}\n```", "```\nswitch v := i.(type) {\ncase int:\n     fmt.Printf(\"i was %d\\n\", i)\ncase string:\n     fmt.Printf(\"i was %s\\n\", i)\ncase float:\n     fmt.Printf(\"i was %v\\n\", i)\ncase Person, *Person:\n     fmt.Printf(\"i was %v\\n\", i)\ndefault:\n     // %T will print i's underlying type out\n     fmt.Printf(\"i was an unsupported type %T\\n\", i)\n}\n```"]