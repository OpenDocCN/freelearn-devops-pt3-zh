- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Driving CI/CD with GitHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is designed to unravel the layers of GitHub Actions, from its core
    concepts to advanced deployment strategies. You will encounter a detailed exploration
    of GitHub Actions’ capabilities, structure, and best practices. We delve into
    the essence of workflows, jobs, steps, and actions, each dissected to reveal their
    importance in automation. Practical insights on reducing redundancy, managing
    secrets and variables, and the art of debugging will enhance your workflows’ efficiency
    and security. Permissions and approval processes are also covered, ensuring that
    you wield control over your **Continuous Integration/Continuous Delivery** (**CI/CD**)
    pipeline with precision.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment strategies unfold with clarity, presenting blue-green, rolling, and
    canary deployments, each with their steps, real-world applications, and switchover
    methods. The world of feature release strategies is also demystified, providing
    you with a detailed explanation of feature flags and release trains.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following main topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Actions – Mastering workflow automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Feature release strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub Actions – Mastering workflow automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'GitHub Actions represents a transformative shift in how software development
    and deployment processes are automated. As a native feature of GitHub, this world-class
    CI/CD platform facilitates the creation, management, and execution of workflows
    directly within your GitHub repository. GitHub Actions provides a simple and clear
    workflow, as the following screenshot shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – GitHub Actions built-in visualization](img/B21203_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – GitHub Actions built-in visualization
  prefs: []
  type: TYPE_NORMAL
- en: This chapter delves into the intricacies of GitHub Actions, providing a detailed
    understanding of its capabilities, implementation, and best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Comprehensive overview of GitHub Actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'GitHub Actions offers a wide range of benefits to enhance your software development
    workflow. Here is a closer look at what it brings to the table:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automation**: GitHub Actions automates repetitive tasks such as code building,
    testing, and deployment. It responds to events such as code pushes and issue creation,
    reducing the need for manual intervention.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Versatility**: It can be used for various purposes, including building containerized
    applications, deploying web services, managing dependencies, and more. This flexibility
    makes it adaptable to different development needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CI/CD automation**: GitHub Actions streamlines the CI and CD processes. It
    automatically builds and tests code changes, ensuring code quality, and simplifies
    the deployment pipeline, leading to faster and more reliable releases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved collaboration**: It automates code review processes, performs automated
    testing, and sends notifications based on workflow results. This fosters better
    collaboration among team members, as they can focus on addressing critical issues
    and improvements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Customization**: GitHub Actions allows for workflow customization through
    YAML configuration. Developers can tailor workflows to suit their specific requirements
    and seamlessly integrate with third-party tools and services for extended functionality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Creating workflows is as simple as placing a YAML file in the `.github/workflows`
    directory of your repository, as shown in the following screenshot. This setup
    enables CI tasks, feedback integration into pull requests, and defining conditions
    for pull request merging:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Easy development experience with YAML](img/B21203_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Easy development experience with YAML
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the power and versatility of GitHub workflows, let’s consider
    a typical CI workflow for a Node.js application. Triggered by every push to the
    `main` branch and pull requests, this workflow may include jobs such as **build**,
    **test**, and **deploy**. Each job serves a specific purpose – building the project,
    running tests, and deploying the application, respectively. Within these jobs,
    steps, and actions are carefully orchestrated to ensure that each phase of the
    CI process is executed flawlessly. From checking out the code and setting up the
    Node.js environment to running tests and deploying the application, each step
    and action plays a critical role. We will now delve into the detailed structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a typical example of a GitHub Actions workflow. The workflow
    is written in YAML, which may seem difficult. But if you look at each line one
    by one, it is simple and very easy. Note that this example is for building a Node.js
    application and will not work if you just paste this file. If you want to try
    it, try copying the entire project from the Packt repository ([https://github.com/PacktPublishing/DevOps-Unleashed-with-Git-and-GitHub/tree/main/chapter5](https://github.com/PacktPublishing/DevOps-Unleashed-with-Git-and-GitHub/tree/main/chapter5)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Deep diving into GitHub workflow structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The GitHub workflow stands as the epitome of modern automation in software development,
    a feature that fundamentally transforms the landscape of how developers approach
    CI/CD processes. This exploration delves into the intricacies of GitHub workflows,
    breaking down their structure and functionality to understand how they revolutionize
    software development practices.
  prefs: []
  type: TYPE_NORMAL
- en: When you see a YAML file, you may think that it is difficult to understand.
    Yes, it might be more intuitive if you could tweak it in the GUI. But the GitHub
    Actions workflow is really simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'The workflow can be broken down into the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Workflow**: The backbone of automation, defining the entire process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Job**: A group of steps executed in the same environment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Steps**: The smallest unit of a workflow, each representing an individual
    task'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actions**: Reusable unit, combined into steps, to perform specific tasks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It would be easier to understand if we think of each of these as the following
    blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – GitHub Actions workflow structure](img/B21203_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – GitHub Actions workflow structure
  prefs: []
  type: TYPE_NORMAL
- en: We will cover these elements in detail in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Workflow – The automation framework
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the heart of GitHub Actions lies the concept of the `.github/workflows` directory
    of a GitHub repository, is the blueprint of your automation strategy. It is here
    where the magic begins—with each GitHub event, such as a push or a pull request,
    these workflows spring into action, setting the cogs of automation in motion.
  prefs: []
  type: TYPE_NORMAL
- en: A GitHub Actions workflow can engage with a variety of event types, each triggering
    different automated sequences that are defined in the YAML file. The following
    subsections cover detailed explanations of the event types that can be used to
    trigger workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Webhook events trigger
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A variety of triggers are possible, but we will mention a few typical ones
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`main` branch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Issue operations**: Similar to pull requests, workflows can react to issue
    activities such as creation, assignment, labeling, and closing. This is ideal
    for automatic issue response templates, prioritization, and triaging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Push events and others**: Perhaps the most common trigger, a push event,
    occurs when commits are pushed to the repository. Workflows initiated by push
    events can handle a multitude of tasks, including code scans, building, testing,
    and deploying applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following example triggers an event when pushed to `main`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Scheduled events trigger
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Workflows can be scheduled to run at specific times using the Cron syntax.
    This feature is akin to an alarm clock that activates your workflows at predetermined
    intervals, useful for nightly builds, regular cleanups, or periodic syncing tasks.
    In this example, the workflow is triggered daily at 5:30 and 17:30 UTC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Manual events trigger
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`workflow_dispatch` allows workflows to be manually triggered from the GitHub
    UI or API. This offers the flexibility to run workflows on demand, which is particularly
    useful for ad hoc tasks such as manual deployments, data imports, or any operation
    where manual oversight is necessary before execution.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a setup for manual operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Job – The execution unit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Within each workflow, we encounter **jobs**. Think of a job as a coherent group
    of steps that execute collectively on the same runner. A runner in GitHub Actions
    is a server that has the GitHub Actions runner application installed. It is essentially
    where your jobs are executed. Each runner can be thought of as a clean, isolated
    **Virtual Machine** (**VM**) that is provisioned for each job or workflow run.
    The beauty of jobs in a GitHub workflow is their ability to run concurrently across
    different runners unless they are explicitly defined to be dependent on one another.
    Each job can operate on a variety of GitHub-hosted VMs, each catering to different
    operating systems, or even on self-hosted machines, offering an unprecedented
    level of flexibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the `build` job is a fundamental component of the
    workflow process, generally responsible for compiling code or generating build
    artifacts. The name `build` can be replaced with any job name you like. In your
    setup, the `runs-on` key specifies the execution environment for the following
    example job, which is the `ubuntu-latest` runner. This choice instructs GitHub
    Actions to execute the `build` job on the most recent version of Ubuntu Linux
    available on the platform. Apart from this, you can choose macOS and Windows.
    Also, your local machines or on-premises machines can be registered as self-hosted
    runners, giving you the flexibility to use them in a variety of environments,
    including those with strict network requirements or larger workloads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `strategy` feature in GitHub Actions simplifies testing across multiple
    environments using the `matrix` option. This option allows you to define a combination
    of different configurations (such as operating systems, programming language versions,
    or dependencies) that you want your workflow to run on. Instead of setting up
    multiple jobs manually for each configuration, the matrix option dynamically generates
    a job for each combination you specify. This approach avoids the redundancy of
    manual setup and ensures your code works on various versions of dependencies,
    such as Node.js. It is a proactive way to catch compatibility issues early, affirming
    your application’s stability across different environments. This is optional,
    but good to keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, container settings can be made as follows. If you want a specific
    container environment, you can use this to implement CI/CD in a flexible environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also specify the conditions under which jobs will run as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Steps – The building blocks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Diving deeper, each job comprises **steps**, fundamental tasks, or operations.
    Each step in a job is executed sequentially, ensuring a controlled progression
    of tasks. These steps can be as simple as a script or command execution or as
    complex as running a series of actions. Steps are the building blocks of a workflow,
    piecing together the larger picture of automation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Actions – Customized task executors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The most granular elements within these steps are **actions**. Actions are the
    workhorses of GitHub workflows, encapsulating specific functionalities in reusable
    units. From custom actions tailor-made for specific tasks to a plethora of ready-to-use
    actions available in GitHub Marketplace, the possibilities are endless. Actions
    come in various forms, including JavaScript actions for direct execution on the
    runner, Docker container actions for containerized operations, and composite run
    steps actions, which combine multiple run commands. This versatility allows for
    a high degree of customization, enabling developers to craft workflows that align
    perfectly with their development needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet from a GitHub Actions workflow is tailored for Node.js
    projects, utilizing a series of commands and actions to prepare the runtime environment
    and build the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s take a closer look at the GitHub Actions specifics:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: This is essentially a label for readability within the workflow file.
    It helps you and anyone else reading the workflow understand what the step is
    intended to do. Here, it specifies that the step will set up Node.js version 14.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uses`: This key specifies an action to be used. Actions are reusable pieces
    of code that can perform complex tasks. `actions/setup-node@v3` refers to the
    third major version of the `setup-node` action, which is designed to configure
    a Node.js environment. When you specify an action with `uses`, GitHub Actions
    will fetch that piece of code and execute it as part of the step.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`with`: This part of the step feeds input parameters to the action specified
    in `uses`. It customizes the behavior of the action. For `setup-node`, you are
    providing two pieces of information: the Node.js version (`node-version: ''14''`)
    and the package manager cache settings (`cache: ''npm''`). The `cache` option
    tells the action to cache the dependencies, which can speed up future job runs.
    This is a predefined parameter in the action that is available in the marketplace
    or is open source. You can create your own and distribute it to the world, or
    create it for internal use and have your internal users use it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`run`: This is a directive for running command-line scripts, and it is where
    you can execute shell commands. In this case, `npm ci` is a command that installs
    all dependencies for your project as specified in your `package-lock.json` file.
    And after that, it builds and tests the project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub Actions may seem complicated at first, but once you get the hang of it,
    it is easy. It is essentially a mechanism to control the flow of scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, GitHub workflows are not just about the tasks they perform; they
    are about streamlining and simplifying the development process. The ability to
    reuse parts of workflows, such as setup and test steps, in different contexts,
    such as pull request validation, exemplifies the platform’s emphasis on efficiency
    and reusability. This aspect is crucial in an era where Agile development and
    rapid iteration are the norms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s embark on the journey of utilizing GitHub Actions. With a vast array
    of templates readily available, the best way to start is by diving right in and
    trying them out. These templates cater to a wide range of automation needs, from
    streamlining repetitive tasks and automating code testing and building in CI to
    facilitating code deployment across various environments and implementing crucial
    security checks and measures. The large selection of GitHub Actions templates
    is easily accessible at GitHub, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Extensive templates for GitHub Actions](img/B21203_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Extensive templates for GitHub Actions
  prefs: []
  type: TYPE_NORMAL
- en: By leveraging these templates, you will be able to harness the full potential
    of GitHub Actions efficiently and effectively. Embrace this powerful tool and
    watch as it transforms your development workflow, making it more streamlined,
    secure, and robust.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Actions best practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several best practices for GitHub Actions that are worth discussing.
    These include reducing redundancy, which helps streamline your workflows by eliminating
    unnecessary repetition. Secrets and variable management are crucial for maintaining
    security and efficiency in your actions. Debugging GitHub Actions workflows is
    an essential skill, allowing you to identify and fix issues quickly. Managing
    permissions effectively ensures that the right levels of access are maintained,
    while the implementation of approval processes with environments helps in controlling
    the deployment flow and maintaining the integrity of different deployment stages.
    Learning and applying these best practices can significantly enhance your proficiency
    with GitHub Actions.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at them one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing redundancy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Harnessing the power of GitHub Actions efficiently demands a focus on reducing
    redundancy, a crucial best practice in workflow automation. This involves three
    key options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Utilizing GitHub Marketplace**: Here, you can tap into a vast array of existing
    actions created by the community, suitable for a wide range of common automation
    tasks. This approach saves time and leverages the collective expertise of other
    developers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Creating custom actions**: For unique requirements not covered by Marketplace
    actions, custom actions offer a tailored solution. They allow you to address the
    specific needs of your project with precision.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implementing reusable workflows**: Develop workflows that can be applied
    across multiple projects. This not only streamlines the workflow setup process
    but also ensures consistency and easier maintenance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By integrating these, you can optimize your use of GitHub Actions, leading
    to more efficient, consistent, and maintainable automation processes in your **Software
    Development Life Cycle** (**SDLC**). Various actions are available as open source
    projects, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Actions in GitHub Marketplace](img/B21203_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Actions in GitHub Marketplace
  prefs: []
  type: TYPE_NORMAL
- en: Custom actions and reusable workflows are the next areas of learning for the
    reader. We will not go into depth here, but for extended use of GitHub Actions,
    there are links to detailed resources in the *Further reading* section at the
    end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Secrets and variable management
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In GitHub Actions, managing secrets and variables is essential for both security
    and workflow customization:'
  prefs: []
  type: TYPE_NORMAL
- en: '`${{ secrets.NAME }}`, ensuring they are not exposed in logs or to unauthorized
    users. Once a secret is registered, it cannot be retrieved, and the registered
    value will not appear in the console output of GitHub Actions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`${{ env.My_Variable }}`. You set environment variables directly in your workflow
    files, and they can be different for each job or step.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example of using a registered secret in GitHub Actions,
    allowing you to inject values from outside the workflow in a flexible manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Proper management of secrets and variables is key to maintaining the security
    and efficiency of your GitHub Actions workflows. Secrets and variables can be
    set from the GitHub configuration page as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Secrets and variables configuration for GitHub Actions](img/B21203_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Secrets and variables configuration for GitHub Actions
  prefs: []
  type: TYPE_NORMAL
- en: Debugging GitHub Actions workflows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Debugging in GitHub Actions is an essential practice to ensure your workflows
    run as expected and to identify and resolve any issues that arise. Here are some
    key points to help you effectively debug your GitHub Actions workflows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ACTIONS_STEP_DEBUG` with the value `true`. This will provide you with more
    detailed information during the execution of your actions, making it easier to
    pinpoint where and why a problem is occurring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Run logs access**: GitHub Actions automatically generates logs for each run.
    These logs can be accessed in the **Actions** tab of your GitHub repository. They
    provide a detailed record of what happened during each step of your workflow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`act` ([https://github.com/nektos/act](https://github.com/nektos/act)) allow
    you to run your workflows locally on your machine. This can be particularly helpful
    for testing complex workflows without having to push changes to your repository.
    It enables a faster iteration cycle in fixing and optimizing your actions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`workflow_dispatch` event trigger in your workflow file allows you to manually
    trigger workflows. This can be useful for testing changes without the need to
    trigger workflows on push or pull request events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other things to keep in mind when creating GitHub Actions workflows include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simplifying workflows**: Break down complex workflows into smaller, more
    manageable parts to isolate and identify issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Utilizing action outputs**: Use outputs from actions for diagnostic purposes.
    These can give insights into the behavior of different steps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Iterative approach**: When making changes to a workflow, do it incrementally.
    Test each change thoroughly before implementing the next. This approach helps
    isolate the impact of each change, making debugging easier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging GitHub Actions workflows effectively requires a combination of utilizing
    detailed logs, testing workflows locally, simplifying complex setups, and manually
    triggering workflows. These practices help to quickly identify and resolve issues,
    ensuring your CI/CD processes are robust and reliable.
  prefs: []
  type: TYPE_NORMAL
- en: Permissions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Managing permissions in GitHub Actions is critical for maintaining the security
    and integrity of your workflow processes. This section focuses on setting and
    managing the appropriate permissions for actions within your GitHub workflows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GITHUB_TOKEN`, a special GitHub-generated token used by workflows. By default,
    this token is scoped to the repository containing your workflow, ensuring actions
    cannot inadvertently affect other repositories or sensitive data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GITHUB_TOKEN` within your workflow file for specific jobs or the entire workflow.
    This allows you to restrict or extend the token’s capabilities based on the needs
    of individual jobs, enhancing security and minimizing risk. Permissions are set
    in the workflow file using the permissions key. You can specify permissions for
    various GitHub API scopes, such as contents, issues, deployments, and more. The
    following is an example of such a setup:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Minimal access**: Apply the **Principle of Least Privilege** (**PoLP**) by
    granting permissions that are only just sufficient for a particular action or
    job to function. Avoid giving broad or admin-level permissions unless absolutely
    necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By meticulously managing permissions in GitHub Actions, you can safeguard your
    workflows against unauthorized access, mistakes, and potential security vulnerabilities.
    This involves setting precise token permissions, securely managing secrets, and
    regularly auditing access levels to align with PoLP. Implementing these practices
    will significantly strengthen the security posture of your CI/CD pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Approval processes with environments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the dynamic world of software deployment and CI, GitHub Actions brings a
    crucial element of control and oversight through its **Environments** feature.
    This innovative functionality significantly elevates the way teams handle their
    deployment workflows, particularly in terms of approval processes and adherence
    to specific operational conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Environments in GitHub Actions serve as dedicated spaces within the workflow,
    each tailored to specific stages such as testing, staging, or production. What
    sets these environments apart is their capacity to be customized with unique rules
    and access controls. They become not just segments of the workflow but controlled
    realms, each with its distinct set of permissions and secrets. This ensures that
    sensitive information and actions are confined to where they are most relevant,
    bolstering the security of the entire process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Central to the value of environments is their role in facilitating approval
    workflows. Imagine a scenario where any deployment to production requires a careful
    review. Environments make this possible by integrating a manual approval process.
    When a deployment reaches the production stage, it triggers a pause in the workflow,
    awaiting the green light from authorized personnel. This pause is not just a halt
    in operations; it is a gatekeeper ensuring that every change undergoes scrutiny
    before it affects the live environment. The approval flow with **Environments**
    is seamlessly integrated into the GitHub Actions experience, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Approval on Environments](img/B21203_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – Approval on Environments
  prefs: []
  type: TYPE_NORMAL
- en: Beyond mere approval, environments in GitHub Actions allow for sophisticated
    condition settings. Jobs within an environment can be configured to run only in
    specific circumstances, such as on certain branches or in response to particular
    events. This level of detail in control ensures that the workflow adheres to the
    precise operational standards of a project, avoiding any unintended deployments
    or actions.
  prefs: []
  type: TYPE_NORMAL
- en: The introduction of protection rules within these environments further fortifies
    the workflow. By setting requirements such as mandatory reviewers for changes,
    organizations can enforce compliance and maintain high-security standards. This
    is not just about keeping the workflow secure; it is about aligning it with organizational
    protocols and best practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'An environment, therefore, is not just an addition to GitHub Actions; it is
    a paradigm shift in how deployment workflows are managed. It introduces a layer
    of security, control, and compliance that is indispensable in modern software
    development. Environments ensure that every step in the CI/CD pipeline, especially
    those involving sensitive stages such as production, is executed under stringent
    scrutiny and within the bounds of defined operational guidelines. This is GitHub
    Actions not just facilitating automation, but doing so with a keen eye on safety,
    reliability, and organizational integrity. From the **Environments** configuration,
    you can add protection rule settings such as adding an approver:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Environments configuration](img/B21203_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – Environments configuration
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Actions stands out as a versatile tool, adaptable to a wide range of
    development scenarios, making it an indispensable asset for modern software development
    teams. Whether it is automating routine tasks, ensuring code quality, or deploying
    applications, GitHub Actions provides the tools and flexibility required for high-quality
    software delivery.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at some applied practices for deploying with GitHub Actions.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to embrace *failure* as a system in DevOps. In the dynamic world
    of DevOps, embracing failure is not just recommended; it is essential. Contrary
    to traditional perspectives where failure is often seen as a setback, in DevOps,
    failure assumes a transformative role. It is not merely an incident or an unexpected
    result; it is an integral part of DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: In conventional deployment methodologies, extensive checks and balances are
    the norm, aimed at minimizing the occurrence of failure. However, the fast-paced
    nature of modern development such as Agile alters this approach significantly.
    In modern development, the landscape is ever-evolving, and services undergo constant
    changes. If these changes are not made swiftly and effectively, it could lead
    to service degradation or failure. Therefore, it becomes crucial to build a system
    that is resilient and can adapt to these rapid changes.
  prefs: []
  type: TYPE_NORMAL
- en: In this context, the goal is not to prevent failure outright, but to create
    an environment where failures are manageable and their impacts are minimized.
    This involves adopting strategies that anticipate failures and implement mechanisms
    to quickly recover or roll back changes when necessary. It is about building robustness
    and resilience into the system, ensuring that it can withstand and recover from
    failures, rather than simply aiming for a failure-free operation. This section
    delves into how to accept failure as a systemic necessity in DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, the realms of infrastructure and application deployment have
    existed as separate domains. However, the advent of DevOps has ushered in an era
    where these boundaries blur into a unified landscape. Nowadays, infrastructure
    configuration is also defined by **Infrastructure as Code** (**IaC**). This means
    that infrastructure and apps can be released at the same time. You need to deploy
    both infrastructure and apps stably in both aspects in the context of DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at some practices that are particularly common when deploying services.
  prefs: []
  type: TYPE_NORMAL
- en: Blue-green deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Blue-green deployment is a strategy in software deployment that minimizes downtime
    and risk by maintaining two identical production environments. This method allows
    for safe and seamless transitions between software versions. As shown in the following
    diagram, the load balancer or **Platform as a Service** (**PaaS**) services’ capabilities
    switch traffic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Blue-green deployment](img/B21203_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – Blue-green deployment
  prefs: []
  type: TYPE_NORMAL
- en: In this strategy, the blue environment hosts the current live version, while
    the green environment is used for the new version. Once the new version in the
    green environment is fully tested and ready, traffic is switched over from blue
    to green.
  prefs: []
  type: TYPE_NORMAL
- en: 'Key benefits of this approach include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Easy rollback**: If issues are discovered in the green environment after
    going live, traffic can be quickly redirected back to the stable blue environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minimal downtime**: Blue-green deployment allows you to release new versions
    of your software without any downtime for end users. The new version is deployed
    alongside the old one, and the switch is made instantly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy testing**: Developers and **Quality Assurance** (**QA**) teams can thoroughly
    test the new version in a production-like environment without affecting end users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The terminology of blue-green is often perceived as a synonym for environments
    such as staging, QA, and production, but it is not exact. Unlike a traditional
    staging-to-production promotion, both the blue and green environments in this
    method are production-grade.
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite its advantages, there are notable challenges:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Requirement of two production environments**: This can be resource-intensive
    and costly. Maintaining two full-scale production environments can be expensive,
    even in a cloud computing context.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Challenges with irreversible changes**: If changes such as database schema
    updates are not backward compatible, rollback can be complicated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stateful application considerations**: Synchronizing stateful data between
    environments can be complex.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typical steps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A practical example of blue-green deployment for a web application, where the
    current live version is 1.3 in the blue environment and the goal is to deploy
    version 1.4, can be outlined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Deployment**: Initiate by deploying the new version, 1.4, to the green environment.
    This environment is a replica of the existing blue environment but hosts the new
    version.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Validation**: Conduct comprehensive testing in the green environment. This
    step is critical to ensure that the new version operates correctly and meets all
    necessary requirements.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Traffic switch**: Once validation is successful, the next step is to switch
    user traffic. This is done by updating the load balancer settings to redirect
    traffic from the blue environment (version 1.3) to the green environment (version
    1.4).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Monitoring**: After the traffic switch, closely monitor the green environment
    for any operational issues or unexpected behavior. This monitoring phase is crucial
    to quickly identify and address any problems that may arise post-deployment.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Finalization**: If the green environment with version 1.4 runs smoothly and
    no significant issues are detected, the deployment is deemed successful, and the
    green environment becomes the new production environment. However, if there are
    critical problems, you have the option to promptly revert traffic to the stable
    blue environment (version 1.3), minimizing disruption and risk.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This methodical approach ensures a smooth transition between application versions,
    maintaining system stability and availability throughout the deployment process.
  prefs: []
  type: TYPE_NORMAL
- en: Real-world scenario
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Achieving a successful blue-green deployment strategy requires a comprehensive
    understanding of your infrastructure and the tools available within your platform.
    The implementation approach can differ significantly based on whether you are
    using **Infrastructure as a Service** (**IaaS**) with VMs or PaaS with load balancers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a closer look at the different methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**DNS load balancers**: In this approach, the changeover between blue and green
    environments is managed through DNS rewriting. This method is often used when
    the environments are hosted on different servers or clusters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layer 4 network load balancers**: These perform the switchover by **Network
    Address Translation** (**NAT**) translation. It is a suitable option for switching
    between environments hosted within the same network infrastructure.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layer 7 application load balancers**: Here, the routing to different application
    versions is managed at the application layer. This method provides more granular
    control over traffic distribution and is often used in complex deployments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many PaaS solutions come with built-in load-balancing capabilities, simplifying
    the blue-green deployment process. In these setups, the load balancer can be easily
    configured to switch traffic between the blue and green environments. In such
    cases, users can set up switching simply by configuration without being aware
    of the presence of a load balancer.
  prefs: []
  type: TYPE_NORMAL
- en: In more advanced environments, such as **Kubernetes** (**k8s**), network resources
    are managed as IaC, providing the capability for dynamic allocation. This enables
    the implementation of blue-green deployments through modifications to IaC configuration,
    typically achieved by editing YAML files. While numerous PaaS offerings abstract
    away network configuration complexities from users, certain platforms, such as
    Kubernetes, maintain network configurations internally within a single cluster,
    thereby enabling the same blue-green deployment approach to be applied seamlessly
    within the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Switching methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, how do we switch environments? There are several possible ways, so let’s
    take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Separate script or graphical UI (GUI) for load balancer configuration**:
    Some teams prefer to handle the switchover separately from the main deployment
    script. This can be done using a dedicated script or through a GUI, providing
    more control and oversight during the switch.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load balancing configuration in deployment script**: This method involves
    scripting the load balancer setting changes directly in the deployment script.
    It is a streamlined approach that can automate the switchover process as part
    of the deployment pipeline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automation**: Automation encompasses the automated testing of the new version,
    ensuring that the switch only occurs when the new version performs successfully.
    This involves setting specific conditions for the release to proceed, often relying
    on components such as **End-To-End** (**E2E**) tests and monitoring for errors
    in the new environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to note that the timing of the switchover and the handling of
    existing connections can vary based on the system and service used. Each method
    has its nuances and requires careful planning to ensure a smooth transition with
    minimal disruption to the users.
  prefs: []
  type: TYPE_NORMAL
- en: Rolling deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A rolling deployment is a deployment strategy used in distributed systems whereby
    updates are applied incrementally across the nodes of a cluster. This method reduces
    downtime and ensures **High Availability** (**HA**) while updating applications
    or systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is used in clusters such as Kubernetes for stable releases with no downtime.
    A rolling deployment involves gradual releases, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Rolling deployment](img/B21203_05_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – Rolling deployment
  prefs: []
  type: TYPE_NORMAL
- en: This way, we can safely update each release one by one.
  prefs: []
  type: TYPE_NORMAL
- en: Typical steps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The process of a cluster rolling deployment generally involves the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Preparation**: Before starting the update, ensure the system is ready for
    the upgrade. This includes taking backups of critical data and preparing the new
    version of the software or configuration to be deployed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Update the first node**: Begin the rolling update by selecting a single node.
    Instead of taking this node out of service before applying the update, the update
    is applied while the node is still in service. A new instance with the updated
    configuration or software is started alongside the existing ones.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Health check**: Once the new instance is up and running, perform a thorough
    health check. This step is crucial to ensure that the new instance is correctly
    configured and capable of handling the intended workload without issues.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Traffic shift**: After confirming that the new instance is healthy, gradually
    redirect traffic from the old instance to the new instance. This may involve adjusting
    load balancer settings or service discovery configurations to point to the new
    instance.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Remove old instance**: Once the new instance is successfully handling traffic,
    the old instance can be safely removed from service. This ensures there is no
    downtime, as the service continues uninterrupted during the update.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Gradual rollout**: Continue with the rolling update by repeating the process
    for each node in the cluster. Update nodes one by one, ensuring each new instance
    is healthy and capable of handling traffic before decommissioning the old ones.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Monitoring**: Throughout the update process, continuously monitor the system
    for any issues. Pay close attention to performance metrics and error logs to quickly
    identify and address any problems.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Finalization**: After all nodes have been updated and old instances removed,
    the rolling update is complete. Conduct a final review to ensure the entire system
    is stable, performing as expected, and that all instances are running the new
    version.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Real-world scenario
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In real-world scenarios, a cluster rolling deployment is particularly vital
    in environments where continuous availability is crucial. This approach is commonly
    used in cloud computing services, data centers, and large-scale web applications.
    For example, updating a Kubernetes cluster or a database cluster often employs
    this strategy to avoid downtime and service disruptions. Also, be aware that rolling
    upgrades include both the application context and the infrastructure context.
    In the case of Kubernetes, in addition to cluster-side upgrades, there is also
    such a procedure for application upgrades.
  prefs: []
  type: TYPE_NORMAL
- en: This may be done through in-place upgrades while the service is running, but
    in mission-critical services, such as financial services, it may be applied in
    conjunction with other release strategies. This is like a blue-green deployment
    with a cloud load balancer in front of the cluster itself and distributed.
  prefs: []
  type: TYPE_NORMAL
- en: While it is true that some of these have a discourse of losing the benefits
    of rolling upgrades in some cases, it means that the configurations that open
    source projects and service vendors generally consider best practices do not necessarily
    match configurations that can realistically be taken.
  prefs: []
  type: TYPE_NORMAL
- en: Switchover methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The method of a rolling deployment varies in difficulty depending on whether
    the system supports it as a feature. In a cluster orchestrator such as Kubernetes,
    updates can be rolled out using automated orchestrators, which manage the process
    of updating nodes and conducting health checks, while there are cases where a
    rolling deployment is still a reality, traditionally done by hand.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if a single-tenant service is hosted in an isolated environment
    for an individual company and each environment requires updates, then deploying
    customers in several tiers is categorized and updates are done gradually. While
    this is also a type of rolling deployment, explicitly referring to DevOps practices
    will often refer to automated practices.
  prefs: []
  type: TYPE_NORMAL
- en: A cluster rolling deployment is essential for maintaining the reliability and
    stability of distributed systems during upgrades or maintenance. By updating nodes
    sequentially, this strategy minimizes the risk of system-wide failures and ensures
    that services remain available to users throughout the process.
  prefs: []
  type: TYPE_NORMAL
- en: Canary deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A canary deployment is a technique whereby new versions of the software are
    rolled out gradually to a small subset of users before being deployed to the entire
    user base. This approach allows developers to test the new version in a real-world
    environment with minimal risk.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a canary deployment, instead of releasing a new version to all users at
    once, the update is first introduced to a small group of users – the **canaries**.
    This group acts as an early indicator for any potential issues, hence the name
    *canary*, akin to the canaries used in coal mines to detect harmful gases. By
    monitoring the behavior and performance of the software with these initial users,
    developers can identify and address any issues before a full rollout. As shown
    in the following diagram, the switching is implemented gradually, and once stability
    is confirmed, the range is expanded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – Canary deployment](img/B21203_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 – Canary deployment
  prefs: []
  type: TYPE_NORMAL
- en: This is essentially the same as a rolling deployment but differs in duration
    and the activities and objectives associated with it. Rolling deployments are
    intended to replace older versions of applications sequentially with newer versions
    by completely replacing the infrastructure on which the application is running,
    and health checks are performed and completely replaced within a short period
    of time. In most cases, this is done in a few minutes to a few hours. For large
    systems, it might take several days.
  prefs: []
  type: TYPE_NORMAL
- en: Canary releases, on the other hand, take a relatively long period of time to
    observe how the system behaves in response to user behavior and to use that feedback
    for a stable release.
  prefs: []
  type: TYPE_NORMAL
- en: Although canary releases are sometimes confused with beta releases targeted
    at a subset of users, it should be noted that canary releases are clearly a practice
    with release stability as a major objective. The methodology for targeted beta
    releases is covered in the *Feature* *flag* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Key benefits of a canary deployment include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Risk mitigation**: By limiting the exposure of the new version, any negative
    impact is contained and affects only a small portion of the user base'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Real-world testing**: Provides an opportunity to observe how the new version
    performs under real-world conditions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User observation**: Early observation from a subset of users can be invaluable
    for making adjustments before the wider release'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Gradual rollout**: Offers a controlled way to manage the release process,
    reducing the likelihood of widespread issues'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, it also has its challenges:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Segmentation**: Deciding which users should be part of the canary group can
    be challenging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring complexity**: Requires robust monitoring tools to effectively
    track the performance of the new version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistent user experience**: Ensuring a consistent experience for all users,
    regardless of the version they are using, can be difficult. For example, when
    a new backend service is developed, it must be released with the assurance that
    the current service will continue to work properly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typical steps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s take a look at each of these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Deployment**: Initially, deploy the new version to a small percentage of
    your infrastructure, which will serve a fraction of your user base.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Monitoring and analysis**: Observe the behavior of the application closely.
    Use metrics, logs, and user feedback to evaluate performance and identify any
    issues.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Expansion**: If the initial deployment is successful, gradually increase
    the percentage of users accessing the new version. Continue monitoring and analyzing
    user feedback and system performance.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Full rollout**: Once confident that the new version is stable and well received,
    proceed with the full rollout to all users.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Roll back if necessary**: If significant issues are identified during the
    canary phase, roll back the changes quickly to minimize impact.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Real-world scenario
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Canary releases will be applied differently depending on the number of users
    and services to be deployed.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when Microsoft applies canary releases to deploy Azure features,
    the canaries can be selected from a particular data center or a particular cluster
    of data centers. This is because it clearly narrows down the affected users and
    minimizes the impact. Another advantage of this clear user focus is that the situation
    can be observed on an ongoing basis. When stability is confirmed by deploying
    to a particular cluster or data center, the next step is to expand the deployment
    to a wider target.
  prefs: []
  type: TYPE_NORMAL
- en: In the absence of the ability to target specific data centers or clusters, canary
    releases are frequently executed in a more randomized manner, leveraging the capabilities
    of cloud platforms. For instance, consider the approach of directing a random
    subset of users, say 5%, to a newly configured environment. This method employs
    a weight-based distribution strategy, where initially a small percentage such
    as 5% is chosen, subsequently increasing to 10%, 25%, and eventually 100% as confidence
    in the new environment grows. During this process, the load balancer is configured
    to allocate the defined percentage of user requests to the staging or new environment.
    Many cloud load balancers use this weight-based method.
  prefs: []
  type: TYPE_NORMAL
- en: To enhance user experience consistency, some services use cookies to ensure
    subsequent requests from the same client are directed to the same instance. However,
    the primary method of traffic allocation under this model is largely random. For
    instance, in the scenario where 5% of users are routed to a new environment and
    an error exists in the new version, there is a proportional 5% likelihood of users
    encountering the error, but all the users have that possibility.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, a more deterministic method involves the use of header-based
    routing. This technique involves inserting specific information into the request
    header, which is then utilized to direct traffic. This approach reduces randomness
    by enabling targeted trials for specific users or user groups. The feasibility
    of implementing this method depends on the capabilities of the cloud service being
    used.
  prefs: []
  type: TYPE_NORMAL
- en: Both methods provide mechanisms for the gradual exposure of new updates or features,
    but each with its own level of control. For example, DNS load balancers do not
    read header information, so they basically only distribute weights, but they may
    be able to distribute by country. Layer 7 application load balancers, on the other
    hand, can read header information and other information.
  prefs: []
  type: TYPE_NORMAL
- en: Canary selection methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In canary deployments, managing how users are exposed to the new version is
    crucial. Various methods can be employed to control this exposure:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Weight-based approach**: This method involves allocating a certain percentage
    of traffic to the new version. For example, initially, 5% of users may be directed
    to the new environment, gradually increasing to 25%, 50%, and ultimately 100%
    as confidence in the new version grows. Load balancers are often configured to
    handle this distribution of traffic based on predefined weights.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Header-based routing**: This technique utilizes specific information added
    to the request headers to direct traffic to the appropriate version. This method
    is less random than weight-based routing and allows for more targeted testing,
    such as exposing the new version to certain user groups or individuals based on
    header criteria.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cookie-based routing**: Some services use cookies to ensure that subsequent
    requests from the same client are consistently directed to the same version (either
    new or old). This approach helps maintain a consistent user experience and is
    particularly useful for session persistence.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Geography-based distribution**: In some cases, traffic can be distributed
    based on the geographical location of the users. Some DNS load balancers, for
    example, can route traffic differently based on the country or region, which can
    be useful for global services looking to roll out updates in specific areas first.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing the right switchover method is a critical decision in canary deployments,
    as it directly impacts the ability to effectively test the new version and respond
    to any issues that may arise during the initial rollout phase.
  prefs: []
  type: TYPE_NORMAL
- en: A canary deployment is a strategic approach to software releases, offering a
    balanced mix of risk mitigation and real-world testing. By gradually introducing
    changes, it allows for a more measured and informed approach to software deployment.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to deploy applications and how to release them seamlessly and
    securely. Now that we have looked at strategies for how to deploy, we will next
    look at how to release at a more functional level.
  prefs: []
  type: TYPE_NORMAL
- en: Feature release strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have focused on releasing the infrastructure and the service as a
    whole, but now, we will focus on releasing the features within the service. For
    feature releases, we introduce a release style called the feature flag and release
    train.
  prefs: []
  type: TYPE_NORMAL
- en: Feature flag
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Feature flag deployment is a technique used in software development and delivery
    that involves toggling on or off certain features of an application without deploying
    new code. This method allows for more granular control over feature release, testing,
    and rollback, enabling a more dynamic and flexible approach to software management.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main drawback of using feature flags for anything is that feature flags
    can easily become a technical liability. Unused feature flags can clutter up the
    code base. Feature flags enable features for specific users or groups, as shown
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12 – Feature flag](img/B21203_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.12 – Feature flag
  prefs: []
  type: TYPE_NORMAL
- en: Dark launches are typically released to user groups that do not know they are
    being tested and have not been told about the new feature at all. The advantage
    of this, on the other hand, is that it can be applied to any user group that wishes
    to do so, and not just to certain categories of users.
  prefs: []
  type: TYPE_NORMAL
- en: Typical steps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The implementation of feature flags typically involves the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implementation of feature flags in code**: Developers write conditional code
    for new features, controlled by feature flags. These flags can be toggled on or
    off, determining whether the feature is active.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Integration with feature management system**: The feature flags are then
    integrated with a feature management system, which allows for controlling and
    changing the flags without needing to modify the code base.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Testing**: Before enabling the feature for all users, it is often tested
    with a limited audience, similar to a canary release. This testing can be targeted
    based on user segments, geography, or other criteria.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Gradual rollout**: After initial testing, the feature can be gradually rolled
    out to more users, allowing for careful monitoring of its impact and performance.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Monitoring and feedback**: Continuous monitoring is essential to quickly
    identify any issues. Feedback from users during the rollout phase is also valuable
    for further refinement.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Full rollout or rollback**: Depending on the feedback and performance, the
    feature can be fully rolled out to all users or rolled back by simply toggling
    the feature flag off.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Real-world scenario
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Feature flags are an integral tool for modern software teams, enabling them
    to deliver features more efficiently and with greater control. This approach reduces
    risks associated with deploying new features and allows for more Agile product
    development and iteration. Their application extends across various aspects of
    software development, including A/B testing and dark launches.
  prefs: []
  type: TYPE_NORMAL
- en: The following subsections are real-world examples illustrating these applications.
  prefs: []
  type: TYPE_NORMAL
- en: A/B testing
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Let’s say a software team at an e-commerce company might use feature flags
    to test two different checkout page designs. They would create two variants: Design
    A (the current design) and Design B (the new design). By employing feature flags,
    they can expose Design B to a small, randomized group of users while the rest
    continue to see Design A. The team then monitors **Key Performance Indicators**
    (**KPIs**) such as conversion rates, **Average Order Value** (**AOV**), and user
    feedback. This data helps them understand which design performs better in terms
    of user engagement and sales conversion. Based on the results, they can decide
    to either roll out Design B to all users, iterate on it, or revert to Design A,
    all with minimal disruption to the overall user experience.'
  prefs: []
  type: TYPE_NORMAL
- en: Dark launch
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: A social media platform might use dark launches to test a new feature, such
    as an enhanced image recognition algorithm. They release the feature *in the dark*,
    meaning it is live but not visible to users. The platform then collects data on
    how the new algorithm performs in terms of accuracy and speed compared to the
    old one, without users being aware of the change.
  prefs: []
  type: TYPE_NORMAL
- en: This approach allows the platform to gather real-world data on the feature’s
    performance and iron out any issues before making it visible to users. If the
    new algorithm does not perform as expected, they can refine or roll it back without
    impacting the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Feature flag deployment empowers teams to test and release features with higher
    confidence and control. By decoupling deployment from release, it allows for more
    flexibility, quicker iteration, and reduced risk in software development processes.
  prefs: []
  type: TYPE_NORMAL
- en: Release train
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A release train is a concept in software development that emphasizes regular,
    scheduled deliveries of new features, enhancements, and fixes. It aligns multiple
    teams and processes to ensure a coordinated and predictable release cycle, significantly
    improving the efficiency and reliability of software deployments. As shown in
    the following diagram, the release train only releases those that meet the deadline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13 – Release train](img/B21203_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.13 – Release train
  prefs: []
  type: TYPE_NORMAL
- en: Typical steps
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The release train approach typically involves the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Planning and coordination**: Establish a release schedule that all teams
    adhere to. This schedule includes fixed intervals (for example, bi-weekly, monthly)
    at which new features and updates are released.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Development and testing**: Teams work on their respective features and fixes
    within the defined timeline. CI and **Continuous Testing** (**CT**) are employed
    to ensure code quality and compatibility.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Integration and staging**: All features, enhancements, and fixes are integrated
    into a staging environment. This stage is crucial for identifying any integration
    issues and ensuring that all components work together seamlessly.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Release review**: Conduct a review meeting with all stakeholders to ensure
    that the release is ready to be deployed. This meeting assesses the quality, functionality,
    and potential impact of the release.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Deployment**: Once approved, the release is deployed to production according
    to the schedule. The deployment process is typically automated to reduce human
    error and increase efficiency.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Monitoring and feedback**: After the release, continuous monitoring is essential
    to quickly identify and address any post-deployment issues. Feedback from users
    and stakeholders is collected for future improvements.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Real-world scenario
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a large software organization, the release train approach can significantly
    streamline the deployment process. For instance, a company developing a suite
    of business applications might have multiple teams working on different modules
    such as finance, HR, and operations. By adopting the release train model, the
    organization ensures that updates across all modules are released in a coordinated
    manner. Every month, new features and updates from each team are integrated, tested,
    and then deployed simultaneously. This synchronization avoids complexities and
    conflicts that can arise when different teams deploy updates independently.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, this approach provides customers with a predictable update schedule,
    enabling them to plan for the adoption of new features and updates. It also allows
    for more efficient allocation of resources within the organization, as teams can
    plan their workloads in accordance with the release schedule.
  prefs: []
  type: TYPE_NORMAL
- en: In essence, the release train model fosters a disciplined, predictable, and
    efficient release process, benefiting both the development teams and the end users.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has equipped you with the knowledge and skills to transform your
    development workflow into a model of automation excellence. The journey through
    the pages of this chapter has taken you from the foundational elements of GitHub
    Actions to strategic deployment and release techniques that stand at the forefront
    of modern software practices. To go further from here, you need to deepen such
    things as testing and concurrency. These things are not only connected to how
    the pipeline is put together but also to the philosophy of testing and integration.
    I hope you will continue to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: By embracing the practices and strategies outlined herein, you are now poised
    to craft workflows that are not only efficient and robust but also secure and
    compliant with the highest standards. Let this chapter be a constant companion
    as you continue to innovate and excel in the evolving landscape of software development.
    In the upcoming chapter, we will delve into the critical areas of DevOps metrics,
    DevSecOps, and scaling collaboration, exploring how these concepts play a pivotal
    role in enhancing the efficiency and security of software development and deployment
    processes.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*About custom* *actions*: [https://docs.github.com/en/actions/creating-actions/about-custom-actions](https://docs.github.com/en/actions/creating-actions/about-custom-actions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Reusing* *workflows*: [https://docs.github.com/en/actions/using-workflows/reusing-workflows](https://docs.github.com/en/actions/using-workflows/reusing-workflows)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Part 3: Beyond DevOps'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This part provides a detailed examination of DevOps, emphasizing the role of
    metrics, the incorporation of DevSecOps practices, and strategies for scaling
    collaboration in organizations. It then shifts focus to the integration of AI
    in software development, exploring tools such as GitHub Copilot and best practices
    for coding with AI assistance, including prompt crafting and AI-friendly programming
    principles. Finally, it reflects on the transformative impact of technologies
    such as Git, GitHub, DevOps, and AI in software development, contemplating the
    future influence of AI on software engineering practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B21203_06.xhtml#_idTextAnchor125)*, Enriching DevOps Implementation*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B21203_07.xhtml#_idTextAnchor141)*, Accelerate Productivity with
    AI*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B21203_08.xhtml#_idTextAnchor157)*, Reflection and Conclusion*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
