<html><head></head><body>
		<div id="_idContainer084">
			<h1 id="_idParaDest-110" class="chapter-number"><a id="_idTextAnchor115"/><st c="0">7</st></h1>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor116"/><st c="2">An Overview of DevSecOps in Power Platform</st></h1>
			<p><st c="44">DevSecOps is a software development methodology that integrates security practices into the </st><a id="_idIndexMarker750"/><st c="137">whole </st><strong class="bold"><st c="143">software development life cycle</st></strong><st c="174"> (</st><strong class="bold"><st c="176">SDLC</st></strong><st c="180">) from</st><a id="_idTextAnchor117"/><st c="187"> requirement analysis, planning and design, development, and testing and quality assurance through deployment and maintenance. </st><st c="314">The Power Platform is a modern application runtime platform that enables developers to build custom applications, automate workflows, create chatbots, design and publish websites, and more. </st><st c="504">The platform has a robust security model that ensures data protection and compliance with industry standards (</st><em class="italic"><st c="614">more than 90+ compliance certificates</st></em><st c="652">); application life cycle management and the DevOps processes established by Azure DevOps or GitHub partially consider by default this security infusion when they deal with any kind of </st><span class="No-Break"><st c="838">development projects.</st></span></p>
			<p><st c="859">This chapter will cover the steps and actions that are essential for us to set up a secure DevOps development project with multiple environments and </st><strong class="bold"><st c="1009">Microsoft Entra ID</st></strong><st c="1027">-backed identity and access management. </st><st c="1068">We will also learn how we can use DevOps tools to spin up Power Platform-based development projects at scale, allowing developers and contributors to quickly build and deploy applications while maintaining security and compliance standards. </st><st c="1309">The platform also provides static analysis tools and reports to monitor certain types of security threats. </st><st c="1416">This helps us enable frictionless productivity while minimizing cyber risk. </st><st c="1492">We will also cover the security implications regarding custom code with open source libraries and we will investigate our DevOps tools from a </st><span class="No-Break"><st c="1634">security perspective.</st></span></p>
			<p><st c="1655">In this chapter, we are going to cover the following </st><span class="No-Break"><st c="1709">main topics:</st></span></p>
			<ul>
				<li><st c="1721">What </st><span class="No-Break"><st c="1727">is DevSecOps?</st></span></li>
				<li><st c="1740">Security model of </st><span class="No-Break"><st c="1759">Power Platform</st></span></li>
				<li><st c="1773">Secret scanning and static code </st><span class="No-Break"><st c="1806">analysis tools</st></span></li>
				<li><span class="No-Break"><st c="1820">Solution checker</st></span></li>
				<li><st c="1837">Spinning up DevSecOps projects </st><span class="No-Break"><st c="1869">at scale</st></span></li>
				<li><st c="1877">Security of </st><span class="No-Break"><st c="1890">DevOps processes</st></span></li>
			</ul>
			<h1 id="_idParaDest-112"><a id="_idTextAnchor118"/><st c="1906">Technical requirements</st></h1>
			<p><st c="1929">To delve into the details of DevSecOps approaches and tools, we need to have </st><span class="No-Break"><st c="2007">the following:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="2021">A Power Platform subscription</st></strong><st c="2051">: We can sign up for a Power Apps Developer Plan (</st><a href="https://www.microsoft.com/en-us/power-platform/products/power-apps/free"><st c="2102">https://www.microsoft.com/en-us/power-platform/products/power-apps/free</st></a><st c="2174">), if we already have a Microsoft Entra ID work account, or we can join the Microsoft 365 Developer </st><span class="No-Break"><st c="2275">Program (</st></span><a href="https://developer.microsoft.com/en-us/microsoft-365/dev-program"><span class="No-Break"><st c="2284">https://developer.microsoft.com/en-us/microsoft-365/dev-program</st></span></a><span class="No-Break"><st c="2348">)</st></span></li>
				<li><strong class="bold"><st c="2350">An Azure DevOps services organization</st></strong><st c="2387">: We can create a DevOps organization any time for </st><span class="No-Break"><st c="2439">free (</st></span><a href="https://learn.microsoft.com/en-us/azure/devops/user-guide/sign-up-invite-teammates"><span class="No-Break"><st c="2445">https://learn.microsoft.com/en-us/azure/devops/user-guide/sign-up-invite-teammates</st></span></a><span class="No-Break"><st c="2528">).</st></span></li>
				<li><strong class="bold"><st c="2531">A GitHub handle and a public </st></strong><span class="No-Break"><strong class="bold"><st c="2561">repository</st></strong></span><span class="No-Break"><st c="2571">: </st></span><a href="https://github.com/signup"><span class="No-Break"><st c="2574">https://github.com/signup</st></span></a></li>
				<li><strong class="bold"><st c="2599">GitHub Advanced Security</st></strong><st c="2624">: This is available free for public repositories; </st><span class="No-Break"><st c="2675">see </st></span><a href="https://docs.github.com/en/get-started/learning-about-github/about-github-advanced-security#about-advanced-security-features"><span class="No-Break"><st c="2679">https://docs.github.com/en/get-started/learning-about-github/about-github-advanced-security#about-advanced-security-features</st></span></a><span class="No-Break"><st c="2803">.</st></span></li>
				<li><strong class="bold"><st c="2804">Samples and walk-throughs</st></strong><st c="2830"> discussed in this chapter are located </st><span class="No-Break"><st c="2869">under </st></span><a href="https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/tree/main/Chapter07"><span class="No-Break"><st c="2875">https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/tree/main/Chapter07</st></span></a></li>
			</ul>
			<h1 id="_idParaDest-113"><a id="_idTextAnchor119"/><st c="2974">What is DevSecOps?</st></h1>
			<p><strong class="bold"><st c="2993">DevSecOps</st></strong><st c="3003"> stands</st><a id="_idIndexMarker751"/><st c="3010"> for </st><strong class="bold"><st c="3015">development, security, and operations</st></strong><st c="3052"> and the collaboration of these areas to deliver secure applications. </st><st c="3122">Its principles were established shortly after defining the DevOps process and methodology. </st><st c="3213">The idea is the same, applying the </st><strong class="bold"><st c="3248">shift-left</st></strong><st c="3258"> mindset in </st><a id="_idIndexMarker752"/><st c="3270">security in an analogous way to how we have applied the shift-left mindset in quality assurance and later in operations. </st><st c="3391">It is a framework that integrates security into all phases of the SDLC and, in that sense, it is an evolution in the way software development organizations approach security by introducing a security-first mindset culture and automating security into every phase of the software development life cycle from design to delivery. </st><st c="3718">Organizations </st><a id="_idIndexMarker753"/><st c="3732">widely adopt this approach to reduce the risk of releasing code with security vulnerabilities to avoid not just reputation loss but also the high financial impacts of </st><span class="No-Break"><st c="3899">such failures.</st></span></p>
			<p><st c="3913">If we look back at the main phases of the SDLC that we learned about in </st><a href="B22208_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><st c="3986">Chapter 1</st></em></span></a><st c="3995"> (requirement analysis, planning and design, development, testing and quality assurance, deployment, and maintenance), then we can map the security activities and automations to those phases, as the following </st><span class="No-Break"><st c="4204">figure shows:</st></span></p>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="image/B22208_07_1.jpg" alt="Figure 7.1 – Security in SDLC"/><st c="4217"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="4873">Figure 7.1 – Security in SDLC</st></p>
			<p><st c="4902">These steps and activities </st><a id="_idIndexMarker754"/><st c="4930">and their continuous improvements build up the </st><strong class="bold"><st c="4977">security development life cycle</st></strong><st c="5008"> (</st><strong class="bold"><st c="5010">SDL</st></strong><st c="5013">). </st><st c="5017">The SDL is a </st><a id="_idIndexMarker755"/><st c="5030">software development process that helps developers build and design more secure software that addresses security compliance requirements while reducing development costs. </st><st c="5201">It standardizes security best practices across services and results in delivering more </st><span class="No-Break"><st c="5288">secure products.</st></span></p>
			<p><st c="5304">Let us have a look at these activities in detail going through the SDLC and, respectively, the </st><span class="No-Break"><st c="5400">security scopes.</st></span></p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor120"/><st c="5416">Setup</st></h2>
			<p><st c="5422">During the</st><a id="_idIndexMarker756"/><st c="5433"> initial phase of the project, we focus on two major </st><span class="No-Break"><st c="5486">security topics:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="5502">Inventory Management</st></strong><st c="5523"> is one </st><a id="_idIndexMarker757"/><st c="5531">of the key elements of security because this catalogizes the applications and services we provide for our customers. </st><st c="5648">It is our </st><strong class="bold"><st c="5658">app catalog</st></strong><st c="5669"> that</st><a id="_idIndexMarker758"/><st c="5674"> contains </st><a id="_idIndexMarker759"/><st c="5684">our applications (</st><strong class="bold"><st c="5702">products</st></strong><st c="5711">) and </st><a id="_idIndexMarker760"/><st c="5718">services (</st><strong class="bold"><st c="5728">service trees</st></strong><st c="5742">) in production and their assets (source code location, released binaries, version numbers, Azure DevOps projects, Azure pipelines, GitHub projects, GitHub workflows, etc.) within our organization. </st><st c="5941">With the help of Inventory Management, we can easily find the application owners of the impacted components in the case of security breaches. </st><st c="6083">Inventory Management is fully automated in organizations with mature DevSecOps processes, which means every time a new project is kicked off, a new catalog item is created that triggers workflows to spin up Azure DevOps or GitHub projects, Git repositories, Microsoft Entra ID groups, service principals, self-hosted agents, pipelines, and </st><span class="No-Break"><st c="6423">so on.</st></span></li>
				<li><strong class="bold"><st c="6429">Access control management</st></strong><st c="6455"> refers</st><a id="_idIndexMarker761"/><st c="6462"> to the access to the application artifacts and, respectively, the underlying DevOps tools from an engineering perspective. </st><st c="6586">We need to define the framework</st><a id="_idIndexMarker762"/><st c="6617"> and the </st><strong class="bold"><st c="6626">identity and access management</st></strong><st c="6656"> (</st><strong class="bold"><st c="6658">IAM</st></strong><st c="6661">) solution that we will use to give access to product owners, engineers, testers, architects, release managers, and ops teams while they interact with development projects. </st><st c="6835">We also need to define how we are going to deal with conditional access policies, such as</st><a id="_idIndexMarker763"/><st c="6924"> enforcing </st><strong class="bold"><st c="6935">multi-factor authentication</st></strong><st c="6962"> (</st><strong class="bold"><st c="6964">MFA</st></strong><st c="6967">) when accessing production environments, and to which extent we are going to work with privileged identities</st><a id="_idIndexMarker764"/><st c="7077"> in </st><strong class="bold"><st c="7081">privileged identity management</st></strong><st c="7111"> (</st><strong class="bold"><st c="7113">PIM</st></strong><st c="7116">), for instance, to provide just-in-time privileged access to Microsoft Entra ID and Azure resources for high privileged users or global administrators. </st><st c="7270">When PIM is enabled, these highly privileged activities are monitored and </st><a id="_idIndexMarker765"/><st c="7344">audited, too. </st><st c="7358">It is worth noting that this access control is not the one that our application or service to be developed will use for authentication </st><span class="No-Break"><st c="7493">and authorization.</st></span></li>
			</ul>
			<h2 id="_idParaDest-115"><a id="_idTextAnchor121"/><st c="7511">Plan and Design</st></h2>
			<p><st c="7527">After</st><a id="_idIndexMarker766"/><st c="7533"> setting up the project with the appropriate access rights and Inventory Management in place, we delve into the </st><em class="italic"><st c="7645">Plan and Design</st></em><st c="7660"> phase from a </st><span class="No-Break"><st c="7674">security perspective:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="7695">Threat modeling</st></strong><st c="7711"> is </st><a id="_idIndexMarker767"/><st c="7715">used to identify threats to our systems through the view of potential attackers and their probabilities and impacts on our applications before implementing any mitigation. </st><st c="7887">It is a typical risk management process focusing on security. </st><st c="7949">There are several tools available on the market to model threats, such as</st><a id="_idIndexMarker768"/><st c="8022"> the </st><strong class="bold"><st c="8027">Microsoft Threat Modeling Tool</st></strong><st c="8057"> (see the </st><em class="italic"><st c="8067">Further reading</st></em><st c="8082"> section). </st><st c="8093">As part of the sprint planning process, we can conduct threat modeling exercises, and, based on the risk analysis, we can decide whether we should mitigate certain threats and introduce those activities as product backlog items marked with the </st><span class="No-Break"><st c="8337">security category.</st></span></li>
				<li><strong class="bold"><st c="8355">Secure coding standards</st></strong><st c="8379"> are </st><a id="_idIndexMarker769"/><st c="8384">used to define the security coding standards based on our programming languages and technology stacks in our coding guidelines. </st><st c="8512">Nowadays, static code analysis tools can check that our code changes are aligned with our security coding standards in a fully automated way. </st><st c="8654">In C#, for instance, one of the often-used security standards is to use the </st><strong class="source-inline"><st c="8730">SecureString</st></strong><st c="8742"> type to handle credentials in </st><span class="No-Break"><st c="8773">our code.</st></span></li>
				<li><strong class="bold"><st c="8782">The peer review guide</st></strong><st c="8804"> is </st><a id="_idIndexMarker770"/><st c="8808">used to lay down the peer review process: when and how often they will be executed and whether we will involve security experts in the process or not. </st><st c="8959">Nowadays, DevOps processes already prescribe code reviews in case of any pull requests, and DevOps tools support and document the findings </st><span class="No-Break"><st c="9098">in detail.</st></span></li>
				<li><strong class="bold"><st c="9108">Pre-commit hooks</st></strong><st c="9125"> define</st><a id="_idIndexMarker771"/><st c="9132"> what kind of security checks we perform before committing code changes to repositories, for instance, checking commits for secrets before they reach our repositories. </st><st c="9300">Pre-commit hooks can execute only a small subset of static code analysis rulesets because of time constraints, but they are </st><a id="_idIndexMarker772"/><st c="9424">essential parts to immediately block commits to prevent security breaches. </st><st c="9499">We can</st><a id="_idIndexMarker773"/><st c="9505"> use </st><strong class="bold"><st c="9510">IDE security plugins</st></strong><st c="9530"> to execute lightweight security </st><span class="No-Break"><st c="9563">analysis locally.</st></span></li>
			</ul>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor122"/><st c="9580">Commit (CI)</st></h2>
			<p><st c="9592">After passing the</st><a id="_idIndexMarker774"/><st c="9610"> pre-commit hooks and code review results, the next phase is to execute the CI build and the related security activities as part of the pull request </st><span class="No-Break"><st c="9759">validation process:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="9778">Dependency management</st></strong><st c="9800">: Nowadays, custom-developed applications heavily rely on </st><a id="_idIndexMarker775"/><st c="9859">open source packages. </st><st c="9881">On average, 90% of the code in current applications contains components based on external packages or</st><a id="_idIndexMarker776"/><st c="9982"> libraries. </st><st c="9994">The term </st><strong class="bold"><st c="10003">software supply chain management</st></strong><st c="10035"> is very often used, since those packages that we use in our applications also use other third-party components that also use other packages, and the chain goes on in that way. </st><st c="10212">Identifying and exposing vulnerabilities in those third-party packages makes our applications vulnerable unless we refresh our supply chain. </st><st c="10353">Tools such as </st><strong class="bold"><st c="10367">GitHub Dependabot</st></strong><st c="10384"> can</st><a id="_idIndexMarker777"/><st c="10388"> identify the vulnerabilities in our supply chain (</st><em class="italic"><st c="10439">inherited vulnerabilities</st></em><st c="10465">) and automatically create Dependabot alerts with pull requests to submit the changes back to our main branches. </st><st c="10579">Dependabot checks can be executed during </st><span class="No-Break"><st c="10620">CI builds.</st></span></li>
				<li><strong class="bold"><st c="10630">Static application security testing</st></strong><st c="10666"> (</st><strong class="bold"><st c="10668">SAST</st></strong><st c="10672">): This is static code analysis and code scanning </st><a id="_idIndexMarker778"/><st c="10723">for security. </st><st c="10737">There are several tools available on the market that we can use to perform such analyses on our code base, such as SonarCloud, Fortify, or GitHub Advanced Security with CodeQL. </st><st c="10914">These tools can be integrated into our CI pipelines for further customization. </st><st c="10993">The output of static code analysis results are </st><strong class="bold"><st c="11040">Static Analysis Results Interchange Format</st></strong><st c="11082"> (</st><strong class="bold"><st c="11084">SARIF</st></strong><st c="11089">) open standard data. </st><st c="11112">Code scanning alerts</st><a id="_idIndexMarker779"/><st c="11132"> are automatically created based on SARIF results and they can be tracked as backlog items. </st><st c="11224">In the case of the GitHub Enterprise version with Advanced Security, we have also the possibility to use GitHub Copilot to fix our security issues </st><span class="No-Break"><st c="11371">fully automated.</st></span></li>
				<li><strong class="bold"><st c="11387">Security unit and functional testing</st></strong><st c="11424">: These are other ways to maintain the high quality of our code base and to avoid implementing </st><span class="No-Break"><st c="11520">security vulnerabilities.</st></span></li>
				<li><strong class="bold"><st c="11545">Secure pipelines</st></strong><st c="11562">: We need to cautiously care about our automated pipelines from a security point of view: who can access which pipeline, where the pipeline secrets are stored (Azure Key Vault), and whether we can use managed identities to execute workflows because insecure CI/CD pipelines can lead to credential leakage or even to execute malicious code in production environments. </st><st c="11930">During</st><a id="_idIndexMarker780"/><st c="11936"> CI builds, so-called </st><strong class="bold"><st c="11958">software bills of materials</st></strong><st c="11985"> (</st><strong class="bold"><st c="11987">SBOMs</st></strong><st c="11992">) are created to track the components used in the build pipeline. </st><st c="12059">An SBOM is a list of software components with their hierarchical relationships, version numbers, dependencies, and license requirements, usually in JSON format, that </st><a id="_idIndexMarker781"/><st c="12225">build up the application. </st><st c="12251">SBOMs help with the transparency and provenance claims for our supply chain and help with conformance enablement. </st><st c="12365">Hosted pools can be used to build and sign the code, ensuring build integrity and component governance. </st><st c="12469">After a successful build, the code is stored in a secure </st><span class="No-Break"><st c="12526">artifact storage.</st></span></li>
				<li><strong class="bold"><st c="12543">Credential scanning</st></strong><st c="12563">: We</st><a id="_idIndexMarker782"/><st c="12568"> can use tools to scan our code base for plain text credentials to lower the risk of </st><span class="No-Break"><st c="12653">credential stealing.</st></span></li>
			</ul>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor123"/><st c="12673">Deploy (CD)</st></h2>
			<p><st c="12685">In this stage, we</st><a id="_idIndexMarker783"/><st c="12703"> look at the overall health of the code base, in addition to the items checked in the Commit stage (which can be repeated in the deploy stage as well). </st><st c="12855">We introduce additional security checks during the </st><span class="No-Break"><st c="12906">release process:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="12922">Dynamic application security testing</st></strong><st c="12959"> (</st><strong class="bold"><st c="12961">DAST</st></strong><st c="12965">) is a technique used to evaluate</st><a id="_idIndexMarker784"/><st c="12999"> the security of a software application in its running state. </st><st c="13061">It involves the use of DAST tools to conduct simulated cyber-attacks on web applications while they are operational, identifying vulnerabilities such as SQL injection, cross-site scripting, and insecure configurations. </st><st c="13280">This form of security testing emulates the actions of a malicious attacker to uncover security weaknesses within the live application, enabling developers to address these issues prior to the application’s release to </st><span class="No-Break"><st c="13497">the public.</st></span></li>
				<li><strong class="bold"><st c="13508">Cloud configuration validation</st></strong><st c="13539"> is the process of verifying that the configuration</st><a id="_idIndexMarker785"/><st c="13590"> of cloud resources is correct, secure, and compliant with best practices and policies. </st><st c="13678">This can be done through automated tools that scan the configuration files and settings of cloud resources and report any issues or violations (such as configuration changes in production, and discrepancies between </st><a id="_idIndexMarker786"/><st c="13893">the IaC scripts and the running configuration). </st><st c="13941">Validation can help prevent misconfigurations, security vulnerabilities, and compliance issues, and ensure that cloud resources are set up and </st><span class="No-Break"><st c="14084">managed correctly.</st></span></li>
				<li><strong class="bold"><st c="14102">Infrastructure-as-code</st></strong><st c="14125"> (</st><strong class="bold"><st c="14127">IaC</st></strong><st c="14130">) </st><strong class="bold"><st c="14133">scanning</st></strong><st c="14141"> is the process of analyzing IaC files for</st><a id="_idIndexMarker787"/><st c="14183"> security vulnerabilities, misconfigurations, and compliance with best practices and policies. </st><st c="14278">IaC scanning tools can detect policy violations and suggest fixes for any violations detected. </st><st c="14373">Even LLM-based tools can be used to prompt a GPT-4 model to detect policy violations in IaC files and suggest fixes for any violation detections. </st><st c="14519">The violations and fixes are reported in a </st><span class="No-Break"><st c="14562">SARIF file.</st></span></li>
				<li><strong class="bold"><st c="14573">Security acceptance testing</st></strong><st c="14601"> is the process of verifying that a system meets the defined</st><a id="_idIndexMarker788"/><st c="14661"> security requirements and standards before it is released or deployed. </st><st c="14733">This type of testing is typically performed on new systems, upgrades, or deployments and includes the testing of information security requirements and adherence to secure system development practices. </st><st c="14934">Acceptance testing activities may be performed on individual components or integrated systems, and validation activities may be performed using test environments to ensure that the system will not introduce vulnerabilities. </st><st c="15158">Care must be taken when selecting test data or data from information systems that are operational to ensure that no personally identifiable information, secret data such as passwords, or hashes are captured in </st><span class="No-Break"><st c="15368">that dataset.</st></span></li>
			</ul>
			<p><st c="15381">After successful deployments to test and later to production environments, the SBOM and evidence storage are used to track </st><span class="No-Break"><st c="15505">the releases.</st></span></p>
			<h2 id="_idParaDest-118"><a id="_idTextAnchor124"/><st c="15518">Operate and Monitor</st></h2>
			<p><st c="15538">In this stage, after </st><a id="_idIndexMarker789"/><st c="15560">successfully releasing our application to production, we need to focus on the following </st><span class="No-Break"><st c="15648">security-infused activities:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="15676">Continuous monitoring</st></strong><st c="15698"> is </st><a id="_idIndexMarker790"/><st c="15702">the process of continuously tracking, assessing, and reviewing the security controls and risks of an information system. </st><st c="15823">This process helps to ensure that the security controls remain effective over time and that any changes to the system or its environment do not introduce new vulnerabilities. </st><st c="15998">Continuous monitoring can be achieved by automated tools and processes that collect and analyze data from various sources, such as logs, network traffic, and system configurations. </st><st c="16179">This data is then used to identify potential security issues and to generate alerts or reports that can be used to improve the security of </st><span class="No-Break"><st c="16318">the system.</st></span></li>
				<li><strong class="bold"><st c="16329">Audit logs</st></strong><st c="16340"> are </st><a id="_idIndexMarker791"/><st c="16345">monitored for security detections. </st><st c="16380">Admin monitoring and scanning are performed to ensure the security of the system. </st><st c="16462">We can consider the audit logs of our solutions, as our DevOps tools as well. </st><st c="16540">Audit logs are essential to understand and detect changes that might come from </st><span class="No-Break"><st c="16619">suspicious sources.</st></span></li>
				<li><strong class="bold"><st c="16638">Threat intelligence</st></strong><st c="16658"> is the</st><a id="_idIndexMarker792"/><st c="16665"> practice of collecting, analyzing, and disseminating information about current and potential cybersecurity threats. </st><st c="16782">It assists organizations in proactively detecting and addressing security threats. </st><st c="16865">Microsoft Threat Intelligence is a cloud service that uses machine learning algorithms on the collected signals globally to detect and mitigate security risks. </st><st c="17025">This infrastructure is used to support Azure services, traditional products, endpoints (devices), and other corporate assets. </st><st c="17151">It is designed to protect the global infrastructure that powers services such as Microsoft Azure and Power Platform. </st><strong class="bold"><st c="17268">Security incident and event management</st></strong><st c="17306"> (</st><strong class="bold"><st c="17308">SIEM</st></strong><st c="17312">) tools, such </st><a id="_idIndexMarker793"/><st c="17327">as Microsoft Sentinel or Microsoft Defender for Cloud, use audit logs to detect anomalies and unusual patterns by leveraging different machine </st><span class="No-Break"><st c="17470">learning algorithms.</st></span></li>
				<li><strong class="bold"><st c="17490">Blameless post-mortems</st></strong><st c="17513"> are the process of analyzing incidents or failures in a non-punitive</st><a id="_idIndexMarker794"/><st c="17582"> manner, with the goal of identifying the root causes and improving systems and processes to prevent similar incidents from happening again. </st><st c="17723">The focus is on learning and improving, rather than assigning blame or punishment. </st><st c="17806">Blameless post-mortems encourage open and honest communication, allowing team members to share their mistakes and learn from them</st><a id="_idIndexMarker795"/><st c="17935"> without fear of retribution. </st><st c="17965">This approach fosters a culture of continuous improvement and helps teams to build more </st><span class="No-Break"><st c="18053">resilient systems.</st></span></li>
			</ul>
			<p><st c="18071">We will see in the upcoming sections which of these activities we can apply for Power Platform solutions and which of these tasks are provided by the ops teams of the Power Platform </st><span class="No-Break"><st c="18254">SaaS offering.</st></span></p>
			<p><st c="18268">Let’s now move on to the security model of Power Platform and learn about its security design </st><span class="No-Break"><st c="18363">and principles.</st></span></p>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor125"/><st c="18378">Security model of Power Platform</st></h1>
			<p><st c="18411">Microsoft Power Platform runs on </st><a id="_idIndexMarker796"/><st c="18445">Microsoft Azure, and it benefits from all the security PaaS services available in the hyperscaler, such as Microsoft Sentinel, Microsoft Defender for Cloud, the comprehensive audit logs of Microsoft Entra, and </st><span class="No-Break"><st c="18655">much more.</st></span></p>
			<p><st c="18665">The </st><a id="_idIndexMarker797"/><st c="18670">security model of Microsoft Power Platform is built on the principle of </st><strong class="bold"><st c="18742">least privileged access</st></strong><st c="18765"> (</st><strong class="bold"><st c="18767">LPA</st></strong><st c="18770">), which</st><a id="_idIndexMarker798"/><st c="18779"> facilitates the creation of applications with finer access control levels. </st><st c="18855">Power Platform leverages the Microsoft Identity Platform for the authorization of all API requests, utilizing the widely recognized OAuth 2.0 protocol. </st><st c="19007">Additionally, Dataverse, which serves as the foundational data layer for Power Platform, boasts a comprehensive security model that encompasses security at the environmental level, role-based, and record- and field-level security, security roles, and business units and teams through security groups and application users, as we learned about in </st><a href="B22208_04.xhtml#_idTextAnchor074"><span class="No-Break"><em class="italic"><st c="19353">Chapter 4</st></em></span></a><span class="No-Break"><st c="19362">.</st></span></p>
			<p><st c="19363">Additionally, Power Platform is built in distinct environments, which are containers of our apps, flows, connections, and other components along with security and data access management capabilities in geographic locations defined at the creation of </st><span class="No-Break"><st c="19614">those environments.</st></span></p>
			<p><st c="19633">The architecture of Power Platform is based on the zero-trust security principle, the </st><em class="italic"><st c="19720">never trust, always verify</st></em><st c="19746"> philosophy. </st><st c="19759">A </st><strong class="bold"><st c="19761">zero-trust strategy</st></strong><st c="19780"> prescribes strict identity verification for every user and </st><a id="_idIndexMarker799"/><st c="19840">device regardless of their location (corporate or external perimeter), and this check happens every time corporate resources are to be accessed. </st><st c="19985">This approach is realized with the help of Microsoft Identity Platform and the capabilities of Microsoft Entra ID. </st><st c="20100">Every call going to Power Platform service endpoints requires a valid access token (bearer token) to get that endpoint executed. </st><st c="20229">On the server side, the access token is sent to the identity provider (to Microsoft Entra ID to check its validity) every time a request hits the endpoints. </st><st c="20386">These digitally signed access tokens contain claims about the caller that are used for authentication and authorization purposes. </st><st c="20516">After identifying our caller, Power Platform will determine its authorization level in conjunction with that endpoint. </st><st c="20635">Here, custom and built-in security roles, the business unit hierarchy, and team assignments are considered </st><span class="No-Break"><st c="20742">application-level authorizations.</st></span></p>
			<p><st c="20775">The following figure </st><a id="_idIndexMarker800"/><st c="20797">shows the architecture of Power Platform within one Microsoft </st><span class="No-Break"><st c="20859">Azure region:</st></span></p>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/B22208_07_2.jpg" alt="Figure 7.2 – Power Platform architecture"/><st c="20872"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="21283">Figure 7.2 – Power Platform architecture</st></p>
			<p><st c="21323">A cluster of web </st><a id="_idIndexMarker801"/><st c="21341">frontend servers contains ASP.NET sites hosted within the Azure App Service Environment. </st><st c="21430">An App Service Environment</st><a id="_idIndexMarker802"/><st c="21456"> provides the underlying, dedicated compute units on which App Service Plans are deployed. </st><st c="21547">App Service Plans can host one or more applications (websites). </st><st c="21611">These are part of Azure App Service. </st><st c="21648">When accessing a Power Platform service or app, the client’s DNS is used to direct the request to the closest data center, as determined by Azure Traffic Manager. </st><st c="21811">Azure Traffic Manager provides several options for routing and load-balancing at layer 4 in the OSI model, such as performance routing (closest endpoint by latency), weighted round-robin, and geography-based routing (closest endpoint by </st><span class="No-Break"><st c="22048">geographical location).</st></span></p>
			<p><st c="22071">The frontend cluster is responsible for handling the sign-in and authentication process. </st><st c="22161">Once a user is verified, they receive a Microsoft Entra ID access token (OAuth2 token). </st><st c="22249">The ASP.NET system examines the token to identify the user’s organization (Azure App Registrations are used internally with the account type </st><em class="italic"><st c="22390">Multitenant</st></em><st c="22401"> behind the scene). </st><st c="22421">It then communicates with the Power Platform global backend service to inform the browser of the specific backend cluster where the organization’s tenant resides. </st><st c="22584">All further interactions between the client and the backend cluster happen directly, bypassing the </st><span class="No-Break"><st c="22683">web frontend.</st></span></p>
			<p><st c="22696">For static resources such as JavaScript, CSS, and image files, the browser typically retrieves them </st><a id="_idIndexMarker803"/><st c="22797">from </st><strong class="bold"><st c="22802">Azure Content Delivery </st></strong><span class="No-Break"><strong class="bold"><st c="22825">Network</st></strong></span><span class="No-Break"><st c="22832"> (</st></span><span class="No-Break"><strong class="bold"><st c="22834">CDN</st></strong></span><span class="No-Break"><st c="22837">).</st></span></p>
			<p><st c="22840">The backbone of </st><a id="_idIndexMarker804"/><st c="22857">Power Platform services is running</st><a id="_idIndexMarker805"/><st c="22891"> in the </st><strong class="bold"><st c="22899">backend clusters</st></strong><st c="22915">, which provide service endpoints, background services, databases, caches, and various other elements. </st><st c="23018">The backend clusters span numerous Azure regions. </st><st c="23068">A single region may accommodate multiple clusters (represented as </st><strong class="bold"><st c="23134">Scale Group</st></strong><st c="23145"> in the previous figure), enabling the Power Platform services to scale horizontally beyond the vertical and horizontal scaling capacities of an </st><span class="No-Break"><st c="23290">individual cluster.</st></span></p>
			<p><st c="23309">These backend clusters are designed to be </st><em class="italic"><st c="23352">stateful</st></em><st c="23360">, hosting the complete dataset for all the tenants they serve. </st><st c="23423">The specific cluster storing a tenant’s data is known as that tenant’s primary cluster. </st><st c="23511">The Power Platform global backend service provides details about a user’s primary cluster to the web frontend cluster, which then directs requests to the appropriate home backend cluster. </st><em class="italic"><st c="23699">Every environment resides within a scale group</st></em><st c="23745">, which is a collective infrastructure designed to offer a scalable and maintainable set of resources. </st><st c="23848">A scale group accommodates numerous customer organizations, each possessing its own database while sharing the service infrastructure. </st><st c="23983">This setup leverages a variety of Azure services, such as Azure SQL, Azure Virtual Machines, and Azure Cache for Redis. </st><st c="24103">These scale groups are established in pairs corresponding to the region chosen by the customer. </st><st c="24199">For instance, opting for the United States as the region results in the formation of scale groups in both the West US and East US regions. </st><st c="24338">While tenant metadata and data typically reside within the cluster, there is an exception for data replication to a secondary backend cluster located in a paired region within the same Azure geography. </st><st c="24540">This secondary cluster acts as a contingency during regional disruptions, remaining inactive otherwise. </st><st c="24644">Additionally, microservices dispersed across various machines within the cluster’s virtual network contribute to the </st><span class="No-Break"><st c="24761">backend’s functionality.</st></span></p>
			<p><st c="24785">DevSecOps processes and activities are realized and operated by the Power Platform product teams, and we embrace those as part </st><a id="_idIndexMarker806"/><st c="24913">of this </st><strong class="bold"><st c="24921">Software-as-a-Service</st></strong><st c="24942"> (</st><strong class="bold"><st c="24944">SaaS</st></strong><st c="24948">) offering. </st><st c="24961">This means that the product engineering teams have established controls and guardrails starting with Inventory Management, access control, pre-commit hooks, peer review, SAST and DAST analysis, secure pipelines, IaC scanning, and dependency analysis through threat intelligence on their development processes. </st><st c="25271">This approach is audited and certified by third-party independent auditors on a regular basis. </st><st c="25366">During the development process, these teams use Microsoft SDL for coding best practices and threat modeling, too. </st><st c="25480">This leads to the conclusion that we need to focus on only the customization and extensibility points of the platform since these are the</st><a id="_idIndexMarker807"/><st c="25617"> places where we can introduce </st><a id="_idIndexMarker808"/><st c="25648">vulnerabilities in our solutions. </st><st c="25682">These include but not limited to </st><span class="No-Break"><st c="25715">the following:</st></span></p>
			<ul>
				<li><st c="25729">Environment </st><span class="No-Break"><st c="25742">access management</st></span></li>
				<li><st c="25759">Custom-developed </st><strong class="bold"><st c="25777">Power Apps Component Framework</st></strong><st c="25807"> (</st><span class="No-Break"><strong class="bold"><st c="25809">PCF</st></strong></span><span class="No-Break"><st c="25812">) components</st></span></li>
				<li><st c="25825">Dataverse custom workflow activities and Dataverse web resources (HTML </st><span class="No-Break"><st c="25897">and JavaScript)</st></span></li>
				<li><st c="25912">Dataverse configurations and Dataverse </st><span class="No-Break"><st c="25952">custom-developed plugins</st></span></li>
				<li><st c="25976">Power </st><span class="No-Break"><st c="25983">Fx expressions</st></span></li>
				<li><st c="25997">Power Pages custom code (HTML, JavaScript, </st><span class="No-Break"><st c="26041">and Liquid)</st></span></li>
				<li><st c="26052">Our own DevOps processes with automation scripts </st><span class="No-Break"><st c="26102">for CI/CD</st></span></li>
				<li><st c="26111">Solution and </st><span class="No-Break"><st c="26125">Inventory Management</st></span></li>
				<li><st c="26145">Fusion architecture components in </st><span class="No-Break"><st c="26180">Microsoft Azure</st></span></li>
			</ul>
			<p><st c="26195">After understanding the security model of Power Platform and the benefits of this SaaS product from a security perspective, let us learn more about the tools we can use for static code analysis, dependency checks, and </st><span class="No-Break"><st c="26414">secret scanning.</st></span></p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor126"/><st c="26430">Secret scanning and static code analysis tools</st></h1>
			<p><st c="26477">Although there are many other SAST tools on the market, </st><strong class="bold"><st c="26534">GitHub Advanced Security</st></strong><st c="26558"> (</st><strong class="bold"><st c="26560">GHAS</st></strong><st c="26564">) provides </st><a id="_idIndexMarker809"/><st c="26576">the most comprehensive feature set for static security code analysis together with Copilot security support. </st><st c="26685">GHAS features </st><a id="_idIndexMarker810"/><st c="26699">are the following for private </st><span class="No-Break"><st c="26729">GitHub repositories:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="26749">Code scanning</st></strong><st c="26763"> uses </st><strong class="bold"><st c="26769">CodeQL</st></strong><st c="26775"> or other </st><a id="_idIndexMarker811"/><st c="26785">tools of your flavor to find vulnerabilities </st><a id="_idIndexMarker812"/><st c="26830">and coding errors. </st><st c="26849">Results are stored in SARIF format, and they are managed at a repository level </st><span class="No-Break"><st c="26928">in GitHub.</st></span></li>
				<li><strong class="bold"><st c="26938">CodeQL CLI</st></strong><st c="26949"> is a standalone</st><a id="_idIndexMarker813"/><st c="26965"> tool that we can use to scan our code base for vulnerabilities and coding errors. </st><st c="27048">The </st><strong class="bold"><st c="27052">CodeQL CLI</st></strong><st c="27062"> is used in conjunction with the previous point (code scanning), or we can use it in other DevOps tools, such as GitLab </st><span class="No-Break"><st c="27182">or Jenkins.</st></span></li>
				<li><strong class="bold"><st c="27193">Secret scanning</st></strong><st c="27209"> looks </st><a id="_idIndexMarker814"/><st c="27216">for secrets, keys, and sensitive tokens in your code base. </st><strong class="bold"><st c="27275">Pre-commit hooks</st></strong><st c="27291"> are also available to block local commits </st><a id="_idIndexMarker815"/><st c="27334">before reaching the repository and creating a new </st><span class="No-Break"><st c="27384">history record.</st></span></li>
				<li><strong class="bold"><st c="27399">Custom auto-triage rules</st></strong><st c="27424"> assist</st><a id="_idIndexMarker816"/><st c="27431"> in orchestrating</st><a id="_idIndexMarker817"/><st c="27448"> your </st><strong class="bold"><st c="27454">Dependabot alerts</st></strong><st c="27471"> on a large scale. </st><st c="27490">With custom auto-triage rules, you can determine which alerts to disregard, postpone, or initiate a Dependabot security </st><span class="No-Break"><st c="27610">update for.</st></span></li>
				<li><strong class="bold"><st c="27621">Dependency review</st></strong><st c="27639"> helps us </st><a id="_idIndexMarker818"/><st c="27649">to catch insecure dependencies before we introduce them</st><a id="_idIndexMarker819"/><st c="27704"> in our repositories, and provides information on licenses, dependents, and age </st><span class="No-Break"><st c="27784">of dependencies.</st></span></li>
			</ul>
			<p><st c="27800">These advanced security features are available in every public GitHub repository without any </st><span class="No-Break"><st c="27894">additional fee.</st></span></p>
			<p><st c="27909">GHAS for Azure DevOps became generally available in September 2023. </st><st c="27978">The same code scanning, secret scanning, and dependency scanning features are available in this product as in GitHub Enterprise. </st><st c="28107">The GitHub engineering team has shared this feature set with Azure DevOps teams in the same way as, a few years ago, the Azure DevOps team provided the build agent (hosted runners) functionality to the GitHub </st><span class="No-Break"><st c="28316">product group.</st></span></p>
			<p class="callout-heading"><st c="28330">Which tool, when?</st></p>
			<p class="callout"><st c="28348">We can use GHAS for Azure DevOps only for Azure Git repositories. </st><st c="28415">If we have a GitHub repository attached to Azure DevOps pipelines, we need to use GHAS on the GitHub side. </st><st c="28522">Build tasks for GHAS for Azure DevOps will </st><span class="No-Break"><st c="28565">not work.</st></span></p>
			<p><st c="28574">GHAS is based on </st><a id="_idIndexMarker820"/><st c="28592">the </st><strong class="bold"><st c="28596">Code Query Language</st></strong><st c="28615"> (</st><strong class="bold"><st c="28617">CodeQL</st></strong><st c="28623">), which can be used to build up code analysis databases on different programming languages. </st><st c="28717">CodeQL supports C, C++, C#, Java, Go, Kotlin, JavaScript, Python, Ruby, Swift and TypeScript. </st><st c="28811">CodeQL approaches code as data, enabling the discovery of potential security flaws with more assurance than conventional static analysis tools. </st><st c="28955">By creating a CodeQL database that mirrors your code base, you can execute CodeQL queries against this database to pinpoint issues within your code. </st><st c="29104">The query results are shown as </st><em class="italic"><st c="29135">code scanning alerts</st></em><st c="29155"> in GitHub and Azure DevOps when you use CodeQL with </st><span class="No-Break"><st c="29208">code scanning.</st></span></p>
			<p><st c="29222">CodeQL creates a relational database under the hood. </st><st c="29276">Every language has its own schema and CodeQL </st><a id="_idIndexMarker821"/><st c="29321">uses </st><strong class="bold"><st c="29326">extractors</st></strong><st c="29336"> (unique for every language) to read the code files and compiled binaries (except for script languages) and builds up a hierarchical representation of code expressions, abstract syntax tree, data flow graph, and control flow graph. </st><st c="29568">These building blocks are stored in the database and security queries are executed against these tables to find language-specific vulnerabilities and coding errors. </st><st c="29733">CodeQL’s databases are snapshots taken from the time when we executed the analysis. </st><st c="29817">GitHub provides query packs for any supported languages. </st><strong class="bold"><st c="29874">Query packs</st></strong><st c="29885"> consist</st><a id="_idIndexMarker822"/><st c="29893"> of </st><strong class="bold"><st c="29897">CodeQL suites</st></strong><st c="29910"> (</st><strong class="bold"><st c="29912">qls</st></strong><st c="29915">) that</st><a id="_idIndexMarker823"/><st c="29922"> are sets of query language files (</st><strong class="bold"><st c="29957">ql files</st></strong><st c="29966">). </st><st c="29970">These query suites help us to immediately benefit from the security knowledge and expertise of GitHub and to get these code scanning rules executed on our code base. </st><st c="30136">We can also write our own queries using Visual Studio Code and the CodeQL extension and we can derive from existing query suites to introduce our additional checks (the Windows Driver Validation Team did this to introduce their own custom </st><span class="No-Break"><st c="30375">rules:</st></span><span class="No-Break"><span class="P---URL"> </span></span><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/static-tools-and-codeql"><span class="No-Break"><st c="30381">https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/static-tools-and-codeql</st></span></a><span class="No-Break"><st c="30471">).</st></span></p>
			<p><st c="30474">The CodeQL CLI is part of the GHAS offering, and it is free of charge for students and academics. </st><st c="30573">CodeQL CLI as a standalone tool supports macOS, Linux, and Windows operating systems and we can download it as binaries (see the link in </st><span class="No-Break"><em class="italic"><st c="30710">Further reading</st></em></span><span class="No-Break"><st c="30725">).</st></span></p>
			<p><st c="30728">We can use the CodeQL CLI to execute code analysis even locally, on our Azure DevOps build agents, or on our </st><span class="No-Break"><st c="30838">GitHub runners.</st></span></p>
			<p><st c="30853">Both Azure DevOps and GitHub offer build tasks and actions around the CodeQL CLI to easily integrate code scanning capabilities in our existing pipelines </st><span class="No-Break"><st c="31008">and workflows:</st></span></p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/B22208_07_3.jpg" alt="Figure 7.3 – CodeQL CLI wrappers in DevOps tools"/><st c="31022"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="31065">Figure 7.3 – CodeQL CLI wrappers in DevOps tools</st></p>
			<p><st c="31113">Since </st><a id="_idIndexMarker824"/><st c="31120">there are numerous places in Power Platform where we can introduce custom code, it is recommended to have firsthand knowledge of how to use the CodeQL CLI and how to set up pipelines and workflows to execute the different query packs. </st><st c="31355">The best place to </st><a href="https://github.com/microsoft/PowerApps-Samples"><st c="31373">fin</st><span id="_idTextAnchor127"/><st c="31376">d custom code for Power Platform is the </st><strong class="source-inline"><st c="31417">Pow</st></strong></a><strong class="source-inline"><st c="31420">erApps-Samples</st></strong><st c="31435"> repository at </st><a href="https://github.com/microsoft/PowerApps-Samples"><st c="31450">https://github.com/microsoft/PowerApps-Samples</st></a><st c="31496">. Let us check the custom </st><strong class="bold"><st c="31522">JavaScript</st></strong><st c="31532"> (</st><strong class="bold"><st c="31534">JS</st></strong><st c="31536">) and </st><strong class="bold"><st c="31543">TypeScript</st></strong><st c="31553"> (</st><strong class="bold"><st c="31555">T</st><a id="_idTextAnchor128"/><st c="31556">S</st></strong><st c="31557">) files</st><a id="_idIndexMarker825"/><st c="31564"> for vulnerabilities using the following commands </st><a id="_idIndexMarker826"/><st c="31614">in PowerShell (</st><strong class="source-inline"><st c="31629">runcodeql_javascript.ps1</st></strong><st c="31654"> in the GitHub repo of </st><span class="No-Break"><st c="31677">this chapter):</st></span></p>
			<ol>
				<li><st c="31691">We can download the CodeQL CLI binaries (see </st><em class="italic"><st c="31737">Further reading</st></em><st c="31752"> | </st><em class="italic"><st c="31755">CodeQL CLI Binaries</st></em><st c="31774">) and add the unpacked folder location to our </st><span class="No-Break"><st c="31821">environment path.</st></span></li>
				<li><st c="31838">We then clone the repo and navigate to the </st><span class="No-Break"><st c="31882">target folder:</st></span><pre class="source-code">
<strong class="bold"><st c="31896">git clone https://github.com/microsoft/PowerApps-Samples</st></strong></pre></li>				<li><st c="31953">Let us download the query pack for JavaScript </st><span class="No-Break"><st c="32000">and TypeScript:</st></span><pre class="source-code">
<strong class="bold"><st c="32015">codeql.exe pack download codeql/javascript-queries --dir ./codeql-pack/javascript</st></strong></pre></li>				<li><st c="32097">Let us create our CodeQL database for JavaScript/TypeScript (there is only one extractor for JS/TS </st><span class="No-Break"><st c="32197">in place):</st></span><pre class="source-code">
<strong class="bold"><st c="32207">codeql.exe database create --language=javascript --source-root . </st><st c="32273">codeql-database-js --overwrite</st></strong></pre></li>				<li><st c="32303">We now </st><a id="_idIndexMarker827"/><st c="32311">execute one of the query suites available in </st><strong class="source-inline"><st c="32356">codeql-pack</st></strong><st c="32367"> and export the results in a </st><span class="No-Break"><st c="32396">CSV file:</st></span><pre class="source-code"><st c="32405">
codeql.exe database analyze .\codeql-database-js .\codeql-pack\javascript\codeql\javascript-queries\0.8.12\codeql-suites\</st><strong class="bold"><st c="32527">javascript-code-scanning.qls</st></strong><st c="32556"> --format=csv --output=results.csv</st></pre></li>				<li><st c="32590">Of course, we can analyze the code and get the results in </st><span class="No-Break"><st c="32649">SARIF format:</st></span><pre class="source-code">
<strong class="bold"><st c="32662">codeql.exe database analyze .\codeql-database-js .\codeql-pack\javascript\codeql\javascript-queries\0.8.12\codeql-suites\javascript-code-scanning.qls --format=sarif-latest --sarif-category=javascript --output=javascript.sarif</st></strong></pre></li>				<li><st c="32888">We can use </st><strong class="source-inline"><st c="32900">codeql github upload-results</st></strong><st c="32928"> to upload our SARIF file to one of our GitHub repositories (we cannot upload back the results to the original repository due to lack of privileges). </st><st c="33078">We need to create a PAT token that grants us access to the </st><span class="No-Break"><st c="33137">repo (</st></span><span class="No-Break"><strong class="source-inline"><st c="33143">security_event</st></strong></span><span class="No-Break"><st c="33158">):</st></span><pre class="source-code"><st c="33161">
# Upload results to GitHub repository
$env:GH_PAT = "ghp_PAT TOKEN"
$env:GH_PAT | &amp; codeql.exe github upload-results `
          --repository=ourrepo/test `
          --ref=refs/heads/main `
          --commit 18cd21585b94dd16c48dc13bc1365269696a75a4 `
          --sarif=javascript.sarif --github-auth-stdin</st></pre><p class="list-inset"><st c="33429">We also need to have a commit hash ID to which we upload the </st><span class="No-Break"><st c="33491">SARIF result.</st></span></p></li>			</ol>
			<p><st c="33504">In the case of C# projects and solutions, the CodeQL commands are a little bit different. </st><st c="33595">For instance, when </st><a id="_idIndexMarker828"/><st c="33614">we need to implement Dataverse plugins, we can use the C# query pack but, in this case, we need also to build our Visual Studio projects during the analysis (see </st><strong class="source-inline"><st c="33776">runcodeql_dotnet.ps1</st></strong><st c="33796"> in the </st><strong class="source-inline"><st c="33804">Chapter07</st></strong><st c="33813"> folder of the </st><span class="No-Break"><st c="33828">GitHub repo):</st></span></p>
			<pre class="source-code"><st c="33841">
codeql.exe pack download codeql/csharp-queries --dir ./codeql-pack/csharp
codeql.exe database create --language=csharp --source-root . </st><st c="33977">codeql-database </st><strong class="bold"><st c="33993">--command "dotnet build .\dataverse\DiscoveryService\DiscoveryService.sln"</st></strong><st c="34067"> --overwrite
codeql.exe database analyze .\codeql-database .\codeql-pack\csharp\codeql\csharp-queries\0.8.12\codeql-suites\csharp-code-scanning.qls --format=csv --output=csharp-results.csv</st></pre>			<p><st c="34255">We use the </st><strong class="source-inline"><st c="34267">--command</st></strong><st c="34276"> argument to create a database for one or more compiled languages. </st><st c="34343">It expects the </st><strong class="source-inline"><st c="34358">build</st></strong><st c="34363"> command that builds our solution, such as </st><strong class="source-inline"><st c="34406">dotnet build &lt;&lt;path to the sln file&gt;&gt;</st></strong><st c="34443">. We do not need this option if we are working with Python </st><span class="No-Break"><st c="34502">or TS/JS.</st></span></p>
			<p><st c="34511">In the case of </st><a id="_idIndexMarker829"/><st c="34527">large code bases, we can use the following tricks to optimize CodeQL </st><span class="No-Break"><st c="34596">run durations:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="34610">Query packs</st></strong><st c="34622">: We</st><a id="_idIndexMarker830"/><st c="34627"> can create our own query packs derived from the publicly available ones and we can create our own query suites to focus on different code scanning and security scanning analyses depending on the time we have in our pipelines. </st><st c="34854">For example, during the pull request validation build, we would like to minimize the execution time of the analysis by focusing on the most critical security vulnerabilities, whereas building the main branch would execute every available </st><span class="No-Break"><st c="35092">query suite.</st></span></li>
				<li><strong class="bold"><st c="35104">Optional threads parameter in </st></strong><strong class="source-inline"><st c="35135">codeql database analyze</st></strong><st c="35158">: We can use the </st><strong class="source-inline"><st c="35176">--thread</st></strong><st c="35184"> parameter </st><a id="_idIndexMarker831"/><st c="35195">if we want to use more than one thread to run queries. </st><st c="35250">The default value is </st><strong class="source-inline"><st c="35271">1</st></strong><st c="35272">, which means the analysis runs only in one thread. </st><st c="35324">We can specify more threads to speed up query execution. </st><st c="35381">To set the number of threads to the number of logical processors, we specify </st><strong class="source-inline"><st c="35458">0</st></strong><st c="35459"> to </st><span class="No-Break"><st c="35463">this argument.</st></span></li>
				<li><strong class="bold"><st c="35477">CodeQL execution targeting only part of our code base</st></strong><st c="35531">: Ideally, we can have pull request pipelines/workflows that contain not just the trigger condition of whether the pull request happens but </st><a id="_idIndexMarker832"/><st c="35672">also </st><strong class="bold"><st c="35677">path filters</st></strong><st c="35689"> for the changes in the source</st><a id="_idIndexMarker833"/><st c="35719"> code. </st><st c="35726">With that, CodeQL can be executed for only the portion of the code, namely, the area in the source hierarchy that has </st><span class="No-Break"><st c="35844">been changed.</st></span></li>
			</ul>
			<p><st c="35857">Finally, we delve into the Azure pipeline build tasks available</st><a id="_idIndexMarker834"/><st c="35921"> in </st><strong class="bold"><st c="35925">Azure DevOps for GHAS</st></strong><st c="35946"> (see </st><strong class="source-inline"><st c="35952">.pipelines/codeql.yml</st></strong><st c="35973"> in the </st><strong class="source-inline"><st c="35981">Chapter07</st></strong><st c="35990"> folder of the </st><span class="No-Break"><st c="36005">GitHub repo):</st></span></p>
			<ol>
				<li><st c="36018">Let us</st><a id="_idIndexMarker835"/><st c="36025"> import </st><a href="https://github.com/microsoft/PowerApps-Samples"><st c="36033">https://github.com/microsoft/PowerApps-Samples</st></a><st c="36079"> into one of our Azure DevOps projects. </st><st c="36119">We need to go to </st><strong class="bold"><st c="36136">Repos</st></strong><st c="36141"> and click the drop-down list containing all repositories in the project where we will find the </st><strong class="bold"><st c="36237">Import repository</st></strong> <span class="No-Break"><st c="36254">action item:</st></span></li>
			</ol>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/B22208_07_4.jpg" alt="Figure 7.4 – Import a Git repository"/><st c="36267"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="36429">Figure 7.4 – Import a Git repository</st></p>
			<p class="list-inset"><st c="36465">Here, we can add the URL to the GitHub public repo and </st><span class="No-Break"><st c="36521">import </st></span><span class="No-Break"><strong class="source-inline"><st c="36528">PowerApps-Samples</st></strong></span><span class="No-Break"><st c="36545">.</st></span></p>
			<ol>
				<li value="2"><st c="36546">Enable the </st><strong class="bold"><st c="36558">Advanced Security</st></strong><st c="36575"> feature by opening the project settings (project administrator rights are required) and then selecting the recently imported repository. </st><st c="36713">We </st><a id="_idIndexMarker836"/><st c="36716">need to enable </st><strong class="bold"><st c="36731">Advanced Security</st></strong><st c="36748"> by toggling </st><span class="No-Break"><st c="36761">the button:</st></span></li>
			</ol>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/B22208_07_5.jpg" alt="Figure 7.5 – Turning on the Advanced Security feature in Azure DevOps"/><st c="36772"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="37430">Figure 7.5 – Turning on the Advanced Security feature in Azure DevOps</st></p>
			<ol>
				<li value="3"><st c="37499">After enabling this security feature, we can navigate to </st><strong class="bold"><st c="37557">Pipelines</st></strong><st c="37566">, and we can create a new pipeline YAML file that will be stored in the new </st><span class="No-Break"><st c="37642">Git repository.</st></span></li>
				<li><st c="37657">The YAML file should look </st><span class="No-Break"><st c="37684">as follows:</st></span><pre class="source-code"><st c="37695">
trigger:
- none
pool:
  vmImage: ubuntu-latest
steps:
</st><strong class="bold"><st c="37748">- task: PowerPlatformToolInstaller@2</st></strong>
<strong class="bold"><st c="37784">  inputs:</st></strong>
<strong class="bold"><st c="37792">    DefaultVersion: true</st></strong>
<strong class="bold"><st c="37813">- task: AdvancedSecurity-Codeql-Init@1</st></strong>
<strong class="bold"><st c="37852">  inputs:</st></strong>
<strong class="bold"><st c="37860">    languages: 'javascript'</st></strong>
<strong class="bold"><st c="37884">    querysuite: 'code-scanning'</st></strong>
<strong class="bold"><st c="37912">- task: AdvancedSecurity-Codeql-Analyze@1</st></strong>
<strong class="bold"><st c="37954">  inputs:</st></strong>
<strong class="bold"><st c="37962">    WaitForProcessing: true</st></strong></pre><p class="list-inset"><st c="37986">This</st><a id="_idIndexMarker837"/><st c="37991"> YAML file will execute the same CodeQL analysis that we have seen previously with PowerShell for JavaScript via the </st><span class="No-Break"><st c="38108">CodeQL CLI.</st></span></p></li>				<li><st c="38119">The code scanning and secret scanning alerts are listed under </st><strong class="bold"><st c="38182">Repos</st></strong><st c="38187"> in the </st><strong class="bold"><st c="38195">Advanced Security</st></strong><st c="38212"> tab of </st><span class="No-Break"><st c="38220">Azure DevOps:</st></span></li>
			</ol>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/B22208_07_6.jpg" alt="Figure 7.6 – Code and secret scanning results in Azure DevOps"/><st c="38233"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="39290">Figure 7.6 – Code and secret scanning results in Azure DevOps</st></p>
			<p><st c="39351">In the case of GitHub, we can apply the same steps by forking </st><strong class="source-inline"><st c="39414">PowerApps-Samples</st></strong><st c="39431"> and creating </st><a id="_idIndexMarker838"/><st c="39445">the code analysis-related actions (see </st><strong class="source-inline"><st c="39484">.github/workflows/codeql.yml</st></strong><st c="39512"> in the </st><strong class="source-inline"><st c="39520">Chapter07</st></strong><st c="39529"> folder of the </st><span class="No-Break"><st c="39544">GitHub repo):</st></span></p>
			<pre class="source-code"><st c="39557">
name: "CodeQL"
on:
  workflow_dispatch:
jobs:
  analyze:
    name: Analyze javascript
    runs-on: ubuntu-latest
    timeout-minutes: 120
    permissions:
      # required for all workflows
      security-events: write
      # only required for workflows in private repositories
      actions: read
      contents: read
    steps:
</st><strong class="bold"><st c="39835">    - name: Checkout repository</st></strong>
<strong class="bold"><st c="39862">      uses: actions/checkout@v4</st></strong>
<strong class="bold"><st c="39888">    - name: Initialize CodeQL</st></strong>
<strong class="bold"><st c="39914">      uses: github/codeql-action/init@v3</st></strong>
<strong class="bold"><st c="39949">      with:</st></strong>
<strong class="bold"><st c="39955">        languages: javascript-typescript</st></strong>
<strong class="bold"><st c="39988">        build-mode: none</st></strong>
<strong class="bold"><st c="40005">    - name: Perform CodeQL Analysis</st></strong>
<strong class="bold"><st c="40037">      uses: github/codeql-action/analyze@v3</st></strong>
<strong class="bold"><st c="40075">      with:</st></strong>
<strong class="bold"><st c="40081">        category: "/language:javascript-typescript"</st></strong></pre>			<p><st c="40125">Using the</st><a id="_idIndexMarker839"/><st c="40135"> Azure DevOps pipeline templates and the reusable GitHub workflows, we can easily introduce these additional code scanning and security analysis steps in every project of ours. </st><st c="40312">Fortunately, there is another way to infuse security validation and code scanning checks in Power Platform solutions, which is the </st><span class="No-Break"><strong class="bold"><st c="40443">solution checker</st></strong></span><span class="No-Break"><st c="40459">.</st></span></p>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor129"/><st c="40460">Solution checker</st></h1>
			<p><st c="40477">The solution checker</st><a id="_idIndexMarker840"/><st c="40498"> embraces the Power Apps checker service to execute code analysis in solutions by submitting jobs for the Power Platform backend. </st><st c="40628">There are </st><a id="_idIndexMarker841"/><st c="40638">predefined </st><strong class="bold"><st c="40649">rulesets</st></strong><st c="40657"> with </st><strong class="bold"><st c="40663">rules</st></strong><st c="40668"> to cover certain security recommendations and coding best practices of our solutions. </st><st c="40755">The solution checker can report the found issues in SARIF format, which we can easily upload to our DevOps tools, such as GitHub with GHAS or GHAS for Azure DevOps. </st><st c="40920">The solution checker reviews the following Power Platform assets in </st><span class="No-Break"><st c="40988">unmanaged solutions:</st></span></p>
			<ul>
				<li><st c="41008">Dataverse custom </st><span class="No-Break"><st c="41026">workflow activities</st></span></li>
				<li><st c="41045">Dataverse web resources (HTML </st><span class="No-Break"><st c="41076">and JavaScript)</st></span></li>
				<li><st c="41091">Dataverse configurations, such as SDK </st><span class="No-Break"><st c="41130">message steps</st></span></li>
				<li><st c="41143">Power Automate flows (via Power Automate </st><span class="No-Break"><st c="41185">Flow Checker)</st></span></li>
				<li><st c="41198">Power Fx expressions (via App Checker – part of the Power Apps </st><span class="No-Break"><st c="41262">checker service)</st></span></li>
			</ul>
			<p><st c="41278">The rulesets and their rules are predefined and categorized to cover the previously listed components: plug-in or workflow activity, web resources, and canvas app. </st><st c="41443">We can execute the</st><a id="_idIndexMarker842"/><st c="41461"> solution checker in multiple ways for </st><span class="No-Break"><st c="41500">unmanaged solutions:</st></span></p>
			<ul>
				<li><st c="41520">In the Power Apps maker portal under the </st><span class="No-Break"><strong class="bold"><st c="41562">Solutions</st></strong></span><span class="No-Break"><st c="41571"> blade.</st></span></li>
				<li><st c="41578">Using the </st><strong class="source-inline"><st c="41589">pac solution check</st></strong><st c="41607"> command with the proper parameters, such as </st><span class="No-Break"><st c="41652">the following:</st></span><pre class="source-code">
<strong class="bold"><st c="41666">pac solution check --path c:\Users\Documents\Solution.zip --outputDirectory c:\samplepackage --geo Europe.</st></strong></pre><p class="list-inset"><st c="41773">We can also upload our solutions to Blob Storage and use a </st><strong class="source-inline"><st c="41833">pac solution check</st></strong><st c="41851"> call on that </st><a id="_idIndexMarker843"/><st c="41865">blob using </st><strong class="bold"><st c="41876">shared access signature</st></strong><st c="41899"> (</st><span class="No-Break"><strong class="bold"><st c="41901">SAS</st></strong></span><span class="No-Break"><st c="41904">) tokens.</st></span></p></li>				<li><st c="41914">Using the</st><a id="_idIndexMarker844"/><st c="41924"> PowerShell module, </st><strong class="source-inline"><st c="41944">Microsoft.PowerApps.Checker.PowerShell</st></strong><st c="41982">, and respectively the </st><strong class="source-inline"><st c="42005">Get-PowerAppsCheckerRulesets</st></strong><st c="42033"> cmdlet for fetching the pre-built rulesets and the </st><strong class="source-inline"><st c="42085">Invoke-PowerAppsChecker</st></strong><st c="42108"> cmdlet for submitting the analysis job to the Power Platform backbone. </st><st c="42180">However, these cmdlets are in the pre-release version and they </st><span class="No-Break"><st c="42243">might change.</st></span></li>
				<li><st c="42256">Using </st><a id="_idIndexMarker845"/><st c="42263">the </st><strong class="bold"><st c="42267">Power Apps checker web API</st></strong><st c="42293">: The Power App maker portal, the PAC CLI, and the PowerShell module rely on these REST API endpoints under the hood. </st><st c="42412">We can directly call these endpoints having the appropr</st><a href="https://unitedstates.api.advisor.powerapps.com"><st c="42467">iate access token in place; for instance, the </st></a><st c="42514">US endpoint is reachable under the following </st><span class="No-Break"><st c="42559">URL: </st></span><a href="https://unitedstates.api.advisor.powerapps.com"><span class="No-Break"><st c="42564">https://unitedstates.api.advisor.powerapps.com</st></span></a><span class="No-Break"><st c="42610">.</st></span></li>
				<li><st c="42611">Using </st><strong class="bold"><st c="42618">managed environments</st></strong><st c="42638"> to enforce solution checker runs before importing solutions to target environments. </st><st c="42723">Here, we can block the import of solutions if violations against these rules </st><span class="No-Break"><st c="42800">are encountered.</st></span></li>
				<li><st c="42816">Leveraging the </st><strong class="bold"><st c="42832">build tasks for Azure DevOps</st></strong><st c="42860"> and </st><strong class="bold"><st c="42865">GitHub Actions for Power Platform</st></strong><st c="42898">: There</st><a id="_idIndexMarker846"/><st c="42906"> are pre-built actions/tasks in both DevOps tools that we can use to execute the solution checker on the appropriate ruleset. </st><st c="43032">The </st><strong class="bold"><st c="43036">ALM Accelerator for Power Platform</st></strong><st c="43070">, which</st><a id="_idIndexMarker847"/><st c="43077"> we discussed in detail in </st><a href="B22208_06.xhtml#_idTextAnchor103"><span class="No-Break"><em class="italic"><st c="43104">Chapter 6</st></em></span></a><st c="43113">, provides pipeline templates that execute solution checker build tasks (</st><strong class="source-inline"><st c="43186">PowerPlatformChecker@2</st></strong><st c="43209">) during the import process of solutions from Git repositories. </st><st c="43274">This task uses the PAC CLI behind </st><span class="No-Break"><st c="43308">the scenes.</st></span></li>
			</ul>
			<p><st c="43319">Let us have a look at the build task in Azure pipelines that executes such a static code analysis on our </st><a id="_idIndexMarker848"/><st c="43425">solution (see </st><strong class="source-inline"><st c="43439">.pipelines/solution-checker.yml</st></strong><st c="43470"> in the </st><strong class="source-inline"><st c="43478">Chapter07</st></strong><st c="43487"> folder of the </st><span class="No-Break"><st c="43502">GitHub repo):</st></span></p>
			<pre class="source-code"><st c="43515">
trigger:
- none
pool:
  vmImage: ubuntu-latest
variables:
 solutionName: "PacktCopilotSolution"
steps:
- task: PowerPlatformToolInstaller@2
  inputs:
    DefaultVersion: true
- task: PowerPlatformPackSolution@2
  inputs:
    SolutionSourceFolder: '$(System.DefaultWorkingDirectory)/src/$(solutionName)'
    SolutionOutputFile: '$(Build.ArtifactStagingDirectory)/Solution/$(solutionName).zip'
    SolutionType: 'Unmanaged'
</st><strong class="bold"><st c="43915">- task: PowerPlatformChecker@2</st></strong>
<strong class="bold"><st c="43945">  inputs:</st></strong>
<strong class="bold"><st c="43953">    authenticationType: 'PowerPlatformSPN'</st></strong>
<strong class="bold"><st c="43992">    PowerPlatformSPN: 'dev-US_XXX_Y'</st></strong>
<strong class="bold"><st c="44025">    FilesToAnalyze: '$(Build.ArtifactStagingDirectory)/Solution/$(solutionName).zip'</st></strong>
<strong class="bold"><st c="44106">    RuleSet: '0ad12346-e108-40b8-a956-9a8f95ea18c9'</st></strong>
<strong class="bold"><st c="44154">    ArtifactDestinationName: 'CodeAnalysisLogs'</st></strong></pre>			<p><st c="44198">Here, we use the unpacked version of a solution in the Git repository, pack that solution as an unmanaged one, and then call the </st><strong class="source-inline"><st c="44328">PowerPlatformChecker@2</st></strong><st c="44350"> task to perform the solution check. </st><st c="44387">The </st><strong class="source-inline"><st c="44391">RuleSet</st></strong><st c="44398"> GUID is the solution checker ruleset. </st><st c="44437">There is only one other and that is AppSource certification for submitting solutions for Microsoft AppSource. </st><st c="44547">We need to define a service connection, as we did in </st><a href="B22208_06.xhtml#_idTextAnchor103"><span class="No-Break"><em class="italic"><st c="44600">Chapter 6</st></em></span></a><st c="44609">, to connect to an environment because the </st><strong class="source-inline"><st c="44652">AppChecker</st></strong><st c="44662"> service job executes solution validations in environments. </st><st c="44722">Although we reference here a local unmanaged solution, that solution is uploaded to the </st><a id="_idIndexMarker849"/><st c="44810">environment before the analysis. </st><st c="44843">The results are not stored in the environment but exported as a SARIF file. </st><st c="44919">The build task also publishes the SARIF result to the artifacts of </st><span class="No-Break"><st c="44986">pipeline results.</st></span></p>
			<p><st c="45003">In the case of GitHub, we can use the following workflow to achieve the same result (see </st><strong class="source-inline"><st c="45093">.github/workflows/solution-checker.yml</st></strong><st c="45131"> in the </st><strong class="source-inline"><st c="45139">Chapter07</st></strong><st c="45148"> folder of the </st><span class="No-Break"><st c="45163">GitHub repo):</st></span></p>
			<pre class="source-code"><st c="45176">
name: Solution-Checker
on:
  workflow_dispatch:
jobs:
  solutioncheck:
    runs-on: ubuntu-latest
    env:
     Solution: mpa_ITBase
    steps:
      - uses: actions/checkout@v3
      - name: Install Power Platform Tools
        uses: microsoft/powerplatform-actions/actions-install@v1
</st><strong class="bold"><st c="45422">      - name: Pack unmanaged solution</st></strong>
<strong class="bold"><st c="45453">        uses: microsoft/powerplatform-actions/pack-solution@v1</st></strong>
<strong class="bold"><st c="45508">        with:</st></strong>
<strong class="bold"><st c="45514">          solution-folder: ${{ env.Solution }}</st></strong>
<strong class="bold"><st c="45551">          solution-file: ${{ env.Solution }}_unmanaged.zip</st></strong>
<strong class="bold"><st c="45600">          solution-type: Unmanaged</st></strong>
<strong class="bold"><st c="45625">      - name: Check-solution</st></strong>
<strong class="bold"><st c="45648">        uses: microsoft/powerplatform-actions/check-solution@v1</st></strong>
<strong class="bold"><st c="45704">        with:</st></strong>
<strong class="bold"><st c="45710">          environment-url: https://yourorg.crm.dynamics.com</st></strong>
<strong class="bold"><st c="45760">          app-id: 862e5a17-d38b-BBBB-FFFF-88a77f59623f</st></strong>
<strong class="bold"><st c="45805">          client-secret: "${{ secrets.CLIENTSECRET_DEV }}"</st></strong>
<strong class="bold"><st c="45854">          tenant-id: 4ae51f31-033a-XXXX-YYYY-5ece14d2c081</st></strong>
<strong class="bold"><st c="45902">          path: ${{ env.Solution }}_unmanaged.zip</st></strong></pre>			<p><st c="45942">The GitHub action, </st><strong class="source-inline"><st c="45962">microsoft/powerplatform-actions/pack-solution@v1</st></strong><st c="46010">, also uploads</st><a id="_idIndexMarker850"/><st c="46024"> the SARIF result to the artifacts of the GitHub </st><span class="No-Break"><st c="46073">workflow run.</st></span></p>
			<p class="callout-heading"><st c="46086">Managing the findings</st></p>
			<p class="callout"><st c="46108">Whether the solution checker with SARIF results, GHAS, or other code and dependency scanning tools are used to execute SAST, after gathering the results, we also need to manage those findings. </st><st c="46302">We can mitigate these risks by accepting them, such as a security alert in the test code will not be corrected, or we can introduce new issues or work items to update the code according to the finding and respectively the vulnerability described</st><a id="_idIndexMarker851"/><st c="46547"> in the </st><strong class="bold"><st c="46555">Common Weakness Enumeration</st></strong><st c="46582"> (</st><strong class="bold"><st c="46584">CWE</st></strong><st c="46587">) database. </st><st c="46600">Modern DevOps tools support linking the code scanning, dependency scanning, and secret scanning alerts to work items or issues and introduce the demand for fixes in the development </st><span class="No-Break"><st c="46781">life cycle.</st></span></p>
			<p><st c="46792">Now we are familiar with the solution checker, the GHAS features, and the tasks in the DevSecOps process related to the SDLC methodology, we now combine this knowledge with the automated DevOps processes from </st><a href="B22208_06.xhtml#_idTextAnchor103"><span class="No-Break"><em class="italic"><st c="47002">Chapter 6</st></em></span></a><span class="No-Break"><st c="47011">.</st></span></p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor130"/><st c="47012">Spinning up DevSecOps projects at scale</st></h1>
			<p><st c="47052">In </st><a href="B22208_06.xhtml#_idTextAnchor103"><span class="No-Break"><em class="italic"><st c="47056">Chapter 6</st></em></span></a><st c="47065">, we </st><a id="_idIndexMarker852"/><st c="47070">learned how to spin up Power Platform environments with solutions assigned to our Git repositories and, respectively, the underlying branches. </st><st c="47213">We created pipeline templates and reusable workflows in GitHub to provide automations for </st><span class="No-Break"><st c="47303">the following:</st></span></p>
			<ul>
				<li><st c="47317">Spinning up new Power Platform </st><span class="No-Break"><st c="47349">developer environments</st></span></li>
				<li><st c="47371">Creating service connections to those Power </st><span class="No-Break"><st c="47416">Platform environments</st></span></li>
				<li><st c="47437">Exporting solutions from developer environments to </st><span class="No-Break"><st c="47489">Git branches</st></span></li>
				<li><st c="47501">Importing solutions from Git repositories and branches to target environments via pull requests or directly to our </st><span class="No-Break"><st c="47617">developer branch</st></span></li>
			</ul>
			<p><st c="47633">We can take one step forward in this journey and automate the entire development process of Power Platform solutions. </st><st c="47752">First, let us introduce a new term: workload. </st><strong class="bold"><st c="47798">Workloads</st></strong><st c="47807"> consist </st><a id="_idIndexMarker853"/><st c="47816">of one or more solutions that contribute to each other to implement complex business requirements. </st><st c="47915">We can consider them as the input solutions for package deployer packages, such as the </st><strong class="bold"><st c="48002">Enterprise templates</st></strong><st c="48022"> we learned about in </st><a href="B22208_04.xhtml#_idTextAnchor074"><span class="No-Break"><em class="italic"><st c="48043">Chapter 4</st></em></span></a><st c="48052">. To set up an enterprise-grade DevSecOps project for workloads or for separate solutions, we need to accomplish the following additional </st><span class="No-Break"><st c="48190">automation tasks:</st></span></p>
			<ol>
				<li><st c="48207">Create AAD groups (Microsoft Entra ID groups) for owners and contributors. </st><st c="48283">There must be at least two owners in the </st><strong class="source-inline"><st c="48324">Owners</st></strong><st c="48330"> group. </st><st c="48338">In most cases, we recommend having a budget owner and a technical owner assigned to </st><span class="No-Break"><st c="48422">a project</st></span><span class="No-Break"><st c="48431">.</st></span></li>
				<li><st c="48432">Create environments for testing and production per each workload or use existing shared environments hosting more solutions for the </st><span class="No-Break"><st c="48565">new one.</st></span></li>
				<li><st c="48573">Create </st><a id="_idIndexMarker854"/><st c="48581">service principals for these environments using </st><strong class="source-inline"><st c="48629">pac admin create-service-principal</st></strong><st c="48663"> and the </st><strong class="bold"><st c="48672">System Administrator</st></strong><st c="48692"> security role. </st><st c="48708">By default, we do not assign any other users from</st><a id="_idIndexMarker855"/><st c="48757"> the development team or service accounts to these environments. </st><st c="48822">Depending on the organization, the security group assigned to the environment might be global administrators or the </st><strong class="source-inline"><st c="48938">Owners</st></strong><st c="48944"> AAD group </st><span class="No-Break"><st c="48955">created earlier.</st></span></li>
				<li><st c="48971">Create an Azure DevOps project and assign the </st><strong class="source-inline"><st c="49018">Owners</st></strong><st c="49024"> AAD group to </st><strong class="bold"><st c="49038">Project Administrators</st></strong><st c="49060">, whereas assign the </st><strong class="source-inline"><st c="49081">Contributors</st></strong><st c="49093"> group to the </st><strong class="bold"><st c="49107">Contributors</st></strong><st c="49119"> group of </st><span class="No-Break"><st c="49129">Azure DevOps.</st></span></li>
				<li><st c="49142">Create a Git repository for the workload or solution in the Azure DevOps project with branch policies </st><span class="No-Break"><st c="49245">in place.</st></span></li>
				<li><st c="49254">Create service connections for these environments using the service principals that we have created. </st><st c="49356">This is what we did in </st><a href="B22208_06.xhtml#_idTextAnchor103"><span class="No-Break"><em class="italic"><st c="49379">Chapter 6</st></em></span></a><span class="No-Break"><st c="49388">.</st></span></li>
				<li><st c="49389">Create CI/CD pipelines that use pipeline templates available in a separate, dedicated repository and configure them to use those new service connections </st><span class="No-Break"><st c="49543">as parameters.</st></span></li>
			</ol>
			<p><st c="49557">In the end, we can achieve the following </st><span class="No-Break"><st c="49599">project setup:</st></span></p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="image/B22208_07_7.jpg" alt="Figure 7.7 – DevSecOps Power Platform project"/><st c="49613"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="49942">Figure 7.7 – DevSecOps Power Platform project</st></p>
			<p><st c="49987">We can see</st><a id="_idIndexMarker856"/><st c="49998"> here the </st><strong class="bold"><st c="50008">Microsoft Entra ID tenant</st></strong><st c="50033"> as the</st><a id="_idIndexMarker857"/><st c="50040"> main glue of our security concept. </st><st c="50076">We give access only to the AAD groups throughout the systems (i.e., for Power Platform and Azure DevOps). </st><st c="50182">Individual user assignments are blocked by policies in both systems. </st><st c="50251">With that, we can guarantee that only the members of the AAD groups (</st><strong class="source-inline"><st c="50320">Owners</st></strong><st c="50327"> and </st><strong class="source-inline"><st c="50332">Contributors</st></strong><st c="50344">) can work on the project. </st><st c="50372">Membership changes are logged into </st><strong class="bold"><st c="50407">Azure Log Analytics workspaces</st></strong><st c="50437"> and </st><a id="_idIndexMarker858"/><st c="50442">monitored by SIEM solutions, such as Microsoft Sentinel (</st><span class="No-Break"><st c="50499">Threat Intelligence).</st></span></p>
			<p><st c="50521">We can automate all the previous steps with the help</st><a id="_idIndexMarker859"/><st c="50574"> of </st><strong class="bold"><st c="50578">Azure pipelines</st></strong><st c="50593"> located in a separate Azure DevOps project. </st><st c="50638">Let us see those steps </st><span class="No-Break"><st c="50661">in detail:</st></span></p>
			<ol>
				<li><st c="50671">Create </st><span class="No-Break"><st c="50679">AAD groups:</st></span><p class="list-inset"><st c="50690">To create an AAD group, we can use the following script (see </st><strong class="source-inline"><st c="50752">create-aad-group.sh</st></strong><st c="50771"> in the </st><strong class="source-inline"><st c="50779">Chapter07</st></strong><st c="50788"> folder of the </st><span class="No-Break"><st c="50803">GitHub repo):</st></span></p><pre class="source-code"><st c="50816">
#!/bin/bash
set -e
# Variables
SERVICE_PRINCIPAL_APP_ID="&lt;your-service-principal-app-id&gt;"
SERVICE_PRINCIPAL_SECRET="&lt;your-service-principal-password&gt;"
TENANT_ID="&lt;your-tenant-id&gt;"
GROUP_NAME="&lt;your-group-name&gt;"
# Login as the service principal
</st><strong class="bold"><st c="51061">az login --service-principal -u $SERVICE_PRINCIPAL_APP_ID -p $SERVICE_PRINCIPAL_SECRET --tenant $TENANT_ID</st></strong><st c="51167">
# Create the AAD group
</st><strong class="bold"><st c="51191">az ad group create --display-name $GROUP_NAME --mail-nickname $GROUP_NAME</st></strong><st c="51264">
# get the user object id
</st><strong class="bold"><st c="51290">AADObjectID=$(az ad user show \</st></strong>
<strong class="bold"><st c="51321">             --id $userPrincipalName \</st></strong>
<strong class="bold"><st c="51347">             --query id \</st></strong>
<strong class="bold"><st c="51360">             --output tsv)</st></strong><st c="51374">
# add a member to the group
</st><strong class="bold"><st c="51403">az ad group member add --group $GROUP_NAME --member-id $AADObjectID</st></strong></pre><p class="list-inset"><st c="51470">The </st><a id="_idIndexMarker860"/><st c="51475">service principal we use here needs to have a privileged administrator role, such</st><a id="_idIndexMarker861"/><st c="51556"> as </st><strong class="bold"><st c="51560">User Access Administrator</st></strong><st c="51585"> in our Microsoft Entra ID tenant, to be able to create </st><span class="No-Break"><st c="51641">AAD groups.</st></span></p></li>				<li><st c="51652">Create environments for testing </st><span class="No-Break"><st c="51685">and production:</st></span><p class="list-inset"><st c="51700">In </st><a href="B22208_06.xhtml#_idTextAnchor103"><span class="No-Break"><em class="italic"><st c="51704">Chapter 6</st></em></span></a><st c="51713">, we used the </st><strong class="source-inline"><st c="51727">pac admin create</st></strong><st c="51743"> commands to create Power Platform developer environments. </st><st c="51802">To create a sandbox or a production environment, we can use the following script (see </st><strong class="source-inline"><st c="51888">create-powerplatform-env.sh</st></strong><st c="51915"> in </st><a id="_idIndexMarker862"/><st c="51919">the </st><strong class="source-inline"><st c="51923">Chapter07</st></strong><st c="51932"> folder of the </st><span class="No-Break"><st c="51947">GitHub repo):</st></span></p><pre class="source-code"><st c="51960">
#!/bin/bash
set -e
# Define environment variables
SERVICE_PRINCIPAL_APP_ID="&lt;your-service-principal-app-id&gt;"
SERVICE_PRINCIPAL_SECRET="&lt;your-service-principal-password&gt;"
TENANT_ID="&lt;your-tenant-id&gt;"
ENV_NAME="YOUR_ENV_NAME"
REGION="YOUR_REGION"
CURRENCY="YOUR_CURRENCY"
LANGUAGE="YOUR_LANGUAGE"
# Login to Power Apps using service principal
</st><strong class="bold"><st c="52302">pac auth create --applicationId $SERVICE_PRINCIPAL_APP_ID --clientSecret $SERVICE_PRINCIPAL_SECRET \</st></strong>
<strong class="bold"><st c="52402">--tenant $TENANT_ID</st></strong><st c="52422">
# Create a new environment
</st><strong class="bold"><st c="52450">pac admin create --name $ENV_NAME --region $REGION \</st></strong>
<strong class="bold"><st c="52502">    --currency $CURRENCY --language $LANGUAGE \</st></strong>
<strong class="bold"><st c="52546">    --type Production</st></strong>
<strong class="bold"><st c="52564">rawOutput=$(pac admin list --name $ENV_NAME | tail -n 2)</st></strong>
<strong class="bold"><st c="52621">environmentId=$(echo $rawOutput | cut -d ' ' -f 2)</st></strong><st c="52672">
#Enable Managed Environment
</st><strong class="bold"><st c="52701">pac admin set-governance-config \</st></strong>
<strong class="bold"><st c="52734">   --environment $environmentId \</st></strong>
<strong class="bold"><st c="52765">   --protection-level Standard</st></strong></pre><p class="list-inset"><st c="52793">In the case of the production environment, we use the </st><strong class="source-inline"><st c="52848">pac admin set-governance-config</st></strong><st c="52879"> command to enable managed </st><span class="No-Break"><st c="52906">environment features.</st></span></p></li>				<li><st c="52927">Create</st><a id="_idIndexMarker863"/><st c="52934"> service principals </st><span class="No-Break"><st c="52954">for environments:</st></span><p class="list-inset"><st c="52971">As we did in </st><a href="B22208_05.xhtml#_idTextAnchor089"><span class="No-Break"><em class="italic"><st c="52985">Chapter 5</st></em></span></a><st c="52994">, we can use the following PAC CLI command to create a service principal assigned to the newly </st><span class="No-Break"><st c="53089">created environments:</st></span></p><pre class="source-code">
<strong class="bold"><st c="53110">pac admin create-service-principal -env &lt;&lt;URL&gt;&gt; -n VersionControlSPN --role "System Administrator"</st></strong></pre><p class="list-inset"><st c="53209">We need to store the application ID, client secret, and tenant ID in a safe location. </st><st c="53296">We can</st><a id="_idIndexMarker864"/><st c="53302"> use </st><strong class="bold"><st c="53307">Azure Key Vault</st></strong><st c="53322"> service to store our secrets, which can be used later in Azure DevOps pipelines with the help of the </st><strong class="source-inline"><st c="53424">AzureKeyVault@2</st></strong> <span class="No-Break"><st c="53439">build task.</st></span></p></li>				<li><st c="53451">Create an Azure </st><span class="No-Break"><st c="53468">DevOps project:</st></span><p class="list-inset"><st c="53483">Here, we need to use</st><a id="_idIndexMarker865"/><st c="53504"> a </st><strong class="bold"><st c="53507">personal access token</st></strong><st c="53528"> (</st><strong class="bold"><st c="53530">PAT</st></strong><st c="53533">) created in Azure DevOps to interact with the Azure DevOps CLI. </st><st c="53599">The PAT token requires more privileges to be able to create a DevOps project in the same organization. </st><st c="53702">These are the scopes that we need to assign to our </st><span class="No-Break"><st c="53753">PAT token:</st></span></p><ul><li><strong class="bold"><st c="53763">Pipeline resources</st></strong><st c="53782">: Use </st><span class="No-Break"><st c="53789">and manage</st></span></li><li><strong class="bold"><st c="53799">Project and Team</st></strong><st c="53816">: Read, write, </st><span class="No-Break"><st c="53832">and manage</st></span></li><li><strong class="bold"><st c="53842">Graph</st></strong><st c="53848">: Read </st><span class="No-Break"><st c="53856">and manage</st></span></li><li><strong class="bold"><st c="53866">Identity</st></strong><st c="53875">: Read </st><span class="No-Break"><st c="53883">and manage</st></span></li></ul><p class="list-inset"><st c="53893">Azure pipelines also provide a built-in access token on which the pipelines and, respectively, the jobs can execute different tasks. </st><st c="54027">It is called </st><strong class="source-inline"><st c="54040">System.AccessToken</st></strong><st c="54058"> and we can refer to this token to perform administrative or organization-wide actions. </st><st c="54146">With this approach, we can eliminate the </st><a id="_idIndexMarker866"/><st c="54187">use of personal access tokens and we can grant access rights and privileges for the build service account at the collection level. </st><st c="54318">For this, we need to disable the </st><strong class="bold"><st c="54351">Limit job authorization scope to current project for non-release pipelines</st></strong><st c="54425"> and </st><strong class="bold"><st c="54430">Limit job authorization scope to current project for release pipelines</st></strong><st c="54500"> options under </st><strong class="bold"><st c="54515">Project Settings</st></strong><st c="54531"> in the pipeline’s </st><strong class="bold"><st c="54550">Settings</st></strong><st c="54558"> blade in the project that will host our management pipelines, as the following </st><span class="No-Break"><st c="54638">figure shows:</st></span></p></li>
			</ol>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="image/B22208_07_8.jpg" alt="Figure 7.8 – System.AccessToken: project versus organization scope"/><st c="54651"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="55598">Figure 7.8 – System.AccessToken: project versus organization scope</st></p>
			<p class="list-inset"><st c="55664">If these toggle buttons are disabled, then we need to turn them off at the organization level. </st><st c="55760">Finally, we need to grant permission to the </st><strong class="bold"><st c="55804">Project Collection Build Service (organization)</st></strong><st c="55851"> user to allow the </st><strong class="bold"><st c="55870">Create new projects</st></strong><st c="55889"> and </st><strong class="bold"><st c="55894">Edit instance-level information</st></strong><st c="55925"> permissions. </st><st c="55939">After this, we can use the </st><strong class="source-inline"><st c="55966">$(System.AccessToken)</st></strong><st c="55987"> system variable in our pipelines to execute the following script (see </st><strong class="source-inline"><st c="56058">.pipelines/setup-azure-devops-project.yml</st></strong><st c="56099"> in the </st><strong class="source-inline"><st c="56107">Chapter07</st></strong><st c="56116"> folder of the </st><span class="No-Break"><st c="56131">GitHub repo):</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="56144">echo $(System.AccessToken) | az devops login --organization $(System.CollectionUri)</st></strong>
<strong class="bold"><st c="56228">az devops project create --name ${{ parameters.projectName }} --org $(System.CollectionUri)</st></strong>
<strong class="bold"><st c="56320">aadAdminGroupId=$(az ad group show --group $(AADGroupForAdmin) --query id -o tsv)</st></strong><st c="56402">
echo "Admin group id: $aadAdminGroupId"
</st><strong class="bold"><st c="56443">azureDevopsAdminGroupDescriptor=$(az devops security group list --organization $(System.CollectionUri) --project ${{parameters.projectName}} | jq -r '.graphGroups[] | select(.displayName=="Project Administrators") | .descriptor')</st></strong><st c="56672">
echo "Azure DevOps Admin Group Descriptor: $azureDevopsAdminGroupDescriptor"
# Add the AAD group to the Administrators groups in Azure DevOps
collectionUri=$(System.CollectionUri)
orgnamewithouthttps=${collectionUri//https:\/\//}
</st><strong class="bold"><st c="56903">curl -u :$(System.AccessToken) \</st></strong>
<strong class="bold"><st c="56935">     -H "Content-Type: application/json" \</st></strong>
<strong class="bold"><st c="56973">     -d "{\"originId\": \"$aadAdminGroupId\"}" \</st></strong>
<strong class="bold"><st c="57017">"https://vssps.$ orgnamewithouthttps /_apis/graph/groups?groupDescriptors=$azureDevopsAdminGroupDescriptor&amp;api-version=6.1-preview.1"</st></strong></pre>			<p class="list-inset"><st c="57151">Unfortunately, we</st><a id="_idIndexMarker867"/><st c="57169"> need to call the REST API endpoint of Azure DevOps to add our AAD group to the </st><em class="italic"><st c="57249">Project Administrators</st></em><st c="57271"> group of Azure DevOps because the </st><strong class="source-inline"><st c="57306">az devops security group membership add --group-id $azureDevopsAdminGroupId --member-id $aadAdminGroupId --org $(System.CollectionUri)</st></strong><st c="57440"> command doesn’t work </st><span class="No-Break"><st c="57462">across projects.</st></span></p>
			<ol>
				<li value="5"><st c="57478">Create a </st><span class="No-Break"><st c="57488">Git repository:</st></span><p class="list-inset"><st c="57503">When </st><a id="_idIndexMarker868"/><st c="57509">creating a new Azure DevOps project, a default Git repository with the name of </st><strong class="source-inline"><st c="57588">project</st></strong><st c="57595"> and a default team is created. </st><st c="57627">To create a repository, we can use the </st><strong class="source-inline"><st c="57666">az repos create</st></strong><st c="57681"> command with the appropriate parameters. </st><st c="57723">We need the following variables in our </st><span class="No-Break"><st c="57762">Bash script:</st></span></p><pre class="source-code"><st c="57774">
# Variables
organizationURL="&lt;Your-Azure-DevOps-Organization-URL&gt;"
project="&lt;Your-Azure-DevOps-Project&gt;"
repository="&lt;Your-New-Repository-Name&gt;"
pat="&lt;Your-Personal-Access-Token&gt;"</st></pre><p class="list-inset"><st c="57954">This enables us to use the following command to create a </st><span class="No-Break"><st c="58012">new repository:</st></span></p><pre class="source-code"><strong class="bold"><st c="58027">repositoryId=$(az repos create --name $repository --organization $organizationURL --project $project --detect false | jq -r .id)</st></strong></pre><p class="list-inset"><st c="58156">We need to initiate the repository with the first commit by creating the </st><span class="No-Break"><strong class="source-inline"><st c="58230">main</st></strong></span><span class="No-Break"><st c="58234"> branch:</st></span></p><pre class="source-code"><st c="58242">organizationName=$(basename $organizationURL)
</st><strong class="bold"><st c="58289">git clone https://$organizationName@dev.azure.com/$organizationName/$project/_git/$repository</st></strong><st c="58382">
cd $repository
</st><strong class="bold"><st c="58398">git checkout -b main</st></strong><st c="58418">
echo "# $repository" &gt;&gt; README.md
</st><strong class="bold"><st c="58453">git add .</st></strong>
<strong class="bold"><st c="58462">git commit -m "Initial commit"</st></strong>
<strong class="bold"><st c="58493">git push -u origin --all</st></strong></pre><p class="list-inset"><st c="58518">Finally, we can </st><a id="_idIndexMarker869"/><st c="58535">create a </st><strong class="bold"><st c="58544">branch policy</st></strong><st c="58557"> to </st><a id="_idIndexMarker870"/><st c="58561">protect our </st><strong class="source-inline"><st c="58573">main</st></strong><st c="58577"> branch from direct commits by introducing the check for linked work items on pull requests (see </st><strong class="source-inline"><st c="58674">create-gitrepo-and-branch-policy.sh</st></strong><st c="58709"> in the </st><strong class="source-inline"><st c="58717">Chapter07</st></strong><st c="58726"> folder of the </st><span class="No-Break"><st c="58741">GitHub repo):</st></span></p><pre class="source-code"><strong class="bold"><st c="58754">az repos policy work-item-linking create</st></strong><st c="58795"> \
</st><strong class="bold"><st c="58798">....--branch "refs/heads/main" \</st></strong>
<strong class="bold"><st c="58830">    --enabled true --organization $organization --project $project \</st></strong>
<strong class="bold"><st c="58895">    --repository $repositoryId --blocking true --detect false</st></strong></pre></li>				<li><st c="58953">Create service connections for Power </st><span class="No-Break"><st c="58991">Platform environments:</st></span><p class="list-inset"><st c="59013">We did this exercise in </st><a href="B22208_06.xhtml#_idTextAnchor103"><span class="No-Break"><em class="italic"><st c="59038">Chapter 6</st></em></span></a><st c="59047">, in the </st><em class="italic"><st c="59056">Branches and </st></em><span class="No-Break"><em class="italic"><st c="59069">environments</st></em></span><span class="No-Break"><st c="59081"> subsection</st></span><span class="No-Break"><st c="59092">.</st></span></p></li>
				<li><st c="59093">Create CI/CD pipelines on </st><span class="No-Break"><st c="59120">pipeline templates:</st></span><p class="list-inset"><st c="59139">To create an Azure pipeline that uses a pipeline template from a different Git repository in a different Azure DevOps project, we can use the </st><strong class="source-inline"><st c="59282">resources</st></strong><st c="59291"> keyword in our pipeline YAML file to specify the repository containing the template. </st><st c="59377">Then, we can reference the template in our pipeline. </st><st c="59430">Here is an example for this (see </st><strong class="source-inline"><st c="59463">.pipelines/azure-pipelines-using-template.yml</st></strong><st c="59508"> in the </st><strong class="source-inline"><st c="59516">Chapter07</st></strong><st c="59525"> folder of the </st><span class="No-Break"><st c="59540">GitHub repo):</st></span></p><pre class="source-code">
<strong class="bold"><st c="59553">resources:</st></strong>
<strong class="bold"><st c="59564">  repositories:</st></strong>
<strong class="bold"><st c="59578">  - repository: templates</st></strong>
<strong class="bold"><st c="59602">    type: git</st></strong>
<strong class="bold"><st c="59612">    name: OtherProject/TemplateRepo</st></strong>
<strong class="bold"><st c="59644">    ref: refs/heads/main</st></strong>
<strong class="bold"><st c="59665">    endpoint: MyServiceConnection</st></strong><st c="59695">
steps: #or stages:
- template: .pipelines\ include-paccli-steps.yml@templates</st></pre><p class="list-inset"><st c="59773">In this </st><a id="_idIndexMarker871"/><st c="59782">example, </st><strong class="source-inline"><st c="59791">OtherProject/TemplateRepo</st></strong><st c="59816"> is the name of the other project and the repository containing the template. </st><strong class="source-inline"><st c="59894">my-template.yml</st></strong><st c="59909"> is the name of the template file in the other repository. </st><strong class="source-inline"><st c="59968">@templates</st></strong><st c="59978"> at the end of the template line is a reference to the templates repository defined in the </st><strong class="source-inline"><st c="60069">resources</st></strong><st c="60078"> section. </st><st c="60088">We need to have sufficient permissions to access the other project and repository. </st><st c="60171">Also, if the other repository is private and located in a different DevOps organization, we need to create a service connection in Azure DevOps to authenticate to the repository and to provide it as an endpoint, highlighted in the script. </st><st c="60410">We can use the Azure DevOps CLI to create a pipeline. </st><st c="60464">However, the Azure DevOps CLI does not currently support defining the pipeline configuration directly in the command. </st><st c="60582">We need to have a YAML file that defines the pipeline configuration, and then we can use the following command to create the pipeline based on that </st><span class="No-Break"><st c="60730">YAML file:</st></span></p><pre class="source-code"><strong class="bold"><st c="60740">az pipelines create --name "MyPipeline" --repository "MyRepo" --branch main --yml-path "azure-pipelines.yml" --organization "https://dev.azure.com/MyOrganization" --project "MyProject"</st></strong></pre><p class="list-inset"><st c="60925">This command assumes that the YAML file is in the root of the repository. </st><st c="61000">If the YAML file is in a different location, we need to specify the path relative to the root of the repository in the </st><strong class="source-inline"><st c="61119">--yml-path</st></strong><st c="61129"> option. </st><st c="61138">To create these YAML files, we can use the previously discussed Git commands to commit the baseline pipelines that already refer to the pipeline templates that are enriched with secret scanning and static </st><span class="No-Break"><st c="61343">code analysis.</st></span></p></li>			</ol>
			<p><st c="61357">At the end of these steps, we have the new Azure DevOps project and the new Git repository with pipelines in place that use the service connections to connect to the Power Platform </st><a id="_idIndexMarker872"/><st c="61539">environments and leverage pipeline templates located in a centralized repository governed by Microsoft </st><span class="No-Break"><st c="61642">Entra ID.</st></span></p>
			<p><st c="61651">We can realize the same approach in GitHub. </st><st c="61696">The only difference here is that we need to configure our GitHub organization to use Microsoft Entra ID through the </st><strong class="bold"><st c="61812">SAML protocol</st></strong><st c="61825">. GitHub</st><a id="_idIndexMarker873"/><st c="61833"> can provision enterprise accounts with the help of</st><a id="_idIndexMarker874"/><st c="61884"> a </st><strong class="bold"><st c="61887">system for cross-domain identity management</st></strong><st c="61930"> (</st><strong class="bold"><st c="61932">SCIM</st></strong><st c="61936">) configuration. </st><st c="61954">This means we can add Microsoft Entra ID accounts to GitHub Enterprise organizations and, respectively, repositories, and those users can </st><span class="No-Break"><st c="62092">sign in.</st></span></p>
			<p class="callout-heading"><st c="62100">Microsoft Entra ID</st></p>
			<p class="callout"><st c="62119">Regarding </st><a id="_idIndexMarker875"/><st c="62130">the DevOps tools we use, the main security takeaway is that we need to embrace Microsoft Entra ID accounts and, respectively, groups to manage access to projects, repositories, pipelines, work items, workflows, and so on. </st><st c="62352">From the administration perspective, we want to manage only memberships of Entra ID groups to grant or remove access to DevOps services and we do not allow individuals account-level access to </st><span class="No-Break"><st c="62544">our services.</st></span></p>
			<p><st c="62557">Of course, there are many other tasks that we can introduce in our development life cycle stages. </st><st c="62656">One of the most crucial activities is Inventory Management as discussed in the </st><em class="italic"><st c="62735">Setup</st></em><st c="62740"> section of this chapter. </st><st c="62766">Inventory Management can be realized within Power Platform on Dataverse as well. </st><st c="62847">The setup of new development projects can be managed with the help of Power Automate cloud flows that execute those previously discussed Azure DevOps pipelines behind the scenes. </st><st c="63026">The Inventory Management repository can store the metadata about our projects, such as who the owners are, where the source code/solution packages are located, which Entra ID groups are created, which Power Platform environments are spun up, and </st><span class="No-Break"><st c="63272">so on.</st></span></p>
			<p><st c="63278">However, as illustrated in the following figure, there are numerous additional tasks, including those activities we discussed at the beginning of the chapter in conjunction with custom development projects, that occur at different stages of the SDLC of Power </st><span class="No-Break"><st c="63538">Platform solutions:</st></span></p>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="image/B22208_07_9.jpg" alt="Figure 7.9 – DevSecOps activities in Power Platform solutions"/><st c="63557"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="64669">Figure 7.9 – DevSecOps activities in Power Platform solutions</st></p>
			<p><st c="64730">For instance, we </st><a id="_idIndexMarker876"/><st c="64748">can introduce more security analysis tasks in our pipelines, such as using GHAS or CodeQL for SAST, we can create our own build farms for our dedicated builds, apply code signing for our binary components or even for our Power Apps native mobile apps (wrap the app), perform DAST, execute test automation during CI/CD steps, and also set up advanced monitoring to read and analyze the DevOps audit logs or even the application logs. </st><st c="65181">This is only the tip of the iceberg since projects and organizations are continuously improving their DevSecOps practices and, with that, their security postures </st><span class="No-Break"><st c="65343">as well.</st></span></p>
			<p><st c="65351">We now delve into our final topic, the security of our established </st><span class="No-Break"><st c="65419">DevOps processes.</st></span></p>
			<h1 id="_idParaDest-123"><a id="_idTextAnchor131"/><st c="65436">Security of DevOps processes</st></h1>
			<p><st c="65465">Creating DevSecOps processes </st><a id="_idIndexMarker877"/><st c="65495">and setting up whole development projects fully automated from scratch is necessary to infuse security tasks in every phase and stage of the development life cycle. </st><st c="65660">On the other hand, we need to consider our established DevSecOps processes for security vulnerabilities and the attack surface as well. </st><st c="65796">In the previous sections, we have seen that with the help of Microsoft Entra ID groups, we can control and guardrail access to our running projects, but it is only one of the first steps to create more secure methods in those processes. </st><st c="66033">We need to continuously monitor the activities of our engineers and DevOps teams, such as accessing repositories and executing workflows/pipelines by logging them to Log Analytics </st><a id="_idIndexMarker878"/><st c="66213">workspaces. </st><st c="66225">We can then use threat intelligence tools such as Microsoft Azure Sentinel to discover unusual patterns throughout the application life cycle. </st><st c="66368">We can also create threat models using Microsoft’s Threat Modeling Tool on our own CI/CD pipelines to play around with security scenarios, such as how to avoid vulnerable code injections through DevOps tools, or how to avoid granting access to a developer in production environments via DevOps pipelines or GitHub workflows from risk and </st><span class="No-Break"><st c="66706">probability perspectives.</st></span></p>
			<p><st c="66731">Mission-critical workloads operating in highly regulated industries and environments, such as the US government cloud or deployments in the financial sector, require even more guardrails in place. </st><st c="66929">We can fully isolate Power Platform development tenants from production ones. </st><st c="67007">The handover between these separate tenants can happen through </st><strong class="bold"><st c="67070">Azure Service Bus</st></strong><st c="67087"> or</st><a id="_idIndexMarker879"/><st c="67090"> other messaging queue services, as the following </st><span class="No-Break"><st c="67140">figure shows:</st></span></p>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="image/B22208_07_10.jpg" alt="Figure 7.10 – Isolated tenants"/><st c="67153"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="67188">Figure 7.10 – Isolated tenants</st></p>
			<p><st c="67218">On the development side, Azure pipelines or GitHub workflows build the managed and unmanaged solutions and place them in Azure Blob Storage. </st><st c="67360">They also queue new messages in the message queue that contain the metadata information about the deployment, such as which solution from which blob container with which version the production side pipelines should deploy to. </st><st c="67586">They also contain the SAS tokens to access Blob Storage from the production tenant. </st><st c="67670">On the production side, Power Automate cloud flows pick up the queue message triggered by the Service Bus condition and execute the deployment based on the queue message to the targeted environments. </st><st c="67870">With that, there is no direct, synchronous connection between development and production tenants. </st><st c="67968">We </st><a id="_idIndexMarker880"/><st c="67971">apply </st><a id="_idIndexMarker881"/><st c="67977">the </st><strong class="bold"><st c="67981">asynchronous design pattern</st></strong><st c="68008"> here (pulling model) to terminate the original synchronous deployment call to our </st><span class="No-Break"><st c="68091">production environment.</st></span></p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor132"/><st c="68114">Summary</st></h1>
			<p><st c="68122">In this chapter, we explored the DevSecOps process, delving into its evolution, the concept of a shift-left mindset, and the integration of security tasks within our SDLC. </st><st c="68295">We then acquainted ourselves with the security architecture and guiding principles underpinning Power Platform. </st><st c="68407">Our journey continued with an examination of GHAS, leveraging CodeQL to conduct SAST. </st><st c="68493">We also investigated the solution checker, utilizing Azure DevOps build tasks and GitHub Actions to perform the platform’s built-in analysis. </st><st c="68635">Our deep dive extended into the realms of the Azure CLI, Azure DevOps scripts, pipelines, and pipeline templates, enabling us to construct an Azure DevOps project embedded with security from the ground up in a fully automated manner. </st><st c="68869">Lastly, we dedicated time to understanding the security threats that could potentially compromise our DevOps pipelines or workflows and discussed strategies to mitigate </st><span class="No-Break"><st c="69038">these risks.</st></span></p>
			<p><st c="69050">In the next chapter, we will craft a tangible solution, applying every aspect of DevOps and ALM through practical, </st><span class="No-Break"><st c="69166">hands-on walkthroughs.</st></span></p>
			<h1 id="_idParaDest-125"><a id="_idTextAnchor133"/><st c="69188">Further reading</st></h1>
			<ul>
				<li><st c="69204">DevSecOps </st><span class="No-Break"><st c="69215">controls: </st></span><a href="https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/secure/devsecops-controls"><span class="No-Break"><st c="69225">https://learn.microsoft.com/en-us/azure/cloud-adoption-framework/secure/devsecops-controls</st></span></a></li>
				<li><strong class="bold"><st c="69315">Security Development Life Cycle</st></strong><em class="italic"> </em><st c="69347">(</st><strong class="bold"><st c="69349">SDL</st></strong><st c="69352">) </st><span class="No-Break"><st c="69355">Practices: </st></span><a href="https://www.microsoft.com/en-us/securityengineering/sdl/practices"><span class="No-Break"><st c="69366">https://www.microsoft.com/en-us/securityengineering/sdl/practices</st></span></a></li>
				<li><st c="69431">Threat </st><span class="No-Break"><st c="69439">Modeling: </st></span><a href="https://www.microsoft.com/en-us/securityengineering/sdl/threatmodeling"><span class="No-Break"><st c="69449">https://www.microsoft.com/en-us/securityengineering/sdl/threatmodeling</st></span></a></li>
				<li><st c="69519">Microsoft threat modeling </st><span class="No-Break"><st c="69546">tool: </st></span><a href="https://aka.ms/threatmodelingtool"><span class="No-Break"><st c="69552">https://aka.ms/threatmodelingtool</st></span></a></li>
				<li><st c="69585">GitHub </st><span class="No-Break"><st c="69593">Dependabot: </st></span><a href="https://docs.github.com/en/code-security/dependabot"><span class="No-Break"><st c="69605">https://docs.github.com/en/code-security/dependabot</st></span></a></li>
				<li><span class="No-Break"><st c="69656">CodeQL: </st></span><a href="https://docs.github.com/en/code-security/code-scanning/introduction-to-code-scanning/about-code-scanning-with-codeql"><span class="No-Break"><st c="69665">https://docs.github.com/en/code-security/code-scanning/introduction-to-code-scanning/about-code-scanning-with-codeql</st></span></a></li>
				<li><st c="69781">Security in Power </st><span class="No-Break"><st c="69800">Platform: </st></span><a href="https://learn.microsoft.com/en-us/power-platform/admin/security/overview"><span class="No-Break"><st c="69810">https://learn.microsoft.com/en-us/power-platform/admin/security/overview</st></span></a></li>
				<li><st c="69882">GitHub Advanced Security for Azure </st><span class="No-Break"><st c="69918">DevOps: </st></span><a href="https://azure.microsoft.com/en-us/products/devops/github-advanced-security"><span class="No-Break"><st c="69926">https://azure.microsoft.com/en-us/products/devops/github-advanced-security</st></span></a></li>
				<li><st c="70000">CodeQL CLI </st><span class="No-Break"><st c="70012">binaries: </st></span><a href="https://github.com/github/codeql-cli-binaries"><span class="No-Break"><st c="70022">https://github.com/github/codeql-cli-binaries</st></span></a></li>
				<li><st c="70067">CodeQL query </st><span class="No-Break"><st c="70081">packs: </st></span><a href="https://github.com/github/codeql"><span class="No-Break"><st c="70088">https://github.com/github/codeql</st></span></a></li>
				<li><st c="70120">CodeQL </st><span class="No-Break"><st c="70128">analysis: </st></span><a href="https://docs.github.com/en/code-security/codeql-cli/getting-started-with-the-codeql-cli/preparing-your-code-for-codeql-analysis"><span class="No-Break"><st c="70138">https://docs.github.com/en/code-security/codeql-cli/getting-started-with-the-codeql-cli/preparing-your-code-for-codeql-analysis</st></span></a></li>
				<li><st c="70265">Solution </st><span class="No-Break"><st c="70275">checker: </st></span><a href="https://learn.microsoft.com/en-us/power-apps/maker/data-platform/use-powerapps-checker"><span class="No-Break"><st c="70284">https://learn.microsoft.com/en-us/power-apps/maker/data-platform/use-powerapps-checker</st></span></a></li>
				<li><st c="70370">PAC CLI for solution </st><span class="No-Break"><st c="70392">checker: </st></span><a href="https://learn.microsoft.com/en-us/power-platform/developer/cli/reference/solution#pac-solution-check"><span class="No-Break"><st c="70401">https://learn.microsoft.com/en-us/power-platform/developer/cli/reference/solution#pac-solution-check</st></span></a></li>
				<li><st c="70501">Microsoft.PowerApps.Checker.PowerShell </st><span class="No-Break"><st c="70541">module: </st></span><a href="https://learn.microsoft.com/en-us/powershell/module/microsoft.powerapps.checker.powershell/invoke-powerappschecker?view=pa-ps-latest"><span class="No-Break"><st c="70549">https://learn.microsoft.com/en-us/powershell/module/microsoft.powerapps.checker.powershell/invoke-powerappschecker?view=pa-ps-latest</st></span></a></li>
				<li><st c="70681">System access </st><span class="No-Break"><st c="70696">token: </st></span><a href="https://learn.microsoft.com/en-us/azure/devops/pipelines/process/access-tokens?view=azure-devops&amp;tabs=yaml"><span class="No-Break"><st c="70703">https://learn.microsoft.com/en-us/azure/devops/pipelines/process/access-tokens?view=azure-devops&amp;tabs=yaml</st></span></a></li>
				<li><st c="70809">Work item branch </st><span class="No-Break"><st c="70827">policy: </st></span><a href="https://learn.microsoft.com/en-us/rest/api/azure/devops/policy/configurations/create?view=azure-devops-rest-7.1&amp;tabs=HTTP#work-item-policy"><span class="No-Break"><st c="70835">https://learn.microsoft.com/en-us/rest/api/azure/devops/policy/configurations/create?view=azure-devops-rest-7.1&amp;tabs=HTTP#work-item-policy</st></span></a></li>
				<li><st c="70973">GitHub enterprise </st><span class="No-Break"><st c="70992">accounts: </st></span><a href="mailto:https://docs.github.com/en/enterprise-cloud@latest/admin/managing-your-enterprise-account/about-enterprise-accounts"><span class="No-Break"><st c="71002">https://docs.github.com/en/enterprise-cloud@latest/admin/managing-your-enterprise-account/about-enterprise-accounts</st></span></a></li>
			</ul>
		</div>
	<div id="charCountTotal" value="71117"/></body></html>