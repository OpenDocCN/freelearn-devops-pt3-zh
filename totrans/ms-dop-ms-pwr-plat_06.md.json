["```\n main\n    test\n        devA\n        devB\n        devZ\n```", "```\n    <st c=\"9056\">git config user.name $(Build.RequestedFor)</st>\n    <st c=\"9099\">git config user.email $(Build.RequestedForEmail)</st>\n    <st c=\"9148\">#creating the branch under \"dev\" folder</st>\n    <st c=\"9188\">newbranch=dev/${{ parameters.devbranch }}</st>\n    <st c=\"9230\">git checkout -b $newbranch</st>\n    <st c=\"9257\">git -c http.extraheader=\"AUTHORIZATION: bearer $(System.AccessToken)\" push origin $newbranch</st>\n    ```", "```\n    <st c=\"9611\">pac auth create --applicationId 862e5a17-d38b-43ff-b24f-88a77f59623f \\</st>\n     <st c=\"9682\">--clientSecret $(ClientSecret) \\</st>\n     <st c=\"9715\">--tenant 4ae51f31-033a-48fa-be48-5ece14d2c081</st>\n    ```", "```\n    <st c=\"9893\">az login --service-principal \\</st>\n     <st c=\"9924\">-u 862e5a17-d38b-43ff-b24f-88a77f59623f \\</st>\n     <st c=\"9966\">-p $(ClientSecret) \\</st>\n     <st c=\"9987\">--tenant 4ae51f31-033a-48fa-be48-5ece14d2c081</st>\n    <st c=\"10033\">AADObjectID=$(az ad user show \\</st>\n     <st c=\"10065\">--id $(Build.RequestedForEmail) \\</st>\n     <st c=\"10099\">--query id \\</st>\n     <st c=\"10112\">--output tsv)</st>\n    <st c=\"10165\">$(Build.RequestedForEmail)</st> system variable contains the email address of the user who started the pipeline. We use the Microsoft Entra IDâ€™s user object ID to create a Power Platform developer environment on behalf of this user (the command, per se, runs under the name of the service principal and not on behalf of our users):\n\n    ```", "```\n\n    <st c=\"10571\">After creating the Power Platform</st> <st c=\"10605\">environment, we need to assign the developer (who has started the pipeline) to it as the</st> <st c=\"10695\">System Administrator:</st>\n\n    ```", "```\n\n    ```", "```\n     {\n       \"authorization\": {\n          \"parameters\": {\n             \"tenantId\": \"GUID\",\n             \"applicationId\": \"GUID\",\n             \"clientSecret\": \"secret\"\n          },\n          \"scheme\": \"None\"\n       },\n       \"createdBy\": {},\n       \"data\": {},\n       \"isShared\": false,\n       \"isOutdated\": false,\n       \"name\": \"ConnenctionName\",\n       \"owner\": \"library\",\n       \"type\": \"powerplatform-spn\",\n       \"url\": \"DataverseURL\",\n       \"administratorsGroup\": null,\n       \"description\": \"\",\n       \"groupScopeId\": null,\n       \"operationStatus\": null,\n       \"readersGroup\": null,\n       \"serviceEndpointProjectReferences\": [\n        {\n             \"description\": \"\",\n             \"name\": \"ProjectName\",\n             \"projectReference\": {\n                \"id\": \"ProjectID\",\n                \"name\": \"ProjectName\"\n             }\n         }\n       ]\n    }\n    ```", "```\n    # Set the filename\n    filename=\"config_tokenizer.json\"\n    # Read the JSON file\n    json_string=$(cat .pipelines/$filename)\n    # Replace the value\n    new_json_string=$(jq '.authorization.parameters.clientSecret = \"$(ClientSecret)\"' <<< \"$json_string\")\n    new_json_string=$(jq '.authorization.parameters.tenantId = \"$(tenantId)\"' <<< \"$new_json_string\")\n    new_json_string=$(jq '.authorization.parameters.applicationId = \"$(applicationId)\"' <<< \"$new_json_string\")\n    new_json_string=$(jq '.url = \"${{ parameters.ppdevenvironmentURL }}\"' <<< \"$new_json_string\")\n    new_json_string=$(jq '.name = \"${{ parameters.ppdevenvironment }}\"' <<< \"$new_json_string\")\n    new_json_string=$(jq '.serviceEndpointProjectReferences[0].projectReference.id = \"$(System.TeamProjectId)\"' <<< \"$new_json_string\")\n    new_json_string=$(jq '.serviceEndpointProjectReferences[0].projectReference.name = \"$(System.TeamProject)\"' <<< \"$new_json_string\")\n    new_json_string=$(jq '.serviceEndpointProjectReferences[0].name = \"${{ parameters.ppdevenvironment }}\"' <<< \"$new_json_string\")\n    # Write the modified JSON data back to the file\n    echo $new_json_string > config.json\n    ```", "```\n    <st c=\"14659\">echo $(PatToken) | az devops login --organization $(System.CollectionUri)</st>\n    <st c=\"14733\">az devops service-endpoint create \\</st>\n     <st c=\"14769\">--organization $(System.CollectionUri) \\</st>\n    <st c=\"15175\">AzDO/.pipelines/import-solution.yml</st> in the <st c=\"15218\">Chapter06</st> folder of the GitHub repo):\n\n    ```", "```\n\n    <st c=\"16256\">We use</st> `<st c=\"16264\">${{parameters.serviceconnection}}</st>` <st c=\"16297\">as a string parameter of the pipeline, which represents the name of the service connection</st> <st c=\"16389\">previously created.</st><st c=\"16408\">We can put these steps together</st> <st c=\"16440\">into one pipeline or keep them separately.</st> <st c=\"16484\">We can also chain these pipelines by using other trigger conditions, such as</st> `<st c=\"16561\">branch created</st>`<st c=\"16575\">. For instance, a new dev branch is created under the</st> `<st c=\"16629\">dev/*</st>` <st c=\"16634\">condition looks,</st> <st c=\"16652\">as follows:</st>\n\n    ```", "```\n\n    ```", "```\n -  checkout:  git://$(System.TeamProject)/$(Build.Repository.Name)@${{parameters.targetBranch}}\n    displayName:  'Checkout  Source  Branch'\n    persistCredentials:  true\n#  Configure  email/name  and  checkout  git  branch\n-  script:  |\n      git  config  user.name  $(Build.RequestedFor)\n      git  config  user.email  $(Build.RequestedForEmail)\n      git  checkout  origin/${{parameters.targetBranch}}  --track\n[[Adding here those PowerPlatformExportSolution@2 and PowerPlatformUnpackSolution@2 steps discussed earlier.]]\n-  script:  |\n        #!/bin/bash\n        set  -e\n        #  Set  the  path  to  the  directory  containing  the  solution\n        solution_dir=\"$(Build.SourcesDirectory)/src/$(solutionName)\"\n        #  Find  all  Solution.xml  files  in  the  solution  directory  and  its  subdirectories\n        find  \"$solution_dir\"  -type  f  -name  \"Solution.xml\"  |  while  read  -r  file;  do\n                #  Replace  the  content  of  the  <Version>  tag  with  0.0.0.0\n                sed  -i  's|<Version>.*</Version>|<Version>0.0.0.0</Version>|g'  \"$file\"\n        done\n    displayName:  \"Set  version  number  to  0.0.0.0\"\n-  script:  |\n        rm  -rf  ./out/$(solutionName).zip\n        rm  -rf  ./out/$(solutionName)_managed.zip\n        git  add  --all\n        git  commit  -am  \"Solution  is  committed\"  --allow-empty\n        git  -c  httpO.extraheader=\"AUTHORIZATION:  bearer  $(System.AccessToken)\"  push  origin  ${{parameters.targetBranch}}\n```", "```\n    <st c=\"20596\">trigger:</st>\n    <st c=\"20969\">SolutionChecker</st> or performing <st c=\"20999\">automated tests</st>. We can introduce approval processes for staging environments (test and production) to control when changes are approved by release managers or environment administrators, with the help of <st c=\"21204\">Azure DevOps</st> <st c=\"21217\">Services environments</st>.\n    ```", "```\n     #  Solution  version  in  source  control  is  not  used. Instead,  create  version  at  build  time  from  the  current  build  number. -  pwsh:  |\n          Get-ChildItem  -Path  \"$(Build.SourcesDirectory)\\$(RepoName)\\${{parameters.solutionName}}\\SolutionPackage\\**\\Solution.xml\"  |\n          ForEach-Object  {\n                    (Get-Content  $_.FullName)  `\n                            -replace  '<Version>0.0.0.0<\\/Version>',  '<Version>$(Build.BuildNumber)</Version>'  |\n                    Out-File  $_.FullName\n          }\n        displayName:  'Update  Solution  XML  with  Build  Number'\n    name:  1.0.$(Date:yyyyMMdd)$(Rev:.r)\n    ```", "```\n # Power Platform Catalog Manager application's GUID\npac admin list --application 83a35943-cb41-4266-b7d2-81d60f383695\n# environment is the \"Catalog\" environment\npac catalog list --environment 0b90d036-e017-e840-9287-b1de3d95e252\n# create a submission json file\npac catalog create-submission\n# update the generated json file\npac catalog submit --environment 0b90d036-e017-e840-9287-b1de3d95e252 --path .\\submission.json --solution-zip .\\mpa_ITBase_managed.zip\n```", "```\n # File: templates/include-paccli-steps.yml\nsteps:\n-  bash:  |\n        echo  \"Installing  Pac  CLI\"\n        dotnet  tool  install  --global  Microsoft.PowerApps.CLI.Tool\n    displayName:  \"Installing  Pac  CLI\"\n```", "```\n # File: azure-pipelines.yml\njobs:\n- job: Linux\n  pool:\n    vmImage: 'ubuntu-latest'\n  steps:\n  - template: templates/include-paccli-steps.yml\n- job: Windows\n  pool:\n    vmImage: 'windows-latest'\n  steps:\n  - template: templates/include-paccli-steps.yml\n```", "```\n on:\n  workflow_call:\n    inputs:\n      version:\n        required: true\n        type: number\n      platform:\n       required: true\n       type: string\n       description: \"platform\"\njobs:\n  installpac:\n    runs-on: ${{inputs.platform}}\n    steps:\n     - name: install pac cli\n       shell: bash\n       run: |\n          echo \"version number: ${{inputs.version}}\"\n          dotnet tool install --global Microsoft.PowerApps.CLI.Tool\n```", "```\n name: Call a reusable workflow\non:\n  workflow_dispatch:\njobs:\n  call-paccli-workflow:\n    uses: jovadker/ppmanaged/.github/workflows/install-paccli.yml@main\n    with:\n      version: 8\n      platform: ubuntu-latest\n  call-workflow-windows:\n    uses: jovadker/ppmanaged/.github/workflows/install-paccli.yml@main\n    with:\n      version: 8\n      platform: windows-latest\n```", "```\n testSuite:\n   testSuiteName: Regression test suite\n   testSuiteDescription: ''\n   persona: User1\n   appLogicalName: vadkerti_contentgenerator_48e05\n   appId: ''\n   onTestCaseStart: \"\"\n   onTestCaseComplete: \"\"\n   onTestSuiteComplete: \"\"\n   networkRequestMocks:\n   testCases:\n   - testCaseName: Test with empty input\n      testCaseDescription: ''\n      testSteps: |\n         =\n         SetProperty(Prompt.Text, \"Writing some test\");\n         Select(SystemPrompt);\n         SetProperty(Prompt.Text, \"\");\n         Select(SystemPrompt);\n         Select(Prompt);\n         Select(Button4);\n         Assert(IsMatch(TextInput4.Text, \"I'm sorry, I'm not sure what you are asking. Can you please provide more context or clarify your question?<|im_end|>\"), \"Different output\");\ntestSettings:\n   filePath:\n   browserConfigurations:\n   - browser: Chromium\n      device:\n      screenWidth: 0\n      screenHeight: 0\n   locale: en-US\n   recordVideo: true\n   headless: true\n   enablePowerFxOverlay: false\n   timeout: 30000\nenvironmentVariables:\n   filePath:\n   users:\n   - personaName: User1\n      emailKey: user1Email\n      passwordKey: user1Password\n```"]