<html><head></head><body>
		<div id="_idContainer115">
			<h1 id="_idParaDest-126" class="chapter-number"><a id="_idTextAnchor134"/><st c="0">8</st></h1>
			<h1 id="_idParaDest-127"><a id="_idTextAnchor135"/><st c="2">Demonstrating ALM and DevOps Implementation</st></h1>
			<p><st c="45">In this chapter, we will go through a hands-on exercise involving a real-world example, with code snippets and step-by-step instructions. </st><st c="184">We will use one</st><a id="_idIndexMarker882"/><st c="199"> of the templates available in the </st><strong class="bold"><st c="234">Power Platform Enterprise template</st></strong><st c="268"> to demonstrate the end-to-end scenario of DevOps processes. </st><st c="329">This template is the </st><strong class="bold"><st c="350">Employee Kudos template</st></strong><st c="373">, which we can use to praise</st><a id="_idIndexMarker883"/><st c="401"> others for their outstanding achievements. </st><st c="445">The available solution</st><a id="_idIndexMarker884"/><st c="467"> provides a model-driven application (</st><strong class="bold"><st c="505">Kudos Administration App</st></strong><st c="530">) to administer the kudos, opt out users, and create badges that can be used in the canvas app to fill out the kudos. </st><st c="649">This latter canvas app, called the </st><strong class="bold"><st c="684">Kudos App</st></strong><st c="693"> in the solution, provides a user interface</st><a id="_idIndexMarker885"/><st c="736"> for users in an organization. </st><st c="767">Since the Kudos</st><a id="_idIndexMarker886"/><st c="782"> solution depends on the </st><strong class="bold"><st c="807">Employee Experience Base</st></strong><st c="831"> solution, we will learn how we can manage two solutions</st><a id="_idIndexMarker887"/><st c="887"> simultaneously by introducing multiple </st><strong class="bold"><st c="927">GitHub workflows</st></strong><st c="943"> in the release train and leveraging the deployment package. </st><st c="1004">We will define the branch strategy for this application, and we will delve into the different GitHub workflows with </st><strong class="bold"><st c="1120">DevSecOps</st></strong><st c="1129"> tasks to manage the development</st><a id="_idIndexMarker888"/><st c="1161"> of these solutions. </st><st c="1182">We will introduce backlog management and use the branch policies to protect our main branch from accidental changes. </st><st c="1299">We will create tests for the Kudos app and introduce </st><strong class="bold"><st c="1352">monitoring</st></strong><st c="1362"> to our app and flows. </st><st c="1385">Finally, we will learn about </st><strong class="bold"><st c="1414">feature flags</st></strong><st c="1427"> and how we can use them to enable</st><a id="_idIndexMarker889"/><st c="1461"> or disable certain features in </st><span class="No-Break"><st c="1493">our applications.</st></span></p>
			<p><st c="1510">In this chapter, we are going to cover the following </st><span class="No-Break"><st c="1564">main topics:</st></span></p>
			<ul>
				<li><st c="1576">Exercise – repository management and branch strategies for </st><span class="No-Break"><st c="1636">the applications</st></span></li>
				<li><st c="1652">Exercise – building CD pipelines and a </st><span class="No-Break"><st c="1692">release train</st></span></li>
				<li><st c="1705">Exercise – backlog management </st><span class="No-Break"><st c="1736">in GitHub</st></span></li>
				<li><st c="1745">Exercise – </st><span class="No-Break"><st c="1757">testing solutions</st></span></li>
				<li><st c="1774">Exercise – </st><span class="No-Break"><st c="1786">monitoring applications</st></span></li>
				<li><st c="1809">Exercise – introducing </st><span class="No-Break"><st c="1833">feature flags</st></span></li>
			</ul>
			<h1 id="_idParaDest-128"><a id="_idTextAnchor136"/><st c="1846">Technical requirements</st></h1>
			<p><st c="1869">To delve into the details of DevSecOps approaches and tools, we need to have </st><span class="No-Break"><st c="1947">the following:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="1961">A Microsoft Azure subscription</st></strong><st c="1992">: We can sign up for a Microsoft Azure subscription through </st><a href="https://azure.microsoft.com/en-us/free"><st c="2053">https://azure.microsoft.com/en-us/free</st></a><st c="2091">. If we have a Visual Studio subscription or are Microsoft Certified Trainers, we can enroll in an MSDN-based subscription with a 150 USD </st><span class="No-Break"><st c="2229">monthly credit.</st></span></li>
				<li><strong class="bold"><st c="2244">A Power Platform subscription</st></strong><st c="2274">: We can sign up for a Power Apps Developer Plan (</st><a href="https://www.microsoft.com/en-us/power-platform/products/power-apps/free"><st c="2325">https://www.microsoft.com/en-us/power-platform/products/power-apps/free</st></a><st c="2397">), if we already have a Microsoft Entra ID work account, or we can join the Microsoft 365 Developer </st><span class="No-Break"><st c="2498">Program (</st></span><a href="https://developer.microsoft.com/en-us/microsoft-365/dev-program"><span class="No-Break"><st c="2507">https://developer.microsoft.com/en-us/microsoft-365/dev-program</st></span></a><span class="No-Break"><st c="2571">).</st></span></li>
				<li><strong class="bold"><st c="2574">A GitHub handle and a public </st></strong><span class="No-Break"><strong class="bold"><st c="2604">repository</st></strong></span><span class="No-Break"><st c="2614">: (</st></span><a href="https://github.com/signup"><span class="No-Break"><st c="2618">https://github.com/signup</st></span></a><span class="No-Break"><st c="2644">)</st></span></li>
				<li><strong class="bold"><st c="2646">GitHub Advanced Security features</st></strong><st c="2679"> are available for free for public </st><span class="No-Break"><st c="2714">repositories: </st></span><a href="https://docs.github.com/en/get-started/learning-about-github/about-github-advanced-security#about-advanced-security-features"><span class="No-Break"><st c="2728">https://docs.github.com/en/get-started/learning-about-github/about-github-advanced-security#about-advanced-security-features</st></span></a><span class="No-Break"><st c="2852">.</st></span></li>
				<li><strong class="bold"><st c="2853">Samples and walkthroughs</st></strong><st c="2878"> are discussed in this chapter and are located </st><span class="No-Break"><st c="2925">at </st></span><a href="https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/tree/main/Chapter08"><span class="No-Break"><st c="2928">https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/tree/main/Chapter08</st></span></a><span class="No-Break"><st c="3027">.</st></span></li>
				<li><strong class="bold"><st c="3028">The Azure CLI</st></strong><st c="3042">: We can install the Azure CLI directly on our machine by following the installation guide (</st><a href="https://learn.microsoft.com/en-us/cli/azure/install-azure-cli#install"><st c="3135">https://learn.microsoft.com/en-us/cli/azure/install-azure-cli#install</st></a><st c="3205">), or we can use </st><strong class="bold"><st c="3223">Azure Cloud Shell</st></strong><st c="3240"> from the Azure portal to get an interactive Bash or </st><span class="No-Break"><st c="3293">PowerShell session.</st></span></li>
				<li><strong class="bold"><st c="3312">GitHub Codespaces</st></strong><st c="3330">: GitHub provides 60-hour computing resources each month to individuals for free. </st><st c="3413">To create and start GitHub Codespaces, it is enough to have a </st><span class="No-Break"><strong class="bold"><st c="3475">GitHub handle</st></strong></span><span class="No-Break"><st c="3488">.</st></span></li>
				<li><strong class="bold"><st c="3489">The GitHub CLI</st></strong><st c="3504">: We can install the GitHub CLI locally from </st><a href="https://cli.github.com/"><st c="3550">https://cli.github.com/</st></a><st c="3573">, or we can use GitHub Codespaces to start our development container under the chapter’s GitHub repository </st><span class="No-Break"><st c="3680">at </st></span><span class="No-Break"><strong class="source-inline"><st c="3683">.devcontainer/devcontaine</st><a id="_idTextAnchor137"/><st c="3708">r.json</st></strong></span><span class="No-Break"><st c="3715">.</st></span></li>
			</ul>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor138"/><st c="3716">Exercise – repository management and branch strategies for the applications</st></h1>
			<p><st c="3792">Before we delve into the hands-on</st><a id="_idIndexMarker890"/><st c="3826"> exercises, it is worth getting</st><a id="_idIndexMarker891"/><st c="3857"> familiar with the Kudos app of the Power Platform Enterprise template. </st><st c="3929">We can learn more about this solution by visiting the official documentation</st><a id="_idIndexMarker892"/><st c="4005"> of the enterprise template: </st><a href="https://learn.microsoft.com/en-us/power-platform/enterprise-templates/hr/employee-kudos/install-and-set-up"><st c="4034">https://learn.microsoft.com/en-us/power-platform/enterprise-templates/hr/employee-kudos/install-and-set-up</st></a><st c="4140">. The source code of this solution we have prepared in the repository provided with the book contains the additional extensions and workflows we will use throughout </st><span class="No-Break"><st c="4305">the exercises.</st></span></p>
			<p><st c="4319">In this exercise, we</st><a id="_idIndexMarker893"/><st c="4340"> are going to create a public </st><strong class="bold"><st c="4370">GitHub repository</st></strong><st c="4387"> that will host our applications available in the chapter’s own GitHub repository, and we are going</st><a id="_idIndexMarker894"/><st c="4486"> to set up our branch strategy and create</st><a id="_idIndexMarker895"/><st c="4527"> the prerequisites to be able to deploy the Kudos app in our Power Platform production environment. </st><st c="4627">We will take the </st><span class="No-Break"><st c="4644">following steps:</st></span></p>
			<table id="table001-1" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold"><st c="4660">Step</st></strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold"><st c="4665">Description</st></strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><st c="4677">1.</st></span></p>
						</td>
						<td class="No-Table-Style">
							<p><st c="4680">Clone the sample repository in our own GitHub </st><span class="No-Break"><st c="4727">public repository.</st></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><st c="4745">2.</st></span></p>
						</td>
						<td class="No-Table-Style">
							<p><st c="4748">Create our Power Platform production environment that will host the Kudos app and the service principal that we will use in GitHub workflows. </st><st c="4891">The credentials of the service principal are stored in </st><span class="No-Break"><st c="4946">GitHub secrets.</st></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><st c="4961">3.</st></span></p>
						</td>
						<td class="No-Table-Style">
							<p><st c="4964">Create a Microsoft Entra ID Group (Azure AD group) that will contain the users who can use </st><span class="No-Break"><st c="5056">the application.</st></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><st c="5072">4.</st></span></p>
						</td>
						<td class="No-Table-Style">
							<p><st c="5075">Create the connections of the Kudos app in the </st><span class="No-Break"><st c="5123">production environment.</st></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><st c="5146">5.</st></span></p>
						</td>
						<td class="No-Table-Style">
							<p><st c="5149">Create the deployment setting file to manage the connection references in the CI/CD workflows, and execute the </st><strong class="source-inline"><st c="5261">Release to Production</st></strong><st c="5282"> flow to deploy Kudos app in the </st><span class="No-Break"><st c="5315">production environment.</st></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><st c="5338">6.</st></span></p>
						</td>
						<td class="No-Table-Style">
							<p><st c="5341">Define our branch strategy based on the </st><span class="No-Break"><st c="5382">GitHub flow.</st></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><st c="5394">7.</st></span></p>
						</td>
						<td class="No-Table-Style">
							<p><st c="5397">Create our first branch protection rule to enforce pull requests </st><span class="No-Break"><st c="5463">on main.</st></span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="5471">Table 8.1 – Steps for the exercise</st></p>
			<p><st c="5506">To simplify the</st><a id="_idIndexMarker896"/><st c="5522"> script executions</st><a id="_idIndexMarker897"/><st c="5540"> in the</st><a id="_idIndexMarker898"/><st c="5547"> upcoming steps</st><a id="_idIndexMarker899"/><st c="5562"> and sections, we will use </st><strong class="bold"><st c="5589">GitHub Codespaces</st></strong><st c="5606">. GitHub Codespaces provides computing resources</st><a id="_idIndexMarker900"/><st c="5654"> and developer containers that are hosted in the GitHub cloud. </st><st c="5717">We have prepared such a container with various tools, such</st><a id="_idIndexMarker901"/><st c="5775"> as the GitHub CLI, </st><strong class="bold"><st c="5795">Git CLI</st></strong><st c="5802">, </st><strong class="bold"><st c="5804">PAC CLI</st></strong><st c="5811">, and Azure CLI, which are already</st><a id="_idIndexMarker902"/><st c="5845"> pre-installed on it. </st><st c="5867">Its configuration is located directly </st><span class="No-Break"><st c="5905">at </st></span><a href="https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/blob/main/.devcontainer/devcontainer.json"><span class="No-Break"><st c="5908">https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/blob/main/.devcontainer/devcontainer.json</st></span></a><span class="No-Break"><st c="6029">.</st></span></p>
			<p><st c="6030">To start the container, we need to navigate to the book’s GitHub repository in the web browser (</st><a href="https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform"><st c="6127">https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform</st></a><st c="6207">) and click on the </st><strong class="bold"><st c="6227">Code</st></strong><st c="6231"> button and then the </st><strong class="bold"><st c="6252">Create codespace on main</st></strong><st c="6276"> button, as shown in the </st><span class="No-Break"><st c="6301">following figure:</st></span></p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/B22208_08_1.jpg" alt="Figure 8.1 – Creating a codespace in GitHub"/><st c="6318"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="7233">Figure 8.1 – Creating a codespace in GitHub</st></p>
			<p><st c="7276">After clicking</st><a id="_idIndexMarker903"/><st c="7291"> the button, the </st><strong class="source-inline"><st c="7308">devcontainer.json</st></strong><st c="7325"> file </st><a id="_idIndexMarker904"/><st c="7331">available under the </st><strong class="source-inline"><st c="7351">.devcontainer</st></strong><st c="7364"> folder is parsed, and</st><a id="_idIndexMarker905"/><st c="7386"> based</st><a id="_idIndexMarker906"/><st c="7392"> on that</st><a id="_idIndexMarker907"/><st c="7400"> configuration, a new </st><strong class="bold"><st c="7422">Docker image</st></strong><st c="7434"> is created in the background. </st><st c="7465">This image will run as a container, and in a new browser, Visual Studio Code will soon appear, having pre-installed the features described in the </st><span class="No-Break"><st c="7611">JSON file:</st></span></p>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="image/B22208_08_2.jpg" alt="Figure 8.2 – A codespace in a browser"/><st c="7621"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="8188">Figure 8.2 – A codespace in a browser</st></p>
			<p><st c="8225">In the</st><a id="_idIndexMarker908"/><st c="8232"> terminal </st><a id="_idIndexMarker909"/><st c="8242">window (usually </st><strong class="bold"><st c="8258">Bash</st></strong><st c="8262">, but </st><strong class="bold"><st c="8268">PowerShell</st></strong><st c="8278"> is also available) on the screen, we</st><a id="_idIndexMarker910"/><st c="8315"> will start the tasks to create our own</st><a id="_idIndexMarker911"/><st c="8354"> repository, step </st><span class="No-Break"><st c="8372">by step:</st></span></p>
			<ol>
				<li><strong class="bold"><st c="8380">Create a Git repository in GitHub</st></strong><st c="8414">: If we want to create a repository in GitHub, we can use the GitHub CLI in the GitHub web portal. </st><st c="8514">The GitHub CLI is an open source tool that provides commands to administer our repositories, start GitHub workflows, authenticate against GitHub APIs, create issues, pull requests and releases, and so on. </st><st c="8719">If we have a </st><strong class="bold"><st c="8732">GitHub Copilot subscription</st></strong><st c="8759">, then we can use</st><a id="_idIndexMarker912"/><st c="8776"> the GitHub CLI with the </st><strong class="source-inline"><st c="8801">copilot suggest</st></strong><st c="8816"> or </st><strong class="source-inline"><st c="8820">copilot explain</st></strong><st c="8835"> parameters to interact with GitHub Copilot without switching context. </st><strong class="source-inline"><st c="8906">Gh copilot suggest</st></strong><st c="8924"> translates our natural language prompt to the correct GitHub CLI command with appropriate parameters, whereas </st><strong class="source-inline"><st c="9035">gh copilot explain</st></strong><st c="9053"> describes the command we are interested in by using natural language. </st><st c="9124">We can use the following script to create a repository called </st><strong class="source-inline"><st c="9186">Kudos</st></strong><st c="9191"> in our own GitHub Enterprise organization, if available, or using our own GitHub handle after logging in (GitHub Codespaces provides, by default, limited access to GitHub </st><span class="No-Break"><st c="9363">administrative endpoints):</st></span><pre class="source-code"><st c="9389">
export GITHUB_TOKEN=
gh auth login
gh auth switch
# move out of the book repoto "/workspaces"
cd ..
</st><st c="9490">gh repo create Kudos --public --clone</st></pre><p class="list-inset"><st c="9527">The </st><strong class="source-inline"><st c="9532">clone</st></strong><st c="9537"> parameter</st><a id="_idIndexMarker913"/><st c="9547"> in the command line immediately </st><a id="_idIndexMarker914"/><st c="9580">clones</st><a id="_idIndexMarker915"/><st c="9586"> the empty repository to our working folder. </st><st c="9631">Now, we need to copy everything from</st><a id="_idIndexMarker916"/><st c="9667"> the </st><strong class="source-inline"><st c="9672">Chapter08</st></strong><st c="9681"> folder (</st><a href="https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/tree/main/Chapter08"><st c="9690">https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform/tree/main/Chapter08</st></a><st c="9790">) to this new repository and commit those files directly into the main branch. </st><st c="9870">If we don’t use GitHub Codespaces, then we need to clone the </st><strong class="source-inline"><st c="9931">Mastering-DevOps-on-Microsoft-Power-Platform</st></strong><st c="9975"> repository with the help of the </st><span class="No-Break"><st c="10008">Git CLI:</st></span></p><pre class="source-code"><st c="10016">git clone https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform.git</st></pre><p class="list-inset"><st c="10110">After cloning, we can copy the files and folder from </st><strong class="source-inline"><st c="10164">Chapter08</st></strong><st c="10173"> folder to our </st><strong class="source-inline"><st c="10188">Kudos</st></strong><st c="10193"> folder (the </st><span class="No-Break"><st c="10206">git repo):</st></span></p><pre class="source-code"><st c="10216">cp -rT ./Mastering-DevOps-on-Microsoft-Power-Platform/Chapter08/ ./Kudos</st></pre><p class="list-inset"><st c="10289">Then, we can use the following scripts to add, commit, and push the files to the </st><span class="No-Break"><st c="10371">new repository:</st></span></p><pre class="source-code"><st c="10386"># use the credentials of gh CLI in Git commands
gh auth setup-git
git config --global user.email "ouremail@address.com"
git config --global user.name "Our Name"
git add .
</st><st c="10558">git commit -m "Baseline Kudos app"
git branch -M main
git push -u origin main</st></pre><p class="list-inset"><st c="10635">With</st><a id="_idIndexMarker917"/><st c="10640"> that, we </st><a id="_idIndexMarker918"/><st c="10650">have everything in our new</st><a id="_idIndexMarker919"/><st c="10676"> repository that we will use in</st><a id="_idIndexMarker920"/><st c="10707"> our </st><span class="No-Break"><st c="10712">hands-on exercises:</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer087" class="IMG---Figure">
					<img src="image/B22208_08_3.jpg" alt="Figure 8.3 – Our own repository with the Kudos app"/><st c="10731"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="11338">Figure 8.3 – Our own repository with the Kudos app</st></p>
			<p class="list-inset"><st c="11388">In our new repository, there</st><a id="_idIndexMarker921"/><st c="11417"> is also a </st><strong class="source-inline"><st c="11428">.devcontainer</st></strong><st c="11441"> folder containing a GitHub Codespace definition. </st><st c="11491">Here, let’s create our own codespace on the main branch and authenticate against GitHub once again to get write access to </st><span class="No-Break"><st c="11613">the repository:</st></span></p>
			<pre class="source-code"><st c="11628">
export GITHUB_TOKEN=
gh auth login
gh auth switch</st></pre>			<p class="list-inset"><st c="11678">In addition, if </st><a id="_idIndexMarker922"/><st c="11695">we have done every preparation</st><a id="_idIndexMarker923"/><st c="11725"> step right and if we open up the </st><strong class="bold"><st c="11759">Actions</st></strong><st c="11766"> tab</st><a id="_idIndexMarker924"/><st c="11770"> now, we should see the available GitHub workflows, as shown in the </st><span class="No-Break"><st c="11838">following figure:</st></span></p>
			<div>
				<div id="_idContainer088" class="IMG---Figure">
					<img src="image/B22208_08_4.jpg" alt="Figure 8.4 – GitHub workflows for the Kudos app"/><st c="11855"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="12492">Figure 8.4 – GitHub workflows for the Kudos app</st></p>
			<p class="list-inset"><st c="12539">We will use these workflows soon to deploy our Kudos app to a Power Platform </st><span class="No-Break"><st c="12617">production environment.</st></span></p>
			<ol>
				<li value="2"><strong class="bold"><st c="12640">Kudos application’s prerequisites</st></strong><st c="12674">: There are a few prerequisites that we need to fulfill to get these GitHub workflows running as expected. </st><st c="12782">First, we need to create an </st><strong class="bold"><st c="12810">Azure App registration</st></strong><st c="12832"> in our tenant that we will use</st><a id="_idIndexMarker925"/><st c="12863"> in our GitHub workflows to import and export our solutions accordingly. </st><st c="12936">As we learned in </st><a href="B22208_05.xhtml#_idTextAnchor089"><span class="No-Break"><em class="italic"><st c="12953">Chapter 5</st></em></span></a><st c="12962">, the easiest way to create a Power Platform environment is to use the </st><strong class="source-inline"><st c="13033">pac admin create</st></strong><st c="13049"> command, whereas to create a service</st><a id="_idIndexMarker926"/><st c="13086"> principal, we apply the </st><strong class="source-inline"><st c="13111">pac admin create-service-principal</st></strong><st c="13145"> command. </st><st c="13155">So, let’s create the production environment for our Kudos application, using an interactive login to our Power Platform tenant in GitHub Codespaces </st><span class="No-Break"><st c="13303">or locally:</st></span><pre class="source-code"><st c="13314">
pac auth create
</st><strong class="bold"><st c="13331">pac admin create --name Kudos-Prod --region Europe \</st></strong>
<strong class="bold"><st c="13383">    --currency EUR \</st></strong>
<strong class="bold"><st c="13400">    --type Production</st></strong></pre><p class="list-inset"><st c="13418">We can use the following command to find the recently created environment and its </st><span class="No-Break"><st c="13501">environment URL:</st></span></p><pre class="source-code"><st c="13517">pac admin list --name Kudos-Prod</st></pre><p class="list-inset"><st c="13550">We </st><a id="_idIndexMarker927"/><st c="13554">then run the</st><a id="_idIndexMarker928"/><st c="13566"> following command to create</st><a id="_idIndexMarker929"/><st c="13594"> the service principal with the </st><strong class="bold"><st c="13626">System Administrator</st></strong><st c="13646"> role, using the production URL queried </st><a id="_idIndexMarker930"/><st c="13686">previously, as we did in </st><a href="B22208_05.xhtml#_idTextAnchor089"><span class="No-Break"><em class="italic"><st c="13711">Chapter 5</st></em></span></a><st c="13720"> when we</st><a id="_idIndexMarker931"/><st c="13728"> integrated a Power Platform pipeline </st><span class="No-Break"><st c="13766">with GitHub:</st></span></p><pre class="source-code"><st c="13778">pac admin create-service-principal -env &lt;&lt;URL&gt;&gt; -n </st><strong class="bold"><st c="13830">KudosSPN</st></strong><st c="13838"> --role "System Administrator"</st></pre><p class="list-inset"><st c="13868">The last call requires administrative privileges</st><a id="_idIndexMarker932"/><st c="13917"> not just in the Power Platform tenant but also in </st><strong class="bold"><st c="13968">Microsoft Entra ID</st></strong><st c="13986"> (the </st><strong class="source-inline"><st c="13992">Application.ReadWrite.Allpermission</st></strong><st c="14027"> role). </st><st c="14035">This command returns the application ID (</st><strong class="source-inline"><st c="14076">Application Id</st></strong><st c="14091">), tenant ID (</st><strong class="source-inline"><st c="14106">Tenant Id</st></strong><st c="14116">), service principal ID (</st><strong class="source-inline"><st c="14142">Service Principal Id</st></strong><st c="14163">), and client</st><a id="_idIndexMarker933"/><st c="14177"> secret (</st><strong class="source-inline"><st c="14186">Client Secret</st></strong><st c="14200">) that we need to store as </st><strong class="bold"><st c="14228">GitHub repository secrets</st></strong><st c="14253">. We need to introduce these secrets with the names </st><strong class="source-inline"><st c="14305">PPAPPID</st></strong><st c="14312">, </st><strong class="source-inline"><st c="14314">PPAPPSECRET</st></strong><st c="14325">, and </st><strong class="source-inline"><st c="14331">PPTENANTID</st></strong><st c="14341"> to our new GitHub repository to get the </st><a id="_idIndexMarker934"/><a id="_idTextAnchor139"/><st c="14382">available GitHub workflows </st><span class="No-Break"><st c="14409">to run:</st></span></p><ul><li><strong class="source-inline"><st c="14416">PPAPPID</st></strong><st c="14424"> is the application ID returned by </st><span class="No-Break"><st c="14459">the command</st></span></li><li><strong class="source-inline"><st c="14470">PPAPPSECRET</st></strong><st c="14482"> is the </st><span class="No-Break"><st c="14490">client secret</st></span></li><li><strong class="source-inline"><st c="14503">PPTENANTID</st></strong><st c="14514"> is the </st><span class="No-Break"><st c="14522">tenant ID</st></span></li></ul><p class="list-inset"><st c="14531">We can use the GitHub CLI to create these secrets at a </st><span class="No-Break"><st c="14587">repository level:</st></span></p><pre class="source-code"><st c="14604">echo "&lt;&lt;Application Id&gt;&gt;" | gh secret set PPAPPID
echo "&lt;&lt;Client Secret&gt;&gt;" | gh secret set PPAPPSECRET
echo "&lt;&lt;Tenant Id&gt;&gt;" | gh secret set PPTENANTID</st></pre><p class="list-inset"><st c="14755">Since </st><a id="_idIndexMarker935"/><st c="14762">we have created the repo with the </st><strong class="source-inline"><st c="14796">gh repo create</st></strong><st c="14810"> command</st><a id="_idIndexMarker936"/><st c="14818"> in our GitHub codespace, the default repository is our Kudos repository. </st><st c="14892">Otherwise, we can use </st><strong class="source-inline"><st c="14914">gh repo set-default owner/repo</st></strong><st c="14944"> command to set it </st><span class="No-Break"><st c="14963">as default.</st></span></p></li>				<li><strong class="bold"><st c="14974">Create an AAD group</st></strong><st c="14994">: If we use the service principal to deploy a solution to our target environment, then the applications within the solution are owned by the service principal. </st><st c="15155">To give others access to the applications, we need</st><a id="_idIndexMarker937"/><st c="15205"> to create a </st><strong class="bold"><st c="15218">Microsoft Entra ID security group</st></strong><st c="15251"> (which we learned how to do in </st><a href="B22208_07.xhtml#_idTextAnchor115"><span class="No-Break"><em class="italic"><st c="15283">Chapter 7</st></em></span></a><st c="15292">). </st><st c="15296">We need to be assigned the </st><em class="italic"><st c="15323">Groups Administrator</st></em><st c="15343"> Microsoft Entra built-in role to manage group creation and member assignment. </st><st c="15422">Let’s execute the following</st><a id="_idIndexMarker938"/><st c="15449"> script to create a Microsoft Entra </st><span class="No-Break"><st c="15485">ID group:</st></span><pre class="source-code">
<strong class="bold"><st c="15494">az login</st></strong>
<strong class="bold"><st c="15503">az ad group create --display-name $GROUP_NAME --mail-nickname $GROUP_NAME</st></strong><st c="15577">
# get the user object id
</st><strong class="bold"><st c="15603">AADObjectID=$(az ad user show \</st></strong>
<strong class="bold"><st c="15634">             --id $userPrincipalName \</st></strong>
<strong class="bold"><st c="15660">             --query id \</st></strong>
<strong class="bold"><st c="15673">             --output tsv)</st></strong><st c="15687">
# add a member to the group
</st><strong class="bold"><st c="15716">az ad group member add --group $GROUP_NAME --member-id $AADObjectID</st></strong></pre><p class="list-inset"><st c="15783">With the </st><a id="_idIndexMarker939"/><st c="15793">PowerShell script available under </st><strong class="source-inline"><st c="15827">\.github\workflows\share-app.ps1</st></strong><st c="15859">, we can share the Kudos app with the</st><a id="_idIndexMarker940"/><st c="15896"> created security group. </st><st c="15921">At the time </st><a id="_idIndexMarker941"/><st c="15933">of writing, there is no PAC CLI command that can be used to share an app with Entra ID groups; that’s why </st><a id="_idIndexMarker942"/><st c="16039">we had to use </st><strong class="bold"><st c="16053">PowerShell</st></strong><st c="16063"> and  the cmdlet </st><strong class="source-inline"><st c="16079">Set-AdminPowerAppRoleAssignment -PrincipalType "Group" -PrincipalObjectId $GroupID -RoleName CanView -AppName $AppName -EnvironmentName $EnvironmentName</st></strong> <strong class="bold"><st c="16231">cmdlet</st></strong><st c="16238"> here. </st><st c="16245">The security group’s object ID needs to be provided as an input </st><a id="_idIndexMarker943"/><st c="16309">parameter to the script. </st><st c="16334">The GitHub workflows available in the repository also expect this AAD group ID </st><span class="No-Break"><st c="16413">as input.</st></span></p></li>				<li><strong class="bold"><st c="16422">Prepare the Power Platform production environment</st></strong><st c="16472">: The Kudos app contains four Power Automate cloud flows and Power Apps canvas apps that use connection references and their corresponding connections, created for </st><em class="italic"><st c="16637">Dataverse</st></em><st c="16646">, </st><em class="italic"><st c="16648">Office 365 Outlook</st></em><st c="16666">, and </st><em class="italic"><st c="16672">Office 365 Users</st></em><st c="16688"> connectors. </st><st c="16701">The </st><strong class="bold"><st c="16705">connection references</st></strong><st c="16726"> are used to make the connections</st><a id="_idIndexMarker944"/><st c="16759"> adjustable in other environments. </st><st c="16794">The </st><strong class="bold"><st c="16798">connectors</st></strong><st c="16808"> are the definitions</st><a id="_idIndexMarker945"/><st c="16828"> of the </st><a id="_idIndexMarker946"/><st c="16836">connections; like classes in </st><strong class="bold"><st c="16865">object-oriented programming</st></strong><st c="16892"> (</st><strong class="bold"><st c="16894">OOP</st></strong><st c="16897">), they are </st><strong class="bold"><st c="16910">OpenAPI-based</st></strong> <strong class="bold"><st c="16923">REST API</st></strong><st c="16932"> specifications that</st><a id="_idIndexMarker947"/><st c="16952"> are instantiated as </st><strong class="bold"><st c="16973">connections</st></strong><st c="16984"> (i.e., objects in OOP) in the environment. </st><st c="17028">When we use solutions to create our flows, apps, and other Power Platform assets, then every time we initiate a new connection in a flow or an app, a </st><strong class="bold"><st c="17178">connection reference</st></strong><st c="17198"> is automatically created in the solution. </st><st c="17241">If we work outside of the solution and create a flow under </st><strong class="bold"><st c="17300">My flows</st></strong><st c="17308">, then direct connections are created instead of connection references. </st><st c="17380">However, a Dataverse connection can be created by the PAC CLI on behalf of a service principal in our production environment with the </st><span class="No-Break"><st c="17514">following script:</st></span><pre class="source-code"><st c="17531">
pac connection create [--environment] --tenant-id --name --application-id --client-secret</st></pre><p class="list-inset"><st c="17621">The </st><a id="_idIndexMarker948"/><st c="17626">Office 365 Outlook and Office 365 Users</st><a id="_idIndexMarker949"/><st c="17665"> connectors require service accounts </st><a id="_idIndexMarker950"/><st c="17702">and real user accounts, not service principals, to authenticate in Outlook and Office 365 APIs. </st><st c="17798">We cannot assign O365 or M365 licenses to service principals. </st><st c="17860">That’s why we need to create those </st><a id="_idIndexMarker951"/><st c="17895">connections in the target environment before deploying our solutions. </st><st c="17965">We can create</st><a id="_idIndexMarker952"/><st c="17978"> these connections in the </st><strong class="bold"><st c="18004">PowerApps maker portal</st></strong><st c="18026"> under the </st><strong class="bold"><st c="18037">Connections</st></strong><st c="18048"> blade by clicking the </st><strong class="bold"><st c="18071">+ New connection</st></strong><st c="18087"> button, as shown in the </st><span class="No-Break"><st c="18112">following figure:</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/B22208_08_5.jpg" alt="Figure 8.5 – Connections for the Kudos application"/><st c="18129"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="18589">Figure 8.5 – Connections for the Kudos application</st></p>
			<p class="list-inset"><st c="18639">After creating the three </st><a id="_idIndexMarker953"/><st c="18665">connections, we should see the same result as displayed in the figure. </st><st c="18736">Finally, we need to share these connections with the service principal and the application user that was created earlier in </st><em class="italic"><st c="18860">step 2</st></em><st c="18866">, by clicking the three dots and selecting the </st><strong class="bold"><st c="18913">Share</st></strong><st c="18918"> menu element </st><span class="No-Break"><st c="18932">in </st></span><span class="No-Break"><strong class="bold"><st c="18935">Connections</st></strong></span><span class="No-Break"><st c="18946">:</st></span></p>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="image/B22208_08_6.jpg" alt="Figure 8.6 – Sharing the connection with the service principal"/><st c="18948"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="19269">Figure 8.6 – Sharing the connection with the service principal</st></p>
			<p class="list-inset"><st c="19331">Let’s </st><a id="_idIndexMarker954"/><st c="19338">use these connections in our deployment by</st><a id="_idIndexMarker955"/><st c="19380"> introducing the deployment </st><span class="No-Break"><st c="19408">settings </st></span><span class="No-Break"><a id="_idIndexMarker956"/></span><span class="No-Break"><st c="19417">file.</st></span></p>
			<ol>
				<li value="5"><strong class="bold"><st c="19422">Deployment settings file</st></strong><st c="19447">: To use </st><a id="_idIndexMarker957"/><st c="19457">these connections during the deployment of the solution, we need to use a so-called </st><strong class="bold"><st c="19541">deployment setting file</st></strong><st c="19564">. This file has been already</st><a id="_idIndexMarker958"/><st c="19592"> generated for the solution with the </st><span class="No-Break"><st c="19629">following script:</st></span><pre class="source-code"><st c="19646">
pac solution create-settings --solution-zip .\mpa_Kudos_1_0_0_36.zip</st></pre><p class="list-inset"><st c="19715">This command takes out the </st><strong class="bold"><st c="19743">connection references</st></strong><st c="19764"> from the solution and exposes</st><a id="_idIndexMarker959"/><st c="19794"> them to be set during the import; refer to the </st><strong class="source-inline"><st c="19842">\src\mpa_Kudos\deploymentSettings.json</st></strong><st c="19880"> file in the </st><span class="No-Break"><st c="19893">GitHub repository:</st></span></p><pre class="source-code"><st c="19911">{
  "EnvironmentVariables": [],
  </st><strong class="bold"><st c="19942">"ConnectionReferences": [</st></strong><st c="19967">
    {
      "LogicalName": "mpa_KudosDataverse",
      "ConnectionId": "[Dataverse]",
      "ConnectorId": "/providers/Microsoft.PowerApps/apis/shared_commondataserviceforapps"
    },
    </st><strong class="bold"><st c="20126">{</st></strong>
<strong class="bold"><st c="20127">      "LogicalName": "mpa_KudosO365",</st></strong>
<strong class="bold"><st c="20159">      "ConnectionId": "[O365]",</st></strong>
<strong class="bold"><st c="20185">      "ConnectorId": "/providers/Microsoft.PowerApps/apis/shared_office365users"</st></strong>
<strong class="bold"><st c="20260">    },</st></strong><st c="20263">
    {
      "LogicalName": "mpa_KudosOutlook",
      "ConnectionId": "[Outlook]",
      "ConnectorId": "/providers/Microsoft.PowerApps/apis/shared_office365"
    }]}</st></pre><p class="list-inset"><st c="20403">The missing </st><strong class="source-inline"><st c="20416">ConnectionId</st></strong><st c="20428"> values are set</st><a id="_idIndexMarker960"/><st c="20443"> during</st><a id="_idIndexMarker961"/><st c="20450"> the GitHub workflow runs. </st><st c="20477">These values </st><a id="_idIndexMarker962"/><st c="20490">are the incoming parameters of our workflows. </st><st c="20536">To get these values from our Power Platform environment, we</st><a id="_idIndexMarker963"/><st c="20595"> need to click on the connections in the </st><strong class="bold"><st c="20636">Power Apps maker portal</st></strong><st c="20659"> and copy the IDs of the connections</st><a id="_idIndexMarker964"/><st c="20695"> from the corresponding URLs. </st><st c="20725">The following figure shows the connection ID of the Dataverse connection, highlighted in </st><span class="No-Break"><st c="20814">the URL:</st></span></p></li>			</ol>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<img src="image/B22208_08_7.jpg" alt="Figure 8.7 – The connection ID in the URL"/><st c="20822"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="21339">Figure 8.7 – The connection ID in the URL</st></p>
			<p class="list-inset"><st c="21380">The first</st><a id="_idIndexMarker965"/><st c="21390"> GUID in the URL is the environment ID, whereas </st><a id="_idIndexMarker966"/><st c="21438">the second GUID is the connection </st><a id="_idIndexMarker967"/><st c="21472">ID. </st><st c="21476">The following example highlights </st><a id="_idIndexMarker968"/><st c="21509">the </st><span class="No-Break"><st c="21513">second GUID:</st></span></p>
			<pre class="source-code"><st c="21525">
https://make.powerapps.com/environments/&lt;&lt;Environment GUID&gt;&gt;/connections/shared_commondataserviceforapps/</st><strong class="bold"><st c="21631">cc54b39cf98e41e0969dfdd7b90e2e6a</st></strong><st c="21664">/details#</st></pre>			<p class="list-inset"><st c="21674">We need to store these IDs or commit them in our repository. </st><st c="21736">In </st><a href="B22208_10.xhtml#_idTextAnchor172"><span class="No-Break"><em class="italic"><st c="21739">Chapter 10</st></em></span></a><st c="21749">, we will learn more about the deployment settings of Power Platform solutions. </st><st c="21829">The </st><em class="italic"><st c="21833">Release to Production</st></em><st c="21854"> GitHub workflow under </st><strong class="source-inline"><st c="21877">\.github\workflows\cd-to-prod.yml</st></strong><st c="21910"> contains the default values of these connection IDs, which we can overwrite and commit back to the main branch. </st><st c="22023">With everything in place, we can deploy the Kudos app from the main branch to our production Power Platform environment, by starting this workflow with the gathered </st><span class="No-Break"><st c="22188">connection IDs:</st></span></p>
			<div>
				<div id="_idContainer092" class="IMG---Figure">
					<img src="image/B22208_08_8.jpg" alt="Figure 8.8 – The Release to Production workflow with parameters"/><st c="22203"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="22548">Figure 8.8 – The Release to Production workflow with parameters</st></p>
			<p class="list-inset"><st c="22611">To </st><a id="_idIndexMarker969"/><st c="22615">store these connection IDs, we can</st><a id="_idIndexMarker970"/><st c="22649"> alternatively</st><a id="_idIndexMarker971"/><st c="22663"> use </st><strong class="bold"><st c="22668">GitHub environments</st></strong><st c="22687">. In the case of our developer</st><a id="_idIndexMarker972"/><st c="22717"> branch, we will use a </st><a id="_idIndexMarker973"/><st c="22740">dedicated GitHub environment to pre-configure these values later in </st><span class="No-Break"><st c="22808">this chapter.</st></span></p>
			<ol>
				<li value="6"><strong class="bold"><st c="22821">Create our branch strategy</st></strong><st c="22848">: At the beginning of our development project, we need to design which branching and merging strategy we will use. </st><st c="22964">In </st><a href="B22208_05.xhtml#_idTextAnchor089"><span class="No-Break"><em class="italic"><st c="22967">Chapter 5</st></em></span></a><st c="22976">, we learned about the </st><strong class="bold"><st c="22999">GitHub flow</st></strong><st c="23010">, and this is what we</st><a id="_idIndexMarker974"/><st c="23031"> are going to create for the Kudos application. </st><st c="23079">The following figure shows our strategy and the direct mapping between Power Platform environments and </st><span class="No-Break"><st c="23182">Git branches:</st></span></li>
			</ol>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<img src="image/B22208_08_9.jpg" alt="Figure 8.9 – The branch strategy"/><st c="23195"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="23301">Figure 8.9 – The branch strategy</st></p>
			<p class="list-inset"><st c="23333">The</st><a id="_idIndexMarker975"/><st c="23337"> arrows</st><a id="_idIndexMarker976"/><st c="23344"> between the Power Platform environments and Git branches represent the code and deployment flows. </st><st c="23443">A production environment</st><a id="_idIndexMarker977"/><st c="23467"> can handle only </st><strong class="bold"><st c="23484">pull requests</st></strong><st c="23497"> (i.e., the solutions are only imported into those environments), whereas</st><a id="_idIndexMarker978"/><st c="23570"> developer environments should support a bidirectional mode, since changes in those environments shall be exported back to Git repos, to dev branches. </st><st c="23721">In our case, the </st><strong class="source-inline"><st c="23738">dev/DEV-US_XXX_Z</st></strong><st c="23754"> branch represents a short-lived feature branch containing the implementation </st><a id="_idIndexMarker979"/><st c="23832">of a user story or a </st><span class="No-Break"><st c="23853">bug fix.</st></span></p>
			<ol>
				<li value="7"><strong class="bold"><st c="23861">Create our branch protection rule</st></strong><st c="23895">: In </st><a href="B22208_06.xhtml#_idTextAnchor103"><span class="No-Break"><em class="italic"><st c="23901">Chapter 6</st></em></span></a><st c="23910">, we learned about branch</st><a id="_idIndexMarker980"/><st c="23935"> policies and </st><strong class="bold"><st c="23949">branch protection rules</st></strong><st c="23972">, as well as which settings we can configure</st><a id="_idIndexMarker981"/><st c="24016"> to our repositories in </st><strong class="bold"><st c="24040">Azure DevOps Services</st></strong><st c="24061"> and GitHub. </st><st c="24074">Let’s create our minimum branch protection rule for our main branch by visiting our GitHub repository in a web browser and opening </st><strong class="bold"><st c="24205">Settings</st></strong><st c="24213">, then the </st><strong class="bold"><st c="24224">Branches</st></strong><st c="24232"> blade, and then clicking on the </st><strong class="bold"><st c="24265">Add branch protection rule</st></strong><st c="24291"> button. </st><st c="24300">In the textbox, we need to type </st><strong class="source-inline"><st c="24332">main</st></strong><st c="24336"> in the </st><strong class="bold"><st c="24344">Branch name pattern</st></strong><st c="24363"> field, and we need to select the </st><strong class="bold"><st c="24397">Require a pull request before merging</st></strong><st c="24434"> checkbox, as shown in the </st><span class="No-Break"><st c="24461">following figure:</st></span></li>
			</ol>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="image/B22208_08_10.jpg" alt="Figure 8.10 – The branch protection rule for main"/><st c="24478"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="26022">Figure 8.10 – The branch protection rule for main</st></p>
			<p class="list-inset"><st c="26071">At the </st><a id="_idIndexMarker982"/><st c="26079">bottom of the page, we need</st><a id="_idIndexMarker983"/><st c="26106"> to click</st><a id="_idIndexMarker984"/><st c="26115"> on the </st><strong class="bold"><st c="26123">Create</st></strong><st c="26129"> button. </st><st c="26138">With this setting, we ensure that only pull requests are allowed to our main branch. </st><st c="26223">Note that, by default, </st><strong class="bold"><st c="26246">Require approvals</st></strong><st c="26263"> is checked, which means at least someone else should review our pull requests. </st><st c="26343">Since we cannot assign a pull request to ourselves, if we </st><a id="_idIndexMarker985"/><st c="26401">work</st><a id="_idIndexMarker986"/><st c="26405"> alone, it is recommended to uncheck </st><strong class="bold"><st c="26442">Require approvals</st></strong><st c="26459">. However, it is obviously not best practice to do so in a real-world project. </st><st c="26538">Besides this setting, we need to define the type of merge that we want to allow developers to do. </st><st c="26636">It is recommended to use </st><strong class="bold"><st c="26661">squash merging</st></strong><st c="26675">, which combines all commits</st><a id="_idIndexMarker987"/><st c="26703"> from the head branch into a single commit in the target branch. </st><st c="26768">This significantly reduces the commit history, since all changes we commit in our developer branch sequentially will be combined into one commit after a successful pull request to the parent branch. </st><st c="26967">We can force this type of merge by going to the </st><strong class="bold"><st c="27015">Settings</st></strong><st c="27023"> menu in GitHub and, under the </st><strong class="bold"><st c="27054">General</st></strong><st c="27061"> blade, removing every other </st><span class="No-Break"><st c="27090">merge type:</st></span></p>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="image/B22208_08_11.jpg" alt="Figure 8.11 – Enforcing squash merging"/><st c="27101"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="27759">Figure 8.11 – Enforcing squash merging</st></p>
			<p class="list-inset"><st c="27797">Checking</st><a id="_idIndexMarker988"/><st c="27806"> only </st><strong class="bold"><st c="27812">Allow squash merging</st></strong><st c="27832"> will force </st><a id="_idIndexMarker989"/><st c="27844">the pull</st><a id="_idIndexMarker990"/><st c="27852"> requests to be squash commits. </st><st c="27884">The other two options, </st><strong class="bold"><st c="27907">Allow merge commits</st></strong><st c="27926"> and </st><strong class="bold"><st c="27931">Allow rebase merging</st></strong><st c="27951">, will copy the commit history of the child </st><a id="_idIndexMarker991"/><st c="27995">branches into the main branch, leading to large history nodes in the </st><span class="No-Break"><st c="28064">commit history.</st></span></p>
			<p><st c="28079">If we encounter any issue in the </st><a id="_idIndexMarker992"/><st c="28113">previous steps, we can use the following settings to get verbose logging of </st><span class="No-Break"><st c="28189">the commands.</st></span></p>
			<ul>
				<li><strong class="bold"><st c="28202">The GitHub CLI</st></strong><st c="28217">: We need to introduce the </st><strong class="source-inline"><st c="28245">GH_DEBUG</st></strong><st c="28253"> environment variable. </st><st c="28276">If its value is </st><strong class="source-inline"><st c="28292">1</st></strong><st c="28293">, it provides more insights, but if we set this variable to </st><strong class="source-inline"><st c="28353">api</st></strong><st c="28356">, then we will see every REST API call to the </st><span class="No-Break"><st c="28402">GitHub endpoints:</st></span><pre class="source-code"><st c="28419">
export GH_DEBUG=</st><strong class="bold"><st c="28436">api</st></strong></pre><p class="list-inset"><st c="28440">After setting this environment variable, every </st><strong class="source-inline"><st c="28488">gh</st></strong><st c="28490"> command executed will print the detailed trace in the </st><span class="No-Break"><st c="28545">standard output.</st></span></p></li>				<li><strong class="bold"><st c="28561">The Azure CLI</st></strong><st c="28575">: In the case of the Azure CLI, it is enough to add the </st><strong class="source-inline"><st c="28632">--debug</st></strong><st c="28639"> flag to the end of every command that we want </st><span class="No-Break"><st c="28686">to troubleshoot:</st></span><pre class="source-code"><st c="28702">
az login </st><strong class="bold"><st c="28712">--debug</st></strong></pre></li>				<li><strong class="bold"><st c="28719">The PAC CLI</st></strong><st c="28731">: At the </st><a id="_idIndexMarker993"/><st c="28741">time of writing, the PAC CLI </st><a id="_idIndexMarker994"/><st c="28770">doesn’t offer any flag or environment variable to enrich the verbose logs in the standard output. </st><st c="28868">If we need to troubleshoot PAC CLI commands, we can</st><a id="_idIndexMarker995"/><st c="28919"> only use the log available under </st><span class="No-Break"><st c="28953">the</st></span><span class="No-Break"><a id="_idIndexMarker996"/></span><span class="No-Break"><st c="28956"> following:</st></span><pre class="source-code">
<strong class="bold"><st c="28967">%userprofile%\.dotnet\tools\.store\microsoft.powerapps.cli.tool\1.30.7\microsoft.powerapps.cli.tool\1.30.7\tools\net6.0\any\logs\pac-log.txt</st></strong></pre></li>			</ul>
			<p><st c="29108">Now, we are fully prepared to make some changes to the Kudos application. </st><st c="29183">Let’s understand the existing GitHub workflows and their roles in the </st><span class="No-Break"><st c="29253">DevOps processes.</st></span></p>
			<h1 id="_idParaDest-130"><a id="_idTextAnchor140"/><st c="29270">Exercise – building CD pipelines and a release train</st></h1>
			<p><st c="29323">In the GitHub repository, we will find the following prebuilt GitHub workflows to manage the life cycle</st><a id="_idIndexMarker997"/><st c="29427"> of our development project, end </st><span class="No-Break"><st c="29460">to end:</st></span></p>
			<ol>
				<li><strong class="bold"><st c="29467">Set up a dev environment GitHub workflow</st></strong><st c="29508">: Located under </st><strong class="source-inline"><st c="29525">.github/workflows/setup-dev-environment.yml</st></strong><st c="29568">, this workflow creates a developer branch with the name provided before the workflow execution (the branch name follows the naming rule, </st><strong class="source-inline"><st c="29706">dev/branch_name</st></strong><st c="29721">). </st><st c="29725">The pipeline spins up a Power Platform developer environment with the same name used for the branch. </st><st c="29826">We need to add the work account that we use in the Power Platform tenant to create the developer environment on behalf of our account. </st><st c="29961">At the end of the workflow, we can see</st><a id="_idIndexMarker998"/><st c="29999"> additional steps that grant </st><strong class="bold"><st c="30028">System Administrator rights</st></strong><st c="30055"> to our work account and to the service principal that we created for the production environment earlier. </st><st c="30161">Let’s execute this workflow with the </st><span class="No-Break"><st c="30198">following parameters:</st></span></li>
			</ol>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<img src="image/B22208_08_12.jpg" alt="Figure 8.12 – Workflow inputs of “Setup dev environment”"/><st c="30219"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="30366">Figure 8.12 – Workflow inputs of “Setup dev environment”</st></p>
			<p class="list-inset"><st c="30422">After a successful run, we will see a new Power Platform developer environment with the name </st><strong class="source-inline"><st c="30516">DEV-US_XXX_Z</st></strong><st c="30528"> and a branch with the </st><span class="No-Break"><st c="30551">name </st></span><span class="No-Break"><strong class="source-inline"><st c="30556">dev/DEV-US_XXX_Z</st></strong></span><span class="No-Break"><st c="30572">.</st></span></p>
			<ol>
				<li value="2"><strong class="bold"><st c="30573">The Import to dev GitHub workflow</st></strong><st c="30607">: After having the dev</st><a id="_idIndexMarker999"/><st c="30630"> environment, we want to deploy the solutions (the Employee Experience and Kudos) to our Power Platform developer environment. </st><st c="30757">To do this, we need to create a GitHub environment with the same name that we gave our branch, with the </st><strong class="source-inline"><st c="30861">dev</st></strong><st c="30864"> prefix. </st><st c="30873">In our case, it is </st><strong class="source-inline"><st c="30892">dev/DEV-US_XXX_Z</st></strong><st c="30908">. We can create the GitHub environment by opening the </st><strong class="bold"><st c="30962">Settings</st></strong><st c="30970"> tab and then the </st><strong class="bold"><st c="30988">Environments</st></strong><st c="31000"> blade in the GitHub portal (the GH CLI doesn’t support creating GitHub environments). </st><st c="31087">Here, we need to introduce the following three variables that our </st><em class="italic"><st c="31153">Import to dev</st></em><st c="31166"> workflow will use for </st><span class="No-Break"><st c="31189">connection IDs:</st></span><ul><li><span class="No-Break"><strong class="source-inline"><st c="31204">DATAVERSE_CONNECTION_ID</st></strong></span></li><li><span class="No-Break"><strong class="source-inline"><st c="31228">O365_CONNECTION_ID</st></strong></span></li><li><span class="No-Break"><strong class="source-inline"><st c="31247">OUTLOOK_CONNECTION_ID</st></strong></span></li></ul><p class="list-inset"><st c="31269">We can see how we’ve introduced the variables in the </st><span class="No-Break"><st c="31323">following screenshot:</st></span></p></li>
			</ol>
			<div>
				<div id="_idContainer097" class="IMG---Figure">
					<img src="image/B22208_08_13.jpg" alt="Figure 8.13 – The GitHub environment with connection IDs"/><st c="31344"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="31808">Figure 8.13 – The GitHub environment with connection IDs</st></p>
			<p class="list-inset"><st c="31864">As a next step, we need to create these three </st><strong class="bold"><st c="31911">connections</st></strong><st c="31922"> in our developer environment, share the connections</st><a id="_idIndexMarker1000"/><st c="31974"> with the service principal (</st><strong class="source-inline"><st c="32003">KudosSPN</st></strong><st c="32012">), and copy the connection IDs from the appropriate URLs into the </st><strong class="source-inline"><st c="32079">deploymentSettings.json</st></strong><st c="32102"> file. </st><st c="32109">Our workflow expects to find this information in the assigned GitHub environment with the matching name. </st><st c="32214">Let’s execute the </st><em class="italic"><st c="32232">Import to dev</st></em><st c="32245"> workflow located under </st><strong class="source-inline"><st c="32269">github/workflows/import-to-dev.yml</st></strong><st c="32303"> from the dev</st><a id="_idIndexMarker1001"/><st c="32316"> branch, to import the </st><strong class="bold"><st c="32339">unmanaged solutions</st></strong><st c="32358"> to the </st><span class="No-Break"><st c="32366">developer environment:</st></span></p>
			<div>
				<div id="_idContainer098" class="IMG---Figure">
					<img src="image/B22208_08_14.jpg" alt="Figure 8.14 – The Import to dev workflow"/><st c="32388"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="33124">Figure 8.14 – The Import to dev workflow</st></p>
			<p class="list-inset"><st c="33164">We need to select</st><a id="_idIndexMarker1002"/><st c="33182"> our recently created developer branch to use its name to find the right environment in the Power </st><span class="No-Break"><st c="33280">Platform tenant:</st></span></p>
			<div>
				<div id="_idContainer099" class="IMG---Figure">
					<img src="image/B22208_08_15.jpg" alt="Figure 8.15 – Executing the workflow on the dev branch"/><st c="33296"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="33342">Figure 8.15 – Executing the workflow on the dev branch</st></p>
			<p class="list-inset"><st c="33396">When everything is set up right according to the previous steps, we will see the GitHub workflow running during the execution of the job. </st><st c="33535">The </st><strong class="source-inline"><st c="33539">import-to-dev</st></strong><st c="33552"> job will run in the </st><strong class="source-inline"><st c="33573">dev/DEV-US_XXX_Z</st></strong><st c="33589"> environment, displaying the GitHub environment name in the job’s rectangular box of the workflow run (</st><strong class="source-inline"><st c="33692">Import to dev</st></strong><st c="33706">), as shown in the </st><span class="No-Break"><st c="33726">following figure:</st></span></p>
			<div>
				<div id="_idContainer100" class="IMG---Figure">
					<img src="image/B22208_08_16.jpg" alt="Figure 8.16 – The GitHub workflow import-to-dev job"/><st c="33743"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="33923">Figure 8.16 – The GitHub workflow import-to-dev job</st></p>
			<p class="list-inset"><st c="33974">After the successful run, we have only one task</st><a id="_idIndexMarker1003"/><st c="34022"> left, which is to turn on the </st><strong class="bold"><st c="34053">Power Automate cloud flow</st></strong><st c="34078">, </st><em class="italic"><st c="34080">Kudos App – Notification email</st></em><st c="34110">, by opening the Kudos solution and viewing the flow under the </st><strong class="bold"><st c="34173">Cloud flows</st></strong><st c="34184"> solution asset. </st><st c="34201">We will not see the flows under </st><strong class="bold"><st c="34233">My flows</st></strong><st c="34241"> because these flows are intentionally not shared </st><span class="No-Break"><st c="34291">with us.</st></span></p>
			<p class="list-inset"><st c="34299">When we examine</st><a id="_idIndexMarker1004"/><st c="34315"> the YML file of the workflow in detail, we can see that this pipeline uses a </st><strong class="bold"><st c="34393">reusable workflow</st></strong><st c="34410"> to pack and upload the</st><a id="_idIndexMarker1005"/><st c="34433"> managed and unmanaged versions of the solutions, both </st><a id="_idIndexMarker1006"/><st c="34488">Employee Experience Base and Kudos, to </st><strong class="bold"><st c="34527">GitHub artifacts</st></strong><st c="34543">. Then, upcoming jobs download these artifacts and prepare the </st><strong class="source-inline"><st c="34606">deploymentSettings.json</st></strong><st c="34629"> file with the right connection IDs. </st><st c="34666">Finally, we execute the </st><strong class="source-inline"><st c="34690">microsoft/powerplatform-actions/import-solution@v1</st></strong><st c="34740"> action to import the unmanaged solutions with the right deployment configurations to our Power Platform environment. </st><st c="34858">We also</st><a id="_idIndexMarker1007"/><st c="34865"> import data to the </st><strong class="bold"><st c="34885">custom table</st></strong><st c="34897">, </st><strong class="source-inline"><st c="34899">Badge</st></strong><st c="34904">, with the help of the </st><strong class="source-inline"><st c="34927">microsoft/powerplatform-actions/import-data@v1</st></strong> <span class="No-Break"><st c="34973">GitHub action.</st></span></p>
			<p class="list-inset"><em class="italic"><st c="34988">The branch name is the glue that ties the Power Platform environment, the Git branch, and the GitHub environment together to help developers easily find their </st></em><span class="No-Break"><em class="italic"><st c="35148">own environments/configurations.</st></em></span></p>
			<ol>
				<li value="3"><strong class="bold"><st c="35180">The Commit to dev branch GitHub workflow</st></strong><st c="35221">: Located under </st><strong class="source-inline"><st c="35238">\.github\workflows\commit-to-dev.yml</st></strong><st c="35274">, this workflow has been built to easily commit the changes made in the Power Platform developer environment back to the developer branch. </st><st c="35413">We can make changes by going directly</st><a id="_idIndexMarker1008"/><st c="35450"> to the Kudos solution in the </st><strong class="bold"><st c="35480">maker portal</st></strong><st c="35492"> and opening the canvas app, (the Kudos app) for editing. </st><st c="35550">On the main screen of the applica</st><a id="_idTextAnchor141"/><st c="35583">tion, let’s change the textbox to include the current date, as shown in the </st><span class="No-Break"><st c="35660">following figure:</st></span></li>
			</ol>
			<div>
				<div id="_idContainer101" class="IMG---Figure">
					<img src="image/B22208_08_17.jpg" alt="Figure 8.17 – Editing the Kudos App in the developer environment"/><st c="35677"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="36216">Figure 8.17 – Editing the Kudos App in the developer environment</st></p>
			<p class="list-inset"><st c="36280">We need to save the app</st><a id="_idIndexMarker1009"/><st c="36304"> and publish the customizations before executing the </st><em class="italic"><st c="36357">Commit to dev branch</st></em><st c="36377"> GitHub workflow. </st><st c="36395">If we want to run the app locally in this environment, we also need to share the application within the solution with our account. </st><st c="36526">The </st><em class="italic"><st c="36530">Commit to dev branch</st></em><st c="36550"> expects no input parameter; we only need to set the branch to our developer branch. </st><st c="36635">If we started the workflow directly on the main branch, it would fail because of the branch protection rules that are applied. </st><st c="36762">Under the hood, this workflow exports both solutions as managed and unmanaged (</st><strong class="source-inline"><st c="36841">microsoft/powerplatform-actions/export-solution@v1</st></strong><st c="36892">) and also unpacks them to the right folders in the developer branch (</st><strong class="source-inline"><st c="36963">microsoft/powerplatform-actions/unpack-solution@v1</st></strong><st c="37014">). </st><st c="37018">Finally, the flow commits the changes to the dev branch. </st><st c="37075">As we did earlier, we use the branch name to find the </st><strong class="bold"><st c="37129">Power Platform environment URL</st></strong><st c="37159"> to export the solutions from the right Dataverse instance, with the help of the following Bash </st><span class="No-Break"><st c="37255">script snippet:</st></span></p>
			<pre class="source-code"><st c="37270">
ref=${{ github.ref }}
branch="${ref#refs/heads/dev/}"
echo "$branch"
# Workflow is executed on the dev branch so we need to get the environment URL from the dev branch
</st><strong class="bold"><st c="37439">rawOutput=$(pac admin list --name $branch | tail -n 2)</st></strong>
<strong class="bold"><st c="37493">environmentURL=$(echo $rawOutput | cut -d ' ' -f 3)</st></strong><st c="37545">
echo "Environment URL: $environmentURL"
# setting the env.devEnvironmentURL
echo "devEnvironmentURL=$environmentURL" &gt;&gt; "$GITHUB_ENV"</st></pre>			<p class="list-inset"><st c="37679">In the final line, we create</st><a id="_idIndexMarker1010"/><st c="37708"> an environment variable with the value of the URL to use in the upcoming actions within the GitHub job. </st><st c="37813">We hand over this URL to other jobs in the workflow by using the </st><strong class="source-inline"><st c="37878">outputs</st></strong><st c="37885"> and </st><strong class="source-inline"><st c="37890">needs</st></strong><st c="37895"> keywords in the </st><span class="No-Break"><st c="37912">YML file.</st></span></p>
			<ol>
				<li value="4"><strong class="bold"><st c="37921">Create a pull request back to the main branch</st></strong><st c="37967">: After changing the main text box in the</st><a id="_idIndexMarker1011"/><st c="38009"> solution, we can submit a </st><strong class="bold"><st c="38036">pull request</st></strong><st c="38048"> to merge our changes back to the main branch. </st><st c="38095">We just need to go to the </st><strong class="bold"><st c="38121">Pull requests</st></strong><st c="38134"> tab in our GitHub repository and create one pull request from </st><strong class="source-inline"><st c="38197">dev/DEV-US_XXX_Z</st></strong><st c="38213"> branch to </st><strong class="source-inline"><st c="38224">main</st></strong><st c="38228">. The pull request will compare the two branches and list every change that has been made since the creation of the developer branch. </st><st c="38362">We can use </st><strong class="bold"><st c="38373">GitHub Copilot</st></strong><st c="38387"> to generate a summary</st><a id="_idIndexMarker1012"/><st c="38409"> of these changes by clicking the Copilot icon on the pull </st><span class="No-Break"><st c="38468">request page:</st></span></li>
			</ol>
			<div>
				<div id="_idContainer102" class="IMG---Figure">
					<img src="image/B22208_08_18.jpg" alt="Figure 8.18 – A Copilot-generated pull request summary"/><st c="38481"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="38863">Figure 8.18 – A Copilot-generated pull request summary</st></p>
			<p class="list-inset"><st c="38917">By clicking the </st><strong class="bold"><st c="38934">Merge</st></strong><st c="38939"> button, our pull request</st><a id="_idIndexMarker1013"/><st c="38964"> will close and the changes will merge</st><a id="_idIndexMarker1014"/><st c="39002"> back to the parent branch. </st><st c="39030">Usually, we delete developer branches after a successful pull request, but this time, let’s keep our dev branch to execute some additional exercises in the </st><span class="No-Break"><st c="39186">upcoming sections.</st></span></p>
			<ol>
				<li value="5"><strong class="bold"><st c="39204">The Release to Production GitHub workflow</st></strong><st c="39246">: Located under </st><strong class="source-inline"><st c="39263">\.github\workflows\cd-to-prod.yml</st></strong><st c="39296">, this workflow deploys the latest version of the main branch to the production environment, as we discussed in the previous section. </st><st c="39430">We can execute this workflow to deploy the latest version of the Kudos app to the </st><span class="No-Break"><st c="39512">production environment.</st></span></li>
			</ol>
			<p><st c="39535">In </st><a href="B22208_06.xhtml#_idTextAnchor103"><span class="No-Break"><em class="italic"><st c="39539">Chapter 6</st></em></span></a><st c="39548">, we learned about the </st><strong class="bold"><st c="39571">ALM Accelerator for Power Platform</st></strong><st c="39605">, how it controls the versions of the Power Platform</st><a id="_idIndexMarker1015"/><st c="39657"> solutions, and why it sets them intentionally to </st><strong class="source-inline"><st c="39707">0.0.0.0.</st></strong><st c="39715"> in Azure DevOps Services during the development phase. </st><st c="39771">We can apply the same concept in GitHub by introducing a reusable workflow located under </st><strong class="source-inline"><st c="39860">\.github\workflows\set-version-number.yml</st></strong><st c="39901">. This workflow has two parameters; one is the source folder of our solutions, and the other is the version number to be set. </st><st c="40027">The workflow checks out the repository, searches for the </st><strong class="source-inline"><st c="40084">Solution.xml</st></strong><st c="40096"> file under the source folder, and replaces the inline version tags with the version number, provided as an </st><span class="No-Break"><st c="40204">input parameter:</st></span></p>
			<pre class="source-code"><st c="40220">
- shell: bash
  run: |
   # Find all Solution.xml files in the solution directory and its subdirectories
   </st><strong class="bold"><st c="40321">find</st></strong><st c="40325"> ${{ inputs.source_folder }} -type f -name "Solution.xml" | while read -r file; do
   # Replace the content of the &lt;Version&gt; tag with version number provided in the input
     </st><strong class="bold"><st c="40493">sed</st></strong><st c="40496"> -i 's|&lt;Version&gt;.*&lt;/Version&gt;|&lt;Version&gt;${{ inputs.version_number }}&lt;/Version&gt;|g' "$file"
     done</st></pre>			<p><st c="40588">The final action in the flow commits</st><a id="_idIndexMarker1016"/><st c="40625"> back the changes to the branch on which the </st><span class="No-Break"><st c="40670">workflow runs.</st></span></p>
			<p><st c="40684">We need to add this reusable workflow to the </st><em class="italic"><st c="40730">Commit to dev branch</st></em><st c="40750"> workflow to set the version number of the solutions to </st><strong class="source-inline"><st c="40806">0.0.0.0</st></strong><st c="40813">. Let’s update the workflow in the dev branch (</st><strong class="source-inline"><st c="40860">dev/DEV-US_XXX_Z</st></strong><st c="40877">) with the following lines, directly adding them to the end of </st><span class="No-Break"><st c="40941">the workflow:</st></span></p>
			<pre class="source-code"><st c="40954">
set-version-number:
    needs: [ commit-to-dev-kudos ]
    name: Set the version numbers to 0.0.0.0
    uses: jovadker/ppdemo/.github/workflows/set-version-number.yml@main
    with:
        source_folder: src/
        version_number: "0.0.0.0"</st></pre>			<p><st c="41166">Let’s commit the changes locally and push</st><a id="_idIndexMarker1017"/><st c="41208"> them back to the remote repository. </st><st c="41245">We can work in </st><strong class="bold"><st c="41260">Visual Studio Code</st></strong><st c="41278"> (</st><strong class="bold"><st c="41280">VS Code</st></strong><st c="41287">) or directly in the </st><strong class="bold"><st c="41309">GitHub UI</st></strong><st c="41318">, based on our preferences, or we</st><a id="_idIndexMarker1018"/><st c="41351"> can use GitHub Codespaces and execute the changes there. </st><st c="41409">For the latter option, we need</st><a id="_idIndexMarker1019"/><st c="41439"> to switch to the branch (</st><strong class="source-inline"><st c="41465">dev/DEV-US_XXX_Z</st></strong><st c="41482">) and create </st><span class="No-Break"><st c="41496">another codespace:</st></span></p>
			<div>
				<div id="_idContainer103" class="IMG---Figure">
					<img src="image/B22208_08_19.jpg" alt="Figure 8.19 – A GitHub codespace on the dev branch"/><st c="41514"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="42312">Figure 8.19 – A GitHub codespace on the dev branch</st></p>
			<p><st c="42362">After launching the newly created codespace, we can add the workflow snippet (the GitHub job with the name </st><strong class="source-inline"><st c="42470">set-version-number</st></strong><st c="42488">) to the end of the file, as shown in the </st><span class="No-Break"><st c="42531">following figure:</st></span></p>
			<div>
				<div id="_idContainer104" class="IMG---Figure">
					<img src="image/B22208_08_20.jpg" alt="Figure 8.20 – The commit-to-dev.yml file in the GitHub codespace"/><st c="42548"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="43595">Figure 8.20 – The commit-to-dev.yml file in the GitHub codespace</st></p>
			<p><st c="43659">After saving the file in the VS Code editor</st><a id="_idIndexMarker1020"/><st c="43703"> in the browser, we can navigate to the source control icon on the left menu and commit our changes, by providing a commit message and clicking on the </st><span class="No-Break"><strong class="bold"><st c="43854">Commit</st></strong></span><span class="No-Break"><st c="43860"> button:</st></span></p>
			<div>
				<div id="_idContainer105" class="IMG---Figure">
					<img src="image/B22208_08_21.jpg" alt="Figure 8.21 – A Git commit in a GitHub codespace"/><st c="43868"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="44605">Figure 8.21 – A Git commit in a GitHub codespace</st></p>
			<p><st c="44653">After clicking on the </st><strong class="bold"><st c="44676">Commit</st></strong><st c="44682"> button, we should not forget to click on </st><strong class="bold"><st c="44724">Sync Changes</st></strong><st c="44736"> to push back the changes to the </st><span class="No-Break"><st c="44769">remote origin.</st></span></p>
			<p><st c="44783">To test the GitHub workflow</st><a id="_idIndexMarker1021"/><st c="44811"> upon our changes, we can start it on the branch, </st><strong class="source-inline"><st c="44861">dev/DEV-US_XXX_Z</st></strong><st c="44877">, and see how the two solutions and their </st><strong class="source-inline"><st c="44919">Solution.xml</st></strong><st c="44931"> files are updated. </st><st c="44951">Similarly, we can introduce this job to other flows if we plan to maintain a homogenous versioning in </st><span class="No-Break"><st c="45053">our solutions.</st></span></p>
			<p class="callout-heading"><st c="45067">Version number – 0.0.0.0</st></p>
			<p class="callout"><st c="45092">If we use the </st><strong class="source-inline"><st c="45107">0.0.0.0</st></strong><st c="45114"> version number, then the solutions imported to Power Platform developer environments will also have this version. </st><st c="45229">This approach is ideal for multiple developers working on the same solution or project, since they will not override the versions by committing their changes back to developer branches and later, through pull requests, to the </st><span class="No-Break"><st c="45455">main branch.</st></span></p>
			<p><st c="45467">Finally, we can leverage the releases feature of GitHub to publish</st><a id="_idIndexMarker1022"/><st c="45534"> our new versions. </st><strong class="bold"><st c="45553">GitHub releases</st></strong><st c="45568"> offer an easy way to package our software, along with release notes and links to binary files, for other people to use. </st><st c="45689">We can manage these releases in GitHub workflows; the platform provides a special trigger that we can use to add our solutions to a release, and there</st><a id="_idIndexMarker1023"/><st c="45839"> are actions available in the </st><strong class="bold"><st c="45869">GitHub marketplace</st></strong><st c="45887"> to create releases within workflows. </st><st c="45925">We will create our release by executing a new GitHub workflow that builds</st><a id="_idIndexMarker1024"/><st c="45998"> our solutions, using </st><strong class="bold"><st c="46020">MSBuild</st></strong><st c="46027">, creates a deployment package, and publishes the generated artifacts as part of the new </st><span class="No-Break"><st c="46116">release version.</st></span></p>
			<p><st c="46132">The Kudos application provides </st><strong class="bold"><st c="46164">Visual Studio projects</st></strong><st c="46186"> to build our solutions like traditional Visual Studio</st><a id="_idIndexMarker1025"/><st c="46240"> solutions, using the </st><strong class="source-inline"><st c="46262">MSBuild</st></strong><st c="46269"> and </st><strong class="source-inline"><st c="46274">dotnet</st></strong><st c="46280"> CLIs. </st><st c="46287">We can create these </st><strong class="source-inline"><st c="46307">.cdsproj files</st></strong><st c="46321"> at any time by executing the following PAC CLI command in the </st><span class="No-Break"><strong class="source-inline"><st c="46384">solution</st></strong></span><span class="No-Break"><st c="46392"> folder:</st></span></p>
			<pre class="source-code"><st c="46400">
pac solution init --publisher-name developer --publisher-prefix dev</st></pre>			<p><st c="46468">This command creates a wrapper around our solution, if empty, and then it will create </st><a id="_idIndexMarker1026"/><st c="46555">an empty solution under the </st><strong class="source-inline"><st c="46583">src</st></strong><st c="46586"> folder, into which we can copy our solution files (XML and </st><span class="No-Break"><st c="46646">JSON files).</st></span></p>
			<p><st c="46658">In </st><a href="B22208_04.xhtml#_idTextAnchor074"><span class="No-Break"><em class="italic"><st c="46662">Chapter 4</st></em></span></a><st c="46671">, we learned about</st><a id="_idIndexMarker1027"/><st c="46689"> deployment packages and the </st><strong class="bold"><st c="46718">Package Deployer tool</st></strong><st c="46739">. This tool is used to manage the deployment of multiple dependent solutions to target environments. </st><st c="46840">With the following commands, we can create a deployment package that will create a </st><strong class="source-inline"><st c="46923">.csproj</st></strong><st c="46930"> file under the </st><span class="No-Break"><strong class="source-inline"><st c="46946">DeploymentPackage</st></strong></span><span class="No-Break"><st c="46963"> folder:</st></span></p>
			<pre class="source-code"><st c="46971">
pac package init --outputDirectory DeploymentPackage
cd .\DeploymentPackage
</st><strong class="bold"><st c="47048">pac package add-solution --path &lt;&lt;PATHTORELEASE&gt;&gt;\mpa_EmployeeExperienceBase_managed.zip</st></strong>
<strong class="bold"><st c="47136">pac package add-solution --path &lt;&lt;PATHTORELEASE&gt;&gt;\mpa_EmployeeExperienceBase_managed.zip\mpa_Kudos_managed.zip</st></strong></pre>			<p><st c="47247">The </st><strong class="source-inline"><st c="47252">pac package add-solution</st></strong><st c="47276"> command adds the managed solutions that were previously built by </st><strong class="source-inline"><st c="47342">MSBuild</st></strong><st c="47349"> to this </st><strong class="source-inline"><st c="47358">.csproj</st></strong><st c="47365"> file as references. </st><st c="47386">After setting up the deployment package, we can use the </st><strong class="source-inline"><st c="47442">dotnet publish -c Release</st></strong><st c="47467"> command to build the release version of the </st><span class="No-Break"><st c="47512">deployment package.</st></span></p>
			<p class="callout-heading"><st c="47531">The deployment package</st></p>
			<p class="callout"><st c="47554">We have created a folder structure in the GitHub repository where the two solutions and the </st><strong class="source-inline"><st c="47647">DeploymentPackage</st></strong><st c="47664"> folder are placed under the </st><strong class="source-inline"><st c="47693">src</st></strong><st c="47696"> folder. </st><st c="47705">The </st><strong class="source-inline"><st c="47709">csproj</st></strong><st c="47715"> file in the </st><strong class="source-inline"><st c="47728">DeploymentPackage</st></strong><st c="47745"> folder references the release builds of the two solutions, Employee Experience Base </st><span class="No-Break"><st c="47830">and Kudos.</st></span></p>
			<p><st c="47840">Finally, we can create our GitHub release</st><a id="_idIndexMarker1028"/><st c="47882"> by using the </st><em class="italic"><st c="47896">GitHub Release</st></em><st c="47910"> workflow, located under </st><strong class="source-inline"><st c="47935">/.github/workflows/create-release.yml</st></strong><st c="47972">. The high-level steps and the key takeaways of the workflow are </st><span class="No-Break"><st c="48037">as follows:</st></span></p>
			<ol>
				<li><strong class="bold"><st c="48048">Set the version number</st></strong><st c="48071">: Here, we use a </st><strong class="bold"><st c="48089">composite GitHub action</st></strong><st c="48112"> to set the version number</st><a id="_idIndexMarker1029"/><st c="48138"> instead of a reusable workflow. </st><st c="48171">Composite actions are actions that are built up from multiple other</st><a id="_idIndexMarker1030"/><st c="48238"> actions, without the need to write </st><strong class="bold"><st c="48274">JavaScript</st></strong><st c="48284"> code or create </st><strong class="bold"><st c="48300">Docker images</st></strong><st c="48313"> for our business logic. </st><st c="48338">Our composite action is located under </st><strong class="source-inline"><st c="48376">/.github/actions/set-version-number-action/action.yml</st></strong><st c="48429">, and it sets the version number of Power Platform solutions. </st><st c="48491">As we saw earlier, reusable workflows need to be run as jobs, which means the GitHub runner will clean up the local repository after finishing the reusable workflow job and moving on to the next job. </st><st c="48691">If we don’t want to commit our version numbers, we need to run all actions within the same job. </st><st c="48787">That’s why we have created this </st><span class="No-Break"><st c="48819">composite action.</st></span></li>
				<li><strong class="bold"><st c="48836">Build the solutions and deployment package</st></strong><st c="48879">: We use a </st><strong class="bold"><st c="48891">GitHub-hosted Windows runner</st></strong><st c="48919"> to make the </st><strong class="source-inline"><st c="48932">MSBuild</st></strong><st c="48939"> and </st><strong class="source-inline"><st c="48944">dotnet</st></strong><st c="48950"> CLIs available</st><a id="_idIndexMarker1031"/><st c="48965"> for our build actions. </st><st c="48989">We build the solutions with the </st><span class="No-Break"><st c="49021">following command:</st></span><pre class="source-code">
<strong class="bold"><st c="49039">msbuild .\src\solutions.proj /p:Configuration=Release</st></strong></pre><p class="list-inset"><st c="49093">The </st><strong class="source-inline"><st c="49098">proj</st></strong><st c="49102"> file contains the references to the </st><strong class="source-inline"><st c="49139">cdsproj</st></strong><st c="49146"> files under the </st><strong class="source-inline"><st c="49163">solutions</st></strong><st c="49172"> folders. </st><st c="49182">We generate the deployment package with the </st><strong class="source-inline"><st c="49226">dotnet publish -c Release /p:Version=${{inputs.release_version}}</st></strong><st c="49290"> command by setting the version of the package to the one provided as the workflow parameter. </st><st c="49384">After having the binaries generated, we upload every build artifact to the GitHub </st><span class="No-Break"><st c="49466">artifact store.</st></span></p></li>				<li><strong class="bold"><st c="49481">Download the deployment package and create the GitHub release</st></strong><st c="49543">: in this separate job, we download</st><a id="_idIndexMarker1032"/><st c="49579"> the artifacts and execute the </st><strong class="source-inline"><st c="49610">gh cli</st></strong><st c="49616"> command to create a </st><span class="No-Break"><st c="49637">GitHub release:</st></span><pre class="source-code"><st c="49652">
gh release create ${{inputs.release_version}} --title "${{inputs.release_title}}" --generate-notes ${{ env.solution_release_folder}}/*.*</st></pre><p class="list-inset"><st c="49789">By using the </st><strong class="source-inline"><st c="49803">generate-notes</st></strong><st c="49817"> argument, the GitHub release notes will be automatically generated. </st><st c="49886">We also attach our binaries to the created release by referring to the folder and its content, </st><strong class="source-inline"><st c="49981">${{ </st></strong><span class="No-Break"><strong class="source-inline"><st c="49985">env.solution_release_folder}}/*.*</st></strong></span><span class="No-Break"><st c="50018">.</st></span></p></li>			</ol>
			<p><st c="50019">Let’s now execute this flow with its default parameters and, upon completion, check whether we can see on the main page of our GitHub repository, under </st><strong class="bold"><st c="50172">Releases</st></strong><st c="50180">, a release called </st><strong class="bold"><st c="50199">Initial release</st></strong><st c="50214">. By opening it, we should discover more details about our first release – for example, the </st><span class="No-Break"><st c="50306">attached assets:</st></span></p>
			<div>
				<div id="_idContainer106" class="IMG---Figure">
					<img src="image/B22208_08_22.jpg" alt="Figure 8.22 – The GitHub release with the Power Platform package"/><st c="50322"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="50590">Figure 8.22 – The GitHub release with the Power Platform package</st></p>
			<p class="callout-heading"><st c="50654">The package deployer</st></p>
			<p class="callout"><st c="50675">The </st><strong class="source-inline"><st c="50680">.pdpkg</st></strong><st c="50686"> (</st><strong class="bold"><st c="50688">package deployer package</st></strong><st c="50712">) files are used to package</st><a id="_idIndexMarker1033"/><st c="50740"> multiple, interconnected Power Platform solutions into one deployment package that can be moved between tenants. </st><st c="50854">To install these packages, we simply call the</st><strong class="source-inline"><st c="50899"> pac package deploy --package</st></strong> <strong class="source-inline"><st c="50928">.\bin\Release\mpa_Kudos_DeploymentPackage.1.0.0.pdpkg.zip</st></strong><st c="50985"> on the other tenant. </st><st c="51007">These packages</st><a id="_idIndexMarker1034"/><st c="51021"> can also upload data and prepare the target environment for </st><span class="No-Break"><st c="51082">the solutions.</st></span></p>
			<p><st c="51096">With GitHub releases, we can</st><a id="_idIndexMarker1035"/><st c="51125"> distribute our development project results to IT ops teams responsible for the production tenant, without directly connecting our developer tenant and workflows with the </st><span class="No-Break"><st c="51296">production one.</st></span></p>
			<p><st c="51311">If you encounter issues when attempting to run</st><a id="_idIndexMarker1036"/><st c="51358"> the workflows, consider the following </st><span class="No-Break"><st c="51397">troubleshooting options:</st></span></p>
			<ul>
				<li><strong class="bold"><st c="51421">Check the run logs</st></strong><st c="51440">: The first step is to check the logs of the workflow run. </st><st c="51500">GitHub provides detailed logs for each step of the workflow, which can help us identify where an </st><span class="No-Break"><st c="51597">error occurred.</st></span></li>
				<li><strong class="bold"><st c="51612">Use debugging tools</st></strong><st c="51632">: </st><strong class="bold"><st c="51635">GitHub Actions</st></strong><st c="51649"> supports various debugging</st><a id="_idIndexMarker1037"/><st c="51676"> tools. </st><st c="51684">We can use the </st><strong class="source-inline"><st c="51699">ACTIONS_STEP_DEBUG</st></strong><st c="51717"> secret to enable step debug logs, which provide more detailed output for </st><span class="No-Break"><st c="51791">each step.</st></span></li>
				<li><strong class="bold"><st c="51801">Run the workflow locally</st></strong><st c="51826">: We can use tools such as </st><strong class="bold"><st c="51854">act</st></strong><st c="51857"> (</st><a href="https://github.com/nektos/act"><st c="51859">https://github.com/nektos/act</st></a><st c="51888">) to run our workflows locally on our machine. </st><st c="51936">This can help us debug the workflow in an environment </st><span class="No-Break"><st c="51990">we control.</st></span></li>
				<li><strong class="bold"><st c="52001">Review the workflow file</st></strong><st c="52026">: Ensure that the </st><strong class="source-inline"><st c="52045">.yml</st></strong><st c="52049"> workflow file is correctly formatted and that all required fields are present. </st><st c="52129">Syntax errors or missing fields can cause workflows to fail. </st><st c="52190">We should very carefully change the indent of the lines in YML files because only one additional space can lead to a </st><span class="No-Break"><st c="52307">syntax error.</st></span></li>
				<li><strong class="bold"><st c="52320">Check for external changes</st></strong><st c="52347">: Sometimes, changes in external dependencies or an environment can cause workflows to fail. </st><st c="52441">We need to ensure that all external services and dependencies </st><span class="No-Break"><st c="52503">are operational.</st></span></li>
			</ul>
			<p><st c="52519">Now, let’s move on to the next topic and delve into </st><span class="No-Break"><st c="52572">backlog management.</st></span></p>
			<h1 id="_idParaDest-131"><a id="_idTextAnchor142"/><st c="52591">Exercise – backlog management in GitHub</st></h1>
			<p><st c="52631">In </st><a href="B22208_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic"><st c="52635">Chapter 1</st></em></span></a><st c="52644">, we learned about why it is essential to track our activities, user stories, change requests, and bug fixes on any code base. </st><st c="52771">Let’s recall the </st><span class="No-Break"><st c="52788">key takeaways:</st></span></p>
			<ul>
				<li><st c="52802">We want to plan our developer work in every sprint ahead</st><a id="_idIndexMarker1038"/><st c="52859"> to laser-focus</st><a id="_idIndexMarker1039"/><st c="52874"> on the</st><a id="_idIndexMarker1040"/><st c="52881"> most critical </st><strong class="bold"><st c="52896">features</st></strong><st c="52904">, </st><strong class="bold"><st c="52906">bugs</st></strong><st c="52910">, and </st><strong class="bold"><st c="52916">defects</st></strong><st c="52923">. The entire </st><strong class="bold"><st c="52936">sprint planning process</st></strong><st c="52959"> is based on a healthy </st><strong class="bold"><st c="52982">product backlog</st></strong><st c="52997"> that every developer</st><a id="_idIndexMarker1041"/><st c="53018"> and product owner</st><a id="_idIndexMarker1042"/><st c="53036"> needs </st><span class="No-Break"><st c="53043">to maintain.</st></span></li>
				<li><st c="53055">Healthy backlog management allows only source code changes</st><a id="_idIndexMarker1043"/><st c="53114"> that are planned to avoid </st><strong class="bold"><st c="53141">gold plating</st></strong><st c="53153"> (developers adding extra features that are not part of the activity) and </st><strong class="bold"><st c="53227">scope creeping</st></strong><st c="53241"> (when a project team works on features</st><a id="_idIndexMarker1044"/><st c="53280"> that are requested by the customer without adjusting the project’s cost </st><span class="No-Break"><st c="53353">or timeline).</st></span></li>
				<li><strong class="bold"><st c="53366">Backlog management</st></strong><st c="53385"> provides </st><strong class="bold"><st c="53395">backward traceability</st></strong><st c="53416"> as well as the ability to trace</st><a id="_idIndexMarker1045"/><st c="53448"> back from the application running in production to the source</st><a id="_idIndexMarker1046"/><st c="53510"> code that produced the </st><strong class="bold"><st c="53534">binaries</st></strong><st c="53542"> of the application. </st><st c="53563">We can use this information for root-cause analysis to discover which change, tracked by a work item, led to issues </st><span class="No-Break"><st c="53679">in production.</st></span></li>
			</ul>
			<p><st c="53693">Both Azure DevOps Services</st><a id="_idIndexMarker1047"/><st c="53720"> and GitHub provide these requirement engineering</st><a id="_idIndexMarker1048"/><st c="53769"> and issue management capabilities, with advanced project management features, such as scheduling our activities and assigning them to team members </st><span class="No-Break"><st c="53917">in sprints.</st></span></p>
			<p><st c="53928">To maintain healthy backlog management in GitHub, we can</st><a id="_idIndexMarker1049"/><st c="53985"> improve the minimum </st><strong class="bold"><st c="54006">branch protection rule</st></strong><st c="54028"> we created in the </st><em class="italic"><st c="54047">first exercise of this chapter</st></em><st c="54077"> (</st><strong class="bold"><st c="54079">pull requests are mandatory</st></strong><st c="54106">) to allow only pull requests to be closed that have descriptions and comments. </st><st c="54187">We need to introduce a GitHub workflow that is triggered by the </st><strong class="source-inline"><st c="54251">pull_request</st></strong><st c="54263"> action targeting the branch main and executes the </st><span class="No-Break"><st c="54314">following actions:</st></span></p>
			<div>
				<div id="_idContainer107" class="IMG---Figure">
					<img src="image/B22208_08_23.jpg" alt="Figure 8.23 – A pull request-triggered workflow for branch protection"/><st c="54332"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="54475">Figure 8.23 – A pull request-triggered workflow for branch protection</st></p>
			<p><st c="54544">The key part</st><a id="_idIndexMarker1050"/><st c="54557"> of our workflow</st><a id="_idIndexMarker1051"/><st c="54573"> looks as follows (located </st><span class="No-Break"><st c="54600">under </st></span><span class="No-Break"><strong class="source-inline"><st c="54606">/.github/workflows/pr-check.yml</st></strong></span><span class="No-Break"><st c="54637">):</st></span></p>
			<pre class="source-code">
<strong class="bold"><st c="54640">name: Pull request check</st></strong>
<strong class="bold"><st c="54665">on:</st></strong>
<strong class="bold"><st c="54669">  pull_request:</st></strong>
<strong class="bold"><st c="54683">    types: [edited, synchronize, opened, reopened]</st></strong>
<strong class="bold"><st c="54730">    branches: [ "main" ]</st></strong><st c="54751">
jobs:
  prcheck:
    runs-on: ubuntu-latest
    steps:
      - name: Check for comments in PR
        </st><strong class="bold"><st c="54830">id: check-comments</st></strong><st c="54848">
        run: |
          # every pull request is an issue as well
          #- we can address them through /issues/ endpoint
          comments=$(</st><strong class="bold"><st c="54957">curl</st></strong><st c="54962"> -s -H "Authorization: token ${{secrets.GITHUB_TOKEN}}" \
             "</st><strong class="bold"><st c="55021">https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.pull_request.number }}/comments")</st></strong><st c="55133">
          if [ $(echo "$comments" | jq '. </st><st c="55166">| length') -eq 0 ]; then
            echo "There is no comment added to the PR."
            </st><strong class="bold"><st c="55235">echo "no_comments=true" &gt;&gt; $GITHUB_OUTPUT</st></strong><st c="55276">
          else
            echo "Comments are added to the PR."
            </st><strong class="bold"><st c="55319">echo "no_comments=false" &gt;&gt; $GITHUB_OUTPUT</st></strong><st c="55361">
          fi
        shell: bash
      - name: Fail if no comments
        run: |
          if [[ </st><strong class="bold"><st c="55418">"${{ steps.check-comments.outputs.no_comments }}</st></strong><st c="55466">" == "true" ]]; then
           echo "No comments added to the pull request. </st><st c="55533">Failing the build."
           </st><st c="55553">exit 1
          fi
        shell: bash</st></pre>			<p><st c="55574">We use </st><strong class="source-inline"><st c="55582">curl</st></strong><st c="55586"> to query the comments</st><a id="_idIndexMarker1052"/><st c="55608"> belonging to the issue</st><a id="_idIndexMarker1053"/><st c="55631"> via the REST API endpoint (</st><strong class="source-inline"><st c="55659">https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.pull_request.number }}/comments</st></strong><st c="55769">), since every pull request is also modeled as an </st><strong class="bold"><st c="55820">issue</st></strong><st c="55825">. After validating that the comments array is not empty, we set the output property, </st><strong class="source-inline"><st c="55910">no_comments</st></strong><st c="55921">, accordingly. </st><st c="55936">The next action consumes the output of the previous action and passes or fails the build. </st><st c="56026">If the workflow fails, the pull request is blocked, and the merge is not allowed. </st><st c="56108">The workflow also checks at the beginning whether there is a description added to the pull request with the same approach. </st><st c="56231">We can correct our pull request by writing descriptions and adding comments in hindsight. </st><st c="56321">Also, we can use GitHub Copilot to generate our pull request description, based on the changes between the child and </st><span class="No-Break"><st c="56438">parent branches:</st></span></p>
			<div>
				<div id="_idContainer108" class="IMG---Figure">
					<img src="image/B22208_08_24.jpg" alt="Figure 8.24 – Using GitHub Copilot to generate PR descriptions"/><st c="56454"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="57005">Figure 8.24 – Using GitHub Copilot to generate PR descriptions</st></p>
			<p><st c="57067">We just need to click</st><a id="_idIndexMarker1054"/><st c="57089"> on the Copilot</st><a id="_idIndexMarker1055"/><st c="57104"> icon, and then the underlying </st><strong class="bold"><st c="57135">GPT-4 model</st></strong><st c="57146"> generates the summary</st><a id="_idIndexMarker1056"/><st c="57168"> for the pull request – in our case, </st><strong class="bold"><st c="57205">The pull request includes a minor change to the </st></strong><span class="No-Break"><strong class="bold"><st c="57253">Readme.md file…</st></strong></span><span class="No-Break"><st c="57268">.</st></span></p>
			<p><st c="57269">If we want to introduce more complex checks during the pull request in conjunction with backlog</st><a id="_idIndexMarker1057"/><st c="57365"> management, we can visit the </st><strong class="bold"><st c="57395">GitHub Marketplace</st></strong><st c="57413"> to find actions, such as </st><strong class="source-inline"><st c="57439">verify-linked-issue</st></strong><st c="57458"> (</st><a href="https://github.com/marketplace/actions/verify-linked-issue"><st c="57460">https://github.com/marketplace/actions/verify-linked-issue</st></a><st c="57518">), which checks whether pull requests have at least one linked </st><span class="No-Break"><st c="57582">issue attached.</st></span></p>
			<p><st c="57597">Now that we have established strict control of our repository and work management, let’s move on to the next topic, </st><span class="No-Break"><strong class="bold"><st c="57714">quality assurance</st></strong></span><span class="No-Break"><st c="57731">.</st></span></p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor143"/><st c="57732">Exercise – testing solutions</st></h1>
			<p><st c="57761">In </st><a href="B22208_06.xhtml#_idTextAnchor103"><span class="No-Break"><em class="italic"><st c="57765">Chapter 6</st></em></span></a><st c="57774">, we delved into the </st><strong class="bold"><st c="57795">quality assurance</st></strong><st c="57812"> (</st><strong class="bold"><st c="57814">QA</st></strong><st c="57816">) topics and learned</st><a id="_idIndexMarker1058"/><st c="57837"> about the tools and frameworks</st><a id="_idIndexMarker1059"/><st c="57868"> that are available for end-to-end UI testing</st><a id="_idIndexMarker1060"/><st c="57913"> in PowerApps, such as </st><strong class="bold"><st c="57936">Power Apps Test Engine</st></strong><st c="57958">, or open </st><a id="_idIndexMarker1061"/><st c="57968">source</st><a id="_idIndexMarker1062"/><st c="57974"> web</st><a id="_idIndexMarker1063"/><st c="57978"> testing </st><a id="_idIndexMarker1064"/><st c="57987">frameworks, such as </st><strong class="bold"><st c="58007">Selenium</st></strong><st c="58015">, </st><strong class="bold"><st c="58017">Playwright</st></strong><st c="58027">, </st><strong class="bold"><st c="58029">Appium</st></strong><st c="58035"> or </st><strong class="bold"><st c="58039">Cypress</st></strong><st c="58046">. We also concluded that Power Automate cloud flows and </st><strong class="bold"><st c="58102">desktop flows</st></strong><st c="58115"> are considered</st><a id="_idIndexMarker1065"/><st c="58130"> our business logic layer, and we can test them through the UI components, as end-to-end tests. </st><st c="58226">In this section, we are going to do </st><span class="No-Break"><st c="58262">the following:</st></span></p>
			<ul>
				<li><st c="58276">Create a test in Power Apps Test Studio for the Kudos app in our Power Platform developer </st><span class="No-Break"><st c="58367">environment (</st></span><span class="No-Break"><strong class="source-inline"><st c="58380">DEV-US_XXX_Z</st></strong></span><span class="No-Break"><st c="58393">).</st></span></li>
				<li><st c="58396">Download it as a test suite </st><strong class="bold"><st c="58425">YAML file</st></strong><st c="58434"> and commit it to our developer</st><a id="_idIndexMarker1066"/><st c="58465"> branch (remember that this branch is </st><span class="No-Break"><st c="58503">still alive).</st></span></li>
				<li><st c="58516">Run it locally with the help of the </st><span class="No-Break"><st c="58553">PAC CLI.</st></span></li>
				<li><st c="58561">Introduce this step to our </st><em class="italic"><st c="58589">Commit to dev branch</st></em> <span class="No-Break"><st c="58609">GitHub workflow.</st></span></li>
			</ul>
			<p><st c="58626">We also have some prerequisites</st><a id="_idIndexMarker1067"/><st c="58658"> for this test </st><span class="No-Break"><st c="58673">automation scenario:</st></span></p>
			<ul>
				<li><st c="58693">To be able to execute our test during the CI/CD process, we also</st><a id="_idIndexMarker1068"/><st c="58758"> need to have a user without </st><strong class="bold"><st c="58787">Multifactor Authentication</st></strong><st c="58813"> (</st><strong class="bold"><st c="58815">MFA</st></strong><st c="58818">) in our development tenant; learn more about it in the link in the </st><em class="italic"><st c="58887">Further reading</st></em><st c="58902"> section (Power Apps </st><span class="No-Break"><st c="58923">Test Engine).</st></span></li>
				<li><st c="58936">We also need to share the Kudos app</st><a id="_idIndexMarker1069"/><st c="58972"> under the </st><strong class="bold"><st c="58983">Solutions</st></strong><st c="58992"> blade with this </st><strong class="bold"><st c="59009">Microsoft Entra </st></strong><span class="No-Break"><strong class="bold"><st c="59025">ID user</st></strong></span><span class="No-Break"><st c="59032">.</st></span></li>
				<li><st c="59033">We must add this user</st><a id="_idIndexMarker1070"/><st c="59055"> to the developer environment (</st><strong class="source-inline"><st c="59086">DEV-US_XXX_Z</st></strong><st c="59099">) in the </st><strong class="bold"><st c="59109">Power Platform Admin Center</st></strong><st c="59136">, and we need</st><a id="_idIndexMarker1071"/><st c="59149"> to </st><a id="_idIndexMarker1072"/><st c="59153">assign the built-in </st><strong class="bold"><st c="59173">Security Role</st></strong><st c="59186">, </st><strong class="bold"><st c="59188">Basic User</st></strong><st c="59198">, and the custom one, </st><strong class="bold"><st c="59220">Kudos Employee</st></strong><st c="59234">, to this </st><a id="_idIndexMarker1073"/><st c="59244">user. </st><st c="59250">This latter one gives access to the custom tables created by the Kudos solution and contains the badges, as well as the already </st><span class="No-Break"><st c="59378">shared Kudos.</st></span></li>
				<li><st c="59391">We need to start the app interactively once on behalf of our test user without MFA, granting them access to the connections used in the Kudos app, Office 365 Users, and Office </st><span class="No-Break"><st c="59568">365 Outlook.</st></span></li>
				<li><st c="59580">Finally, we need to share the </st><em class="italic"><st c="59611">Kudo App – Share Kudo with Sender</st></em><st c="59644">, </st><em class="italic"><st c="59646">Assign to Recipient</st></em><st c="59665">, and </st><em class="italic"><st c="59671">Kudos App - Notification email</st></em><st c="59701"> cloud flows with this user as </st><em class="italic"><st c="59732">Run only users</st></em><st c="59746"> in the Power</st><a id="_idIndexMarker1074"/><st c="59759"> Automate cloud </st><span class="No-Break"><st c="59775">flow UI.</st></span></li>
			</ul>
			<p><st c="59783">We can easily record</st><a id="_idIndexMarker1075"/><st c="59804"> our tests by using the </st><strong class="bold"><st c="59828">Power Apps Test Studio</st></strong><st c="59850">. We just need to go to our solution in the developer environment, open the Kudos app</st><a id="_idIndexMarker1076"/><st c="59935"> for editing, click on </st><strong class="bold"><st c="59958">Advanced tools</st></strong><st c="59972"> on the left side, and open the </st><strong class="bold"><st c="60004">Open tests</st></strong><st c="60014"> link. </st><st c="60021">Here, we can use the </st><strong class="bold"><st c="60042">Record</st></strong><st c="60048"> button to let the studio record our steps, like creating a new kudos for one of the users in our environment. </st><st c="60159">If we have completed the recording, we can download the result as a YAML file by clicking on the </st><strong class="bold"><st c="60256">Download suite</st></strong><st c="60270"> button. </st><st c="60279">You can find more information about the features of Test Studio in the </st><em class="italic"><st c="60350">Further reading</st></em><st c="60365"> section under the </st><em class="italic"><st c="60384">Working with Power Apps Test Studio</st></em><st c="60419"> link. </st><st c="60426">We can use this YAML file or the one that was already added to the repository under the </st><strong class="source-inline"><st c="60514">/test/SmokeTestSuite.yaml</st></strong><st c="60539"> file to continue </st><span class="No-Break"><st c="60557">this exercise.</st></span></p>
			<p><st c="60571">Once we have our YAML file, we need to make some</st><a id="_idIndexMarker1077"/><st c="60620"> changes to be able to run in </st><strong class="bold"><st c="60650">headless browser mode</st></strong><st c="60671">, which means the test can be executed without starting a browser in the UI session. </st><st c="60756">This setting is essential to get these </st><strong class="bold"><st c="60795">Playwright-based</st></strong><st c="60811"> tests executed on GitHub-hosted</st><a id="_idIndexMarker1078"/><st c="60843"> runners. </st><st c="60853">We need to set the screen resolution to other numbers than the default </st><strong class="source-inline"><st c="60924">0x0</st></strong><st c="60927">, such as </st><strong class="source-inline"><st c="60937">102x768</st></strong><st c="60944"> pixels (</st><strong class="source-inline"><st c="60953">screenWidth </st></strong><span class="No-Break"><strong class="source-inline"><st c="60966">X screenHeight</st></strong></span><span class="No-Break"><st c="60980">):</st></span></p>
			<pre class="source-code"><st c="60983">
testSettings:
  filePath:
  browserConfigurations:
  - browser: Chromium
    device:
    </st><strong class="bold"><st c="61059">screenWidth: 1024</st></strong><strong class="bold"><st c="61076">screenHeight: 768</st></strong><st c="61094">
  locale: en-US
  </st><strong class="bold"><st c="61109">recordVideo: true</st></strong><strong class="bold"><st c="61126">headless: true</st></strong><st c="61141">
  enablePowerFxOverlay: false
  timeout: 30000</st></pre>			<p><st c="61184">Besides these updates, we can set </st><strong class="source-inline"><st c="61219">headless</st></strong><st c="61227"> parameter to </st><strong class="source-inline"><st c="61241">false</st></strong><st c="61246"> for local testing purposes to follow the UI actions in a Chromium-based browser. </st><st c="61328">To execute this test YAML file locally, we can use the following script </st><span class="No-Break"><st c="61400">in Bash:</st></span></p>
			<pre class="source-code"><st c="61408">
export user1Email="USEREMAIL"
export user1Password="PASSWORD"
pac test run --test-plan-file ./test/SmokeTestSuite.yaml -env 4d3c1075-FFFF-GGGG-VVVV-40c6f5edd705 --tenant 4ae51f31-XXXX-YYYY-ZZZZ-5ece14d2c081</st></pre>			<p><st c="61615">We need to set the test user</st><a id="_idIndexMarker1079"/><st c="61644"> email address and password as environment variables, and we also need to provide the test file location, the environment ID, and tenant ID. </st><st c="61785">After successful execution, we will find the test results in the </st><strong class="source-inline"><st c="61850">TestOutput</st></strong><st c="61860"> folder with the video recording, as well in the </st><strong class="source-inline"><st c="61909">.</st></strong><span class="No-Break"><strong class="source-inline"><st c="61910">webm</st></strong></span><span class="No-Break"><st c="61915"> format.</st></span></p>
			<p><st c="61923">To execute this test in GitHub, we need</st><a id="_idIndexMarker1080"/><st c="61963"> to create two additional </st><strong class="bold"><st c="61989">repository secrets</st></strong><st c="62007">, one for the test user’s email address and the other for the test user’s password – </st><strong class="source-inline"><st c="62092">TESTUSER</st></strong><st c="62100"> and </st><strong class="source-inline"><st c="62105">TESTUSERPSW</st></strong><st c="62116">, and – similar to the other three ones (</st><strong class="source-inline"><st c="62157">PPAPPID</st></strong><st c="62165">, </st><strong class="source-inline"><st c="62167">PPAPPSECRET</st></strong><st c="62178">, and </st><strong class="source-inline"><st c="62184">PPTENANTID</st></strong><st c="62194">) that we created at the beginning of </st><span class="No-Break"><st c="62233">this chapter.</st></span></p>
			<p><st c="62246">We have crafted a GitHub workflow in advance to execute our </st><strong class="source-inline"><st c="62307">SmokeTestSuite.yaml</st></strong><st c="62326"> file easily on the dev branch. </st><st c="62358">This workflow is available under </st><strong class="source-inline"><st c="62391">/.github/workflows/run-test.yml</st></strong><st c="62422"> and uses the following Bash script to run </st><span class="No-Break"><st c="62465">the test:</st></span></p>
			<pre class="source-code"><st c="62474">
 - name: Run test
     </st><strong class="bold"><st c="62492">shell: bash</st></strong><strong class="bold"><st c="62503">run: |</st></strong><st c="62510">
       set -e
       </st><strong class="bold"><st c="62518">ref=${{ github.ref }}</st></strong><st c="62539">
       branch="${ref#refs/heads/dev/}"
       echo "$branch"
       # Get the environment Id
       </st><strong class="bold"><st c="62612">rawOutput=$(pac admin list --name $branch | tail -n 2)</st></strong><st c="62666">
       environmentId=$(echo $rawOutput | cut -d ' ' -f 2)
       </st><strong class="bold"><st c="62718">export user1Email="${{secrets.TESTUSER}}</st></strong><st c="62758">"
       </st><strong class="bold"><st c="62761">export user1Password="${{secrets.TESTUSERPSW}}</st></strong><st c="62807">"
       </st><strong class="bold"><st c="62810">pac test run \</st></strong><strong class="bold"><st c="62824">--test-plan-file ./test/SmokeTestSuite.yaml \</st></strong><strong class="bold"><st c="62870">-env $environmentId \</st></strong><strong class="bold"><st c="62892">--tenant ${{secrets.PPTENANTID}}</st></strong></pre>			<p><st c="62925">We can run this workflow, </st><em class="italic"><st c="62952">Run test (test)</st></em><st c="62967">, directly on our developer branch (</st><strong class="source-inline"><st c="63003">DEV-US_XXX_Z</st></strong><st c="63016">). </st><st c="63020">Based on the branch name, the workflow finds our developer environment and then calls </st><strong class="source-inline"><st c="63106">pac test run</st></strong><st c="63118"> with the </st><span class="No-Break"><st c="63128">appropriate parameters.</st></span></p>
			<p><st c="63151">To avoid feature regression and maintain</st><a id="_idIndexMarker1081"/><st c="63192"> the high quality of our solution, we can introduce this step in our </st><em class="italic"><st c="63261">Commit to dev branch</st></em><st c="63281"> GitHub workflow to fail fast and early in the development process. </st><st c="63349">All we need to do is to append the entire job, called </st><strong class="source-inline"><st c="63403">test</st></strong><st c="63407">, from the </st><strong class="source-inline"><st c="63418">/.github/workflows/run-test.yml</st></strong><st c="63449"> as the first job in the workflow, as we want to only allow new commits landing in the branch when our automated </st><span class="No-Break"><st c="63562">tests pass:</st></span></p>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<img src="image/B22208_08_25.jpg" alt="Figure 8.25 – The Commit to dev branch with a placeholder for “test” job"/><st c="63573"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="64234">Figure 8.25 – The Commit to dev branch with a placeholder for “test” job</st></p>
			<p><st c="64306">Additionally, we can introduce this quality check in our pull request triggered workflow (</st><em class="italic"><st c="64397">Pull request check</st></em><st c="64416">), in the production workflow (</st><em class="italic"><st c="64448">Release to Production</st></em><st c="64470">), or even in the release workflow (</st><em class="italic"><st c="64507">GitHub Release</st></em><st c="64522">) based on our preferences. </st><st c="64551">Some of these workflows need to be extended, for instance, to be able to spin up new Power Platform environments, deploy the release candidate, and execute the tests. </st><st c="64718">Only our imagination and project costs can limit our </st><span class="No-Break"><st c="64771">QA investments.</st></span></p>
			<p><st c="64786">Now, our application is ready</st><a id="_idIndexMarker1082"/><st c="64816"> to run in production. </st><st c="64839">There is only one task left, which is to get real-time insights and telemetry data about our application’s runtime characteristics and behavior. </st><st c="64984">Let’s discover what monitoring options we have in </st><span class="No-Break"><st c="65034">Power Platform.</st></span></p>
			<h1 id="_idParaDest-133"><a id="_idTextAnchor144"/><st c="65049">Exercise – monitoring the applications</st></h1>
			<p><st c="65088">After publishing our application</st><a id="_idIndexMarker1083"/><st c="65121"> to the production environment, we want to understand how it performs, how users interact with the application, and how far the application is stable and can run without errors. </st><st c="65299">As</st><a id="_idIndexMarker1084"/><st c="65301"> Microsoft Power Platform runs on </st><strong class="bold"><st c="65335">Microsoft Azure</st></strong><st c="65350">, it can leverage the existing Azure </st><strong class="bold"><st c="65387">platform-as-a-service</st></strong><st c="65408"> (</st><strong class="bold"><st c="65410">PaaS</st></strong><st c="65414">) services to provide real-time</st><a id="_idIndexMarker1085"/><st c="65446"> telemetry data collection and analysis for the Power Platform portfolio – Power Apps, Power Automate, Copilot Studio, Power Pages, and even Dataverse. </st><st c="65598">Azure’s</st><a id="_idIndexMarker1086"/><st c="65605"> PaaS service is </st><strong class="bold"><st c="65622">Azure Application Insights</st></strong><st c="65648">, which is </st><a id="_idIndexMarker1087"/><st c="65659">tidily</st><a id="_idIndexMarker1088"/><st c="65665"> connected to </st><strong class="bold"><st c="65679">Azure Monitor</st></strong><st c="65692"> and </st><strong class="bold"><st c="65697">Azure Log Analytics workspaces</st></strong><st c="65727">. Azure Application Insights is an </st><strong class="bold"><st c="65762">Application Performance Management</st></strong><st c="65796"> (</st><strong class="bold"><st c="65798">APM</st></strong><st c="65801">) solution that can be used</st><a id="_idIndexMarker1089"/><st c="65829"> in live production monitoring scenarios. </st><st c="65871">Application Insights provides application dashboards, application maps, live metrics, transaction search, availability view, failures view, performance view, monitoring alerts, workbooks, and so on. </st><st c="66070">With Application Insights, we can also discover the usage patterns of our users, how people interact with the app, and how the churn rate or the conversion rate looks. </st><st c="66238">It also visualizes the user journey on web applications. </st><st c="66295">The Application Insights service offers machine learning-based</st><a id="_idIndexMarker1090"/><st c="66357"> analysis of telemetry data (called </st><strong class="bold"><st c="66393">Smart Detection</st></strong><st c="66408">) to identify anomalies or performance degradation before outages or blackouts occur. </st><st c="66495">If the built-in detection features are not enough, we can write our own queries to look</st><a id="_idIndexMarker1091"/><st c="66582"> for anomalies with the help of </st><strong class="bold"><st c="66614">Kusto Query Language</st></strong><st c="66634"> (</st><strong class="bold"><st c="66636">KQL</st></strong><st c="66639">). </st><st c="66643">We can introduce our custom alerting and notifications</st><a id="_idIndexMarker1092"/><st c="66697"> based on</st><a id="_idIndexMarker1093"/><st c="66706"> the</st><a id="_idIndexMarker1094"/><st c="66710"> query </st><a id="_idIndexMarker1095"/><st c="66717">results</st><a id="_idIndexMarker1096"/><st c="66724"> of KQL scripts that can trigger </st><strong class="bold"><st c="66757">Azure Playbooks</st></strong><st c="66772">, </st><strong class="bold"><st c="66774">Azure Logic Apps</st></strong><st c="66790">, </st><strong class="bold"><st c="66792">Azure Functions</st></strong><st c="66807">, </st><strong class="bold"><st c="66809">Azure EventHub</st></strong><st c="66823">, and </st><strong class="bold"><st c="66829">custom Webhooks</st></strong><st c="66844">. The custom webhooks can trigger Power Automate cloud flows to react to the anomalies and outriders in the Power Platform. </st><st c="66968">Last but not least, Application Insights provides SDKs, available</st><a id="_idIndexMarker1097"/><st c="67033"> in JavaScript, Java, C#, Node.js, and Python, based on the </st><span class="No-Break"><strong class="bold"><st c="67093">OpenTelemetry framework</st></strong></span><span class="No-Break"><st c="67116">.</st></span></p>
			<p><st c="67117">Since Power Apps are browser-based applications and the web</st><a id="_idIndexMarker1098"/><st c="67177"> player that hosts the apps in the browser is based on </st><strong class="bold"><st c="67232">Apache Cordova framework</st></strong><st c="67256">, which is also used with </st><strong class="source-inline"><st c="67282">react-native</st></strong><st c="67294"> in the native mobile apps through </st><strong class="bold"><st c="67329">wrap functionality</st></strong><st c="67347">, it is a very straightforward</st><a id="_idIndexMarker1099"/><st c="67377"> approach to embrace Application Insights’ capabilities in our low-code/no-code platform. </st><st c="67467">We can add Application Insights’ endpoint directly to the canvas app – in our case, to the Kudos app. </st><st c="67569">We just need to edit the app in the developer environment through the Kudos solution and select the </st><strong class="bold"><st c="67669">App</st></strong><st c="67672"> node in the tree view on the </st><span class="No-Break"><st c="67702">left side:</st></span></p>
			<div>
				<div id="_idContainer110" class="IMG---Figure">
					<img src="image/B22208_08_26.jpg" alt="Figure 8.26 – Application Insights in Power Apps Studio"/><st c="67712"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="68566">Figure 8.26 – Application Insights in Power Apps Studio</st></p>
			<p><st c="68621">On the right side, among the properties</st><a id="_idIndexMarker1100"/><st c="68661"> of </st><strong class="bold"><st c="68665">App</st></strong><st c="68668">, we will find the </st><strong class="bold"><st c="68687">Instrumentation key</st></strong><st c="68706"> field, and here, we should provide the instrumentation key of our Application Insights instance. </st><st c="68804">Let’s create an Application Insights instance in our </st><span class="No-Break"><st c="68857">Azure subscription:</st></span></p>
			<pre class="source-code"><st c="68876">
# Login interactively
az login
# Select the right subscription
az account set --subscription baa70448-593c-4dc7-8a91-c92cf7eaf66e
az group create --location westeurope --resource-group KudosApp.AI.RG
</st><strong class="bold"><st c="69077">workspace=$(az monitor log-analytics workspace create \</st></strong>
<strong class="bold"><st c="69132">    --resource-group KudosApp.AI.RG \</st></strong>
<strong class="bold"><st c="69166">    --workspace-name KudosWorkspace \</st></strong>
<strong class="bold"><st c="69200">    --location westeurope --query id --output tsv)</st></strong>
<strong class="bold"><st c="69247">az monitor app-insights component create \</st></strong>
<strong class="bold"><st c="69290">    --app KudosAppInsights \</st></strong>
<strong class="bold"><st c="69315">    --location westeurope \</st></strong>
<strong class="bold"><st c="69339">    --workspace $workspace \</st></strong>
<strong class="bold"><st c="69364">    --resource-group KudosApp.AI.RG</st></strong></pre>			<p><st c="69396">The final command will return</st><a id="_idIndexMarker1101"/><st c="69426"> a JSON object with the </st><strong class="source-inline"><st c="69450">instrumentationKey</st></strong><st c="69468"> key as well. </st><st c="69482">We can now add the key to the Kudos app and try it out to see how data is ingested into the </st><strong class="bold"><st c="69574">Application </st></strong><span class="No-Break"><strong class="bold"><st c="69586">Insights</st></strong></span><span class="No-Break"><st c="69594"> dashboard.</st></span></p>
			<p class="callout-heading"><st c="69605">Canvas app insights</st></p>
			<p class="callout"><st c="69625">To view telemetry</st><a id="_idIndexMarker1102"/><st c="69643"> information, we need to enable canvas app insights in the Power Platform admin center. </st><st c="69731">Go to </st><strong class="bold"><st c="69737">Settings</st></strong><st c="69745">, which lists all the tenant settings, and select the </st><strong class="bold"><st c="69799">Canvas app insights</st></strong><st c="69818"> item. </st><st c="69825">In the </st><strong class="bold"><st c="69832">Canvas app insights</st></strong><st c="69851"> pane on the right side, we can turn this </st><span class="No-Break"><st c="69893">feature on.</st></span></p>
			<p><st c="69904">Of course, we don’t want to store directly the instrumentation key in the canvas app. </st><st c="69991">The simplest way to make the instrumentation key independent from the app would be to introduce a new environment variable, but at the time of writing, it is not supported for the instrumentation key property. </st><st c="70201">What we can do is update our deployment pipeline and replace the instrumentation</st><a id="_idIndexMarker1103"/><st c="70281"> key with the correct value, stored as a </st><strong class="bold"><st c="70322">GitHub environment variable</st></strong><st c="70349">. In the previous sections, we saw examples of how we can use the GitHub environments and the defined variables to create environment-related customizations. </st><st c="70507">If we introduce the instrumentation key, then we will find an additional </st><strong class="source-inline"><st c="70580">json file</st></strong><st c="70589"> in our solution folder – </st><strong class="source-inline"><st c="70615">/src/mpa_Kudos/src/CanvasApps/src/mpa_KudosApp/AppInsightsKey.json</st></strong><st c="70681">. This contains the instrumentation key that we can replace with the correct one inside our </st><span class="No-Break"><st c="70773">GitHub workflow.</st></span></p>
			<p><st c="70789">Although we don’t have a custom chatbot in this solution, </st><strong class="bold"><st c="70848">Microsoft Copilot Studio</st></strong><st c="70872"> also supports this kind of integration</st><a id="_idIndexMarker1104"/><st c="70911"> with Azure Application Insights. </st><st c="70945">We can configure the connection string of our Azure Application Insights instance under </st><strong class="bold"><st c="71033">Settings</st></strong><st c="71041"> in the </st><strong class="bold"><st c="71049">Copilot details</st></strong><st c="71064"> menu, under the </st><strong class="bold"><st c="71081">Advanced</st></strong><st c="71089"> tab, as shown in the </st><span class="No-Break"><st c="71111">following figure:</st></span></p>
			<div>
				<div id="_idContainer111" class="IMG---Figure">
					<img src="image/B22208_08_27.jpg" alt="Figure 8.27 – Application Insights in Microsoft Copilot Studio"/><st c="71128"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="72035">Figure 8.27 – Application Insights in Microsoft Copilot Studio</st></p>
			<p><st c="72097">Here, we should provide</st><a id="_idIndexMarker1105"/><st c="72121"> the entire connection string in the </st><span class="No-Break"><st c="72158">following format:</st></span></p>
			<pre class="source-code"><st c="72175">
InstrumentationKey=XXXXXXXX-YYYY-YYYY-YYYY-XXXXXXXXXXXX;IngestionEndpoint=https://westeurope-5.in.applicationinsights.azure.com/;LiveEndpoint=https://westeurope.livediagnostics.monitor.azure.com/;ApplicationId=TTTTTTTT-ZZZZ-ZZZZ-ZZZZ-SSSSSSSSSSSS</st></pre>			<p><st c="72422">We can find this string in the </st><strong class="bold"><st c="72454">Overview</st></strong><st c="72462"> blade of our Azure Application </st><span class="No-Break"><st c="72494">Insights instance.</st></span></p>
			<p><st c="72512">In the case of </st><strong class="bold"><st c="72528">Power Pages websites</st></strong><st c="72548">, we need to infuse the code snippet</st><a id="_idIndexMarker1106"/><st c="72584"> that tracks the user actions on the website and ingests the telemetry data into the Azure Application Insights endpoint. </st><st c="72706">We just need to get the client-side JavaScript snippet available in the documentation</st><a id="_idIndexMarker1107"/><st c="72791"> and add it as a content snippet in our </st><strong class="bold"><st c="72831">Power Pages </st></strong><span class="No-Break"><strong class="bold"><st c="72843">management</st></strong></span><span class="No-Break"><st c="72853"> app:</st></span></p>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<img src="image/B22208_08_28.jpg" alt="Figure 8.28 – Application Insights in Power Pages"/><st c="72858"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="73599">Figure 8.28 – Application Insights in Power Pages</st></p>
			<p><st c="73648">The snippet itself</st><a id="_idIndexMarker1108"/><st c="73667"> is available here at </st><a href="https://learn.microsoft.com/en-us/azure/azure-monitor/app/javascript-sdk?tabs=javascriptwebsdkloaderscript"><st c="73689">https://learn.microsoft.com/en-us/azure/azure-monitor/app/javascript-sdk?tabs=javascriptwebsdkloaderscript</st></a><st c="73795">, and only the connection string should be updated with </st><span class="No-Break"><st c="73851">our one.</st></span></p>
			<p><st c="73859">Besides canvas apps, custom</st><a id="_idIndexMarker1109"/><st c="73887"> chatbots, and Power Pages websites, Azure Application Insights as the common APM framework</st><a id="_idIndexMarker1110"/><st c="73978"> for Power Platform</st><a id="_idIndexMarker1111"/><st c="73997"> can be used to monitor </st><strong class="bold"><st c="74021">model-driven applications</st></strong><st c="74046">, Power Automate cloud flows, and </st><strong class="bold"><st c="74080">Dataverse diagnostics and performance events</st></strong><st c="74124">. This can be done using the </st><strong class="bold"><st c="74153">Export data to Application Insights</st></strong><st c="74188"> feature, which is available in the</st><a id="_idIndexMarker1112"/><st c="74223"> Power Platform admin center if we own paid/premium Dataverse licenses. </st><st c="74295">For us, it means we can create export packages that push the telemetry data from the selected environment to our Application Insights service, without infusing the endpoint or the connection string to our Power Platform assets. </st><st c="74523">We don’t need to prepare or create anything in our solutions; the environment and this export job will take care of the telemetry ingestion. </st><st c="74664">It is recommended to use one Application Insights instance per environment, and note that this feature is turned on and supported in managed </st><span class="No-Break"><st c="74805">environments only.</st></span></p>
			<p class="callout-heading"><st c="74823">Delayed ingestion of telemetry data</st></p>
			<p class="callout"><st c="74859">The timeframe set out in the </st><strong class="bold"><st c="74889">service level agreement</st></strong><st c="74912"> (</st><strong class="bold"><st c="74914">SLA</st></strong><st c="74917">) for the delivery of telemetry data streams</st><a id="_idIndexMarker1113"/><st c="74962"> from Power Platform products supported by this feature to Application Insights is </st><span class="No-Break"><st c="75045">24 hours.</st></span></p>
			<p><st c="75054">If we want to collect</st><a id="_idIndexMarker1114"/><st c="75076"> real-time telemetry from these Power Platform assets, we can create our own extensions, such as </st><span class="No-Break"><st c="75173">the following:</st></span></p>
			<ul>
				<li><st c="75187">In model-driven apps, we can create a </st><strong class="bold"><st c="75226">Power Platform Component Framework</st></strong><st c="75260"> (</st><strong class="bold"><st c="75262">PCF</st></strong><st c="75265">) control that is displayed</st><a id="_idIndexMarker1115"/><st c="75293"> in the UI and connects to the Application Insights endpoint</st><a id="_idIndexMarker1116"/><st c="75353"> with </st><span class="No-Break"><st c="75359">client-side JavaScript.</st></span></li>
				<li><st c="75382">With Power Automate cloud flows, we can use the information that is logged in Dataverse about the start time, durations, end time, status (e.g., failing, canceling, or succeeding), and executed actions</st><a id="_idIndexMarker1117"/><st c="75584"> of cloud flows and send it, with the help of the </st><strong class="bold"><st c="75634">Dataverse plugin</st></strong><st c="75650">, to the Application Insights endpoint. </st><st c="75690">The other option to monitor these flows is to use the new built-in </st><strong class="bold"><st c="75757">Automation center</st></strong><st c="75774"> blade in </st><span class="No-Break"><st c="75784">Power Automate:</st></span></li>
			</ul>
			<div>
				<div id="_idContainer113" class="IMG---Figure">
					<img src="image/B22208_08_29.jpg" alt="Figure 8.29 – The Power Automate Automation center"/><st c="75799"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="76747">Figure 8.29 – The Power Automate Automation center</st></p>
			<p class="list-inset"><st c="76797">Here, we can visualize the data logged in Dataverse, and we can use Copilot on the right-hand side to get help </st><span class="No-Break"><st c="76909">with troubleshooting.</st></span></p>
			<ul>
				<li><st c="76930">With Dataverse, we can develop a </st><strong class="bold"><st c="76964">custom Dataverse plugin</st></strong><st c="76987"> that sends this information</st><a id="_idIndexMarker1118"/><st c="77015"> to the Application  Insights</st><a id="_idIndexMarker1119"/><st c="77043"> endpoint, with the help of the </st><span class="No-Break"><strong class="bold"><st c="77075">C# SDK</st></strong></span><span class="No-Break"><st c="77081">.</st></span></li>
			</ul>
			<p><st c="77082">As we have seen, Azure Application</st><a id="_idIndexMarker1120"/><st c="77117"> Insights is an enterprise-ready application performance management PaaS solution that we can easily integrate into our Power Platform </st><span class="No-Break"><st c="77252">product portfolio.</st></span></p>
			<p><st c="77270">Now, we will delve into our final topic, the world of feature flags, and what they can bring to our Power </st><span class="No-Break"><st c="77377">Platform solutions.</st></span></p>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor145"/><st c="77396">Exercise – introducing feature flags</st></h1>
			<p><st c="77433">In custom development projects, </st><strong class="bold"><st c="77466">feature flags</st></strong><st c="77479"> are used to turn on or off features</st><a id="_idIndexMarker1121"/><st c="77515"> of applications. </st><st c="77533">Agile teams benefit from this concept very much because features with great impact and long development time, which span over multiple sprints, can be kept hidden from end users until they are fully developed. </st><st c="77743">Consider features such as enabling the Copilot feature in Microsoft Azure or making GitHub Copilot available in public repositories. </st><st c="77876">These features were developed behind feature flags before they were released to the public audience. </st><st c="77977">We also very often use feature flags to turn on new features for a group of users (e.g., users who participate in beta-testing activities). </st><st c="78117">The aforementioned Copilots were first available as a private preview for dedicated customers, then they went to the public preview stage, and finally, they became </st><span class="No-Break"><st c="78281">generally available.</st></span></p>
			<p><st c="78301">The solution-specific </st><strong class="bold"><st c="78324">environment variables</st></strong><st c="78345"> in Power Platform can provide this feature flag capability, if we</st><a id="_idIndexMarker1122"/><st c="78411"> use it in front of new features. </st><st c="78445">To use environment variables in Power Platform solutions as feature flags, we can follow </st><span class="No-Break"><st c="78534">these steps:</st></span></p>
			<ol>
				<li><st c="78546">Create an environment variable within our solution. </st><st c="78599">This can be done by selecting </st><strong class="bold"><st c="78629">New</st></strong><st c="78632"> | </st><strong class="bold"><st c="78635">More</st></strong><st c="78639"> | the </st><strong class="bold"><st c="78646">Environment</st></strong><st c="78657"> variable in the solution we are </st><span class="No-Break"><st c="78690">working on.</st></span></li>
				<li><st c="78701">Set the data type for the environment variable, which can be </st><strong class="source-inline"><st c="78763">Boolean</st></strong><st c="78770">, </st><strong class="source-inline"><st c="78772">Option Set</st></strong><st c="78782">, or </st><strong class="source-inline"><st c="78787">Text</st></strong><st c="78791">, depending on what we need for the </st><span class="No-Break"><st c="78827">feature flag.</st></span></li>
				<li><st c="78840">Use the environment variable in our solution components, such as Power Automate flows, Power Apps canvas apps, or custom connectors. </st><st c="78974">For Power Apps, we can access the environment variable value using the </st><strong class="source-inline"><st c="79045">LookUp()</st></strong><st c="79053"> PowerFX function, and for Power Automate, we can use Dataverse’s </st><strong class="source-inline"><st c="79119">Perform an outbound action</st></strong><st c="79145"> with the action </st><span class="No-Break"><st c="79162">name </st></span><span class="No-Break"><strong class="source-inline"><st c="79167">RetrieveEnvironmentVariableSecretValue</st></strong></span><span class="No-Break"><st c="79205">.</st></span></li>
				<li><st c="79206">Deploy our solution to different environments, and change the environment variable value according to our feature flag settings. </st><st c="79336">This allows us to enable or disable certain features or functionalities based on the </st><span class="No-Break"><st c="79421">environment settings.</st></span></li>
			</ol>
			<p><st c="79442">Let’s introduce a feature flag</st><a id="_idIndexMarker1123"/><st c="79473"> to our Kudos app solution to control which label needs to be displayed on the landing page – the original one, or the one that we created in the </st><em class="italic"><st c="79619">Exercise – building CD pipelines and a release train</st></em><st c="79671"> section earlier in </st><span class="No-Break"><st c="79691">this chapter:</st></span></p>
			<div>
				<div id="_idContainer114" class="IMG---Figure">
					<img src="image/B22208_08_30.jpg" alt="Figure 8.30 – An environment variable as a feature flag"/><st c="79704"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><st c="80127">Figure 8.30 – An environment variable as a feature flag</st></p>
			<p><st c="80182">We define this </st><a id="_idIndexMarker1124"/><st c="80198">environment variable with the </st><strong class="source-inline"><st c="80228">Boolean</st></strong><st c="80235"> data type and its default value is set to </st><strong class="bold"><st c="80278">No</st></strong><st c="80280">. If we want to set the value in the environment, we just need to click on </st><strong class="bold"><st c="80355">+ New value</st></strong><st c="80366"> to set the value to </st><strong class="bold"><st c="80387">Yes</st></strong><st c="80390">. The environment variable is </st><span class="No-Break"><st c="80420">called </st></span><span class="No-Break"><strong class="source-inline"><st c="80427">featureFlagLabel</st></strong></span><span class="No-Break"><st c="80443">.</st></span></p>
			<p><st c="80444">To read the value of an environment variable in a canvas app using PowerFX, we can use the </st><span class="No-Break"><st c="80536">following method:</st></span></p>
			<ul>
				<li><st c="80553">Make sure we have added the </st><strong class="source-inline"><st c="80582">Environment Variable Values</st></strong><st c="80609"> table to our canvas app’s </st><span class="No-Break"><st c="80636">data sources.</st></span></li>
				<li><st c="80649">Use the </st><strong class="source-inline"><st c="80658">LookUp()</st></strong><st c="80666"> function with the schema name of our environment variable – for example, </st><strong class="source-inline"><st c="80740">LookUp('Environment Variable Values', 'Environment Variable Definition'.'Schema Name' = "</st></strong><span class="No-Break"><strong class="source-inline"><st c="80829">YourEnvironmentVariableSchemaName").Value</st></strong></span><span class="No-Break"><st c="80871">.</st></span></li>
				<li><st c="80872">This will retrieve the current value of the environment variable </st><span class="No-Break"><st c="80938">we specified.</st></span></li>
			</ul>
			<p><st c="80951">Let’s open our Kudos app to edit</st><a id="_idIndexMarker1125"/><st c="80984"> from our solution, and then introduce the new data source, </st><strong class="source-inline"><st c="81044">Environment Variable Values</st></strong><st c="81071">. After that, we need to change the </st><strong class="source-inline"><st c="81107">Text</st></strong><st c="81111"> property of </st><strong class="source-inline"><st c="81124">lblTitle_LandingScreen</st></strong><st c="81146"> from static text to </st><span class="No-Break"><st c="81167">the following:</st></span></p>
			<pre class="source-code"><st c="81181">
If(
    </st><strong class="bold"><st c="81186">IsBlank(LookUp('Environment Variable Values', 'Environment Variable Definition'.'Schema Name' = "mpa_featureFlagLabel").Value)</st></strong><st c="81312">,
    "Employee Kudos",
    If(
        </st><strong class="bold"><st c="81336">LookUp('Environment Variable Values', 'Environment Variable Definition'.'Schema Name' = "mpa_featureFlagLabel").Value = "no"</st></strong><st c="81460">,
        "Employee Kudos",
        "Employee Kudos - April 2024"
    )
)</st></pre>			<p><st c="81513">As we learned in the first section of this chapter, deployment settings files do not only contain connection references but also environment variables. </st><st c="81666">Our </st><strong class="source-inline"><st c="81670">deploymentSettings.json</st></strong><st c="81693"> file is located under </st><strong class="source-inline"><st c="81716">\src\mpa_Kudos\deploymentSettings.json</st></strong><st c="81754">. With the help of the </st><strong class="source-inline"><st c="81777">cat</st></strong><st c="81780"> command, we have already updated this file in our GitHub workflows (</st><em class="italic"><st c="81849">Release to Production</st></em><st c="81871"> and </st><em class="italic"><st c="81876">Import to dev</st></em><st c="81889">) regarding </st><span class="No-Break"><st c="81902">connection references:</st></span></p>
			<pre class="source-code"><st c="81924">
newDataverseId="${{ github.event.inputs.dataverseConnectionId }}"
newO365Id="${{ github.event.inputs.o365IdConnectionId }}"
newOutlookId="${{ github.event.inputs.outlookIdConnectionId }}"
cat ${{ env.solution_source_folder}}/${{ env.kudos_solution_name }}/deploymentSettings.json | jq --arg dataverseId "$newDataverseId" --arg o365Id "$newO365Id" --arg outlookId "$newOutlookId" '</st><strong class="bold"><st c="82305">.ConnectionReferences[]</st></strong><st c="82328"> |=
         if .ConnectionId == "[Dataverse]" then .ConnectionId = $dataverseId
         elif .ConnectionId == "[O365]" then .ConnectionId = $o365Id
         elif .ConnectionId == "[Outlook]" then .ConnectionId = $outlookId
        else . </st><st c="82533">end' &gt; temp.json &amp;&amp; mv temp.json ${{ env.solution_source_folder}}/${{ env.kudos_solution_name }}/deploymentSettings.json</st></pre>			<p><st c="82653">Similarly, we can update the values of environment variables in this JSON file to fully automate them in our deployment pipelines. </st><st c="82785">We just need</st><a id="_idIndexMarker1126"/><st c="82797"> to replace the </st><strong class="source-inline"><st c="82813">.ConnectionReferences[]</st></strong><st c="82836"> array with the </st><strong class="source-inline"><st c="82852">.EnvironmentVariables[]</st></strong><st c="82875"> one to adjust </st><span class="No-Break"><st c="82890">our variables.</st></span></p>
			<p><st c="82904">In this section, we learned how we can use environment variables to add feature flags to our applications and </st><span class="No-Break"><st c="83015">cloud flows.</st></span></p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor146"/><st c="83027">Summary</st></h1>
			<p><st c="83035">In this chapter, we embarked on an exciting journey, diving into the practical application of DevOps and ALM principles. </st><st c="83157">We explored a variety of hands-on exercises, from mastering repository branch strategies to constructing robust CD pipelines, managing backlogs effectively, and enforcing branch protection rules. </st><st c="83353">We also delved into automated testing of our solutions, monitored our application’s performance in runtime with APM, and harnessed the power of feature flags. </st><st c="83512">These exercises were not just theoretical; we also applied them to a real-world example, utilizing GitHub as our DevOps tool of choice. </st><st c="83648">Through these practical walkthroughs, we’ve woven every thread of DevOps and ALM into a</st><a href="https://learn.microsoft.com/en-us/power-platform/enterprise-templates/overview"><st c="83735"> hands-on </st><span class="No-Break"><st c="83745">experience tapestry.</st></span></a></p>
			<p><a href="https://learn.microsoft.com/en-us/power-platform/enterprise-templates/overview"><st c="83765">In the forthcoming chapter, we will delve into </st></a><st c="83813">fusion architecture and see how we can leverage Azure PaaS services in our Power </st><span class="No-Break"><st c="83894">Platform solutions.</st></span></p>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor147"/><st c="83913">Further reading</st></h1>
			<ul>
				<li><st c="83929">Power Platform Enterprise </st><span class="No-Break"><st c="83956">template: </st></span><a href="https://learn.microsoft.com/en-us/power-platform/enterprise-templates/overview"><span class="No-Break"><st c="83966">https://learn.microsoft.com/en-us/power-platform/enterprise-templates/overview</st></span></a></li>
				<li><st c="84044">Kudos </st><span class="No-Break"><st c="84051">application: </st></span><a href="https://learn.microsoft.com/en-us/power-platform/enterprise-templates/hr/employee-kudos/install-and-set-up"><span class="No-Break"><st c="84064">https://learn.microsoft.com/en-us/power-platform/enterprise-templates/hr/employee-kudos/install-and-set-up</st></span></a></li>
				<li><st c="84170">The GitHub </st><span class="No-Break"><st c="84182">CLI: </st></span><span class="No-Break"><st c="84187">https://github.com/cli/cli</st></span></li>
				<li><st c="84213">The GitHub CLI with GitHub </st><span class="No-Break"><st c="84241">Copilot: </st></span><a href="https://docs.github.com/en/copilot/github-copilot-in-the-cli/using-github-copilot-in-the-cli"><span class="No-Break"><st c="84250">https://docs.github.com/en/copilot/github-copilot-in-the-cli/using-github-copilot-in-the-cli</st></span></a></li>
				<li><st c="84342">Pre-populate connection </st><span class="No-Break"><st c="84367">references: </st></span><a href="https://learn.microsoft.com/en-us/power-platform/alm/conn-ref-env-variables-build-tools#get-the-connection-reference-information"><span class="No-Break"><st c="84379">https://learn.microsoft.com/en-us/power-platform/alm/conn-ref-env-variables-build-tools#get-the-connection-reference-information</st></span></a></li>
				<li><st c="84507">GitHub </st><span class="No-Break"><st c="84515">environments: </st></span><a href="https://docs.github.com/en/actions/learn-github-actions/variables#using-the-vars-context-to-access-configuration-variable-values"><span class="No-Break"><st c="84529">https://docs.github.com/en/actions/learn-github-actions/variables#using-the-vars-context-to-access-configuration-variable-values</st></span></a></li>
				<li><st c="84657">GitHub </st><span class="No-Break"><st c="84665">outputs: </st></span><a href="https://docs.github.com/en/actions/using-jobs/defining-outputs-for-jobs"><span class="No-Break"><st c="84674">https://docs.github.com/en/actions/using-jobs/defining-outputs-for-jobs</st></span></a></li>
				<li><st c="84745">GitHub jobs and </st><span class="No-Break"><st c="84762">needs: </st></span><a href="https://docs.github.com/en/actions/using-jobs/using-jobs-in-a-workflow"><span class="No-Break"><st c="84769">https://docs.github.com/en/actions/using-jobs/using-jobs-in-a-workflow</st></span></a></li>
				<li><st c="84839">GitHub composite </st><span class="No-Break"><st c="84857">actions: </st></span><a href="https://docs.github.com/en/actions/creating-actions/creating-a-composite-action"><span class="No-Break"><st c="84866">https://docs.github.com/en/actions/creating-actions/creating-a-composite-action</st></span></a></li>
				<li><st c="84945">GitHub pull </st><span class="No-Break"><st c="84958">requests: </st></span><a href="https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-pull-requests"><span class="No-Break"><st c="84968">https://docs.github.com/en/pull-requests/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-pull-requests</st></span></a></li>
				<li><st c="85111">GitHub </st><span class="No-Break"><st c="85119">Marketplace: </st></span><a href="https://github.com/marketplace"><span class="No-Break"><st c="85132">https://github.com/marketplace</st></span></a></li>
				<li><st c="85162">Power Apps Test </st><span class="No-Break"><st c="85179">Engine: </st></span><a href="https://learn.microsoft.com/en-us/power-apps/developer/test-engine/overview"><span class="No-Break"><st c="85187">https://learn.microsoft.com/en-us/power-apps/developer/test-engine/overview</st></span></a></li>
				<li><st c="85262">Working with Power Apps Test </st><span class="No-Break"><st c="85292">Studio: </st></span><a href="https://learn.microsoft.com/en-us/power-apps/maker/canvas-apps/working-with-test-studio"><span class="No-Break"><st c="85300">https://learn.microsoft.com/en-us/power-apps/maker/canvas-apps/working-with-test-studio</st></span></a></li>
				<li><st c="85387">Azure Application Insights </st><span class="No-Break"><st c="85415">overview: </st></span><a href="https://learn.microsoft.com/en-us/azure/azure-monitor/app/app-insights-overview"><span class="No-Break"><st c="85425">https://learn.microsoft.com/en-us/azure/azure-monitor/app/app-insights-overview</st></span></a></li>
				<li><st c="85504">Metric </st><span class="No-Break"><st c="85512">alerts: </st></span><a href="https://learn.microsoft.com/en-us/azure/azure-monitor/alerts/tutorial-metric-alert"><span class="No-Break"><st c="85520">https://learn.microsoft.com/en-us/azure/azure-monitor/alerts/tutorial-metric-alert</st></span></a></li>
				<li><st c="85602">Action </st><span class="No-Break"><st c="85610">groups: </st></span><a href="https://learn.microsoft.com/en-us/azure/azure-monitor/alerts/action-groups"><span class="No-Break"><st c="85618">https://learn.microsoft.com/en-us/azure/azure-monitor/alerts/action-groups</st></span></a></li>
				<li><st c="85692">Power Apps with Application </st><span class="No-Break"><st c="85721">Insights: </st></span><a href="https://learn.microsoft.com/en-us/power-apps/maker/canvas-apps/application-insights"><span class="No-Break"><st c="85731">https://learn.microsoft.com/en-us/power-apps/maker/canvas-apps/application-insights</st></span></a></li>
				<li><st c="85814">An overview of Application Insights </st><span class="No-Break"><st c="85851">integration: </st></span><a href="https://learn.microsoft.com/en-us/power-platform/admin/overview-integration-application-insights"><span class="No-Break"><st c="85864">https://learn.microsoft.com/en-us/power-platform/admin/overview-integration-application-insights</st></span></a></li>
				<li><st c="85960">Export data to Application </st><span class="No-Break"><st c="85988">Insights: </st></span><a href="https://learn.microsoft.com/en-us/power-platform/admin/set-up-export-application-insights"><span class="No-Break"><st c="85998">https://learn.microsoft.com/en-us/power-platform/admin/set-up-export-application-insights</st></span></a></li>
				<li><st c="86087">Power Pages and Application </st><span class="No-Break"><st c="86116">Insights: </st></span><a href="https://learn.microsoft.com/en-us/power-pages/go-live/telemetry-monitoring"><span class="No-Break"><st c="86126">https://learn.microsoft.com/en-us/power-pages/go-live/telemetry-monitoring</st></span></a></li>
				<li><st c="86200">Environment </st><span class="No-Break"><st c="86213">variables: </st></span><a href="https://learn.microsoft.com/en-us/power-apps/maker/data-platform/environmentvariables"><span class="No-Break"><st c="86224">https://learn.microsoft.com/en-us/power-apps/maker/data-platform/environmentvariables</st></span></a></li>
				<li><st c="86309">Power Automate automation </st><span class="No-Break"><st c="86336">center: </st></span><a href="https://learn.microsoft.com/en-us/power-automate/automation-center-overview"><span class="No-Break"><st c="86344">https://learn.microsoft.com/en-us/power-automate/automation-center-overview</st></span></a></li>
			</ul>
		</div>
	<div id="charCountTotal" value="86419"/>

		<div id="_idContainer116" class="Content">
			<h1 id="_idParaDest-137" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor148"/><st c="0">Part 3:Exploring DevOps Best Practices and the Road Ahead</st></h1>
			<p><st c="58">In this part, we will be exploring the possibilities of building fusion teams, where pro developers and DevOps engineers can help with the low-code/no-code development approach. </st><st c="237">We will understand how culture plays a significant role in faster development cycles and the importance of building reusable components. </st><st c="374">We will look at how Microsoft Azure cloud services can integrate with Power Platform solutions. </st><st c="470">Pro developers will understand how extensible Power Platform is with the ability to utilize custom code components that can extend the capabilities of Power Platform. </st><st c="637">We will conclude this chapter by investigating how artificial intelligence has changed the way we develop our business applications and how it enables us to build custom copilots that not only support our DevOps process but also enrich our </st><span class="No-Break"><st c="877">business solutions.</st></span></p>
			<p><st c="896">This part has the </st><span class="No-Break"><st c="915">following chapters:</st></span></p>
			<ul>
				<li><a href="B22208_09.xhtml#_idTextAnchor149"><em class="italic"><st c="934">Chapter 9</st></em></a><st c="944">, </st><em class="italic"><st c="946">Implementing the Fusion Development Approach</st></em></li>
				<li><a href="B22208_10.xhtml#_idTextAnchor172"><em class="italic"><st c="990">Chapter 10</st></em></a><st c="1001">, </st><em class="italic"><st c="1003">Enabling Pro-Dev Extensibility in Power Platform</st></em></li>
				<li><a href="B22208_11.xhtml#_idTextAnchor208"><em class="italic"><st c="1051">Chapter 11</st></em></a><st c="1062">, </st><em class="italic"><st c="1064">Managing the Environment Life Cycle with Design Best Practices</st></em></li>
				<li><a href="B22208_12.xhtml#_idTextAnchor231"><em class="italic"><st c="1126">Chapter 12</st></em></a><st c="1137">, </st><em class="italic"><st c="1139">Looking Ahead with Copilots, ChatOps, and AI-Infused Applications</st></em></li>
			</ul>
		</div>
		<div>
			<div id="_idContainer117">
			</div>
		</div>
		<div>
			<div id="_idContainer118" class="Basic-Graphics-Frame">
			</div>
		</div>
	<div id="charCountTotal" value="1204"/></body></html>