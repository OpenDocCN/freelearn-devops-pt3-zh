- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What Are the Various SDLC Release Management Models?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Software development teams can organize their work using various **frameworks**
    or **release management models**. These models help organizations implement the
    **software development life cycle** (**SDLC**) using different strategies to accomplish
    the same result. A release management model contains individual phases that software
    developers use to organize their work while delivering a software product or feature.
    Generally speaking, each model contains the following six phases: **change request**,
    **planning**, **design & build**, **testing**, **deployment**, and **release support**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Release management models ensure that high-quality software is produced according
    to customer requirements. Various release management methodologies have been created
    to serve this purpose, such as ITIL, waterfall, iterative, V-model, spiral, big
    bang, agile, and DevOps, but there are several less popular ones that aren’t within
    the scope of this book. Let’s review some of the most commonly used SDLC release
    management models:'
  prefs: []
  type: TYPE_NORMAL
- en: The ITIL model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The waterfall model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The iterative model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The V-model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The spiral model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The big bang model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The agile model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The DevOps model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The ITIL model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The British Government’s **Central Computing and Telecommunications Agency**
    (**CCTA**) created the **Information Technology Infrastructure Library** (**ITIL**)
    model: a set of best practices for IT activities, such as **IT service management**
    (**ITSM**) and **IT asset management** (**ITAM**), having its origins in the early
    1980s. These practices are centered on the concept of aligning IT services with
    the requirements of a company’s operations. In the year 2000, the CCTA merged
    into Great Britain’s **Office for Government** **Commerce** (**OGC**).'
  prefs: []
  type: TYPE_NORMAL
- en: In their infancy, enterprise IT departments were regarded as cost centers by
    senior leadership, rather than the value multipliers that they are. At that time,
    many firms had no established protocols for obtaining services or reporting IT
    incidents, and IT and business communication was poor. As a result, many firms’
    leadership believed IT did not create value or meet company-wide objectives. As
    enterprise IT departments began proliferating, they understood that they needed
    to prove how valuable they were by meeting measurable outcomes defined by the
    business.
  prefs: []
  type: TYPE_NORMAL
- en: With the advent of the ITSM paradigm, businesses’ attention shifted from IT
    *departments* to the management and fulfillment of IT *services*. ITSM was new
    to IT professionals, who were treated as a separate entity, while the business
    unit was treated as their client. To serve clients, IT provides services supported
    by technological resources and expertise. So, to demonstrate value, IT must supply
    these services at established service level agreements and fulfill strategic business
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: ITIL guides IT service management across all service life cycles. At its core,
    ITIL is a framework for managing an organization’s IT infrastructure in order
    to achieve strategic goals, generate business value, and ensure a baseline of
    competence. A company can then use this benchmark as a starting point for future
    planning, implementation, and evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you have probably already inferred by now, the **ITIL release management
    model** has more to do with *systems development* than software development. That
    being said, ITIL is recognized as one of the earliest and most widely implemented
    release management models used in enterprise environments. Despite ITIL being
    an outlier in the release management of software, just be aware of what ITIL is
    and how it fits into the overall release management ecosystem. Now, let’s look
    at the two most recent versions of ITIL: V3 and V4.'
  prefs: []
  type: TYPE_NORMAL
- en: ITIL 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The OGC made significant advancements in its strategy for IT Service Management
    (ITSM) and provided updated guidance that exceeded the depth and comprehensiveness
    of ITIL version 2\. ITIL version 3 was released to the general public in 2007
    and was structured as a compilation of five distinct stages within the service
    life cycle. These stages include *service strategy*, *service design*, *service
    transition*, *service operation*, and *continuous* *service improvement*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of the five stages is intended to cover a certain stage of the service
    life cycle, which can be summarized as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Service strategy**: To make a plan for better serving customers. The service
    strategy process, which begins with an analysis of customer requirements and market
    conditions, establishes the services to be provided by the IT organization and
    the capabilities to be built. The end goal is to shift the IT department’s mindset
    toward one of strategic planning and execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service design**: To develop new information technology (IT) services. The
    breadth of the process encompasses both the creation of new services and the modification
    and enhancement of existing ones.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service transition**: To create and release computer systems. Changes to
    services and service management procedures are implemented in a coordinated way,
    which is another responsibility of the service transition function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Service operation**: To make sure that IT services are provided well and
    quickly. In the service operation process, users’ requests are met, service failures
    are fixed, problems are fixed, and routine operating tasks are done.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Continual service improvement**: To apply quality management techniques to
    gain insight into both present and past performance. The purpose of the continual
    service improvement process is to implement the concept of continuous improvement
    adopted by ISO 20000 into IT processes and services in order to maximize their
    effectiveness and efficiency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure depicts the stages of the ITIL V3 release management model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1: The ITIL V3 release management model](img/B21803_03_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.1: The ITIL V3 release management model'
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our look at ITIL V3\. We are observing both ITIL V3 and ITIL
    V4 because they diverge somewhat significantly from each other. It is notable
    that ITIL V4 is a recent addition and its process diagram doesn’t capture the
    same heritage that earlier editions of ITIL were known for. ITIL V4’s departure
    comes with a shift in focus to being a more flexible service framework, rather
    than being a rigid IT service management model.
  prefs: []
  type: TYPE_NORMAL
- en: ITIL 4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There hasn’t been a significant revision of ITIL since 2007; therefore, **ITIL
    4** could represent a reaction to the rise in competing service management frameworks
    such as **VeriSM™**, **SIAM®**, and **FitSM**. It’s an updated and expanded version
    of **ITIL V3** (also known as **ITIL 2011**) that can serve as a flexible foundation
    for enterprises undergoing digital transformation.
  prefs: []
  type: TYPE_NORMAL
- en: ITIL version 4 outlines a process framework for providing IT-enabled products
    and services. There have been extensive edits made to the documentation to make
    it more readable, and several examples have been added. ITIL 4 also considers
    contemporary practices in software engineering and information technology administration
    by providing guidance on using methodologies such as Agile, DevOps, and Lean in
    the context of service management. Finally, ITIL 4 emphasizes that it is *a framework
    for service management* (rather than *IT service management*), which reflects
    the expanding use of service management best practices outside of the IT industry.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to remember that, although ITIL is indeed a release management
    methodology, it has more in common with the system development life cycle than
    the software development life cycle. It is for this reason that ITIL appears first
    on our list. Now, let’s turn our attention to the waterfall release management
    model. The waterfall model is the original release management standard for organizing
    projects that focus on building information systems. The waterfall model came
    into existence during the pivotal years when engineers were transitioning from
    programming computers with switchboards and cables to using logical sequences
    of holes that were etched out of punch cards. This marked the first time in history
    that programs could be authored and managed independently of physical machines.
  prefs: []
  type: TYPE_NORMAL
- en: The waterfall model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **waterfall** model is a method for organizing the phases of a project in
    a linear, sequential order. This means that each phase builds on the deliverables
    of the one that came before it and corresponds to a different level of task specialization.
    This method is frequently used in a number of engineering design specializations.
    Since progress is made in mostly one direction (*downwards*, like a waterfall),
    this methodology is typically considered to be one of the least iterative and
    adaptable models in software development. The reason for this is that a team can
    only move forward in the waterfall process, never backward. This linear progression
    of immutable phases includes *requirements gathering & analysis*, *system design*,
    *implementation*, *testing*, *deployment*, and *maintenance*.
  prefs: []
  type: TYPE_NORMAL
- en: The waterfall model was the very first kind of release management SDLC to be
    used in software development. The manufacturing and construction sectors are credited
    with being the birthplace of the waterfall development model. In these industries,
    highly organized environments meant that making design modifications became prohibitively
    expensive earlier in the fabrication process. When it was first implemented for
    the development of software, there were no acknowledged alternatives for knowledge-based
    creative work.
  prefs: []
  type: TYPE_NORMAL
- en: The waterfall release management approach has received significant backlash
    as a result of its flaws. Before they see functional software, clients might not
    know exactly what their requirements are, which might lead them to change their
    requirements after the fact. This would result in the need for redesign, redevelopment,
    and retesting, which would drive up expenses. Software engineers and business
    developers may lack the foresight of the potential challenges that may arise throughout
    the design process of a new software product or feature. In such instances, it
    is advisable to reassess the design rather than continue with a design that doesn’t
    take into account any newly identified limitations, prerequisites, or issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every phased process can be better understood after viewing a diagram depicting
    its stages and the way they flow. Observing the waterfall release management model
    as a diagram certainly makes it easy to understand how its linear sequences of
    immutable steps give the waterfall model its name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2: The six phases of the waterfall release management model](img/B21803_03_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.2: The six phases of the waterfall release management model'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the waterfall release management model is well suited to organizing
    a large effort, involving hundreds or even thousands of developers on a single
    project. Now that you have a fundamental understanding of the waterfall release
    management model, you are well equipped to grasp the concepts of the more advanced
    release management models that came after it.
  prefs: []
  type: TYPE_NORMAL
- en: The next release management model that we will investigate is the *iterative
    and incremental* model, commonly referred to as simply the **iterative** model.
    This method involves constructing a system in small, incremental steps, or iterations.
    This release management model is one of the earliest and closest competitors of
    the waterfall model, getting its start in around 1960\. It is for this reason
    that we will be discussing the Iterative and Incremental release management model
    next.
  prefs: []
  type: TYPE_NORMAL
- en: The iterative model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The concept behind this technique is to build a system in small, incremental
    steps, or *iterations*, so that software engineers can benefit from the lessons
    learned while building the system’s previous versions. Learning occurs throughout
    system development and use, where essential steps may begin with a rudimentary
    implementation of a subset of software requirements and iteratively improve until
    the whole system is implemented. Modifications to the design and new features
    are incorporated after each iteration of the development cycle, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3: The iterative and incremental release management model](img/B21803_03_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.3: The iterative and incremental release management model'
  prefs: []
  type: TYPE_NORMAL
- en: 'The exact technique is broken down into three steps: the **initialization phase**,
    the **iteration step**, and the **project control list**. The system’s starting
    point is built during initialization. In this first stage of development, we want
    to give the user something that they can give feedback to. It should provide a
    comprehensive overview of the issue and a straightforward solution. A project
    control list is compiled at the beginning of each iteration to serve as a record
    of all outstanding tasks. It entails things like reworking parts of the current
    solution or adding brand-new functionality. The analysis step results in consistent
    updates to the control list.'
  prefs: []
  type: TYPE_NORMAL
- en: The **redesign** and **implementation** of an iteration should be easy to understand
    and apply, either during the iteration itself or as a separate job added to the
    project’s control list. The iterative method does not mandate a specific granularity
    in the design. However, in a key iterative project, a formal software design document
    may be utilized to supplement the code as the primary source of documentation
    for the system. An iteration’s analysis is based on user feedback and the program
    analysis tools available. It entails an examination of the structure, modularity,
    usability, dependability, efficiency, and attainment of goals. The project control
    list is updated based on the findings of the research.
  prefs: []
  type: TYPE_NORMAL
- en: With iterative development, your team will make incremental improvements and
    tweaks to the software until it is fully functional. Each iteration should aim
    to better the product as a whole, not just produce a new feature or functional
    component. Iterative style management allows for adjustments to be made to the
    project as needed to ensure success. This helps the development group take any
    unforeseen shifts in direction into consideration, whether positive or negative.
  prefs: []
  type: TYPE_NORMAL
- en: A competent iterative project manager must be able to make these adjustments
    as the project progresses with minimal disruption to the crew and with an ear
    for the feedback of other team members in order to ensure that the schedule and
    budget remain attainable. Additionally, faults and difficulties can be recognized
    and fixed earlier, saving time and money. When you regularly provide viable product
    increments, it allows consumers to submit feedback sooner, resulting in superior
    software that is relevant to the needs of users. There won’t be any last-minute
    adjustments or frantic attempts at fulfilling unachievable deadlines if the product
    is managed in an iterative and incremental style.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our look at the iterative and incremental release management
    model. As you can now infer, the iterative and incremental model is shockingly
    similar to the agile release management model that came decades later, which we
    will cover later in this chapter. Now, let’s change gears and shift our focus
    to the V-shaped release management model.
  prefs: []
  type: TYPE_NORMAL
- en: The V-model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **V-model** gets its name from its resemblance to the letter *V*. This
    SDLC release management model is partitioned into stages in the V-model, with
    each stage having its own dedicated testing phase. The V’s left side represents
    the verification stage, while the V’s right side represents the validation stage.
    The V-model is a graphical depiction of the phases involved in creating a system
    and it is used to construct rigorous models for project management and development
    life cycles. The following figure shows the V-model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4: The V-shaped release management model](img/B21803_03_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: The V-shaped release management model'
  prefs: []
  type: TYPE_NORMAL
- en: The V-model provides a high-level overview of the major activities and their
    associated outputs in a computerized system validation framework, sometimes known
    as project life cycle development. It specifies the activities that must be carried
    out and the deliverables that must be generated during product development.
  prefs: []
  type: TYPE_NORMAL
- en: The process of breaking down requirements and developing system specifications
    is depicted on the V’s left side. Integrating and validating individual components
    is represented by the V’s right side. However, requirements have to go through
    a validation process first, where they are compared to higher-level requirements
    or user demands. In addition, there is a concept known as system model validation.
    You can also accomplish this by shifting left, meaning that it’s possible that
    the claim that validation only occurs on the right side is inaccurate, depending
    on how the team operates.
  prefs: []
  type: TYPE_NORMAL
- en: Time and development in the V-model progress from left to right, and there is
    no way to reverse the process. As can be seen in the diagram, all iteration occurs
    vertically, either going up or down the framework’s architecture. The two processes
    are distinguished by the fact that verification is done in accordance with predefined
    technical specifications, while validation is done in accordance with actual world
    conditions or user requirements. You can validate by ensuring that you are building
    the correct thing and verifying that you are building it the correct way.
  prefs: []
  type: TYPE_NORMAL
- en: The spiral model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 1986, Barry W. Boehm created the **spiral** release management model as a
    method for organizing the SDLC. It assumes that building an app is a cycle that
    may be repeated indefinitely until the desired result is achieved. By continuously
    monitoring risks and inspecting the intermediate product, the spiral model significantly
    reduces the likelihood of failure in large software projects.
  prefs: []
  type: TYPE_NORMAL
- en: Issues that arise during the course of the development process have a variety
    of potential impacts on the finished product. If such an outcome occurs, you should
    prepare for an increase in prices, an increase in work, and a delay in the delivery
    date. These are all elements that have the potential to quickly become a threat
    to the sustainability of your company. The iterative and gradual approach that
    the spiral model takes, in addition to the regular risk assessment that can take
    the form of prototype drafts, studies, or simulations, is designed to either eliminate
    the possibility of events like this entirely or at least reduce the severity of
    the damage they do. Spiral software development is popular for large, highly customized
    projects where customers and developers prioritize financial management or projects
    in highly volatile markets. The spiral model’s biggest advantage over other conventional
    models is risk analysis, which benefits all involved. Regular risk assessments
    are especially important in innovative technical environments that lack empirical
    values and have a higher risk probability.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5: The spiral release management model](img/B21803_03_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: The spiral release management model'
  prefs: []
  type: TYPE_NORMAL
- en: 'The software development project goes through its spiral model cycle in an
    ongoing manner until it reaches its final status. The cycle consists mostly of
    the following four steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The first phase of a typical cycle in a spiral model is to determine which goals
    ought to be associated with the various stages of software development. Increasing
    the functionality or enhancing the performance are both examples of this type
    of change. At the same time, it is required to specify several implementation
    choices (for example, design A against design B) as well as to determine the framework
    conditions and the expenses or the amount of time that will be spent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The following stage is to analyze the various options, with the goal and the
    conditions of the framework serving as the authoritative reference values. During
    this phase of the spiral model cycle, the regions of uncertainty that present
    a major risk to the overall development of the software project should be identified
    and analyzed. Prototyping, simulations, benchmark testing, analytical models,
    and user surveys are some of the tools that will be utilized during the next stage,
    which will be the development of a strategy that is both the least risk-inducing
    and the most cost-effective.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After a thorough risk assessment has been conducted, software development can
    proceed—always with some degree of residual risk. If, for instance, performance
    risks, user interface risks, or internal interface control risks substantially
    dominate the development process, the first alternative is an evolutionary development
    strategy, in which the project is specified more clearly, and prototypes are optimized.
    In this strategy, the user interface risks, and the internal interface control
    risks are concerns that strongly dominate the development process. Then, the code
    is created and tested multiple times until the intended outcome is obtained, which
    serves as a low-risk foundation for subsequent development processes thereafter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Evolutionary prototype development
  prefs: []
  type: TYPE_NORMAL
- en: Evolutionary prototype development, also referred to as breadboard prototyping,
    stands apart from other prototyping strategies. The primary objective of utilizing
    evolutionary prototyping is to construct a highly resilient model using a systematic
    process and consistently enhancing it. This approach is based on the idea that
    the evolutionary prototype serves as the foundation for the newly implemented
    system, allowing for future enhancements and additional requirements to be incorporated
    gradually over time.
  prefs: []
  type: TYPE_NORMAL
- en: The next cycle is planned as soon as the current one ends. If the goal of the
    single cycle could be fulfilled and the determination of the next aim is pending,
    then this might be the usual continuation of the project. On the other hand, if
    the preceding stage of development is flawed, finding solutions might be your
    only option. One possible replacement for the current approach is one of the alternatives
    that has already been identified or the introduction of a brand new one. With
    this, you can make another go at it till you achieve your goal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The spiral release management model in software development is considered a
    generic process model. The four stages merely establish the fundamental goals
    of a cycle, without necessitating their manifestation in every iteration. The
    ordering of their sequence is not strictly dictated by the spiral model. Hence,
    the model has the potential to be integrated with other process models at any
    given point in time.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our review of the spiral release management model. By now, you
    know that spiral software development is a risk-averse model that asserts the
    implementation of iterative development techniques and manages risks throughout
    every step of the SDLC. Next, let’s investigate the big bang release management
    model—a risky development style that couldn’t be more different from the spiral
    model.
  prefs: []
  type: TYPE_NORMAL
- en: The big bang model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Without any extensive preparation, software engineers leap full force into programming
    while under the big bang release management model. In other words, there is no
    predetermined plan in place, and requirements are instead implemented as they
    are discovered. In some cases, a complete rewrite of the application may be necessary
    if adjustments must be made. You can see clearly how the big bang model bears
    its name. However, this methodology shines when there are only one or two developers
    involved in the project, as is the case in academia or for practice. This technique
    is useful when there is a lack of clarity regarding the project’s requirements
    and a firm deadline for completion.
  prefs: []
  type: TYPE_NORMAL
- en: The big bang model is a software development life cycle paradigm that begins
    with nothing and builds up from there. Very little time is spent on planning,
    and we do not adhere to any particular procedure. As it does not require any planning,
    it is the most fundamental type of release management methodology. The requirements
    are applied on the fly with minimal forethought, and the client isn’t even clear
    about what they want. The primary goal of this approach is to start coding as
    soon as possible, without adhering to any particular structure, and to provide
    the finished product to the customer as soon as possible. The day-to-day development
    begins with a few prerequisites even though there is little knowledge of the final
    result. Following that, the client maintains close correspondence with the development
    team in order to track how the work is progressing. If the result matches what
    was expected, the product is authorized; otherwise, a different solution is devised.
  prefs: []
  type: TYPE_NORMAL
- en: In a nutshell, this methodology does not necessitate extensively specified requirements,
    and product needs are comprehended and executed promptly upon receipt. The core
    emphasis of this paradigm is on coding, leaving it more susceptible to risks compared
    to alternative release management models. After the components, or at least their
    constituent parts, are fully integrated, testing can begin. This model is best
    for enabling the integration of bleeding edge technologies in an existing environment,
    for analyzing the modifications made, and for adaptability.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can infer, this model bears resemblance to the big bang theory of the
    creation of the universe. The result of a condensed mixture of time, resources,
    and energy leads to the establishment of a finished product, in the blink of an
    eye, and seemingly out of nothing. The following diagram is a detailed description
    of the big bang release management model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6: The big bang release management model](img/B21803_03_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6: The big bang release management model'
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our review of the big bang release management model. By now,
    you have gained perspective on what the true meaning of release management is.
    You understand what release management can be, from its most formal to its most
    informal. Next, we’ll examine the infamous agile release management model. Love
    it or hate it, the agile model was outrageously popular for around two decades
    before DevOps caught on and then eclipsed it.
  prefs: []
  type: TYPE_NORMAL
- en: The agile model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **agile** release management model divides the SDLC phases into multiple
    development cycles, with the team delivering incremental software changes at the
    conclusion of each cycle. The agile methodology is highly effective, and its rapid
    development cycles help teams identify problems early on; however, excessive reliance
    on customer feedback could result in excessive scope creep. The agile model is
    ideal for software development initiatives that require adaptability and flexibility
    over time. The following diagram depicts the agile model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7: The agile release management model](img/B21803_03_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.7: The agile release management model'
  prefs: []
  type: TYPE_NORMAL
- en: The majority of the techniques used for agile development divide the work into
    a number of smaller increments. These increments require less time and effort
    for upfront planning and design compared to other release management models, such
    as the waterfall model. These iterations, known as sprints, are brief periods
    of activity and normally last between one and four weeks. Each iteration requires
    the participation of a cross-functional team that works on all activities, including
    planning, analysis, design, coding, unit testing, and acceptance testing. At the
    conclusion of the iteration, stakeholders see a demonstration of a product that
    is already functional. This reduces risk overall and makes it easier for the product
    to quickly adjust to new circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: The goal is to have a release that is available (with a low number of bugs)
    at the conclusion of each iteration, even though each iteration might not yield
    sufficient features to warrant a market release. When products are developed incrementally,
    there is more flexibility for them to *fail often and early* throughout each iteration
    phase as opposed to failing catastrophically close to the product’s final delivery
    date. There may be a requirement for multiple revisions before a product or new
    features can be released. The most important indicator of progress is the presence
    of working software.
  prefs: []
  type: TYPE_NORMAL
- en: Rapid product development and reduced risk are the two major benefits of adopting
    the agile methodology. As a result, the risks associated with creating a product
    that doesn’t fulfill consumer requirements can be mitigated by releasing the product
    to the market in smaller increments.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our review of the agile release management model. As you can
    see, the agile model was the logical successor to the iterative and incremental
    model, yet it was also a stepping stone towards the DevOps release management
    model. It is for this reason that we will be discussing the DevOps model next.
  prefs: []
  type: TYPE_NORMAL
- en: The DevOps model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **DevOps** release management model encompasses a collection of methodologies
    that integrate **software development** (**Dev**) and **IT operations** (**Ops**)
    in order to facilitate expedited and more frequently issued software releases.
    This software development strategy combines communication, automation, and analysis.
    The DevOps methodology places emphasis on the delivery of software that aligns
    with business objectives and meets customer requirements. This is achieved through
    the utilization of rapid feedback loops, pertinent **key performance indicators**
    (**KPIs**), and an iterative development strategy. While DevOps does include planning,
    design, coding, testing, and deployment, a hallmark of this model is how it incorporates
    continuous integration, continuous delivery, continuous testing, and continuous
    monitoring into the SDLC. The following diagram depicts the DevOps model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8: The DevOps release management model](img/B21803_03_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.8: The DevOps release management model'
  prefs: []
  type: TYPE_NORMAL
- en: Release management relies heavily on precise reporting in order to keep tabs
    on needs, risks, and obstacles. It also guarantees that the project’s initial
    goals and objectives will be met all the way through the software development
    life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: The adoption of DevOps principles inherently results in an improved release
    management framework, which in turn produces industry-standard procedures for
    effective collaboration and testing at every stage of the delivery life cycle.
    People have a tendency to focus on automation as the most important value in DevOps;
    nevertheless, automation should always be focused on boosting the productivity
    of your people. As people work to improve operational efficiency and minimize
    the impact of human mistakes, they will inevitably start releasing reliable services
    with greater velocity.
  prefs: []
  type: TYPE_NORMAL
- en: The integration of release management within the DevOps culture enables firms
    to attain expedited, dependable, and successful software releases. Ultimately,
    this phenomenon serves to boost consumer happiness, build fellowship within development
    teams, and accelerate the expansion of businesses.
  prefs: []
  type: TYPE_NORMAL
- en: DevOps and release management share an affinity with regard to software development,
    project management, and IT operations. DevOps release management encompasses activities
    involved in overseeing the design, planning, scheduling, testing, and implementation
    of the software release and delivery cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Organizations that have implemented modifications to a product at least once
    have a solid understanding of the crucial role of release management within the
    context of DevOps. When executed correctly, the implementation of this strategy
    has the potential to enhance the efficiency of development, testing, and operational
    processes. In addition, this release management strategy effectively reduces expenses
    associated with rework, enhances collaborative efforts, and facilitates the successful
    delivery of goods of superior quality.
  prefs: []
  type: TYPE_NORMAL
- en: This elevates the organization’s oversight of all phases of the release process,
    spanning from the initial development to final delivery. The use of DevOps release
    management is now the contemporary standard for when a new product is being launched
    or a modification is being introduced. The DevOps processes may vary slightly
    depending on a given team, their preferred practices, and the objectives of the
    organization.
  prefs: []
  type: TYPE_NORMAL
- en: By embracing DevOps release management, software development teams benefit from
    incorporating quality checks and shifting left and by carrying out testing, automation,
    and QA procedures much earlier in the software delivery life cycle. Due to its
    usefulness in removing silos that isolate team members, DevOps release management
    is emerging as the most popular release management strategy currently being adopted.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have reached the end of this chapter. By this point, we have discussed the
    eight most common release management models in the IT industry. They are the ITIL,
    waterfall, iterative, V-shaped, spiral, big bang, agile, and DevOps models. You
    should now understand the various benefits and drawbacks of each release management
    model and feel confident about selecting the right one for your project. Moreover,
    you have been exposed to the amazing benefits that DevOps offers over the previous
    release management models that came before it. As a result, you have a working
    knowledge of the history of release management and can draw well-informed conclusions
    about how each model evolved beyond the next.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes [*Chapter 3*](B21803_03.xhtml#_idTextAnchor051). In the next
    chapter, we are going to learn about what makes DevOps release management unique.
    This is important to know because we are going to shift our focus to the DevOps
    Release Management Model for the remainder of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Why does the ITIL release management model have more to do with the systems
    development life cycle than the software development life cycle?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What was the very first standard release management model?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the three steps in the iterative and incremental release management
    model?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What direction does the progression of time and development travel in the V-shaped
    release management model?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the defining feature of the spiral release management model?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the three key ingredients that the big bang release management model
    requires in order to begin a new project?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the motto of the agile release management model with regard to testing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the defining feature of the DevOps release management model?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When is it acceptable to backtrack and move to previous phases of the waterfall
    release management model?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In what phase of the DevOps release management model does testing occur?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Part 2: The Advantages of DevOps Release Management'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this second section of the book, we’ll begin by learning what problems DevOps
    Release Management tries to solve. From there, we will learn what makes DevOps
    Release Management Unique. Then, we’ll get an understanding of the basics of CI/CD,
    the heart of a DevOps-based value stream. Finally, we’ll explore how CI/CD pipelines
    enforce good DevOps Release Management. The goal of this section is to underscore
    the hallmarks of DevOps Release Management so that you have the foundational knowledge
    needed before advancing further and becoming a seasoned DevOps leader and tactician.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B21803_04.xhtml#_idTextAnchor066), *What Problems Does DevOps
    Release Management Try to Solve?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B21803_05.xhtml#_idTextAnchor078), *Understanding What Makes
    DevOps Release Management Unique*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B21803_06.xhtml#_idTextAnchor095), *Understanding the Basics
    of CI/CD*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B21803_07.xhtml#_idTextAnchor120), *A Practical Pipeline for
    Technical Release Managers*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B21803_08.xhtml#_idTextAnchor141), *How CI/CD Pipelines Enforce
    Good DevOps Release Management*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
