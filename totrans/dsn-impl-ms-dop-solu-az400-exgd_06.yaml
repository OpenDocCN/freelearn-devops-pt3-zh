- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Implementing Continuous Deployment and Release Management
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现持续部署和发布管理
- en: In the previous chapter, you learned how to use Azure DevOps pipelines for continuous
    integration. Due to this, you now know how to pick up a version of your sources
    and create artifacts that you can deploy. In this chapter, you will learn how
    to extend this with continuous delivery and continuous deployment practices so
    that you automatically deploy these artifacts to the servers or platforms that
    your code is running on.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，你学习了如何使用 Azure DevOps 管道进行持续集成。因此，你现在知道如何获取源代码的一个版本，并创建你可以部署的工件。在本章中，你将学习如何扩展这些技术，结合持续交付和持续部署实践，从而自动将这些工件部署到你的代码运行的服务器或平台上。
- en: To do this, we will start by introducing Azure DevOps release definitions so
    that you can define and run the releases of your application. Next, a series of
    strategies will be introduced that you can use to perform deployments in a low-risk
    manner. Doing this makes it possible for you to automate the process of deploying
    new versions unattended, with a limited risk of incidents occurring. From here,
    we will shift our attention to automating the creation of release notes. After
    this, we will introduce Visual Studio App Center, which is used for building,
    testing, and releasing mobile and desktop applications. Finally, other tools for
    continuous deployment will be introduced.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们将从介绍 Azure DevOps 发布定义开始，这样你就可以定义并运行你的应用程序发布。接下来，将介绍一系列策略，你可以使用这些策略以低风险的方式执行部署。这样做使得你能够自动化部署新版本的过程，且在事件发生的风险最小的情况下进行无人值守的部署。从这里，我们将转向自动化创建发布说明的过程。之后，我们将介绍
    Visual Studio App Center，它用于构建、测试和发布移动和桌面应用程序。最后，还将介绍其他持续部署工具。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Continuous delivery and continuous deployment
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续交付与持续部署
- en: Working with Azure DevOps releases
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Azure DevOps 发布
- en: Writing multi-stage **Yet Another Markup Language** (**YAML**) pipelines
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写多阶段的**另一种标记语言**（**YAML**）管道
- en: Implementing continuous deployment strategies
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现持续部署策略
- en: Deploying mobile applications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署移动应用程序
- en: Automating release notes
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化发布说明
- en: Other tools
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他工具
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To experiment with the techniques described in this chapter, you might need
    one or more of the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尝试本章所描述的技术，你可能需要以下一项或多项：
- en: An Azure DevOps account for building release definitions and multi-stage YAML
    pipelines
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于构建发布定义和多阶段 YAML 管道的 Azure DevOps 账户
- en: An App Center account for deploying mobile applications
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于部署移动应用程序的 App Center 账户
- en: Free trial options are available for both of these.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这两者都提供免费试用选项。
- en: Continuous delivery and continuous deployment
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续交付与持续部署
- en: The difference between continuous delivery and continuous deployment is a common
    source of confusion. Some people think these terms are interchangeable and see
    them as two synonyms for the same concept, but they have, in fact, two different
    meanings.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 持续交付和持续部署之间的区别是一个常见的混淆来源。一些人认为这些术语可以互换，并将它们视为同一个概念的两个同义词，但它们实际上有两个不同的含义。
- en: Continuous delivery is a practice where teams ensure that the artifacts they
    build are continuously validated and ready to be deployed to a production environment.
    Often, this is done by deploying the artifacts to a production-like environment,
    such as acceptance or even a staging environment, and applying a series of tests,
    such as verification tests, to ensure that an application is working correctly.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 持续交付是一种实践，团队确保他们构建的工件被持续验证并随时准备部署到生产环境中。通常，这通过将工件部署到类似生产环境的环境中（例如验收环境或甚至预发布环境），并应用一系列测试（如验证测试）来确保应用程序正常工作。
- en: Continuous deployment is a practice where every version that is deployed to
    a production-like environment and passes all tests and verifications is also deployed
    to production automatically.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 持续部署是一种实践，任何部署到类似生产环境并通过所有测试和验证的版本都会自动部署到生产环境中。
- en: It is a recommended practice to plan for continuous delivery irrespective of
    whether your team decides to deploy more frequently or not. Deployment and upgrades
    are dependent on multiple factors, which may change over time. Hence, continuous
    delivery will be a prerequisite for faster release cycles.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您的团队是否决定更频繁地部署，都建议计划进行持续交付。部署和升级取决于多个因素，这些因素可能随时间而变化。因此，持续交付将成为更快发布周期的先决条件。
- en: When working with Azure DevOps, Azure Pipelines is the tool of choice for implementing
    continuous delivery and deployment. This can be done using either the visual classic
    editor or with multi-stage YAML pipelines, both of which will be discussed in
    the following section.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Azure DevOps 时，Azure Pipelines 是实现持续交付和部署的首选工具。可以使用视觉经典编辑器或多阶段 YAML 管道来完成这一操作，这两者将在以下部分讨论。
- en: Working with Azure DevOps releases
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Azure DevOps 发布
- en: Continuous delivery and deployment can both be implemented in Azure DevOps by
    using releases. When creating a new release definition, an outline of the release
    process is created. This process will often start with an artifact that triggers
    the creation of a new release. Next, it is possible to define one or more stages
    that the release can be deployed to. Often, these stages correspond to the different
    application environments – for example, test and production – but this is not
    mandatory.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用发布来在 Azure DevOps 中实现持续交付和部署。创建新的发布定义时，将创建发布过程的大纲。此过程通常从触发新发布的工件开始。接下来，可以定义一个或多个阶段，可以将发布部署到这些阶段。通常，这些阶段对应于不同的应用程序环境，例如测试和生产，但这不是强制的。
- en: 'Let’s learn how to create a new release definition and explore the various
    options we have. First, navigate to **Pipelines** and choose **Releases** from
    the menu. From here, it is possible to start creating a new release pipeline,
    which will take us to a screen that looks similar to the one shown in the following
    screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何创建一个新的发布定义并探索我们拥有的各种选项。首先，导航到**管道**并从菜单中选择**发布**。从这里，可以开始创建一个新的发布管道，这将带我们到一个看起来类似以下截图的屏幕：
- en: '![Figure 6.1 – New release pipeline ](img/B18655_06_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.1 – 新发布管道](img/B18655_06_01.jpg)'
- en: Figure 6.1 – New release pipeline
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 新发布管道
- en: 'On the preceding screen, we can perform the following actions (which are numbered
    in the preceding screenshot):'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个屏幕上，我们可以执行以下操作（在上述屏幕截图中编号）：
- en: First, note that, on the left, it is possible to see the outline of the release
    pipeline with a box. Here, you can select one or more artifacts that can be used
    in the release pipeline.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，请注意，左侧可以看到发布管道的大纲和一个框。在这里，您可以选择一个或多个可用于发布管道的工件。
- en: To the right of this, there is a box where the different stages of the release
    can be seen. By default, one stage is created already.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧，可以看到一个框，其中显示了发布的不同阶段。默认情况下，已经创建了一个阶段。
- en: It is possible to pick a template as a starting point for the deployment pipeline
    for this pre-created stage. Choosing to start with an empty job in this view allows
    you to craft a custom deployment pipeline from scratch.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以选择一个模板作为此预创建阶段的部署管道的起点。在此视图中选择从空作业开始，可以从头开始创建自定义部署管道。
- en: After choosing a job template or an empty job to start with, the pane on the
    right will close, and it will be possible to start editing the release pipeline
    from left to right, starting with the artifacts.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择作业模板或从空作业开始之后，右侧的窗格将关闭，并且可以从左到右开始编辑发布管道，从工件开始。
- en: Once a skeleton release pipeline is visible, the first things you will need
    to configure are the artifacts that the release should work with. This is the
    subject of the next section.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦看到一个基本的发布管道框架，您需要配置的第一件事是发布应该使用的工件。这是下一部分的主题。
- en: Creating artifacts and release triggers
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建工件和发布触发器
- en: The previous chapter described build definitions and YAML pipelines, which create
    artifacts. These artifacts are picked up in releases and form the basis for deploying
    an application.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前一章描述了构建定义和 YAML 管道，这些管道创建了工件。这些工件在发布中被接收，并形成部署应用程序的基础。
- en: 'To start editing a release pipeline, follow these steps:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始编辑发布管道，请按照以下步骤操作：
- en: 'Click on the **Add an artifact** button to start building the starting point
    of the release definition. This will open the right-hand pane shown in the following
    screenshot:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加构件**按钮以开始构建发布定义的起点。这将打开右侧窗格，如下图所示：
- en: '![Figure 6.2 – Add an artifact ](img/B18655_06_02.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – 添加构件 ](img/B18655_06_02.jpg)'
- en: Figure 6.2 – Add an artifact
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 添加构件
- en: In the picker for the project, the current project will be selected by default.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目选择器中，当前项目将默认被选中。
- en: Now, specify the artifacts that the release pipeline should pick up.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，指定发布管道应获取的构件。
- en: After this, the default version to use and the source alias will be automatically
    selected. The default version can always be overridden when manually starting
    a release, so **Latest** is a sensible default.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此后，默认使用的版本和源别名将自动选择。默认版本可以在手动启动发布时覆盖，因此**最新**是一个合理的默认选项。
- en: The source alias is the name of the folder where the artifacts can be located
    when we add jobs to the release stages at a later date. The default is often fine.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 源别名是我们稍后在发布阶段添加任务时，构件所在文件夹的名称。默认设置通常可以使用。
- en: Finish adding the artifact by clicking **Add**.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**添加**完成构件的添加。
- en: 'Now that we’ve specified the artifacts to work with, it is time to specify
    when a new release should be created. Let’s learn how to do this:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经指定了要使用的构件，是时候指定何时创建新发布了。让我们学习如何做到这一点：
- en: 'To configure the availability of a new artifact to trigger the release, click
    on the lightning bolt next to the artifact to open the configuration pane. This
    can be seen in the following screenshot:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 若要配置新构件的可用性以触发发布，点击构件旁边的闪电符号以打开配置窗格。这可以在以下截图中看到：
- en: '![Figure 6.3 – Specifying a deployment trigger  ](img/B18655_06_03.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – 指定部署触发器  ](img/B18655_06_03.jpg)'
- en: Figure 6.3 – Specifying a deployment trigger
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 指定部署触发器
- en: In this pane, it is possible to create a new release, when one is available,
    using the top slider. This will expand a new section where you can define one
    or more filters so that you can specify conditions under which a new artifact
    should trigger a release.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此窗格中，可以使用顶部滑块创建新的发布，当发布可用时。这将展开一个新部分，您可以在其中定义一个或多个过滤器，以便指定在何种条件下新构件应触发发布。
- en: Click the **Add** button to start adding a condition.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加**按钮以开始添加条件。
- en: A common example is to only include artifacts that come from the master branch,
    as shown in *Figure 6.3*.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个常见的示例是仅包含来自主分支的构件，如*图6.3*所示。
- en: In addition to artifacts that come from regular builds, it is possible to also
    allow artifacts that come from pull request builds to start a new release.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了来自常规构建的构件外，还可以允许来自拉取请求构建的构件启动新发布。
- en: Finally, it is possible to create a new release on a fixed schedule.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，可以按固定计划创建一个新的发布。
- en: If no schedule and no trigger are specified, a new release will only be created
    when someone does so manually.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有指定计划和触发器，则新发布仅在有人手动操作时创建。
- en: Specifying the stages to deploy the release
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指定要部署发布的阶段
- en: After specifying the artifacts to release, it is time to specify one or more
    stages to deploy the release to. Often, every environment (test, acceptance, and
    production) will correspond to a stage, but it is also possible to have other
    stages if the situation calls for it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定了要发布的构件后，是时候指定一个或多个阶段来部署发布了。通常，每个环境（测试、验收和生产）将对应一个阶段，但如果情况需要，也可以有其他阶段。
- en: 'Let’s learn how to add a new stage and explore various options. First, click
    on **Pipelines** to arrive at the following screen:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们学习如何添加新阶段并探索各种选项。首先，点击**管道**，进入如下屏幕：
- en: '![Figure 6.4 – Configuring a stage within a new pipeline ](img/B18655_06_04.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![图6.4 – 在新管道中配置阶段 ](img/B18655_06_04.jpg)'
- en: Figure 6.4 – Configuring a stage within a new pipeline
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 在新管道中配置阶段
- en: 'Now, complete the following steps:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，完成以下步骤：
- en: Click the **Add** button to create a new stage. A stage can be either new or
    a clone of an existing one.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加**按钮以创建新阶段。一个阶段可以是新的，也可以是现有阶段的克隆。
- en: After selecting an already existing stage, it can be removed using the **Delete**
    button on the top right.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择已存在的阶段后，可以通过右上角的**删除**按钮将其移除。
- en: Other actions that can be performed on this screen include renaming the stage
    and designating a stage owner. The owner will be notified when a release is deployed
    to the environment.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此页面上，还可以执行其他操作，包括重命名阶段和指定阶段所有者。每当发布部署到环境中时，所有者将会收到通知。
- en: After creating and naming a stage, it is possible to add jobs and tasks to a
    stage, just like it was possible for a build pipeline. To do this, click on the
    link in the box that denotes the stage.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建并命名一个阶段后，可以像在构建流水线中一样，向该阶段添加作业和任务。为此，请点击表示该阶段的框中的链接。
- en: 'From here on, this works exactly the same as building pipelines. There is only
    one addition: besides agent jobs and agentless jobs, it is also possible to use
    deployment group jobs.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从这里开始，它与构建流水线的操作完全相同。唯一的区别是：除了代理作业和无代理作业，还可以使用部署组作业。
- en: These will be discussed in the *Working with deployment groups* section later
    on. But first, let’s understand which stages we need.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些将在稍后的*与部署组一起工作*部分进行讨论。但首先，让我们了解一下我们需要哪些阶段。
- en: Which stages do I need?
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 我需要哪些阶段？
- en: One of the questions that frequently arise when working with releases is, *which
    stages do I need in my release pipeline?* According to the documentation, stages
    should denote the major divisions of a release pipeline. When starting out with
    releases, this often boils down to having one stage per environment in a release
    pipeline. Appropriate stages include **test**, **acceptance**, and **production**.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理发布时，常见的一个问题是，*我在发布流水线中需要哪些阶段？* 根据文档，阶段应该表示发布流水线中的主要分区。在开始处理发布时，这通常简化为每个环境在发布流水线中都有一个阶段。适当的阶段包括**测试**、**验收**和**生产**。
- en: When working with releases for a long time, we might incorporate more automation
    in the pipelines and want to add extra checking stages to them. An example might
    be a stage called **load test**, which is executed in parallel to the **test**
    stage. Another example might be the introduction of a stage for **automated UI
    tests**.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在长时间处理发布的过程中，我们可能会在流水线中加入更多自动化，并希望为其添加额外的检查阶段。例如，可能会有一个叫做**负载测试**的阶段，与**测试**阶段并行执行。另一个例子可能是引入一个用于**自动化UI测试**的阶段。
- en: No matter which stages are added, the approach to propagating a release to production
    should always stay the same. When a release propagates from stage to stage and
    gets closer to production, this should show that there is confidence in this release,
    that it is working correctly, and that it can be promoted to production.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 无论添加了哪些阶段，发布到生产的传播方式始终应保持一致。当发布从一个阶段传播到另一个阶段，并且越来越接近生产时，这应表明对该发布有信心，证明它正在正确工作，并且可以推广到生产环境。
- en: Stage triggers, approvals, and gates
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 阶段触发器、审批和门控
- en: 'After defining the required stages and adding jobs and tasks to them, it is
    time to configure when the release to a specific stage should be triggered. The
    steps for this can be seen in the following screenshot:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义所需阶段并向其添加作业和任务之后，接下来是配置何时触发发布到特定阶段。此步骤可以在以下屏幕截图中看到：
- en: '![Figure 6.5 – Post-deployment configuration ](img/B18655_06_05.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5 – 部署后配置](img/B18655_06_05.jpg)'
- en: Figure 6.5 – Post-deployment configuration
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – 部署后配置
- en: 'Note that the following steps need to be carried out for every stage individually:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，以下步骤需要为每个阶段单独执行：
- en: To trigger a release to a specific stage, click on the button with a lightning
    bolt and a person icon, to the left of the square that denotes the stage.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要触发发布到特定阶段，请点击位于表示该阶段的方块左侧，带有闪电符号和人形图标的按钮。
- en: The first thing to configure here is when a release should propagate to this
    stage. This can be either upon the availability of the release, after completing
    another stage, or only upon manual request. The choice you make here will also
    be reflected in the visual representation of the pipeline.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里配置的第一件事是何时将发布传播到此阶段。可以在发布可用时、在完成另一个阶段后，或仅在手动请求时进行选择。您在此处做出的选择也将反映在流水线的视觉表示中。
- en: Separate from the trigger, it is possible to define one or more filters that
    limit which artifacts will trigger a deployment to the stage. There can be one
    or more include or exclude branch filters for every artifact.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与触发器分开，您还可以定义一个或多个过滤器，以限制哪些工件将触发对该阶段的部署。每个工件可以有一个或多个包括或排除分支过滤器。
- en: It is also possible to redeploy on a fixed schedule.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 也可以按固定计划重新部署。
- en: Finally, if the creation of a new release is specified for builds that were
    started from a pull request, the release can also be allowed to propagate to the
    current stage using the **Pull request deployment** slider.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，如果为从拉取请求启动的构建指定了创建新发布，则可以使用**拉取请求部署**滑块允许该发布传播到当前阶段。
- en: 'Next to these triggers, approvers and gates can be added so that you can configure
    how to handle deployment queue settings. These settings can be accessed from the
    tabs below the section for **Triggers**, as shown in the following screenshot:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些触发器旁边，可以添加审批者和门控，以便你可以配置如何处理部署队列设置。这些设置可以通过下面的**触发器**选项卡访问，如下图所示：
- en: '![Figure 6.6 – Pre-deployment conditions  ](img/B18655_06_06.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.6 – 部署前条件](img/B18655_06_06.jpg)'
- en: Figure 6.6 – Pre-deployment conditions
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – 部署前条件
- en: 'Once the trigger condition has been configured, the next section is about approvers.
    Here, groups or users are specified. They must give their approval before release
    to this stage can begin. Multiple people can be added, and if so, an order can
    be defined that they have to approve, or it can be specified that a single approval
    is enough. By scrolling down, you will find the following options:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦触发条件被配置，接下来的部分是关于审批者的。在这里，指定了组或用户。在发布到此阶段之前，他们必须给予批准。可以添加多个人，如果是这样，可以定义他们必须批准的顺序，或者可以指定一个批准就足够。向下滚动，你会看到以下选项：
- en: '![Figure 6.7 – Deployment gates ](img/B18655_06_07.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.7 – 部署门控](img/B18655_06_07.jpg)'
- en: Figure 6.7 – Deployment gates
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 – 部署门控
- en: The second tab (on the left) allows you to add one or more gates. Gates are
    automated checks that have to succeed before the release can continue. Currently,
    this shows the configuration details for configuring a work item query and a threshold
    on the number of results – for example, to ensure that there are no open bugs
    before a release proceeds. There are also gates available that can call in Azure
    Monitor, Azure Functions, or a RESTful API. This set of gates can be extended
    using the Azure DevOps extension mechanisms. Some of these extensions also integrate
    with common change management systems.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选项卡（左侧）允许你添加一个或多个门控。门控是必须成功的自动化检查，才能继续发布。目前，这显示了配置工作项查询和结果数量阈值的配置细节——例如，确保在发布继续之前没有未解决的错误。也有可用的门控，可以调用
    Azure Monitor、Azure Functions 或 RESTful API。此套门控可以通过 Azure DevOps 扩展机制进行扩展。这些扩展中的一些还与常见的变更管理系统集成。
- en: The final section (on the right) allows you to configure how to handle a situation
    where different versions of the release are ready for deployment to the same stage.
    Here, it is possible to specify how many releases can run in parallel. If there
    are even more releases coming in, you can queue them up and deploy them one after
    the other, or only deploy the latest.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分（右侧）允许你配置如何处理不同版本的发布准备部署到同一阶段的情况。在这里，可以指定可以并行运行多少个发布。如果有更多的发布到来，你可以将它们排队并一个接一个地部署，或者只部署最新的版本。
- en: Working with deployment groups
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用部署组
- en: Another topic that you might run into at some point is deploying an application
    to on-premises servers or servers that are behind a firewall. You may also come
    across situations where it is necessary to run scripts on all of the machines
    hosting the application or situations where the target environment does not supply
    a mechanism for deploying applications.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个你可能会遇到的话题是将应用程序部署到本地服务器或位于防火墙后的服务器。你还可能会遇到需要在所有托管应用程序的机器上运行脚本的情况，或目标环境没有提供部署应用程序的机制的情况。
- en: The approach to performing releases, which was shown in the *Working with Azure
    DevOps releases* section of this chapter, relies on being able to connect to the
    target machines or services that will host the application. We call these **push-based
    deployments**, and this is not always possible.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中“*与 Azure DevOps 发布工作*”部分展示的发布方式依赖于能够连接到将托管应用程序的目标机器或服务。我们称之为**推送式部署**，但并非总是可以做到这一点。
- en: When deploying to target machines that cannot be connected to, another approach
    needs to be taken. This approach is called **agent-based deployment**. In an agent-based
    deployment, an Azure DevOps agent is installed on every machine that the application
    will be installed on. Next, these agents must be grouped into deployment groups.
    Once this is done, a **deployment group job** can be added to the release.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当部署到无法连接的目标机器时，需要采取另一种方法。这种方法称为**基于代理的部署**。在基于代理的部署中，Azure DevOps 代理将安装在每台需要部署应用程序的机器上。接下来，这些代理必须被分组到部署组中。一旦完成这一操作，就可以向发布中添加**部署组作业**。
- en: 'This is very similar to an agent’s job, except for one thing. In an agent job,
    the tasks in the job will run on **one of the agents** against the target machine.
    In a deployment group job, all of the tasks will run on all of the agents in the
    release group on the target machines. This difference between both approaches
    can be seen in the following diagram:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这与代理作业非常相似，只有一处不同。在代理作业中，作业中的任务将在**其中一台代理**上执行，目标机器上。 在部署组作业中，所有任务将在目标机器上的发布组中所有代理上执行。下图展示了两者方法之间的区别：
- en: '![Figure 6.8 – Jobs are run on an agent ](img/B18655_06_08.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.8 – 作业在代理上运行](img/B18655_06_08.jpg)'
- en: Figure 6.8 – Jobs are run on an agent
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.8 – 作业在代理上运行
- en: When using this approach, it is necessary to have agents on the machines that
    the application needs to be deployed to. These agents listen to Azure DevOps,
    and whenever a new release is requested, they retrieve the work and execute it
    on the local machine.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此方法时，必须在应用程序需要部署到的机器上安装代理。这些代理监听 Azure DevOps，并在有新的发布请求时，它们会获取工作并在本地机器上执行。
- en: Managing deployment groups
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理部署组
- en: 'Before you can add a deployment group job to a release pipeline, you need to
    create a deployment group. To do so, perform the following steps:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在您可以向发布流水线中添加部署组作业之前，您需要创建一个部署组。为此，请执行以下步骤：
- en: Navigate to the **Pipelines** menu.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**流水线**菜单。
- en: Open the **Deployment groups** menu.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**部署组**菜单。
- en: Click on **New** to add a new deployment group.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**新建**以添加新的部署组。
- en: Enter a deployment group name and description and click **Create**.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入部署组名称和描述，然后点击**创建**。
- en: 'Once the new deployment group has been created, a script will appear on the
    right, as shown in the following screenshot:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了新的部署组，右侧会出现一个脚本，如下图所示：
- en: '![Figure 6.9 – Creating a new deployment group ](img/B18655_06_09.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.9 – 创建新部署组](img/B18655_06_09.jpg)'
- en: Figure 6.9 – Creating a new deployment group
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.9 – 创建新部署组
- en: Executing this script on the target machine will install the agent and automatically
    register that machine as part of the newly created deployment group.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在目标机器上执行此脚本将安装代理，并自动将该机器注册为新创建的部署组的一部分。
- en: If an application must be deployed to three stages (test, acceptance, and production)
    using deployment groups, there will need to be three separate deployment groups,
    one for each environment.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果必须使用部署组将应用程序部署到三个阶段（测试、验收和生产），则需要为每个环境创建三个单独的部署组。
- en: Creating a release pipeline with a deployment group
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建带有部署组的发布流水线
- en: 'After creating the necessary deployment group(s), those can be used in releases
    from the **Tasks** view, as shown in the following screenshot:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 创建所需的部署组后，可以在**任务**视图中使用它们进行发布，如下图所示：
- en: '![Figure 6.10 – Specifying the deployment group in the pipeline ](img/B18655_06_10.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.10 – 在流水线中指定部署组](img/B18655_06_10.jpg)'
- en: Figure 6.10 – Specifying the deployment group in the pipeline
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.10 – 在流水线中指定部署组
- en: 'To do this, perform the following steps:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，请执行以下步骤：
- en: Add a new deployment group to the pipeline.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向流水线中添加一个新的部署组。
- en: Specify which deployment group the job should run on by picking it from the
    drop-down menu.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从下拉菜单中选择，指定作业应在哪个部署组上运行。
- en: Add one or more tasks to execute the job. The functionality of the user interface
    is the same as that for regular agent jobs.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个或多个任务以执行作业。用户界面的功能与常规代理作业相同。
- en: Besides the different approaches to executing on all agents in a group instead
    of one, deployment group jobs behave the same as regular agent jobs.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在一组中对所有代理执行作业的不同方法外，部署组作业与常规代理作业的行为相同。
- en: Writing multi-stage YAML pipelines
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写多阶段 YAML 流水线
- en: In addition to the visual designer for release definitions, it is also possible
    to implement continuous deployment using YAML pipelines. When doing so, it is
    still recommended to differentiate between the build (**Continuous Integration**
    (**CI**)) and release (**Continuous Deployment** (**CD**)) phases of a pipeline.
    The concept of stages is used to make this possible. A YAML pipeline can be divided
    into one or more stages. A stage can represent an environment such as test, acceptance,
    or production, but this isn’t always true. If, in an application scenario, it
    makes sense to add extra stages such as pre-production or staging, you can include
    additional stages as applicable. It is good practice to publish **pipeline artifacts**
    in earlier stages and to consume or **download artifacts** in later stages.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可视化设计器用于发布定义外，还可以使用 YAML 流水线实现持续部署。进行此操作时，仍建议区分流水线中的构建（**持续集成** (**CI**)）和发布（**持续部署**
    (**CD**)）阶段。阶段的概念用于使这一目标成为可能。一个 YAML 流水线可以分为一个或多个阶段。一个阶段可以代表一个环境，如测试、验收或生产，但这并不总是成立。如果在应用场景中，有必要增加额外的阶段，如预生产或暂存阶段，你可以根据需要添加额外的阶段。一个好的实践是，在早期阶段发布
    **流水线工件**，并在后续阶段使用或 **下载工件**。
- en: Multi-stage YAML pipelines are the new default for creating pipelines in Azure
    DevOps. Since working with YAML pipelines can have a steeper learning curve than
    working with classic releases, you may find it easier to work with classic releases
    first and switch to YAML pipelines later. Just like with builds, many of the concepts
    of classic releases translate to multi-stage YAML pipelines as well.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 多阶段 YAML 流水线是 Azure DevOps 中创建流水线的默认方式。由于使用 YAML 流水线的学习曲线可能比经典发布更陡峭，你可能会发现先使用经典发布再转向
    YAML 流水线更容易。与构建一样，经典发布的许多概念也可以转化为多阶段 YAML 流水线。
- en: Adding stages to YAML pipelines
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向 YAML 流水线添加阶段
- en: 'If no stages are defined in a YAML pipeline, there is always one implicit stage
    that holds all the jobs. To convert a pipeline into a multi-stage pipeline, you
    need to add the `stages` keyword and a list of stages, as shown in the following
    code:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 YAML 流水线中没有定义任何阶段，则总会有一个隐式阶段来容纳所有作业。要将流水线转换为多阶段流水线，你需要添加 `stages` 关键字和阶段列表，如下代码所示：
- en: '[PRE0]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding syntax shows that a list of stages is defined at the top of the
    YAML file. Each stage starts by defining a name. This name can be used later so
    that you can refer to this stage.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 上述语法显示了在 YAML 文件的顶部定义了一个阶段列表。每个阶段从定义一个名称开始。这个名称可以在后续使用，方便你引用该阶段。
- en: While jobs (unless otherwise specified) run in parallel by default, stages always
    run sequentially by default. But just like jobs, stages accept the `dependsOn`
    and `condition` keywords to change the ordering and parallelism, and (potentially)
    to skip stages.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然作业（除非另有说明）默认是并行运行的，但阶段默认是顺序运行的。与作业类似，阶段也接受 `dependsOn` 和 `condition` 关键字，用于改变执行顺序和并行度，甚至（可能）跳过某些阶段。
- en: Downloading artifacts
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下载工件
- en: A common use of multi-stage pipelines is to separate the build stage and the
    deployment stage. To make this possible, the build stage often publishes one or
    more pipeline artifacts. This was discussed in [*Chapter 5*](B18655_05.xhtml#_idTextAnchor177),
    *Moving to Continuous Integration*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 多阶段流水线的常见用途是将构建阶段与部署阶段分开。为了实现这一点，构建阶段通常会发布一个或多个流水线工件。在 [*第 5 章*](B18655_05.xhtml#_idTextAnchor177)
    中已经讨论过，*转向持续集成*。
- en: 'All the artifacts that were published in a previous stage of the current pipeline
    can be downloaded using a `download` task:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当前流水线中前一个阶段发布的所有工件，可以通过 `download` 任务下载：
- en: '[PRE1]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It is also possible to download artifacts from another pipeline. To do this,
    the `current` constant has to be replaced with the name of that pipeline. Pipeline
    artifacts are downloaded to the `$(Pipeline.Workspace)` directory.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以从另一个流水线下载工件。为此，必须将 `current` 常量替换为该流水线的名称。流水线工件将被下载到 `$(Pipeline.Workspace)`
    目录。
- en: Tip
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If you want more fine-grained control over downloading pipeline artifacts –
    for example, over the version of the artifact to use or the location to download
    the artifact to – you can also use the **Download Pipeline Artifacts** tasks,
    which are documented at [https://docs.microsoft.com/bs-cyrl-ba/azure/devops/pipelines/tasks/utility/download-pipeline-artifact?view=azure-devops](https://docs.microsoft.com/bs-cyrl-ba/azure/devops/pipelines/tasks/utility/download-pipeline-artifact?view=azure-devops).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望对下载管道工件有更精细的控制——例如，控制使用的工件版本或下载工件的位置——你还可以使用**下载管道工件**任务，相关文档可以参考[https://docs.microsoft.com/bs-cyrl-ba/azure/devops/pipelines/tasks/utility/download-pipeline-artifact?view=azure-devops](https://docs.microsoft.com/bs-cyrl-ba/azure/devops/pipelines/tasks/utility/download-pipeline-artifact?view=azure-devops)。
- en: Publishing and downloading artifacts within a pipeline ensures that code that
    is built in the first stage is also the code that is deployed in the second stage
    – even if the stages run days apart. In essence, each pipeline run builds a local
    stage of all the artifacts associated with that specific run.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在管道中发布和下载工件可以确保在第一阶段构建的代码也是在第二阶段部署的代码——即使各阶段之间间隔几天。本质上，每次管道运行都会构建与该特定运行相关的所有工件的本地阶段。
- en: Approvals
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 审批
- en: In a multi-stage YAML pipeline, it is not possible to define approvers as compared
    to what was possible when creating a classic release pipeline. The reason for
    this is that the pipeline – *the build and deployment process* – is viewed as
    code. Code is worked on by developers and operators only. Approvals are worked
    on by, for example, product owners. However, this does not mean that it is impossible
    to implement approval flows for the progression of a pipeline to the next stage.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在多阶段 YAML 管道中，无法像创建经典发布管道时那样定义审批者。原因在于，管道——*构建和部署过程*——被视为代码。代码只由开发人员和运维人员处理。而审批则是由例如产品负责人来处理。然而，这并不意味着无法为管道的推进到下一个阶段实现审批流程。
- en: To control whether a pipeline is allowed to proceed to a certain stage, the
    concept of environments needs to be introduced. An environment is defined when
    we give it a name and a description. One or more approvers can be attached to
    these environments. Once this is done, jobs can be configured to target such an
    environment. If there is at least one job in a stage that targets an environment,
    then that environment is said to be used by the stage. If an approval has been
    configured on that environment, the deployment to that stage will not continue
    until the approver has given permission.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制管道是否允许继续到某个阶段，需要引入环境的概念。环境在我们为其指定名称和描述时定义。可以将一个或多个审批者附加到这些环境。一旦完成，作业就可以配置为针对该环境。如果一个阶段中至少有一个作业针对某个环境，那么该环境就被认为是该阶段使用的环境。如果该环境已配置审批，则在审批者给予许可之前，部署将无法继续到该阶段。
- en: 'To start working with environments, you’ll need to access the list of environments.
    This list can be found in the **Pipelines** menu, as shown in the following screenshot:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始使用环境，你需要访问环境列表。该列表可以在**管道**菜单中找到，如下图所示：
- en: '![Figure 6.11 – Adding a new environment ](img/B18655_06_11.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.11 – 添加新环境](img/B18655_06_11.jpg)'
- en: Figure 6.11 – Adding a new environment
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.11 – 添加新环境
- en: 'To add a new environment, perform the following steps:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加新环境，请执行以下步骤：
- en: Open the **Pipelines** menu and choose **Environments**.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**管道**菜单并选择**环境**。
- en: Select **New environment** from the top right.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从右上角选择**新建环境**。
- en: Specify a name and description.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定名称和描述。
- en: Click **Create**.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**创建**。
- en: 'It is possible to associate resources with an environment. Resources that are
    coupled with an environment can be used in a pipeline if, and only if, that pipeline
    is also targeting that environment. To protect the resources of an environment,
    the owner of that environment can add one or more approvers. An example of a configured
    approver can be seen in the following screenshot:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将资源与环境关联。与环境耦合的资源可以在管道中使用，但前提是该管道也针对该环境。为了保护环境的资源，环境的所有者可以添加一个或多个审批者。下面的截图中展示了一个配置的审批者示例：
- en: '![Figure 6.12 – Configuring approvers for the environment ](img/B18655_06_12.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.12 – 配置环境的审批者](img/B18655_06_12.jpg)'
- en: Figure 6.12 – Configuring approvers for the environment
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.12 – 配置环境的审批者
- en: 'Approvers can be added to an environment as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过以下方式向环境添加审批者：
- en: Navigate to the **Environments** overview pane.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**环境**概览窗格。
- en: Open an environment by clicking on it.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the top-right menu marked with the three dots and choose **Approvals and
    Checks**.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Create** button.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pick a user or group from the list and add extra instructions if needed.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Create** button again.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Approvals make it possible for you to control the progression of a pipeline
    to the next stage if that pipeline targets the correct environment. Targeting
    an environment is done by specifying a specific type of job – the deployment job.
    The following YAML shows how to do this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Deployment jobs do not directly contain the steps to execute as an agent job
    does. Instead, they first must specify an execution strategy for the tasks outlined
    under the `steps` keyword. At the time of writing, the only strategy supported
    is `runOnce`. Other strategies are expected to be announced in the future.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, only Kubernetes clusters are supported as environment
    resources, but more types of resources have been announced for the future.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know about the technical means for creating release definitions
    and writing multi-stage YAML pipelines, it is time to look at the different strategies
    we can use to apply this in practice. These CD strategies are designed to minimize
    the risk of deploying new versions of an application automatically.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Implementing CD strategies
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we deploy an application continuously, it is important to think about
    the strategy we should use. Just doing deployment after deployment may have more
    risks associated with it than a business is willing to accept. It is important
    to think about how to deal with issues that might occur during or after deploying
    a new version of your application.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: There are a few deployment strategies that can be applied to reduce the risks
    that might come with deployments, all of which will be covered in this section.
    Please note that it is possible to combine one or more of the following patterns.
    For example, it is perfectly possible to use a blue-green strategy for every ring
    in a ring-based deployment. Also, all deployment strategies can be combined with
    the use of feature flags.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Blue-green deployments
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Blue-green deployments is a technique where a new version of an application
    never gets deployed to the production servers directly. Instead, it gets deployed
    to another set of servers first. Once this has been done successfully, users are
    directed to the new deployment.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume that an application runs on a total of three hosts by default.
    A typical setup for blue-green deployment would be two sets of three hosts – the
    blue group and the green group. In front of these two sets, there is a reverse
    proxy that functions as a load balancer and redirects the incoming requests to
    the blue group. The following diagram shows how this works:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.13 – Blue-green deployments ](img/B18655_06_13.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
- en: Figure 6.13 – Blue-green deployments
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: To deploy a new version of the application in this situation, it needs to be
    deployed to the green group of servers. Since these servers are not receiving
    any traffic from end users, this way of upgrading the servers has no impact on
    them at all.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: After the deployment, the new deployment can be verified to ensure that it was
    successful and that the application is running correctly. After this verification,
    the load balancer is reconfigured to redirect traffic to the green group. Now,
    the new version of the application is served.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: Should there suddenly be any unexpected issues, it is very easy to switch back
    to the previous deployment by reconfiguring the load balancer back to the blue
    group. If the deployment is successful and there are no issues, it is possible
    to start the deployment of the next version by going through the same procedure,
    but now with the roles of the green and the blue groups switched.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Immutable servers
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A variation of the blue-green deployment pattern is immutable servers. With
    immutable servers, there is no going back and forth between two groups of servers.
    Instead, the group of servers that is serving the old version of the application
    is completely disregarded or removed. Often, this is done after a grace period.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of this is that there will still be means to roll back to a previous
    version – almost instantaneously if the old servers are kept around for a while.
    The other benefit is that there is now a guarantee that no remains from a previous
    deployment are being carried over into the newer deployments. Using immutable
    servers, the change of active servers over time might look as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.14 – Immutable server deployments ](img/B18655_06_14.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
- en: Figure 6.14 – Immutable server deployments
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Of course, an approach like this is only feasible when using technologies such
    as containers or virtual machines. Nobody would expect anyone to disregard physical
    servers after every redeployment.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Progressive exposure
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Progressive exposure is a deployment strategy in which the number of users that
    have access to a new deployment or a new feature is slowly increased over time.
    The goal of this strategy is to limit the number of users that are experiencing
    issues when a faulty release of a feature is made available.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also look at this more positively and in line with the CD way of thinking:
    exposing a new feature to only a few users at first and increasing that number
    over time allows us to increase the amount of trust in a new version or feature
    of an application before exposing it to all users.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Canary deployments
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first strategy for progressive exposure is to use canary deployments. In
    a canary deployment, not all users are routed to the new version immediately –
    only a limited percentage of the users get access to that version. These users
    are the canaries and they are monitored very closely. If they experience any issues
    or if degradation in performance of a service is observed, the new deployment
    is quickly rolled back.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical approach to realizing canary deployments is to use them in combination
    with blue-green deployments. The difference is that instead of switching all users
    over at the same time, only a small percentage is moved over to the new version
    at the start, and then the number of users that are moved over is gradually increased
    over time. This might look something similar to the following:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.15 – Canary deployments ](img/B18655_06_15.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
- en: Figure 6.15 – Canary deployments
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: If a deployment is rolled back because errors have been observed, this is not
    a fun experience for users. To prevent the same small group of users from running
    into issues repeatedly, it might be beneficial to select a different group of
    canary users afterward.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: Ring-based deployments
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a ring-based environment, there is not just one production environment –
    there are multiple. Each production environment serves only a portion of the users.
    It differs from a canary deployment in that, instead of just two environments,
    there can be as many as needed. Also, every new version goes to all the rings,
    one after the other.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: 'So, instead of redirecting the users, in a ring-based environment, the new
    version propagates to the servers used by those users. The new version just keeps
    propagating from one ring to the next, until they are all done:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.16 – Ring-based deployments ](img/B18655_06_16.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
- en: Figure 6.16 – Ring-based deployments
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: Ring-based deployment architectures are especially suitable for products that
    are accessed by customers from all around the world. The different rings can be
    positioned around the world, thus combining the deployment benefits with the added
    benefit of reduced latency for users.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Blue-green versus canary deployments
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While both approaches are useful in minimizing the impact on your production
    workloads, there are some subtle variations that must be remembered when choosing
    one over the other:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: You can opt for blue-green deployment only when your production environment
    has an identical yet redundant secondary instance. Basically, you can upgrade
    the secondary instance first, and then route the traffic to it. Once satisfied
    with its working, you can continue with the deployment on your primary instance.
    This type of setup is similar to what is used during a disaster recovery situation.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you do not have an extra second instance but are able to partition your primary
    instance in a way that a subset of the user traffic can be routed to separate
    physical compute units, you can benefit from using the canary deployment strategy.
    Canary provides a relatively easier way to activate or deactivate features based
    on certain criteria to a subset of users of the application. Canary deployment
    is preferred for right-shift testing strategies, wherein the performance and usability
    of a new feature can be initially verified with a limited load, before rolling
    it out with the entire user base of the application.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, both methods require some initial planning and investment to straighten
    out the processes of deployment.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: Feature flags
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The third form of progressive deployment can be achieved using feature flags,
    also called feature toggles. Whereas canary deployments and ring-based deployments
    rely on slowly exposing new binaries to an increasing number of users, feature
    flags are used to slowly expose new features to an increasing number of users.
    This can be achieved even if they are all sending requests to the same server.
    Feature flags are generally used to mitigate the risk of releasing new features
    when upgrading to a new version of the application binaries that contain them.
    These flags act like a toggle switch whereby providing the ability to system administrators
    to enable or disable specific features at runtime.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: The best example of a feature flag is showing or hiding a button that gives
    users access to a new feature. Application settings, a database, or an external
    service are used to keep track of which feature has been enabled for which user.
    Depending on that setting, the feature is shown or hidden. Examples of such external
    services include LaunchDarkly, split.io, and Prefab.Cloud.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'Microsoft Azure also offers a resource named Azure App Configuration that can
    be used for centrally managing your feature flags and other application settings.
    You can read more about it here: [https://docs.microsoft.com/en-us/azure/azure-app-configuration/overview](https://docs.microsoft.com/en-us/azure/azure-app-configuration/overview).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Other feature flags might toggle bug fixes or performance improvements on or
    off. This can help to gradually expose these enhancements or fixes to ensure there
    are no issues. There should be a process in place when introducing feature toggles
    within the code base. It adds complexity, as the feature must support on-off toggles
    without having any impact to end users. This process should not only describe
    adding feature toggles but also how to remove them as soon as possible. An example
    of such a process can be as follows.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: A new feature flag is introduced by a developer as soon as the business needs
    to release the feature independently of the deployments that were made by the
    development team, or for a change that the development team qualifies as high-risk
    and wants to be able to pull back at any time without redeploying it. Introducing
    a feature flag means a new database entry or a declaration of a new setting is
    applied in the application settings.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: After introducing the feature toggle, the new feature or change is developed
    and tested. This means that there are one or more `if` statements in the code
    base that execute different code paths, depending on the state of the feature
    flag. At this point, the application must maintain two code execution paths until
    they remove the feature flag again. It is a good practice to separate these two
    code paths as much as possible using existing engineering practices, such as dependency
    injection.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: While the code is continuously being shipped to users, the feature is not enabled
    for anyone. Only when the development team is fully satisfied with the change
    or the product owner feels the time is right for releasing a new feature is the
    feature flag turned on.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: It is important not to stop here. After turning the feature flag on, it should
    actively be determined whether the feature or change is working properly, and
    if it is, the feature flag should be removed as soon as possible. This way, the
    time the two code paths need to be maintained for is as short as possible.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that besides maintaining an increased number of execution paths,
    there is now a larger number of paths to test. The impact of this consequence
    quickly grows if dependencies or exclusions between feature flags are introduced.
    Feature flags that can only be turned on or off, depending on the state of another
    feature flag, can be costly, and it is recommended to avoid this.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: If implemented properly and removed as soon as possible, the added cost of feature
    flags is often worth it. As with every engineering practice, start small and evaluate
    what works in the given context, before adapting the practice at scale.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Roll back or fail forward
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No matter which strategy is being used, it is necessary to think about the ability
    to roll back one or more versions and how long that will take. For example, blue-green
    deployments give us the ability to go back one version almost instantaneously,
    if a new version has not been deployed to the non-active servers yet. On the other
    hand, performing a rollback in a ring-based deployment will require a full redeployment
    of the previous version, which will probably take longer and comes with all the
    risks of deployment. This may even need to be done on multiple rings, making it
    more challenging.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Another approach that can be adopted is that of failing forward. When adopting
    this approach, it is stated that there will never be a rollback to a previous
    version. Instead, when any issue is encountered, this will be addressed by redeploying
    a new version with the fix of that issue in it. This strategy is gaining traction
    lately since it saves time, as we don’t have to prepare, test, and practice rollbacks.
    However, there can be risks involved with this process:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: There is no guarantee that the fix will be correct. The issue might not be resolved
    by the newly deployed version or, even worse, the new version might result in
    transitioning from one issue to another.
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working out a detailed root cause of any issue takes time, just like writing
    a fix does. The consequence of this might be that the fix might take longer than
    a rollback would have taken.
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No matter which approach is taken, consider the consequences and prepare for
    them.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have mainly focused on web-based applications. In the next section,
    we will shift our attention to mobile applications.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Deploying mobile applications
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One type of application that needs a special approach to deployment is a mobile
    application. These applications are often not downloaded and installed by end
    users directly and are mostly consumed via an app store on their mobile device.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio App Center is a Microsoft offering that can be used for distributing
    (deploying) mobile applications to end users via app stores, but also via private
    distribution lists.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'You can discover more about App Center here: [https://visualstudio.microsoft.com/app-center/](https://visualstudio.microsoft.com/app-center/).'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'After logging into App Center, you will be taken to the following screen:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.17 – Adding a new app ](img/B18655_06_17.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
- en: Figure 6.17 – Adding a new app
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can create a new app definition. An app definition should be created
    for every target operating system of an application. If the same application is
    going to be deployed to both Android and iOS, at least two apps have to be created.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating an app is done by performing the following steps:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Log in to App Center.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the blue **Add new app** button. If there are no existing apps, this button
    will be in the center of the screen; otherwise, it will be at the top right (hidden
    under the popup shown in the preceding screenshot).
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the name of the app.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the type of release.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the operating system.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the platform to use.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Add new app** to create the app.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once an app has been created, it can be connected to the correct app store and
    distribution groups can be created.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the app store
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The app store is the main mechanism for distributing an application for all
    mobile platforms. Once a build is delivered to an app store, users can install
    and use the application. The current list of connections to app stores can be
    opened using the **Stores** tab on the left-hand side of **App Center**. From
    this list, an individual store connection can be opened, which will take us to
    a screen similar to the one shown in the following screenshot:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.18 – An app store within Visual Studio App Center ](img/B18655_06_18.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
- en: Figure 6.18 – An app store within Visual Studio App Center
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: This view shows a list of all the versions of the application that have been
    published to the connected store account. This is also where a new version of
    the application can be selected for publication to the store. This is done using
    the blue **Publish to Google Play** button at the top. This will open a popup
    where you can select the correct release. You only have to confirm this once to
    publish this version.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'New connections to the store can be created by navigating back to the list
    of all store connections and clicking the **Add** button. This will open a wizard
    where two pieces of information have to be entered:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: '**The type of store connection**: This list is limited to the stores that are
    available to apps of the type that was chosen when creating the app definition.
    For example, for iOS, this is limited to the Apple App Store and the Intune Company
    Portal.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Connection details**: Often, they include the means of authentication between
    App Center and the app store.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once the new connection has been created, it can be found on the list shown
    previously and can be used to distribute the app.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Another means of distribution is using distribution groups, which we’ll introduce
    in the next section.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Using distribution groups
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Distribution groups are used to create named lists of one or more users, often
    testers or alpha users, that install an application through an invitation, rather
    than via the app store. Distribution groups can be found in the left-hand menu,
    under **Groups**:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.19 – Distribution groups within Visual Studio App Center ](img/B18655_06_19.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
- en: Figure 6.19 – Distribution groups within Visual Studio App Center
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, a new group can be added, as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to **Distribution groups** using the menu on the left.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the blue button labeled with a plus (**+**) sign (hidden under the popup
    in the preceding screenshot).
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose a name for the group.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add one or more members.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the new group.
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once a distribution group has been created, it can be used for publishing releases,
    which we will discuss in the next section.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Publishing an app
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To publish the first or a new version of an app, it has to be shared with App
    Center. This can be done using the **Releases** tab on the left-hand side. When
    opening up the releases, the following view, detailing all the current releases,
    will appear. From here, any release can be selected so that you can view the details
    of it:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.20 – Viewing the releases of an app ](img/B18655_06_20.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_IMG
- en: Figure 6.20 – Viewing the releases of an app
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: In this view, a list of the most recent releases is shown in the middle column.
    After selecting an individual release, the details of that version will be shown.
    This includes its formal version, the store(s) and/or distribution group(s) it
    has been shared with, and other details.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: From here, it is possible to distribute this specific version to a store connection
    or distribution group directly using the **Distribute** bottom at the top right.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, a new release can also be created by uploading a new build of the
    app. To do this, follow these steps:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **New release** button, which is available from the list of all
    releases (it might be necessary to close the details of a specific release first).
    This will open the following view:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.21 – Uploading a new build ](img/B18655_06_21.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
- en: Figure 6.21 – Uploading a new build
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: A new wizard will open, where a build needs to be uploaded. Depending on the
    type of app, the correct type of file will be requested. After uploading the binaries,
    click **Next**.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, the release notes have to be filled in. After detailing the changes in
    this release, click **Next** again.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, it is time to specify where this new build should be distributed. At least
    one destination – either a distribution group or a store – has to be selected.
    After selecting one or more destinations, click **Next** again.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final wizard tab will show the selections you’ve made so far. Check the
    details and click **Distribute** to complete the creation of a new version and
    its initial distribution.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Often, the same version or release needs to be distributed to other groups or
    stores over time as well. It is not necessary (nor useful) to create a new release
    every time. Instead, going to the **Detail** pages of the new destination store
    connection or distribution group allows you to publish an existing release to
    that destination as well.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative to using App Center to perform release management this way,
    it is also possible to use Azure Pipelines for release management.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: App Center via Azure Pipelines
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: App Center can also be integrated with Azure Pipelines. If teams are familiar
    with the release process in Azure Pipelines, it can be sensible to build the app
    in Azure Pipelines and only use App Center for deployment to stores and distribution
    groups.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: To make this possible, there are tasks available in Azure Pipelines that allow
    you to upload a release and trigger the deployment of a release to a store or
    distribution group. That way, release management can be done in Azure Pipelines
    while the App Center-specific capabilities are still leveraged where applicable.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: This section is focused on mobile applications specifically, while the next
    section will apply to all types of releases. When creating releases is automated
    and new versions follow each other quickly, it is useful to start automating the
    creation and publication of release notes as well. This will be discussed in the
    next section.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Automating release notes
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After automating the build, releasing an application, and working on increasing
    the flow of value to end users, many developers find that it becomes harder and
    harder to keep documentation and release notes up to date. As the amount of releases
    increases, this becomes more and more work, and eventually, the team will fall
    behind or even give up completely.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: 'To combat this, it is possible to automate the creation and publication of
    release notes. One way to do this is by using the *Azure DevOps Release Notes
    Generator*. Refer this for more details: [https://docs.microsoft.com/en-us/samples/azure-samples/azure-devops-release-notes/azure-devops-release-notes-generator/](https://docs.microsoft.com/en-us/samples/azure-samples/azure-devops-release-notes/azure-devops-release-notes-generator/).'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: 'The generator is an Azure Functions application that is available on GitHub.
    To use the Release Notes Generator, the following needs to be done:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: 'Download or clone the function code from GitHub at this link: [https://github.com/Azure-Samples/azure-devops-release-notes](https://github.com/Azure-Samples/azure-devops-release-notes).'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an Azure App Service Plan, function app, and storage account in Azure.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Blob Container in the storage account called `releases`.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile the function code and deploy it to an Azure App Service.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new Azure DevOps WebHook to call the deployed function whenever a new
    release is created. (Please refer to the Wiki documentation on GitHub for more
    detailed instructions.)
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After setting this up, the generator will run whenever a new release is created.
    It will then do the following:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Query the created release for its name, all associated work items, and all the
    commits that are new since the previous release
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate a Markdown file containing all of this information
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upload that file to the blob container – that is, `releases`
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Of course, the Azure DevOps Release Notes Generator is just one example of automating
    tasks around releases, and there are other alternatives available as well. Also,
    many companies create tailored, in-house automation scripts for updating and publishing
    documentation and other tasks.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Other tools
  id: totrans-286
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to Azure DevOps and App Center, there are other tools that can be
    used for deploying and releasing software. GitLab CI/CD and Jenkins, which were
    discussed in the previous chapter for executing builds, can also be used for releases.
    Besides those, Octopus Deploy is also a commonly used tool that integrates well
    with Azure DevOps.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: Octopus Deploy
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Octopus Deploy** is a deployment automation tool that is based on the concept
    of running a series of tasks on one or more target machines.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Octopus reaches these machines through a tentacle (an agent) that is installed
    on these machines. In Octopus Deploy, it is possible to define applications and
    environments and assign one or more machines to each of those. To do deployments,
    execution steps can be defined in a graphical editor, comparable to the visual
    release editor of Azure DevOps.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: One of the main differences is that these steps are not defined per environment,
    only once per pipeline. Next, it is possible to specify which environments each
    task should run on. This way, it is easier to see where the deployment to different
    environments varies.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: There is an integration between Azure DevOps and Octopus Deploy available, in
    the form of a build and release task. Using this integration, you can start a
    deployment using Octopus Deploy from an Azure DevOps build or release pipeline.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about continuous deployment and how you can implement
    them using Azure DevOps. In addition to the visual release editor, you also learned
    about multi-stage YAML pipelines, which you can use for releasing your software
    to multiple stages, all of the way to production. Next, we discussed a series
    of strategies that you can use for releasing. You now know about blue-green deployments,
    using immutable servers, and different strategies for progressive exposure. You
    also learned how to choose between making sure you have rollback capabilities
    and accepting a fail-forward strategy.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Then, you learned about automating release notes and documentation and how you
    can generate those automatically as part of your pipeline. After that, you learned
    about continuous deployment for mobile applications and how that differs from
    the delivery of web applications. Finally, you learned about the existence of
    Octopus Deploy, how it operates, and how it integrates with Azure DevOps.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about topic dependency management using
    Azure Artifacts. This can be used to host your own NuGet packages or to host build
    artifacts when you are using other products for building or releasing your application,
    in combination with Azure Pipelines.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-297
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude this chapter, here is a list of questions for you to test your
    knowledge of this chapter’s material. You will find the answers in the *Assessments*
    section of the *Appendix*:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'True or false: an Azure DevOps Classic release is always triggered by the availability
    of a new version of an artifact.'
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following platforms can App Center publish apps to? (You can choose
    more than one.)
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Google Play Store
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Apple App Store
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Microsoft Intune
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following techniques use progressive exposure for minimizing the
    risks of deploying a new version? (You can choose more than one.)
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Feature toggles
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Ring-based deployments
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Canary deployments
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: deployment groups can be used for deploying software to on-premises
    servers when an Azure Pipelines agent is installed on the machine that will be
    running the software.'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the advantage of integrating App Center with Azure Pipelines if you
    have an Azure Pipelines release definition triggering actions in App Center?
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Prerequisites**: The exercises in this chapter have a dependency on [*Chapter
    8*](B18655_08.xhtml#_idTextAnchor542), *Implement Infrastructure and Configuration
    as Code*. Please complete the exercises mentioned in that chapter so that you
    have provisioned the necessary resources in Azure to continue with the build deployment-related
    pipeline creation.'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PacktBookLibrary` project. This will be used as a service account for deploying
    resources and builds to Azure:'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigate to **Project Settings** | **Service connections** (under **Pipelines**)
    and then click on the **New Service Connection** button.
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Within the **New service connection** dialog, ensure that the **Azure Resource
    Manager** option is selected and then, in the next step, that **Service Principal
    (automatic)** is selected.
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Keep scope as **Subscription** and specify the Service connection name as **Azure
    Service Connection**.
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Under **Security**, check the option to grant access to all pipelines.
  id: totrans-316
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Create `DEV`, `TST`, and `PRD`. Don’t add any resources for now:![Figure 6.22
    – Environments for deployment ](img/B18655_06_22.jpg)
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure 6.22 – Environments for deployment
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'For each environment entry, configure the approvers for it. The list of approvers
    should be the members who can approve any activity in their respective owned environment:'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 6.23 – Configuring environment settings ](img/B18655_06_23.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
- en: Figure 6.23 – Configuring environment settings
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `Environment`: Refers to the name of the environment'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`azureSubscription`: Refers to the service connection name to be used'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Webappname`: Refers to the Azure App Service resource name'
  id: totrans-324
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Resorucegroup`: Refers to the resource group in which the App Service resource
    has been provisioned'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Slotname`: Refers to the slot of the App Service that the build has to be
    deployed to'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You should now see three different variable groups:![Figure 6.24 – Variable
    groups per environment ](img/B18655_06_24.jpg)
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure 6.24 – Variable groups per environment
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your code repository for the `PacktBookLibrary` repository and create
    a subfolder named `deploy` in the `pipelines` directory:'
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a file named `template.yaml`. Insert code as per the file present in
    this directory: [https://github.com/PacktPublishing/Designing-and-Implementing-Microsoft-DevOps-Solutions-AZ-400-Exam-Guide](https://github.com/PacktPublishing/Designing-and-Implementing-Microsoft-DevOps-Solutions-AZ-400-Exam-Guide)'
  id: totrans-330
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Place another file named `template.yaml` in the `build` subdirectory:'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Insert code as per the file present in this directory: [https://github.com/PacktPublishing/Designing-and-Implementing-Microsoft-DevOps-Solutions-AZ-400-Exam-Guide](https://github.com/PacktPublishing/Designing-and-Implementing-Microsoft-DevOps-Solutions-AZ-400-Exam-Guide)'
  id: totrans-332
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the `pipelines` directory, create a file named `main-cd-pipeline.yaml`.
    Insert code as per the file present in this directory: [https://github.com/PacktPublishing/Designing-and-Implementing-Microsoft-DevOps-Solutions-AZ-400-Exam-Guide](https://github.com/PacktPublishing/Designing-and-Implementing-Microsoft-DevOps-Solutions-AZ-400-Exam-Guide)'
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a CD pipeline to provision the latest build to three different environments:'
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on `main`, set the path as the relative path to `main-cd-pipeline.yaml`,
    and then save the pipeline under the name `main-cd-pipeline`.
  id: totrans-335
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Grant permissions to the pipelines to all the variable groups. You should see
    the following two pipelines now:![Figure 6.25 – Viewing the pipeline run statuses
    ](img/B18655_06_25.jpg)
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure 6.25 – Viewing the pipeline run statuses
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Run `main-cd-pipeline` and verify whether the build deployment is succeeding
    or not.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-339
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More information on using stages in YAML pipelines can be found at [https://docs.microsoft.com/en-us/azure/devops/pipelines/process/stages](https://docs.microsoft.com/en-us/azure/devops/pipelines/process/stages).
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information on the idea of immutable servers can be found at [https://martinfowler.com/bliki/ImmutableServer.xhtml](https://martinfowler.com/bliki/ImmutableServer.xhtml).
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about LaunchDarkly can be found at [https://launchdarkly.com/](https://launchdarkly.com/).
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More details about the build and release extension for integration with Octopus
    Deploy can be found at [https://marketplace.visualstudio.com/items?itemName=octopusdeploy.octopus-deploy-build-release-tasks](https://marketplace.visualstudio.com/items?itemName=octopusdeploy.octopus-deploy-build-release-tasks).
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Azure DevOps Release Notes Generator can be found at [https://docs.microsoft.com/en-us/samples/azure-samples/azure-devops-release-notes/azure-devops-release-notes-generator/](https://docs.microsoft.com/en-us/samples/azure-samples/azure-devops-release-notes/azure-devops-release-notes-generator/).
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some Microsoft hands-on labs for practicing the topics we covered in this chapter
    can be found at the following links:'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/learn/modules/create-multi-stage-pipeline/index](https://docs.microsoft.com/en-us/learn/modules/create-multi-stage-pipeline/index)'
  id: totrans-346
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/learn/modules/create-release-pipeline/index](https://docs.microsoft.com/en-us/learn/modules/create-release-pipeline/index)
    and [https://docs.microsoft.com/en-us/learn/modules/manage-release-cadence/index](https://docs.microsoft.com/en-us/learn/modules/manage-release-cadence/index)'
  id: totrans-347
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Part 3 – Expanding Your DevOps Pipeline
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this part, you will learn about other DevOps practices that build upon the
    strong foundation of **Continuous Integration** (**CI**)/**Continuous Delivery**
    (**CD**) discussed earlier in *Part 2 , Getting to Continuous Delivery*. You will
    learn about how to establish a robust **Application Lifecycle Management** (**ALM**)
    process to manage your infrastructure in the cloud, as well as streamlined upgrades
    and migration of your backend databases without incurring any loss of information.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: We will also look at continuous testing practices to understand more about the
    concept of “shift-left quality.” This involves embedding quality concerns in our
    pipelines from the start and continuously verifying them, resulting in the faster
    delivery of a secure and high-quality product.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: 'This part of the book comprises the following chapters:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18655_07.xhtml#_idTextAnchor453), *Dependency Management*'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B18655_08.xhtml#_idTextAnchor542), *Implement Infrastructure
    and Configuration as Code*'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B18655_09.xhtml#_idTextAnchor699), *Dealing with Databases in
    DevOps Scenarios*'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B18655_10.xhtml#_idTextAnchor760), *Integrating Continuous Testing*'
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B18655_11.xhtml#_idTextAnchor889), *Managing* *Security and
    Compliance*'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
