- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Installing and Configuring GitLab Runners
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装与配置 GitLab Runner
- en: In [*Chapter 4*](B18073_04.xhtml#_idTextAnchor084), you learned about the fundamentals
    of GitLab CI/CD. We defined and introduced the vocabulary and concepts around
    CI/CD pipelines, which included CI/CD pipeline components, different pipeline
    types, how to observe and interact with pipelines in the GitLab UI, and how to
    write a pipeline’s configuration using the `.gitlab-ci.yml` file. A few paragraphs
    were also spent introducing GitLab Runner as the crucial component of GitLab CI/CD,
    which actually runs pipeline tasks and reports the results back to GitLab.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 4 章*](B18073_04.xhtml#_idTextAnchor084) 中，你了解了 GitLab CI/CD 的基本概念。我们定义并介绍了与
    CI/CD 流水线相关的词汇和概念，其中包括 CI/CD 流水线的组成部分、不同的流水线类型、如何在 GitLab UI 中观察和与流水线交互，以及如何使用
    `.gitlab-ci.yml` 文件编写流水线配置。几段文字还介绍了 GitLab Runner 作为 GitLab CI/CD 的关键组件，它实际上运行流水线任务并将结果报告回
    GitLab。
- en: The sole focus of this chapter will be the topic of GitLab runners. You will
    learn in this chapter that GitLab runners act as the “muscle” in the CI/CD process.
    Runners are small programs that are installed separately from the main GitLab
    application. Their purpose is to receive new CI/CD jobs published by GitLab and
    follow the jobs’ instructions as specified in the `.gitlab-ci.yml` file. Runners
    can be installed and configured to work with a variety of types of infrastructure,
    including standalone servers, VMs, containers, and others.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的唯一重点将是 GitLab Runner。你将在本章中了解到，GitLab Runner 在 CI/CD 过程中充当了“肌肉”的角色。Runner
    是一些与 GitLab 主应用程序分开安装的小程序，它们的目的是接收 GitLab 发布的新的 CI/CD 任务，并按照 `.gitlab-ci.yml`
    文件中指定的指令执行任务。Runner 可以安装并配置为与多种类型的基础设施一起使用，包括独立服务器、虚拟机、容器等。
- en: We’ll begin by introducing the runner architecture as well as comparing and
    contrasting GitLab Runner with other tools that you may be familiar with. Next,
    we’ll describe installing and configuring runners so they can be paired with GitLab
    to run CI/CD jobs. Finally, we’ll end with discussing best practices for using
    different runner types for different circumstances.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先介绍 Runner 架构，并将 GitLab Runner 与你可能熟悉的其他工具进行比较。接下来，我们将描述如何安装和配置 Runner，使其能够与
    GitLab 配对以运行 CI/CD 任务。最后，我们将讨论在不同情况下使用不同 Runner 类型的最佳实践。
- en: 'Once you have learned how to install, configure, use, and maintain GitLab runners,
    you will be well on your way to managing the end-to-end life cycle for building,
    testing, and deploying your application. Here is how we’ll cover the topics in
    this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你学会了如何安装、配置、使用和维护 GitLab Runner，你就能顺利管理应用程序的构建、测试和部署的端到端生命周期。本章将介绍以下主题：
- en: Defining GitLab runners and their relationship to CI/CD
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义 GitLab Runner 及其与 CI/CD 的关系
- en: The runner architecture and supported platforms
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Runner 架构与支持的平台
- en: Installing the Runner agent
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Runner 代理
- en: Configuring and registering the runner with GitLab
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置并注册 Runner 到 GitLab
- en: Understanding when and why to use the various runner types and executors
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解何时以及为何使用不同类型的 Runner 和执行器
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Like the previous chapters, you’ll get the most out of this chapter if you have
    an account on a GitLab instance **software-as-a-service** (**SaaS**) or self-managed).
    In addition, installing the GitLab Runner agent requires a computer (Windows,
    Mac, or Linux) on which to install the runner binary. A personal laptop would
    be fine—the runner is lightweight and its system requirements are minimal. If
    you are using GitLab.com, CI/CD pipelines can also be run using GitLab’s SaaS
    runners, though be aware of possible usage charges.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的章节一样，如果你在 GitLab 实例的**软件即服务**（**SaaS**）或自托管环境中有一个账户，你将从本章中获得更多收益。此外，安装 GitLab
    Runner 代理需要一台计算机（Windows、Mac 或 Linux），在该计算机上安装 Runner 二进制文件。个人笔记本电脑也可以使用——Runner
    轻量且系统要求较低。如果你使用的是 GitLab.com，CI/CD 流水线也可以通过 GitLab 的 SaaS Runner 来运行，不过请注意可能会产生使用费用。
- en: Defining GitLab runners and their relationship to CI/CD
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义 GitLab Runner 及其与 CI/CD 的关系
- en: Recall that GitLab CI/CD is a series of tasks performed against code in your
    project, which often include some combination of build, test, and deploy jobs.
    Importantly, CI/CD pipelines are not run inside the GitLab application, as each
    job will generally require some specific platform and set of tools to successfully
    run.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，GitLab CI/CD 是一系列针对你项目中的代码执行的任务，这些任务通常包括构建、测试和部署工作的组合。重要的是，CI/CD 流水线并不是在
    GitLab 应用程序内部运行的，因为每个任务通常需要某些特定的平台和工具集才能成功运行。
- en: Note
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: GitLab runners are programs that accept CI/CD jobs from GitLab, run the jobs’
    tasks in an appropriate execution environment, and then report the results back
    to GitLab.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab runners 是从 GitLab 接受 CI/CD 任务、在适当的执行环境中运行任务，并将结果报告回 GitLab 的程序。
- en: GitLab Runner is an open source application written in Go
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitLab Runner 是一个用 Go 语言编写的开源应用程序。
- en: The official repository for the GitLab Runner application lives in a project
    hosted on [GitLab.com](http://GitLab.com) called `gitlab-runner`. At the time
    of writing, you can navigate to [https://gitlab.com/gitlab-org/gitlab-runner](https://gitlab.com/gitlab-org/gitlab-runner)
    to view the project’s development and source code. Like the main GitLab application,
    GitLab Runner follows a monthly release cadence. The latest version of GitLab
    Runner is *usually* the same major and minor release number as GitLab, though
    that is not guaranteed to always be the case. Like most of GitLab, GitLab Runner
    is open source and distributed under the MIT license.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab Runner 应用程序的官方仓库托管在 [GitLab.com](http://GitLab.com) 上，项目名为 `gitlab-runner`。写作时，您可以访问
    [https://gitlab.com/gitlab-org/gitlab-runner](https://gitlab.com/gitlab-org/gitlab-runner)
    来查看该项目的开发和源代码。与主要的 GitLab 应用程序一样，GitLab Runner 遵循每月发布一次的版本发布周期。GitLab Runner 的最新版本*通常*与
    GitLab 的主版本号和次版本号相同，但这并不总是保证的。与大多数 GitLab 一样，GitLab Runner 是开源的，并且根据 MIT 许可证进行分发。
- en: A perusal of the code base referenced in the previous URL shows us that Gitlab
    Runner is written in the Go programming language. The program is compatible with
    most major computer architectures (x86, AMD64, ARM, and so on) and operating systems
    (Windows, macOS, and Linux)—really, just about anywhere that supports installing
    Go binaries. We’ll soon see that installing the runner executable is straightforward
    and requires few dependencies.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 查阅前述 URL 中的代码库，我们可以看到 GitLab Runner 是用 Go 编程语言编写的。该程序与大多数主要的计算机架构（x86、AMD64、ARM
    等）和操作系统（Windows、macOS 和 Linux）兼容——实际上，只要支持安装 Go 二进制文件的地方，几乎都可以运行。我们很快会看到，安装 runner
    可执行文件非常简单，且所需依赖很少。
- en: GitLab Runner runs CI/CD jobs specified in .gitlab-ci.yml
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitLab Runner 执行在 `.gitlab-ci.yml` 文件中指定的 CI/CD 任务。
- en: Recall from the previous chapter that GitLab CI/CD pipelines comprise stages
    and jobs defined in `.gitlab-ci.yml`. Each job contains a set of instructions,
    which is often shell-style commands to be run in sequence. By default, every new
    commit to a branch where a `.gitlab-ci.yml` file is defined launches a new pipeline
    run. That means the jobs in `.gitlab-ci.yml` will be scheduled to run following
    the order and logic specified in the configuration.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾上一章，GitLab CI/CD 流水线由在 `.gitlab-ci.yml` 文件中定义的阶段和任务组成。每个任务包含一组指令，通常是按顺序执行的
    shell 风格命令。默认情况下，每当对一个定义了 `.gitlab-ci.yml` 文件的分支进行新的提交时，就会启动一个新的流水线运行。这意味着 `.gitlab-ci.yml`
    中的任务将按照配置中指定的顺序和逻辑进行调度。
- en: During a CI/CD pipeline run, when a job arrives at its “turn,” the job will
    be assigned to an available GitLab runner that is able to run the job’s instructions.
    One job gets assigned to one runner. After the runner receives the job from GitLab,
    one of the first things it will do is fetch the commit that launched the pipeline,
    so it has the relevant snapshot of the code base. The runner may then perform
    steps such as compiling a build, running unit tests, running security scans, or
    deploying the application to some kind of environment. Remember, the runner just
    follows the job’s instructions from `.gitlab-ci.yml`. Once the runner completes
    the tasks specified in the job, it will report the results back to GitLab. That
    will almost always include returning a pass or fail status, as well as any artifacts
    generated or modified during job execution.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CI/CD 流水线运行过程中，当某个任务到达其“轮次”时，该任务将被分配给一个可用的 GitLab runner，该 runner 能够执行任务的指令。每个任务会分配给一个
    runner。在 runner 从 GitLab 接收到任务后，它将首先执行的操作之一是获取启动流水线的提交记录，以便拥有相关的代码库快照。然后，runner
    可能会执行编译构建、运行单元测试、安全扫描，或者将应用程序部署到某个环境中等步骤。请记住，runner 只是按照 `.gitlab-ci.yml` 文件中的任务指令进行操作。一旦
    runner 完成任务中指定的工作，它将结果报告回 GitLab。报告几乎总是包括返回通过或失败状态，以及在任务执行过程中生成或修改的任何工件。
- en: As discussed near the beginning of [*Chapter 4*](B18073_04.xhtml#_idTextAnchor084)
    (see the *Viewing a list of pipelines* section), the pipeline status and job execution
    can be monitored in real time via the GitLab UI. The runner constantly communicates
    with GitLab, and from the UI, you can view available runners, modify runner settings,
    intervene with pipeline and job execution, view uploaded artifacts, and more.
    One way to think about the relationship between GitLab’s CI/CD components is to
    think of runners as the muscles that follow the instructions of `.gitlab-ci.yml`
    (the brain). GitLab would then be like the nervous system, which coordinates the
    communication between the brain (the pipeline configuration) and the muscles (the
    runners doing the heavy lifting of running CI/CD jobs).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如在[*第4章*](B18073_04.xhtml#_idTextAnchor084)（参见*查看管道列表*部分）开头讨论的那样，可以通过 GitLab
    用户界面实时监控管道状态和作业执行。Runner 持续与 GitLab 通信，从用户界面可以查看可用的 Runner、修改 Runner 设置、干预管道和作业执行、查看上传的工件等。一种理解
    GitLab CI/CD 组件之间关系的方式是将 Runner 看作是执行 `.gitlab-ci.yml` 指令的肌肉（大脑），而 GitLab 则像是神经系统，协调大脑（管道配置）和肌肉（执行
    CI/CD 作业的 Runner）之间的通信。
- en: The runner architecture and supported platforms
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Runner 架构和支持的平台
- en: Before going into further details about runner components, installation, and
    configuration, it’s worth clarifying a few pieces of terminology. So far in this
    chapter, the words *GitLab Runner* and *runner* may appear to have been used interchangeably.
    However, a bit of nuance is required. *GitLab Runner* refers to the application
    installed once on a computer. Once the GitLab Runner application is installed,
    it does not yet communicate with GitLab or run CI/CD jobs. In order to connect
    to GitLab and run CI/CD jobs, an administrator will need to execute a GitLab Runner
    command that *registers* individual *runners* with GitLab and specifies the execution
    environment those runners will use. Each registered runner will then be a dedicated
    process that checks into GitLab and runs CI/CD jobs.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步详细讨论 Runner 组件、安装和配置之前，值得澄清一些术语。到目前为止，本章中可能使用了*GitLab Runner*和*runner*这两个词交替出现。然而，这两个词之间有些微妙的差别。*GitLab
    Runner*是指安装在计算机上的应用程序。安装 GitLab Runner 应用程序后，它尚未与 GitLab 通信或执行 CI/CD 作业。为了连接到
    GitLab 并运行 CI/CD 作业，管理员需要执行一个 GitLab Runner 命令，该命令将单个*runner*注册到 GitLab，并指定这些
    runner 将使用的执行环境。每个注册的 runner 将成为一个独立的进程，定期与 GitLab 联系并运行 CI/CD 作业。
- en: 'This setup can appear confusing at first because a single GitLab Runner application
    will normally support registering multiple runner processes on the computer where
    it’s installed. Moreover, those runner processes might use a variety of execution
    environments for running their jobs. For example, consider a single, bare-metal
    Linux server. An admin may install the GitLab Runner application, which they then
    use to register the following:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置一开始可能会显得有些混乱，因为单个 GitLab Runner 应用程序通常会支持在安装它的计算机上注册多个 Runner 进程。此外，这些 Runner
    进程可能会使用不同的执行环境来运行它们的作业。例如，考虑一个单独的裸机 Linux 服务器。管理员可能会安装 GitLab Runner 应用程序，然后使用它注册以下内容：
- en: A runner process that executes a job in a shell session on the server OS
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Runner 进程，在服务器操作系统的 shell 会话中执行作业
- en: A second runner process that executes a job in a Docker container
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个第二个 Runner 进程，在 Docker 容器中执行作业
- en: A third runner process that pipes a job’s commands to another server over SSH
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个第三方 Runner 进程，将作业的命令通过 SSH 管道传送到另一台服务器
- en: 'That is, a single GitLab Runner application installed on a single computer
    can register multiple runners. The Gitlab Runner application is responsible for
    starting, stopping, and managing the individual runner processes and picking up
    CI/CD jobs from GitLab. *Figure 5**.1* summarizes the flow of information between
    GitLab, a runner, and the environment used to execute the job payload:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，安装在单台计算机上的一个 GitLab Runner 应用程序可以注册多个 Runner。GitLab Runner 应用程序负责启动、停止和管理各个
    Runner 进程，并从 GitLab 获取 CI/CD 作业。*图 5.1* 总结了 GitLab、Runner 和执行作业负载的环境之间的信息流：
- en: '![Figure 5.1 – GitLab Runner communication and job execution](img/Figure_5.01_B18073.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – GitLab Runner 通信与作业执行](img/Figure_5.01_B18073.jpg)'
- en: Figure 5.1 – GitLab Runner communication and job execution
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – GitLab Runner 通信与作业执行
- en: For the purposes of this chapter, don’t worry too much about the finer details
    of this flow. Just understand that runners communicate with GitLab in order to
    receive and run CI/CD jobs in an associated execution environment.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了本章的目的，不必太担心此流程的细节。只需理解 runner 与 GitLab 通信，以便在关联的执行环境中接收和运行 CI/CD 作业。
- en: GitLab Runner is supported on most platforms and architectures
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitLab Runner 支持大多数平台和架构
- en: At the time of writing this book, GitLab Runner can be installed on every major
    Linux distribution and architecture, as well as on FreeBSD, Windows, macOS, Docker,
    and Kubernetes. GitLab also offers a FIPS 140-12 runner binary for those organizations
    that require it for legal or internal compliance reasons.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，GitLab Runner 可以安装在每个主要的 Linux 发行版和架构上，以及 FreeBSD、Windows、macOS、Docker
    和 Kubernetes 上。GitLab 还为那些因法律或内部合规要求需要它的组织提供了 FIPS 140-12 版 runner 二进制文件。
- en: '*Table 5.1* summarizes the supported architectures and operating system platforms
    as of GitLab Runner 15.3:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*表 5.1* 总结了截至 GitLab Runner 15.3 支持的架构和操作系统平台：'
- en: '| **Officially Supported Computer Architectures** | **Officially Supported**
    **Operating Systems** |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| **官方支持的计算机架构** | **官方支持的操作系统** |'
- en: '| --- | --- |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| x86 | Debian |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| x86 | Debian |'
- en: '| AMD64 | Ubuntu |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| AMD64 | Ubuntu |'
- en: '| ARM | CentOS |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| ARM | CentOS |'
- en: '| ARM64 | Red Hat Enterprise Linux |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| ARM64 | Red Hat Enterprise Linux |'
- en: '| s390x | Fedora |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| s390x | Fedora |'
- en: '| ppx64le | Linux Mint |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| ppx64le | Linux Mint |'
- en: '|  | Microsoft Windows |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '|  | Microsoft Windows |'
- en: '|  | macOS |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '|  | macOS |'
- en: '|  | FreeBSD |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '|  | FreeBSD |'
- en: Table 5.1 – GitLab Runner-supported platforms
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 表 5.1 – GitLab Runner 支持的平台
- en: This table lists the architecture and OS platforms that GitLab explicitly supports
    per its documentation. For the Linux distributions listed, GitLab makes official
    GitLab Runner packages available that can be managed with the distribution’s native
    package manager. However, even if your Linux distribution of choice doesn’t appear
    in the table, you can generally install the GitLab Runner binary manually on any
    Linux box provided it has a compatible computer architecture.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这张表列出了 GitLab 根据其文档明确支持的架构和操作系统平台。对于列出的 Linux 发行版，GitLab 提供官方的 GitLab Runner
    包，可以通过该发行版的本地包管理器进行管理。然而，即使你的 Linux 发行版没有出现在表中，只要该系统具有兼容的计算机架构，通常也可以手动安装 GitLab
    Runner 二进制文件。
- en: As previously mentioned, GitLab Runner can also be hosted in a container or
    container orchestration system, namely Docker and Kubernetes, respectively. Note
    this refers to the hosting of the GitLab Runner agent itself, as opposed to the
    executor or execution environment it uses to run jobs. When we discuss executors
    in detail later in the chapter, we will learn that a runner can be directed to
    use Docker or Kubernetes as its executor, regardless of where the GitLab Runner
    agent is installed, provided it has access to the relevant container tools.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，GitLab Runner 还可以托管在容器或容器编排系统中，即分别是 Docker 和 Kubernetes。请注意，这指的是托管 GitLab
    Runner 代理本身，而不是其用于运行作业的执行器或执行环境。当我们稍后在本章详细讨论执行器时，我们将了解到，runner 可以被指示使用 Docker
    或 Kubernetes 作为其执行器，无论 GitLab Runner 代理安装在哪里，只要它能够访问相关的容器工具。
- en: Runners can be specific, group, or shared
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Runners 可以是特定的、组级的或共享的
- en: In [*Chapter 3*](B18073_03.xhtml#_idTextAnchor061), we learned that work in
    GitLab is organized into projects and groups. Projects and groups are intended
    to represent organizational boundaries such as teams or product lines. Projects
    normally (though not always) host a Git repository containing source code. Groups
    are containers that hold projects and other groups, similar to how folders organize
    files and other folders in a filesystem.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 3 章*](B18073_03.xhtml#_idTextAnchor061) 中，我们了解到 GitLab 中的工作是按项目和组来组织的。项目和组代表组织边界，如团队或产品线。项目通常（但不总是）托管一个包含源代码的
    Git 仓库。组是容器，用来存放项目和其他组，类似于文件系统中文件夹的组织方式。
- en: '[*Chapter 4*](B18073_04.xhtml#_idTextAnchor084) then introduced CI/CD pipelines.
    We learned that CI/CD pipelines run inside a project against that project’s code.
    How, then, do we organize and assign runners in GitLab, making them available
    for CI/CD pipelines to run their jobs? It turns out that we can organize runner
    availability similarly to how we can organize many other GitLab resources: by
    making them available at the project, group, or instance level.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第 4 章*](B18073_04.xhtml#_idTextAnchor084)随后介绍了 CI/CD 流水线。我们了解到 CI/CD 流水线是在项目内运行，并针对该项目的代码。那么，如何在
    GitLab 中组织和分配跑者，使它们可供 CI/CD 流水线运行作业呢？事实证明，我们可以像组织其他 GitLab 资源一样组织跑者的可用性：通过将其设置为项目级、群组级或实例级。'
- en: Specific runners are enabled for individual projects
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特定跑者启用供个别项目使用
- en: Project owners and maintainers may choose to register runners just for their
    projects. **Specific runners** are assigned to specific projects, and only pick
    up and run jobs from CI/CD pipelines running in the project they’re assigned to.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 项目所有者和维护者可以选择仅为他们的项目注册跑者。**特定跑者**被分配给特定项目，仅会接收并运行该项目中 CI/CD 流水线的作业。
- en: 'Using specific runners has a couple of advantages. The first is that specific
    runners empower project owners and developers to set up the runner infrastructure
    they need without changing anything outside the project they’re working in. For
    example, a developer might install GitLab Runner on their local laptop, and register
    a specific runner to a project where they’re the lead contributor. The developer
    won’t need to ask IT or platform owners to go through some global change management
    process. Project-specific runners can be managed under project settings, as shown
    in *Figure 5**.2*:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特定跑者有几个优势。首先是特定跑者使项目所有者和开发者能够设置他们所需的跑者基础设施，而无需更改他们所在项目之外的任何内容。例如，开发者可能会在他们的本地笔记本电脑上安装
    GitLab Runner，并将特定跑者注册到他们作为主要贡献者的项目中。这样，开发者就不需要请求 IT 或平台所有者进行全局变更管理。项目特定的跑者可以在项目设置下进行管理，如*图
    5.2*所示：
- en: '![Figure 5.2 – Project-level runner settings](img/Figure_5.02_B18073.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 项目级跑者设置](img/Figure_5.02_B18073.jpg)'
- en: Figure 5.2 – Project-level runner settings
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 项目级跑者设置
- en: Another advantage of specific runners is the possibility of dedicated or customized
    tooling for individual projects. Specific runners allow for easier project-level
    accounting of resource use. Moreover, security and compliance policies may require
    that certain projects use dedicated infrastructure that is separate from the rest
    of the organization. A runner registered to one specific project will only run
    pipeline code from inside that project. Pipelines from other parts of GitLab won’t
    have access to it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 特定跑者的另一个优势是为个别项目提供专用或定制化的工具。特定跑者使得项目级资源使用的会计工作变得更简单。此外，安全和合规政策可能要求某些项目使用与组织其他部分隔离的专用基础设施。注册到特定项目的跑者只会运行该项目内部的流水线代码，GitLab
    其他部分的流水线无法访问它。
- en: Group runners are available for all projects inside a group
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 群组跑者可供群组内所有项目使用
- en: 'We’ve learned that some resources in GitLab are only available in projects,
    some resources are only available in groups, and others can be available in both
    projects and groups. Runners are an example of that third type of resource. Registering
    a runner at the group level makes that runner available to all pipelines in all
    projects within that group and its subgroups. *Figure 5**.3* shows that group
    runners can be registered in a group’s CI/CD settings:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到，GitLab 中有些资源仅在项目中可用，有些资源仅在群组中可用，还有一些资源可以同时在项目和群组中使用。跑者就是这第三类资源的一个例子。在群组级注册跑者使得该跑者可以供群组内所有项目及其子群组的流水线使用。*图
    5.3* 显示群组跑者可以在群组的 CI/CD 设置中注册：
- en: '![Figure 5.3 – Group runner settings](img/Figure_5.03_B18073.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 群组跑者设置](img/Figure_5.03_B18073.jpg)'
- en: Figure 5.3 – Group runner settings
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 群组跑者设置
- en: Group owners can create and manage group runners, which accept and run CI/CD
    jobs on a **first-in, first-out** (**FIFO**) basis. Group runners are useful for
    teams that want to share resources or run multi-project CI/CD pipelines, but still
    need to manage their own runners for accounting or compliance reasons.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 群组所有者可以创建并管理群组跑者，群组跑者会按**先进先出**（**FIFO**）顺序接收并运行 CI/CD 作业。群组跑者对于那些希望共享资源或运行跨多个项目的
    CI/CD 流水线的团队非常有用，但这些团队仍然需要管理自己的跑者以满足会计或合规要求。
- en: Shared runners are available to all projects across GitLab
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享跑者可供 GitLab 中所有项目使用
- en: GitLab instance administrators can choose to register runners that can pick
    up CI/CD jobs from any project in any group across the GitLab instance. This allows
    platform owners to abstract away runner management from developers or project
    managers. Instance admins can also configure CI/CD quotas at the global level
    that limit the amount of CI/CD pipeline minutes individual projects can use across
    available shared runners.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab实例的管理员可以选择注册运行器，这些运行器可以从GitLab实例中任何项目的任何组获取CI/CD作业。这使平台所有者可以将运行器管理从开发人员或项目经理中抽象出来。实例管理员还可以在全局级别配置CI/CD配额，限制各个项目在可用的共享运行器上使用的CI/CD流水线分钟数。
- en: Shared Runners Only Apply to Self-Managed GitLab
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 共享运行器仅适用于自管理的GitLab
- en: Administrators can only configure shared runners on self-managed GitLab instances.
    [GitLab.com](http://GitLab.com) customers can choose to use SaaS runners provided
    by GitLab, as well as register their own group or specific runners. A certain
    number of pipeline minutes for SaaS runners are included in each GitLab license
    tier, with additional minutes available for purchase. There is never a charge
    to use your own group or specific runners.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 管理员只能在自管理的GitLab实例上配置共享运行器。[GitLab.com](http://GitLab.com)的客户可以选择使用GitLab提供的SaaS运行器，也可以注册自己的组或特定运行器。每个GitLab许可级别包含一定数量的SaaS运行器流水线分钟，额外的分钟可以购买。使用您自己的组或特定运行器永远不收费。
- en: Container-based platforms such as Kubernetes are a common executor choice for
    shared runners in order to provide ephemeral resources that can be quickly scaled.
    Unlike group runners, which pick jobs on a FIFO basis, shared runners operate
    via a *fair usage queue*. Projects with the fewest CI/CD jobs using shared runners
    have priority over those with more active jobs using shared runners. That helps
    to ensure that a single massive pipeline from one project doesn’t hog the entire
    shared runner infrastructure.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 基于容器的平台，如Kubernetes，是共享运行器常见的执行器选择，旨在提供可以快速扩展的临时资源。与基于FIFO原则挑选作业的组运行器不同，共享运行器通过*公平使用队列*进行操作。使用共享运行器的CI/CD作业较少的项目优先于作业更活跃的项目。这有助于确保来自单个项目的大规模流水线不会占用整个共享运行器基础设施。
- en: Each runner has a defined executor
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 每个运行器都有一个定义的执行器
- en: 'Let’s review some of the components we have mentioned so far:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下到目前为止提到的一些组件：
- en: The GitLab application, which schedules and coordinates CI/CD pipelines
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitLab应用程序，调度和协调CI/CD流水线
- en: GitLab Runner, the binary installed on a computer
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitLab Runner，安装在计算机上的二进制文件
- en: Individual runners, which are processes that run CI/CD jobs and are managed
    by the GitLab Runner agent
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独立运行器，它们是运行CI/CD作业的进程，由GitLab Runner代理管理
- en: 'If you look back at *Figure 5**.1*, you will notice an **Executor component**,
    which receives the job payload and returns the job output and status. The executor
    refers to the environment that a runner process uses to run a received CI/CD job.
    A runner’s executor is specified when the runner is first registered with GitLab.
    Recall that multiple runner processes, each with its own executor, can be registered
    from a single computer that has the GitLab Runner agent installed. *Table 5.2*
    summarizes the supported runner executors:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾*图5.1*，你会注意到一个**执行器组件**，它接收作业负载并返回作业输出和状态。执行器指的是运行接收到的CI/CD作业的运行器进程所使用的环境。运行器的执行器在运行器首次注册到GitLab时指定。回想一下，可以从安装了GitLab
    Runner代理的单台计算机注册多个运行器进程，每个进程都有自己的执行器。*表5.2*总结了支持的运行器执行器：
- en: '| **Officially Supported GitLab Runner Executors** |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| **官方支持的GitLab Runner执行器** |'
- en: '| --- |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| Docker |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| Docker |'
- en: '| Shell |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| Shell |'
- en: '| VirtualBox |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| VirtualBox |'
- en: '| Parallels |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| Parallels |'
- en: '| Kubernetes |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| Kubernetes |'
- en: '| Docker Machine |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| Docker Machine |'
- en: '| SSH |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| SSH |'
- en: '| Custom |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| Custom |'
- en: Table 5.2 – GitLab Runner supported executors
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 表5.2 – GitLab Runner支持的执行器
- en: We will describe each executor in turn.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将依次描述每个执行器。
- en: The Docker executor
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker执行器
- en: A runner using the Docker executor runs CI/CD jobs in Docker containers that
    are launched from a specified Docker image. This provides a reproducible environment
    containing the tools needed to run the CI/CD job. Using the Docker executor requires
    that Docker Engine be installed on the same computer as GitLab Runner.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Docker执行器的运行器在从指定Docker镜像启动的Docker容器中运行CI/CD作业。这提供了一个可复现的环境，包含运行CI/CD作业所需的工具。使用Docker执行器要求在与GitLab
    Runner相同的计算机上安装Docker引擎。
- en: Note
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Docker is the most common executor used among GitLab users. Docker containers
    are also the default environment used by the shared SaaS runners on GitLab.com.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 是 GitLab 用户中最常用的执行器。Docker 容器也是 GitLab.com 上共享 SaaS 运行器使用的默认环境。
- en: 'The Docker executor makes it easy to ensure CI/CD jobs have the tools they
    need to successfully run. Those tools are provided in the container image that
    the runner is instructed to use for the job. The image used for a job can be specified
    in a few separate places:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 执行器使得确保 CI/CD 任务拥有成功运行所需的工具变得容易。这些工具通过容器镜像提供，运行器被指示在任务中使用该镜像。任务使用的镜像可以在几个不同的位置进行指定：
- en: Inside a job definition in `.gitlab-ci.yml`
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `.gitlab-ci.yml` 文件中的任务定义内部
- en: Globally in `.gitlab-ci.yml`, so it is used for all jobs in the pipeline
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `.gitlab-ci.yml` 文件中全局设置，这样它会被用于流水线中的所有任务
- en: As the default image used by a runner with the Docker executor if `.gitlab-ci.yml`
    does not specify an image to use
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 `.gitlab-ci.yml` 文件中没有指定要使用的镜像，则作为运行器使用 Docker 执行器时的默认镜像
- en: The image the runner uses can be in a local GitLab container registry, another
    external registry, or a public container registry such as Docker Hub. For example,
    if your CI/CD job requires an environment with Python tooling, you might instruct
    the runner to fetch the `python:3.10` image from Docker Hub, and then launch a
    container from that image to run the job. Once the job completes, the runner will
    delete the container until it receives a new job, at which point the runner will
    run the job in a fresh container.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 运行器使用的镜像可以位于本地的 GitLab 容器注册表、其他外部注册表，或像 Docker Hub 这样的公共容器注册表。例如，如果你的 CI/CD
    任务需要一个包含 Python 工具的环境，你可以指示运行器从 Docker Hub 拉取 `python:3.10` 镜像，然后从该镜像启动一个容器来运行任务。任务完成后，运行器会删除该容器，直到收到新的任务，这时运行器会在一个新的容器中运行该任务。
- en: The Shell executor
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Shell 执行器
- en: The Shell executor runs jobs directly in a shell session on the machine where
    GitLab Runner is installed. The content of the `script` keyword in each job definition
    in `.gitlab-ci.yml` is run as if a user were typing commands in a terminal. The
    key advantage of the Shell executor is that it is simple to get started since
    it uses the native shell and filesystem of wherever GitLab Runner is installed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: Shell 执行器直接在安装了 GitLab Runner 的机器上通过 shell 会话运行任务。每个任务定义中的 `.gitlab-ci.yml`
    文件中的 `script` 关键字的内容会像用户在终端中输入命令一样执行。Shell 执行器的主要优点是，因其使用了 GitLab Runner 安装所在的本地
    shell 和文件系统，因此上手简单。
- en: 'There are, however, a couple of challenges that make the Shell executor difficult
    to scale:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Shell 执行器有一些挑战，使其难以扩展：
- en: The first is that you need to have the necessary build, test, or deploy tools
    required by the CI/CD job already on the server for the Shell executor to access.
    Or you would need to have steps in the `script` keyword that install the necessary
    dependencies.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，你需要在服务器上预先安装 CI/CD 任务所需的构建、测试或部署工具，以便 Shell 执行器能够访问这些工具。或者你需要在 `script` 关键字中指定步骤来安装所需的依赖项。
- en: The second challenge is the lack of a clean-slate environment for CI/CD jobs.
    It is easy to leave leftover build and test artifacts since the job will be executed
    directly in the server’s filesystem, rather than in a reproducible environment
    such as a container.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个挑战是缺乏干净的环境来执行 CI/CD 任务。由于任务将在服务器的文件系统中直接执行，而不是在如容器这样的可重现环境中，因此容易留下构建和测试的残留物。
- en: So while the Shell executor may be the best executor to use as a beginner standing
    up your first pipelines, it is recommended that you use a different executor for
    more complicated build environments.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管 Shell 执行器可能是你初次搭建流水线时最好的选择，但对于更复杂的构建环境，建议使用其他执行器。
- en: The VirtualBox executor
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: VirtualBox 执行器
- en: The VirtualBox executor is a way to provide reproducible environments for CI/CD
    jobs that may still require full operating system resources. The executor can
    only be used on computers that have the VirtualBox hypervisor installed. When
    you register a runner with the VirtualBox executor, specify a **virtual machine**
    (**VM**) template that the runner will use to run CI/CD jobs. When the runner
    picks up a job, it will spin up a new VM from the base template, run the job in
    a shell session on that VM, report the results back to GitLab, and then tear down
    the VM.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: VirtualBox 执行器是一种为 CI/CD 作业提供可重现环境的方法，这些作业可能仍然需要完整的操作系统资源。该执行器只能在安装了 VirtualBox
    虚拟化程序的计算机上使用。当您将 Runner 注册到 VirtualBox 执行器时，指定一个 **虚拟机**（**VM**）模板，Runner 将使用该模板运行
    CI/CD 作业。当 Runner 获取到一个作业时，它会从基本模板启动一个新的虚拟机，在该虚拟机上通过 shell 会话执行作业，将结果返回到 GitLab，然后销毁虚拟机。
- en: While useful as a way of ensuring clean-slate environments, the VirtualBox executor
    may not be necessary unless the job requires access to an operating system running
    on a Type-2 hypervisor. Consider using the Docker or Kubernetes executor if you
    would like standardization without the overhead of a VM.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机执行器虽然在确保清洁环境方面很有用，但除非作业需要访问运行在 Type-2 虚拟化程序上的操作系统，否则可能不需要使用。若您希望在没有虚拟机开销的情况下实现标准化，考虑使用
    Docker 或 Kubernetes 执行器。
- en: The Parallels executor
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Parallels 执行器
- en: The Parallels executor is configured and runs jobs the same way as the VirtualBox
    executor, the difference being that it uses the Parallels virtualization platform
    instead of VirtualBox. This allows you to run CI/CD jobs in a Windows VM running
    on a macOS host machine.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Parallels 执行器的配置和运行方式与 VirtualBox 执行器相同，不同之处在于它使用 Parallels 虚拟化平台而非 VirtualBox。这样，您就可以在运行
    macOS 的主机机器上运行 Windows 虚拟机中的 CI/CD 作业。
- en: The Kubernetes executor
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kubernetes 执行器
- en: When a runner is registered with the Kubernetes executor, it runs a CI/CD job
    in a Pod (that is, a group of one or more containers) in a Kubernetes cluster.
    This naturally requires you to have a Kubernetes cluster set up, which the runner
    connects to via the Kubernetes API.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个 Runner 注册到 Kubernetes 执行器时，它会在 Kubernetes 集群中的 Pod（即一个或多个容器的组合）中运行 CI/CD
    作业。这自然需要您已设置好 Kubernetes 集群，并通过 Kubernetes API 让 Runner 与之连接。
- en: 'At the time of writing, there are a few different ways that GitLab Runner can
    connect to a Kubernetes cluster:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在写作本文时，GitLab Runner 连接到 Kubernetes 集群的方式有几种不同的选择：
- en: GitLab offers an official **Helm chart** to deploy the Runner agent into a cluster.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitLab 提供了一个官方的 **Helm chart**，用于将 Runner 代理部署到集群中。
- en: GitLab also includes a broader method to connect a Kubernetes cluster to a GitLab
    instance, called **GitLab Agent for Kubernetes**. Once the GitLab instance is
    connected to a cluster, you can then use the agent to deploy a runner with the
    Kubernetes executor onto the cluster.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitLab 还包括一种更广泛的方法，将 Kubernetes 集群连接到 GitLab 实例，称为 **GitLab Agent for Kubernetes**。一旦
    GitLab 实例连接到集群，您就可以使用代理将带有 Kubernetes 执行器的 Runner 部署到集群中。
- en: GitLab is actively working on a tool called **GitLab Operator** that further
    automates the provisioning of GitLab resources in Kubernetes, using container
    management platforms such as Red Hat OpenShift. Operator will provide another
    method of deploying a runner with the Kubernetes executor to a cluster. While
    not yet recommended for production use, Operator can be used to effectively manage
    resources in your dev and test environments. Refer to the GitLab documentation
    for more details.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitLab 正在积极开发一个名为 **GitLab Operator** 的工具，进一步自动化在 Kubernetes 中配置 GitLab 资源，使用如
    Red Hat OpenShift 等容器管理平台。Operator 将提供另一种方法，将 Kubernetes 执行器与集群部署在一起。虽然目前尚不推荐在生产环境中使用，Operator
    可用于有效地管理开发和测试环境中的资源。有关更多详细信息，请参考 GitLab 文档。
- en: Ultimately, successfully working with container orchestrations requires a high
    degree of knowledge and experience in networking, storage, and security. If you
    or your team has Kubernetes expertise, the Kubernetes executor can be a powerful
    way to implement and scale a cloud-native CI/CD workflow. If not, it is better
    to stick with previously mentioned executors such as Docker.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，成功地使用容器编排需要对网络、存储和安全有很高的知识和经验。如果您或您的团队拥有 Kubernetes 专业知识，Kubernetes 执行器可以成为实现和扩展云原生
    CI/CD 工作流的强大方式。如果没有，最好还是坚持使用之前提到的执行器，如 Docker。
- en: The Docker Machine executor
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Docker Machine 执行器
- en: While the Docker executor provisions individual Docker containers for running
    CI/CD jobs, the Docker Machine executor provisions the entire host (VMs) that
    has Docker Engine instead. Those hosts themselves then support the launching of
    Docker containers. Docker Machine is normally used with a cloud provider with
    autoscaling, so you can quickly and flexibly launch container-compatible hosts
    as demand requires.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 执行器为每个 CI/CD 作业提供单独的 Docker 容器，而 Docker Machine 执行器则为整个拥有 Docker 引擎的主机（VMs）提供服务。这些主机本身支持启动
    Docker 容器。Docker Machine 通常与具有自动扩展功能的云提供商一起使用，因此您可以根据需求快速灵活地启动与容器兼容的主机。
- en: Note
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Docker (the company) is no longer actively developing Docker Machine in favor
    of Docker Desktop. GitLab maintains a fork of Docker Machine in order to continue
    supporting the Docker Machine executor.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Docker（公司）已不再积极开发 Docker Machine，而是支持 Docker Desktop。GitLab 维护 Docker Machine
    的分支以继续支持 Docker Machine 执行器。
- en: You can somewhat think of the Docker Machine executor as a combination of the
    VirtualBox/Parallels executor and the Docker executor, with additional autoscaling
    support included. Docker Machine can also be useful to ensure isolated resources
    for each job, by ensuring containers run on their own dedicated VMs. In fact,
    GitLab uses Docker Machine for its own Linux SaaS runners, offering users runners
    that are both scalable and properly isolated on the multi-tenant platform.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将 Docker Machine 执行器视为 VirtualBox/Parallels 执行器和 Docker 执行器的组合，还包括额外的自动扩展支持。Docker
    Machine 还可以用于确保每个作业的隔离资源，通过确保容器在其专用的 VM 上运行。事实上，GitLab 在其自身的 Linux SaaS Runner
    上使用 Docker Machine，为用户提供可扩展且在多租户平台上适当隔离的 Runner。
- en: The SSH executor
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SSH 执行器
- en: Sometimes you might want to run CI/CD jobs on a piece of infrastructure where,
    for technical or compliance reasons, you are unable to install GitLab Runner.
    If that infrastructure supports SSH access from a computer where you *can* install
    GitLab Runner, you can use the SSH executor to run CI/CD jobs on the remote host.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，您可能希望在一个基础设施上运行 CI/CD 作业，在该基础设施上，由于技术或合规性原因，无法安装 GitLab Runner。如果该基础设施支持从能够安装
    GitLab Runner 的计算机进行 SSH 访问，您可以使用 SSH 执行器在远程主机上运行 CI/CD 作业。
- en: When you register a GitLab runner using the SSH executor, you will also specify
    the remote host to run the CI/CD job, and the SSH identity file used to connect
    to that host. When the runner receives a CI/CD job, it will then “pipe” the commands
    over SSH so they are executed on the remote host. While the SSH executor currently
    only supports Bash commands and scripts, you might find it useful if you do not
    want to install the GitLab Runner program on every machine on which you want to
    run CI/CD jobs.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用 SSH 执行器注册 GitLab Runner 时，还将指定运行 CI/CD 作业的远程主机以及用于连接到该主机的 SSH 身份文件。当 Runner
    接收到 CI/CD 作业时，它将通过 SSH “管道” 命令，以便在远程主机上执行它们。尽管 SSH 执行器目前仅支持 Bash 命令和脚本，但如果您不希望在每台希望运行
    CI/CD 作业的机器上安装 GitLab Runner 程序，则可能会发现它很有用。
- en: 'So far, we’ve described the major components of GitLab runners: the GitLab
    Runner agent, its individual registered runner processes, and the executor each
    runner process might use to run its jobs. There is one more element of runner
    configuration worth discussing, and that is runner tags.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经描述了 GitLab Runner 的主要组件：GitLab Runner 代理，其各自注册的 Runner 进程，以及每个 Runner
    进程可能使用的执行器来运行其作业。还有一个值得讨论的 Runner 配置元素，那就是 Runner 标签。
- en: Runner tags restrict which runners can pick up which jobs
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Runner 标签限制了可以接收哪些作业的 Runner
- en: '`apache`, `rhel`, or `ios`. Tags can also represent the runner’s intended use
    in a certain stage in the CI/CD process, such as `build`, `staging`, or `prod`.
    When you also specify one or more tags in a CI/CD job definition, you can ensure
    that the runner has the proper tooling and environment needed to run that job.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`apache`，`rhel` 或 `ios`。标签还可以表示 Runner 在 CI/CD 过程中某个阶段的预期用途，例如 `build`，`staging`
    或 `prod`。当您在 CI/CD 作业定义中指定一个或多个标签时，可以确保 Runner 具有运行该作业所需的适当工具和环境。'
- en: 'For example, consider the example following job in a `.``gitlab-ci.yml` file:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 `.gitlab-ci.yml` 文件中的以下作业示例：
- en: '[PRE0]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `windows` and `staging` tags, as included in the CI/CD job definition, ensure
    that the `deploy-to-staging` job will only ever be assigned to runners that have
    both the `windows` and `staging` tags also assigned to them. By default, runners
    that have tags will not run untagged jobs – that is, jobs that do not have tags
    matching them to a certain tagged runner. This default can be overwritten in the
    runner’s settings, where you can permit tagged runners to run jobs that do not
    have tags, and therefore presumably do not care where they are run.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CI/CD 作业定义中包含的 `windows` 和 `staging` 标签，确保 `deploy-to-staging` 作业只会分配给同时具有
    `windows` 和 `staging` 标签的 runner。默认情况下，具有标签的 runner 不会运行没有标签的作业——即没有标签与某个特定标签
    runner 匹配的作业。这个默认设置可以在 runner 的设置中覆盖，你可以允许带标签的 runner 运行没有标签的作业，因此也不关心它们运行在哪里。
- en: Runner Tags ≠ Git Tags
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Runner 标签 ≠ Git 标签
- en: The word “tag” in GitLab can seem confusing because the term is used in a few
    different contexts. In this discussion, “tag” is simply a label put on runners
    that matches them to CI/CD jobs with the same tag or tags. These are not Git tags,
    which are descriptive labels placed on Git commits, and are also found in GitLab.
    Runner tags are unrelated to tags used in Git version control.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitLab 中，“标签”这个词可能会让人感到困惑，因为这个术语在不同的上下文中都有使用。在本讨论中，“标签”仅仅是一个附加在 runner 上的标签，用于将其与具有相同标签的
    CI/CD 作业匹配。这些标签与 Git 提交中使用的 Git 标签不同，后者是描述性标签，放置在 Git 提交中，也可以在 GitLab 中找到。Runner
    标签与 Git 版本控制中使用的标签无关。
- en: By now, we’ve covered all the essential information around GitLab runners, how
    they work conceptually, and the different supported platforms and executors. It
    is time to walk through the runner installation process.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了有关 GitLab runner 的所有基本信息，包括它们的工作原理以及支持的不同平台和执行器。现在是时候开始讲解 runner
    安装过程了。
- en: Installing the Runner agent
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Runner 代理
- en: 'This section will be most helpful if you follow along and install and register
    a runner on your own computer. You will find that the installation steps will
    differ slightly depending on your system type: Windows, macOS, Linux with a supported
    package manager, or a generic Linux system. Regardless of platform, the same two-step
    process holds:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你一边跟着操作，一边在自己的计算机上安装和注册 runner，那么本节内容将最为有用。你会发现，安装步骤会根据你的系统类型略有不同：Windows、macOS、具有支持的包管理器的
    Linux 或通用 Linux 系统。无论平台如何，都是相同的两步流程：
- en: Install the GitLab Runner agent.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 GitLab Runner 代理。
- en: Register a runner with GitLab.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 GitLab 中注册一个 runner。
- en: Installing GitLab Runner
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装 GitLab Runner
- en: As previously mentioned, the method of installation will differ slightly depending
    on your operating system. For major Linux distributions, the documentation ([https://docs.gitlab.com/runner/install/linux-repository.html](https://docs.gitlab.com/runner/install/linux-repository.html))
    will direct you to add the runner repository to your system, and then use your
    native package manager to install the `gitlab-runner` package. For Windows, macOS,
    and other Linux distros, you will use `curl` to get the program directly from
    GitLab, make it executable, then install and start the runner agent.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，安装方法会根据你的操作系统略有不同。对于主要的 Linux 发行版，文档（[https://docs.gitlab.com/runner/install/linux-repository.html](https://docs.gitlab.com/runner/install/linux-repository.html)）会指导你将
    runner 仓库添加到系统中，然后使用本地包管理器安装 `gitlab-runner` 包。对于 Windows、macOS 和其他 Linux 发行版，你将使用
    `curl` 直接从 GitLab 获取程序，设置可执行权限，然后安装并启动 runner 代理。
- en: 'Let’s take the example of a Red Hat Linux Enterprise server with an *x86_64*
    architecture and RPM-based package management system. The GitLab documentation
    directs us to first download and execute a shell script that adds the `gitlab-runner`
    repositories to our system’s package manager:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以一台具有 *x86_64* 架构和基于 RPM 包管理系统的 Red Hat Linux Enterprise 服务器为例。GitLab 文档指导我们首先下载并执行一个
    shell 脚本，该脚本会将 `gitlab-runner` 仓库添加到系统的包管理器中：
- en: '[PRE1]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you were to examine the content of the shell script, you would see that all
    it does is detect the operating system platform, and then run the relevant package
    management comment to add the `gitlab-runner` repository. You can verify that
    this step has been completed by checking your list of available repositories (`sudo
    dnf repolist` in RHEL). You should see `gitlab-runner` in the list alongside the
    primary OS repositories.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看该 shell 脚本的内容，会发现它的作用只是检测操作系统平台，然后运行相关的包管理命令来添加 `gitlab-runner` 仓库。你可以通过检查可用仓库列表（在
    RHEL 中使用 `sudo dnf repolist`）来验证此步骤是否完成。你应该能在列表中看到 `gitlab-runner`，与主要操作系统仓库一起列出。
- en: 'We’ve added the runner repository, but have not yet installed GitLab Runner.
    We can easily do so by installing the `gitlab-runner` package:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经添加了运行器库，但尚未安装GitLab Runner。我们可以通过安装`gitlab-runner`包轻松完成此操作：
- en: '[PRE2]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once the installation completes, GitLab Runner should automatically start in
    the background (you will need to manually start GitLab Runner if you installed
    it on Windows or macOS, or installed it manually on Linux). You can verify that
    the GitLab Runner agent is started and running with:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，GitLab Runner应该会自动在后台启动（如果你在Windows或macOS上安装了GitLab Runner，或者在Linux上手动安装了它，你需要手动启动GitLab
    Runner）。你可以通过以下命令验证GitLab Runner代理是否已启动并正在运行：
- en: '[PRE3]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You should see confirmation that the agent is running, and also that there are
    not yet any runners registered with GitLab. Registering runners is what we will
    do next.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到代理正在运行的确认信息，同时也会看到目前还没有任何运行器注册到GitLab。注册运行器将是我们接下来的步骤。
- en: Registering a runner with GitLab
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在GitLab中注册运行器
- en: We have so far installed the GitLab Runner agent on a computer, where it runs
    as a background service. However, there are not yet any runners communicating
    with GitLab. The way we set up runners to communicate with GitLab and run CI/CD
    jobs is by *registering* one or more runners.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在计算机上安装了GitLab Runner代理，并且它作为后台服务运行。但是，目前还没有任何运行器与GitLab进行通信。我们将通过*注册*一个或多个运行器来设置它们与GitLab进行通信并运行CI/CD任务。
- en: 'Recall the previous discussion on shared, specific, and group runners. When
    you register a runner with GitLab, you bind runners to an entire GitLab instance
    (shared runners), a group (group runners), or a project (specific runners). Registration
    instructions and runner settings after registration appear in the respective part
    of GitLab where you register the runner (instance, group, or project). For example,
    recalling *Figure 5**.2*, we see that we can find these details under **Settings**
    | **CI/CD** | **Runners** in the *Hats for* *Cats* project:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾之前讨论的共享、特定和组运行器。当你在GitLab中注册运行器时，你将运行器绑定到整个GitLab实例（共享运行器）、一个组（组运行器）或一个项目（特定运行器）。注册说明和注册后的运行器设置将在你注册运行器的GitLab相应部分（实例、组或项目）中出现。例如，回顾*图5.2*，我们可以在*Hats
    for Cats*项目中的**设置** | **CI/CD** | **运行器**下找到这些详细信息：
- en: '![Figure 5.4 – Project-level runner settings](img/Figure_5.04_B18073.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图5.4 – 项目级运行器设置](img/Figure_5.04_B18073.jpg)'
- en: Figure 5.4 – Project-level runner settings
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.4 – 项目级运行器设置
- en: 'In addition, take note of the registration token shown in *Figure 5**.4*. The
    runner registration token is generated by GitLab and is used by the runner to
    authenticate to the correct area of GitLab where it is registered:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意*图5.4*中显示的注册令牌。该运行器注册令牌由GitLab生成，并用于运行器身份验证，确保它注册到GitLab中的正确区域：
- en: If you are following along on a demo system, copy the registration token to
    your clipboard, as we will need it when we register a runner from the computer
    where we have GitLab Runner installed.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在演示系统中操作，请将注册令牌复制到剪贴板，因为在我们从安装了GitLab Runner的计算机注册运行器时需要使用它。
- en: 'Next, return to the computer where GitLab Runner is installed. From a Terminal
    session, run a prompt-based runner registration script:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，返回到安装了GitLab Runner的计算机。从终端会话中运行一个基于提示的运行器注册脚本：
- en: '[PRE4]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'GitLab will first prompt you for the URL of your GitLab application instance.
    For SaaS, this will be [https://gitlab.com](https://gitlab.com). Otherwise, it
    will be the URL you use to reach your self-managed instance. In this example,
    we will stick with `gitlab.com`:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GitLab首先会提示你输入GitLab应用实例的URL。对于SaaS版本，这将是[https://gitlab.com](https://gitlab.com)。否则，它将是你用来访问自托管实例的URL。在本示例中，我们将使用`gitlab.com`：
- en: '[PRE5]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, the script will ask for the runner registration token. This is the token
    shown in *Figure 5**.2* and will be different depending on the project or group
    with which you are registering a runner. Put another way, the registration token
    authenticates the runner to GitLab and ensures that it is registered to the correct
    project or group:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，脚本将要求输入运行器注册令牌。此令牌显示在*图5.2*中，并根据你注册运行器的项目或组而有所不同。换句话说，注册令牌用于验证运行器与GitLab的连接，确保它注册到正确的项目或组：
- en: '[PRE7]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can then provide an optional description that will show up in the runner’s
    metadata in the GitLab UI. This example might presume the runner is a Linux server
    where developers can build and test their code:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以提供一个可选的描述，该描述将在GitLab UI中显示在运行器的元数据中。此示例假设运行器是一个Linux服务器，开发人员可以在上面构建和测试他们的代码：
- en: '[PRE9]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The next message prompts you to enter any optional runner tags. Recall that
    tags are label metadata that you assign to a runner. Tags advertise the runner
    as being able to pick up CI/CD jobs that have those same tags. For example, a
    build job might include the `rhel` tag to indicate that the job requires tooling
    provided by Red Hat Linux. Only runners with that tag will be allowed to pick
    up the job. Tags can be assigned on runner registration, as shown here, and can
    also be modified via the runner settings in the GitLab UI:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个消息提示你输入任何可选的 runner 标签。回想一下，标签是你分配给 runner 的标签元数据。标签将 runner 宣传为能够接收具有相同标签的
    CI/CD 作业。例如，构建作业可能会包含 `rhel` 标签，表示该作业需要由 Red Hat Linux 提供的工具。只有具有该标签的 runner 才能接收此作业。标签可以在
    runner 注册时分配，如此处所示，也可以通过 GitLab UI 中的 runner 设置进行修改：
- en: '[PRE11]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The optional maintenance note is another area of descriptive metadata that
    doesn’t otherwise configure the runner behavior:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 可选的维护备注是另一种描述性元数据，不会配置 runner 的行为：
- en: '[PRE13]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'At this point in the script, the newly created runner process will reach out
    to GitLab to confirm that it can communicate and authenticate:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本的这一点，新创建的 runner 进程将与 GitLab 通信，以确认它能够进行通信和身份验证：
- en: '[PRE14]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Lastly, the runner will ask for the execution environment it should use to
    run CI/CD jobs. Also, remember that the executor depends on having the necessary
    tooling available; for example, selecting Docker requires that Docker Engine is
    installed and available on the server. In this example, we’ll select `Shell`,
    as it’s the easiest executor with which to get started and requires no dependencies:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，runner 会询问它应使用哪个执行环境来运行 CI/CD 作业。另外，请记住，执行器取决于是否具备必要的工具；例如，选择 Docker 需要在服务器上安装并可用
    Docker 引擎。在此示例中，我们将选择 `Shell`，因为它是最容易入门的执行器，且不需要依赖项：
- en: '[PRE15]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The script will finally confirm that runner registration has succeeded. A runner
    process is now running on the computer, managed by the local GitLab Runner agent,
    and ready to pick up a CI/CD job from the GitLab instance:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本最终会确认 runner 注册成功。现在，runner 进程正在计算机上运行，由本地 GitLab Runner 代理管理，并准备从 GitLab
    实例接收 CI/CD 作业：
- en: '[PRE17]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can verify successful registration and communication in a couple of ways.
    From where GitLab Runner is installed, you can view the configured runners with
    the following command:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过几种方式验证注册和通信是否成功。在安装 GitLab Runner 的地方，可以使用以下命令查看已配置的 runner：
- en: '[PRE19]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: A runner with a description of `Linux dev server` is listed, along with its
    executor, registration token, and the GitLab instance the runner is registered
    to.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 列出了描述为 `Linux dev server` 的 runner，以及其执行器、注册令牌和 runner 注册的 GitLab 实例。
- en: 'We can also verify that the runner is properly registered from the GitLab side.
    The runner we just registered is registered with our *Hats for Cats* project.
    *Figure 5**.5* shows that if we return to the project via `Linux dev runner` registered
    and available to the project:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以从 GitLab 端验证 runner 是否正确注册。我们刚刚注册的 runner 已经注册到我们的*Hats for Cats*项目中。*图
    5.5* 显示，如果我们返回项目，通过 `Linux dev runner` 注册并可用于该项目：
- en: '![Figure 5.5 – Specific runner successfully registered with GitLab](img/Figure_5.05_B18073.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 特定 runner 成功注册到 GitLab](img/Figure_5.05_B18073.jpg)'
- en: Figure 5.5 – Specific runner successfully registered with GitLab
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 特定 runner 成功注册到 GitLab
- en: The GitLab UI shows a couple of other interesting features from our specific
    runner. The `dev` and `rhel` tags are shown alongside the runner ID and description.
    The lock icon next to the runner ID indicates that the runner is locked to the
    specific project to which it is registered, and it cannot be assigned to other
    projects. The pencil icon will take us to runner settings that we can adjust in
    the GitLab UI, and the pause button will “pause” the runner. Pausing the runner
    will keep it registered with GitLab, but will prevent the runner from accepting
    new jobs while it is paused.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab UI 显示了我们特定 runner 的一些其他有趣特性。`dev` 和 `rhel` 标签显示在 runner ID 和描述旁边。runner
    ID 旁边的锁图标表示该 runner 已锁定到特定项目，不能分配给其他项目。铅笔图标将带我们进入 GitLab UI 中可调整的 runner 设置，暂停按钮则会“暂停”该
    runner。暂停 runner 会使其保持在 GitLab 中注册，但会阻止它在暂停时接受新作业。
- en: 'We can view existing runner settings and statistics by clicking on the hyperlinked
    runner ID. *Figure 5**.6* shows information from the runner we registered earlier,
    which can be viewed in the GitLab UI. This information includes the runner’s architecture
    and networking details, its activity status, and assignable attributes such as
    runner tags, its protected or unprotected status, description, and ability to
    be assigned to other projects:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过点击超链接的运行器 ID 来查看现有的运行器设置和统计信息。*图 5.6* 显示了我们之前注册的运行器信息，可以在 GitLab UI 中查看。这些信息包括运行器的架构和网络详情、活动状态，以及可分配的属性，如运行器标签、是否受保护、描述和是否可以分配给其他项目：
- en: '![Figure 5.6 – Runner information in the GitLab UI](img/Figure_5.06_B18073.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – GitLab UI 中的运行器信息](img/Figure_5.06_B18073.jpg)'
- en: Figure 5.6 – Runner information in the GitLab UI
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – GitLab UI 中的运行器信息
- en: If we return to the runner settings (as shown in *Figure 5**.5*) and select
    the edit (pencil) icon, we arrive at a page that shows additional runner details
    as well as attributes we can set from the UI. These settings include protecting
    the runner and modifying the description and runner tags, as shown in *Figure
    5**.7*.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们返回到运行器设置页面（如*图 5.5*所示），并选择编辑（铅笔）图标，我们将进入一个页面，显示额外的运行器详情以及我们可以从 UI 设置的属性。这些设置包括保护运行器、修改描述和运行器标签，如*图
    5.7*所示。
- en: The maximum job timeout field tells the runner to report a job as failed by
    default after a certain period elapses. Be careful with this option; if you set
    it, make sure it is a value larger than the maximum amount of time you would expect
    one of your builds to take.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 最大作业超时字段默认情况下告诉运行器在一定时间后报告作业失败。使用此选项时要小心；如果设置了该选项，请确保其值大于你期望一个构建所需的最大时间。
- en: '![Figure 5.7 – Runner settings in the GitLab UI](img/Figure_5.07_B18073.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7 – GitLab UI 中的运行器设置](img/Figure_5.07_B18073.jpg)'
- en: Figure 5.7 – Runner settings in the GitLab UI
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – GitLab UI 中的运行器设置
- en: At this point, your runner is registered, active, and ready to start picking
    up CI/CD jobs. The topic we will next turn to is considerations around the runner
    configurations and executors based on your or your organization’s needs.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，您的运行器已注册、处于活动状态，并准备开始接收 CI/CD 作业。接下来我们将讨论基于你或你组织需求的运行器配置和执行器的相关考虑。
- en: Considerations regarding the various runner types and executors
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于各种运行器类型和执行器的考虑因素
- en: We’ve learned that there are many types of runners, configuration options, and
    execution environments. In this section, we will discuss some performance, security,
    and monitoring considerations to help guide your decision-making regarding which
    runners to use, and when to use them.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解到，存在许多类型的运行器、配置选项和执行环境。在本节中，我们将讨论一些性能、安全性和监控方面的考虑，以帮助你在决定使用哪些运行器以及何时使用它们时作出决策。
- en: Performance considerations
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能考虑
- en: As a developer or operator, you want to make sure that pipelines run as efficiently
    as possible. Key performance considerations around CI/CD job execution are runner
    availability and resources, repository size, and how you handle job and application
    dependencies.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发人员或运维人员，你希望确保管道尽可能高效地运行。关于 CI/CD 作业执行的关键性能考虑因素包括运行器的可用性和资源、代码库的大小，以及如何处理作业和应用程序的依赖关系。
- en: Runner availability
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 运行器可用性
- en: 'Consider the three scopes of runners discussed earlier in this chapter:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 请考虑本章前面讨论的三种运行器作用域：
- en: Shared runners configured at this instance level (if using self-managed GitLab),
    available to all projects in the instance
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在此实例级别配置的共享运行器（如果使用自托管的 GitLab），可供该实例中的所有项目使用
- en: Group runners available to all projects in a group and its subgroups
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 群组运行器可供群组及其子群组中的所有项目使用
- en: Specific runners registered only to designated projects
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅注册到指定项目的特定运行器
- en: The way each of the types of runners handles CI/CD jobs can affect pipeline
    efficiency and execution times. Specific runners are a fairly straightforward
    case. Use specific runners when you know you need dedicated resources for a project.
    That said, you may gain pipeline efficiency at the expense of the efficient use
    of resources. Idle server time can be a consequence of widely using specific runners.
    Moreover, pooling resources together in group and shared runners can also allow
    you to take advantage of autoscaling features offered by cloud services in a way
    that may not be economically feasible with specific runners. So, if your application’s
    resource use and demand are predictable, look to use specific runners. If you
    expect fluctuation in resource requirements, consider group or shared runners.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 每种类型的 runner 处理 CI/CD 作业的方式会影响管道效率和执行时间。特定 runner 是一个相对直接的例子。当你知道需要为某个项目分配专用资源时，应使用特定
    runner。也就是说，你可能会在提高管道效率的同时牺牲资源的高效利用。广泛使用特定 runner 可能导致服务器空闲时间增加。此外，将资源整合到组和共享
    runner 中，也能让你利用云服务提供的自动扩展功能，这在使用特定 runner 时可能在经济上不可行。因此，如果你的应用资源使用和需求是可预测的，应该使用特定
    runner。如果你预计资源需求会波动，则可以考虑使用组 runner 或共享 runner。
- en: Regarding group and shared runners, they may appear to be roughly equivalent
    in practice, especially if your GitLab instance has a single top-level group storing
    all your projects. However, group and shared runners are quite different in the
    way they pick up their respective jobs. Group runners process jobs on a FIFO basis.
    This means a single resource-intensive pipeline can “hog” a set of group runners
    as its jobs are queued, especially if there are many jobs in a single stage.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 关于组和共享 runner，它们在实际操作中可能看起来差不多，尤其是当你的 GitLab 实例有一个顶级组来存储所有项目时。然而，组 runner 和共享
    runner 在获取各自作业的方式上有很大不同。组 runner 按照 FIFO（先进先出）原则处理作业。这意味着一个资源密集型的管道可能会“占用”一组组
    runner，因为它的作业在队列中排队，尤其是当一个阶段有很多作业时。
- en: Specific runners, on the other hand, operate via a fair usage queue. That is,
    projects on the GitLab instance with the fewest jobs already using shared runners
    are given priority. That may be desirable in some cases, as it suggests more equitable
    pipeline execution across all your projects in GitLab. In practice, some projects
    may be more important than others, and you will want those projects to have priority
    execution, where pending jobs aren’t sent to the back of the line because others
    in the project have already run. In that case, group runners with their FIFO assignment
    may be your best bet.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，特定 runner 通过公平使用队列操作。也就是说，GitLab 实例中作业最少的项目将优先使用共享 runner。这在某些情况下可能是期望的，因为它意味着你在
    GitLab 中的所有项目将得到更公平的管道执行。然而，实际上，某些项目可能比其他项目更为重要，你会希望这些项目得到优先执行，避免因为其他项目的作业已经运行而导致待处理作业被排到队尾。在这种情况下，组
    runner 按 FIFO 分配可能是最好的选择。
- en: Repository size
  id: totrans-204
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码库大小
- en: GitLab’s documentation describes a “large” repository as containing more than
    50,000 files in the working tree (that is, in the collection of checked-out files).
    When repositories are large, a rate-limiting step in the pipeline can be the runner
    cloning or fetching the project repository.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab 文档将“大型”代码库定义为工作树中包含超过 50,000 个文件的代码库（即，已检出的文件集合）。当代码库较大时，管道中的限速步骤可能是
    runner 克隆或拉取项目代码库。
- en: GitLab Runner already has some optimizations in place to minimize the time and
    resources it takes to pull down project files. If the project has previously been
    cloned to the runner’s execution environment, the runner will perform an incremental
    fetch so that the entire repository isn’t pulled down for each job. Moreover,
    runners will by default perform a shallow clone, copying down only the latest
    20 commits from the project (this setting can be adjusted with the `GIT_DEPTH`
    variable in your `.``gitlab-ci.yml` file).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab Runner 已经对拉取项目文件的时间和资源进行了优化。如果项目已经被克隆到 runner 的执行环境中，runner 会执行增量拉取，这样就不需要为每个作业都拉取整个代码库。此外，默认情况下，runner
    会执行浅克隆，只复制项目的最新 20 次提交（这个设置可以通过 `.gitlab-ci.yml` 文件中的 `GIT_DEPTH` 变量进行调整）。
- en: For some more advanced configuration, you can use the `pre_clone_script` keyword
    in your `.gitlab-ci.yml` file to set Git configuration commands that run before
    the runner clones the repository.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些更高级的配置，你可以在 `.gitlab-ci.yml` 文件中使用 `pre_clone_script` 关键字，设置在 runner 克隆代码库之前执行的
    Git 配置命令。
- en: Caching dependencies
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存依赖
- en: The considerations around dependency and artifact caching are conceptually similar
    to the discussion around large repositories. The idea is that we want to minimize
    the need for runners to repeatedly download the same files, and download only
    the files they need for the CI/CD job currently assigned to the runner.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖关系和工件缓存的考虑概念上类似于大仓库的讨论。其核心思想是，我们希望尽量减少 runner 重复下载相同文件的需求，只下载当前分配给 runner
    的 CI/CD 作业所需的文件。
- en: The `cache` keyword in `.gitlab-ci.yml` is where you specify file paths that
    should remain on the runner between jobs. We recommend combining the `cache` keyword
    with runner tags so that jobs such as tooling are assigned to runners that have
    those dependencies pre-cached.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`.gitlab-ci.yml` 中的 `cache` 关键字是指定应在作业之间保留在 runner 上的文件路径。我们建议将 `cache` 关键字与
    runner 标签结合使用，这样像工具链之类的作业可以分配给那些已经预缓存这些依赖的 runner。'
- en: By default, each runner will also download all artifacts for every job that
    has previously run in that pipeline. You can use the `dependencies` keyword to
    select which jobs’ artifacts should be downloaded. For example, if you have separate
    Windows and Linux build jobs, and separate test jobs for your Windows and Linux
    builds, it makes sense for the test jobs to only download the artifacts from their
    respective build job.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，每个 runner 还会下载该管道中之前运行的每个作业的所有工件。你可以使用 `dependencies` 关键字来选择需要下载哪些作业的工件。例如，如果你有分别针对
    Windows 和 Linux 的构建作业，并且有独立的 Windows 和 Linux 构建的测试作业，那么测试作业应该只下载各自构建作业的工件。
- en: Finally, if your pipelines are container-based, you might spend heavy amounts
    of networking resources pulling container images from public registries to run
    your jobs. GitLab has a feature called Dependency Proxy, where you can configure
    a local registry to cache Docker images, so the runner executor does not need
    to pull from a public source on each run. Rather, the runner will pull from the
    local registry, and pulling from the public source will only need to take place
    for updating the container versions in the cache.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你的管道是基于容器的，你可能会消耗大量的网络资源，从公共注册表拉取容器镜像来运行任务。GitLab 有一个名为 Dependency Proxy
    的功能，允许你配置本地注册表来缓存 Docker 镜像，这样 runner 执行器就不需要在每次运行时从公共源拉取。相反，runner 会从本地注册表拉取，只有在更新缓存中的容器版本时才需要从公共源拉取。
- en: Security considerations
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全性考虑
- en: There is far more to discuss concerning security and GitLab than can be covered
    in this book. However, two considerations are immediately implicated by your choices
    in installing and configuring runners. Those considerations are the choice of
    runner executor, and how you handle secrets in your CI/CD pipelines.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有关安全性和 GitLab 的内容远远超出了本书所能涵盖的范围。然而，你在安装和配置 runners 时会涉及到两个直接相关的考虑因素。它们是选择 runner
    执行器，以及你如何在 CI/CD 管道中处理机密信息。
- en: Your choice of runner executor
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 你选择的 runner 执行器
- en: Remember that CI/CD pipelines are fundamentally the execution of commands on
    a remote host – that is, hosts where GitLab Runner is installed. You, therefore,
    run the inherent risk of performing operations not just on your source code but
    also on the underlying infrastructure hosting the runner.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，CI/CD 管道本质上是在远程主机上执行命令——也就是说，在安装了 GitLab Runner 的主机上。因此，你面临的固有风险不仅是对源代码进行操作，还包括对承载
    runner 的底层基础设施进行操作。
- en: In general, some runner executers can be thought of as “safer” than others.
    Using the shell executor, while convenient, exposes your server’s filesystem to
    the runner, and operations performed against the filesystem may persist across
    jobs. For example, a CI/CD pipeline job for project A might be able to access
    files from project B if a pipeline for project B recently used that same runner.
    The `gitlab-runner` user will run under the authority of whichever user registered
    the runner. If `sudo` was used for registration, that means the runner will have
    full root access. Therefore, we recommend using the shell executor only for specific
    runners in projects you trust.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 通常来说，一些 runner 执行器可以被认为比其他执行器“更安全”。尽管 shell 执行器使用起来方便，但它暴露了服务器的文件系统给 runner，而对文件系统进行的操作可能会跨作业持续存在。例如，项目
    A 的 CI/CD 管道作业可能会访问项目 B 的文件，如果项目 B 最近使用了相同的 runner。`gitlab-runner` 用户将在注册 runner
    的用户权限下运行。如果注册时使用了 `sudo`，这意味着 runner 将具有完整的 root 权限。因此，我们建议仅在你信任的项目中的特定 runner
    上使用 shell 执行器。
- en: The Docker executor can be thought of as somewhat safer because containers are
    an additional abstraction layer away from the host system. The runner clones project
    code and runs job commands inside an isolated container, and then tears down the
    container after reporting the results back to GitLab. Of critical importance,
    though, is making sure the containers run in unprivileged mode. That is, the jobs
    must be run by non-root users to ensure job execution does not involve access
    to the host system.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 执行器可以被认为是相对更安全的，因为容器为主机系统提供了一个额外的抽象层。运行器会克隆项目代码并在隔离的容器中运行作业命令，随后在将结果报告回
    GitLab 后销毁该容器。至关重要的是，确保容器以非特权模式运行。也就是说，作业必须由非 root 用户运行，以确保作业执行过程中不会涉及主机系统的访问。
- en: The VirtualBox/Parallels executor can be considered among the safest of the
    runner executors because jobs are run inside an ephemeral VM with an isolated
    OS and filesystem. CI/CD jobs will not have access to the underlying hypervisor,
    and there is minimal risk of information unintentionally being shared between
    jobs. Consider using these executors if you are otherwise unsure of your ability
    to secure shell or Docker environments.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: VirtualBox/Parallels 执行器可以被认为是最安全的运行器之一，因为作业在具有隔离操作系统和文件系统的临时虚拟机中运行。CI/CD 作业无法访问底层的虚拟化管理程序，并且作业之间不太可能意外共享信息。如果你对保护
    shell 或 Docker 环境的能力没有信心，可以考虑使用这些执行器。
- en: Secret management
  id: totrans-220
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 秘密管理
- en: Managing secrets and avoiding their unintentional disclosure is a topic with
    a larger scope than the focus of this chapter. However, because runners receive
    both repository information and environment variables from GitLab, it is important
    to understand how poor secret management can cause your runners to be a vector
    for exposing sensitive information.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 管理密钥并避免它们被意外泄露是一个范围较广的主题，超出了本章的重点。然而，由于运行器从 GitLab 获取仓库信息和环境变量，因此理解糟糕的秘密管理可能导致运行器成为泄露敏感信息的途径至关重要。
- en: Never, under any circumstances, hardcode secrets (passwords, cloud credentials,
    deploy keys, and so on) into your project repository. The nature of Git version
    control is that once information is committed to the project, it is a part of
    the repository’s immutable snapshot history. Simply removing the secret with a
    future commit does not remove it from previous commits. Because runners clone
    project repositories with a certain depth of historic snapshots, secrets accidentally
    left in a project are propagated to the runner infrastructure.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 无论在任何情况下，都不要将密钥（密码、云凭证、部署密钥等）硬编码到项目仓库中。Git 版本控制的特性是，一旦信息被提交到项目中，它就成为仓库不可变快照历史的一部分。仅仅通过未来的提交删除该密钥并不会将其从之前的提交中移除。由于运行器会以一定深度的历史快照克隆项目仓库，意外遗留在项目中的密钥会被传播到运行器基础设施中。
- en: '[*Chapter 7*](B18073_07.xhtml#_idTextAnchor162) will cover how you can use
    GitLab’s Secret Detection tool to perform historic scans on your repository for
    potentially hardcoded secrets. Ultimately, the solution to the “I accidentally
    committed sensitive information” problem is to consider that information irrevocably
    exposed, and to therefore reset or rotate the affected credentials or keys.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '[*第 7 章*](B18073_07.xhtml#_idTextAnchor162)将介绍如何使用 GitLab 的秘密检测工具对你的仓库进行历史扫描，以查找可能硬编码的密钥。最终，解决“我不小心提交了敏感信息”问题的办法是考虑该信息已不可挽回地暴露，因此需要重置或轮换受影响的凭证或密钥。'
- en: A similar situation arises with CI/CD variables. Variables used in GitLab CI/CD
    are exported as environment variables to a runner’s shell session. Unmasked and
    unprotected variables that store secrets run the risk of ending up on runners
    that execute untrusted builds. To guard against this possibility, store variables
    as masked and protected variables at the project or group level, ensuring they
    can only be used on protected branches, and ensuring their values are not exposed
    on the runners.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD 变量也会出现类似情况。GitLab CI/CD 中使用的变量作为环境变量导出到运行器的 shell 会话中。未掩码和未保护的存储密钥的变量存在被执行不可信构建的运行器泄露的风险。为了防止这种情况，应该将变量存储为掩码和受保护的变量，且仅能在受保护分支上使用，并确保它们的值不会在运行器上暴露。
- en: Monitoring considerations
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 监控考虑
- en: Recall that GitLab Runner runs as a separate application on infrastructure outside
    the GitLab instance. Monitoring the data around your runners and pipelines is
    essential to ensure proper security and resource utilization.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，GitLab Runner 作为一个独立的应用程序运行在 GitLab 实例之外的基础设施上。监控你的运行器和管道的数据对于确保正确的安全性和资源利用率至关重要。
- en: 'The three key areas of consideration around monitoring your runners are as
    follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 监控runner时需要考虑的三个关键领域如下：
- en: The analytics available in the Gitlab UI
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitLab UI中的分析
- en: The runner logging system
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Runner日志系统
- en: The exportable metrics produced by the runners themselves
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由runner本身产生的可导出指标
- en: Self-managed GitLab has in-depth logging and monitoring facilities. Most monitoring
    can be managed by the built-in Prometheus server, and logs can be exported to
    aggregation systems such as **Splunk**. Similarly, GitLab Runner generates log
    entries that can be managed in the local operating system as well as by external
    or web-based tools.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 自托管的GitLab提供了深入的日志记录和监控功能。大部分监控可以由内置的Prometheus服务器管理，日志也可以导出到诸如**Splunk**之类的聚合系统。同样，GitLab
    Runner生成的日志条目可以在本地操作系统中进行管理，也可以由外部或基于Web的工具进行管理。
- en: GitLab UI analytics
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GitLab UI分析
- en: 'General CI/CD analytics can be found at the project level under **Analytics**
    | **CI/CD**. *Figure 5**.8* shows statistics for the public GitLab project hosted
    on [GitLab.com](http://GitLab.com):'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 一般的CI/CD分析可以在项目级别的**Analytics** | **CI/CD**下找到。*图 5.8*展示了托管在[GitLab.com](http://GitLab.com)上的公共GitLab项目的统计数据：
- en: '![Figure 5.8 – CI/CD analytics for the GitLab project](img/Figure_5.08_B18073.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8 – GitLab项目的CI/CD分析](img/Figure_5.08_B18073.jpg)'
- en: Figure 5.8 – CI/CD analytics for the GitLab project
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – GitLab项目的CI/CD分析
- en: The metrics shown in the UI here only account for general pipeline trends, namely
    overall pipeline success and failure rates. However, this data can serve as a
    useful starting point from which you can determine whether pipeline failures are
    caused by logic errors in source code or issues with the underlying infrastructure
    (that is, your runners). If runners appear to be the culprit, you can then dive
    deeper into runner-specific logs and metrics, as discussed in the next few paragraphs.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这里在UI中显示的指标仅反映了一般的流水线趋势，即整体流水线的成功和失败率。然而，这些数据可以作为一个有用的起点，帮助你判断流水线失败是由于源代码中的逻辑错误，还是由于底层基础设施（即你的runner）的问题。如果runner是罪魁祸首，你可以进一步深入到runner特定的日志和指标，正如接下来几段所讨论的。
- en: Runner logging
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Runner日志
- en: GitLab Runner does not have a dedicated log file. Rather, messages are published
    to the general system log file. Normally that would be `/var/log/syslog` in Debian-flavored
    operating systems (such as Ubuntu) and `/var/log/messages` in Fedora-flavored
    operating systems (such as Red Hat Linux). Errors in the runner service, its configuration,
    or its ability to communicate with GitLab will be logged in these files.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab Runner没有专用的日志文件。相反，消息会发布到常规系统日志文件中。在Debian系列操作系统（如Ubuntu）中，这通常是`/var/log/syslog`，在Fedora系列操作系统（如Red
    Hat Linux）中，是`/var/log/messages`。关于runner服务、其配置或与GitLab通信能力的错误会被记录在这些文件中。
- en: 'A useful way to confirm that the runner has a valid configuration and that
    it can communicate properly with GitLab is to run the `gitlab-runner verify` command
    as shown:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 确认runner配置有效且能够与GitLab正常通信的一个有用方法是运行`gitlab-runner verify`命令，如下所示：
- en: '[PRE20]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding output, you can verify the runner’s architecture, version,
    process ID, registration ID, and ability to talk to GitLab.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的输出中，你可以验证runner的架构、版本、进程ID、注册ID以及与GitLab通信的能力。
- en: Runner Prometheus metrics
  id: totrans-242
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Runner Prometheus指标
- en: Self-managed GitLab has in-depth logging and monitoring facilities. Most monitoring
    can be managed by the built-in Prometheus server. Similarly, GitLab Runner includes
    an embedded HTTP server that can advertise its metrics to an available Prometheus
    server.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 自托管的GitLab提供了深入的日志记录和监控功能。大部分监控可以由内置的Prometheus服务器管理。同样，GitLab Runner包括一个嵌入式HTTP服务器，可以将其指标公布到一个可用的Prometheus服务器。
- en: 'In order to expose the runner’s metrics, you first need to edit the runner’s
    main configuration file, `config.toml`, which can normally be found in `/etc/gitlab-runner`.
    Add the `listen_address` parameter to tell the metrics server which port to listen
    on. An example `config.toml` file with the `listen_address` parameter added may
    look like this:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 为了暴露runner的指标，你首先需要编辑runner的主配置文件`config.toml`，该文件通常可以在`/etc/gitlab-runner`找到。添加`listen_address`参数来告知指标服务器监听哪个端口。一个添加了`listen_address`参数的`config.toml`文件示例如下：
- en: '[PRE21]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: After you edit the configuration file, restart the GitLab Runner service with
    `sudo gitlab-runner restart`. An available Prometheus server will then be able
    to read in and instrument the runner metrics.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑配置文件后，使用`sudo gitlab-runner restart`重启GitLab Runner服务。然后，合适的Prometheus服务器将能够读取并记录runner的指标。
- en: Summary
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we described the part that runners play in GitLab CI/CD pipelines.
    We learned that runners can be thought of as the “muscle” of CI/CD executing jobs
    specified in `.gitlab-ci.yml`. Runners can be installed as standalone programs
    on most computer platforms and can be shared with all projects in GitLab, or with
    only certain projects or groups. Moreover, wherever you have a runner installed,
    you can choose the execution environment it uses to run CI/CD tasks.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们描述了在 GitLab CI/CD 流水线中运行者的角色。我们了解到，运行者可以被视为执行 `.gitlab-ci.yml` 中指定的作业的“肌肉”。运行者可以作为独立程序安装在大多数计算机平台上，并且可以与
    GitLab 中的所有项目或仅特定项目或组共享。此外，无论在何处安装了运行者，您都可以选择它用于运行 CI/CD 任务的执行环境。
- en: Regardless of your role, it is helpful to understand how runner settings can
    affect pipeline performance, application security, and observability in the development
    life cycle. We encourage you to practice the process of installing and registering
    runners, even if maintaining the runner infrastructure is not part of your day-to-day
    responsibilities. A confident knowledge level of runner architecture and workflows
    will make you a better software practitioner as you continue your GitLab journey.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 无论您的角色如何，了解运行者设置如何影响流水线性能、应用程序安全性以及开发生命周期中的可观察性都是有帮助的。我们鼓励您练习安装和注册运行者的过程，即使维护运行者基础设施并不是您日常职责的一部分。对运行者架构和工作流程的自信了解将使您成为更好的软件实践者，因为您继续您的
    GitLab 之旅。
- en: The next chapter will build upon what we’ve learned so far and will introduce
    you to building out a robust test infrastructure using GitLab CI/CD. Application
    verification, and later, security, will serve as core topics whose coverage will
    enable you to continuously improve the efficiency, sustainability, and security
    of your DevOps workflows.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将在我们所学的基础上进行扩展，并向您介绍如何使用 GitLab CI/CD 构建强大的测试基础设施。应用程序验证以及稍后的安全性将作为核心主题，覆盖这些内容将使您能够不断提高
    DevOps 工作流的效率、可持续性和安全性。
