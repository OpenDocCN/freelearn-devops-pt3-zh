<html><head></head><body>
		<div id="_idContainer123">
			<h1 id="_idParaDest-204"><em class="italic"><a id="_idTextAnchor203"/>Chapter 8</em>: Managing Dependencies Using GitHub Packages</h1>
			<p>Using a package registry to manage your dependencies should be an absolute no-brainer. If you are writing .NET, you use NuGet, if you are writing JavaScript, it's probably npm, and if you are using Java, it's Maven or Gradle. And yet, I meet many teams that still use their filesystem or Git submodules to reuse code files in multiple code bases. Or they build assemblies and store them in source control. Moving to packages with <strong class="bold">semantic versioning</strong> is easy and cheap, and it boosts the quality and discoverability of your shared code.</p>
			<p>In this chapter, I show you how you can use GitHub Packages to manage your internal dependencies like you manage your software supply chain. The main topics are as follows:</p>
			<ul>
				<li>GitHub Packages</li>
				<li>Using npm packages with Actions</li>
				<li>Using Docker with Packages</li>
				<li>Apache Maven, Gradle, NuGet, and RubyGems packages<p class="callout-heading">Semantic Versioning</p><p class="callout"><strong class="bold">Semantic versioning</strong> is <a id="_idIndexMarker529"/>a formal convention for specifying version numbers for software. It consists of different parts with different meanings. Examples of semantic version numbers are <strong class="source-inline">1.0.0</strong> or <strong class="source-inline">1.5.99-beta</strong>. The format is as follows:</p><p class="callout"><strong class="source-inline">&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;-&lt;pre&gt;</strong></p><p class="callout"><strong class="bold">Major version</strong>: A<a id="_idIndexMarker530"/> numeric identifier that gets increased if the version is not backward compatible and has breaking changes. An update to a new major version must be handled with caution! A major version of zero is for the initial development.</p><p class="callout"><strong class="bold">Minor version</strong>: A <a id="_idIndexMarker531"/>numeric identifier that gets increased if new features are added but the version is backward compatible with the previous version and can be updated without breaking anything if you need the new functionality.</p><p class="callout"><strong class="bold">Patch</strong>: A <a id="_idIndexMarker532"/>numeric identifier that gets increased if you release bug fixes that are backward compatible. New patches should always be installed.</p><p class="callout"><strong class="bold">Pre-version</strong>: A <a id="_idIndexMarker533"/>text identifier that is appended using a hyphen. The identifier must only use ASCII alphanumeric characters and hyphens (<strong class="source-inline">[0-9A-Za-z-]</strong>).  The longer the text, the smaller the pre-version (meaning <strong class="source-inline">-alpha</strong> &lt; <strong class="source-inline">-beta</strong> &lt; <strong class="source-inline">-rc</strong>). A pre-release version is always smaller than a normal version (<strong class="source-inline">1.0.0-alpha</strong> &lt; <strong class="source-inline">1.0.0</strong>).</p><p class="callout">See <a href="https://semver.org/">https://semver.org/</a> for the complete specification.</p></li>
			</ul>
			<p>Using packages does not automatically mean you are using a loosely coupled architecture. Packages are, in most cases, still hard dependencies. It depends on how you use the packages to really decouple your release cadence.</p>
			<h1 id="_idParaDest-205"><a id="_idTextAnchor204"/>GitHub Packages</h1>
			<p><strong class="bold">GitHub Packages</strong> is <a id="_idIndexMarker534"/>a platform for hosting and managing your packages, containers, and other dependencies.</p>
			<p>You can integrate GitHub Packages with GitHub Actions, the GitHub APIs, and webhooks. This allows you to create an end-to-end workflow to release and consume your code.</p>
			<p>GitHub Packages currently supports the following registries:</p>
			<ul>
				<li><strong class="bold">Container</strong> registry<a id="_idIndexMarker535"/> supporting <strong class="bold">Docker</strong> and <strong class="bold">OCI</strong> images</li>
				<li><strong class="bold">npm</strong> registry <a id="_idIndexMarker536"/>for JavaScript using npm (<strong class="source-inline">package.json</strong>)</li>
				<li><strong class="bold">NuGet</strong> registry <a id="_idIndexMarker537"/>for .NET (<strong class="source-inline">nupkg</strong>)</li>
				<li><strong class="bold">Apache Maven</strong> registry<a id="_idIndexMarker538"/> for Java (<strong class="source-inline">pom.xml</strong>)</li>
				<li><strong class="bold">Gradle</strong> registry<a id="_idIndexMarker539"/> for Java (<strong class="source-inline">build.gradle</strong>)</li>
				<li><strong class="bold">RubyGems</strong> registry <a id="_idIndexMarker540"/>for Ruby (<strong class="source-inline">Gemfile</strong>)</li>
			</ul>
			<h2 id="_idParaDest-206"><a id="_idTextAnchor205"/>Pricing</h2>
			<p>Packages <a id="_idIndexMarker541"/>are free for public packages. For private packages, each GitHub version includes a certain amount of storage and data transfer. Any usage beyond that amount is charged separately and can be controlled using spending limits.</p>
			<p>Monthly billed customers have a default spending limit of $0 US dollars, which prevents additional usage of storage or data transfer. Invoiced customers have an unlimited default spending limit.</p>
			<p>The amount of included storage and data transferred for each product is listed in <em class="italic">Table 8.1</em>:</p>
			<div>
				<div id="_idContainer118" class="IMG---Figure">
					<img src="image/Table_8.1.jpg" alt="Table 8.1 – Included storage and data transfer for Packages in GitHub products&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 8.1 – Included storage and data transfer for Packages in GitHub products</p>
			<p>All <a id="_idIndexMarker542"/>outbound data transfer is free when triggered by GitHub Actions. All inbound data transfer from any source is also free.</p>
			<p>When the included limits are reached, the following costs are charged:</p>
			<ul>
				<li><strong class="bold">Storage</strong>: $0.25 USD per GB</li>
				<li><strong class="bold">Data Transfer</strong>: $0.50 USD per GB</li>
			</ul>
			<p>For more details on pricing, see <a href="https://docs.github.com/en/billing/managing-billing-for-github-packages/about-billing-for-github-packages">https://docs.github.com/en/billing/managing-billing-for-github-packages/about-billing-for-github-packages</a>.</p>
			<h2 id="_idParaDest-207"><a id="_idTextAnchor206"/>Permissions and visibility</h2>
			<p>A package<a id="_idIndexMarker543"/> that is published to a repository inherits the permissions and visibility of the repository that owns the package. Currently, only container packages offer granular permissions and access control (see <em class="italic">Figure 8.1</em>).</p>
			<div>
				<div id="_idContainer119" class="IMG---Figure">
					<img src="image/B17827_08_01.jpg" alt="Figure 8.1 – Managing access to container packages&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.1 – Managing access to container packages</p>
			<p>All other package types follow the repository access for repository-scoped packages. At the organization level, packages are private with write permissions for owners and read permissions for members.</p>
			<p>If you have <a id="_idIndexMarker544"/>admin permissions to a container image, you can set the access permissions for the container image to <strong class="source-inline">private</strong> or <strong class="source-inline">public</strong>. Public images allow anonymous access without authentication. You can also grant access permissions for a container image that are separate from the permissions you've set at the organization and repository levels.</p>
			<p>At the organization level, you can set the kind of container packages members can publish. You can also see and restore deleted packages (see<em class="italic"> Figure 8.2</em>).</p>
			<div>
				<div id="_idContainer120" class="IMG---Figure">
					<img src="image/B17827_08_02.jpg" alt="Figure 8.2 – Package permissions on organization level&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.2 – Package permissions on organization level</p>
			<p>For container<a id="_idIndexMarker545"/> images owned by a user account, you can give any person an access role. For container images published and owned by an organization, you can only grant access roles to persons or teams in your organization.</p>
			<p>For more details on<a id="_idIndexMarker546"/> permissions and visibility, see <a href="https://docs.github.com/en/packages/learn-github-packages/configuring-a-packages-access-control-and-visibility">https://docs.github.com/en/packages/learn-github-packages/configuring-a-packages-access-control-and-visibility</a>.</p>
			<h1 id="_idParaDest-208"><a id="_idTextAnchor207"/>Using npm packages with Actions</h1>
			<p>It is <a id="_idIndexMarker547"/>very easy to set up a release workflow for packages with GitHub Actions. You can use <strong class="source-inline">GITHUB_TOKEN</strong> to authenticate and the native clients of your package managers. To try it out with npm, you can follow the step-by-step<a id="_idIndexMarker548"/> instructions here: <a href="https://github.com/wulfland/package-demo">https://github.com/wulfland/package-demo</a>.</p>
			<p>You can <a id="_idIndexMarker549"/>create the package using <strong class="source-inline">npm init</strong> if you have installed npm on your machine. Otherwise, just copy the contents of <strong class="source-inline">package.json</strong> and <strong class="source-inline">package-lock.json</strong> from the aforementioned repository.</p>
			<p>The workflow to publish the package is simple. It gets triggered every time a new release is created:</p>
			<pre class="source-code">on:</pre>
			<pre class="source-code">  release:</pre>
			<pre class="source-code">    types: [created]</pre>
			<p>The workflow consists of two jobs. The first one only builds and tests the package using npm:</p>
			<pre class="source-code">  build:</pre>
			<pre class="source-code">    runs-on: ubuntu-latest</pre>
			<pre class="source-code">    steps:</pre>
			<pre class="source-code">      - uses: actions/checkout@v2</pre>
			<pre class="source-code">      - uses: actions/setup-node@v2</pre>
			<pre class="source-code">        with:</pre>
			<pre class="source-code">          node-version: 12</pre>
			<pre class="source-code">      - run: npm ci</pre>
			<pre class="source-code">      - run: npm test</pre>
			<p>The second one <a id="_idIndexMarker550"/>published the image to the registry. This one requires permission to write <a id="_idIndexMarker551"/>packages and to read content. It uses <strong class="source-inline">${{ secrets.GITHUB_TOKEN }}</strong> to authenticate to the registry:</p>
			<pre class="source-code">  publish-gpr:</pre>
			<pre class="source-code">    needs: build</pre>
			<pre class="source-code">    runs-on: ubuntu-latest</pre>
			<pre class="source-code">    permissions:</pre>
			<pre class="source-code">      packages: write</pre>
			<pre class="source-code">      contents: read</pre>
			<pre class="source-code">    steps:</pre>
			<pre class="source-code">      - uses: actions/checkout@v2</pre>
			<pre class="source-code">      - uses: actions/setup-node@v2</pre>
			<pre class="source-code">        with:</pre>
			<pre class="source-code">          node-version: 12</pre>
			<pre class="source-code">          <strong class="bold">registry-url</strong>: <strong class="bold">https://npm.pkg.github.com/</strong></pre>
			<pre class="source-code">      - run: npm ci</pre>
			<pre class="source-code">      - run: npm publish</pre>
			<pre class="source-code">        env:</pre>
			<pre class="source-code">          <strong class="bold">NODE_AUTH_TOKEN</strong>: ${{secrets.<strong class="bold">GITHUB_TOKEN</strong>}}</pre>
			<p>The workflow is simple and will publish a new package to your npm registry every time you create a new release in GitHub. You can find the details and settings for the package under <strong class="bold">Code</strong> | <strong class="bold">Packages</strong> (see <em class="italic">Figure 8.3</em>).</p>
			<div>
				<div id="_idContainer121" class="IMG---Figure">
					<img src="image/B17827_08_03.jpg" alt="Figure 8.3 – Details and settings of the package&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3 – Details and settings of the package</p>
			<p>You can<a id="_idIndexMarker552"/> then consume the package in other projects using <strong class="source-inline">npm install @&lt;owner-name&gt;/&lt;package-name&gt;</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Note that the version of the package is not the tag or release. It is the version that is in the <strong class="source-inline">package.json</strong> file. If you don't update the version before creating a second release, the workflow will fail.</p>
			<p>If you want to<a id="_idIndexMarker553"/> automate this, there are a few actions that can help. You can<a id="_idIndexMarker554"/> use <strong class="bold">NPM-Version</strong> (see <a href="https://github.com/marketplace/actions/npm-version">https://github.com/marketplace/actions/npm-version</a>) to automatically set the version of npm before publishing. You could use the name of the release (<strong class="source-inline">github.event.release.name</strong>) or tag (<strong class="source-inline">github.event.release.tag_name</strong>) and set the package version to it:</p>
			<pre class="source-code">- name: 'Change NPM version'</pre>
			<pre class="source-code">  uses: reedyuk/npm-version@1.1.1</pre>
			<pre class="source-code">  with:</pre>
			<pre class="source-code">    version: ${{github.event.release.<strong class="bold">tag_name</strong>}}</pre>
			<p>If you want a more flexible approach that calculates your semantic version number based upon tags and branches, you can<a id="_idIndexMarker555"/> use <strong class="bold">GitVersion</strong> (see <a href="https://gitversion.net/">https://gitversion.net/</a>). <strong class="bold">GitVersion</strong> is part<a id="_idIndexMarker556"/> of the <strong class="bold">GitTools</strong> action (see <a href="https://github.com/marketplace/actions/gittools">https://github.com/marketplace/actions/gittools</a>).</p>
			<p>For <strong class="bold">GitVersion</strong> to function properly, you have to perform a <a id="_idIndexMarker557"/>so-called <strong class="bold">shallow clone</strong>. You do this by adding the <strong class="source-inline">fetch-depth</strong> parameter to the checkout action and setting it to <strong class="source-inline">0</strong>:</p>
			<pre class="source-code">    steps:</pre>
			<pre class="source-code">      - uses: actions/checkout@v2</pre>
			<pre class="source-code">        with: </pre>
			<pre class="source-code">          <strong class="bold">fetch-depth: 0</strong></pre>
			<p>Next, install <strong class="bold">GitVersion</strong> and <a id="_idIndexMarker558"/>run the <strong class="source-inline">execute</strong> action. Set an <strong class="source-inline">id</strong> if you want to get details of<a id="_idIndexMarker559"/> the semantic version:</p>
			<pre class="source-code">      - name: Install GitVersion</pre>
			<pre class="source-code">        uses: gittools/actions/gitversion/setup@v0.9.7</pre>
			<pre class="source-code">        with:</pre>
			<pre class="source-code">          versionSpec: '5.x'</pre>
			<pre class="source-code">          </pre>
			<pre class="source-code">      - name: Determine Version</pre>
			<pre class="source-code">        id:   <strong class="bold">gitversion</strong></pre>
			<pre class="source-code">        uses: gittools/actions/gitversion/execute@v0.9.7</pre>
			<p>The calculated final semantic version number is stored as the environment variable <strong class="source-inline">$GITVERSION_SEMVER</strong>. You can use this, for example, as the input for <strong class="bold">npm-version</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Note that <strong class="bold">GitVersion</strong> supports configuration files to learn how it should calculate the version! See <a href="https://gitversion.net/">https://gitversion.net/</a> for more information.</p>
			<p>If you need to <a id="_idIndexMarker560"/>access details from <strong class="bold">GitVersion</strong> (such as major, minor, or patch), you can access them as output parameters of the <strong class="source-inline">gitversion</strong> task:</p>
			<pre class="source-code">  - name: Display GitVersion outputs</pre>
			<pre class="source-code">    run: |</pre>
			<pre class="source-code">      echo "Major: ${{ steps.<strong class="bold">gitversion</strong>.outputs.major }}"</pre>
			<p>With <strong class="bold">GitVersion</strong>, you <a id="_idIndexMarker561"/>can extend your workflow to create packages from branches or tags – not only releases:</p>
			<pre class="source-code">on:</pre>
			<pre class="source-code">  push: </pre>
			<pre class="source-code">    tags:</pre>
			<pre class="source-code">      - 'v*'</pre>
			<pre class="source-code">    branches:</pre>
			<pre class="source-code">      - 'release/*'</pre>
			<p>Building a release workflow with automated semantic versioning is complex and depends a lot on the workflow and package manager you use. This chapter should get you started. The techniques can also be<a id="_idIndexMarker562"/> applied to <strong class="bold">NuGet</strong>, <strong class="bold">Maven</strong>, or any other <a id="_idIndexMarker563"/>package manager.</p>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor208"/>Using Docker with Packages</h1>
			<p>The<a id="_idIndexMarker564"/> container registry of GitHub is <strong class="source-inline">ghcr.io</strong>. Container images can be owned by an organization or personal account, but you can customize the<a id="_idIndexMarker565"/> access to each of them. By default, the images inherit the visibility and permission model of the repository where the workflow is run.</p>
			<p>If you want to try it out yourself, you can find the step-by-step guide here: <a href="https://github.com/wulfland/container-demo">https://github.com/wulfland/container-demo</a>. Follow these steps to understand what the build does:</p>
			<ol>
				<li>Create a new repository called <strong class="source-inline">container-demo</strong> and add a very simple <strong class="source-inline">Dockerfile</strong> (without extension):<p class="source-code">FROM alpine</p><p class="source-code">CMD ["echo", "Hello World!"]</p></li>
			</ol>
			<p>The Docker<a id="_idIndexMarker566"/> image inherits from the alpine distribution and outputs <strong class="source-inline">Hello World!</strong> to your console. If you are new to <a id="_idIndexMarker567"/>Docker and want to try it out, clone the repository and change your directory in the root of the local repository. Build the image for the container:</p>
			<p class="source-code">$ docker build -t container-demo </p>
			<p>And then run the container:</p>
			<p class="source-code">$ docker run --rm container-demo</p>
			<p>The <strong class="source-inline">--rm</strong> argument automatically removes the container when it is done. This should write <strong class="source-inline">Hello World!</strong> to your console.</p>
			<ol>
				<li value="2">Now create a workflow file called <strong class="source-inline">release-container.yml</strong> in <strong class="source-inline">.github/workflows/</strong>. The workflow will be triggered every time a new release is created:<p class="source-code">name: Publish Docker image</p><p class="source-code">on:</p><p class="source-code">  release:</p><p class="source-code">    types: [published]</p></li>
			</ol>
			<p>The registry and the name of the image are set as environment variables. I use the repository name as the name for the image. You can also set a fix name here:</p>
			<p class="source-code">env:</p>
			<p class="source-code">  REGISTRY: ghcr.io</p>
			<p class="source-code">  IMAGE_NAME: ${{ github.repository }}</p>
			<p>The job <a id="_idIndexMarker568"/>needs write permission to <strong class="source-inline">packages</strong> and it <a id="_idIndexMarker569"/>will need to clone the repository:</p>
			<p class="source-code">jobs:</p>
			<p class="source-code">  build-and-push-image:</p>
			<p class="source-code">    runs-on: ubuntu-latest</p>
			<p class="source-code">    permissions:</p>
			<p class="source-code">      contents: read</p>
			<p class="source-code">      packages: write</p>
			<p class="source-code">    steps:</p>
			<p class="source-code">      - name: Checkout repository</p>
			<p class="source-code">        uses: actions/checkout@v2</p>
			<p><strong class="source-inline">docker/login-action</strong> authenticates the workflow using <strong class="source-inline">GITHUB_TOKEN</strong>. This is the recommended way to do it:</p>
			<p class="source-code">- name: Log in to the Container registry</p>
			<p class="source-code">  uses: docker/login-action@v1.10.0</p>
			<p class="source-code">  with:</p>
			<p class="source-code">    registry: ${{ env.REGISTRY }}</p>
			<p class="source-code">    username: ${{ github.actor }}</p>
			<p class="source-code">    password: ${{ secrets.GITHUB_TOKEN }}</p>
			<p><strong class="source-inline">metadata-action</strong> extracts metadata from the Git context and applies tags to the Docker image. When we create a release, we push a tag (<strong class="source-inline">refs/tags/&lt;tag-name&gt;</strong>). The action will create a Docker tag with the same name as the Git tag and also create the latest tag for the image. Note that the metadata is passed as output variables to the next step! That's why I set an <strong class="source-inline">id</strong> for this step:</p>
			<p class="source-code">- name: Extract metadata (tags, labels)</p>
			<p class="source-code">  id: <strong class="bold">meta</strong></p>
			<p class="source-code">  uses: docker/metadata-action@v3.5.0</p>
			<p class="source-code">  with:</p>
			<p class="source-code">    images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}</p>
			<p><strong class="source-inline">build-push-action</strong> builds the image and pushes it to the container registry. The<a id="_idIndexMarker570"/> tags and labels are pulled <a id="_idIndexMarker571"/>from the outputs of the <strong class="source-inline">meta</strong> step:</p>
			<p class="source-code">- name: Build and push Docker image</p>
			<p class="source-code">  uses: docker/build-push-action@v2.7.0</p>
			<p class="source-code">  with:</p>
			<p class="source-code">    context: .</p>
			<p class="source-code">    push: true</p>
			<p class="source-code">    tags: ${{ steps.<strong class="bold">meta</strong>.outputs.tags }}</p>
			<p class="source-code">    labels: ${{ steps.<strong class="bold">meta</strong>.outputs.labels }}</p>
			<ol>
				<li value="3">Create a new release and tag to trigger the workflow. Once the workflow is complete, you can find the details and settings for the package under <strong class="bold">Code</strong> | <strong class="bold">Packages </strong>(see <em class="italic">Figure 8.4</em>).</li>
			</ol>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="image/B17827_08_04.jpg" alt="Figure 8.4 – Details and settings of the container package&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.4 – Details and settings of the container package</p>
			<p>GitHub will <a id="_idIndexMarker572"/>now create a new Docker image and add it to the registry if you create a new release.</p>
			<ol>
				<li value="4">You can <a id="_idIndexMarker573"/>pull you container locally from the registry and run it:<p class="source-code">$ docker pull ghcr.io/<strong class="bold">&lt;user&gt;</strong>/container-demo:latest</p><p class="source-code">$ docker run --rm ghcr.io/<strong class="bold">&lt;user&gt;</strong>/container-demo:latest</p><p class="source-code">&gt; Hello World!</p></li>
			</ol>
			<p>Note that you have to authenticate using <strong class="source-inline">docker login ghcr.io</strong> before pulling the image if your package is not public.</p>
			<p>The container registry is a great way to release software. From command-line tools to complete microservices, you can ship your software with all its dependencies for others to consume it.</p>
			<h1 id="_idParaDest-210"><a id="_idTextAnchor209"/>Apache Maven, Gradle, NuGet, and RubyGems packages</h1>
			<p>The other package types are basically the same as npm and Docker: if you know the native package manager, they are really easy to use. I will only give a very brief introduction to each one.</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor210"/>Java with Apache Maven</h2>
			<p>For <strong class="bold">Java</strong> packages <a id="_idIndexMarker574"/>with <strong class="bold">Maven</strong>, you just have to add your package registry to the <strong class="source-inline">pom.xml</strong> file:</p>
			<pre class="source-code">&lt;distributionManagement&gt;</pre>
			<pre class="source-code">  &lt;repository&gt;</pre>
			<pre class="source-code">    &lt;id&gt;github&lt;/id&gt;</pre>
			<pre class="source-code">    &lt;name&gt;GitHub Packages&lt;/name&gt;</pre>
			<pre class="source-code">    &lt;url&gt;https://maven.pkg.github.com/<strong class="bold">user</strong>/<strong class="bold">repo</strong>&lt;/url&gt;</pre>
			<pre class="source-code">  &lt;/repository&gt;</pre>
			<pre class="source-code">&lt;/distributionManagement&gt;</pre>
			<p>You can then publish your package in a workflow using <strong class="source-inline">GITHUB_TOKEN</strong>:</p>
			<pre class="source-code">- name: Publish package</pre>
			<pre class="source-code">  run: mvn --batch-mode deploy</pre>
			<pre class="source-code">  env:</pre>
			<pre class="source-code">    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}</pre>
			<p>To retrieve packages from your development machine, you have to authenticate using a <strong class="bold">Personal Access Token</strong> (<strong class="bold">PAT</strong>) with <strong class="source-inline">read:packages</strong> scope. You can generate a new token in <a id="_idIndexMarker575"/>GitHub under <strong class="bold">Settings</strong> | <strong class="bold">Developer Settings</strong> | <strong class="bold">Personal access tokens</strong>. Add your user and the PAT to the <strong class="source-inline">~/.m2/settings.xml</strong> file.</p>
			<p>For more<a id="_idIndexMarker576"/> information, see <a href="https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-apache-maven-registry">https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-apache-maven-registry</a>.</p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor211"/>Gradle</h2>
			<p>In <strong class="bold">Gradle</strong>, you<a id="_idIndexMarker577"/> have to add the registry to the <strong class="source-inline">build.gradle</strong> file. You can read the username and access token from the environment variables:</p>
			<pre class="source-code">repositories {</pre>
			<pre class="source-code">  maven {</pre>
			<pre class="source-code">    name = "GitHubPackages"</pre>
			<pre class="source-code">    url = "https://maven.pkg.github.com/<strong class="bold">user</strong>/<strong class="bold">repo</strong>"</pre>
			<pre class="source-code">    credentials {</pre>
			<pre class="source-code">      username = System.getenv("<strong class="bold">GITHUB_ACTOR</strong>")</pre>
			<pre class="source-code">      password = System.getenv("<strong class="bold">GITHUB_TOKEN</strong>")</pre>
			<pre class="source-code">    }</pre>
			<pre class="source-code">  }</pre>
			<pre class="source-code">}</pre>
			<p>In the workflow, you can publish using <strong class="source-inline">gradle publish</strong>:</p>
			<pre class="source-code">- name: Publish package</pre>
			<pre class="source-code">  run: <strong class="bold">gradle publish</strong></pre>
			<pre class="source-code">  env:</pre>
			<pre class="source-code">    GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}</pre>
			<p>For more details, see <a href="https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-gradle-registry">https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-gradle-registry</a>.</p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor212"/>RubyGems</h2>
			<p>If you want <a id="_idIndexMarker578"/>to build and publish all <strong class="bold">gems</strong> for your <strong class="source-inline">.gemspec</strong> files in your repository, you can use an action from the marketplace:</p>
			<pre class="source-code">- name: Build and publish gems got .gemspec files</pre>
			<pre class="source-code">  uses: jstastny/publish-gem-to-github@master</pre>
			<pre class="source-code">  with:</pre>
			<pre class="source-code">    token: ${{ secrets.<strong class="bold">GITHUB_TOKEN</strong> }}</pre>
			<pre class="source-code">    owner: <strong class="bold">OWNER</strong></pre>
			<p>To work<a id="_idIndexMarker579"/> with packages, you need at least RubyGems 2.4.1 and bundler 1.6.4. Modify the <strong class="source-inline">~/.gemrc</strong> file and add the registry as the source by providing your username and personal access token to install packages:</p>
			<pre class="source-code">---</pre>
			<pre class="source-code">:backtrace: false</pre>
			<pre class="source-code">:bulk_threshold: 1000</pre>
			<pre class="source-code">:sources:</pre>
			<pre class="source-code">- https://rubygems.org/</pre>
			<pre class="source-code">- https://<strong class="bold">USERNAME</strong>:<strong class="bold">TOKEN</strong>@rubygems.pkg.github.com/<strong class="bold">OWNER</strong>/</pre>
			<pre class="source-code">:update_sources: true</pre>
			<pre class="source-code">:verbose: true  </pre>
			<p>To install packages using <strong class="bold">bundler</strong><strong class="bold"><a id="_idIndexMarker580"/></strong>, you also must configure it with your user and token:</p>
			<pre class="source-code">$ bundle config \</pre>
			<pre class="source-code">https://rubygems.pkg.github.com/<strong class="bold">OWNER</strong> \</pre>
			<pre class="source-code"><strong class="bold">USERNAME</strong>:<strong class="bold">TOKEN</strong></pre>
			<p>For more <a id="_idIndexMarker581"/>details, see <a href="https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-rubygems-registry">https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-rubygems-registry</a>.</p>
			<h2 id="_idParaDest-214"><a id="_idTextAnchor213"/>NuGet</h2>
			<p>To <a id="_idIndexMarker582"/>publish <strong class="bold">NuGet</strong> packages, you can use the <strong class="source-inline">setup-dotnet</strong> action. It has additional parameters for <strong class="source-inline">source-url</strong>. The token is set using an environment variable:</p>
			<pre class="source-code">- uses: actions/setup-dotnet@v1</pre>
			<pre class="source-code">  with:</pre>
			<pre class="source-code">    dotnet-version: '5.0.x'</pre>
			<pre class="source-code">    source-url: https://nuget.pkg.github.com/<strong class="bold">OWNER</strong>/index.json</pre>
			<pre class="source-code">  env:</pre>
			<pre class="source-code">    NUGET_AUTH_TOKEN: ${{secrets.<strong class="bold">GITHUB_TOKEN</strong>}}</pre>
			<p>You can then build and test your project. After that, just pack and push the package to the registry:</p>
			<pre class="source-code">- run: |</pre>
			<pre class="source-code">  dotnet pack --configuration Release</pre>
			<pre class="source-code">  dotnet nuget push "bin/Release/<strong class="bold">*</strong>.nupkg"</pre>
			<p>To install packages, you have to add the registry as a source to the <strong class="source-inline">nuget.config</strong> file, including your user and token:</p>
			<pre class="source-code">&lt;?xml version="1.0" encoding="utf-8"?&gt;</pre>
			<pre class="source-code">&lt;configuration&gt;</pre>
			<pre class="source-code">    &lt;packageSources&gt;</pre>
			<pre class="source-code">        &lt;add key="github" value="https://nuget.pkg.github.com/<strong class="bold">OWNER</strong>/index.json" /&gt;</pre>
			<pre class="source-code">    &lt;/packageSources&gt;</pre>
			<pre class="source-code">    &lt;packageSourceCredentials&gt;</pre>
			<pre class="source-code">        &lt;github&gt;</pre>
			<pre class="source-code">            &lt;add key="Username" value="<strong class="bold">USERNAME</strong>" /&gt;</pre>
			<pre class="source-code">            &lt;add key="ClearTextPassword" value="<strong class="bold">TOKEN</strong>" /&gt;</pre>
			<pre class="source-code">        &lt;/github&gt;</pre>
			<pre class="source-code">    &lt;/packageSourceCredentials&gt;</pre>
			<pre class="source-code">&lt;/configuration&gt;</pre>
			<p>For more <a id="_idIndexMarker583"/>information, see <a href="https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-nuget-registry">https://docs.github.com/en/packages/working-with-a-github-packages-registry/working-with-the-nuget-registry</a>.</p>
			<h1 id="_idParaDest-215"><a id="_idTextAnchor214"/>Summary</h1>
			<p>Working with packages is straightforward. The biggest challenge is authentication. But with <strong class="source-inline">GITHUB_TOKEN</strong> in GitHub Actions, it is easy to set up a completely automated release workflow. That's why it is important for your teams to have it in your toolbox. A lot of problems in releasing code can be reduced if you share code as containers or packages using semantic versioning and a separate release flow.</p>
			<p>In this chapter, you have learned how you can use semantic versioning and packages to better manage your internal dependencies and to share code. You have learned what packages are and how you can set up release workflows for each package type.</p>
			<p>In the next chapter, we'll have a closer look at environments and how you can deploy with GitHub actions to any platform.</p>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor215"/>Further reading</h1>
			<p>For more information about the topics in this chapter, refer to the following:</p>
			<ul>
				<li><em class="italic">Semantic versioning</em>: <a href="https://semver.org/">https://semver.org/</a></li>
				<li><em class="italic">Billing and pricing</em>: <a href="https://docs.github.com/en/billing/managing-billing-for-github-packages/about-billing-for-github-packages">https://docs.github.com/en/billing/managing-billing-for-github-packages/about-billing-for-github-packages</a></li>
				<li><em class="italic">Access control and visibility</em>: <a href="https://docs.github.com/en/packages/learn-github-packages/configuring-a-packages-access-control-and-visibility">https://docs.github.com/en/packages/learn-github-packages/configuring-a-packages-access-control-and-visibility</a></li>
				<li><em class="italic">Working with the registry </em>(Container, Apache Maven, Gradle. NuGet, npm, RubyGems): <a href="https://docs.github.com/en/packages/working-with-a-github-packages-registry">https://docs.github.com/en/packages/working-with-a-github-packages-registry</a></li>
			</ul>
		</div>
	</body></html>