- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Puppet Concepts and Practices
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Puppet的概念和实践
- en: This chapter will focus on the origins of Puppet, why it was created, and how
    it is used in DevOps engineering. It will look at Puppet’s approach to configuration
    management and how its declarative approach differs from more regular procedural
    languages. Puppet has many features that are common in other languages such as
    variables, conditional statements, and functions. But in this chapter, we will
    cover the key terms, structure, and ideas of the language that make it different
    and how the underlying platform runs. We will give a clear, high-level overview
    of its approach and how it relates to customer needs and infrastructure environments.
    Finally, as there are a lot of preconceptions regarding Puppet, this chapter will
    finish by addressing some of the most common ones, including where they come from,
    and unwrap them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍Puppet的起源，为什么它被创建，以及它如何在DevOps工程中使用。它将探讨Puppet的配置管理方法，以及其声明式方法与更常规的过程性语言有何不同。Puppet拥有许多在其他语言中常见的特性，如变量、条件语句和函数。但在本章中，我们将介绍语言的关键术语、结构和思想，以及它与客户需求和基础设施环境的关系。最后，鉴于关于Puppet有很多先入为主的看法，本章将结束时解决一些最常见的误解，包括它们的来源，并将其解开。
- en: This should ensure a fundamental understanding of Puppet and its approach before
    we build up a deeper, technical understanding of the language in upcoming chapters.
    It will also ensure this book is not just about technology but how genuine value
    can be delivered to customers using the service that Puppet provides.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保在我们在接下来的章节中深入了解语言之前，能够对Puppet及其方法有一个基本的理解。它还将确保本书不仅仅关于技术，而是关于如何通过Puppet提供的服务为客户创造真正的价值。
- en: 'In this chapter, we are going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Puppet’s history and relationship to DevOps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet的历史和与DevOps的关系
- en: Puppet as a declarative and idempotent language
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet作为声明式和幂等的语言
- en: Key terms in the Puppet language
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet语言中的关键术语
- en: Puppet as a platform
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet作为一个平台
- en: Common misconceptions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常见误解
- en: Puppet’s history and relationship to DevOps
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Puppet的历史和与DevOps的关系
- en: Puppet was started by creator and founder Luke Kaines, who was working as a
    sysadmin and consultant. He was unable to find the tooling he wanted to use and
    that his customers could rely on, so he created Puppet as a Ruby-based open source
    configuration management language in 2005\. The success of this open source project
    resulted in the release of a commercial offering, Puppet Enterprise, in February
    2011\. But as the demands increased and Puppet needed to reform and expand as
    both a company and an open source project, Luke stood down, stating that the challenges
    of growing Puppet to enterprise-scale were *far from what I love to do most, and
    far from my core skills. We need to scale, and we need* *to execute*.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet由创始人卢克·凯恩斯（Luke Kaines）创建，他曾是系统管理员和顾问。由于找不到自己想要使用且客户可以依赖的工具，他于2005年创建了Puppet，作为一个基于Ruby的开源配置管理语言。这个开源项目的成功促使在2011年2月推出了商业版本Puppet
    Enterprise。但随着需求的增加，Puppet在作为公司和开源项目的改革和扩展中，卢克选择了退出，表示将Puppet发展到企业级规模的挑战是*远离我最喜欢做的事情，远离我的核心技能。我们需要扩展，并且需要*
    *执行*。
- en: 'The new leadership that followed took a direction that saw the company develop
    its professional services, and focus more effort on developer tooling and education
    while expanding its product range both organically and via acquisitions, striking
    a difficult balance between the open source community and its enterprise customer
    demands. Puppet was acquired by Perforce Software on May 17, 2022, following the
    Chef (2020) and Ansible (2015) acquisitions, as the last of the standalone configuration
    management start-ups. Luke summed up the change that has taken place in the industry:
    *DevOps teams are different now. Companies are looking for a complete solution,
    rather than wanting to integrate individual* *best-of-breed vendors.*'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 随后接任的领导层采取了一个方向，使公司发展了其专业服务，并在扩展产品范围时，更多地关注开发者工具和教育，同时在开源社区和企业客户需求之间寻求艰难的平衡。Puppet于2022年5月17日被Perforce
    Software收购，成为继Chef（2020年）和Ansible（2015年）收购之后，最后一家独立的配置管理初创公司。卢克总结了行业发生的变化：*如今，DevOps团队有所不同。公司正在寻找一个完整的解决方案，而不是想要集成单个*
    *最优质的供应商。*
- en: This history has seen Puppet move from a tool that left it to the developer
    to decided how best to use it to solve problems to, today, a tool with patterns
    and solutions that users can just consume to standardize their automation and
    deployment. This has allowed users to focus on their solutions and not the underlying
    technology.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这一历史见证了Puppet从一种让开发者决定如何使用它来解决问题的工具，发展到今天，成为一种具有模式和解决方案的工具，用户可以直接使用这些模式和解决方案来标准化他们的自动化和部署。这使得用户能够专注于他们的解决方案，而不是底层技术。
- en: DevOps itself has become a frustrating term in the IT industry; the definition
    given by formal sources differs hugely from how companies actually use it, and
    references to it can be used as a cynical buzzword or sales gimmick. The focus
    of this book is on DevOps engineering, as used particularly by large companies
    and has been well r1esearched and discussed in studies such as the Puppet-run
    *State of DevOps Report*. DevOps engineering is normally delivered as part of
    projects such as digital transformations, cloud-first migrations, and various
    other modernization projects. What is typically seen in these projects is a desire
    to automate self-service deployment, compliance, and remove toil. This approach
    follows the DevOps goal of breaking down the silos between developers and ops
    teams by allowing better communication and establishing shared goals. What is
    noticeable is that the system administrator role in which Luke worked originally
    has effectively been replaced by roles such as DevOps engineers.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps 本身在 IT 行业已成为一个令人沮丧的术语；正式来源给出的定义与公司实际使用它的方式有很大差异，且对其的引用往往被用作讽刺性的流行语或销售噱头。本书的重点是
    DevOps 工程，尤其是在大公司中的应用，这些内容已经在如 Puppet 主办的*DevOps 状况报告*等研究中得到了深入的研究和讨论。DevOps 工程通常作为数字化转型、云优先迁移和其他各种现代化项目的一部分进行交付。在这些项目中，通常可以看到的目标是自动化自助部署、合规性并消除繁琐的操作。此方法遵循
    DevOps 目标，即通过促进更好的沟通和建立共同目标来打破开发和运维团队之间的壁垒。值得注意的是，Luke 最初所工作的系统管理员角色，实际上已被 DevOps
    工程师等新角色所取代。
- en: 'Puppet will be used as part of a DevOps toolchain, and *Figure 1**.1* shows
    an example set of tools and their relative functions. It is typical for Puppet
    to start its role at the end of a provisioning pipeline, as infrastructure is
    stood up in a platform and needs to be configured and enforced:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 将作为 DevOps 工具链的一部分使用，*图 1.1* 展示了一组工具及其相对功能的示例。通常，Puppet 的作用开始于一个提供管道的末端，当基础设施在平台中搭建好并需要进行配置和执行时，Puppet
    就会介入：
- en: '![Figure 1.1 – A DevOps toolset](img/Figure_01.01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1 – DevOps 工具集](img/Figure_01.01.jpg)'
- en: Figure 1.1 – A DevOps toolset
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – DevOps 工具集
- en: This book will focus not just on a technological understanding but also on how
    to use the maturity of the Puppet language, tooling, and platform with opinionated
    patterns. These approaches have been developed through years of customer engagements
    for Puppet and the communities’ own implementations to allow users to reduce their
    effort in finding the right approach, focus on their solutions, and deliver immediate
    benefit and return to their customers.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本书不仅专注于技术理解，还将着重于如何利用Puppet语言、工具和平台的成熟度以及带有明确观点的模式。这些方法是通过多年的客户合作以及Puppet和社区自身实现的经验发展而来，旨在帮助用户减少寻找合适方法的努力，专注于解决方案，并为客户带来即时的收益和回报。
- en: Puppet as a declarative and idempotent language
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Puppet 作为一种声明式和幂等的语言
- en: The first important thing to understand is how Puppet differs from normal scripting
    or coding languages. Puppet is declarative, meaning you describe the state you
    want the system to be in. For example, you could describe that your system should
    have a user called `username` with UID `1234`, a configuration file should not
    exist, and a kernel setting should be at a particular value. In comparison to
    most languages where you have to describe the process to get to the state, Puppet’s
    approach brings us closer to how customers request services. They don’t want to
    know how it’s done, just that it will meet their requirements. These resource
    definitions can be saved in your version control system. Often, this approach
    is described as being part of **Infrastructure** **as Code**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 理解的第一件重要事情是了解 Puppet 与普通的脚本或编程语言有何不同。Puppet 是声明式的，这意味着你描述的是你希望系统达到的状态。例如，你可以描述系统应该有一个名为`username`的用户，UID为`1234`，配置文件不应该存在，内核设置应该是某个特定的值。与大多数语言不同，Puppet
    的方法不要求描述如何达到这个状态，而是更接近客户请求服务的方式。客户并不关心过程如何，只关心最终结果能满足他们的需求。这些资源定义可以保存在你的版本控制系统中。通常，这种方法被描述为**基础设施即代码**的一部分。
- en: Puppet is idempotent, meaning that it will only make the changes required to
    get into the declared state. Meanwhile, most procedural languages will run steps
    every time and, typically, require various checks such as `if` statements to be
    added to make checks to avoid duplication. This is particularly powerful as what
    is called *enforcement* can be run with the Puppet language, ensuring the state
    you declared has been reached, and is capable of detecting whether a change happened
    because of you updating the state you wished the machine to be in or whether it
    was a change that happened on the machine itself moving away from the desired
    state. This can greatly assist with audits and avoid any configuration drifts
    in an estate and ensure change is managed and deliberate.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 是幂等的，这意味着它只会进行必要的更改，以使系统达到声明的状态。而大多数过程性语言每次运行时都会执行步骤，并通常需要添加诸如`if`语句等各种检查，以避免重复。这一特性非常强大，因为所谓的*强制执行*可以通过
    Puppet 语言来实现，确保你声明的状态已经达成，并能够检测是否是你更新了目标机器的状态导致了变化，或者变化是机器本身的变化，偏离了期望的状态。这在审计中非常有帮助，可以避免配置漂移，确保变更是经过管理且有意为之。
- en: Puppet is OS-independent; the language is focused on the state, not the underlying
    implementation of how particular OSes install a package or add a user. This gives
    us a universal language that is independent of any underlying implementations,
    allowing for less duplication of code, avoiding the need to use layers of `case`/`if`
    statements to detect differences, and allowing multiple language implementations
    such as PowerShell for Windows and Bash for Unix-based systems. Additionally,
    it makes it easier to recover after failures in applying code. If in a procedural
    language, a step fails, it might not be safe to run the script in full again depending
    on how well the check steps have been coded. In contrast, Puppet code is able
    to resume only performing the steps it needs to reach the correct state.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 是操作系统无关的；它关注的是系统状态，而不是特定操作系统如何安装软件包或添加用户的实现方式。这为我们提供了一种通用语言，不依赖于任何底层实现，减少了代码的重复，避免了使用`case`/`if`语句来检测差异的需求，并允许多种语言实现，比如
    Windows 的 PowerShell 和基于 Unix 的系统的 Bash。此外，它还使得在应用代码失败后更容易恢复。如果在过程性语言中某个步骤失败，根据检查步骤的编写方式，可能无法安全地重新运行整个脚本。而
    Puppet 代码则能够仅执行必要的步骤，以便恢复到正确的状态。
- en: 'A simple example of Puppet code to create a user would look like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的 Puppet 代码示例如下，用于创建一个用户：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In contrast, a shell script might have a section like this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，一个 shell 脚本可能包含如下部分：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding shell example, we have to check whether a user exists, and
    if not, create one. If it does exist, then does it have the right UID? If not,
    we change it. This script only covers OSes that can use `useradd` and `usermod`.
    To achieve compatibility with multiple OSes, we would need a test to detect the
    OS type and produce a section of code like this for every OS or group of OSes
    and their required commands. Often, it would be more practical to write in multiple
    languages and scripts to cover a broader base of OS flavors, that is, if we wanted
    to cover both Unix and Windows, for example.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的 shell 示例中，我们需要检查一个用户是否存在，如果不存在，就创建一个。如果它存在，那么它的 UID 是否正确？如果不正确，我们将进行更改。这个脚本仅覆盖能够使用
    `useradd` 和 `usermod` 的操作系统。为了实现跨多个操作系统的兼容性，我们需要检测操作系统类型并为每个操作系统或操作系统组及其所需的命令编写类似的代码段。通常，为了涵盖更广泛的操作系统版本，编写多种语言和脚本是更实用的做法，例如，如果我们想同时支持
    Unix 和 Windows。
- en: This compares to the Puppet declaration, which will work on multiple OSes without
    change as Puppet will detect the required commands and perform all the necessary
    state checks as part of that.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这与 Puppet 声明相对比，后者无需更改就可以在多个操作系统上工作，因为 Puppet 会检测所需的命令，并作为一部分执行所有必要的状态检查。
- en: This example is all just for a single resource with a single attribute. You
    can quickly see how the shell script example will not scale as it becomes increasingly
    complex with almost endless checks and options.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例仅仅涉及一个具有单个属性的资源。你可以很快看到，随着检查项和选项的不断增加，shell 脚本示例将变得越来越复杂，并且难以扩展。
- en: Key terms in the Puppet language
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Puppet 语言中的关键术语
- en: Looking at the Puppet language in more detail, the most fundamental item in
    Puppet is a **resource**. Each resource describes some part of the system and
    the desired state you wish it to be in. Each resource has a **type**, which is
    a definition for the Puppet language of how this particular resource can be configured,
    which **attributes** can be set, and what **providers** can be used. The attributes
    are what describe the state. So, for a user, this might be a home directory or,
    for a file, the permissions. **Providers** are what make the Puppet OS independent
    since they do the underlying commands be they for creating a user or installing
    a package.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 详细查看 Puppet 语言，Puppet 中最基本的元素是**资源**。每个资源描述系统的某个部分以及你希望它处于的理想状态。每个资源都有一个**类型**，它是
    Puppet 语言中该资源如何配置的定义，包括哪些**属性**可以设置，以及可以使用哪些**提供者**。属性描述的是状态。因此，对于一个用户来说，属性可能是家目录；对于文件而言，属性可能是权限。**提供者**使得
    Puppet 跨操作系统独立工作，因为它们执行底层命令，无论是创建用户还是安装软件包。
- en: 'So, let’s take an example of a company that typically submits build request
    forms to an environments team to request the configuration for a server:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们以一个公司为例，该公司通常会向环境团队提交构建请求表单，要求配置服务器：
- en: '![Table 1.1 – An example build request form](img/Table_01.01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![表格 1.1 – 构建请求表单示例](img/Table_01.01.jpg)'
- en: Table 1.1 – An example build request form
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 表格 1.1 – 构建请求表单示例
- en: In *Table 1.1*, the request form, we see groupings of users, groups, and directories,
    which are all, essentially, **types**. Each item under them is a resource, and
    the configuration settings are the attributes.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在*表格 1.1*中，请求表单里我们看到有用户、用户组和目录的分组，它们本质上都是**类型**。它们下面的每一项都是一个资源，而配置设置则是属性。
- en: 'This request could translate to something like the following:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个请求可以转化为如下内容：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding example shows how Puppet translates more directly to user requests
    and can remain readable without even understanding any of the Puppet language.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的示例展示了 Puppet 如何更加直接地转换为用户请求，并且即使不理解 Puppet 语言，也能保持可读性。
- en: What isn’t visible, in this example, is the `usermod` provider. Instead, if
    I wished to use LDAP commands for user creation, I would set my `provider` attribute
    to LDAP.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，未显示的是 `usermod` 提供者。如果我想使用 LDAP 命令创建用户，我将把我的 `provider` 属性设置为 LDAP。
- en: The next important thing to note is that due to the nature of writing Puppet
    in a stateful way, we are not writing an ordered process that executes line by
    line but only declaring the state of resources that could be implemented in any
    order. Therefore, if we have any dependencies, we need to use the `relationship`
    parameter; this describes a before/after relationship, which is exactly as it
    sounds, or a subscribe/refresh, whereby, for example, updating a configuration
    file could cause a service to restart. In the previous example, Puppet automatically
    creates certain dependencies such as ensuring the group is created before the
    user, so we don’t have to add a **relationship** parameter.Often, these relationships
    are seen as one of the most difficult parts of Puppet to adapt to, as many coders
    are used to writing a process to follow and mistakes can be made. This can cause
    a cycle of dependencies, whereby a chain of these dependencies cycles round, and
    there is no way to create a starting resource that isn’t dependent on another.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个重要的注意事项是，由于 Puppet 是以有状态的方式编写的，我们并不是编写一个逐行执行的有序过程，而只是声明资源的状态，这些资源可以以任何顺序实现。因此，如果我们有任何依赖关系，就需要使用
    `relationship` 参数；它描述了一个前后关系，正如字面意思，或者是一个订阅/刷新，例如，更新配置文件可能会导致服务重启。在之前的示例中，Puppet
    会自动创建某些依赖关系，例如确保在用户之前创建组，因此我们不必添加 **relationship** 参数。通常，这些关系被视为适应 Puppet 时最难掌握的部分，因为许多程序员习惯于编写一个按顺序执行的过程，容易出错。这可能导致依赖关系的循环，其中一系列依赖关系循环往复，没有办法创建一个不依赖于其他资源的起始资源。
- en: Evidently, the resources we declare need a structure, and the first step is
    for this code to be in a file. Puppet calls these `.pp`. **Classes** are blocks
    of Ppuppet code that give us a way to specifically call sections of code to be
    run on hosts. Normally, as a good practice, we only have one **class** in a **manifest**
    file. Puppet then uses **modules** as a way to group these **manifests** and **classes**.
    This grouping is based on the principle that a **module** should do a single thing
    well and represent a technical implementation, such as a **module** configuring
    the IIS application or configuring postfix as a mail relay. **Modules** are simply
    a directory structure storing the **manifests**, **classes**, and other Puppet
    items (which we will cover, in detail, in [*Chapter 8*](B18492_08.xhtml#_idTextAnchor212))
    and are not a keyword in the language itself. So, ideally, modules should be shareable
    and reusable for different users and organizations with many taken straight from
    the **Puppet Forge**, which is Puppet’s catalog of modules with both commercial
    and open source offerings.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们声明的资源需要一个结构，第一步是将这些代码放入一个文件中。Puppet 将这些文件称为 `.pp` 文件。**类**是 Puppet 代码块，它为我们提供了一种特定的方式来调用在主机上运行的代码段。通常，作为一种最佳实践，我们在一个
    **manifest** 文件中只包含一个 **类**。然后，Puppet 使用 **模块** 来将这些 **manifest** 和 **类** 进行分组。这个分组的原则是
    **模块** 应该专注于做一件事并且做到极致，代表一个技术实现，例如，配置 IIS 应用程序的 **模块** 或者配置 postfix 作为邮件中继的 **模块**。**模块**
    只是一个目录结构，用来存储 **manifest**、**类** 和其他 Puppet 项目（我们将在 [*第 8 章*](B18492_08.xhtml#_idTextAnchor212)
    中详细讲解），它本身并不是语言中的关键字。因此，理想情况下，模块应该是可共享和可重用的，供不同的用户和组织使用，很多模块直接来自 **Puppet Forge**，即
    Puppet 的模块目录，里面既有商业产品也有开源产品。
- en: 'An example of one common style and practice for modules is to have a manifest
    file with a single class for the following:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一个常见的模块风格和实践是，包含一个具有单一类的 manifest 文件，示例如下：
- en: '`install.pp` (grouping resources related to installing software)'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`install.pp`（与安装软件相关的资源分组）'
- en: '`config.pp` (grouping resources related to configuring software)'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config.pp`（与配置软件相关的资源分组）'
- en: '`service.pp` (grouping resources related to running services)'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`service.pp`（与运行服务相关的资源分组）'
- en: '`init.pp` (a way of initializing the module and accepting parameters)'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`init.pp`（初始化模块并接受参数）'
- en: At a higher level, we then have **roles** and **profiles, which** are used to
    create the structure of your organization. While **modules** should be sharable
    and repeatable installations of technical implementations, such as Oracle or IIS,
    **roles** and **profiles** will only have context within your organization. **Roles**
    and **profiles** are **classes** used to group **modules** and selected parameters
    into logical technical stacks and customer solutions. It is common to make a **roles
    module** and a **profiles module** while keeping together the **classes** used.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在更高层次上，我们有**角色**和**配置文件**，它们用于创建您组织的结构。虽然**模块**应该是可共享和可重复的技术实现安装，例如 Oracle 或
    IIS，**角色**和**配置文件**仅在您的组织内有意义。**角色**和**配置文件**是**类**，用于将**模块**和选定的参数组合成逻辑技术栈和客户解决方案。通常会创建一个**角色模块**和一个**配置文件模块**，同时保持使用的**类**在一起。
- en: What can be confusing, at this point, is that you can end up with an Oracle
    **Role**, an Oracle **profile**, and an Oracle **module**. So, while the Oracle
    module configures and installs Oracle with various parameters available to it
    to customize the installation, the Oracle profile is about how your organization
    uses this module and what other modules it might add to this technology stack.
    You might specify that you always use Oracle with a cluster service and, therefore,
    your Oracle profile contains both an Oracle module and a cluster module. Alternatively,
    it might pass parameters to the Oracle module within your profile, which set default
    kernel settings for your organization’s configuration.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，可能会让人困惑的是，您可能会有一个 Oracle **角色**、一个 Oracle **配置文件**和一个 Oracle **模块**。因此，虽然
    Oracle 模块配置并安装 Oracle，并提供各种可用的参数以自定义安装，但 Oracle 配置文件是关于您的组织如何使用该模块，以及它可能会向该技术栈中添加其他模块。您可能会指定总是将
    Oracle 与集群服务一起使用，因此您的 Oracle 配置文件包含 Oracle 模块和集群模块。或者，它可能会在配置文件中传递参数给 Oracle 模块，从而设置您组织配置的默认内核设置。
- en: You can think of a role as being what the customer actually wants when they
    submit a build request; they need a particular type of server, be it an Oracle
    or an IIS server. They don’t care about the underlying implementations – only
    that it meets their requirements. While the Oracle role will certainly need the
    Oracle profile, it will expect it to meet the OS security standard and to have
    any agents or other supporting tools your organization defines. Therefore, a common
    profile for many organizations is a base OS security standard that ensures every
    server is compliant and that is part of almost every role.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将角色理解为客户在提交构建请求时实际需要的东西；他们需要特定类型的服务器，无论是 Oracle 服务器还是 IIS 服务器。他们不关心底层的实现——只关心它是否满足他们的需求。虽然
    Oracle 角色肯定需要 Oracle 配置文件，但它期望满足操作系统安全标准，并且具备您组织定义的任何代理或其他支持工具。因此，对于许多组织来说，一个常见的配置文件是基本的操作系统安全标准，确保每台服务器都符合标准，这几乎是每个角色的一部分。
- en: '*Figure 1**.2* shows an example of what has just been described as an Oracle
    role class in the roles module, which includes an Oracle profile class and an
    OS security profile class, both from the profile module. Then, the Oracle profile
    includes an Oracle module, while the `os_security` profile includes the DNS module:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 1.2* 显示了刚刚描述的一个例子，即角色模块中的 Oracle 角色类，其中包括来自配置文件模块的 Oracle 配置文件类和操作系统安全配置文件类。然后，Oracle
    配置文件包含一个 Oracle 模块，而`os_security`配置文件则包含 DNS 模块：'
- en: '![Figure 1.2 – The structure of roles, profiles, and modules](img/Figure_01.02.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2 – 角色、配置文件和模块的结构](img/Figure_01.02.jpg)'
- en: Figure 1.2 – The structure of roles, profiles, and modules
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – 角色、配置文件和模块的结构
- en: In [*Chapter 8*](B18492_08.xhtml#_idTextAnchor212), we will go into more technical
    detail, but the key takeaway from this overview is to understand that modules
    provide sharable and reusable single-use technical installations. In contrast,
    the roles and profiles pattern provides the context for your organization. Roles
    are for customers ordering server offerings; they don’t need to understand the
    technical implementation, only that it meets their business requirement. The profiles
    in your organization’s technology stack are managed by technical designers and
    architects, who combine and specify modules according to your organization’s standards
    and configurations. These roles are responsible for defining how different components
    are integrated to create the desired technology stack. So while an Oracle module
    by itself can configure and install Oracle, it is the profile that defines the
    exact configurations that should be passed to that Oracle module and the other
    modules it may be dependent on such as having a NetBackup client installed.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第8章*](B18492_08.xhtml#_idTextAnchor212)中，我们将深入探讨更多技术细节，但从本概述中最重要的要点是理解模块提供了可共享和可重用的一次性技术安装。相比之下，角色和配置文件模式为你的组织提供了背景。角色是客户在订购服务器服务时使用的；他们不需要理解技术实现，只需要知道它符合他们的业务需求。你组织技术栈中的配置文件由技术设计师和架构师管理，他们根据组织的标准和配置来组合和指定模块。这些角色负责定义不同组件如何集成，以创建所需的技术栈。因此，虽然一个Oracle模块本身可以配置和安装Oracle，但正是配置文件定义了应该传递给Oracle模块的具体配置，以及它可能依赖的其他模块，例如安装NetBackup客户端。
- en: With what we have covered in modules, roles, and profiles, going back to *Table
    1.1*, instead, we can have a customer submitting the build request form but not
    having to specify everything they need; they could simply order an `exampleapp`
    role server.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通过我们在模块、角色和配置文件中所讨论的内容，回到*表1.1*，我们可以让客户提交构建请求表单，但不需要指定他们所需要的所有内容；他们可以简单地订购一个`exampleapp`角色服务器。
- en: What we have seen so far is fine when servers meet all the specifications and
    are standard, but exceptions are commonplace. **Hiera** is Puppet's data system,
    and it can be used to pass parameters to the roles and profiles model to handle
    exceptions. Hiera, as its name suggests, is hierarchical. It defines an ordered
    lists of data sources to access to find the most relevant setting. These data
    sources will typically be ordered from the default value for all nodes to a more
    specific group such as a particular role and specific values for an individual
    node.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们看到的内容适用于服务器满足所有规格且是标准的情况，但例外情况是常见的。**Hiera**是Puppet的数据信息系统，它可以用于将参数传递给角色和配置文件模型，以处理例外情况。Hiera顾名思义是分层的。它定义了一个有序的数据源列表，以访问找到最相关的设置。这些数据源通常从所有节点的默认值到更具体的组，例如某个特定角色和单个节点的特定值。
- en: 'For example, if email servers were disabled by the default OS security profile
    but were required for `exampleapp`, we could have the following YAML file:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果默认操作系统安全配置文件禁用了电子邮件服务器，但`exampleapp`需要它，我们可以使用以下YAML文件：
- en: exampleapp.yaml
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: exampleapp.yaml
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Similarly, if `server1` needed a different UID, we could have the following
    YAML file:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，如果`server1`需要一个不同的UID，我们可以使用以下YAML文件：
- en: server1.yaml
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: server1.yaml
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'One of the most important points of creating these patterns is to avoid hardcoded
    values in your modules. By using Hiera, you give yourself a dynamic way to change
    the values in the future without modifying the code. This could evolve to access
    the data via a self-service portal – automating away from builds ordered via spreadsheets,
    emails, and discussions, which would have to be configured by the build teams
    instead of portals such as VMware vRealize Automation or ServiceNow:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 创建这些模式的最重要的一个点是避免在模块中使用硬编码的值。通过使用Hiera，你为自己提供了一种动态方式，可以在未来更改值，而无需修改代码。这可以演变为通过自助服务门户访问数据——从通过电子表格、电子邮件和讨论来订购构建的方式自动化出来，而这些构建必须由构建团队配置，而不是像VMware
    vRealize Automation或ServiceNow这样的门户：
- en: "![Figure 1.\uFEFF3 – An example portal](img/Figure_01.03.jpg)"
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: "![图1.\uFEFF3 – 示例门户](img/Figure_01.03.jpg)"
- en: Figure 1.3 – An example portal
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – 示例门户
- en: In *Figure 1**.3*, an example portal shows how customers can be presented with
    simplified products. The focus of the Puppet language should be to deliver consistent
    products to customers and allow customers, architects, and technical staff to
    focus on what they care about and not have to delve into the technical requirements
    or coding sections themselves.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 1.3*中，示例门户展示了如何向客户展示简化的产品。Puppet 语言的重点应当是为客户提供一致的产品，并让客户、架构师和技术人员专注于他们关心的内容，而无需自己深入技术要求或编码部分。
- en: Puppet as a platform
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Puppet 作为平台
- en: So far, this chapter has focused on the Puppet language, but now we will look
    at the Puppet platform and how it applies the desired state to client servers.
    Puppet can be run with just an installed agent and all the files locally, which
    is common for testing, but this overview will focus on the client-server setup.
    In *Chapters 10*, *13*, and *14*, we will go into much more detail about resilience,
    scalability, and more advanced running options. However, for now, we will focus
    on how a Puppet client talks to a server to request and apply its desired state.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本章重点讨论了 Puppet 语言，但现在我们将探讨 Puppet 平台以及它如何将期望的状态应用于客户端服务器。Puppet 可以仅通过安装代理和所有文件本地运行，这在测试中很常见，但本概述将重点介绍客户端-服务器设置。在*第
    10、13 和 14 章*中，我们将详细讨论弹性、可扩展性和更高级的运行选项。然而，目前我们将重点关注 Puppet 客户端如何与服务器通信，以请求并应用其期望的状态。
- en: 'Every client under Puppet control will install a Puppet agent. *Figure 1**.4*
    shows the steps of a Puppet agent run, which this section will outline:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 控制下的每个客户端都会安装 Puppet 代理。*图 1.4* 显示了 Puppet 代理运行的步骤，本节将概述这些步骤：
- en: "![Figure 1.\uFEFF4 – The Puppet agent run life cycle](img/Figure_01.04.jpg)"
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.4 – Puppet 代理运行生命周期](img/Figure_01.04.jpg)'
- en: Figure 1.4 – The Puppet agent run life cycle
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – Puppet 代理运行生命周期
- en: The first step is for the agent to identify itself to the primary server with
    SSL keys or to create new SSL keys for the primary server to sign. This will secure
    communication between the server and client.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是代理通过 SSL 密钥向主服务器标识自己，或者为主服务器创建新的 SSL 密钥进行签名。这将确保服务器与客户端之间的通信安全。
- en: The next action is for the client to use a Ruby library called `Facter`. This
    is a system profiler to gather what is known as **facts** about the system. This
    can be things such as the OS version or RAM size. These facts can be used in code
    or by Hiera to make choices about what state a host should be in, such as Windows
    Server 2022 having a particular registry setting.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是客户端使用一个名为`Facter`的 Ruby 库。这是一个系统分析器，用于收集系统的**事实**。这些事实可以是操作系统版本或内存大小等内容。这些事实可以在代码中使用，或通过
    Hiera 来决定主机应处于什么状态，例如 Windows Server 2022 可能需要特定的注册表设置。
- en: Then, the server identifies what classes should be applied to a server. Typically,
    this is done by what is called an **end node classifier** (**ENC**) script, which
    is based on the facts and user definitions. Normally, this will apply a role class
    to a server, which, as we discussed in the previous section, builds up a definition
    of profiles and module classes.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，服务器识别应该应用于服务器的类。通常，这由所谓的**端节点分类器**（**ENC**）脚本完成，该脚本基于事实和用户定义。通常，这会将一个角色类应用于服务器，正如我们在前一部分中讨论的那样，角色类会构建出配置文件和模块类的定义。
- en: Then, the primary server compiles a catalog and a YAML file of the resources
    to be applied to the node (ensuring the CPU-intensive work happens on the server
    and not the client).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，主服务器会编译目录和要应用于节点的资源 YAML 文件（确保 CPU 密集型的工作发生在服务器上，而不是客户端）。
- en: This catalog is then sent to the client who uses the catalog as a blueprint
    of what the state should look like and makes any necessary changes to enforce
    the state on the client.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 该目录随后被发送给客户端，客户端将该目录作为应有状态的蓝图，并进行任何必要的更改以在客户端上强制执行该状态。
- en: Finally, a report is sent back to the primary server confirming what resources
    were applied and whether these resources had to be changed due to a change in
    Puppet code or whether they were changed outside of Puppet control (which might
    be an audit or security breach).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一份报告会被发送回主服务器，确认应用了哪些资源，以及这些资源是否因为 Puppet 代码的更改而需要进行调整，或者它们是否在 Puppet 控制之外被更改（可能是审计或安全漏洞）。
- en: 'In *Figure 1**.5*, we see an example extract from a Puppet report showing the
    name of the resource, the type of change made, and the value it needed to change.
    Additionally, the report includes a record of unchanged resources highlighting
    what is part of Puppet''s enforcement:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 1.5*中，我们看到一个Puppet报告的示例，展示了资源的名称、所做的更改类型以及所需更改的值。此外，报告还包括未更改资源的记录，突出显示了Puppet强制执行的部分：
- en: "![Figure 1.\uFEFF5 – The Puppet console server report](img/Figure_01.05.jpg)"
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: "![图 1.\uFEFF5 – Puppet 控制台服务器报告](img/Figure_01.05.jpg)"
- en: Figure 1.5 – The Puppet console server report
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – Puppet 控制台服务器报告
- en: 'By default, this cycle takes place every 30 minutes. In the previous sections,
    the focus was on how the language can automate the building of servers. Here,
    we can see that, via the platform, we can ensure all our deployed servers are
    enforced with the state we set out to achieve; whether that be a security standard
    profile or whether we decided to update the settings in a particular implementation
    such as adding extra features to IIS. This avoids server drift, where servers
    on the estate are difficult to keep up to date or are vulnerable to changes made
    manually in error or that maliciously breach standards. *Figure 1**.6* shows the
    dashboard view of Puppet Enterprise, giving a clear view of an estate of servers
    and the status of the last run. This highlights whether the servers are in compliance
    with our state or had to make changes in their previous run:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这个周期每30分钟进行一次。在前面的部分中，重点讨论了语言如何自动化构建服务器。在这里，我们可以看到，通过该平台，我们可以确保所有部署的服务器都被强制执行我们设定的状态；无论是安全标准配置文件，还是我们决定更新某个实现中的设置，比如向IIS添加额外功能。这可以避免服务器漂移，即当服务器难以保持更新或容易受到手动错误更改或恶意违反标准的影响时。*图
    1.6*显示了Puppet Enterprise的仪表板视图，清晰展示了一个服务器群体及其上次运行的状态。这突出显示了服务器是否符合我们的状态要求，或是否在上次运行时做出了更改：
- en: "![Figure 1.\uFEFF6 – The Puppet console status dashboard](img/Figure_01.06.jpg)"
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: "![图 1.\uFEFF6 – Puppet 控制台状态仪表板](img/Figure_01.06.jpg)"
- en: Figure 1.6 – The Puppet console status dashboard
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6 – Puppet 控制台状态仪表板
- en: What we have reviewed so far would presume a common code base, and when any
    code changes are made, all clients would have a new state enforced within the
    next 30 minutes as agents contact the primary server. This would clearly be problematic,
    as bugs will affect all servers within a brief period. This is why Puppet has
    `git`, where the version can be declared as a commit, a tag, or a branch, which
    we can list in a file called a **Puppetfile**.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止我们回顾的内容假设了一个共同的代码库，当任何代码更改发生时，所有客户端将在下一个30分钟内强制执行新的状态，因为代理会联系主服务器。这显然是个问题，因为漏洞将在短时间内影响所有服务器。这就是为什么Puppet使用`git`，其中版本可以声明为提交、标签或分支，我们可以在一个名为**Puppetfile**的文件中列出这些内容。
- en: 'An example module declaration would look like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例模块声明看起来像这样：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By maintaining this `git`, in what is known as a **control** repo, it is possible
    to represent multiple environments by having different branches with different
    versions of the Puppet file.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在所谓的**控制**仓库中维护这个`git`，可以通过拥有不同版本的Puppet文件的不同分支，来表示多个环境。
- en: A common practice is to match environments against how your organization classifies
    server usage. Normally, this means a minimum of a development environment and
    a production environment. So, changes can be tested against servers in development,
    and then the successfully tested ones can be deployed to production. This can
    be taken further using canary environments to test small subsets of the server.
    This approach can all be customized to the change and risk setup of different
    organizations.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见做法是根据您的组织如何分类服务器使用情况来匹配环境。通常，这意味着至少有一个开发环境和一个生产环境。因此，可以在开发服务器上测试更改，经过成功测试的更改可以部署到生产环境中。这个过程可以通过使用金丝雀环境（canary
    environments）来进一步测试服务器的小子集。这种方法可以根据不同组织的变化和风险设置进行定制。
- en: All the facts and reports we mentioned, as part of the agent cycle, are stored
    in `PuppetDB`, a frontend database for PostgreSQL. which is designed to manage
    Puppet data such as reports and facts. This is used with the `CMDB` style data
    and for combinations where we can check whether a certain resource for a role
    had changed, which could indicate a change breach had taken place.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到的所有事实和报告，作为代理周期的一部分，都存储在`PuppetDB`中，这是一个基于PostgreSQL的前端数据库，专门用于管理Puppet数据，如报告和事实。它与`CMDB`风格的数据一起使用，可以检查某个角色的特定资源是否发生了变化，从而可能表明发生了变更违规。
- en: So, in this section, we have seen that the Puppet platform gives a way to progressively
    deploy new code based on environments. It stores facts about the clients along
    with the reports generated on each run, giving a powerful view of CMDB along with
    audit and compliance information in the reports as we confirm what state the servers
    are in. This can all be searched using PQL. This can lead to huge savings in operational
    toil in terms of audit and compliance report generation and helps avoid building
    technical debt as standards and configurations change.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这一部分中，我们已经看到Puppet平台提供了一种基于环境逐步部署新代码的方式。它存储有关客户端的事实以及每次运行生成的报告，提供了强大的CMDB视图，并在报告中提供了审核和合规性信息，我们可以确认服务器处于何种状态。这些信息都可以通过PQL进行搜索。这可以大大减少在审核和合规报告生成中的操作负担，并有助于避免随着标准和配置的变化而积累技术债务。
- en: Common misconceptions
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见误解
- en: '*Isn’t* *Puppet dead?*'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '*难道* *Puppet已经过时了吗？*'
- en: The focus of bleeding-edge technology has moved on to serverless and other **Software-as-a-Service**
    (**SaaS**)/containerized offerings, while at an **Infrastructure-as-a-Service**
    (**IaaS**) level, development in Puppet has reached a much greater level of maturity.
    10 years ago, you might have bought this book assuming it was relevant regardless
    of whether you were going to work with Puppet. Today, you have a Puppet solution
    to implement or understand.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 尖端技术的焦点已经转向无服务器和其他**软件即服务**（**SaaS**）/容器化的解决方案，而在**基础设施即服务**（**IaaS**）层面，Puppet的发展已达到更高的成熟度。十年前，你可能会买这本书，认为无论是否打算使用Puppet，它都是相关的。今天，你有一个Puppet解决方案需要实施或理解。
- en: '*I need to know Ruby to* *use Puppet*.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '*我需要了解Ruby才能* *使用Puppet*。'
- en: Some basic knowledge of Ruby would be an advantage for certain areas of Puppet
    code. A focus on the good use of the Puppet language to get early returns is what
    this book will focus on, and the reality is that the majority of Puppet professionals
    don’t spend much time with Ruby trying to create customizations. Even specialists
    working for Puppet itself find that it can be some time before they need to write
    something custom in Ruby.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些Puppet代码领域，具备Ruby的基础知识会有所帮助。本书将重点讲解如何良好地使用Puppet语言以快速获得回报，现实情况是，大多数Puppet专业人员并不会花太多时间在Ruby上进行自定义开发。即使是为Puppet公司工作的专家，也发现有时需要写自定义Ruby代码之前，可能需要等上一段时间。
- en: '*Puppet won’t work with our* *change management*.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '*Puppet不能与我们的* *变更管理* *协作*。'
- en: A big fear is the idea of Puppet making changes outside the scope of governance
    and change management. This often reflects assumptions and a lack of communication
    with change management teams. Puppet will enforce the state you have described;
    therefore, changes will only happen if the state described in the code has changed
    or if it has been changed outside of Puppet’s control. As previously mentioned,
    as long as it is agreed that Puppet is the way to define particular resources,
    any change to the state should be seen as outside of governance and, therefore,
    put back into place. Later chapters will discuss how to release code and environments
    to ensure that Puppet remains properly access-controlled and, therefore, within
    governance.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的担忧是Puppet在治理和变更管理范围之外进行修改的想法。这通常反映了假设和与变更管理团队缺乏沟通的情况。Puppet会强制执行你描述的状态；因此，只有在代码中描述的状态发生变化或在Puppet控制之外被修改时，才会发生变化。如前所述，只要达成一致，Puppet就是定义特定资源的方式，任何对状态的更改都应该视为治理范围外的内容，因此应该恢复到原状态。后续章节将讨论如何发布代码和环境，确保Puppet保持适当的访问控制，从而确保其处于治理范围内。
- en: '*I can’t make manual changes* *or exceptions*.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*我不能进行手动修改* *或例外处理*。'
- en: This could certainly happen if users try to work around Puppet. To avoid this,
    it’s important to define what Puppet is responsible for, what other tooling or
    manual processes are responsible for, and how exceptions should be requested and
    approved in your system. As will be discussed in *Chapters 8* and *9*, by using
    parameters in modules and Hiera for exceptions, a controlled method can be used
    for exceptions, which also keeps a record in code.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户试图绕过Puppet，这种情况肯定会发生。为避免这种情况，明确Puppet的责任范围、其他工具或手动流程的责任范围以及如何在系统中请求和批准例外是非常重要的。正如*第8章*和*第9章*中所讨论的，通过在模块和Hiera中使用参数来处理例外，可以采用一种受控的方法处理例外，并且能够在代码中保留记录。
- en: '*I need Puppet Enterprise to use add-ons* *and integrations*.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*我需要Puppet Enterprise才能使用附加组件* *和集成*。'
- en: There is a huge amount of confusion, particularly from industry analysts, who
    make comparisons about what users get with Puppet Enterprise and how open source
    might be limited. This book will go into more depth in [*Chapter 14*](B18492_14.xhtml#_idTextAnchor340),
    but the fundamental difference for Puppet Enterprise is you are paying for support,
    services, and pre-canned modules, infrastructure, and solutions. If you have the
    skills, developers, and time, all of these features can be replicated in open
    source. Ultimately, Enterprise runs on the open source components.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '*Everyone will need to* *learn Puppet*.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: A major focus of this book will be the importance of structuring code to allow
    for self-service processes. This avoids users who might wish to have small exceptions
    or integrations having to learn everything as a Puppet developer and only having
    to understand your offerings.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '*It will clash with* *other systems*.'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: The key part is to understand what Puppet will be responsible for and what other
    systems will be responsible for, and to document this well. Many environments
    will run multiple configuration management, orchestration, and software management
    tools. The important thing is to use them to their strengths with clear boundaries.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how Puppet was created by Luke Kaines as a stateful
    language to ease the automation of the configuration management of servers. We
    learned how using this stateful approach provides a language more natural for
    describing user requirements for configuration management and reduces the complexity
    involved in more traditional procedural approaches.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: We looked at an overview of the core language terms and components and how they
    are structured via roles, profiles, and modules. This structure offers a natural
    way to create customer offerings, technical stacks, and reusable technical modules.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: We looked at how the states described in the language are then applied to hosts
    via Puppet runs, and from these runs, we examined how valuable audit and compliance
    information can be gathered and stored in `PuppetDB`. We discussed how code can
    be managed in environments to allow the gradual release of state changes in a
    managed way in logical groups of servers that suits your organization’s risk appetite
    and development structure.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: The chapter discussed some misconceptions around Puppet along with the main
    themes of relevance, complexity, and flexibility. Puppet’s maturity and focus
    on IaaS make it less fashionable, but using patterns and modules developed by
    Puppet and the community allows you to use Puppet to its strengths and deliver
    automation and self-service configuration and compliance to customers. Ensuring
    clear boundaries and responsibilities so that Puppet can integrate with, and work
    alongside, other tooling and teams avoids clashes and allows others to interact
    with Puppet and gain the benefits.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will review the major changes that have taken place
    in Puppet since version 5 and in the latest version, 7\. Recommendations of the
    tooling to use to create an effective development environment will be made, and
    the creation of lab environments will be outlined and demonstrated. Additional
    reference sites will be outlined to allow readers to continue their research and
    stay up to date with developments in Puppet. This will ensure that as we start
    on the technical details in the following chapters, you will have the capability
    to test and experiment in your own environment and follow up in more detail on
    your points of interest.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将回顾自版本5以来，Puppet发生的主要变化，以及最新版本7的变化。将提供推荐的工具，以帮助创建一个有效的开发环境，并将概述和演示实验室环境的创建。此外，还将列出额外的参考网站，供读者继续研究，并跟进Puppet的最新发展。这将确保在接下来的章节中，我们开始讲解技术细节时，你能够在自己的环境中进行测试和实验，并深入跟进你感兴趣的内容。
