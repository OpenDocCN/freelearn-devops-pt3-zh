["```\nservice Ops {\n     rpc ListTraces(ListTracesReq) returns (ListTracesResp) {};\n     rpc ShowTrace(ShowTraceReq) returns (ShowTraceResp) {};\n     rpc ChangeSampling(ChangeSamplingReq) returns (ChangeSamplingResp) {};\n     rpc DeployedVersion(DeployedVersionReq) returns (DeployedVersionResp) {};\n     rpc Alerts(AlertsReq) returns (AlertsResp) {};\n}\n```", "```\npackage bot\nimport (\n        \"log\"\n        \"context\"\n        \"regexp\"\n        \"encoding/json\"\n        \"github.com/slack-go/slack\"\n        \"github.com/slack-go/slack/slackevents\"\n        \"github.com/slack-go/slack/socketmode\"\n)\n```", "```\ntype HandleFunc func(ctx context.Context, m Message)\ntype register struct{\n        r *regexp.Regexp\n        h HandleFunc\n}\n```", "```\ntype Message struct {\n        User *slack.User\n        AppMention *slackevents.AppMentionEvent\n        Text string\n}\n```", "```\ntype Bot struct {\n    api *slack.Client\n    client *socketmode.Client\n    ctx context.Context\n    cancel context.CancelFunc\n    defaultHandler HandleFunc\n    reg []register\n}\nfunc New(api *slack.Client, client *socketmode.Client) (*Bot, error) {\n    b := &Bot{\n            api: api,\n            client: client,\n            ctx: ctx,\n            cancel: cancel,\n    }\n    return b, nil\n}\n```", "```\nfunc (b *Bot) Start() {\n     b.ctx, b.cancel = context.WithCancel(context.Background())\n     go b.loop()\n     b.client.RunContext(b.ctx)\n}\nfunc (b *Bot) Stop() {\n     b.cancel()\n     b.ctx = nil\n     b.cancel = nil\n}\n```", "```\nfunc (b *Bot) Register(r *regexp.Regexp, h HandleFunc) { \n    if h == nil { \n        panic(\"HandleFunc cannot be nil\") \n    } \n    if r == nil {\n        if b.defaultHandle != nil {\n                panic(\"cannot add two default handles\")\n        }\n        b.defaultHandle = h\n        return\n    }\n    b.reg = append(b.reg, register{r, h})\n}\n```", "```\nfunc (b *Bot) loop() {\n    for {\n        select {\n        case <-b.ctx.Done():\n                return\n        case evt := <-b.client.Events:\n            switch evt.Type {\n            case socketmode.EventTypeConnectionError:\n                    log.Println(\"connection failed. Retrying later...\")\n            case socketmode.EventTypeEventsAPI:\n                    data, ok := evt.Data.(slackevents.EventsAPIEvent)\n                    if !ok {\n                            log.Println(\"bug: got type(%v) which should be a slackevents.EventsAPIEvent, was %T\", evt.Data)\n                            continue\n                    }\n                    b.client.Ack(*evt.Request)\n                    go b.appMentioned(data)\n            }\n        }\n    }\n}\n```", "```\nfunc (b *Bot) appMentioned(ctx context.Context, data slackevents.EventsAPIEvent) {\n    switch data.Type {\n    case slackevents.CallbackEvent:\n            callback := data.Data.(*slackevents.EventsAPICallbackEvent)\n            switch ev := data.InnerEvent.Data.(type) {\n            case *slackevents.AppMentionEvent:                \n                msg, err := b.makeMsg(ev)\n                if err != nil {\n                    log.Println(err)\n                    return\n                }\n                for _, reg := range b.reg {\n                    if reg.r.MatchString(m.Text){\n                            reg.h(ctx, b.api, b.client, m)\n                            return\n                    }\n                }\n                if b.defaultHandler != nil {\n                    b.defaultHandler(ctx, m)\n                }\n            }\n    default:\n        b.client.Debugf(\"unsupported Events API event received\")\n    }\n```", "```\nlist traces operation=AddPets() limit=25\n```", "```\ntype Ops struct {\n     OpsClient *client.Ops\n     API       *slack.Client\n     SMClient  *socketmode.Client\n}\nfunc (o Ops) write(m bot.Message, s string, i ...interface{}) error {\n     _, _, err := o.API.PostMessage(\n          m.AppMention.Channel,\n          slack.MsgOptionText(fmt.Sprintf(s, i...), false),\n     )\n     return err\n}\n```", "```\nvar listTracesRE = regexp.MustCompile(`(\\S+)=(?:(\\S+))`)\ntype opt struct {\n     key string\n     val string\n}\n```", "```\nfunc (o Ops) ListTraces(ctx context.Context, m bot.Message) {\n\tsp := strings.Split(m.Text, \"list traces\")\n\tif len(sp) != 2 {\n\t\to.write(m, \"The 'list traces' command is malformed\")\n\t\treturn\n\t}\n\tt := strings.TrimSpace(sp[1])\n\tkvOpts := []opt{}\n\tmatches := listTracesRE.FindAllStringSubmatch(t, -1)\n\tfor _, match := range matches {\n\t\tkvOpts = append(\n\t\t\tkvOpts,\n\t\t\topt{\n\t\t\t\tstrings.TrimSpace(match[1]),\n\t\t\t\tstrings.TrimSpace(match[2]),\n\t\t\t},\n\t\t)\n\t}\n```", "```\n\toptions := []client.CallOption{}\n\tfor _, opt := range kvOpts {\n\t\tswitch opt.key {\n\t\tcase \"operation\":\n\t\t\toptions = append(\n\t\t\t\toptions,\n\t\t\t\tclient.WithOperation(opt.val),\n\t\t\t)\n\t\tcase \"start\":\n\t\t\tt, err := time.Parse(\n\t\t\t\t`01/02/2006-15:04:05`, opt.val,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\to.write(m, \"The start option must be in the form `01/02/2006-15:04:05` for UTC\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\toptions = append(options, client.WithStart(t))\n\t\tcase \"end\":\n\t\t\tif opt.val == \"now\" {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tt, err := time.Parse(\n\t\t\t\t`01/02/2006-15:04:05`, opt.val,\n\t\t\t)\n\t\t\tif err != nil {\n\t\t\t\to.write(m, \"The end option must be in the form `01/02/2006-15:04:05` for UTC\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\toptions = append(options, client.WithEnd(t))\n\t\tcase \"limit\":\n\t\t\ti, err := strconv.Atoi(opt.val)\n\t\t\tif err != nil {\n\t\t\t\to.write(m, \"The limit option must be an integer\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\tif i > 100 {\n\t\t\t\to.write(m, \"Cannot request more than 100 traces\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\toptions = append(options, client.WithLimit(int32(i)))\n\t\tcase \"tags\":\n\t\t\ttags, err := convertList(opt.val)\n\t\t\tif err != nil {\n\t\t\t\to.write(m, \"tags: must enclosed in [], like tags=[tag,tag2]\")\n\t\t\t\treturn\n\t\t\t}\n\t\t\toptions = append(options, client.WithLabels(tags))\n\t\tdefault:\n\t\t\to.write(m, \"don't understand an option type(%s)\", opt.key)\n\t\t\treturn\n\t\t}\n\t}\n```", "```\n\ttraces, err := o.OpsClient.ListTraces(ctx, options...)\n\tif err != nil {\n\t\to.write(m, \"Ops server had an error: %s\", err)\n\t\treturn\n\t}\n\tb := strings.Builder{}\n\tb.WriteString(\"Here are the traces you requested:\\n\")\n\ttable := tablewriter.NewWriter(&b)\n\ttable.SetHeader([]string{\"Start Time(UTC)\", \"Trace ID\"})\n\tfor _, item := range traces {\n\t\ttable.Append(\n\t\t\t[]string{\n\t\t\t\titem.Start.Format(\"01/02/2006 04:05\"),\n\t\t\t\t\"http://127.0.0.1:16686/trace/\" + item.ID,\n\t\t\t},\n\t\t)\n\t}\n\ttable.Render()\n\to.write(m, b.String())\n}\n```", "```\nvar help = map[string]string{\n     \"list traces\": `\nlist traces <opt1=val1 op2=val2>\nEx: list traces operation=AddPets() limit=5\n...\n`,\n}\nvar cmdList string\nfunc init() {\n     cmds := []string{}\n     for k := range help {\n          cmds = append(cmds, k)\n     }\n     sort.Strings(cmds)\n     b := strings.Builder{}\n     for _, cmd := range cmds {\n          b.WriteString(cmd + \"\\n\")\n     }\n     b.WriteString(\"You can get more help by saying `help <cmd>` with a command from above.\\n\")\n     cmdList = b.String()\n}\n```", "```\nfunc (o Ops) Help(ctx context.Context, m bot.Message) {\n     sp := strings.Split(m.Text, \"help\")\n     if len(sp) < 2 {\n          o.write(m, \"%s,\\nYou have to give me a command you want help with\", m.User.Name)\n          return\n     }\n     cmd := strings.TrimSpace(strings.Join(sp[1:], \"\"))\n     if cmd == \"\" {\n          o.write(m, \"Here are all the commands that I can help you with:\\n%s\", cmdList)\n          return\n     }\n     if v, ok := help[cmd]; ok {\n          o.write(m, \"I can help you with that:\\n%s\", v)\n          return\n     }\n     o.write(m, \"%s,\\nI don't know what %q is to give you help\", m.User.Name, cmd)\n}\n```", "```\nfunc (o Ops) lastResort(ctx context.Context, m bot.Message) {\n     o.write(m, \"%s,\\nI don't have anything that handles what you sent.  Try the 'help' command\", m.User.Name)\n}\n```", "```\nfunc (o Ops) Register(b *bot.Bot) {\n     b.Register(regexp.MustCompile(`^\\s*help`), o.Help)\n     b.Register(regexp.MustCompile(`^\\s*list traces`), o.ListTraces)\n     b.Register(nil, o.lastResort)\n}\n```", "```\nfunc main() { \n    ... // Other setup like slack client init \n    b, err := bot.New(api, client) \n    if err != nil { \n        panic(err) \n    } \n    h := handlers.Ops{\n        OpsClient: opsClient, \n        API: api, \n        SMClient: smClient,\n    }\n    h.Register(b) \n    b.Start() \n} \n```", "```\n    docker-compose up -d\n    ```", "```\n    AUTH_TOKEN=xoxb-[the rest of the token]\n    APP_TOKEN=xapp-[the rest of the token]\n    ```", "```\n    go run chatbot.go\n    ```", "```\n    Bot started\n    ```", "```\ngo run go run petstore.go --help\n```"]