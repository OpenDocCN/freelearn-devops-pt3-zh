- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Bolt for Orchestration
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用于编排的Bolt
- en: In this chapter, we will cover **Bolt** and Puppet Enterprise’s **orchestrator**.
    We will show how Bolt is Puppet’s tool for ad hoc orchestration, allowing work
    to be done that does not fit into Puppet’s state-based enforcement model. We will
    discuss how to configure it to connect to clients with different transport mechanisms
    and credentials and run simple commands and upload files. Furthermore, we will
    show how **tasks** allow single-action scripts in various languages to be run
    via Bolt, while **plans** allow combinations of tasks to be written using logic
    and variables in the Puppet or YAML language. The project directory structure
    will be examined, allowing Bolt content to be stored and shared. This will be
    compared to how plans and tasks can be stored in a Puppet module using the **Puppet
    Enterprise Cloud Deployment Module** (**PECDM**) **Bolt project** as an example.
    We will then show how Bolt can be extended with plugins to dynamically load information
    from other sources. We will also show how Bolt can directly be used with Puppet
    to apply manifest blocks, connect to PuppetDB, and use Hiera.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍**Bolt**和Puppet Enterprise的**orchestrator**。我们将展示Bolt是Puppet用于临时编排的工具，能够处理不适合Puppet基于状态强制执行模型的工作。我们将讨论如何配置它以连接具有不同传输机制和凭证的客户端，并执行简单命令和上传文件。此外，我们将展示如何通过Bolt运行**tasks**，这些任务可以是多种语言的单一操作脚本，而**plans**则允许通过逻辑和变量在Puppet或YAML语言中编写任务组合。我们还将探讨项目目录结构，允许存储和共享Bolt内容。这将与如何使用**Puppet
    Enterprise Cloud Deployment Module**（**PECDM**）**Bolt项目**作为示例，将计划和任务存储在Puppet模块中进行比较。接着，我们将展示如何通过插件扩展Bolt，从其他来源动态加载信息。我们还将展示如何将Bolt与Puppet直接结合使用，应用清单块，连接到PuppetDB，并使用Hiera。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下主要内容：
- en: Exploring and configuring Bolt
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索和配置Bolt
- en: Understanding the structure of projects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解项目的结构
- en: Introducing tasks and plans
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务与计划介绍
- en: Plugins
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 插件
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Clone the control repo, `controlrepo-chapter12`, from [https://github.com/puppetlabs/control-repo](https://github.com/puppetlabs/control-repo)
    to your GitHub account and update the Puppetfile with the contents of [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch12/Puppetfile](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch12/Puppetfile)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 将控制仓库`controlrepo-chapter12`从[https://github.com/puppetlabs/control-repo](https://github.com/puppetlabs/control-repo)克隆到您的GitHub账户，并用[https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch12/Puppetfile](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch12/Puppetfile)的内容更新Puppetfile。
- en: 'Build a standard cluster with two Unix clients and two Windows clients by downloading
    the `params.json` file from [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch12/params.json](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch12/params.json)
    and updating it with the location of your control repo and your SSH key for the
    control repo. Then, run the following command from your `pecdm` directory:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从[https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch12/params.json](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch12/params.json)下载`params.json`文件，并更新其中的控制仓库位置和控制仓库的SSH密钥，构建一个标准集群，包含两个Unix客户端和两个Windows客户端。然后，在`pecdm`目录中运行以下命令：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Exploring and configuring Bolt
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索和配置Bolt
- en: Throughout this book so far, we have focused on Puppet’s strengths as a state-based
    and idempotent configuration management tool. But there are situations where this
    approach simply doesn’t fit, such as service restarts as part of troubleshooting
    or ordering application deployments with vendor-based install scripts. There is
    any number of tasks that fit into the wider automation effort that are ad hoc
    and single use; therefore, Bolt was introduced by Puppet to act as an agentless
    orchestrator. Bolt is now in its 3.x version, since its release in 2017, and a
    lot of rapid development has taken place. Over 2022, it stabilized, with far fewer
    releases and changes to features, but we would strongly advise you to keep Bolt
    as up to date as possible to avoid any confusion.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书主要集中在Puppet作为基于状态和幂等的配置管理工具的优势。但也有一些场景，其中这种方法并不适用，例如作为故障排除一部分的服务重启，或者使用供应商提供的安装脚本进行应用部署排序。许多任务属于更广泛自动化努力的一部分，属于临时和一次性的任务；因此，Puppet推出了Bolt，作为一个无代理的编排工具。自2017年发布以来，Bolt已经进入3.x版本，并且经历了快速的发展。到了2022年，Bolt趋于稳定，发布和功能更新大大减少，但我们强烈建议您尽可能保持Bolt的最新版本，以避免任何混淆。
- en: Having reviewed the general purpose of Bolt as an ad hoc task runner, the first
    step is to understand how Bolt can connect to clients with transports and targets.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在审阅了Bolt作为临时任务运行器的通用目的之后，第一步是理解Bolt如何通过传输和目标连接到客户端。
- en: Connecting to clients with transports and targets
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过传输和目标连接到客户端
- en: Bolt is a fully open sourced project available at [https://github.com/puppetlabs/bolt](https://github.com/puppetlabs/bolt),
    written in `bolt`. It connects to devices via one of the various **transports**
    it offers, which is the mechanism/protocol that allows it to establish a connection
    to multiple platforms, such as virtual machines, network devices, or containers
    without an agent. The transports available are as follows.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Bolt是一个完全开放源项目，位于[https://github.com/puppetlabs/bolt](https://github.com/puppetlabs/bolt)，使用`bolt`编写。它通过提供的各种**传输**连接到设备，这是一种机制/协议，允许它在不需要代理的情况下建立到多个平台（如虚拟机、网络设备或容器）的连接。可用的传输如下。
- en: 'System transports:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 系统传输：
- en: Local, which, as would be expected, just runs commands on a local machine.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地，顾名思义，仅在本地机器上运行命令。
- en: '`net-ssh` Ruby library or `native ssh`, if selected. Commonly used for Linux
    and Unix machines.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`net-ssh` Ruby库或`native ssh`，如果选择使用的话。通常用于Linux和Unix机器。'
- en: '**Windows Remote Management** (**WinRM**) for connecting to Microsoft Windows-based
    machines.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Windows远程管理**（**WinRM**），用于连接基于Microsoft Windows的机器。'
- en: Remote, which is used for API- or web-based devices, for example, network devices
    such as switches.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 远程，用于API或基于Web的设备，例如网络设备如交换机。
- en: 'Puppet Enterprise transport:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet Enterprise传输：
- en: '**Puppet Communication Protocol** (**PCP**), used with the Puppet Enterprise
    orchestrator service, discussed in [*Chapter 14*](B18492_14.xhtml#_idTextAnchor340)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Puppet通信协议**（**PCP**），与Puppet Enterprise编排服务一起使用，在[*第14章*](B18492_14.xhtml#_idTextAnchor340)中讨论。'
- en: 'Container transports:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 容器传输：
- en: Docker, which is an application container technology developed by Docker Inc
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker，由Docker Inc开发的应用容器技术。
- en: '**Pod Manager** (**Podman**), which is an application container engine developed
    by Red Hat'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pod管理器**（**Podman**），由Red Hat开发的应用容器引擎。'
- en: '**Linux Container Hypervisor** (**LXD**), which is a system container engine
    that uses **Linux Containers** (**LXC**), developed by [https://linuxcontainers.org](https://linuxcontainers.org)
    and sponsored by Canonical'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Linux容器超级监视程序**（**LXD**），是一个使用**Linux容器**（**LXC**）的系统容器引擎，由[https://linuxcontainers.org](https://linuxcontainers.org)开发并由Canonical赞助。'
- en: Note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Bolt fails to connect to targets from Windows using SSH unless `native-ssh`
    is set to `true` in the transport settings, as per [https://puppet.com/docs/bolt/latest/bolt_known_issues.html#unable-to-authenticate-with-ed25519-keys-over-ssh-transport-on-windows](https://puppet.com/docs/bolt/latest/bolt_known_issues.html#unable-to-authenticate-with-ed25519-keys-over-ssh-transport-on-windows).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 除非在传输设置中将`native-ssh`设置为`true`，否则Bolt无法使用SSH连接到Windows目标，具体参见[https://puppet.com/docs/bolt/latest/bolt_known_issues.html#unable-to-authenticate-with-ed25519-keys-over-ssh-transport-on-windows](https://puppet.com/docs/bolt/latest/bolt_known_issues.html#unable-to-authenticate-with-ed25519-keys-over-ssh-transport-on-windows)。
- en: 'By default, Bolt will use local SSH configuration and at its simplest level
    can run commands directly on devices that are known in Bolt terminology as **targets**.
    A simple example command is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Bolt将使用本地SSH配置，在其最简单的级别上可以直接在被称为**目标**的设备上运行命令。一个简单的例子命令如下：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, the command is within single quotes and the provided target is a resolvable
    hostname or an IP address. Bolt also has **PowerShell cmdlets**, which provide
    a more integrated experience for PowerShell users with more flexibility for chaining
    commands and using structured data for arguments. The same command as previously
    but as a PowerShell cmdlet would look as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，命令在单引号内，提供的目标是可解析的主机名或IP地址。Bolt还具有**PowerShell命令**，为PowerShell用户提供更集成的体验，具有更灵活的命令链接和使用结构化数据作为参数的能力。与之前相同的命令作为PowerShell命令看起来如下：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This takes the default settings of the SSH transport using the current user
    and any saved credentials. To make a choice on the command line, a transport choice
    can be added ahead of the transport name, `<transport_name>://`, multiple targets
    are listed, separated with commas (`,`) and additional options are set to configure
    the transport. For example WinRM requires a username, password and the `no-ssl`
    option set if SSL is not setup for WinRM connections. Take the following example
    command:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这会使用默认的 SSH 传输设置，使用当前用户和任何已保存的凭证。如果想在命令行中做出选择，可以在传输名称前加上传输选择 `<transport_name>://`，多个目标使用逗号（`,`）分隔，并设置其他选项来配置传输。例如，如果
    WinRM 没有配置 SSL 连接，则需要设置用户名、密码和 `no-ssl` 选项。以下是一个示例命令：
- en: '[PRE3]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This command will run `systeminfo` on the `host1.example.com` and `host2.example.com`
    targets using `winrm` to connect, and the `windows` and `Pupp3tL@b5P0rtl@nd!`
    credentials with no SSL check. Bolt runs requests concurrently, by default up
    to 50 at a time. This can be changed using the concurrent argument, `--concurrent`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将使用 `winrm` 连接在 `host1.example.com` 和 `host2.example.com` 目标上运行 `systeminfo`，并使用
    `windows` 和 `Pupp3tL@b5P0rtl@nd!` 凭证，同时不进行 SSL 检查。Bolt 默认并行运行请求，最多同时运行 50 个请求。可以通过
    `--concurrent` 参数调整并发数。
- en: 'A full list of options available to be used with each transport can be viewed
    in the documentation: [https://puppet.com/docs/bolt/latest/bolt_transports_reference.html](https://puppet.com/docs/bolt/latest/bolt_transports_reference.html).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在文档中查看每种传输方式的完整选项列表：[https://puppet.com/docs/bolt/latest/bolt_transports_reference.html](https://puppet.com/docs/bolt/latest/bolt_transports_reference.html)。
- en: Note
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Bolt 1.3.6 deprecated the `nodes` flag in favor of `targets` and removed it
    in Bolt 2.0.0.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Bolt 1.3.6 弃用了 `nodes` 标志，改为使用 `targets`，并在 Bolt 2.0.0 中移除了该标志。
- en: Running ad hoc commands with Bolt
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Bolt 运行临时命令
- en: 'In this section, we will show how to run ad hoc commands with Bolt, using both
    Windows PowerShell and Linux Shell command examples. The following table shows
    how these commands compare across the implementations:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将展示如何使用 Bolt 运行临时命令，包括 Windows PowerShell 和 Linux Shell 命令示例。下表展示了这些命令在不同实现中的对比：
- en: "![Figure 12.1 \uFEFF– PowerShell and Linux Bolt commands](img/B18492_12_01.jpg)"
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.1 – PowerShell 和 Linux Bolt 命令](img/B18492_12_01.jpg)'
- en: Figure 12.1 – PowerShell and Linux Bolt commands
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – PowerShell 和 Linux Bolt 命令
- en: 'To run quoted commands, use double quotes or backslashes (`\`) to escape. For
    example, we could run a search for `lang` in `/etc/locale` with `grep -I ''lang''`.
    To do this, the following command could be run in PowerShell:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行带引号的命令，请使用双引号或反斜杠（`\`）进行转义。例如，我们可以在 `/etc/locale` 中搜索 `lang`，命令为 `grep -I
    'lang'`。为了做到这一点，可以在 PowerShell 中运行以下命令：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this example, the `password-prompt` option would ask for the password securely
    on the command line rather than directly entering it into the executed command.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`password-prompt` 选项将在命令行上安全地提示输入密码，而不是直接将其输入到执行的命令中。
- en: 'To run multiple commands listed in a file, we are not suggesting running a
    script but a step-by-step set of commands; for multiple targets in a file, the
    at symbol (`@`) can be used with the filename within quotes (`''''`). So, for
    example, to run a list of commands from a file called `commandlist` on a list
    of targets in `targetfile`, the following command could be run:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行文件中列出的多个命令，我们不是建议运行脚本，而是逐步执行一组命令；对于文件中的多个目标，可以使用 `@` 符号和引号包围的文件名（`''`）。例如，要从名为
    `commandlist` 的文件中运行一组命令，并在 `targetfile` 中列出的目标上执行，可以运行以下命令：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'For Unix-based systems, to read input from `stdin` for targets or commands,
    the minus symbol (`-`) can be used in place of a target or command string. So,
    to take the same `targetfile` and send the output of the `cat` command to the
    `bolt` command, the following could be run:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基于 Unix 的系统，要从 `stdin` 读取输入以供目标或命令使用，可以用减号（`-`）替代目标或命令字符串。因此，若想使用相同的 `targetfile`
    并将 `cat` 命令的输出传递给 `bolt` 命令，可以运行以下命令：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To run the `uname` and `date` commands on the `hosts1.example.com` and `host2.example.com`
    targets, the following could be command could be used:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 `hosts1.example.com` 和 `host2.example.com` 目标上运行 `uname` 和 `date` 命令，可以使用以下命令：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Using both a file and `stdin` with a list of commands will result in a single
    connection to the target to run all the commands.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 同时使用文件和 `stdin` 列出命令将导致与目标建立单一连接，执行所有命令。
- en: 'To run a script in a file, the `bolt script run` command or `Invoke-BoltScript
    -Script` PowerShell cmdlet can be used along with any arguments to be passed at
    the end of the command. For example, on a Unix host, the following command could
    be used to run an `install.sh` script on the targets in the `application_clients`
    file with `10.6` `no-gui` arguments:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行文件中的脚本，可以使用`bolt script run`命令或`Invoke-BoltScript -Script`PowerShell cmdlet，并在命令末尾传递任何参数。例如，在Unix主机上，可以使用以下命令在`application_clients`文件中的目标上运行带有`10.6`
    `no-gui`参数的`install.sh`脚本：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `arguments` flag can be used to be clearer on the name of the argument
    for each passed value. Any argument with spaces can be surrounded with quotes
    (`''''`). For example, on a Windows system running the `dotnet-install.ps1` script
    on a list of targets on a file with the `-Channel LTS` argument, the command would
    be as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`arguments`标志来明确每个传递值的参数名称。任何带空格的参数可以用引号（`''`）括起来。例如，在Windows系统上运行带有`-Channel
    LTS`参数的`dotnet-install.ps1`脚本，命令如下：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In Unix, any script can be executed on a target by including a shebang (`#!`)
    line at the top of the file specifying the interpreter. For Windows targets, the
    `.ps1`, `.rb`, and `.pp` files are enabled by default, but further extensions
    can be enabled in configuration files, which will be discussed in the next section.
    The scripts can be located from the `modulepath`, this can be of the form `<modulename>/scripts/install.sh`,
    a relative path from the root of the `bolt` folder, or as an absolute path.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix中，任何脚本都可以通过在文件顶部包含一个shebang（`#!`）行来指定解释器，从而在目标上执行。对于Windows目标，`.ps1`、`.rb`和`.pp`文件默认启用，但可以在配置文件中启用其他扩展，这将在下一部分讨论。脚本可以从`modulepath`中找到，形式为`<modulename>/scripts/install.sh`，也可以是`bolt`文件夹根目录的相对路径，或者是绝对路径。
- en: 'In Unix systems, Puppet manifest files and sections of Puppet code can be applied
    to a set of targets with the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unix系统中，Puppet清单文件和Puppet代码的部分可以通过以下方式应用到一组目标：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In PowerShell, this can be achieved with the following command:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在PowerShell中，可以使用以下命令实现：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'To apply Puppet code, the following command would ensure that a `/etc/exampleapp`
    directory exists on the Unix systems:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要应用Puppet代码，以下命令会确保Unix系统上的`/etc/exampleapp`目录存在：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'For PowerShell cmdlets, the command used would be as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 对于PowerShell cmdlets，使用的命令如下：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This format should seem similar to `puppet apply` and `puppet apply -e ''<code>''`.
    Similarly, for code to be applied via Bolt, we must ensure that the code is declared
    to be included in a catalog and not just defined. When a class or type is defined,
    it is available to be used in the catalog but it will not have been added to the
    catalog. In the previous example, if `exampleapp.pp` contained a class definition
    with resources, this would result in a warning: `Manifest only contains definitions
    and will result in no changes on the targets`. The class itself would need to
    be included for it to be added to the catalog and applied via Bolt.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这种格式应该与`puppet apply`和`puppet apply -e '<code>'`相似。类似地，对于通过Bolt应用的代码，我们必须确保代码被声明为包含在目录中，而不仅仅是定义了。当一个类或类型被定义时，它可以在目录中使用，但不会被添加到目录中。在前面的示例中，如果`exampleapp.pp`包含一个带有资源的类定义，那么会出现警告：`Manifest
    only contains definitions and will result in no changes on the targets`。类本身需要被包含才能将其添加到目录中，并通过Bolt应用。
- en: 'There are also commands to upload files from your local machine to the target
    or to download from the targets to your machine. Some simple examples using both
    the Unix version and the Windows version are shown in the following commands.
    The first file listed is the source and the second is the target, regardless of
    whether you’re uploading or downloading:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一些命令可以将文件从本地机器上传到目标，或从目标下载到本地机器。以下命令展示了在Unix和Windows版本中的一些简单示例。第一个列出的文件是源文件，第二个是目标文件，无论是上传还是下载：
- en: '[PRE14]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, let’s take a look at the output.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下输出。
- en: Output and debugging
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 输出和调试
- en: 'So far, the focus has been on how to run commands and not the output. Bolt
    by default logs these commands to the `bolt-debug.log` file in the directory from
    which the Bolt command was run, as well as to the console. There are six logging
    levels:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，重点一直是如何运行命令，而不是输出。默认情况下，Bolt会将这些命令记录到从中运行Bolt命令的目录中的`bolt-debug.log`文件中，并显示在控制台上。共有六个日志级别：
- en: '`trace`: The most detailed level of logging, which shows the inner workings
    of Bolt.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trace`：最详细的日志级别，显示Bolt的内部工作过程。'
- en: '`debug`: Information about target-specific steps.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug`：关于特定目标步骤的信息。'
- en: '`info`: This is high-level logging showing the steps taking place in Bolt.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`info`：这是高级日志，显示 Bolt 中发生的步骤。'
- en: '`warn`: Warning about deprecations and other harmful scenarios. This is the
    default console level.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`warn`：关于弃用功能和其他有害场景的警告。这是默认的控制台级别。'
- en: '`error`: Error messages experienced during the execution of Bolt commands.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`error`：在执行 Bolt 命令时遇到的错误消息。'
- en: '`fatal`: Error messages from Puppet code used with Bolt.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fatal`：来自 Puppet 代码的错误消息，这些代码与 Bolt 一起使用。'
- en: 'A specific log level can be chosen using the `--log-level` flag and the output
    format can be selected using the `format` flag, which can use `human`, `json`,
    or `rainbow`. The output from a Bolt command running `uname` on three hosts would
    look like this in JSON:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `--log-level` 标志选择特定的日志级别，并使用 `format` 标志选择输出格式，支持 `human`、`json` 或 `rainbow`。在三台主机上运行
    `uname` 的 Bolt 命令输出，JSON 格式如下所示：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In comparison, in human-readable format, it would look like this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，以人类可读格式显示时，内容将如下所示：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `rainbow` output looks similar to human-readable format but, as the name
    suggests, it makes the lines multi-colored.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`rainbow` 输出与人类可读格式类似，但正如其名字所示，它使得每一行都呈现为多种颜色。'
- en: 'As part of this output, a `.rerun.json` file will be generated. This will list
    the targets that were processed during the run, indicating which targets failed
    and which succeeded. For the next Bolt command, we can use a `--rerun` flag with
    a value of `success`, `failure`, or `all`. This reads the relevant target section
    from `.rerun.json` to use targets from the previous run. For example, the following
    command could be run as a result of an `install` task failing and choosing to
    run a cleanup task on all failures:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 作为输出的一部分，将生成一个 `.rerun.json` 文件。此文件列出了在运行过程中处理的目标，指示哪些目标失败，哪些目标成功。对于下一个 Bolt
    命令，我们可以使用 `--rerun` 标志，值可以为 `success`、`failure` 或 `all`。此命令将读取 `.rerun.json` 中的相关目标部分，并使用上一次运行的目标。例如，以下命令可能是在
    `install` 任务失败并选择对所有失败进行清理任务时运行：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There are more options for the commands; the full command reference is available
    at [https://puppet.com/docs/bolt/latest/bolt_command_reference.html](https://puppet.com/docs/bolt/latest/bolt_command_reference.html
    ) for Unix-based commands and [https://puppet.com/docs/bolt/latest/bolt_cmdlet_reference.html](https://puppet.com/docs/bolt/latest/bolt_cmdlet_reference.html
    ) for PowerShell-based commands.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 命令有更多选项；完整的命令参考文档可以通过以下链接查看：[https://puppet.com/docs/bolt/latest/bolt_command_reference.html](https://puppet.com/docs/bolt/latest/bolt_command_reference.html)
    针对 Unix 系统的命令和 [https://puppet.com/docs/bolt/latest/bolt_cmdlet_reference.html](https://puppet.com/docs/bolt/latest/bolt_cmdlet_reference.html)
    针对 PowerShell 系统的命令。
- en: Note
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Bolt has a built-in CLI guide that can be accessed by running `bolt guide` on
    the Unix or PowerShell command line.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Bolt 具有内置的 CLI 指南，可以通过在 Unix 或 PowerShell 命令行中运行 `bolt guide` 来访问。
- en: So far, what we have discussed using Bolt for is useful on a very small scale
    but clearly would work with large numbers of servers and more complex configurations.
    So, the next area to cover is the project structure and configuration files.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们使用 Bolt 讨论的内容在非常小的规模下有用，但显然也适用于大规模的服务器和更复杂的配置。因此，接下来要讨论的是项目结构和配置文件。
- en: Understanding the structure of projects
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解项目结构
- en: A `bolt-project.yaml` file exists in it, and this file contains a name key.
    To create this file, run `bolt project init` for Unix systems or `New-BoltProject`
    for PowerShell from within a directory in which you wish to add Bolt project files.
    This will use the name for the project as the name of the directory, but you can
    override this by running it with a name using the `bolt project init customname`
    or `New-BoltProject -Name customname` command, for Unix systems and PowerShell,
    respectively.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中存在一个 `bolt-project.yaml` 文件，该文件包含一个 name 键。要创建该文件，请在希望添加 Bolt 项目文件的目录中，分别针对
    Unix 系统运行 `bolt project init` 或 PowerShell 中运行 `New-BoltProject`。此命令将使用目录名作为项目名称，但你可以通过运行带有名称的命令来覆盖这一点，分别为
    Unix 系统的 `bolt project init customname` 或 PowerShell 中的 `New-BoltProject -Name
    customname` 命令。
- en: This project name must start with a lowercase letter and can only use lowercase
    letters, digits, and underscores. This is because Bolt projects are like modules
    and get loaded into the module path. This is important to note because modules
    contained within the Bolt project will essentially be overwritten in the module
    path if the Bolt project has the same name as the module.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 项目名称必须以小写字母开头，并且只能使用小写字母、数字和下划线。这是因为 Bolt 项目类似于模块，并会加载到模块路径中。需要注意的是，如果 Bolt
    项目与模块具有相同名称，则 Bolt 项目中的模块将被覆盖在模块路径中。
- en: In the directory, the `init` command will have created a `bolt-project.yaml`,
    `inventory.yaml`, and `.``git-ignore` file.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在该目录中，`init` 命令将创建 `bolt-project.yaml`、`inventory.yaml` 和 `.git-ignore` 文件。
- en: Now, let’s look at how we can configure a Bolt project.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何配置一个 Bolt 项目。
- en: Configuring a project
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置项目
- en: '`bolt-project.yaml` contains settings to override the default Bolt behavior,
    a lot of which was discussed in the previous section. The settings to be used
    with the Bolt command can be set here, as well as project configuration such as
    paths to configuration files and data. Largely, the defaults for these settings
    will not need to be changed and the core settings that will be configured include
    the `modules` attribute, which defines modules to manage in the Bolt project,
    and the `plans`, `policies`, and `tasks` attributes, which limit the visibility
    of each item by providing a list that will be visible to project users. A sample
    `bolt-project.yaml` file containing some modules and choosing plans, policies,
    and tasks to be publicly visible could look as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`bolt-project.yaml` 包含用于覆盖默认 Bolt 行为的设置，许多内容在前一节中已经讨论过。可以在此处设置用于 Bolt 命令的设置，以及项目配置，例如配置文件和数据的路径。通常情况下，这些设置的默认值不需要更改，核心设置将包括
    `modules` 属性，该属性定义了在 Bolt 项目中管理的模块，以及 `plans`、`policies` 和 `tasks` 属性，这些属性通过提供可见的列表来限制每个项目项的可见性，用户可以看到该列表。一个包含一些模块，并选择要公开可见的计划、策略和任务的
    `bolt-project.yaml` 文件示例如下：'
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The full list of settings can be found at [https://puppet.com/docs/bolt/latest/bolt_project_reference.html](https://puppet.com/docs/bolt/latest/bolt_project_reference.html).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 设置的完整列表可以在 [https://puppet.com/docs/bolt/latest/bolt_project_reference.html](https://puppet.com/docs/bolt/latest/bolt_project_reference.html)
    中找到。
- en: The `module` attribute has multiple ways to be updated. When adding items from
    Forge, this can be updated via the `bolt module add` Unix command or the `Add-BoltModule`
    PowerShell cmdlet. For example, in Unix systems, `bolt module add puppetlabs/apt`
    will update the `modules` parameter to contain `- name:puppetlabs-apt` in `bolt-project.yaml`.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`module` 属性有多种更新方式。当从 Forge 添加项目时，可以通过 `bolt module add` Unix 命令或 `Add-BoltModule`
    PowerShell cmdlet 更新。例如，在 Unix 系统中，`bolt module add puppetlabs/apt` 将更新 `bolt-project.yaml`
    中的 `modules` 参数，包含 `- name:puppetlabs-apt`。'
- en: 'Then, the `bolt module install` Unix command or the `Install-BoltModule` PowerShell
    cmdlet can be used, which will automatically do several things:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以使用 `bolt module install` Unix 命令或 `Install-BoltModule` PowerShell cmdlet，这将自动完成几项操作：
- en: Find dependencies on all Forge modules
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找所有 Forge 模块的依赖项
- en: Find compatible versions
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找兼容版本
- en: Update the Puppetfile
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新 Puppetfile
- en: Install the modules into the Bolt project
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将模块安装到 Bolt 项目中
- en: 'The modules can also be added at project creation time using the following
    command in Unix systems:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 模块还可以在项目创建时通过以下 Unix 系统命令添加：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In PowerShell, this can be done using the following command:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PowerShell 中，可以使用以下命令来完成此操作：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If you need modules pinned at a specific version or Git modules added, you
    will need to add these manually to the Bolt project file and run the `Force` flag
    with the following Bolt module installation command: `Install-BoltModule -Force`
    on Windows or `bolt module install --force` on Unix systems.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要将模块固定在特定版本或添加 Git 模块，则需要手动将这些模块添加到 Bolt 项目文件中，并使用以下 Bolt 模块安装命令运行 `Force`
    标志：在 Windows 上使用 `Install-BoltModule -Force` 或在 Unix 系统上使用 `bolt module install
    --force`。
- en: These modules allow us to use Puppet code within plans, as well as bring in
    plans and tasks from modules, which will be shown in detail in the *Introducing
    tasks and* *plans* section.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这些模块允许我们在计划中使用 Puppet 代码，并从模块中引入计划和任务，详细内容将在 *介绍任务和* *计划* 部分中展示。
- en: Configuring transports
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置传输
- en: 'The `inventory.yaml` file contains configuration information about targets,
    creating groups of targets with details about how Bolt connects to them. The inventory
    contains a top level that includes settings that act as defaults for all targets,
    group objects that allow targets to be grouped based on common settings, such
    as all Windows nodes using certain WinRM settings, and target objects, which are
    individual settings. For each setting, there are common fields that can be used:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`inventory.yaml` 文件包含有关目标的配置信息，创建目标组并提供有关 Bolt 如何与它们连接的详细信息。清单包含一个顶层，其中包括作为所有目标默认设置的设置，允许基于共同设置（如所有
    Windows 节点使用某些 WinRM 设置）对目标进行分组的组对象，以及目标对象（即单独的设置）。对于每个设置，都可以使用一些通用字段：'
- en: '**Alias**: An alias to use instead of the **Uniform Resource Identifier** (**URI**),
    which can be shorter and more human readable'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**别名**：用来代替**统一资源标识符**（**URI**）的别名，它可以更简短且更易于人类阅读'
- en: '**Config**: A map of transport configuration options for the target'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**：目标的传输配置选项的映射'
- en: '**Facts**: A map of facts for the target(s)'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事实**：目标（们）的事实映射'
- en: '**Features**: An array of features to be enabled (features will be discussed
    later in the chapter)'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**特性**：要启用的特性数组（特性将在本章后续部分讨论）'
- en: '**Name**: Used with groups to give a human-readable name'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：与组一起使用，以提供易于阅读的名称'
- en: '**Plugin hooks**: A map of plugin configurations (plugins will be discussed
    in the *Plugins* section of this chapter)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插件钩子**：插件配置的映射（插件将在本章的 *插件* 部分讨论）'
- en: '**URI**: A target’s URI'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**URI**：目标的 URI'
- en: '**Vars**: A map of variables'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变量**：变量的映射'
- en: 'A sample inventory file could look as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 一个示例清单文件可能如下所示：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This would provide default settings for SSH transport. It should be noted in
    this example it was shown how to create groups within groups in any inventory
    to ease management and settings for groups. In this case, we have an agents group,
    which contains a `linux_agents` group and a `windows_agents` group. The `windows_agents`
    group contains WinRM transport configuration. This allows us to run Bolt against
    all agents but with different transports set. There is then a single target called
    `Primary` outside of these groups.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这将提供 SSH 传输的默认设置。需要注意的是，在此示例中，展示了如何在任何清单中创建组内的组，以便简化管理和组的设置。在此案例中，我们有一个名为 agents
    的组，其中包含 `linux_agents` 组和 `windows_agents` 组。`windows_agents` 组包含 WinRM 传输配置。这使得我们可以对所有代理运行
    Bolt，但为每个代理设置不同的传输方式。然后，在这些组外有一个名为 `Primary` 的单一目标。
- en: The full `inventory.yaml` configuration documentation is available at [https://puppet.com/docs/bolt/latest/bolt_inventory_reference.html](https://puppet.com/docs/bolt/latest/bolt_inventory_reference.html),
    while the transport configuration is available at [https://puppet.com/docs/bolt/latest/bolt_transports_reference.html](https://puppet.com/docs/bolt/latest/bolt_transports_reference.html).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 `inventory.yaml` 配置文档可以在 [https://puppet.com/docs/bolt/latest/bolt_inventory_reference.html](https://puppet.com/docs/bolt/latest/bolt_inventory_reference.html)
    上找到，而传输配置文档可以在 [https://puppet.com/docs/bolt/latest/bolt_transports_reference.html](https://puppet.com/docs/bolt/latest/bolt_transports_reference.html)
    上查看。
- en: To return the contents of the `inventory.yaml` file, the `bolt inventory show`
    Unix command or the `Get-BoltInventory` PowerShell cmdlet can be used. Specific
    targets can be viewed with the `targets` flag.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要返回 `inventory.yaml` 文件的内容，可以使用 `bolt inventory show` Unix 命令或 `Get-BoltInventory`
    PowerShell cmdlet。可以使用 `targets` 标志查看特定目标。
- en: 'As was discussed in the previous section, for Windows scripts, additional extensions
    can be allowed using the inventory file, so in a `config` section, the following
    could be added to allow `.py` and `.pl` scripts to be run:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一节所述，对于 Windows 脚本，可以使用清单文件允许附加扩展，因此在 `config` 部分，可以添加以下内容以允许运行 `.py` 和 `.pl`
    脚本：
- en: '[PRE22]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Having reviewed how to configure settings at a project level in Bolt, it is
    now important to also know how system-level settings can be set in Bolt and also
    how previous legacy versions of Bolt projects may be configured differently.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在回顾如何在 Bolt 中配置项目级别的设置之后，现在需要了解如何在 Bolt 中设置系统级别的设置，以及如何将以前的遗留版本的 Bolt 项目配置为不同的方式。
- en: System level and legacy
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 系统级别和遗留版本
- en: In addition to the project settings, system-level settings can be set in the
    `/etc/puppetlabs/bolt/bolt-defaults.yaml` file on Unix-based systems and the `%PROGRAMDATA%\PuppetLabs\bolt\etc\bolt-defaults.yaml`
    file on Windows systems. User-level settings can be set in `.puppetlabs/etc/bolt/bolt-defaults.yaml`
    in the user’s home directory.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 除了项目设置外，系统级别的设置可以在基于 Unix 的系统中的`/etc/puppetlabs/bolt/bolt-defaults.yaml`文件以及
    Windows 系统中的`%PROGRAMDATA%\PuppetLabs\bolt\etc\bolt-defaults.yaml`文件中进行设置。用户级别的设置可以在用户主目录下的`.puppetlabs/etc/bolt/bolt-defaults.yaml`文件中进行设置。
- en: 'Bolt will choose which project to use with its commands based on the following
    order of priority:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: Bolt 会根据以下优先级顺序选择使用哪个项目：
- en: The project location set in the `BOLT_PROJECT` environment variable
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BOLT_PROJECT`环境变量中设置的项目位置
- en: The `project` flag on a Bolt command with the project location set (`--``project
    /tmp/myproject`)
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设置了项目位置的 Bolt 命令中的`project`标志（`--project /tmp/myproject`）
- en: By traversing from the current directory up until a `bolt-project.yaml` or `boltdir`
    directory is found
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从当前目录向上遍历，直到找到`bolt-project.yaml`或`boltdir`目录
- en: The `.puppetlabs/bolt/` folder in the home directory of the user
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用户主目录下的`.puppetlabs/bolt/`文件夹
- en: Note
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the Unix environment, Bolt does not load a world-writeable Bolt project directory.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unix 环境中，Bolt 不会加载一个世界可写的 Bolt 项目目录。
- en: If you want to ship Bolt within an application project but the base Bolt project
    files would clutter the application, it is possible to embed a Bolt project by
    creating a `boltdir` directory within the application directory. Bolt could still
    be run from the parent directory as it would recognize `boltdir` as containing
    the project.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望将 Bolt 嵌入到一个应用项目中，但基本的 Bolt 项目文件会使应用变得杂乱，你可以通过在应用目录中创建一个`boltdir`目录来嵌入一个
    Bolt 项目。即使是这样，Bolt 仍然可以从父目录运行，因为它会识别`boltdir`作为包含项目的目录。
- en: If you have used older versions of Bolt before 2.36, you will note that projects
    used to create a single `bolt.yaml` file instead of `bolt-project.yaml` and `inventory.yaml`.
    Support for v1 `bolt.yaml` projects was removed in v3.0.0 of Bolt. Additionally,
    Bolt-managed modules changed with the deprecation of manual editing of the Puppetfile
    in v2.42 and the removal of manual editing in v3.0.0\. This also changed the module
    path from containing the `site-modules` and `site` modules to the modern version
    of `modules` and `.modules`. Previously, managed modules had existed in `modules`
    and unmanaged modules in `site` and `site-modules`. This has now been changed
    to managed modules in `.modules` and unmanaged modules in `modules`. To migrate
    an old-style Bolt project to the new style, the `bolt project migrate` Unix command
    or `Update-BoltProject` PowerShell command can be run. As with all automated conversions,
    ensure your pre-migration configuration is backed up in revision control. The
    full details of changes made during the migration process can be found at [https://puppet.com/docs/bolt/latest/projects.html#migrate-a-bolt-project](https://puppet.com/docs/bolt/latest/projects.html#migrate-a-bolt-project).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前使用过 2.36 版本之前的旧版 Bolt，你会注意到项目曾经只创建一个`bolt.yaml`文件，而不是`bolt-project.yaml`和`inventory.yaml`。对
    v1 `bolt.yaml` 项目的支持在 Bolt 的 v3.0.0 版本中被移除。此外，随着 v2.42 版本中手动编辑 Puppetfile 的弃用和
    v3.0.0 版本中手动编辑的移除，Bolt 管理的模块也发生了变化。这也改变了模块路径，从包含`site-modules`和`site`模块变更为现代版本的`modules`和`.modules`。之前，托管的模块存在于`modules`中，非托管的模块则位于`site`和`site-modules`中。现在已经更改为托管的模块位于`.modules`中，非托管的模块位于`modules`中。为了将旧版的
    Bolt 项目迁移到新版本，可以运行`bolt project migrate` Unix 命令或`Update-BoltProject` PowerShell
    命令。像所有自动化转换一样，请确保在迁移之前备份好配置并进行版本控制。有关迁移过程中的更改详细信息，请参阅[https://puppet.com/docs/bolt/latest/projects.html#migrate-a-bolt-project](https://puppet.com/docs/bolt/latest/projects.html#migrate-a-bolt-project)。
- en: Having reviewed the structure created for Bolt configuration and target transport,
    it is now time to look at more structured ways of running Bolt via tasks and plans.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在回顾了为 Bolt 配置和目标传输创建的结构之后，现在是时候通过任务和计划来查看更结构化的运行 Bolt 方式了。
- en: Introducing tasks and plans
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入任务和计划
- en: '**Tasks** and **plans** are more forms of scripts and allow users to manage
    parameters, logic, and flow between actions. Unlike normal Puppet code, plans
    and tasks run through the script in sequential order, even for Puppet plans that
    compile a catalog.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**任务**和**计划**更像是脚本，允许用户管理参数、逻辑和动作之间的流程。与普通的 Puppet 代码不同，计划和任务按顺序运行脚本，即使是那些编译目录清单的
    Puppet 计划也是如此。'
- en: Creating tasks
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建任务
- en: 'Tasks are single-action scripts that can be in any language that will run on
    a target machine. The key differences between the normal scripts we have run with
    Bolt previously and a task are as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 任务是单一操作的脚本，可以使用任何在目标机器上运行的语言。与我们之前使用 Bolt 执行的普通脚本相比，任务的主要区别如下：
- en: Tasks are paired with a JSON file to provide metadata such as parameters, which
    allow them to be shared and reused more easily
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务与 JSON 文件配对，以提供元数据，例如参数，使它们更易于共享和重用
- en: Tasks can handle structure/typed input and output
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务可以处理结构化/类型化的输入和输出
- en: Tasks can handle multiple implementations to make them cross-platform
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务可以处理多种实现，使其跨平台
- en: They can be stored in the task directory of a Bolt project or the task directory
    in a Puppet module. Task implementations should contain their extension in the
    name. The name can include digits, underscores, and upper and lowercase letters
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以存储在 Bolt 项目的任务目录中，或者在 Puppet 模块的任务目录中。任务实现应在名称中包含其扩展名。名称可以包含数字、下划线和大小写字母
- en: When calling these tasks, a namespace is created that is made up of the name
    of the Bolt project or module containing the task and the task name, except if
    the task has been named `init`, in which case it will be referred to only by the
    Bolt project or module name.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用这些任务时，会创建一个命名空间，由包含任务的 Bolt 项目或模块的名称以及任务名称组成，除非任务被命名为 `init`，在这种情况下它只会通过
    Bolt 项目或模块的名称来引用。
- en: For example, the task to install an agent with the `peadm::agent_install`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，安装代理的任务是 `peadm::agent_install`。
- en: Note
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The`.json` and `.md` extensions are reserved and cannot be used for tasks.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`.json` 和 `.md` 扩展名是保留的，不能用于任务。'
- en: For Unix shell systems the script part must contain a shebang (`#!`) line at
    the top of the file specifying the interpreter.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Unix Shell 系统，脚本部分必须在文件顶部包含一个 shebang (`#!`) 行，指定解释器。
- en: 'An example of task implementation is when the PEADM module is used to configure
    the labs using the following code on Unix systems under the `agent_install.sh`
    task name:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 任务实现的一个例子是当使用 PEADM 模块配置实验室时，在 Unix 系统下的 `agent_install.sh` 任务中使用以下代码：
- en: '[PRE23]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Parameters are passed based on variables starting with `$PT_`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是基于以 `$PT_` 开头的变量传递的。
- en: 'With PowerShell, which has a built-in argument handler, this can be done without
    `$PT_` using the `param` function in a task called `agent_install.ps1`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 PowerShell，它具有内置的参数处理器，可以通过在名为 `agent_install.ps1` 的任务中使用 `param` 函数来完成，而无需使用
    `$PT_`：
- en: '[PRE24]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'To make these files visible to Bolt commands and allow callers to pass the
    parameters, a JSON file is written with the same name as the task. For the `agent_install`
    example, it looks like this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些文件对 Bolt 命令可见并允许调用者传递参数，会写一个与任务同名的 JSON 文件。对于 `agent_install` 示例，它看起来是这样的：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The metadata provides a description of the task, which is displayed when listing
    tasks. In addition, the metadata includes a list of parameters with names that
    must start with a lowercase letter and only include lowercase letters, underscores,
    and digits. The parameter type, which may match any Puppet type that can be represented
    in JSON format, and default values for the parameter can also be specified.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据提供了任务的描述，列出任务时会显示。此外，元数据包括参数列表，参数名称必须以小写字母开头，并且仅包含小写字母、下划线和数字。还可以指定参数类型，该类型可以匹配任何可以在
    JSON 格式中表示的 Puppet 类型，以及参数的默认值。
- en: Ensuring the type is an enum or more specific type, such as an integer within
    a specified size range, can make the task much more secure, limiting the input
    and therefore the attack vector. Also, within tasks, you should ensure that the
    parameters for the implementation you are working on are properly separated and
    do not allow strings to be called. Precise examples can be seen at [https://puppet.com/docs/bolt/latest/writing_tasks.html#secure-coding-practices-for-tasks](https://puppet.com/docs/bolt/latest/writing_tasks.html#secure-coding-practices-for-tasks).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 确保类型是枚举类型或更具体的类型，例如在指定大小范围内的整数，可以使任务更加安全，限制输入，从而减少攻击面。此外，在任务中，您应确保正在处理的实现的参数得到正确分隔，并且不允许调用字符串。具体示例可以参考
    [https://puppet.com/docs/bolt/latest/writing_tasks.html#secure-coding-practices-for-tasks](https://puppet.com/docs/bolt/latest/writing_tasks.html#secure-coding-practices-for-tasks)。
- en: The `implementations` parameter allows us to define what scripts are used in
    what environments. In this case, ensure the `.sh` implementation is run on the
    Unix shell and `.ps1` on PowerShell.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`implementations` 参数允许我们定义在什么环境中使用哪些脚本。在此情况下，确保 `.sh` 实现运行在 Unix shell 上，而
    `.ps1` 实现运行在 PowerShell 上。'
- en: With this file in place, the `bolt task show` Unix command or `Get-BoltTask`
    PowerShell cmdlet will show all modules available in the module path, and specific
    tasks can be viewed with `bolt task show <name of task>` or `Get-BoltTask –Name
    <name` `of task>`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个文件，`bolt task show` Unix命令或`Get-BoltTask` PowerShell cmdlet将显示模块路径中所有可用的模块，并且可以通过`bolt
    task show <taskname>`或`Get-BoltTask –Name <taskname>`查看特定任务。
- en: Setting the `private` parameter to `true` prevents the task from being listed
    and can be useful for hiding tasks that are under development, although as we
    showed in the *Configuring a project* section, the same could be achieved at the
    Bolt project level.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 将`private`参数设置为`true`可以防止任务出现在任务列表中，这对于隐藏正在开发中的任务非常有用，尽管如我们在*配置项目*部分所示，这也可以在Bolt项目级别实现。
- en: A parameter can be marked as `sensitive` by setting the parameter value to `true`,
    and variables can be set to `sensitive` within code to ensure they will be redacted
    in logs and output.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将参数值设置为`true`，可以将参数标记为`sensitive`，并且在代码中将变量设置为`sensitive`可以确保它们在日志和输出中被屏蔽。
- en: A parameter of `supports_noop` in the metadata allows users to pass a `noop`
    argument to the task and will result in the `_noop` parameter being `true` or
    `false`. It is then possible to use this parameter in your task code to logically
    check whether changes should be made or just tested.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 元数据中的`supports_noop`参数允许用户向任务传递`noop`参数，这将使得`_noop`参数的值为`true`或`false`。然后，你可以在任务代码中使用此参数来逻辑检查是否应进行更改或仅进行测试。
- en: If the `remote` parameter is set to `true`, the task will only be able to run
    on remote transport to prevent tasks from being run on incompatible transports.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将`remote`参数设置为`true`，则任务只能在远程传输上运行，以防止任务在不兼容的传输上运行。
- en: For a task with lots of options or that returns a lot of information, it may
    be better to use structured input and output rather than just simple parameters.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个选项较多或返回信息较多的任务，使用结构化输入输出可能会比仅使用简单参数更好。
- en: 'Bolt passes task parameters as a single JSON object on `STDIN`, as well as
    environment variables by default. These can then be read in as parameters by a
    Ruby script with the following line: `params =` `JSON.parse(STDIN.read)`.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Bolt将任务参数作为单个JSON对象传递给`STDIN`，并将环境变量一并传递。然后，Ruby脚本可以使用以下代码行读取这些参数：`params
    =` `JSON.parse(STDIN.read)`。
- en: 'For complex output, it should be ensured that the task prints a single JSON
    object to `stdout` in the task. This can be useful if you want to use the result
    within another task. For example, in Python, the following code snippet would
    dump the JSON of two value sets to stdout, using `json.dump` to convert the result
    string into JSON and passing it to the `sys.stdout` method Python uses to print
    to stdout:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对于复杂的输出，应该确保任务在任务中打印单个JSON对象到`stdout`。这在你希望在另一个任务中使用结果时非常有用。例如，在Python中，以下代码片段将把两个值集的JSON转储到stdout，使用`json.dump`将结果字符串转换为JSON并传递给Python用于打印到stdout的`sys.stdout`方法：
- en: '[PRE26]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'To return error messages from tasks, an `Error` object can be returned. In
    structured output, the `_error` key is expected and the `msg` key is available
    as a human-readable message for the UI, `kind` as the string for script handling,
    and `details` with structured data about the task failure, such as exit code tails.
    Take the following example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 要从任务中返回错误消息，可以返回一个`Error`对象。在结构化输出中，预期会有`_error`键，并且`msg`键作为UI中的人类可读消息，`kind`作为脚本处理的字符串，`details`包含有关任务失败的结构化数据，例如退出码尾部。以下是一个例子：
- en: '[PRE27]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If the `_error` key is not present, Bolt generates a generic error instead.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有`_error`键，Bolt将生成一个通用错误。
- en: Note
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Within a module, `pdk new task <taskname>` can be run to generate a `<taskname>.json`
    file and a `<taskname>.sh` file in the task folder.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个模块中，可以运行`pdk new task <taskname>`来生成`<taskname>.json`文件和`<taskname>.sh`文件，文件会保存在任务文件夹中。
- en: 'To run these tasks, the `bolt task run` Unix command or `Invoke-BoltTask` PowerShell
    cmdlet can be used with the parameters either passed as arguments or using the
    `@` symbol via a string of JSON or a filename with the `.json` extension. For
    example, the first task would install a Puppet agent on targets in the agents
    group with the server and `install_flags` parameters set:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这些任务，可以使用`bolt task run` Unix命令或`Invoke-BoltTask` PowerShell cmdlet，并通过传递参数作为命令行参数或使用`@`符号来传递一个JSON字符串或带有`.json`扩展名的文件。例如，第一个任务会在agents组中的目标上安装Puppet代理，并设置server和`install_flags`参数：
- en: '[PRE28]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The second task would run the `package` task and take a JSON string with the
    `params` flag to check the status of the `apache2` package:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个任务将运行`package`任务，并通过`params`标志传入JSON字符串，以检查`apache2`软件包的状态：
- en: '[PRE29]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Having seen how to create and run tasks, it is now time to review plans, which
    allow for greater structure, logic,and flow to be applied in managing tasks and
    the ability to use Puppet code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了如何创建和运行任务后，现在是时候回顾一下计划，计划允许在管理任务时应用更强的结构、逻辑和流程控制，并且能够使用Puppet代码。
- en: Creating Puppet plans
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Puppet计划
- en: Plans are written in Puppet code or YAML and allow multiple tasks and commands
    to be brought together and to apply logic and control of flow and data between
    them.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 计划是用Puppet代码或YAML编写的，它允许将多个任务和命令结合起来，并在它们之间应用逻辑和数据流控制。
- en: 'A Puppet plan is written in a manifest and in a similar format to a Puppet
    class. It starts with the `plan` keyword, then the name of the plan, attributes
    within brackets `()`, and code between curly braces `{}`. So, for example, a sample
    plan in a sample project contained in the plan directory would look as follows:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet计划是以清单形式编写的，格式类似于Puppet类。它以`plan`关键字开始，接着是计划的名称、括号`()`内的属性，以及大括号`{}`中的代码。例如，位于计划目录中的一个示例项目的计划如下所示：
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Plans are named similarly to tasks, with the first segment the name of the module
    or project and the second segment and all following segments named with lowercase
    letters, digits, and underscores.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 计划的命名方式与任务类似，第一部分是模块或项目的名称，第二部分及其后续部分以小写字母、数字和下划线命名。
- en: They must not use a reserved word or have the same as a Puppet data type.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 它们不能使用保留字，也不能与Puppet数据类型相同。
- en: The `init.pp` class, as with tasks and modules, is different. It would skip
    the need for the task to be named directly. However, it can only be used at the
    base level but not in any subdirectory.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`init.pp`类与任务和模块不同。它会跳过任务直接命名的需求。然而，它只能在基础层级使用，而不能在任何子目录中使用。'
- en: 'To create a new plan, the following commands can be used for Unix systems and
    PowerShell, respectively:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新计划，可以使用以下命令，分别适用于Unix系统和PowerShell：
- en: '[PRE31]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Having reviewed how to create a plan, we will now see how plans receive their
    target and transport information via the `TargetSpec` type.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在回顾了如何创建计划后，我们将看到计划如何通过`TargetSpec`类型接收目标和传输信息。
- en: Constructing targets
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建目标
- en: In addition to the normal attribute data types, plans use the `TargetSpec` type,
    which allows for strings exactly like were used with Bolt command targets in the
    *Connecting to clients with transports and targets* section, such as `ssh://examplehost.com`,
    arrays of `Target` types, and recursively, an array of `TargetSpec` types.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 除了普通的属性数据类型外，计划还使用`TargetSpec`类型，这使得可以使用与在*通过传输和目标连接客户端*部分中用于Bolt命令目标相同的字符串，例如`ssh://examplehost.com`，`Target`类型的数组，以及递归的`TargetSpec`类型数组。
- en: The `Target` type represents a target and its specific connections in such a
    way that they can be added to an inventory file.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`Target`类型表示一个目标及其特定连接方式，以便它们可以被添加到清单文件中。'
- en: 'Within a plan, the `get_targets` function can be used to return targets from
    a `TargetSpec`. The following is a simple example of how this is used:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在计划中，可以使用`get_targets`函数从`TargetSpec`中返回目标。以下是一个简单的使用示例：
- en: '[PRE32]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This plan takes a `TargetSpec` object of `apache_servers`, which is passed to
    the `get_targets` function. The Apache `reload` task is then run on each individual
    target server, with the `action` parameter set to `reload`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 该计划接受一个`TargetSpec`对象`apache_servers`，该对象被传递给`get_targets`函数。然后，Apache的`reload`任务在每个目标服务器上运行，`action`参数设置为`reload`。
- en: 'Target objects can also be constructed and changed within a plan manifest using
    functions beginning with `set_` or `add_` for the various parts of the inventory
    config, such as the `set_config`, `set_var`, `add_facts`, and `add_to_group` functions.
    For example, a new target could be assembled like so:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 目标对象还可以在计划清单中构建并通过以`set_`或`add_`开头的函数进行更改，这些函数用于配置文件中各个部分的操作，如`set_config`、`set_var`、`add_facts`和`add_to_group`函数。例如，可以像这样组装一个新目标：
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: It is possible to access parts of the target, such as `$example_server.config['ssh']`,
    but the targets will only last in memory for as long as the plan is running.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 可以访问目标的部分内容，例如`$example_server.config['ssh']`，但是这些目标只会在计划运行时存在于内存中。
- en: Now that we understand how to connect to clients using plans, we will show how
    functions can be used in the Puppet code block of a plan to use features of Bolt
    and the Puppet core language.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了如何使用计划连接到客户端，我们将展示如何在计划的Puppet代码块中使用函数，利用Bolt和Puppet核心语言的特性。
- en: Using plan functions
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用计划函数
- en: As was shown in the *Constructing targets* section, using `run_task`, Bolt plan
    functions can be used within the Puppet code block itself, many of which are the
    same types of commands that were run directly in Bolt, such as `run_command`,
    `run_script`, and `run_task`. The full list is available at [https://puppet.com/docs/bolt/latest/plan_functions.html](https://puppet.com/docs/bolt/latest/plan_functions.html).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 正如*构造目标*部分所示，使用`run_task`，Bolt计划函数可以在Puppet代码块中本身使用，其中许多与直接在Bolt中运行的命令类型相同，例如`run_command`、`run_script`和`run_task`。完整的命令列表可以在[https://puppet.com/docs/bolt/latest/plan_functions.html](https://puppet.com/docs/bolt/latest/plan_functions.html)中找到。
- en: It is also possible to run a plan from within a plan using the `run_plan` function.
    This can be useful to ensure no plan gets too large and they can be more easily
    reused. A pattern that can be observed in the PEADM module is the use of the `subplan`
    folder for plans we only expect to be used within plans, reducing the size and
    complexity of the catalogs.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用`run_plan`函数在一个计划中运行另一个计划。这对于确保没有计划变得过大，并且可以更容易地重复使用它们是非常有用的。在PEADM模块中可以观察到的一种模式是使用`subplan`文件夹存放我们只期望在计划中使用的计划，从而减少目录的大小和复杂性。
- en: It should be noted that most Puppet language features, such as functions, the
    sensitive type, and lambdas, can be used within this code, but other features,
    such as deferred functions, cannot since the catalog is not being sent to the
    node to be applied. The differences are fully documented at [https://puppet.com/docs/bolt/latest/writing_plans.html#puppet-and-ruby-functions-in-plans](https://puppet.com/docs/bolt/latest/writing_plans.html#puppet-and-ruby-functions-in-plans).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，大多数Puppet语言特性，如函数、sensitive类型和lambdas，可以在此代码中使用，但其他特性，如延迟函数，不能使用，因为目录并未发送到节点以供应用。这些差异已在[https://puppet.com/docs/bolt/latest/writing_plans.html#puppet-and-ruby-functions-in-plans](https://puppet.com/docs/bolt/latest/writing_plans.html#puppet-and-ruby-functions-in-plans)中详细记录。
- en: 'For example, within PEADM, the following `run_command` function stops Puppet
    on all the targets stored in the `$all_targets` variable and then runs a `modify_certificate`
    plan on the targets in the `covert_target` variable, passing in a primary `add`
    parameter and the extensions to be added:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在PEADM中，以下`run_command`函数停止所有存储在`$all_targets`变量中的目标上的Puppet，然后在`covert_target`变量中的目标上运行`modify_certificate`计划，传入一个主要的`add`参数和要添加的扩展：
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Puppet code can also be applied via the `apply` function similar to how a `puppet
    apply` command would run. For example, PEADM uses the following code to create
    node groups:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet代码也可以通过`apply`函数应用，类似于运行`puppet apply`命令。例如，PEADM使用以下代码创建节点组：
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This applies the `node_manager_yaml` class, passing a `primary_host` parameter.
    It should be noted that if Puppet libraries are needed in advance of applying
    Puppet code, the `apply_prep` function can be used to ensure they are available
    before using the `apply` function.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这应用了`node_manager_yaml`类，传入了`primary_host`参数。需要注意的是，如果在应用Puppet代码之前需要Puppet库，可以使用`apply_prep`函数，确保在使用`apply`函数之前这些库已经可用。
- en: Logging and results
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志记录和结果
- en: 'To add logging to plans, the `out::message` and `out::verbose` functions are
    used, with message logging on every run and verbose message output only if Bolt
    is run in `verbose` mode. Take the following example:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要在计划中添加日志记录，使用`out::message`和`out::verbose`函数，在每次运行时记录消息，只有当Bolt以`verbose`模式运行时才会输出详细消息。以下是一个示例：
- en: '[PRE36]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`Error` would be printed on every Bolt run, but only when the `–verbose` flag
    is used would the second message be displayed.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`Error`将在每次Bolt运行时打印，但只有在使用`–verbose`标志时，第二条消息才会显示。'
- en: Each function returns an object type of `ResultSet` with each target containing
    its own `Result` object type, except the `apply` function, whose `ResultSet` contains
    `ApplyResult` objects. A plan returns a `PlanResult` type as output, which can
    contain all these data types and just about any Puppet data type.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 每个函数返回一个`ResultSet`类型的对象，每个目标包含自己的`Result`对象类型，除了`apply`函数，其`ResultSet`包含`ApplyResult`对象。计划返回一个`PlanResult`类型的输出，可以包含所有这些数据类型以及几乎所有Puppet数据类型。
- en: These objects can be assigned to variables and then functions used to expose
    data. There are two common functions used in all of these object types. `ok` is
    a function that returns a simple Boolean confirming whether there were any errors
    and the `value` function returns the output of the run.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这些对象可以分配给变量，然后使用函数来公开数据。所有这些对象类型中常用的两个函数是`ok`，它返回一个简单的布尔值来确认是否有任何错误；和`value`函数返回运行的输出。
- en: Further type-specific functions can be viewed in the documentation at [https://puppet.com/docs/bolt/latest/bolt_types_reference.html](https://puppet.com/docs/bolt/latest/bolt_types_reference.html).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 更多类型特定函数可以在[https://puppet.com/docs/bolt/latest/bolt_types_reference.html](https://puppet.com/docs/bolt/latest/bolt_types_reference.html)文档中查看。
- en: 'To return output from the plan, the return function should be used with any
    appropriate data type; this could be the direct output from a task or as simple
    as a string. If no return function is used, the output will be `undef`. For example,
    the following code will run the task `error_check_task` and only if that is successful
    will it return the `ResultSet` type output from the task `output_task`; otherwise,
    it will return the string `OH NO`:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 要从计划返回输出，应使用返回函数与任何适当的数据类型；这可以是来自任务的直接输出或仅仅是一个字符串。如果没有使用返回函数，则输出将为`undef`。例如，以下代码将运行任务`error_check_task`，仅当成功时才会从任务`output_task`返回`ResultSet`类型的输出；否则，将返回字符串`OH
    NO`：
- en: '[PRE37]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, let’s look at how we can handle errors.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何处理错误。
- en: Handling errors
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理错误
- en: 'To perform a simple check and fail a plan as a result, the `fail_plan` function
    can be used. For example, the following code would check whether the `$targets`
    variable only contained a single target:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行简单检查并因此失败计划，可以使用`fail_plan`函数。例如，以下代码将检查`$targets`变量是否仅包含单个目标：
- en: '[PRE38]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'If Bolt functions fail and `_catch_errors` is not set to `true`, then the plan
    will fail. If `_catch_errors` is used, this allows the plan to continue and the
    error can be handled:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Bolt函数失败并且未将`_catch_errors`设置为`true`，则计划将失败。如果使用了`_catch_errors`，则可以允许计划继续执行并处理错误：
- en: '[PRE39]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Alternatively, the `catch_result` function can be used to catch specific types
    of errors, as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，可以使用`catch_result`函数来捕获特定类型的错误，如下所示：
- en: '[PRE40]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: With an understanding of logging and error handling in plans, we can now look
    at how external data can be used in plans. Since Bolt uses Puppet as a library,
    it can use Hiera to access external data. As was covered in [*Chapter 9*](B18492_09.xhtml#_idTextAnchor233),
    this can ensure we separate code and data into plans as we do with Puppet code.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 通过了解计划中的日志记录和错误处理，我们现在可以看看如何在计划中使用外部数据。由于Bolt使用Puppet作为库，因此可以使用Hiera访问外部数据。正如在[*第9章*](B18492_09.xhtml#_idTextAnchor233)中所述，这可以确保我们将代码和数据分离，就像我们在Puppet代码中所做的那样。
- en: Managing data sources
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理数据源
- en: 'Facts can be collected from the hosts using the built-in facts plan or from
    PuppetDB using `puppetdb_facts`, assuming PuppetDB is set up in a Bolt configuration
    already. Using either plan would cause the targets to query PuppetDB to automatically
    have their in-memory inventory updated with the facts. The following example would
    run `facts` on `targets`, and those targets for which the `os.name` fact is equal
    to `Windows` are assigned to the `windows_targets` variable:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用内置的facts计划从主机收集事实，或者使用`puppetdb_facts`从PuppetDB收集，假设已在Bolt配置中设置了PuppetDB。使用任何计划都会导致目标自动查询PuppetDB并更新其内存中的库存。以下示例将在`targets`上运行`facts`，并且将`os.name`事实等于`Windows`的目标分配给`windows_targets`变量：
- en: '[PRE41]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'PuppetDB can also have general queries run against it using the `puppetdb_query`
    function. To return all the `certnames` fact values of `windows` hosts listed
    in PuppetDB, use the following code:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: PuppetDB还可以使用`puppetdb_query`函数执行通用查询。要返回PuppetDB中列出的`windows`主机的所有`certnames`事实值，请使用以下代码：
- en: '[PRE42]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Hiera can be used with plans by using either modules or Bolt project-level Hiera
    and having an appropriate `hiera.yaml`. The `lookup` function can then be used
    either inside `apply` functions or simply in the plan. If `lookup` is used within
    an `apply` function, and assuming the `apply_prep` function is run, we can gather
    all the facts and Hiera will function as expected. When using it within a plan,
    the important differences to note are that Bolt has no automatic parameter lookup
    capabilities like normal Puppet code with classes and the Bolt hierarchy can’t
    use top scope variables or facts. When Hiera is used within Bolt, it uses two
    levels of hierarchy, the project and module levels, with the project level being
    higher in precedence.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用模块或 Bolt 项目级别的 Hiera，并具有适当的`hiera.yaml`，来在计划中使用 Hiera。然后可以在`apply`函数内或直接在计划中使用`lookup`函数。如果在`apply`函数内使用`lookup`，并假设已运行`apply_prep`函数，我们可以收集所有事实，并且
    Hiera 将按预期工作。在计划中使用时，需要注意的重要区别是：Bolt不像正常的 Puppet 代码（通过类）那样具有自动参数查找功能，并且 Bolt 层次结构不能使用顶层变量或事实。在
    Bolt 中使用 Hiera 时，它使用两个层次的层级，项目和模块层级，其中项目层级具有更高的优先级。
- en: 'An example of the Bolt hierarchy would be a `hiera.yaml` project containing
    a hierarchy with Node data and the `plan_hierarchy` key without Node data:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Bolt 层次结构的一个示例是一个包含带有节点数据的层级的`hiera.yaml`项目，以及没有节点数据的`plan_hierarchy`键：
- en: '[PRE43]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'A `lookup` function in the plan could do the following and with an `application`
    variable be able to look up the `dns_server_name` variable in the org level of
    the plan hierarchy:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 计划中的`lookup`函数可以执行以下操作，并通过`application`变量能够在计划层次结构的组织级别查找`dns_server_name`变量：
- en: '[PRE44]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the following section, we will look at how comments can be used to document
    metadata.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将探讨如何使用注释来记录元数据。
- en: Documenting plan metadata
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录计划元数据
- en: 'Unlike tasks, since plans do not have a `metadata.json` file, it is necessary
    to document via comments so that when `puppet plans show <plan name>` is run,
    a description is provided. The first comment line is taken as the description,
    or an `@summary` tag can be used. Using `@param <param name>` on a comment will
    indicate it is the description of a parameter and using `@api private` will mark
    the plan as private. An example of using all of these fields is as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 与任务不同，由于计划没有`metadata.json`文件，因此需要通过注释来记录，以便在运行`puppet plans show <plan name>`时提供描述。第一行注释将作为描述，或者可以使用`@summary`标签。使用`@param
    <param name>`的注释表示它是参数的描述，使用`@api private`将计划标记为私有。使用所有这些字段的示例如下：
- en: '[PRE45]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The data type details are picked up automatically by the `bolt plan` `show`
    command.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类型的详细信息可以通过`bolt plan` `show`命令自动获取。
- en: Note
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It can be useful to add plans and tasks to the control repo, but it should be
    noted that when using PDK validate, PDK cannot validate plans and will only ignore
    plans in the default bottom-level plan directory. If you have a structure that
    puts plans at a lower level, you will have to run `pdk` to ignore these lower
    level directories of plans, such as `pdk set config` `project.validate.ignore
    subdir1/subdir2/plan`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 将计划和任务添加到控制仓库可能是有用的，但需要注意的是，在使用 PDK 验证时，PDK 无法验证计划，并且只会忽略默认的最低级计划目录中的计划。如果你的结构将计划放在较低级别，你需要运行`pdk`来忽略这些低级目录中的计划，例如`pdk
    set config` `project.validate.ignore subdir1/subdir2/plan`。
- en: Plan testing
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计划测试
- en: Testing Puppet plans is beyond the scope of the book. This is because plan testing
    is currently not fully implemented and difficult compared to the normal RSpec
    testing we saw in [*Chapter 8*](B18492_08.xhtml#_idTextAnchor212). Certain things
    are simply not implemented, such as mocking uploading a file or custom functions,
    which makes it difficult to carry out meaningful and complete testing compared
    to module testing. The testing functions currently available can be viewed at
    [https://puppet.com/docs/bolt/latest/testing_plans.html](https://puppet.com/docs/bolt/latest/testing_plans.html).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 Puppet 计划超出了本书的范围。这是因为计划测试目前尚未完全实现，并且相比于我们在[*第八章*](B18492_08.xhtml#_idTextAnchor212)中看到的常规
    RSpec 测试，计划测试更具挑战性。某些功能尚未实现，例如模拟上传文件或自定义函数，这使得与模块测试相比，进行有意义且完整的测试变得困难。目前可以使用的测试功能可参见[https://puppet.com/docs/bolt/latest/testing_plans.html](https://puppet.com/docs/bolt/latest/testing_plans.html)。
- en: Introducing YAML plans
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 YAML 计划
- en: 'YAML plans will be summarized here due to their much lower level of usage than
    Puppet plans. They are named similarly to Puppet-based plans but end with an extension
    of `.yaml` (not `.yml`). However, there is no command to create them. YAML plans
    contain the following:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 由于YAML计划的使用频率远低于Puppet计划，这里将简要概述YAML计划。它们的命名方式与基于Puppet的计划类似，但以`.yaml`扩展名（而非`.yml`）结尾。然而，没有创建它们的命令。YAML计划包含以下内容：
- en: '`Description`: What will be displayed in the `show` command'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`描述`：将在`show`命令中显示的内容'
- en: '`Parameters`: A hash of parameters that can be passed to the plan'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`参数`：可以传递给计划的参数哈希'
- en: '`Private`: A Boolean stating whether the plan is visible to the `show` command'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`私有`：一个布尔值，表示计划是否对`show`命令可见'
- en: '`Return`: An array, Boolean, hash, number, or string to return from the plan'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`返回值`：计划返回的数组、布尔值、哈希值、数字或字符串'
- en: '`Steps`: An array of steps to be run'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`步骤`：将要运行的步骤数组'
- en: The steps essentially represent the action to be performed in that step and
    the variables the step needs. There is a similarity between the options available
    in Bolt and the actions in Puppet plans, such as commands, tasks, scripts, file
    downloads, and file uploads. As with Puppet plans, YAML plans can call other plans
    with a plan step.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤本质上表示将在该步骤中执行的操作和步骤所需的变量。Bolt中可用的选项与Puppet计划中的操作类似，例如命令、任务、脚本、文件下载和文件上传。与Puppet计划一样，YAML计划可以通过计划步骤调用其他计划。
- en: 'The following example task plan, which uses the Docker `puppetlabs` module
    from Forge [https://forge.puppet.com/modules/puppetlabs/docker](https://forge.puppet.com/modules/puppetlabs/docker)
    to create and join an additional manager node to a Docker swarm, shows some of
    these features in use:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例任务计划使用来自Forge的Docker `puppetlabs`模块[https://forge.puppet.com/modules/puppetlabs/docker](https://forge.puppet.com/modules/puppetlabs/docker)来创建并加入一个额外的管理节点到Docker
    swarm，展示了一些这些功能的使用：
- en: '[PRE46]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This task takes the `firstnode` and `othernodes` variables of the `TargetSpec`
    type to provide the servers to the target. It uses the `swarm_init` task to initialize
    on the first node and runs the `swarm_token` task on this node. The `Fact` task
    is then run on `firstnode`, and in the final step, the `join_swarm` task is run
    on `othernodes`. It can be seen calling a variable with the name of previous step
    allows us to access the output created by that step. So we can take the output
    of the token step and map out the taskspec type returned to use the `stdout` as
    the token. For the `manager_ip` parameter, we perform a similar action, but this
    time, as there is more content in `stdout`, we must find the `networking.interface.ip`
    address fact we wish to pass. The plan then sets the return key to take the `stdout`
    output of the `join` step to confirm the result of the plan.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 该任务使用`TargetSpec`类型的`firstnode`和`othernodes`变量将服务器提供给目标。它使用`swarm_init`任务在第一个节点上初始化，并在此节点上运行`swarm_token`任务。接下来，`Fact`任务将在`firstnode`上运行，最后一步，`join_swarm`任务将在`othernodes`上运行。可以看到，调用具有前一步名称的变量可以让我们访问该步骤创建的输出。因此，我们可以获取令牌步骤的输出，并映射返回的taskspec类型，将`stdout`作为令牌使用。对于`manager_ip`参数，我们执行类似的操作，但这次，由于`stdout`中有更多内容，我们必须找到希望传递的`networking.interface.ip`地址事实。计划接着设置返回键，使用`join`步骤的`stdout`输出来确认计划的结果。
- en: It is also possible to use the `eval` step to calculate values, and both Puppet
    and Bolt functions can be used with this. The `message` and `verbose` steps are
    available for output just as they were in Puppet plans, while string interpolation
    follows the normal Puppet principle of single quotes (`''`) having no interpolation,
    just printing the text, double quotes (`""`) performing interpolation, and also
    using a pipe (`|`) with a new line to allow for expressions of a block of Puppet
    code to be displayed on the next line.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以使用`eval`步骤来计算值，并且可以使用Puppet和Bolt函数。`message`和`verbose`步骤用于输出，就像在Puppet计划中一样，而字符串插值遵循正常的Puppet原则，单引号（`''`）没有插值，仅打印文本，双引号（`""`）进行插值，同时使用管道符（`|`）和换行符可以将一块Puppet代码的表达式显示到下一行。
- en: 'To show some of this, the following plan takes an array of strings to install
    as packages:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示其中的一些内容，以下计划将安装一组字符串作为包：
- en: '[PRE47]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We can see that the `unique_packages eval` step uses the `unique` function to
    find only unique values in the array and the `numer_of_packages eval` step uses
    the `size` function, the result of which is passed to the `verbose` output and
    interpolated into a string which shows the number of packages. The `example::install_packages`
    task is run with the output of the `unique_packages` eval step before its output
    is used in the returned value.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，`unique_packages eval` 步骤使用 `unique` 函数来查找数组中的唯一值，而 `numer_of_packages
    eval` 步骤使用 `size` 函数，其结果传递给 `verbose` 输出并插入到一个字符串中，显示包的数量。`example::install_packages`
    任务在 `unique_packages` 评估步骤的输出之后运行，然后将其输出用于返回值。
- en: 'This has been just a summary of using YAML plans. The full options available
    on each step and more are available in the documentation: [https://puppet.com/docs/bolt/latest/writing_yaml_plans.html](https://puppet.com/docs/bolt/latest/writing_yaml_plans.html).'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是使用 YAML 计划的总结。每个步骤的完整选项和更多内容可以在文档中找到：[https://puppet.com/docs/bolt/latest/writing_yaml_plans.html](https://puppet.com/docs/bolt/latest/writing_yaml_plans.html)。
- en: In the following section, let’s look at some examples of plugins that are commonly
    used with Bolt.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将查看一些常用的 Bolt 插件示例。
- en: Plugins
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 插件
- en: Plugins allow Bolt to dynamically load data during a Bolt run. Plugins are essentially
    just modules containing tasks with a `bolt_plugin.json` file identifying which
    tasks are plugins and what type of plugins they are. Some are built into Bolt,
    while others can be added to extend the functionality.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 插件允许 Bolt 在执行期间动态加载数据。插件本质上只是包含任务的模块，`bolt_plugin.json` 文件标识了哪些任务是插件，以及它们是何种类型的插件。有些插件内建于
    Bolt 中，而其他插件可以被添加以扩展功能。
- en: 'There are three types of Bolt plugins:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Bolt 插件有三种类型：
- en: '**Reference**: Used to fetch data from external sources, such as loading information
    into the inventory file'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**引用**：用于从外部源获取数据，例如将信息加载到库存文件中'
- en: '**Secret**: Used to create keys to encrypt text and decrypt cipher text'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**秘密**：用于创建密钥来加密文本和解密密文'
- en: '`apply_prep` function is called on a target'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在目标上调用 `apply_prep` 函数
- en: We will look at these in detail in the following subsections.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下小节中详细查看这些内容。
- en: Reference plugins
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用插件
- en: '`inventory.yaml` or `bolt-project.yaml` using a `_plugin` key with the plugin
    name as the value and followed by parameters associated with the plugin. For example,
    to use the `puppetdb` plugin and query and select all the window nodes in PuppetDB,
    we could add the following group to `inventory.yaml`:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`inventory.yaml` 或 `bolt-project.yaml` 文件使用 `_plugin` 键，其值为插件名称，并随后列出与插件相关的参数。例如，要使用
    `puppetdb` 插件并查询和选择 PuppetDB 中所有窗口节点，我们可以在 `inventory.yaml` 中添加以下组：'
- en: '[PRE48]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This is assuming the PuppetDB connection configuration details are set in one
    of the configuration files.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这是假设 PuppetDB 连接配置详情已设置在其中一个配置文件中。
- en: Note
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'With the PuppetDB plugin configured a one-time query like this can be used
    to query PuppetDB: `bolt task run ''inventory[certname] { facts.kernel = "``Windows"
    }''`.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 配置了 PuppetDB 插件后，可以使用类似以下的单次查询来查询 PuppetDB：`bolt task run 'inventory[certname]
    { facts.kernel = "``Windows" }'`。
- en: 'Another approach to reference plugins can be with passwords where the `prompt`
    plugin will result in user input from the command line that sets a password. For
    example, the following will ensure that when running against `target1.example.com`,
    Bolt will connect on `winrm` with the user `bill` and the password prompted by
    the message `Enter` `your password`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种引用插件的方法是使用密码，其中 `prompt` 插件会提示用户从命令行输入密码。例如，以下内容将确保在对 `target1.example.com`
    进行操作时，Bolt 会使用 `winrm` 连接，用户为 `bill`，密码则通过提示 `Enter` `your password` 来输入：
- en: '[PRE49]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Plugins can also be used in plans via the `resolve_references` function. The
    following example shows a subsection of the `pecdm` module using plugins via the
    `resolve_references` function:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 插件还可以通过 `resolve_references` 函数在计划中使用。以下示例展示了 `pecdm` 模块通过 `resolve_references`
    函数使用插件的一个小节：
- en: '[PRE50]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the preceding code block, it essentially iterates through each group name
    and builds an array of target entries read in from the `terraform` directory set
    by the `tf_dir` variable. To see a further example, look at the contents of the
    `inventory.yaml` file for your lab setup, which uses the `terraform` plugin.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，它本质上是通过每个组名进行迭代，并构建一个从 `tf_dir` 变量设置的 `terraform` 目录中读取的目标条目的数组。要查看进一步的示例，请查看你的实验室设置中的
    `inventory.yaml` 文件内容，该文件使用了 `terraform` 插件。
- en: Secret plugins
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 秘密插件
- en: '`pckcs7` is Bolt’s default and only secret plugin. To create the encryption
    keys, run the `bolt secret createkeys -–force` Unix command or the `New-BoltSecretKey
    -Force` PowerShell cmdlet. This will create the keys in the `keys` folder of your
    project. Cipher text can be generated via the `bolt secret encrypt ''N33dt0kn0wba515!''
    --plugin pckcs7` Unix command or the `Protect-BoltSecret -Text ''N33dt0kn0wba515!
    '' -Plugin pckcs7` PowerShell cmdlet.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'The cipher text from this command can then be used in places such as `inventory.yaml`
    using the `pkcs7` reference plugin, for example:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note the previous encrypted string was shortened and has a default key size
    of `2048`. This can be changed by configuring the plugin in `bolt-project.yaml`
    or the default and user configuration.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: Puppet library
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`apply_prep` function is called in a plan. Each target the plugin is run on
    must be able to use the scripting language used by the plugin. Currently, only
    `puppet-agent` exists as a Puppet library plugin and it is configured to be available
    by default. But any future libraries or custom written libraries would be added
    to the Bolt, user, or default configuration in a similar fashion to this example:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The full list of supported and built-in plugins can be viewed at [https://puppet.com/docs/bolt/latest/supported_plugins.html](https://puppet.com/docs/bolt/latest/supported_plugins.html).
    Writing plugins is beyond the scope of this book, but the documentation at [https://puppet.com/docs/bolt/latest/writing_plugins.html](https://puppet.com/docs/bolt/latest/writing_plugins.html)
    advises further.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: Having covered Bolt in detail, we will now practice creating and using a bolt
    project in the following lab.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Lab – creating and using a Bolt project
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this lab, we will create a Bolt project. We will create a task that runs
    the `facter` command on a Windows and Linux node.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps are as follows:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a Bolt project with the following line of code:'
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Create an `inventory.yaml` file by performing a lookup of Windows and Linux
    clients from the PECDM Bolt project and copying the output:'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Write a task to cover both Windows and Linux that runs the `facter` command,
    taking a single argument if only a single fact should be returned.
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a plan that uses `run_command` to run `facter` and return the results
    of the plan.
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run the task and plan on your Windows and Linux clients.
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find example solutions at [https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch12](https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch12).
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we showed how Bolt complements Puppet’s state-based management
    by providing a capability to run ad hoc actions for anything that doesn’t fit
    the declarative enforcement methods of Puppet. We also showed how transports provide
    the ability for Bolt to connect to targets. We saw how, using the Bolt commands
    via Unix or PowerShell, we could run commands, scripts, Puppet code, and manifests
    on targets, as well as uploading and downloading files. We reviewed how Bolt logs
    to `bolt-debug.log` and how to configure logging to get more logs for different
    issues.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们展示了 Bolt 如何通过提供执行临时操作的能力来补充 Puppet 的状态管理方法，处理那些不符合 Puppet 声明式强制方法的任务。我们还展示了传输方式如何使
    Bolt 能够连接到目标。我们查看了如何通过 Unix 或 PowerShell 使用 Bolt 命令来执行命令、脚本、Puppet 代码和清单，此外还可以上传和下载文件。我们回顾了
    Bolt 如何记录到 `bolt-debug.log` 文件，并且如何配置日志记录以获取更多的日志，以便解决不同的问题。
- en: We then showed how Bolt projects provide a directory structure to contain the
    configuration and data for Bolt. Bolt projects provide the `inventory.yaml` file
    to contain target and transport configuration and the `bolt-project.yaml` file
    to contain project-level configuration settings for Bolt and to allow module dependencies
    to be downloaded into the project. We discussed how the Bolt project is loaded
    into the module path along with any modules it had downloaded. We then highlighted
    how the project format has changed over different versions of Bolt and how the
    `bolt migrate` command can convert older projects to the new format.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们展示了 Bolt 项目如何提供目录结构来存储配置和数据。Bolt 项目提供 `inventory.yaml` 文件来存储目标和传输配置，提供 `bolt-project.yaml`
    文件来存储项目级别的配置设置，并允许将模块依赖项下载到项目中。我们讨论了如何将 Bolt 项目加载到模块路径中，并与其下载的任何模块一起使用。随后，我们强调了项目格式如何随着不同版本的
    Bolt 发生变化，以及如何使用 `bolt migrate` 命令将旧版本项目转换为新格式。
- en: We then discussed how tasks are single-action scripts that can be in any language
    that will run on a target machine, paired with a JSON file to provide metadata
    such as parameters. We also showed how a task can list multiple implementations
    depending on the target. We looked at how sensitive parameters allow passwords
    and other secrets to be used by tasks without logging in the APIs. The `noop`
    option was introduced as a standard way to pass a parameter to a task and run
    in no-execute mode. We also showed how remote tasks contain the `remote` parameter,
    set to `true`, and a remote transport to allow web access services to use tasks
    despite being unable to log on in the traditional way.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 接着我们讨论了任务是单一操作脚本，可以使用任何在目标机器上运行的语言，配合 JSON 文件提供元数据，如参数。我们还展示了如何根据目标列出多个实现。我们查看了如何使用敏感参数使得任务能够使用密码和其他机密信息，而不会在
    API 中记录。我们介绍了 `noop` 选项，它作为标准方式传递参数给任务并以不执行模式运行。我们还展示了如何远程任务包含 `remote` 参数，设置为
    `true`，并使用远程传输方式，使得 Web 访问服务能够使用任务，即便不能通过传统方式登录。
- en: Then, we discussed how tasks are capable of sharing scripts in implementations
    and referring to other modules. Some security practices were discussed to ensure
    parameters are safely passed to tasks.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 接着，我们讨论了任务如何能够共享实现中的脚本，并引用其他模块。我们还讨论了一些安全实践，以确保参数能安全地传递给任务。
- en: Plans were then discussed as a way of running multiple tasks together and providing
    logic and control flow. We saw how plans could be written in either the Puppet
    language or YAML and how targets can be created using the `targetspec` data type
    and functions. We also saw how structured results can be returned after running
    a plan.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 接着讨论了计划（Plans），它们是将多个任务一起运行并提供逻辑和控制流的方式。我们看到计划可以使用 Puppet 语言或 YAML 编写，目标可以通过
    `targetspec` 数据类型和函数创建。我们还看到了如何在运行计划后返回结构化的结果。
- en: We then discussed how Bolt plugins provide ways to dynamically load data into
    Bolt runs using reference plugins to fetch data and store it, such as to fill
    the inventory with data from Terraform. We can also use secret plugins to provide
    keys for encrypting and decrypting values in Bolt runs. The third type of plugin
    we looked at was Puppet library plugins, which has only been implemented currently
    for the installation of Puppet agent via Bolt.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着讨论了 Bolt 插件如何通过引用插件来动态加载数据到 Bolt 运行中，使用引用插件来获取和存储数据，例如从 Terraform 填充数据到清单中。我们还可以使用机密插件提供加密和解密值所需的密钥，以便在
    Bolt 运行中使用。我们查看的第三种插件是 Puppet 库插件，目前仅实现了通过 Bolt 安装 Puppet 代理。
- en: In this chapter, we saw how Bolt can be paired with Puppet to get the best of
    both declarative and stateful language approaches to allow for flexibility in
    Puppet configurations.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到如何将Bolt与Puppet配合使用，结合声明式和有状态的语言方法，发挥两者的优势，从而使Puppet配置更加灵活。
- en: Having reviewed how to use Bolt and Puppet Enterprise, in the next chapter,
    we will look at more advanced topics on how to monitor and scale Puppet infrastructure,
    review performance issues, and use the **Puppet Data Service** to implement the
    external data pattern and allow users to enter data into Puppet setups with self-service
    APIs.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在回顾了如何使用Bolt和Puppet Enterprise之后，在下一章中，我们将探讨如何监控和扩展Puppet基础设施、审查性能问题，并使用**Puppet数据服务**来实现外部数据模式，允许用户通过自助服务API将数据输入到Puppet设置中。
