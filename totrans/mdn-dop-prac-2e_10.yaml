- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: Immutable Infrastructure with Packer
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Packer 实现不可变基础设施
- en: In the previous chapter, we looked at configuration management with Ansible
    and the tool’s core concepts. We also discussed Terraform and IaC in [*Chapter
    8*](B19877_08.xhtml#_idTextAnchor1010), *Infrastructure as Code (IaC) with Terraform*.
    In this chapter, we will look at another way of provisioning your infrastructure
    and configuration using both tools, as well as another one, called **Packer**.
    With all three tools, let’s boot up a scalable **Linux**, **Apache**, **MySQL**,
    **and PHP** (**LAMP**) stack on Azure.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了使用 Ansible 进行配置管理及其核心概念。我们还在 [*第 8 章*](B19877_08.xhtml#_idTextAnchor1010)
    *使用 Terraform 实现基础设施即代码 (IaC)* 中讨论了 Terraform 和 IaC。本章中，我们将介绍使用这两种工具以及另一个工具——**Packer**——来配置基础设施。借助这三种工具，我们将在
    Azure 上启动一个可扩展的**Linux**、**Apache**、**MySQL**、**PHP**（**LAMP**）堆栈。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Immutable infrastructure with HashiCorp’s Packer
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 HashiCorp 的 Packer 实现不可变基础设施
- en: Creating the Apache and MySQL playbook
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 Apache 和 MySQL playbook
- en: Building the Apache and MySQL images using Packer and Ansible provisioners
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Packer 和 Ansible 提供程序构建 Apache 和 MySQL 镜像
- en: Creating the required infrastructure with Terraform
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Terraform 创建所需的基础设施
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need an active Azure subscription to follow the exercises for this
    chapter. Currently, Azure is offering a free trial for 30 days with $200 worth
    of free credits; sign up at [https://azure.microsoft.com/en-in/free](https://azure.microsoft.com/en-in/free).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要一个有效的 Azure 订阅才能完成本章的练习。目前，Azure 正在提供为期 30 天的免费试用，并赠送 200 美元的免费额度；请在 [https://azure.microsoft.com/en-in/free](https://azure.microsoft.com/en-in/free)
    注册。
- en: 'You will also need to clone the following GitHub repository for some of the
    exercises:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要克隆以下 GitHub 仓库以完成部分练习：
- en: '[https://github.com/PacktPublishing/Modern-DevOps-Practices-2e](https://github.com/PacktPublishing/Modern-DevOps-Practices-2e%0D)'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Modern-DevOps-Practices-2e](https://github.com/PacktPublishing/Modern-DevOps-Practices-2e%0D)'
- en: 'Run the following command to clone the repository into your home directory,
    and `cd` into the `ch10` directory to access the required resources:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 运行以下命令，将仓库克隆到你的主目录中，并使用 `cd` 进入 `ch10` 目录以访问所需的资源：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You also need to install **Terraform** and **Ansible** on your system. Refer
    to [*Chapter 8*](B19877_08.xhtml#_idTextAnchor1010), *Infrastructure as Code (IaC)
    with Terraform*, and [*Chapter 9*](B19877_09.xhtml#_idTextAnchor1198), *Configuration
    Management with Ansible*, for more details on installing and setting up Terraform
    and Ansible.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要在系统上安装**Terraform**和**Ansible**。有关安装和设置 Terraform 和 Ansible 的更多详细信息，请参阅
    [*第 8 章*](B19877_08.xhtml#_idTextAnchor1010) *使用 Terraform 实现基础设施即代码 (IaC)* 和
    [*第 9 章*](B19877_09.xhtml#_idTextAnchor1198) *使用 Ansible 进行配置管理*。
- en: Immutable infrastructure with HashiCorp’s Packer
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 HashiCorp 的 Packer 实现不可变基础设施
- en: Imagine you are the author of a book and you need to make changes to an existing
    edition. When you want to make changes, such as improving the content or fixing
    the issues and ensuring the book is up to date, you don’t edit the existing book.
    Instead, you create a new edition with the desired updates while keeping the existing
    editions intact, like the new edition of this book. This concept aligns with **immutable
    infrastructure**.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你是一本书的作者，需要对现有版本进行更改。当你需要进行修改，比如改进内容、修正问题并确保书籍内容是最新时，你不会直接编辑现有的书籍。相反，你会创建一个新的版本，加入所需的更新，同时保持现有版本不变，就像这本书的新版一样。这一概念与**不可变基础设施**相契合。
- en: In IT and systems management, immutable infrastructure is a strategy where,
    instead of making changes to existing servers or **Virtual Machines** (**VMs**),
    you generate entirely new instances with the desired configuration. These new
    instances replace the old ones instead of modifying them, like creating a new
    book edition when you want to incorporate changes.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IT 和系统管理中，不可变基础设施是一种策略，其中，你不会对现有的服务器或**虚拟机**（**VMs**）进行修改，而是生成具有所需配置的全新实例。这些新实例会替代旧实例，而不是修改它们，类似于当你想要进行更改时，创建一本新版本的书籍。
- en: 'Here’s how it works:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 其工作原理如下：
- en: '**Building from scratch**: When you need to update a part of your infrastructure,
    you avoid making direct changes to the existing servers or machines. Instead,
    you create new ones from a pre-established template (an image) that includes the
    updated configuration.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**从零开始构建**：当你需要更新基础设施的一部分时，避免直接对现有的服务器或机器进行修改。相反，你会从一个预先建立的模板（镜像）中创建新的实例，并包含更新的配置。'
- en: '**No in-place modifications**: Like not editing an existing book, you avoid
    making in-place modifications to current servers. This practice reduces the risk
    of unforeseen changes or configuration inconsistencies.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不可就地修改**：就像不编辑现有的书籍一样，你应避免对当前服务器进行就地修改。这种做法减少了不可预见的变化或配置不一致的风险。'
- en: '**Consistency**: Immutable infrastructure ensures that every server or instance
    is identical because they all originate from the same template. This uniformity
    is valuable for ensuring reliability and predictability.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：不可变基础设施确保每个服务器或实例都是相同的，因为它们都源自相同的模板。这种统一性对于确保可靠性和可预测性非常重要。'
- en: '**Rolling updates**: When it’s time to implement an update, you systematically
    replace the old instances with the new ones in a controlled manner. This minimizes
    downtime and potential risks.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滚动更新**：当需要实施更新时，你会以受控的方式系统地用新实例替换旧实例。这将最小化停机时间和潜在风险。'
- en: '**Scalability**: Scaling your infrastructure becomes effortless by generating
    new instances as needed. This is akin to publishing new book editions when there’s
    a surge in demand, or things become outdated.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：通过按需生成新实例，扩展基础设施变得轻松自如。这类似于在需求激增或事物过时时发布新版本的书籍。'
- en: '**Rollback and recovery**: If issues arise from an update, you can swiftly
    revert to the previous version by re-creating instances from a known good template.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**回滚和恢复**：如果更新过程中出现问题，你可以通过从已知的良好模板重新创建实例，迅速恢复到之前的版本。'
- en: So, consider immutable infrastructure as a means of maintaining your infrastructure
    by creating new, improved instances rather than attempting to revise or modify
    existing ones. This approach elevates consistency, reliability, and predictability
    within your IT environment.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将不可变基础设施视为通过创建新的、改进的实例来维护基础设施的一种方式，而不是试图修订或修改现有的实例。这种方法提升了 IT 环境中的一致性、可靠性和可预测性。
- en: To understand this further, let’s consider the traditional method of setting
    up applications via Terraform and Ansible. We would use Terraform to spin up the
    infrastructure and then use Ansible on top to apply the relevant configuration
    to the infrastructure. That is what we did in the last chapter. While that is
    a viable approach, and many enterprises use it, there is a better way to do it
    with modern DevOps approaches and immutable infrastructure.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步理解这一点，让我们考虑通过 Terraform 和 Ansible 设置应用程序的传统方法。我们会使用 Terraform 启动基础设施，然后使用
    Ansible 在其上应用相关的配置。这就是我们在上一章所做的。虽然这是可行的方法，许多企业都在使用它，但有一种更好的方法，可以通过现代 DevOps 方法和不可变基础设施来实现。
- en: Immutable infrastructure is a ground-breaking concept that emerged due to the
    problems with **mutable infrastructure**. In a mutable infrastructure approach,
    we generally update servers in place. So, we follow a mutable process when we
    install Apache in a VM using Ansible and customize it further. We may want to
    update the servers, patch them, update our Apache to a newer version, and update
    our application code from time to time.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变基础设施是一个突破性的概念，它的出现是因为**可变基础设施**所带来的问题。在可变基础设施的方法中，我们通常会在原地更新服务器。因此，当我们使用
    Ansible 安装 Apache 并进一步自定义时，我们遵循的是可变过程。我们可能需要定期更新服务器、打补丁、将 Apache 升级到新版本，或更新应用程序代码。
- en: The issue with this approach is that while we can manage it well with Ansible
    (or related tools, such as **Puppet**, **Chef**, and **SaltStack**), the problem
    always remains that we are making live changes in a production environment that
    might go wrong for various reasons. Worse, it might update something we did not
    anticipate or test in the first place. We also might end up in a partial upgrade
    state that might be difficult to roll back.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的问题在于，虽然我们可以使用 Ansible（或类似工具，如**Puppet**、**Chef**和**SaltStack**）很好地管理它，但问题始终存在，即我们在生产环境中进行实时更改，这可能因各种原因出现问题。更糟糕的是，这可能会更新我们最初没有预见到或测试过的内容。我们也可能最终处于部分升级状态，且此状态可能难以回滚。
- en: With the scalable infrastructure that the cloud provides, you can have a dynamic
    horizontal scaling model where VMs scale with traffic. Therefore, you can have
    the best possible utilization of your infrastructure – the best bang for your
    buck! The problem with the traditional approach is that even if we use Ansible
    to apply the configuration to new machines, it is slower to get ready. Therefore,
    the scaling is not optimal, especially for bursty traffic.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 借助云提供的可扩展基础设施，你可以拥有一个动态的横向扩展模型，虚拟机根据流量进行扩展。因此，你可以实现最佳的基础设施利用率——用最少的投入获得最大的回报！传统方法的问题在于，即使我们使用
    Ansible 将配置应用到新机器上，准备好镜像的速度仍然较慢。因此，扩展并不理想，特别是对于流量突增的情况。
- en: Immutable infrastructure helps you manage these problems by taking the same
    approach we took for containers – *baking configuration directly into the OS image
    using modern DevOps tools and practices*. Immutable infrastructure helps you deploy
    the tested configuration to production by replacing the existing VM without doing
    any updates in place. It is faster to start and easy to roll back. You can also
    version infrastructure changes with this approach.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变基础设施通过采用与我们在容器中使用的相同方法来帮助你解决这些问题——*通过现代的 DevOps 工具和实践将配置直接烘焙到操作系统镜像中*。不可变基础设施通过替换现有虚拟机而不是在原地进行更新来帮助你将经过测试的配置部署到生产环境。它启动更快，回滚也更容易。你还可以通过这种方法对基础设施变更进行版本管理。
- en: '**HashiCorp** has an excellent suite of DevOps products related to infrastructure
    and configuration management. HashiCorp provides **Packer** to help you create
    immutable infrastructure by baking configurations directly in your VM image, rather
    than the slow process of creating a VM with a generic OS image and then customizing
    it later. It works on a similar principle as Docker uses to bake container images;
    that is, you define a template (configuration file) that specifies the source
    image, the desired configuration, and any provisioning steps needed to set up
    the software on the image. Packer then builds the image by creating a temporary
    instance with the base image, applying the defined configuration, and capturing
    the machine image for reuse.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**HashiCorp** 提供了一套出色的与基础设施和配置管理相关的 DevOps 产品。HashiCorp 提供 **Packer** 来帮助你通过直接将配置烘焙到虚拟机镜像中，从而创建不可变基础设施，而不是先使用通用的操作系统镜像创建虚拟机，再后续进行自定义的慢速过程。它的工作原理与
    Docker 用于烘焙容器镜像的原理类似；也就是说，你定义一个模板（配置文件），指定源镜像、所需配置以及设置镜像上软件所需的任何提供步骤。然后，Packer
    会通过创建一个临时实例来构建镜像，应用已定义的配置，并捕获机器镜像以供重复使用。'
- en: 'Packer provides some of the following key features:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Packer 提供以下一些关键功能：
- en: '**Multi-platform support**: Packer works on the plugin architecture and, therefore,
    can be used to create VM images for a lot of different cloud and on-premises platforms,
    such as VMware, Oracle VirtualBox, Amazon EC2, Azure’s ARM, Google Cloud Compute,
    and container images for Docker or other container runtimes.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多平台支持**：Packer 基于插件架构，因此可以用于为许多不同的云平台和本地平台创建虚拟机镜像，如 VMware、Oracle VirtualBox、Amazon
    EC2、Azure 的 ARM、Google Cloud Compute 以及 Docker 或其他容器运行时的容器镜像。'
- en: '**Automation**: Packer automates image creation and eliminates manual effort
    to build images. It also helps you with your multi-cloud strategy, as you can
    use a single configuration to build images for various platforms.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化**：Packer 自动化镜像创建，消除了手动构建镜像的工作。它还帮助你实现多云战略，因为你可以使用单一配置为各种平台构建镜像。'
- en: '**Fosters GitOps**: Packer configurations are machine-readable and written
    in HCL or JSON, so they can easily sit with your code. This, therefore, fosters
    GitOps.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**促进 GitOps**：Packer 配置是机器可读的，并且以 HCL 或 JSON 格式编写，因此可以轻松与代码一起存放。因此，这促进了 GitOps。'
- en: '**Integration with other tools**: Packer integrates well with other HashiCorp
    tools, such as Terraform and Vagrant.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**与其他工具的集成**：Packer 与其他 HashiCorp 工具（如 Terraform 和 Vagrant）集成良好。'
- en: 'Packer uses a staging VM to customize the image. The following is the process
    that Packer follows while building the custom image:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Packer 使用一个临时虚拟机来定制镜像。以下是 Packer 在构建自定义镜像时遵循的过程：
- en: You start with Packer configuration HCL files to define the base image you want
    to start from and where to build the image. You also define the provisioner for
    building the custom image, such as Ansible, and specify what playbooks to use.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你从 Packer 配置的 HCL 文件开始，定义你想要启动的基础镜像以及构建镜像的地方。你还需要定义用于构建自定义镜像的提供者，如 Ansible，并指定要使用的剧本。
- en: When you run a Packer build, Packer uses the details in the configuration files
    to create a build VM from the base image, run the provisioner to customize it,
    turn off the build VM, take a snapshot, and save that as a disk image. It finally
    saves the image in an image repository.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你运行 Packer 构建时，Packer 使用配置文件中的细节，从基础镜像创建构建虚拟机，运行配置工具进行定制，关闭构建虚拟机，拍摄快照，并将其保存为磁盘镜像。最后，它将镜像保存在镜像仓库中。
- en: You can then build the VM from the custom image using Terraform or other tools.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用 Terraform 或其他工具，从自定义镜像构建虚拟机。
- en: 'The following figure explains the process in detail:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下图详细解释了该过程：
- en: '![Figure 10.1 – Packer build process](img/B19877_10_1.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 10.1 – Packer 构建过程](img/B19877_10_1.jpg)'
- en: Figure 10.1 – Packer build process
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1 – Packer 构建过程
- en: The result is that your application is quick to start up and scales very well.
    For any changes within your configuration, create a new disk image with Packer
    and Ansible and then use Terraform to apply the changes to your resources. Terraform
    will then spin down the old VMs and spin up new ones with the new configuration.
    If you can relate it to the container deployment workflow, you can make real sense
    of it. It's akin to using the container workflow within the VM world! But is immutable
    infrastructure for everyone? Let’s understand where it fits best.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是你的应用程序启动迅速，扩展性非常好。对于配置中的任何更改，使用 Packer 和 Ansible 创建一个新的磁盘镜像，然后通过 Terraform
    将更改应用到你的资源上。Terraform 会停止旧的虚拟机并启动新的虚拟机，应用新的配置。如果你能将其与容器部署工作流联系起来，你会更好地理解这一点。这就像在虚拟机世界中使用容器工作流一样！但不可变基础设施适合所有人吗？让我们来理解它最适合的场景。
- en: When to use immutable infrastructure
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用不可变基础设施
- en: Deciding to switch to immutable infrastructure is difficult, especially when
    your Ops team treats servers as pets. Most people get paranoid about the idea
    of deleting an existing server and creating a new one for every update. Well,
    you need to do a lot of convincing when you first come up with the idea. However,
    it does not mean that you must use immutable infrastructure to do proper DevOps.
    It all depends on your use case.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 决定切换到不可变基础设施是很困难的，特别是当你的运维团队将服务器视为宠物时。大多数人对于删除现有服务器并为每次更新创建新服务器的想法感到疑虑重重。嗯，当你第一次提出这个想法时，你需要做很多说服工作。然而，这并不意味着你必须使用不可变基础设施才能做好
    DevOps。最终取决于你的使用场景。
- en: Let’s look at each approach’s pros and cons to understand them better.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过分析每种方法的优缺点来更好地理解它们。
- en: Pros of mutable infrastructure
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可变基础设施的优点
- en: 'Let’s begin with the pros of mutable infrastructure:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们先从可变基础设施的优点开始：
- en: If adequately managed, mutable infrastructure is faster to upgrade and change.
    It makes security patches quicker.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果管理得当，可变基础设施的升级和变更速度较快。安全补丁的应用也更为迅速。
- en: It is simpler to manage, as we don’t have to worry about building the entire
    VM image and redeploying it for every update.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它更易于管理，因为我们不必担心为每次更新构建整个虚拟机镜像并重新部署它。
- en: Cons of mutable infrastructure
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可变基础设施的缺点
- en: 'Next, let’s see the cons of mutable infrastructure:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看可变基础设施的缺点：
- en: It eventually results in configuration drift. When people start making changes
    manually in the server and do not use a config management tool, it becomes difficult
    to know what’s in the server after a particular point. Then, you will have to
    start relying on snapshots.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它最终会导致配置漂移。当人们开始在服务器上手动进行更改并且不使用配置管理工具时，之后你很难知道服务器在某个特定时间点上的状态。然后，你将不得不开始依赖快照。
- en: Versioning is impossible with mutable infrastructure, and rolling back changes
    is troublesome.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可变基础设施中，无法进行版本控制，回滚更改也很麻烦。
- en: There is a possibility of partial updates because of technical issues such as
    a patchy network, unresponsive **apt** repositories, and so on.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于技术问题，例如网络不稳定、**apt** 仓库无响应等，可能会出现部分更新的情况。
- en: There is a risk because changes are applied directly to the production environment.
    There is also a chance that you will end up in an unanticipated state that is
    difficult to troubleshoot.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于更改直接应用到生产环境中，因此存在一定风险。你也有可能陷入一个难以排查的意外状态。
- en: Because of configuration drift, it is impossible to say that the current configuration
    is the same as being tracked in version control. Therefore, building a new server
    from scratch may require manual intervention and comprehensive testing.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于配置漂移，无法保证当前的配置与版本控制中记录的配置一致。因此，从零开始构建新服务器可能需要手动干预和全面测试。
- en: Similarly, let’s look at the pros and cons of immutable infrastructure.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，让我们看看不可变基础设施的优缺点。
- en: Pros of immutable infrastructure
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可变基础设施的优点
- en: 'The pros of immutable infrastructure are as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变基础设施的优点如下：
- en: It eliminates configuration drift as the infrastructure cannot change once deployed,
    and any changes should come via the CI/CD process.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它消除了配置漂移，因为一旦部署了基础设施，基础设施就不能改变，任何更改都应通过CI/CD流程进行。
- en: It is DevOps-friendly as every build and deployment process inherently follows
    modern DevOps practices.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它对DevOps友好，因为每个构建和部署过程本质上遵循现代DevOps实践。
- en: It makes discrete versioning possible as every image generated from an image
    build can be versioned and kept within an image repository. That makes rollouts
    and rollbacks much more straightforward and promotes modern DevOps practices such
    as **canary** and **blue-green** deployments with A/B testing.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使得离散版本控制成为可能，因为从镜像构建生成的每个镜像都可以进行版本控制并保存在镜像仓库中。这使得推出和回滚变得更加简单，并促进现代DevOps实践，如**金丝雀**和**蓝绿**部署以及A/B测试。
- en: The image is pre-built and tested, so we always get a predictable state from
    immutable infrastructure. We, therefore, reduce a lot of risk from production
    implementations.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像是预构建和经过测试的，因此我们总是从不可变基础设施中获得可预测的状态。因此，我们从生产实施中减少了很多风险。
- en: It helps with horizontal scaling on the cloud because you can now create servers
    from pre-built images, making new VMs faster to start up and get ready.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它有助于云上的水平扩展，因为您现在可以从预构建的镜像创建服务器，使得新的虚拟机启动更快且准备就绪。
- en: Cons of immutable infrastructure
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不可变基础设施的缺点
- en: 'The cons of immutable infrastructure are as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 不可变基础设施的缺点如下：
- en: Building and deploying immutable infrastructure is a bit complex, and it is
    slow to add updates and manage urgent hotfixes
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和部署不可变基础设施有些复杂，并且增加更新和管理紧急修复的速度比较慢。
- en: There are storage and network overheads in generating and managing VM images
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成和管理VM镜像存在存储和网络开销
- en: So, as we’ve looked at the pros and cons of both approaches, it ultimately depends
    on how you currently do infrastructure management and your end goal. Immutable
    infrastructure has a huge benefit, and therefore, it is something that every modern
    DevOps engineer should understand and implement if possible. However, technical
    and process constraints prevent people from doing it – while some constraints
    are related to the technology stack, most are simply related to processes and
    red tape. Immutable infrastructure is best when you need consistently reproducible
    and exceptionally reliable deployments. This approach minimizes the risk of configuration
    drift and streamlines updates by reconstructing entire environments instead of
    tweaking existing elements. It proves especially advantageous in scenarios such
    as microservices architectures, container orchestration, and situations where
    rapid scaling and the ability to roll back changes are paramount.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们看了两种方法的优缺点之后，最终取决于您当前如何进行基础设施管理以及您的最终目标。不可变基础设施有巨大的好处，因此，每个现代DevOps工程师都应该理解并尽可能实现它。然而，技术和流程约束阻止了人们的尝试
    - 虽然一些约束与技术堆栈有关，但大多数仅与流程和官僚主义有关。不可变基础设施在需要一致可重现和异常可靠的部署时尤为有利。这种方法通过重建整个环境而不是调整现有元素，最小化了配置漂移的风险，并简化了更新过程。在微服务架构、容器编排以及需要快速扩展和能够回滚更改的场景中，特别有优势。
- en: We all know that DevOps is not all about tools but it is a cultural change that
    should originate from the very top. If it is not possible to use immutable infrastructure,
    you can always use a **config management** tool such as Ansible on top of live
    servers. That makes things manageable to a certain extent.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都知道DevOps不仅仅关乎工具，而是一种应该从高层发源的文化变革。如果不可能使用不可变基础设施，您总是可以在活跃服务器上使用像Ansible这样的**配置管理**工具。这在一定程度上使事物变得可管理。
- en: Now, moving on to Packer, let’s look at how to install it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，继续讲解Packer，让我们看看如何安装它。
- en: Installing Packer
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Packer
- en: 'You can install Packer on a variety of platforms in a variety of ways. Please
    refer to [https://developer.hashicorp.com/packer/downloads](https://developer.hashicorp.com/packer/downloads).
    As Packer is available as an **apt** package, use the following commands to install
    Packer on Ubuntu Linux:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在各种平台上以多种方式安装Packer。请参考[https://developer.hashicorp.com/packer/downloads](https://developer.hashicorp.com/packer/downloads)。由于Packer作为**apt**包可用，请使用以下命令在Ubuntu
    Linux上安装Packer：
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To verify the installation, run the following command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证安装情况，请运行以下命令：
- en: '[PRE2]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we see, Packer is installed successfully. We can proceed with the next activity
    in our goal – *creating playbooks*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，Packer 安装成功。我们可以继续进行我们的下一个目标活动——*创建 playbook*。
- en: Creating the Apache and MySQL playbooks
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Apache 和 MySQL playbook
- en: As our goal is to spin up a scalable **LAMP stack** in this chapter, we must
    start by defining Ansible playbooks that would run on the build VM. We’ve already
    created some roles for Apache and MySQL in [*Chapter 9*](B19877_09.xhtml#_idTextAnchor1198),
    *Configuration Management with Ansible*. We will use the same roles within this
    setup as well.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们本章的目标是启动一个可扩展的 **LAMP 堆栈**，因此我们必须首先定义将在构建 VM 上运行的 Ansible playbook。我们已经在[*第9章*](B19877_09.xhtml#_idTextAnchor1198)，“使用
    Ansible 的配置管理”中为 Apache 和 MySQL 创建了一些角色。我们将在此设置中使用相同的角色。
- en: 'Therefore, we will have the following directory structure within the `ch10`
    directory:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将在 `ch10` 目录中拥有以下目录结构：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We have two playbooks within the `ansible` directory – `webserver-playbook.yaml`
    and `dbserver-playbook.yaml`. Let’s look at each to understand how we write our
    playbooks for Ansible.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `ansible` 目录中有两个 playbook——`webserver-playbook.yaml` 和 `dbserver-playbook.yaml`。让我们分别看看它们，了解如何为
    Ansible 编写 playbook。
- en: '`webserver-playbook.yaml` looks like the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`webserver-playbook.yaml` 文件内容如下：'
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`dbserver-playbook.yaml` looks like the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`dbserver-playbook.yaml` 文件内容如下：'
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we can see, both playbooks have `hosts` set to `default`. That is because
    we will not define the inventory for this playbook. Instead, Packer will use the
    build VM to build the image and dynamically generate the inventory.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，两个 playbook 的 `hosts` 都设置为 `default`。这是因为我们不会为此 playbook 定义清单。相反，Packer
    将使用构建 VM 来构建镜像并动态生成清单。
- en: Note
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Packer will also ignore any `remote_user` attributes within the task and use
    the user present in the Ansible provisioner’s config.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Packer 还会忽略任务中的任何 `remote_user` 属性，并使用 Ansible provisioner 配置中的用户。
- en: As we’ve already tested this configuration in the previous chapter, all we need
    to do now is define the Packer configuration, so let’s go ahead and do that in
    the next section.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在上一章中已经测试过此配置，现在我们需要做的就是定义 Packer 配置，接下来让我们在下一章节中进行操作。
- en: Building the Apache and MySQL images using Packer and Ansible provisioners
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Packer 和 Ansible provisioner 构建 Apache 和 MySQL 镜像
- en: We will now use Packer to create the Apache and MySQL images. Before defining
    the Packer configuration, we have a few prerequisites to allow Packer to build
    custom images.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用 Packer 创建 Apache 和 MySQL 镜像。在定义 Packer 配置之前，我们有几个前提条件，以允许 Packer 构建自定义镜像。
- en: Prerequisites
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前提条件
- en: We must create an **Azure service principal** for Packer to interact with Azure
    and build the image.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须为 Packer 创建一个 **Azure 服务主体**，以便它与 Azure 进行交互并构建镜像。
- en: 'First, log in to your Azure account using the Azure CLI with the following
    command:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，使用以下命令通过 Azure CLI 登录到你的 Azure 帐户：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, set the subscription to the subscription ID we got in response to the
    `az login` command to an environment variable using the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用以下命令将订阅设置为我们从 `az login` 命令响应中获取的订阅 ID，并将其存储为环境变量：
- en: '[PRE7]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, let’s set the subscription ID using the following command:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们使用以下命令设置订阅 ID：
- en: '[PRE8]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then, create the service principal with contributor access using the following
    command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下命令创建具有贡献者访问权限的服务主体：
- en: '[PRE9]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We’ve successfully created the service principal. The response JSON consists
    of `appId`, `password`, and `tenant` values that we will use in the subsequent
    sections.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功创建了服务主体。响应的 JSON 包含了 `appId`、`password` 和 `tenant` 值，我们将在接下来的章节中使用这些值。
- en: Note
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can also reuse the service principal we created in [*Chapter 8*](B19877_08.xhtml#_idTextAnchor1010),
    *Infrastructure as Code (IaC) with* *Terraform*, instead.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以重用我们在[*第8章*](B19877_08.xhtml#_idTextAnchor1010)，“使用 Terraform 进行基础设施即代码
    (IaC)”中创建的服务主体。
- en: 'Now, let’s go ahead and set the values of these variables in the `packer/variables.pkrvars.hcl`
    file with the details:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续在 `packer/variables.pkrvars.hcl` 文件中设置这些变量的值，具体内容如下：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We will use the variable file in our Packer build. We also need a resource group
    for storing the built images.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 Packer 构建中使用变量文件。我们还需要一个资源组来存储构建的镜像。
- en: 'To create the resource group, run the following command:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建资源组，请运行以下命令：
- en: '[PRE11]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now, let’s go ahead and define the Packer configuration.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续定义 Packer 配置。
- en: Defining the Packer configuration
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义 Packer 配置
- en: Packer allows us to define configuration in JSON as well as HCL files. As JSON
    is now deprecated and HCL is preferred, let’s define the Packer configuration
    using HCL.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Packer 允许我们在 JSON 和 HCL 文件中定义配置。由于 JSON 已被弃用且 HCL 是推荐格式，因此我们将使用 HCL 来定义 Packer
    配置。
- en: 'To access resources for this section, switch to the following directory:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本节的资源，请切换到以下目录：
- en: '[PRE12]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will create the following files in the `packer` directory:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 `packer` 目录中创建以下文件：
- en: '`variables.pkr.hcl`: Contains a list of variables we would use while applying
    the configuration'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`variables.pkr.hcl`：包含我们在应用配置时使用的变量列表'
- en: '`plugins.pkr.hcl`: Contains the Packer plugin configuration'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`plugins.pkr.hcl`：包含 Packer 插件配置'
- en: '`webserver.pkr.hcl`: Contains the Packer configuration for building the web
    server image'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`webserver.pkr.hcl`：包含构建 web 服务器镜像的 Packer 配置'
- en: '`dbserver.pkr.hcl`: Contains the Packer configuration for building the `dbserver`
    image'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dbserver.pkr.hcl`：包含构建 `dbserver` 镜像的 Packer 配置'
- en: '`variables.pkrvars.hcl`: Contains the values of the Packer variables defined
    in the `variables.pkr.hcl` file'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`variables.pkrvars.hcl`：包含 `variables.pkr.hcl` 文件中定义的 Packer 变量的值'
- en: 'The `variables.pkr.hcl` file contains the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`variables.pkr.hcl` 文件包含以下内容：'
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `variables.pkr.hcl` file defines a list of user variables that we can use
    within the `source` and `build` blocks of the Packer configuration. We’ve defined
    four string variables – `client_id`, `client_secret`, `tenant_id`, and `subscription_id`.
    We can pass the values of these variables by using the `variables.pkrvars.hcl`
    variable file we defined in the last section.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`variables.pkr.hcl` 文件定义了一个用户变量列表，我们可以在 Packer 配置的 `source` 和 `build` 块中使用。我们定义了四个字符串变量——`client_id`、`client_secret`、`tenant_id`
    和 `subscription_id`。我们可以通过使用在上一节中定义的 `variables.pkrvars.hcl` 变量文件来传递这些变量的值。'
- en: Tip
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Always provide sensitive data from external variables, such as a variable file,
    environment variables, or a secret manager, such as HashiCorp’s Vault. You should
    never commit sensitive information with code.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 始终通过外部变量提供敏感数据，如变量文件、环境变量或秘密管理工具，如 HashiCorp 的 Vault。绝不应将敏感信息与代码一起提交。
- en: 'The `plugins.pkr.hcl` file contains the following block:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '`plugins.pkr.hcl` 文件包含以下块：'
- en: '`packer`: This section defines the common configuration for Packer. In this
    case, we’ve defined the plugins required to build the image. There are two plugins
    defined here – `ansible` and `azure`. Plugins contain a `source` and `version`
    attribute. They contain everything you would need to interact with the technology
    component:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`packer`：此部分定义了 Packer 的通用配置。在此案例中，我们定义了构建镜像所需的插件。这里定义了两个插件——`ansible` 和 `azure`。插件包含
    `source` 和 `version` 属性，包含与技术组件交互所需的一切：'
- en: '[PRE14]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `webserver.pkr.hcl` file contains the following sections:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`webserver.pkr.hcl` 文件包含以下几个部分：'
- en: '`source`: The `source` block contains the configuration we would use to build
    the VM. As we build an `azure-arm` image, we define the source as follows:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`source`：`source` 块包含我们用于构建虚拟机的配置。由于我们正在构建一个 `azure-arm` 镜像，我们将源定义如下：'
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: build {
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: build {
- en: sources = ["source.azure-arm.webserver"]
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: sources = ["source.azure-arm.webserver"]
- en: provisioner "ansible" {
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: provisioner "ansible" {
- en: playbook_file = "../ansible/webserver-playbook.yaml"
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: playbook_file = "../ansible/webserver-playbook.yaml"
- en: '}'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: ../ansible/webserver-playbook.yaml.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ../ansible/webserver-playbook.yaml。
- en: Tip
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示
- en: You can specify multiple sources in the `build` block, each with the same or
    different types. Similarly, we can have numerous provisioners, each executed in
    parallel. So, if you want to build the same configuration for multiple cloud providers,
    you can specify multiple sources for each cloud provider.
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在 `build` 块中指定多个源，每个源可以是相同或不同类型。类似地，我们可以拥有多个提供者，它们会并行执行。因此，如果你想为多个云提供商构建相同的配置，可以为每个云提供商指定多个源。
- en: 'Similarly, we’ve defined the following `dbserver.pkr.hcl` file:'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类似地，我们定义了以下 `dbserver.pkr.hcl` 文件：
- en: '[PRE16]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `source` block has the same configuration as the web server apart from `managed_image_name`.
    The `build` block is also like the web server, but instead, it uses the `../``ansible/dbserver-playbook.yaml`
    playbook.
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`source` 块的配置与 web 服务器相同，除了 `managed_image_name`。`build` 块也类似于 web 服务器，但它使用的是
    `../ansible/dbserver-playbook.yaml` playbook。'
- en: Now, let’s look at the Packer workflow and how to use it to build the image.
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，让我们看看 Packer 的工作流以及如何使用它来构建镜像。
- en: The Packer workflow for building images
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 构建镜像的 Packer 工作流
- en: The Packer workflow comprises two steps – `init` and `build`.
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Packer 工作流包括两个步骤——`init` 和 `build`。
- en: As we already know, Packer uses plugins to interact with the cloud providers;
    therefore, we need to install them. To do so, Packer provides the `init` command.
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如我们所知，Packer使用插件与云服务商进行交互；因此，我们需要安装这些插件。为此，Packer提供了`init`命令。
- en: 'Let’s initialize and install the required plugins using the following command:'
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们使用以下命令初始化并安装所需的插件：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As we can see, the plugin is now installed. Let’s now go ahead and build the
    image.
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如我们所见，插件现在已安装。让我们继续构建镜像。
- en: 'We use the `build` command to create an image using Packer. As we would need
    to pass values to variables, we will specify the variable values using a command-line
    argument, as in the following command:'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用`build`命令通过Packer创建镜像。由于我们需要传递值给变量，我们将通过命令行参数指定变量值，如以下命令所示：
- en: '[PRE18]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Packer would build parallel stacks using both the `webserver` and `dbserver`
    configs.
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Packer将使用`webserver`和`dbserver`配置构建并行堆栈。
- en: 'Packer first creates temporary resource groups to spin up staging VMs:'
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Packer首先创建临时资源组来启动暂存的VM：
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Packer then validates and deploys the deployment templates and gets the IP
    addresses of the staging VMs:'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Packer接着验证并部署部署模板，并获取暂存VM的IP地址：
- en: '[PRE20]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, Packer uses SSH to connect with the staging VMs and provisions them with
    Ansible:'
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，Packer使用SSH连接到暂存的VM，并使用Ansible为其配置：
- en: '[PRE21]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Once the Ansible run is complete, Packer gets the disk details, captures the
    images, and creates the machine images in the resource groups we specified in
    the Packer configuration:'
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦Ansible运行完成，Packer会获取磁盘详情，捕获镜像，并在我们在Packer配置中指定的资源组中创建机器镜像：
- en: '[PRE22]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, it removes the deployment object and the temporary resource group
    it created:'
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，它移除部署对象和它所创建的临时资源组：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'It then provides the list of artifacts it has generated:'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，它会提供它所生成的工件列表：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we look at the `packer-rg` resource group, we will find that there are two
    VM images within it:'
  id: totrans-168
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们查看`packer-rg`资源组，我们会发现其中有两个VM镜像：
- en: '![Figure 10.2 – Packer custom images](img/B19877_10_2.jpg)'
  id: totrans-169
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图10.2 – Packer自定义镜像](img/B19877_10_2.jpg)'
- en: Figure 10.2 – Packer custom images
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图10.2 – Packer自定义镜像
- en: We’ve successfully built custom images with Packer!
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经成功地用Packer构建了自定义镜像！
- en: Tip
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 小贴士
- en: It isn’t possible to rerun Packer with the same managed image name once the
    image is created in the resource group. That is because we don’t want to override
    an existing image accidentally. While you can override it by using the `-force`
    flag with `packer build`, you should include a version within the image name to
    allow multiple versions of the image to exist in the resource group. For example,
    instead of using `apache-webserver`, you can use `apache-webserver-0.0.1`.
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦镜像在资源组中创建，就无法使用相同的托管镜像名称重新运行Packer。这是因为我们不希望意外覆盖现有镜像。虽然你可以通过使用`-force`标志与`packer
    build`来覆盖它，但应该在镜像名称中包含版本号，以便在资源组中允许多个版本的镜像存在。例如，使用`apache-webserver-0.0.1`而不是`apache-webserver`。
- en: It’s time to use these images and create our infrastructure with them now.
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在是使用这些镜像并用它们创建我们基础设施的时候了。
- en: Creating the required infrastructure with Terraform
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用Terraform创建所需的基础设施
- en: Our goal was to build a scalable LAMP stack, so we will define a `apache-webserver`
    image we created and a single VM with the `mysql-dbserver` image. A VM scale set
    is an autoscaling group of VMs that will scale out and scale back horizontally
    based on traffic, similar to how we did with containers on Kubernetes.
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的目标是构建一个可扩展的LAMP堆栈，因此我们将定义一个我们创建的`apache-webserver`镜像和一个使用`mysql-dbserver`镜像的虚拟机。VM规模集是一个VM的自动扩展组，它将根据流量横向扩展和收缩，就像我们在Kubernetes中使用容器时做的一样。
- en: 'We will create the following resources:'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将创建以下资源：
- en: A new resource group called `lamp-rg`
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`lamp-rg`的新资源组
- en: A virtual network within the resource group called `lampvnet`
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`lampvnet`的虚拟网络位于资源组内
- en: A subnet within `lampvnet` called `lampsub`
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`lampsub`的子网，位于`lampvnet`内
- en: 'Within the subnet, we create a `db-nic` that contains the following:'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在子网内，我们创建了一个包含以下内容的`db-nic`：
- en: A network security group called `db-nsg`
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`db-nsg`的网络安全组
- en: A VM called `db` that uses the custom `mysql-dbserver` image
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`db`的虚拟机，使用自定义的`mysql-dbserver`镜像
- en: 'We then create a VM scale set that includes the following:'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们创建一个包括以下内容的VM规模集：
- en: A network profile called `webnp`
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`webnp`的网络配置文件
- en: A backend address pool
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个后端地址池
- en: A load balancer called `web-lb`
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`web-lb`的负载均衡器
- en: A public IP address attached to `web-lb`
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附加到`web-lb`的公共IP地址
- en: An HTTP probe that checks the health of port `80`
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个检查`80`端口健康状况的HTTP探针
- en: 'The following figure explains the topology graphically:'
  id: totrans-190
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下图形说明了拓扑结构：
- en: '![Figure 10.3 – Scalable LAMP stack topology diagram](img/B19877_10_3.jpg)'
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 10.3 – 可扩展 LAMP 堆栈拓扑图](img/B19877_10_3.jpg)'
- en: Figure 10.3 – Scalable LAMP stack topology diagram
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.3 – 可扩展 LAMP 堆栈拓扑图
- en: 'To access resources for this section, switch to the following directory:'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要访问本节的资源，请切换到以下目录：
- en: '[PRE25]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We use the following Terraform template, `main.tf`, to define the configuration.
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用以下 Terraform 模板，`main.tf`，来定义配置。
- en: 'We first define the Terraform providers:'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们首先定义 Terraform 提供程序：
- en: '[PRE26]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We then define the custom image data sources so that we can use them within
    our configuration:'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后我们定义自定义镜像数据源，以便在我们的配置中使用它们：
- en: '[PRE27]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We then define the resource group, virtual network, and subnet:'
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后我们定义资源组、虚拟网络和子网：
- en: '[PRE28]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As the Apache web servers will remain behind a network load balancer, we will
    define the load balancer and the public IP address that we will attach to it:'
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于 Apache Web 服务器将位于网络负载均衡器后面，我们将定义负载均衡器和我们将附加到其上的公共 IP 地址：
- en: '[PRE29]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We will then define a backend address pool to the load balancer so that we
    can use this within the Apache VM scale set:'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后我们将定义一个后端地址池，附加到负载均衡器，以便我们可以在 Apache 虚拟机规模集中使用它：
- en: '[PRE30]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We will define an HTTP probe on port `80` for a health check and attach it
    to the load balancer:'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在端口`80`上定义一个 HTTP 探测器，用于健康检查，并将其附加到负载均衡器：
- en: '[PRE31]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We need a `80` on the load balancer with port `80` of the backend pool VMs.
    We will also attach the HTTP health check probe in this config:'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们需要在负载均衡器上设置`80`端口，并将其与后端池虚拟机的`80`端口关联。我们还将在此配置中附加 HTTP 健康检查探测器：
- en: '[PRE32]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we will define the VM scale set within the resource group using the custom
    image and the load balancer we defined before:'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们将在资源组内使用自定义镜像和之前定义的负载均衡器来定义虚拟机规模集：
- en: '[PRE33]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We then go ahead and define the OS disk and the data disk:'
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后我们继续定义操作系统磁盘和数据磁盘：
- en: '[PRE34]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The OS profile defines how we log in to the VM:'
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 操作系统配置文件定义了我们如何登录到虚拟机：
- en: '[PRE35]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We then define a network profile that will associate the scale set with the
    load balancer we defined before:'
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后我们定义一个网络配置文件，将规模集与之前定义的负载均衡器关联：
- en: '[PRE36]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, moving on to the database configuration, we will start by defining a network
    security group for the database servers to allow ports `22` and `3306` from internal
    servers within the virtual network:'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，进入数据库配置，我们将首先为数据库服务器定义一个网络安全组，以允许从虚拟网络内的内部服务器访问端口`22`和`3306`：
- en: '[PRE37]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We then define a NIC to provide an internal IP to the VM:'
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后我们定义一个网络接口卡（NIC）为虚拟机提供内部 IP 地址：
- en: '[PRE38]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We will then associate the network security group to the network interface:'
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后我们将网络安全组与网络接口关联：
- en: '[PRE39]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Finally, we’ll define the database VM using the custom image:'
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们将使用自定义镜像定义数据库虚拟机：
- en: '[PRE40]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, as we’ve defined everything we needed, fill the `terraform.tfvars` file
    with the required information, and go ahead and initialize our Terraform workspace
    by using the following command:'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，既然我们已经定义了所需的一切，请填写`terraform.tfvars`文件中的必要信息，然后使用以下命令初始化我们的 Terraform 工作区：
- en: '[PRE41]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'As Terraform has initialized successfully, use the following command to apply
    the Terraform configuration:'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于 Terraform 已成功初始化，请使用以下命令应用 Terraform 配置：
- en: '[PRE42]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'As Terraform has applied the configuration and provided the load balancer IP
    address as an output, let’s use that to navigate to the web server:'
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于 Terraform 已应用配置并提供了负载均衡器 IP 地址作为输出，我们使用该地址访问 Web 服务器：
- en: '![Figure 10.4 – LAMP stack working correctly](img/B19877_10_4.jpg)'
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 10.4 – LAMP 堆栈正常工作](img/B19877_10_4.jpg)'
- en: Figure 10.4 – LAMP stack working correctly
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.4 – LAMP 堆栈正常工作
- en: As we get the `Database Connected successfully` message, we see that the configuration
    is successful! We’ve successfully created a scalable LAMP stack using Packer,
    Ansible, and Terraform. It combines *IaC*, *configuration as code*, *immutable
    infrastructure*, and modern DevOps practices to create a seamless environment
    without manual intervention.
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当我们收到`数据库成功连接`消息时，我们看到配置成功！我们已成功使用 Packer、Ansible 和 Terraform 创建了一个可扩展的 LAMP
    堆栈。它结合了*基础设施即代码（IaC）*、*配置即代码*、*不可变基础设施* 和现代 DevOps 实践，创建了一个无须人工干预的无缝环境。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have covered immutable infrastructure with Packer. We used
    Packer with the Ansible provisioner to build custom images for Apache and MySQL.
    We used the custom images to create a scalable LAMP stack using Terraform. The
    chapter introduced you to the era of modern DevOps, where everything is automated.
    We follow the same principles for building and deploying all kinds of infrastructure,
    be it containers or VMs. In the next chapter, we will discuss one of the most
    important topics of DevOps – **continuous integration**.
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了使用 Packer 构建不可变基础设施。我们使用 Packer 配合 Ansible 提供程序构建了用于 Apache 和 MySQL
    的自定义镜像。然后使用这些自定义镜像通过 Terraform 创建了一个可扩展的 LAMP 堆栈。本章向你介绍了现代 DevOps 的时代，在这个时代中，一切都实现了自动化。我们遵循相同的原则来构建和部署各种类型的基础设施，无论是容器还是虚拟机。在下一章中，我们将讨论
    DevOps 中最重要的主题之一——**持续集成**。
- en: Questions
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 问题
- en: Immutable infrastructure helps avoid configuration drift. (True/False)
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不可变基础设施有助于避免配置漂移。（正确/错误）
- en: It is a best practice to source sensitive data from external variables such
    as environment variables or a secret management tool such as HashiCorp’s Vault.
    (True/False)
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最佳实践是从外部变量（如环境变量）或像 HashiCorp 的 Vault 这样的秘密管理工具中获取敏感数据。（正确/错误）
- en: What modifications must we make to our existing playbooks to allow Packer to
    use them?
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要对现有的 playbook 做哪些修改，以便 Packer 能够使用它们？
- en: A. Remove any existing `ansible.cfg` files from the current working directory.
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. 从当前工作目录中删除任何现有的 `ansible.cfg` 文件。
- en: B. Remove any host files from the current working directory.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. 从当前工作目录中删除任何主机文件。
- en: C. Update the `hosts` attribute to default within the playbook.
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. 在 playbook 中将 `hosts` 属性更新为默认值。
- en: D. None of the above.
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. 以上都不是。
- en: Which of the following are the limitations of using the Ansible provisioner
    with Packer? (Choose two)
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些是使用 Ansible 提供程序与 Packer 配合使用时的限制？（选择两个）
- en: A. You cannot pass Jinja2 macros as is to your Ansible playbooks.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. 你不能将 Jinja2 宏原样传递到 Ansible playbook 中。
- en: B. You cannot define `remote_user` within your Ansible playbooks.
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. 你不能在 Ansible playbook 中定义 `remote_user`。
- en: C. You cannot use Jinja2 templates within your Ansible playbooks.
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. 你不能在 Ansible playbook 中使用 Jinja2 模板。
- en: D. You cannot use roles and variables within your Ansible playbooks.
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. 你不能在 Ansible playbook 中使用角色和变量。
- en: While naming managed images, what should we consider? (Choose two)
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命名托管镜像时，我们应考虑哪些因素？（选择两个）
- en: A. Name images as specifically as possible.
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. 尽可能具体地命名镜像。
- en: B. Use the version as part of the image.
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. 将版本作为镜像的一部分。
- en: C. Don’t use the version as part of the image name. Instead, always use the
    `-force` flag within the Packer build.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. 不要将版本作为镜像名称的一部分。相反，总是使用 `-force` 标志来构建 Packer。
- en: When using multiple provisioners, how are configurations applied to the build
    VM?
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用多个提供程序时，如何将配置应用于构建虚拟机？
- en: A. One after the other based on occurrence in the HCL file
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. 按照 HCL 文件中的顺序逐一执行
- en: B. Parallelly
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. 并行
- en: We can use a single set of Packer files to build images with the same configuration
    in multiple cloud environments. (True/False)
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用一组 Packer 文件，在多个云环境中构建具有相同配置的镜像。（正确/错误）
- en: What features does a VM scale set provide? (Choose two)
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虚拟机规模集提供了哪些功能？（选择两个）
- en: A. It helps you horizontally scale VM instances with traffic.
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: A. 它帮助你根据流量水平扩展虚拟机实例。
- en: B. It helps you auto-heal faulty VMs.
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: B. 它帮助你自动修复故障虚拟机。
- en: C. It helps you do canary deployments.
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: C. 它帮助你进行金丝雀发布。
- en: D. None of the above.
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: D. 以上都不是。
- en: Answers
  id: totrans-262
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 答案
- en: 'True'
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: 'True'
  id: totrans-264
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: C
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: C
- en: A, B
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: A、B
- en: A, B
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: A、B
- en: B
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: B
- en: 'True'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确
- en: A, B, C
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: A、B、C
- en: '[PRE43]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Part 4:Delivering Applications with GitOps
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4部分：使用 GitOps 交付应用程序
- en: This section forms the core of the book and elucidates various tools and techniques
    to effectively implement modern DevOps in the cloud. With GitOps as the central
    guiding principle, we will explore various tools and techniques for continuously
    building, testing, securing, and deploying our applications into development,
    testing, and production environments.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 本节是本书的核心内容，阐明了在云中有效实施现代 DevOps 的各种工具和技术。以 GitOps 作为核心指导原则，我们将探讨各种工具和技术，帮助我们不断地构建、测试、保护并将应用程序部署到开发、测试和生产环境中。
- en: 'This part has the following chapters:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分包含以下章节：
- en: '[*Chapter 11*](B19877_11.xhtml#_idTextAnchor1412), *Continuous Integration
    with GitHub Actions and Jenkins*'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B19877_11.xhtml#_idTextAnchor1412)，*使用 GitHub Actions 和 Jenkins 的持续集成*'
- en: '[*Chapter 12*](B19877_12.xhtml#_idTextAnchor1554), *Continuous Deployment/Delivery
    with Argo CD*'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B19877_12.xhtml#_idTextAnchor1554)，*使用 Argo CD 的持续部署/交付*'
- en: '[*Chapter 13*](B19877_13.xhtml#_idTextAnchor1679), *Securing and Testing Your
    CI/CD Pipeline*'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B19877_13.xhtml#_idTextAnchor1679)，*确保和测试你的 CI/CD 流水线*'
