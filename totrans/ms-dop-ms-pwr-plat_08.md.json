["```\n     export GITHUB_TOKEN=\n    gh auth login\n    gh auth switch\n    # move out of the book repoto \"/workspaces\"\n    cd .. gh repo create Kudos --public --clone\n    git clone https://github.com/PacktPublishing/Mastering-DevOps-on-Microsoft-Power-Platform.git\n    ```", "```\n    cp -rT ./Mastering-DevOps-on-Microsoft-Power-Platform/Chapter08/ ./Kudos\n    ```", "```\n    # use the credentials of gh CLI in Git commands\n    gh auth setup-git\n    git config --global user.email \"ouremail@address.com\"\n    git config --global user.name \"Our Name\"\n    git add . git commit -m \"Baseline Kudos app\"\n    git branch -M main\n    git push -u origin main\n    ```", "```\n export GITHUB_TOKEN=\ngh auth login\ngh auth switch\n```", "```\n     pac auth create <st c=\"13331\">pac admin create --name Kudos-Prod --region Europe \\</st>\n     <st c=\"13383\">--currency EUR \\</st>\n    <st c=\"14796\">gh repo create</st> command in our GitHub codespace, the default repository is our Kudos repository. Otherwise, we can use <st c=\"14914\">gh repo set-default owner/repo</st> command to set it as default.\n    ```", "```\n    <st c=\"15494\">az login</st>\n    <st c=\"15503\">az ad group create --display-name $GROUP_NAME --mail-nickname $GROUP_NAME</st> # get the user object id <st c=\"15603\">AADObjectID=$(az ad user show \\</st>\n     <st c=\"15634\">--id $userPrincipalName \\</st>\n     <st c=\"15660\">--query id \\</st>\n     <st c=\"15673\">--output tsv)</st> # add a member to the group <st c=\"15827\">\\.github\\workflows\\share-app.ps1</st>, we can share the Kudos app with the created security group. At the time of writing, there is no PAC CLI command that can be used to share an app with Entra ID groups; that’s why we had to use <st c=\"16079\">Set-AdminPowerAppRoleAssignment -PrincipalType \"Group\" -PrincipalObjectId $GroupID -RoleName CanView -AppName $AppName -EnvironmentName $EnvironmentName</st> <st c=\"16231\">cmdlet</st> here. The security group’s object ID needs to be provided as an input parameter to the script. The GitHub workflows available in the repository also expect this AAD group ID as input.\n    ```", "```\n     pac connection create [--environment] --tenant-id --name --application-id --client-secret\n    ```", "```\n     pac solution create-settings --solution-zip .\\mpa_Kudos_1_0_0_36.zip\n    ```", "```\n    {\n      \"EnvironmentVariables\": [], <st c=\"19942\">\"ConnectionReferences\": [</st> {\n          \"LogicalName\": \"mpa_KudosDataverse\",\n          \"ConnectionId\": \"[Dataverse]\",\n          \"ConnectorId\": \"/providers/Microsoft.PowerApps/apis/shared_commondataserviceforapps\"\n        }, <st c=\"20126\">{</st>\n     <st c=\"20127\">\"LogicalName\": \"mpa_KudosO365\",</st>\n     <st c=\"20159\">\"ConnectionId\": \"[O365]\",</st>\n     <st c=\"20185\">\"ConnectorId\": \"/providers/Microsoft.PowerApps/apis/shared_office365users\"</st>\n     <st c=\"20260\">},</st> {\n          \"LogicalName\": \"mpa_KudosOutlook\",\n          \"ConnectionId\": \"[Outlook]\",\n          \"ConnectorId\": \"/providers/Microsoft.PowerApps/apis/shared_office365\"\n        }]}\n    ```", "```\n https://make.powerapps.com/environments/<<Environment GUID>>/connections/shared_commondataserviceforapps/<st c=\"21877\">\\.github\\workflows\\cd-to-prod.yml</st> contains the default values of these connection IDs, which we can overwrite and commit back to the main branch. With everything in place, we can deploy the Kudos app from the main branch to our production Power Platform environment, by starting this workflow with the gathered connection IDs:\n\t\t\t![Figure 8.8 – The Release to Production workflow with parameters](img/B22208_08_8.jpg)\n\n\t\t\t<st c=\"22548\">Figure 8.8 – The Release to Production workflow with parameters</st>\n\t\t\t<st c=\"22611\">To</st> <st c=\"22615\">store these connection IDs, we can</st> <st c=\"22649\">alternatively</st> <st c=\"22663\">use</st> **<st c=\"22668\">GitHub environments</st>**<st c=\"22687\">. In the case of our developer</st> <st c=\"22717\">branch, we will use a</st> <st c=\"22740\">dedicated GitHub environment to pre-configure these values later in</st> <st c=\"22808\">this chapter.</st>\n\n\t\t\t\t1.  **<st c=\"22821\">Create our branch strategy</st>**<st c=\"22848\">: At the beginning of our development project, we need to design which branching and merging strategy we will use.</st> <st c=\"22964\">In</st> [*<st c=\"22967\">Chapter 5</st>*](B22208_05.xhtml#_idTextAnchor089)<st c=\"22976\">, we learned about the</st> **<st c=\"22999\">GitHub flow</st>**<st c=\"23010\">, and this is what we</st> <st c=\"23031\">are going to create for the Kudos application.</st> <st c=\"23079\">The following figure shows our strategy and the direct mapping between Power Platform environments and</st> <st c=\"23182\">Git branches:</st>\n\n\t\t\t![Figure 8.9 – The branch strategy](img/B22208_08_9.jpg)\n\n\t\t\t<st c=\"23301\">Figure 8.9 – The branch strategy</st>\n\t\t\t<st c=\"23333\">The</st> <st c=\"23337\">arrows</st> <st c=\"23344\">between the Power Platform environments and Git branches represent the code and deployment flows.</st> <st c=\"23443\">A production environment</st> <st c=\"23467\">can handle only</st> `<st c=\"23738\">dev/DEV-US_XXX_Z</st>` <st c=\"23754\">branch represents a short-lived feature branch containing the implementation</st> <st c=\"23832\">of a user story or a</st> <st c=\"23853\">bug fix.</st>\n\n\t\t\t\t1.  `<st c=\"24332\">main</st>` <st c=\"24336\">in the</st> **<st c=\"24344\">Branch name pattern</st>** <st c=\"24363\">field, and we need to select the</st> **<st c=\"24397\">Require a pull request before merging</st>** <st c=\"24434\">checkbox, as shown in the</st> <st c=\"24461\">following figure:</st>\n\n\t\t\t![Figure 8.10 – The branch protection rule for main](img/B22208_08_10.jpg)\n\n\t\t\t<st c=\"26022\">Figure 8.10 – The branch protection rule for main</st>\n\t\t\t<st c=\"26071\">At the</st> <st c=\"26079\">bottom of the page, we need</st> <st c=\"26106\">to click</st> <st c=\"26115\">on the</st> **<st c=\"26123\">Create</st>** <st c=\"26129\">button.</st> <st c=\"26138\">With this setting, we ensure that only pull requests are allowed to our main branch.</st> <st c=\"26223\">Note that, by default,</st> **<st c=\"26246\">Require approvals</st>** <st c=\"26263\">is checked, which means at least someone else should review our pull requests.</st> <st c=\"26343\">Since we cannot assign a pull request to ourselves, if we</st> <st c=\"26401\">work</st> <st c=\"26405\">alone, it is recommended to uncheck</st> **<st c=\"26442\">Require approvals</st>**<st c=\"26459\">. However, it is obviously not best practice to do so in a real-world project.</st> <st c=\"26538\">Besides this setting, we need to define the type of merge that we want to allow developers to do.</st> <st c=\"26636\">It is recommended to use</st> **<st c=\"26661\">squash merging</st>**<st c=\"26675\">, which combines all commits</st> <st c=\"26703\">from the head branch into a single commit in the target branch.</st> <st c=\"26768\">This significantly reduces the commit history, since all changes we commit in our developer branch sequentially will be combined into one commit after a successful pull request to the parent branch.</st> <st c=\"26967\">We can force this type of merge by going to the</st> **<st c=\"27015\">Settings</st>** <st c=\"27023\">menu in GitHub and, under the</st> **<st c=\"27054\">General</st>** <st c=\"27061\">blade, removing every other</st> <st c=\"27090\">merge type:</st>\n\t\t\t![Figure 8.11 – Enforcing squash merging](img/B22208_08_11.jpg)\n\n\t\t\t<st c=\"27759\">Figure 8.11 – Enforcing squash merging</st>\n\t\t\t<st c=\"27797\">Checking</st> <st c=\"27806\">only</st> **<st c=\"27812\">Allow squash merging</st>** <st c=\"27832\">will force</st> <st c=\"27844\">the pull</st> <st c=\"27852\">requests to be squash commits.</st> <st c=\"27884\">The other two options,</st> **<st c=\"27907\">Allow merge commits</st>** <st c=\"27926\">and</st> **<st c=\"27931\">Allow rebase merging</st>**<st c=\"27951\">, will copy the commit history of the child</st> <st c=\"27995\">branches into the main branch, leading to large history nodes in the</st> <st c=\"28064\">commit history.</st>\n\t\t\t<st c=\"28079\">If we encounter any issue in the</st> <st c=\"28113\">previous steps, we can use the following settings to get verbose logging of</st> <st c=\"28189\">the commands.</st>\n\n\t\t\t\t*   `<st c=\"28245\">GH_DEBUG</st>` <st c=\"28253\">environment variable.</st> <st c=\"28276\">If its value is</st> `<st c=\"28292\">1</st>`<st c=\"28293\">, it provides more insights, but if we set this variable to</st> `<st c=\"28353\">api</st>`<st c=\"28356\">, then we will see every REST API call to the</st> <st c=\"28402\">GitHub endpoints:</st>\n\n    ```", "```\n\n    \t\t\t\t*   `<st c=\"28632\">--debug</st>` <st c=\"28639\">flag to the end of every command that we want</st> <st c=\"28686\">to troubleshoot:</st>\n\n    ```", "```\n\n    \t\t\t\t*   **<st c=\"28719\">The PAC CLI</st>**<st c=\"28731\">: At the</st> <st c=\"28741\">time of writing, the PAC CLI</st> <st c=\"28770\">doesn’t offer any flag or environment variable to enrich the verbose logs in the standard output.</st> <st c=\"28868\">If we need to troubleshoot PAC CLI commands, we can</st> <st c=\"28919\">only use the log available under</st> <st c=\"28953\">the</st> <st c=\"28956\">following:</st>\n\n    ```", "```\n\n\t\t\t<st c=\"29108\">Now, we are fully prepared to make some changes to the Kudos application.</st> <st c=\"29183\">Let’s understand the existing GitHub workflows and their roles in the</st> <st c=\"29253\">DevOps processes.</st>\n\t\t\t<st c=\"29270\">Exercise – building CD pipelines and a release train</st>\n\t\t\t<st c=\"29323\">In the GitHub repository, we will find the following prebuilt GitHub workflows to manage the life cycle</st> <st c=\"29427\">of our development project, end</st> <st c=\"29460\">to end:</st>\n\n\t\t\t\t1.  `<st c=\"29525\">.github/workflows/setup-dev-environment.yml</st>`<st c=\"29568\">, this workflow creates a developer branch with the name provided before the workflow execution (the branch name follows the naming rule,</st> `<st c=\"29706\">dev/branch_name</st>`<st c=\"29721\">).</st> <st c=\"29725\">The pipeline spins up a Power Platform developer environment with the same name used for the branch.</st> <st c=\"29826\">We need to add the work account that we use in the Power Platform tenant to create the developer environment on behalf of our account.</st> <st c=\"29961\">At the end of the workflow, we can see</st> <st c=\"29999\">additional steps that grant</st> **<st c=\"30028\">System Administrator rights</st>** <st c=\"30055\">to our work account and to the service principal that we created for the production environment earlier.</st> <st c=\"30161\">Let’s execute this workflow with the</st> <st c=\"30198\">following parameters:</st>\n\n\t\t\t![Figure 8.12 – Workflow inputs of “Setup dev environment”](img/B22208_08_12.jpg)\n\n\t\t\t<st c=\"30366\">Figure 8.12 – Workflow inputs of “Setup dev environment”</st>\n\t\t\t<st c=\"30422\">After a successful run, we will see a new Power Platform developer environment with the name</st> `<st c=\"30516\">DEV-US_XXX_Z</st>` <st c=\"30528\">and a branch with the</st> <st c=\"30551\">name</st> `<st c=\"30556\">dev/DEV-US_XXX_Z</st>`<st c=\"30572\">.</st>\n\n\t\t\t\t1.  `<st c=\"30861\">dev</st>` <st c=\"30864\">prefix.</st> <st c=\"30873\">In our case, it is</st> `<st c=\"30892\">dev/DEV-US_XXX_Z</st>`<st c=\"30908\">. We can create the GitHub environment by opening the</st> `<st c=\"31204\">DATAVERSE_CONNECTION_ID</st>`2.  `<st c=\"31228\">O365_CONNECTION_ID</st>`3.  `<st c=\"31247\">OUTLOOK_CONNECTION_ID</st>`\n\n<st c=\"31269\">We can see how we’ve introduced the variables in the</st> <st c=\"31323\">following screenshot:</st>\n\n\t\t\t![Figure 8.13 – The GitHub environment with connection IDs](img/B22208_08_13.jpg)\n\n\t\t\t<st c=\"31808\">Figure 8.13 – The GitHub environment with connection IDs</st>\n\t\t\t<st c=\"31864\">As a next step, we need to create these three</st> `<st c=\"32003\">KudosSPN</st>`<st c=\"32012\">), and copy the connection IDs from the appropriate URLs into the</st> `<st c=\"32079\">deploymentSettings.json</st>` <st c=\"32102\">file.</st> <st c=\"32109\">Our workflow expects to find this information in the assigned GitHub environment with the matching name.</st> <st c=\"32214\">Let’s execute the</st> *<st c=\"32232\">Import to dev</st>* <st c=\"32245\">workflow located under</st> `<st c=\"32269\">github/workflows/import-to-dev.yml</st>` <st c=\"32303\">from the dev</st> <st c=\"32316\">branch, to import the</st> **<st c=\"32339\">unmanaged solutions</st>** <st c=\"32358\">to the</st> <st c=\"32366\">developer environment:</st>\n\t\t\t![Figure 8.14 – The Import to dev workflow](img/B22208_08_14.jpg)\n\n\t\t\t<st c=\"33124\">Figure 8.14 – The Import to dev workflow</st>\n\t\t\t<st c=\"33164\">We need to select</st> <st c=\"33182\">our recently created developer branch to use its name to find the right environment in the Power</st> <st c=\"33280\">Platform tenant:</st>\n\t\t\t![Figure 8.15 – Executing the workflow on the dev branch](img/B22208_08_15.jpg)\n\n\t\t\t<st c=\"33342\">Figure 8.15 – Executing the workflow on the dev branch</st>\n\t\t\t<st c=\"33396\">When everything is set up right according to the previous steps, we will see the GitHub workflow running during the execution of the job.</st> <st c=\"33535\">The</st> `<st c=\"33539\">import-to-dev</st>` <st c=\"33552\">job will run in the</st> `<st c=\"33573\">dev/DEV-US_XXX_Z</st>` <st c=\"33589\">environment, displaying the GitHub environment name in the job’s rectangular box of the workflow run (</st>`<st c=\"33692\">Import to dev</st>`<st c=\"33706\">), as shown in the</st> <st c=\"33726\">following figure:</st>\n\t\t\t![Figure 8.16 – The GitHub workflow import-to-dev job](img/B22208_08_16.jpg)\n\n\t\t\t<st c=\"33923\">Figure 8.16 – The GitHub workflow import-to-dev job</st>\n\t\t\t<st c=\"33974\">After the successful run, we have only one task</st> <st c=\"34022\">left, which is to turn on the</st> **<st c=\"34053\">Power Automate cloud flow</st>**<st c=\"34078\">,</st> *<st c=\"34080\">Kudos App – Notification email</st>*<st c=\"34110\">, by opening the Kudos solution and viewing the flow under the</st> **<st c=\"34173\">Cloud flows</st>** <st c=\"34184\">solution asset.</st> <st c=\"34201\">We will not see the flows under</st> **<st c=\"34233\">My flows</st>** <st c=\"34241\">because these flows are intentionally not shared</st> <st c=\"34291\">with us.</st>\n\t\t\t<st c=\"34299\">When we examine</st> <st c=\"34315\">the YML file of the workflow in detail, we can see that this pipeline uses a</st> `<st c=\"34606\">deploymentSettings.json</st>` <st c=\"34629\">file with the right connection IDs.</st> <st c=\"34666\">Finally, we execute the</st> `<st c=\"34690\">microsoft/powerplatform-actions/import-solution@v1</st>` <st c=\"34740\">action to import the unmanaged solutions with the right deployment configurations to our Power Platform environment.</st> <st c=\"34858\">We also</st> <st c=\"34865\">import data to the</st> `<st c=\"34899\">Badge</st>`<st c=\"34904\">, with the help of the</st> `<st c=\"34927\">microsoft/powerplatform-actions/import-data@v1</st>` <st c=\"34973\">GitHub action.</st>\n\t\t\t*<st c=\"34988\">The branch name is the glue that ties the Power Platform environment, the Git branch, and the GitHub environment together to help developers easily find their</st>* *<st c=\"35148\">own environments/configurations.</st>*\n\n\t\t\t\t1.  `<st c=\"35238\">\\.github\\workflows\\commit-to-dev.yml</st>`<st c=\"35274\">, this workflow has been built to easily commit the changes made in the Power Platform developer environment back to the developer branch.</st> <st c=\"35413\">We can make changes by going directly</st> <st c=\"35450\">to the Kudos solution in the</st> **<st c=\"35480\">maker portal</st>** <st c=\"35492\">and opening the canvas app, (the Kudos app) for editing.</st> <st c=\"35550\">On the main screen of the applica</st><st c=\"35583\">tion, let’s change the textbox to include the current date, as shown in the</st> <st c=\"35660\">following figure:</st>\n\n\t\t\t![Figure 8.17 – Editing the Kudos App in the developer environment](img/B22208_08_17.jpg)\n\n\t\t\t<st c=\"36216\">Figure 8.17 – Editing the Kudos App in the developer environment</st>\n\t\t\t<st c=\"36280\">We need to save the app</st> <st c=\"36304\">and publish the customizations before executing the</st> *<st c=\"36357\">Commit to dev branch</st>* <st c=\"36377\">GitHub workflow.</st> <st c=\"36395\">If we want to run the app locally in this environment, we also need to share the application within the solution with our account.</st> <st c=\"36526\">The</st> *<st c=\"36530\">Commit to dev branch</st>* <st c=\"36550\">expects no input parameter; we only need to set the branch to our developer branch.</st> <st c=\"36635\">If we started the workflow directly on the main branch, it would fail because of the branch protection rules that are applied.</st> <st c=\"36762\">Under the hood, this workflow exports both solutions as managed and unmanaged (</st>`<st c=\"36841\">microsoft/powerplatform-actions/export-solution@v1</st>`<st c=\"36892\">) and also unpacks them to the right folders in the developer branch (</st>`<st c=\"36963\">microsoft/powerplatform-actions/unpack-solution@v1</st>`<st c=\"37014\">).</st> <st c=\"37018\">Finally, the flow commits the changes to the dev branch.</st> <st c=\"37075\">As we did earlier, we use the branch name to find the</st> **<st c=\"37129\">Power Platform environment URL</st>** <st c=\"37159\">to export the solutions from the right Dataverse instance, with the help of the following Bash</st> <st c=\"37255\">script snippet:</st>\n\n```", "```\n\n\t\t\t<st c=\"37679\">In the final line, we create</st> <st c=\"37708\">an environment variable with the value of the URL to use in the upcoming actions within the GitHub job.</st> <st c=\"37813\">We hand over this URL to other jobs in the workflow by using the</st> `<st c=\"37878\">outputs</st>` <st c=\"37885\">and</st> `<st c=\"37890\">needs</st>` <st c=\"37895\">keywords in the</st> <st c=\"37912\">YML file.</st>\n\n\t\t\t\t1.  `<st c=\"38197\">dev/DEV-US_XXX_Z</st>` <st c=\"38213\">branch to</st> `<st c=\"38224\">main</st>`<st c=\"38228\">. The pull request will compare the two branches and list every change that has been made since the creation of the developer branch.</st> <st c=\"38362\">We can use</st> **<st c=\"38373\">GitHub Copilot</st>** <st c=\"38387\">to generate a summary</st> <st c=\"38409\">of these changes by clicking the Copilot icon on the pull</st> <st c=\"38468\">request page:</st>\n\n\t\t\t![Figure 8.18 – A Copilot-generated pull request summary](img/B22208_08_18.jpg)\n\n\t\t\t<st c=\"38863\">Figure 8.18 – A Copilot-generated pull request summary</st>\n\t\t\t<st c=\"38917\">By clicking the</st> **<st c=\"38934\">Merge</st>** <st c=\"38939\">button, our pull request</st> <st c=\"38964\">will close and the changes will merge</st> <st c=\"39002\">back to the parent branch.</st> <st c=\"39030\">Usually, we delete developer branches after a successful pull request, but this time, let’s keep our dev branch to execute some additional exercises in the</st> <st c=\"39186\">upcoming sections.</st>\n\n\t\t\t\t1.  `<st c=\"39263\">\\.github\\workflows\\cd-to-prod.yml</st>`<st c=\"39296\">, this workflow deploys the latest version of the main branch to the production environment, as we discussed in the previous section.</st> <st c=\"39430\">We can execute this workflow to deploy the latest version of the Kudos app to the</st> <st c=\"39512\">production environment.</st>\n\n\t\t\t<st c=\"39535\">In</st> [*<st c=\"39539\">Chapter 6</st>*](B22208_06.xhtml#_idTextAnchor103)<st c=\"39548\">, we learned about the</st> `<st c=\"39707\">0.0.0.0.</st>` <st c=\"39715\">in Azure DevOps Services during the development phase.</st> <st c=\"39771\">We can apply the same concept in GitHub by introducing a reusable workflow located under</st> `<st c=\"39860\">\\.github\\workflows\\set-version-number.yml</st>`<st c=\"39901\">. This workflow has two parameters; one is the source folder of our solutions, and the other is the version number to be set.</st> <st c=\"40027\">The workflow checks out the repository, searches for the</st> `<st c=\"40084\">Solution.xml</st>` <st c=\"40096\">file under the source folder, and replaces the inline version tags with the version number, provided as an</st> <st c=\"40204\">input parameter:</st>\n\n```", "```\n\n\t\t\t<st c=\"40588\">The final action in the flow commits</st> <st c=\"40625\">back the changes to the branch on which the</st> <st c=\"40670\">workflow runs.</st>\n\t\t\t<st c=\"40684\">We need to add this reusable workflow to the</st> *<st c=\"40730\">Commit to dev branch</st>* <st c=\"40750\">workflow to set the version number of the solutions to</st> `<st c=\"40806\">0.0.0.0</st>`<st c=\"40813\">. Let’s update the workflow in the dev branch (</st>`<st c=\"40860\">dev/DEV-US_XXX_Z</st>`<st c=\"40877\">) with the following lines, directly adding them to the end of</st> <st c=\"40941\">the workflow:</st>\n\n```", "```\n\n\t\t\t<st c=\"41166\">Let’s commit the changes locally and push</st> <st c=\"41208\">them back to the remote repository.</st> <st c=\"41245\">We can work in</st> `<st c=\"41465\">dev/DEV-US_XXX_Z</st>`<st c=\"41482\">) and create</st> <st c=\"41496\">another codespace:</st>\n\t\t\t![Figure 8.19 – A GitHub codespace on the dev branch](img/B22208_08_19.jpg)\n\n\t\t\t<st c=\"42312\">Figure 8.19 – A GitHub codespace on the dev branch</st>\n\t\t\t<st c=\"42362\">After launching the newly created codespace, we can add the workflow snippet (the GitHub job with the name</st> `<st c=\"42470\">set-version-number</st>`<st c=\"42488\">) to the end of the file, as shown in the</st> <st c=\"42531\">following figure:</st>\n\t\t\t![Figure 8.20 – The commit-to-dev.yml file in the GitHub codespace](img/B22208_08_20.jpg)\n\n\t\t\t<st c=\"43595\">Figure 8.20 – The commit-to-dev.yml file in the GitHub codespace</st>\n\t\t\t<st c=\"43659\">After saving the file in the VS Code editor</st> <st c=\"43703\">in the browser, we can navigate to the source control icon on the left menu and commit our changes, by providing a commit message and clicking on the</st> **<st c=\"43854\">Commit</st>** <st c=\"43860\">button:</st>\n\t\t\t![Figure 8.21 – A Git commit in a GitHub codespace](img/B22208_08_21.jpg)\n\n\t\t\t<st c=\"44605\">Figure 8.21 – A Git commit in a GitHub codespace</st>\n\t\t\t<st c=\"44653\">After clicking on the</st> **<st c=\"44676\">Commit</st>** <st c=\"44682\">button, we should not forget to click on</st> **<st c=\"44724\">Sync Changes</st>** <st c=\"44736\">to push back the changes to the</st> <st c=\"44769\">remote origin.</st>\n\t\t\t<st c=\"44783\">To test the GitHub workflow</st> <st c=\"44811\">upon our changes, we can start it on the branch,</st> `<st c=\"44861\">dev/DEV-US_XXX_Z</st>`<st c=\"44877\">, and see how the two solutions and their</st> `<st c=\"44919\">Solution.xml</st>` <st c=\"44931\">files are updated.</st> <st c=\"44951\">Similarly, we can introduce this job to other flows if we plan to maintain a homogenous versioning in</st> <st c=\"45053\">our solutions.</st>\n\t\t\t<st c=\"45067\">Version number – 0.0.0.0</st>\n\t\t\t<st c=\"45092\">If we use the</st> `<st c=\"45107\">0.0.0.0</st>` <st c=\"45114\">version number, then the solutions imported to Power Platform developer environments will also have this version.</st> <st c=\"45229\">This approach is ideal for multiple developers working on the same solution or project, since they will not override the versions by committing their changes back to developer branches and later, through pull requests, to the</st> <st c=\"45455\">main branch.</st>\n\t\t\t<st c=\"45467\">Finally, we can leverage the releases feature of GitHub to publish</st> <st c=\"45534\">our new versions.</st> **<st c=\"45553\">GitHub releases</st>** <st c=\"45568\">offer an easy way to package our software, along with release notes and links to binary files, for other people to use.</st> <st c=\"45689\">We can manage these releases in GitHub workflows; the platform provides a special trigger that we can use to add our solutions to a release, and there</st> <st c=\"45839\">are actions available in the</st> **<st c=\"45869\">GitHub marketplace</st>** <st c=\"45887\">to create releases within workflows.</st> <st c=\"45925\">We will create our release by executing a new GitHub workflow that builds</st> <st c=\"45998\">our solutions, using</st> **<st c=\"46020\">MSBuild</st>**<st c=\"46027\">, creates a deployment package, and publishes the generated artifacts as part of the new</st> <st c=\"46116\">release version.</st>\n\t\t\t<st c=\"46132\">The Kudos application provides</st> `<st c=\"46262\">MSBuild</st>` <st c=\"46269\">and</st> `<st c=\"46274\">dotnet</st>` <st c=\"46280\">CLIs.</st> <st c=\"46287\">We can create these</st> `<st c=\"46307\">.cdsproj files</st>` <st c=\"46321\">at any time by executing the following PAC CLI command in the</st> `<st c=\"46384\">solution</st>` <st c=\"46392\">folder:</st>\n\n```", "```\n\n\t\t\t<st c=\"46468\">This command creates a wrapper around our solution, if empty, and then it will create</st> <st c=\"46555\">an empty solution under the</st> `<st c=\"46583\">src</st>` <st c=\"46586\">folder, into which we can copy our solution files (XML and</st> <st c=\"46646\">JSON files).</st>\n\t\t\t<st c=\"46658\">In</st> [*<st c=\"46662\">Chapter 4</st>*](B22208_04.xhtml#_idTextAnchor074)<st c=\"46671\">, we learned about</st> <st c=\"46689\">deployment packages and the</st> `<st c=\"46923\">.csproj</st>` <st c=\"46930\">file under the</st> `<st c=\"46946\">DeploymentPackage</st>` <st c=\"46963\">folder:</st>\n\n```", "```\n    <st c=\"49098\">proj</st> file contains the references to the <st c=\"49139\">cdsproj</st> files under the <st c=\"49163\">solutions</st> folders. We generate the deployment package with the <st c=\"49226\">dotnet publish -c Release /p:Version=${{inputs.release_version}}</st> command by setting the version of the package to the one provided as the workflow parameter. After having the binaries generated, we upload every build artifact to the GitHub artifact store.\n    ```", "```\n     gh release create ${{inputs.release_version}} --title \"${{inputs.release_title}}\" --generate-notes ${{ env.solution_release_folder}}/*.*\n    ```", "```\n<st c=\"54640\">name: Pull request check</st>\n<st c=\"54665\">on:</st>\n <st c=\"54669\">pull_request:</st>\n <st c=\"54683\">types: [edited, synchronize, opened, reopened]</st>\n <st c=\"54730\">branches: [ \"main\" ]</st> jobs:\n  prcheck:\n    runs-on: ubuntu-latest\n    steps:\n      - name: Check for comments in PR <st c=\"54830\">id: check-comments</st> run: |\n          # every pull request is an issue as well\n          #- we can address them through /issues/ endpoint\n          comments=$(<st c=\"54957\">curl</st> -s -H \"Authorization: token ${{secrets.GITHUB_TOKEN}}\" \\\n             \"<st c=\"55021\">https://api.github.com/repos/${{ github.repository }}/issues/${{ github.event.pull_request.number }}/comments\")</st> if [ $(echo \"$comments\" | jq '. | length') -eq 0 ]; then\n            echo \"There is no comment added to the PR.\" <st c=\"55235\">echo \"no_comments=true\" >> $GITHUB_OUTPUT</st> else\n            echo \"Comments are added to the PR.\" <st c=\"55319\">echo \"no_comments=false\" >> $GITHUB_OUTPUT</st> fi\n        shell: bash\n      - name: Fail if no comments\n        run: |\n          if [[ <st c=\"55418\">\"${{ steps.check-comments.outputs.no_comments }}</st>\" == \"true\" ]]; then\n           echo \"No comments added to the pull request. Failing the build.\" exit 1\n          fi\n        shell: bash\n```", "```\n testSettings:\n  filePath:\n  browserConfigurations:\n  - browser: Chromium\n    device: <st c=\"61059\">screenWidth: 1024</st><st c=\"61076\">screenHeight: 768</st> locale: en-US <st c=\"61109\">recordVideo: true</st><st c=\"61126\">headless: true</st> enablePowerFxOverlay: false\n  timeout: 30000\n```", "```\n export user1Email=\"USEREMAIL\"\nexport user1Password=\"PASSWORD\"\npac test run --test-plan-file ./test/SmokeTestSuite.yaml -env 4d3c1075-FFFF-GGGG-VVVV-40c6f5edd705 --tenant 4ae51f31-XXXX-YYYY-ZZZZ-5ece14d2c081\n```", "```\n - name: Run test <st c=\"62492\">shell: bash</st><st c=\"62503\">run: |</st> set -e <st c=\"62518\">ref=${{ github.ref }}</st> branch=\"${ref#refs/heads/dev/}\"\n       echo \"$branch\"\n       # Get the environment Id <st c=\"62612\">rawOutput=$(pac admin list --name $branch | tail -n 2)</st> environmentId=$(echo $rawOutput | cut -d ' ' -f 2) <st c=\"62718\">export user1Email=\"${{secrets.TESTUSER}}</st>\" <st c=\"62761\">export user1Password=\"${{secrets.TESTUSERPSW}}</st>\" <st c=\"63003\">DEV-US_XXX_Z</st>). Based on the branch name, the workflow finds our developer environment and then calls <st c=\"63106\">pac test run</st> with the appropriate parameters.\n\t\t\t<st c=\"63151\">To avoid feature regression and maintain</st> <st c=\"63192\">the high quality of our solution, we can introduce this step in our</st> *<st c=\"63261\">Commit to dev branch</st>* <st c=\"63281\">GitHub workflow to fail fast and early in the development process.</st> <st c=\"63349\">All we need to do is to append the entire job, called</st> `<st c=\"63403\">test</st>`<st c=\"63407\">, from the</st> `<st c=\"63418\">/.github/workflows/run-test.yml</st>` <st c=\"63449\">as the first job in the workflow, as we want to only allow new commits landing in the branch when our automated</st> <st c=\"63562\">tests pass:</st>\n\t\t\t![Figure 8.25 – The Commit to dev branch with a placeholder for “test” job](img/B22208_08_25.jpg)\n\n\t\t\t<st c=\"64234\">Figure 8.25 – The Commit to dev branch with a placeholder for “test” job</st>\n\t\t\t<st c=\"64306\">Additionally, we can introduce this quality check in our pull request triggered workflow (</st>*<st c=\"64397\">Pull request check</st>*<st c=\"64416\">), in the production workflow (</st>*<st c=\"64448\">Release to Production</st>*<st c=\"64470\">), or even in the release workflow (</st>*<st c=\"64507\">GitHub Release</st>*<st c=\"64522\">) based on our preferences.</st> <st c=\"64551\">Some of these workflows need to be extended, for instance, to be able to spin up new Power Platform environments, deploy the release candidate, and execute the tests.</st> <st c=\"64718\">Only our imagination and project costs can limit our</st> <st c=\"64771\">QA investments.</st>\n\t\t\t<st c=\"64786\">Now, our application is ready</st> <st c=\"64816\">to run in production.</st> <st c=\"64839\">There is only one task left, which is to get real-time insights and telemetry data about our application’s runtime characteristics and behavior.</st> <st c=\"64984\">Let’s discover what monitoring options we have in</st> <st c=\"65034\">Power Platform.</st>\n\t\t\t<st c=\"65049\">Exercise – monitoring the applications</st>\n\t\t\t<st c=\"65088\">After publishing our application</st> <st c=\"65121\">to the production environment, we want to understand how it performs, how users interact with the application, and how far the application is stable and can run without errors.</st> <st c=\"65299\">As</st> <st c=\"65301\">Microsoft Power Platform runs on</st> **<st c=\"65335\">Microsoft Azure</st>**<st c=\"65350\">, it can leverage the existing Azure</st> **<st c=\"65387\">platform-as-a-service</st>** <st c=\"65408\">(</st>**<st c=\"65410\">PaaS</st>**<st c=\"65414\">) services to provide real-time</st> <st c=\"65446\">telemetry data collection and analysis for the Power Platform portfolio – Power Apps, Power Automate, Copilot Studio, Power Pages, and even Dataverse.</st> <st c=\"65598\">Azure’s</st> <st c=\"65605\">PaaS service is</st> **<st c=\"65622\">Azure Application Insights</st>**<st c=\"65648\">, which is</st> <st c=\"65659\">tidily</st> <st c=\"65665\">connected to</st> **<st c=\"65679\">Azure Monitor</st>** <st c=\"65692\">and</st> **<st c=\"65697\">Azure Log Analytics workspaces</st>**<st c=\"65727\">. Azure Application Insights is an</st> **<st c=\"65762\">Application Performance Management</st>** <st c=\"65796\">(</st>**<st c=\"65798\">APM</st>**<st c=\"65801\">) solution that can be used</st> <st c=\"65829\">in live production monitoring scenarios.</st> <st c=\"65871\">Application Insights provides application dashboards, application maps, live metrics, transaction search, availability view, failures view, performance view, monitoring alerts, workbooks, and so on.</st> <st c=\"66070\">With Application Insights, we can also discover the usage patterns of our users, how people interact with the app, and how the churn rate or the conversion rate looks.</st> <st c=\"66238\">It also visualizes the user journey on web applications.</st> <st c=\"66295\">The Application Insights service offers machine learning-based</st> <st c=\"66357\">analysis of telemetry data (called</st> **<st c=\"66393\">Smart Detection</st>**<st c=\"66408\">) to identify anomalies or performance degradation before outages or blackouts occur.</st> <st c=\"66495\">If the built-in detection features are not enough, we can write our own queries to look</st> <st c=\"66582\">for anomalies with the help of</st> **<st c=\"66614\">Kusto Query Language</st>** <st c=\"66634\">(</st>**<st c=\"66636\">KQL</st>**<st c=\"66639\">).</st> <st c=\"66643\">We can introduce our custom alerting and notifications</st> <st c=\"66697\">based on</st> <st c=\"66706\">the</st> <st c=\"66710\">query</st> <st c=\"66717\">results</st> <st c=\"66724\">of KQL scripts that can trigger</st> **<st c=\"66757\">Azure Playbooks</st>**<st c=\"66772\">,</st> **<st c=\"66774\">Azure Logic Apps</st>**<st c=\"66790\">,</st> **<st c=\"66792\">Azure Functions</st>**<st c=\"66807\">,</st> **<st c=\"66809\">Azure EventHub</st>**<st c=\"66823\">, and</st> **<st c=\"66829\">custom Webhooks</st>**<st c=\"66844\">. The custom webhooks can trigger Power Automate cloud flows to react to the anomalies and outriders in the Power Platform.</st> <st c=\"66968\">Last but not least, Application Insights provides SDKs, available</st> <st c=\"67033\">in JavaScript, Java, C#, Node.js, and Python, based on the</st> **<st c=\"67093\">OpenTelemetry framework</st>**<st c=\"67116\">.</st>\n\t\t\t<st c=\"67117\">Since Power Apps are browser-based applications and the web</st> <st c=\"67177\">player that hosts the apps in the browser is based on</st> `<st c=\"67282\">react-native</st>` <st c=\"67294\">in the native mobile apps through</st> **<st c=\"67329\">wrap functionality</st>**<st c=\"67347\">, it is a very straightforward</st> <st c=\"67377\">approach to embrace Application Insights’ capabilities in our low-code/no-code platform.</st> <st c=\"67467\">We can add Application Insights’ endpoint directly to the canvas app – in our case, to the Kudos app.</st> <st c=\"67569\">We just need to edit the app in the developer environment through the Kudos solution and select the</st> **<st c=\"67669\">App</st>** <st c=\"67672\">node in the tree view on the</st> <st c=\"67702\">left side:</st>\n\t\t\t![Figure 8.26 – Application Insights in Power Apps Studio](img/B22208_08_26.jpg)\n\n\t\t\t<st c=\"68566\">Figure 8.26 – Application Insights in Power Apps Studio</st>\n\t\t\t<st c=\"68621\">On the right side, among the properties</st> <st c=\"68661\">of</st> **<st c=\"68665\">App</st>**<st c=\"68668\">, we will find the</st> **<st c=\"68687\">Instrumentation key</st>** <st c=\"68706\">field, and here, we should provide the instrumentation key of our Application Insights instance.</st> <st c=\"68804\">Let’s create an Application Insights instance in our</st> <st c=\"68857\">Azure subscription:</st>\n\n```", "```\n InstrumentationKey=XXXXXXXX-YYYY-YYYY-YYYY-XXXXXXXXXXXX;IngestionEndpoint=https://westeurope-5.in.applicationinsights.azure.com/;LiveEndpoint=https://westeurope.livediagnostics.monitor.azure.com/;ApplicationId=TTTTTTTT-ZZZZ-ZZZZ-ZZZZ-SSSSSSSSSSSS\n```", "```\n If( <st c=\"81186\">IsBlank(LookUp('Environment Variable Values', 'Environment Variable Definition'.'Schema Name' = \"mpa_featureFlagLabel\").Value)</st>,\n    \"Employee Kudos\",\n    If( <st c=\"81336\">LookUp('Environment Variable Values', 'Environment Variable Definition'.'Schema Name' = \"mpa_featureFlagLabel\").Value = \"no\"</st>,\n        \"Employee Kudos\",\n        \"Employee Kudos - April 2024\"\n    )\n)\n```", "```\n newDataverseId=\"${{ github.event.inputs.dataverseConnectionId }}\"\nnewO365Id=\"${{ github.event.inputs.o365IdConnectionId }}\"\nnewOutlookId=\"${{ github.event.inputs.outlookIdConnectionId }}\"\ncat ${{ env.solution_source_folder}}/${{ env.kudos_solution_name }}/deploymentSettings.json | jq --arg dataverseId \"$newDataverseId\" --arg o365Id \"$newO365Id\" --arg outlookId \"$newOutlookId\" '<st c=\"82305\">.ConnectionReferences[]</st> |=\n         if .ConnectionId == \"[Dataverse]\" then .ConnectionId = $dataverseId\n         elif .ConnectionId == \"[O365]\" then .ConnectionId = $o365Id\n         elif .ConnectionId == \"[Outlook]\" then .ConnectionId = $outlookId\n        else . end' > temp.json && mv temp.json ${{ env.solution_source_folder}}/${{ env.kudos_solution_name }}/deploymentSettings.json\n```", "```\n\n```", "```\n\n```"]