<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer031">
			<h1 id="_idParaDest-42" class="chapter-number"><a id="_idTextAnchor134"/>2</h1>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor135"/> Source Code Management with Git and GitOps</h1>
			<p>In the previous chapter, we looked at the core concepts of modern DevOps, had an introduction to the cloud, and got a fair understanding of containers. In this chapter, we will understand source code<a id="_idIndexMarker143"/> management and one of the modern ways of enabling DevOps <span class="No-Break">with </span><span class="No-Break"><strong class="bold">GitOps</strong></span><span class="No-Break">.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>What is source <span class="No-Break">code management?</span></li>
				<li>A crash course <span class="No-Break">on Git</span></li>
				<li>What <span class="No-Break">is GitOps?</span></li>
				<li>The principles <span class="No-Break">of GitOps</span></li>
				<li><span class="No-Break">Why GitOps?</span></li>
				<li>Branching strategies and <span class="No-Break">GitOps workflow</span></li>
				<li>Git <span class="No-Break">versus GitOps</span><a id="_idTextAnchor136"/><a id="_idTextAnchor137"/></li>
			</ul>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor138"/>Technical requirements</h1>
			<p>To follow this chapter, you will need access to a Linux-based command line. If you are using macOS, you can <a id="_idIndexMarker144"/>use the inbuilt Terminal for all tasks. If you’re a Windows user, you must install <strong class="bold">GitBash</strong> from <a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a>. We will cover the installation instructions for this in the <span class="No-Break">following sections.</span></p>
			<p>Now, let’s start by understanding source <span class="No-Break">code management<a id="_idTextAnchor139"/><a id="_idTextAnchor140"/>.</span></p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor141"/>What is source code management?</h1>
			<p>Software development<a id="_idIndexMarker145"/> involves writing code. Code<a id="_idIndexMarker146"/> is the only tangible aspect of the software, allowing the software to function. Therefore, you need to store code somewhere to write and make changes to existing software. There are two kinds of code – <strong class="bold">source code</strong>, which <a id="_idIndexMarker147"/>is written in a high-level language, and <strong class="bold">binaries</strong>, which<a id="_idIndexMarker148"/> are compiled from the source code. Generally, binaries are nothing but functional applications that execute when we run the software, and source code is the human-readable code written to generate the binary, which is why source code is named <span class="No-Break">as such.</span></p>
			<p>A software development team has multiple members writing software features, so they must collaborate on code. They cannot just write code on silos without understanding how the application works. Sometimes, more than one developer works on the same feature, so they need some place to share their code with their peers. Source code is an asset in itself; therefore, we want to store it securely in a central location while still readily providing access to developers without hampering their work. You will also want to track changes and version them as you might want to know what caused a problem and immediately roll them back. You will also need to persist the history of code to understand what changes were made by whom, and you will want to have a mechanism for source code <span class="No-Break">peer reviews.</span></p>
			<p>As you can see, you would want to manage multiple aspects of source code, and therefore you would use a source code management tool to <span class="No-Break">do so.</span></p>
			<p>A source code management tool <a id="_idIndexMarker149"/>helps you manage all aspects of source code. It provides a central location to store your code, version changes and allows multiple developers to collaborate on the same source code. It also keeps a record of all changes through a version history and everything else that we’ve talked about before. Effective source code management practices improve collaboration; enable efficient development workflows; provide version control, repository management, branching <a id="_idIndexMarker150"/>and merging, change tracking, and auditing; and enhance the overall quality and <a id="_idIndexMarker151"/>maintainability <a id="_idIndexMarker152"/>of software projects. Some popular SCM tools <a id="_idIndexMarker153"/>are <strong class="bold">Git</strong>, <strong class="bold">Subversion</strong>, <strong class="bold">Mercurial</strong>, and <strong class="bold">CVS</strong>. However, the<a id="_idIndexMarker154"/> most popular and de facto standard for SCM is Git. So, let's go ahead and learn about it in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor142"/>A crash course on Git</h1>
			<p>Git is the <a id="_idIndexMarker155"/>most popular source code management system available these days, and it has now become mandatory for all developers to learn Git, at least the basic stuff. In this crash course, we will learn about all basic Git operations and build from them in the <span class="No-Break">subsequent chapters.</span></p>
			<p>Git is a distributed version control system. This means that every Git repository is a copy of the original, and you can replicate that to a remote location if needed. In this chapter, we will create and initialize a local Git repository and then push the entire repository to a <span class="No-Break">remote location.</span></p>
			<p>A Git repository<a id="_idIndexMarker156"/> in a remote central location is also known as a <strong class="bold">remote repository</strong>. From<a id="_idIndexMarker157"/> this central repository, all developers sync changes in their local repository, similar to what’s shown in the <span class="No-Break">following diagram:</span></p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/B19877_Figure_2.01.jpg" alt="Figure 2.1 – Git distributed repository model" width="1407" height="686"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Git distributed repository model</p>
			<p>First, let’s install Git locally and initialize a local repository. We will look at a remote <span class="No-Break">repository later.</span></p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor143"/>Installing Git</h2>
			<p>Depending <a id="_idIndexMarker158"/>on your platform and workstation, there are different ways to install Git. To install Git on <strong class="bold">Ubuntu</strong>, run the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
$ sudo apt install -y git-all</pre>			<p>For other OSs and platforms, you can follow the steps at the following <span class="No-Break">link: </span><span class="No-Break">https://git-scm.com/book/en/v2/Getting-Started-Installing-Git</span><span class="No-Break">.</span></p>
			<p>To check if Git has been installed successfully, run the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
$ git --version
git version 2.30.2</pre>			<p>Now, let’s initialize our first <span class="No-Break">Git repository.</span></p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor144"/>Initializing your first Git repository</h2>
			<p>To create a <a id="_idIndexMarker159"/>Git repository, you need to create a directory and run the <strong class="source-inline">git init</strong> command, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
$ mkdir first-git-repo &amp;&amp; cd first-git-repo/
$ git init
Initialized empty Git repository in ~/first-git-repo/.git/</pre>			<p>You are now ready to use your Git repository. You can also see that when you initialized the Git repository, Git created a hidden directory, <strong class="source-inline">.git</strong>, which it uses to keep track of all changes and commits. Whatever changes you make in your repo, Git keeps them as a delta of changes, which it depicts using <strong class="source-inline">+</strong> and <strong class="source-inline">-</strong> signs. We will look at these in detail in the subsequent sections. For now, let’s create a new file within our Git repository and stage it <span class="No-Break">for changes.</span></p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor145"/>Staging code changes</h2>
			<p>Git allows<a id="_idIndexMarker160"/> developers to stage their changes before they commit them. This helps you prepare what you want to commit to the repository. The staging area is a temporary holding area for your changes, and you can add and remove files from the staging area by using the <strong class="source-inline">git add</strong> and <strong class="source-inline">git </strong><span class="No-Break"><strong class="source-inline">restore</strong></span><span class="No-Break"> commands.</span></p>
			<p>Let’s create our first file within the local Git repository and stage <span class="No-Break">the changes:</span></p>
			<pre class="source-code">
$ touch file1</pre>			<p>Alternatively, you can create a blank file in the <span class="No-Break"><strong class="source-inline">first-git-repo</strong></span><span class="No-Break"> directory.</span></p>
			<p>Now, we will check if Git can detect the new file that we’ve created. To do so, we need to run the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
$ git status
On branch master
No commits yet
Untracked files: (use "git add &lt;file&gt;..." to include in what will be committed)
	file1
nothing added to commit but untracked files present (use "git add" to track)</pre>			<p>So, as we can see, Git has detected <strong class="source-inline">file1</strong> and is telling us that it is not tracking the file currently. To allow Git to track the file, let’s run the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
$ git add file1</pre>			<p>Now, let’s run <strong class="source-inline">git status</strong> again to see what <span class="No-Break">has changed:</span></p>
			<pre class="source-code">
$ git status
On branch master
No commits yet
Changes to be committed: (use "git rm --cached &lt;file&gt;..." to unstage)
	new file:   file1</pre>			<p>As we can see, Git now shows <strong class="source-inline">file1</strong> as a new file in the staging area. You can continue making changes, and when you are done, you can commit the changes using the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
$ git commit -m "My first commit"
[master (root-commit) cecfb61] My first commit
 1 file changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 file1</pre>			<p>Git has now <a id="_idIndexMarker161"/>recorded a commit with your changes. Now, let’s look at its status again using the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
$ git status
On branch master
nothing to commit, working tree clean</pre>			<p>Git is now reporting that the working tree is clean, and there is nothing to commit. It also shows that there are no untracked files. Now, let’s change <strong class="source-inline">file1</strong> and add some text <span class="No-Break">to it:</span></p>
			<pre class="source-code">
$ echo "This is first line" &gt;&gt; file1
$ cat file1
This is first line</pre>			<p><strong class="source-inline">file1</strong> now contains the first line. Let’s go ahead and commit <span class="No-Break">this change:</span></p>
			<pre class="source-code">
$ git add file1
$ git commit -m "My second commit"
[master 4c55cf5] My second commit
 1 file changed, 1 insertion(+)</pre>			<p>As we can see, Git is now<a id="_idIndexMarker162"/> reporting that one file has changed, and there is one insertion. Remember when we discussed that Git only tracks the delta changes between commits? That is what is <span class="No-Break">happening here.</span></p>
			<p>In the introduction, we mentioned that Git provides a history of all commits. Let’s look at how we can display <span class="No-Break">this history.</span></p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor146"/>Displaying commit history</h2>
			<p>Git keeps a <a id="_idIndexMarker163"/>history of all commits. To see a list of all commits that you’ve done, you can use the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
$ git log
commit 275d24c62a0e946b8858f562607265c269ec5484 (HEAD -&gt; master)
Author: Gaurav Agarwal &lt;example@gmail.com&gt;
Date:   Wed Apr 19 12:27:13 2023 +0530
    My second commit
commit cecfb61b251f9966f50a4d8bb49742b7af014da4
Author: Gaurav Agarwal &lt; example@gmail.com&gt;
Date:   Wed Apr 19 12:20:02 2023 +0530
    My first commit</pre>			<p>As we can see, Git has displayed the history of both our commits. Notice that Git marks every commit with a commit ID. We can also delve into what changes were made in the commit by using the <strong class="source-inline">git diff &lt;first_commit_id&gt; &lt;second_commit_id&gt;</strong> command, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
$ git diff cecfb61b251f9966f50a4d8bb49742b7af014da4 \
275d24c62a0e946b8858f562607265c269ec5484
diff --git a/file1 b/file1
index e69de29..0cbcf32 100644
--- a/file1
+++ b/file1
@@ -0,0 +1 @@
+This is first line</pre>			<p>The output clearly <a id="_idIndexMarker164"/>shows that the second commit has added <strong class="source-inline">This is first line</strong> <span class="No-Break">within </span><span class="No-Break"><strong class="source-inline">file1</strong></span><span class="No-Break">.</span></p>
			<p>You’ve suddenly realized that you needed to add another line to <strong class="source-inline">file1</strong> and wanted to do so in the same commit. We can do this by amending the commit. We’ll look at this in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor147"/>Amending the last commit</h2>
			<p>It is a best<a id="_idIndexMarker165"/> practice to have a single commit for your changes to a particular feature. This helps you track the changes better and makes it easier for the reviewer to review them. In turn, it is cleaner to visualize and manage. However, committing frequently is also a best practice so that your changes are not lost. Fortunately, Git allows you to add changes to the <span class="No-Break">last commit.</span></p>
			<p>To demonstrate this, let’s change <strong class="source-inline">file1</strong> and add <span class="No-Break">another line:</span></p>
			<pre class="source-code">
$ echo "This is second line" &gt;&gt; file1
$ cat file1
This is first line
This is second line</pre>			<p>Now, let’s add the changes to the previous commit using the <span class="No-Break">following commands:</span></p>
			<pre class="source-code">
$ git add file1
$ git commit --amend</pre>			<p>Once you run this command, Git will show you a prompt, allowing you to amend the commit message if you like. It will look something like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
My second commit
# Please enter the commit message for your changes. Lines
# starting with # will be ignored and an empty message aborts the commit
# Date Wed Apr 19 12:27:13 2023 +0530
# on branch master
# Changes to be commited
#	modified: file1
#</pre>			<p>Save this file (use <strong class="source-inline">ESC:wq</strong> for Vim). This should amend the last commit with the changes. You should get the <span class="No-Break">following output:</span></p>
			<pre class="source-code">
Date: Wed Apr 19 12:27:13 2023 +0530
 1 file changed, 2 insertions(+)</pre>			<p>When Git amends <a id="_idIndexMarker166"/>a commit, you can no longer refer to the previous commit with the same commit ID. Instead, Git generates a separate <strong class="source-inline">SHA-1 id</strong> for the amended commit. So, let’s look at the logs to see this <span class="No-Break">for ourselves:</span></p>
			<pre class="source-code">
$ git log
commit d11c13974b679b1c45c8d718f01c9ef4e96767ab (HEAD -&gt; master)
Author: Gaurav Agarwal &lt;gaurav.agarwal@example.com&gt;
Date:   Wed Apr 19 12:27:13 2023 +0530
    My second commit
commit cecfb61b251f9966f50a4d8bb49742b7af014da4
Author: Gaurav Agarwal &lt; example@gmail.com&gt;
Date:   Wed Apr 19 12:20:02 2023 +0530
    My first commit</pre>			<p>Now, let’s run the <strong class="source-inline">diff</strong> command again and see what it <span class="No-Break">is reporting:</span></p>
			<pre class="source-code">
$ git diff cecfb61b251f9966f50a4d8bb49742b7af014da4 \
d11c13974b679b1c45c8d718f01c9ef4e96767ab
diff --git a/file1 b/file1
index e69de29..655a706 100644
--- a/file1
+++ b/file1
@@ -0,0 +1,2 @@
+This is first line
+This is second line</pre>			<p>The output clearly shows<a id="_idIndexMarker167"/> that the second commit has added <strong class="source-inline">This is first line</strong>, as well as <strong class="source-inline">This is second line</strong>, within <strong class="source-inline">file1</strong>. With that, you’ve successfully amended <span class="No-Break">a commit.</span></p>
			<p>Local repositories<a id="_idIndexMarker168"/> are as good as keeping files on your system. However, since you need to share your code with others and keep it secure from laptop OS crashes, theft, physical damage, and more, you need to push your code into a remote repository. We’ll look at remote repositories in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor148"/>Understanding remote repositories</h2>
			<p><strong class="bold">Remote repositories</strong> are <a id="_idIndexMarker169"/>replicas of the Git repository at a central location for multiple people to access. This allows your developers to work on the same code base simultaneously and provides you with a backup of your code. There are various tools you <a id="_idIndexMarker170"/>can use to <a id="_idIndexMarker171"/>host your remote repositories. Notable ones <a id="_idIndexMarker172"/>include <strong class="bold">GitHub</strong>, <strong class="bold">Bitbucket</strong>, and <strong class="bold">Gerrit</strong>. You can install them on your on-premises or cloud servers or use a <strong class="bold">Software-as-a-Service</strong> (<strong class="bold">SaaS</strong>) platform<a id="_idIndexMarker173"/> to store them online. In this book, we are going to focus <span class="No-Break">on GitHub.</span></p>
			<p>GitHub is <a id="_idIndexMarker174"/>a web-based platform that helps developers collaborate on code. It is based on Git and allows you to host remote Git repositories. It was founded in 2008 and was acquired by Microsoft in 2018. It is one of the most popular open-source SaaS-based Git repository services and contains almost all open-source code <span class="No-Break">available worldwide.</span></p>
			<p>Before we can create our first remote repo, we must go to <a href="https://github.com/signup">https://github.com/signup</a> to create <span class="No-Break">an account.</span></p>
			<p>Once you’ve created an account, we can go ahead and create our first remote <span class="No-Break">Git repository.</span></p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor149"/>Creating a remote Git repository</h2>
			<p>Creating a remote<a id="_idIndexMarker175"/> Git repository is simple on GitHub. Go to <a href="https://github.com/new">https://github.com/new</a>, set <strong class="bold">Repository Name</strong> to <strong class="source-inline">first-git-repo</strong>, keep the rest of the fields as-is, and click the <strong class="bold">Create </strong><span class="No-Break"><strong class="bold">Repository</strong></span><span class="No-Break"> button.</span></p>
			<p>Once you’ve done that, GitHub<a id="_idIndexMarker176"/> will provide you with some steps that you can follow to connect with your remote repository. Before we go into any of that, we want to configure some authentication for our local Git command line to interact with the remote repository. Let’s take <span class="No-Break">a look.</span></p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor150"/>Setting up authentication with the remote Git repository</h2>
			<p>Some of the ways you can <a id="_idIndexMarker177"/>authenticate with your<a id="_idIndexMarker178"/> remote Git repository are <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="bold">HTTPS</strong>: In this mode, Git uses HTTPS<a id="_idIndexMarker179"/> to connect with the remote Git repository. We need to create an HTTPS token within our GitHub account and use this token as a password to authenticate with the remote repository. This process requires you to key in your token every time you authenticate with Git; therefore, it is not a <span class="No-Break">convenient option.</span></li>
				<li><strong class="bold">SSH</strong>: In this mode, Git uses the SSH<a id="_idIndexMarker180"/> protocol to connect with the remote Git repository. While using SSH, we do not need to use a password to authenticate; instead, we must<a id="_idIndexMarker181"/> add the <strong class="bold">public key</strong> of an <strong class="bold">SSH key pair</strong> we can generate from the Linux (or Windows if you’re using<a id="_idIndexMarker182"/> Git Bash) command line to the GitHub account. This process is more secure as well <span class="No-Break">as convenient.</span></li>
			</ul>
			<p>So, let’s set up SSH-based authentication with our remote <span class="No-Break">Git repository.</span></p>
			<p>First, we must generate the SSH key pair within our local system. Go to your Terminal and run the following command to generate an SSH <span class="No-Break">key pair:</span></p>
			<pre class="source-code">
$ ssh-keygen -t rsa
Generating public/private rsa key pair.</pre>			<p>You will be prompted for other details. Keep pressing <em class="italic">Enter</em> until you reach the <span class="No-Break">prompt again.</span></p>
			<p>Once the key pair has been generated, copy the public key present in the <strong class="source-inline">~/.</strong><span class="No-Break"><strong class="source-inline">ssh/id_rsa.pub</strong></span><span class="No-Break"> file.</span></p>
			<p>Then, go to <a href="https://github.com/settings/ssh/new">https://github.com/settings/ssh/new</a>, paste the public key in the <strong class="bold">Key</strong> field, and click the <strong class="bold">Add SSH Key</strong> button. We are now ready to connect with the remote Git repository. Now, let’s look at the configurations we must do on our local repository to connect with the <span class="No-Break">remote repository.</span></p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor151"/>Connecting the local repository to the remote repository</h2>
			<p>You will need to add a <a id="_idIndexMarker183"/>remote entry using the following command to connect with the remote repository from the <span class="No-Break">local repository:</span></p>
			<pre class="source-code">
$ git remote add origin git@github.com:&lt;your-github-username&gt;/first-git-repo.git</pre>			<p>You can also find these details on the <strong class="bold">Quick Setup</strong> page of your <span class="No-Break">GitHub repository.</span></p>
			<p>Now that we’ve set up the connection, let’s look at how we can push our changes to the <span class="No-Break">remote repository.</span></p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor152"/>Pushing changes from the local repository to the remote repository</h2>
			<p>To push the changes from the local repository to the remote repository, use the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
$ git push -u origin master
Enumerating objects: 6, done.
Counting objects: 100% (6/6), done.
Delta compression using up to 12 threads
Compressing objects: 100% (2/2), done.
Writing objects: 100% (6/6), 474 bytes | 474.00 KiB/s, done.
Total 6 (delta 0), reused 0 (delta 0), pack-reused 0
To github.com: &lt;your-github-username&gt;/first-git-repo.git
 * [new branch]      master -&gt; master
Branch 'master' set up to track remote branch 'master' from 'origin'.</pre>			<p>Now, refresh the page on your remote repository. You should see that the code was synced, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/B19877_Figure_2.02.jpg" alt="Figure 2.2 – Code synced in the remote repository" width="940" height="385"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Code synced in the remote repository</p>
			<p>You can also use the inline editor to make further changes to the file using the GitHub web portal. While this is not recommended, we’ll do this to simulate a situation where another developer changed the same file you were <span class="No-Break">working on.</span></p>
			<p>Click on <strong class="bold">file1</strong> and<a id="_idIndexMarker184"/> then click on the <strong class="bold">pencil</strong> icon to edit the file, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/B19877_Figure_2.03.jpg" alt="Figure 2.3 – Editing the file in the remote repository" width="1637" height="468"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Editing the file in the remote repository</p>
			<p>Upon doing this, an editing window will open where you can make changes to the file. Let’s add <strong class="source-inline">This is third line</strong> within the file, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/B19877_Figure_2.04.jpg" alt="Figure 2.4 – Adding a new line" width="803" height="374"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – Adding a new line</p>
			<p>Scroll down – you <a id="_idIndexMarker185"/>should see a <strong class="bold">Commit changes</strong> section, where you can add a commit message field and click on the <strong class="bold">Commit</strong> button, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/B19877_Figure_2.05.jpg" alt="Figure 2.5 – The Commit changes section" width="1641" height="625"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – The Commit changes section</p>
			<p>Once you’ve clicked on that button, you should see the third line, as shown in the <span class="No-Break">following screenshot:</span></p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/B19877_Figure_2.06.jpg" alt="Figure 2.6 – Changes committed remotely" width="946" height="584"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – Changes committed remotely</p>
			<p>At this point, changes have been made to the remote repository, but you have also been working on your <a id="_idIndexMarker186"/>changes. To simulate this, let’s make a change in the local repository as well using the <span class="No-Break">following commands:</span></p>
			<pre class="source-code">
$ echo "This is fourth line" &gt;&gt; file1
$ cat file1
This is first line
This is second line
This is fourth line
$ git add file1
$ git commit -m "Added fourth line"
[master e411e91] Added fourth line
 1 file changed, 1 insertion(+)</pre>			<p>Now that we’ve committed the changes in our local repository, let’s try to push the code to the remote repository using the <span class="No-Break">following commands:</span></p>
			<pre class="source-code">
$ git push
To github.com:&lt;your-github-username&gt;/first-git-repo.git
 ! [rejected]        master -&gt; master (fetch first)
error: failed to push some refs to 'github.com:&lt;your-github-username&gt;/first-git-repo.git'
hint: Updates were rejected because the remote contains work that you do not have locally. 
This is usually caused by another repository pushing to the same ref. You may want to 
first integrate the remote changes.
hint: (e.g., 'git pull ...') before pushing again.
hint: See the 'Note about fast-forwards' in 'git push --help' for details.</pre>			<p>Wait, what<a id="_idIndexMarker187"/> happened? Well, the remote repository rejected the changes as we tried to push changes while someone else made some commits in the remote repository, and our changes are not current. We would need to pull the changes in our local repository first to apply our changes on top of the existing ones in the remote repository. We’ll look at this in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor153"/>Pulling and rebasing your code</h2>
			<p><strong class="bold">Pulling code</strong> involves<a id="_idIndexMarker188"/> downloading up-to-date code from the remote to your local repository. <strong class="bold">Rebasing</strong> means<a id="_idIndexMarker189"/> applying your changes on top of the latest remote commit. It is a best <a id="_idIndexMarker190"/>practice to pull and rebase your changes on top of what already exists in the <span class="No-Break">remote repository.</span></p>
			<p>Let’s do so using the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
$ git pull --rebase
remote: Enumerating objects: 5, done.
remote: Counting objects: 100% (5/5), done.
remote: Compressing objects: 100% (2/2), done.
remote: Total 3 (delta 0), reused 0 (delta 0),pack-reused 0
Unpacking objects: 100% (3/3), 652 bytes | 130.00 KiB/s, done.
From github.com:&lt;your-github-username&gt;/first-git-repo
   d11c139..f5b7620  master     -&gt; origin/master
Auto-merging file1
CONFLICT (content): Merge conflict in file1
error: could not apply e411e91... Added fourth line
Resolve all conflicts manually, mark them as resolved with
"git add/rm &lt;conflicted_files&gt;", then run "git rebase --continue".
You can instead skip this commit: run "git rebase --skip".
To abort and get back to the state before "git rebase", run "git rebase --abort".
Could not apply e411e91... Added fourth line</pre>			<p>Now, we have <a id="_idIndexMarker191"/>another issue: we are unable to rebase our commit as we’ve tried to modify a file that has been modified by someone else. Git wants us to check the file and make appropriate changes <a id="_idIndexMarker192"/>so that the changes are applied correctly. This situation is known as a <strong class="bold">merge conflict</strong>. Git also provides us with the file that contains the <a id="_idIndexMarker193"/>conflict. Let’s open the file with a text editor and make the <span class="No-Break">appropriate changes.</span></p>
			<p>The current file looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
This is first line
This is second line
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
This is third line
=======
This is fourth line
&gt;&gt;&gt;&gt;&gt;&gt;&gt; e411e91 (Added fourth line)</pre>			<p>The portion depicted by <strong class="source-inline">HEAD</strong> is the line in the remote repository and shows the recent changes made remotely. The <strong class="source-inline">e411e91</strong> commit shows the changes that we made locally. Let’s change the file to the following and <span class="No-Break">save it:</span></p>
			<pre class="source-code">
This is first line
This is second line
This is third line
This is fourth line</pre>			<p>Now, let’s add the file to the staging area and continue the rebase using the <span class="No-Break">following commands:</span></p>
			<pre class="source-code">
$ git add file1
$ git rebase --continue
[detached HEAD 17a0242] Added fourth line
 1 file changed, 1 insertion(+)
Successfully rebased and updated refs/heads/master.</pre>			<p>Now that we’ve<a id="_idIndexMarker194"/> rebased the changes, let’s look at the status of the Git repo by running the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
$ git status
On branch master
Your branch is ahead of 'origin/master' by 1 commit.
  (use "git push" to publish your local commits)
nothing to commit, working tree clean</pre>			<p>As we can see, we’ve added a <a id="_idIndexMarker195"/>single commit that we need to push to the remote repository. Let’s do that now using the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
$ git push
Enumerating objects: 5, done.
Counting objects: 100% (5/5), done.
Delta compression using up to 12 threads
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 297 bytes | 148.00 KiB/s, done.
Total 3 (delta 0), reused 0 (delta 0), pack-reused 0
To github.com:&lt;your-github-username&gt;/first-git-repo.git
   f5b7620..17a0242  master -&gt; master</pre>			<p>And this time, the push <span class="No-Break">worked successfully.</span></p>
			<p>In most cases, you would normally need to take a copy of the main code and make changes to it to test new features. You might also want someone to review your changes before they are merged into the main code base. Git allows you to manage that by using Git branches. We’ll look at Git branches in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor154"/>Git branches</h2>
			<p>A <strong class="bold">Git branch</strong> is a <a id="_idIndexMarker196"/>copy of the code base (from where the branch is created) that you can independently modify and work on without affecting the main code base. You will want to create branches while working on new features to ensure that you are not affecting the main branch, which contains reviewed code. Most technology companies normally have several environments where you have code deployed in various stages. For<a id="_idIndexMarker197"/> example, you might have a <strong class="bold">development environment</strong> where you test your features, a <strong class="bold">staging environment</strong> where you<a id="_idIndexMarker198"/> integrate all features and test the complete application, and a <strong class="bold">production environment</strong> where<a id="_idIndexMarker199"/> the application that your end users access resides. So, there would be a possibility that you might have additional environment-specific branches where code deployed on those branches reside. In the following sections of this chapter, we will talk about GitOps, which works on this fundamental principle. For now, let’s look at how we can create and manage <span class="No-Break">Git branches.</span></p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor155"/>Creating and managing Git branches</h2>
			<p>To create a<a id="_idIndexMarker200"/> Git branch, you must be on the branch from where you want to branch your code. As in our example repo, we were working on the master branch. Let’s stay there and create a feature branch out <span class="No-Break">of that.</span></p>
			<p>To create the branch, run the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
$ git branch feature/feature1</pre>			<p>As we can see, the<a id="_idIndexMarker201"/> feature branch has been created. To check what branch we are on now, we can use the <strong class="source-inline">git branch</strong> command. Let’s do <span class="No-Break">that now:</span></p>
			<pre class="source-code">
$ git branch</pre>			<p>And as we see by the <strong class="source-inline">*</strong> sign over the <strong class="source-inline">master</strong> branch, we are still on the <strong class="source-inline">master</strong> branch. The good thing is that it also shows the <strong class="source-inline">feature/feature1</strong> branch in the list. Let’s switch to the feature branch now by using the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
$ git checkout feature/feature1
Switched to branch 'feature/feature1'</pre>			<p>Now, we are on the <strong class="source-inline">feature/feature1</strong> branch. Let’s make some changes to the <strong class="source-inline">feature/feature1</strong> branch and commit it to the <span class="No-Break">local repo:</span></p>
			<pre class="source-code">
$ echo "This is feature 1" &gt;&gt; file1
$ git add file1
$ git commit -m "Feature 1"
[feature/feature1 3fa47e8] Feature 1
 1 file changed, 1 insertion(+)</pre>			<p>As we can see, the code is<a id="_idIndexMarker202"/> now committed to the <strong class="source-inline">feature/feature1</strong> branch. To check the version history, let’s run the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
$ git log
commit 3fa47e8595328eca0bc7d2ae45b3de8d9fd7487c (HEAD -&gt; feature/feature1)
Author: Gaurav Agarwal &lt;gaurav.agarwal@example.com&gt;
Date:   Fri Apr 21 11:13:20 2023 +0530
    Feature 1
commit 17a02424d2b2f945b479ab8ba028f3b535f03575 (origin/master, master)
Author: Gaurav Agarwal &lt;gaurav.agarwal@example.com&gt;
Date:   Wed Apr 19 15:35:56 2023 +0530
    Added fourth line</pre>			<p>As we can<a id="_idIndexMarker203"/> see, the <strong class="source-inline">Feature 1</strong> commit is shown in the Git logs. Now, let’s switch to the <strong class="source-inline">master</strong> branch and run the same <span class="No-Break">command again:</span></p>
			<pre class="source-code">
$ git checkout master
Switched to branch 'master'
Your branch is up to date with 'origin/master'.
$ git log
commit 17a02424d2b2f945b479ab8ba028f3b535f03575 (HEAD -&gt; master, origin/master)
Author: Gaurav Agarwal &lt;gaurav.agarwal@example.com&gt;
Date:   Wed Apr 19 15:35:56 2023 +0530
    Added fourth line
commit f5b7620e522c31821a8659b8857e6fe04c2f2355
Author: Gaurav Agarwal &lt;&lt;your-github-username&gt;@gmail.com&gt;
Date:   Wed Apr 19 15:29:18 2023 +0530
    My third commit</pre>			<p>As we can see here, the <strong class="source-inline">Feature 1</strong> commit changes are absent. This shows that both branches are now isolated (and have now diverged). Now, the changes are locally present and are not in the remote repository yet. To push the changes to the remote repository, we will switch to the <strong class="source-inline">feature/feature1</strong> branch again. Let’s do that with the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
$ git checkout feature/feature1
Switched to branch 'feature/feature1'</pre>			<p>Now that <a id="_idIndexMarker204"/>we’ve switched to the feature branch, let’s push the branch to the remote repository using the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
$ git push -u origin feature/feature1
Enumerating objects: 5, done.
Counting objects: 100% (5/5), done.
Delta compression using up to 12 threads
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 286 bytes | 286.00 KiB/s, done.
Total 3 (delta 1), reused 0 (delta 0), pack-reused 0
remote: Resolving deltas: 100% (1/1), completed with 1 local object.
remote:
remote: Create a pull request for 'feature/feature1' on GitHub by visiting:
remote:      https://github.com/&lt;your-github-username&gt;/first-git-repo/pull/new/feature/feature1
remote:
To github.com:&lt;your-github-username&gt;/first-git-repo.git
 * [new branch]      feature/feature1 -&gt; feature/feature1
Branch 'feature/feature1' set up to track remote branch 'feature/feature1' from 'origin'.</pre>			<p>With that, we’ve successfully pushed the new branch to the remote repository. Assuming the feature is ready, we want the changes to go into the master branch. For that, we would have to raise a pull request. We’ll look at pull requests in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor156"/>Working with pull requests</h2>
			<p>A <strong class="bold">pull request</strong> is a <a id="_idIndexMarker205"/>request for merging a <strong class="bold">source branch</strong> to a <strong class="bold">base branch</strong>. The base branch is the branch where the reviewed code resides. In this case, our base branch is <strong class="source-inline">master</strong>. Pull requests are generally useful for developers to get their code peer reviewed before they merge it with the <em class="italic">fair</em> version of the code. The reviewer generally checks the quality of the code, whether best practices are being followed, and whether coding standards are appropriate. If the reviewer is unhappy, they might want to flag certain sections of the changes and request modifications. There are normally multiple cycles of reviews, changes, and re-reviews. Once the reviewer is happy with the changes, they can approve the pull request, and the requester can merge the code. Let’s take a look at <a id="_idIndexMarker206"/><span class="No-Break">this process:</span></p>
			<ol>
				<li>Let’s try to raise a pull request for merging our code from the <strong class="source-inline">feature/feature1</strong> branch to the <strong class="source-inline">master</strong> branch. To do so, go to your GitHub repo, select <strong class="bold">Pull requests</strong>, and click on the <strong class="bold">New pull request</strong> button, as shown in the <span class="No-Break">following screenshot:</span></li>
			</ol>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="image/B19877_Figure_2.07.jpg" alt="Figure 2.7 – New pull request" width="1670" height="670"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – New pull request</p>
			<ol>
				<li value="2">Keep <strong class="bold">base</strong> set to <strong class="source-inline">master</strong> and, in the <strong class="bold">compare</strong> dropdown, <span class="No-Break">select </span><span class="No-Break"><strong class="source-inline">feature/feature1</strong></span><span class="No-Break">:</span></li>
			</ol>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="image/B19877_Figure_2.08.jpg" alt="Figure 2.8 – Comparing changes" width="1664" height="980"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 – Comparing changes</p>
			<ol>
				<li value="3">As you can<a id="_idIndexMarker207"/> see, it shows you all the changes we’ve made on the <strong class="source-inline">feature/feature1</strong> branch. Click on the <strong class="bold">Create pull request</strong> button to create the pull request. On the next page, stick to the defaults and click on the <strong class="bold">Create pull </strong><span class="No-Break"><strong class="bold">request</strong></span><span class="No-Break"> button:</span></li>
			</ol>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="image/B19877_Figure_2.09.jpg" alt="Figure 2.9 – Pull request created" width="1693" height="1151"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9 – Pull request created</p>
			<ol>
				<li value="4">As you can see, the pull request was created successfully. Here, you can assign a reviewer and get the code reviewed. Once the reviewer approves the code, you can merge the code to the master branch. For now, let’s click on the <strong class="bold">Merge pull request</strong> button, followed by the <strong class="bold">Confirm merge</strong> button, which should merge the <span class="No-Break">pull request.</span></li>
				<li>Now, check if the <strong class="source-inline">master</strong> branch shows the changes within GitHub. If it does, switch to the <strong class="source-inline">master</strong> branch and pull the changes into your local repository. You should <a id="_idIndexMarker208"/>see the changes in your local repository <span class="No-Break">as well.</span></li>
			</ol>
			<p> I leave this to you as <span class="No-Break">an exercise.</span></p>
			<p>This was a crash course on Git to help you get started. Now, let’s move on and understand GitOps, which uses Git as a single source of truth to spin up virtually anything within yo<a id="_idTextAnchor157"/>ur application <span class="No-Break">and infrastructure.</span></p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor158"/>What is GitOps?</h1>
			<p>GitOps is <a id="_idIndexMarker209"/>a method that involves implementing DevOps so that Git forms the single source of truth. Instead of maintaining a long list of scripts and tooling to support this, GitOps focuses on writing declarative code for everything, including the infrastructure, configuration, and application code. This means you can spin anything out of thin air by simply using the Git repository. The idea is that you declare what you need in your Git repository, and there is tooling behind the scenes that ensures the desired state is always maintained in the running application and infrastructure surrounding it. The code to spin up the tooling also resides in Git, and you don’t have anything outside of Git. This means everything, including the tooling, is automated in <span class="No-Break">this process.</span></p>
			<p>While GitOps also enables DevOps within the organization, it primarily focuses on using Git to manage infrastructure provisioning and application software deployments. DevOps is a broad term that contains a set of principles, processes, and tools to enable developers and operations teams to work seamlessly and shorten the development life cycle, with an end goal to deliver better software more quickly using a CI/CD cycle. While GitOps relies heavily on Git and its features and always looks to Git for versioning, finding configuration drift, and only applying deltas, DevOps is, as such, agnostic of any tool and focuses more on the concepts and processes. Therefore, you can implement DevOps without using Git, but you cannot implement<a id="_idIndexMarker210"/> GitOps without Git. Put simply, GitOps implements DevOps, but the reverse may not always <span class="No-Break">be true.</span></p>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor159"/>Why GitOps?</h1>
			<p>GitOps provides us<a id="_idIndexMarker211"/> with the <span class="No-Break">following benefits:</span></p>
			<ul>
				<li><strong class="bold">It deploys better software more quickly</strong>: GitOps offers simplicity in delivering software. You don’t have to worry about what tool you need for the deployment type. Instead, you can commit your changes in Git, and the behind-the-scenes tooling automatically <span class="No-Break">deploys it.</span></li>
				<li><strong class="bold">It provides faster recovery from errors</strong>: If you happen to make an error in deployment (for example, a wrong commit), you can easily roll it back using <strong class="source-inline">git revert</strong> and restore your environment. The idea is that you don’t need to learn anything else apart from Git to do a rollout or <span class="No-Break">a rollback.</span></li>
				<li><strong class="bold">It offers better credential management</strong>: With GitOps, you don’t need to store your credentials in different places for your deployments to work. You simply need to provide the tooling access to your Git repository and the binary repository, and GitOps will take care of the rest. You can keep your environment completely secure by restricting your developers’ access to it and providing them access to <span class="No-Break">Git instead.</span></li>
				<li><strong class="bold">Deployments are self-documenting</strong>: Because everything is kept within Git, which records all commits, the deployments are automatically self-documenting. You can know exactly who deployed what at what time by simply looking at the <span class="No-Break">commit history.</span></li>
				<li><strong class="bold">It promotes shared ownership and knowledge</strong>: As Git forms the single source of truth for all code and configurations within the organization, teams have a single place to understand how things are implemented without ambiguity and dependency on other team members. This helps promote the shared ownership <a id="_idIndexMarker212"/>of the code and knowledge within <span class="No-Break">the team.</span></li>
			</ul>
			<p>Now that we know abo<a id="_idTextAnchor160"/><a id="_idTextAnchor161"/>ut the benefits of GitOps, let’s look at its <span class="No-Break">key <a id="_idTextAnchor162"/>principles.</span></p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor163"/>The principles of GitOps</h1>
			<p>GitOps has the <a id="_idIndexMarker213"/>following <span class="No-Break">key principles:</span></p>
			<ul>
				<li><strong class="bold">It describes the entire system declaratively</strong>: Having declarative code forms the first principle of GitOps. This means that instead of providing instructions on how to build your infrastructure, applying the relevant configuration, and deploying your application, you declare the end state of what you need. This means that your Git repository always maintains a single source of truth. As declarative c<a id="_idTextAnchor164"/>hanges are idempotent, you don’t need to worry about the state of your system as this will eventually become consistent with the code <span class="No-Break">in Git.</span></li>
				<li><strong class="bold">It versions desired system state using Git</strong>: As Git forms an excellent version control system, you don’t need to worry too much about how to roll out and roll back your deployments. A simple Git commit means a new deployment, and a Git revert means a rollback. This means you do not need to worry about anything apart from ensuring that the Git repository reflects what <span class="No-Break">you need.</span></li>
				<li><strong class="bold">It uses tooling to automatically apply approved changes</strong>: As you’ve stored everything within Git, you can then use tooling that looks for changes within the repository and automatically applies them to your environment. You can also have several branches that apply changes to different environments, along with a pull request-based approval and gating process so that only approved changes end up in <span class="No-Break">your environment.</span></li>
				<li><strong class="bold">It uses self-healing agents to alert and correct any divergence</strong>: We have the tooling to automatically apply any changes in Git to the environment. However, we also require self-healing agents to alert us of any divergence from the repository. For example, suppose someone deletes a container manually from the environment but doesn’t remove it from the Git repository. In that scenario, the agent should alert the team and recreate the container to correct the<a id="_idIndexMarker214"/> divergence. This means there is no way to bypass GitOps, and Git remains the single source <span class="No-Break">of truth.</span></li>
			</ul>
			<p>Implementing and living by these principles is simple with modern DevOps tools and techniques, and we will look at practically implementing them later in <em class="italic">Chapters 11</em> and <em class="italic">12</em>. In this chapter, however, we’ll examine their des<a id="_idTextAnchor165"/><a id="_idTextAnchor166"/><a id="_idTextAnchor167"/>ign principles using a branching strategy and <span class="No-Break">GitOps workflow.</span></p>
			<h1 id="_idParaDest-64"><a id="_idTextAnchor168"/>Branching strategies and the GitOps workflow</h1>
			<p>GitOps requires at least two kinds of Git repositories to function: the <strong class="bold">application repository</strong>, which is <a id="_idIndexMarker215"/>from where your buil<a id="_idTextAnchor169"/>ds are triggered, and the <strong class="bold">environment repository</strong>, which <a id="_idIndexMarker216"/>contains all of the infrastructure <a id="_idIndexMarker217"/>and <strong class="bold">configuration as code</strong> (<strong class="bold">CaC</strong>). All deployments are driven from the environment repository, and the changes to the code repository drive the deployments. GitOps follows two primary kinds of deployment <a id="_idIndexMarker218"/>mode<a id="_idTextAnchor170"/><a id="_idTextAnchor171"/>ls: the <strong class="bold">push model</strong> and the <strong class="bold">pull mode<a id="_idTextAnchor172"/>l</strong>. Let’s discuss each <span class="No-Break">of </span><span class="No-Break"><a id="_idIndexMarker219"/></span><span class="No-Break">them<a id="_idTextAnchor173"/>.</span></p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor174"/>The push model</h2>
			<p>The push model<a id="_idIndexMarker220"/> pushes <a id="_idIndexMarker221"/>any changes that occur within your Git repository to the<a id="_idTextAnchor175"/> environment. The following diagram explains this process <span class="No-Break">in detail:</span></p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="image/B19877_Figure_2.010.jpg" alt="Figure 2.10 – The push model" width="1633" height="469"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10 – The push model</p>
			<p>The push model is inherently unaware of the existing configuration and reacts only to changes made to your <a id="_idIndexMarker222"/>Git repositories. Therefore, you will need to set up some form of monitoring to understand whether there are any deviations. Additionally, the push model needs to store all environment credentia<a id="_idTextAnchor176"/>ls w<a id="_idTextAnchor177"/>ithin the tools. This is becau<a id="_idTextAnchor178"/>se it interacts with the<a id="_idIndexMarker223"/> environment<a id="_idIndexMarker224"/> and has to manage the deployments. Typically, we use <strong class="bold">Jenkins</strong>, <strong class="bold">CircleCI</strong>, or <strong class="bold">Travis CI</strong> to implement the push model. While the <a id="_idIndexMarker225"/>push model is not recommend<a id="_idTextAnchor179"/>ed, it beco<a id="_idTextAnchor180"/>mes inevitable in cloud provisioning with <strong class="bold">Terraform</strong>, or <a id="_idIndexMarker226"/>config management with <strong class="bold">Ansible</strong>, as they are<a id="_idTextAnchor181"/><a id="_idTextAnchor182"/> both push-based models. Now,<a id="_idTextAnchor183"/> let’s take a closer look<a id="_idIndexMarker227"/> at the<a id="_idIndexMarker228"/> <span class="No-Break">pull model.</span></p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor184"/>The pull model</h2>
			<p>The pull model <a id="_idIndexMarker229"/>is an <em class="italic">agent-based depl<a id="_idTextAnchor185"/>oyment model</em> (als<a id="_idTextAnchor186"/>o known as an <em class="italic">operator-based deployment model</em>). An <em class="italic">agent</em> (or<em class="italic"> operator</em>) within you<a id="_idTextAnchor187"/>r environment monitors<a id="_idIndexMarker230"/> the Git repository for changes and applies them as and when needed. The operator constantly compares the existing configuration with the configuration in the environment repository and appl<a id="_idTextAnchor188"/>ies changes if required. The following diagram shows this process <span class="No-Break">in detail:</span></p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="image/B19877_Figure_2.011.jpg" alt="Figure 2.11 – The pull model" width="1620" height="455"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.11 – The pull model</p>
			<p>The advantage of the pull model is that it monitors and reacts to environment changes alongside repository changes. This ensures that any changes that do not match the Git repository are reverted from the environment. It also alerts the operations team about anything it could not fix using mail notifications, ticketing tools, or Slack notifications. Because the operator lives within the same environment where the code is deployed, we do not need to store credentials within the tools. Instead, they live securely within the environment. You can also live without storing any credentials at all with tools such as <a id="_idTextAnchor189"/>Kubernetes, where you can <a id="_idIndexMarker231"/>employ <strong class="bold">role-based access control</strong> (<strong class="bold">RBAC</strong>) and service accounts for the operator managing <span class="No-Break">the environment.</span></p>
			<p class="callout-heading">Tip</p>
			<p class="callout">When choosing a GitOps model, the best practice is to check whether you can implement a pull-based model instead of a push-based model. Implement a push-based model only if a pull-based model is not possible. It is also a good idea to implement polling in the push-based model by scheduling something, such as a <strong class="source-inline">cron</strong> job, that will run the push periodically to ensure there is no <span class="No-Break">configuration drift.</span></p>
			<p>We cannot solely<a id="_idTextAnchor190"/> live with one model or the other, so most organizations employ a <strong class="bold">hybrid model</strong> to<a id="_idIndexMarker232"/> run GitOps. This hybrid model combines push and pull models<a id="_idTextAnchor191"/> and focuses on using the pull model. It uses the push model when it cannot use the pull model. Now, let’s u<a id="_idTextAnchor192"/><a id="_idTextAnchor193"/>nderstand how to structure our Git repository so that it can <span class="No-Break">i<a id="_idTextAnchor194"/>mplement GitOps.</span></p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor195"/>Structuring the Git repository</h2>
			<p>To implement GitOps, we require at least<a id="_idIndexMarker233"/> two repositories: the <strong class="bold">application repository and the environment repository</strong>. This does not mean that you cannot combine the two, but for the sake of simplicity, let’s take a look at each of <span class="No-Break">them separately.</span></p>
			<h3>The application repository</h3>
			<p>The application rep<a id="_idTextAnchor196"/>ository <a id="_idIndexMarker234"/>stores the application code. It is a repository in which your <a id="_idIndexMarker235"/>developers can a<a id="_idTextAnchor197"/>ctively develop the product that you run for your business. Typically, your builds result from this application code, and they end up as containers (if we use a container-based approach). Your application repository may or may not have environment-specific branches. Most organizations keep the application repository independent of the environment and focus on building semantic code versions using a branchi<a id="_idTextAnchor198"/>ng strategy<a id="_idTextAnchor199"/>. Now, there are multiple branching strategies available to manage your code, such<a id="_idIndexMarker236"/> as <strong class="bold">Gitflow</strong>, <strong class="bold">GitHub flow</strong>, and any other branching strategy that suits <span class="No-Break">your</span><span class="No-Break"><a id="_idIndexMarker237"/></span><span class="No-Break"> needs.</span></p>
			<p>Gitflow is one<a id="_idIndexMarker238"/> of the most popular branching strategies that organizations use. That said, it is also one of the most complicated ones as it requires several kinds of branches (for instance, master, hotfixes, release branches, develop, and feature branches) and<a id="_idTextAnchor200"/> has a rigid structure. The structure of<a id="_idIndexMarker239"/> Gitflow is shown in the <span class="No-Break">following diagram:</span></p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="image/B19877_Figure_2.012.jpg" alt="Figure 2.12 – Gitflow structure" width="1315" height="1632"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.12 – Gitflow structure</p>
			<p>A <a id="_idIndexMarker240"/>simplified way of doing things is using GitHub flow. It employs fewer branches and is easier to maintain. Typically, it contains a single master branch and many f<a id="_idTextAnchor201"/>eature branches that eventually merge with<a id="_idTextAnchor202"/> the master branch. The master branch always has software that is ready to be deployed to the environments. You tag and version the code in the master branch, pick and deploy it, test it, and then p<a id="_idTextAnchor203"/>romote it to higher environments. The following diagram shows GitHub flow<a id="_idIndexMarker241"/> <span class="No-Break">in detail:</span></p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="image/B19877_Figure_2.013.jpg" alt="Figure 2.13 – GitHub flow" width="1497" height="589"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.13 – GitHub flow</p>
			<p>Note that you are free to create your branching strategy according to your needs and what works <span class="No-Break">for you.</span></p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Choose Gitflow if you have a large team, a vast monolithic repository, and multiple releases running in parallel. Choose GitHub flow if you work for a fast-paced organization that releases updates several times a week and doesn’t use the concept of parallel releases. GitHub flow also typically works for microservices where changes are minor <span class="No-Break">and quick.</span></p>
			<p>Typically, application repositories do not have to worry too much about environments; they can focus more on creati<a id="_idTextAnchor204"/>ng deployable <span class="No-Break">software versions.</span></p>
			<h3>The environment repository</h3>
			<p>T<a id="_idTextAnchor205"/>he <a id="_idIndexMarker242"/>environment repository<a id="_idIndexMarker243"/> stores the<a id="_idTextAnchor206"/> environment-specific configurations needed to run the application code. Therefore, they will typically have <strong class="bold">Infrastructure as Code</strong> (<strong class="bold">IaC</strong>) in <a id="_idIndexMarker244"/>the form of Terraform scripts, CaC in the form of Ansible playbooks, or Kubernetes manifests that typically help deploy the code we’ve built from the <span class="No-Break">application repository.</span></p>
			<p>The environment repository should follow an environment-specific branching strategy where<a id="_idTextAnchor207"/> a branch represents a particular environment. You can have pull request-based <strong class="bold">gating</strong> for these<a id="_idIndexMarker245"/> kinds of scenarios. Typically, you build your <strong class="bold">development environments</strong> from a development branch and then raise a pull request to merge the changes to a staging branch. From the staging branch to production, your code progresses with environments. If you have 10 environments, you might end up with 10 different branches in the environment repository. The following diagram sh<a id="_idTextAnchor208"/>owcases the branching strategy you might want to follow for your <span class="No-Break">environment repository:</span></p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="image/B19877_Figure_2.014.jpg" alt="Figure 2.14 – The environment repository" width="1481" height="815"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.14 – The environment repository</p>
			<p>The<a id="_idTextAnchor209"/> <a id="_idIndexMarker246"/>environment repository aims to act as the single source of truth for your <a id="_idIndexMarker247"/>environments. The configuration you add to the repository is applied directly to <span class="No-Break">your environments.</span></p>
			<p class="callout-heading">Tip</p>
			<p class="callout">While you can combine the environment and application repository into one, the best practice is to keep them separate. GitOps offers a clear separation between the CI and CD processes using the application and environment <span class="No-Break">repositories, respectively.</span></p>
			<p>Now that we’ve covered Git<a id="_idTextAnchor210"/><a id="_idTextAnchor211"/> and GitOps in detail, let’s look at why Git and GitOps are related but <span class="No-Break">different concepts.</span></p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor212"/>Git versus GitOps</h1>
			<p>The following table summarizes the <a id="_idIndexMarker248"/>differences between Git <span class="No-Break">and GitOps:</span></p>
			<table id="table001-2" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style"/>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Git</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">GitOps</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Definition</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Git is a distributed version control system that tracks changes to source code and other files. It allows multiple developers to collaborate and manage code <span class="No-Break">revisions efficiently.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>GitOps is a set of practices and principles that leverage Git as the single source of truth for managing and automating the deployment and operation of infrastructure <span class="No-Break">and applications.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Focus</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Primarily focused on version control and collaboration for <span class="No-Break">source code.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Focused on automating and managing the deployment and operation of infrastructure and applications through Git-based <span class="No-Break">DevOps workflows.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Usage</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Widely used for version control and collaboration in software development projects. Developers use Git to track changes, manage branches, and <span class="No-Break">merge code.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Used for declaratively defining and managing infrastructure and application configurations. Git repositories serve as a central hub for defining desired states and <span class="No-Break">driving automation.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Core <span class="No-Break">Components</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Repositories, branches, commits, and <span class="No-Break">pull requests.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Git repositories, declarative configuration files (such as YAML), Kubernetes manifests, CI/CD pipelines, and deployment tools such as Argo CD <span class="No-Break">or Flux.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Workflow</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Developers clone, modify, commit, and push changes to a remote repository. They collaborate through pull requests and <span class="No-Break">branch merges.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Infrastructure and application configurations are stored in Git repositories. Changes to these configurations trigger automated processes, such as CI/CD pipelines or reconciliation loops, to apply those changes to the <span class="No-Break">target environment.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Benefits</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Enables efficient version control, collaboration, and code management for software <span class="No-Break">development teams.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Promotes infrastructure and application as code, versioning of configurations, and declarative management. It simplifies infrastructure deployment, provides consistency, and enables <span class="No-Break">automated workflows.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Focus Area</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Source <span class="No-Break">code management.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Infrastructure and application deployment <span class="No-Break">and management.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Examples</span></p>
						</td>
						<td class="No-Table-Style">
							<p>GitHub, <span class="No-Break">Bitbucket, GitLab.</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Argo CD, Flux, Jenkins X, <span class="No-Break">Weave Flux.</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>Remember that while <a id="_idIndexMarker249"/>Git is a version control system, GitOps extends this concept by utilizing Git as a central source of truth for infrastructure and application configurations, allowing for automated deployment and management of <span class="No-Break">DevOps workflows.</span></p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor213"/>Summary</h1>
			<p>This chapter covered Git, GitOps, why we need it, its principles, and various GitOps deployments. We also looked at different kinds of repositories that we can create to implement GitOps, along with the branching strategy choices for each <span class="No-Break">of them.</span></p>
			<p>You should now be able to do <span class="No-Break">the following:</span></p>
			<ul>
				<li>Understand what source code management is and how it is necessary for many activities with <span class="No-Break">modern DevOps</span></li>
				<li>Create a Git repository and play around with the <strong class="source-inline">clone</strong>, <strong class="source-inline">add</strong>, <strong class="source-inline">commit</strong>, <strong class="source-inline">push</strong>, <strong class="source-inline">pull</strong>, <strong class="source-inline">branch</strong>, and <span class="No-Break"><strong class="source-inline">checkout</strong></span><span class="No-Break"> commands</span></li>
				<li>Understand what GitOps is and how it fits the modern <span class="No-Break">DevOps context</span></li>
				<li>Understand why we need GitOps and how it achieves <span class="No-Break">modern DevOps</span></li>
				<li>Understand the salient principles <span class="No-Break">of GitOps</span></li>
				<li>Understand how to use an effective branching strategy to implement GitOps based on the org structure and <span class="No-Break">product type</span></li>
			</ul>
			<p>In the next chapter, we will develop a core understanding of containers and look <span class="No-Break">at Docker.</span><a id="_idTextAnchor214"/><a id="_idTextAnchor215"/></p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor216"/>Questions</h1>
			<p>Answer the following questions to test your knowledge of <span class="No-Break">this chapter:</span></p>
			<ol>
				<li>Which of the following is true about Git? (<span class="No-Break">Choose three</span><span class="No-Break">)</span><ol><li> It is a distributed <span class="No-Break">SCM platform</span></li><li> It is a centralized <span class="No-Break">SCM platform</span></li><li> It allows multiple developers <span class="No-Break">to collaborate</span></li><li> It has commits <span class="No-Break">and branches</span></li></ol></li>
				<li>In Git terms, what does Git <span class="No-Break">checkout mean?</span><ol><li>Sync code from remote <span class="No-Break">to local</span></li><li>Switch from one branch <span class="No-Break">to another</span></li><li>Review and approve a <span class="No-Break">pull request</span></li></ol></li>
				<li>In GitOps, what forms a single source <span class="No-Break">of truth</span><ol><li>The <span class="No-Break">Git </span><span class="No-Break">repository</span></li><li>The configuration stored in <span class="No-Break">a datastore</span></li><li>The secret <span class="No-Break">management system</span></li><li>The <span class="No-Break">artifact repository</span></li></ol></li>
				<li>Which of the following options are deployment models for GitOps? (<span class="No-Break">Choose two)</span><ol><li>The <span class="No-Break">push model</span></li><li>The <span class="No-Break">pull model</span></li><li>The <span class="No-Break">staggering model</span></li></ol></li>
				<li>Should you use Gitflow for your <span class="No-Break">environment repository?</span></li>
				<li>For monolithic applications with multiple parallel developments in numerous releases, what is the most suitable Git <span class="No-Break">branching strategy?</span><ol><li><span class="No-Break">Gitflow</span></li><li><span class="No-Break">GitHub flow</span></li><li>Hybrid <span class="No-Break">GitHub flow</span></li></ol></li>
				<li>Which is the recommended deployment model <span class="No-Break">for GitOps?</span><ol><li>The <span class="No-Break">push model</span></li><li>The <span class="No-Break">pull model</span></li><li>The <span class="No-Break">staggering model</span><a id="_idTextAnchor217"/><a id="_idTextAnchor218"/></li></ol></li>
			</ol>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor219"/>Answers</h1>
			<ol>
				<li value="1"><span class="No-Break">A,C,D</span></li>
				<li>B</li>
				<li>A</li>
				<li><span class="No-Break">A,B</span></li>
				<li><span class="No-Break">No</span></li>
				<li>A</li>
				<li>B</li>
			</ol>
		</div>
	</div>
</div>
</body></html>