<html><head></head><body>
		<div id="_idContainer054">
			<h1 id="_idParaDest-223" class="chapter-number"><a id="_idTextAnchor293"/>12</h1>
			<h1 id="_idParaDest-224"><a id="_idTextAnchor294"/>Bolt for Orchestration</h1>
			<p>In this chapter, we will cover <strong class="bold">Bolt </strong>and <a id="_idIndexMarker832"/>Puppet Enterprise’s <strong class="bold">orchestrator</strong>. We will show how Bolt is Puppet’s tool for ad hoc <a id="_idIndexMarker833"/>orchestration, allowing work to be done that does not fit into Puppet’s state-based enforcement model. We will discuss how to configure it to connect to clients with different transport mechanisms and credentials and run simple commands and upload files. Furthermore, we will show how <strong class="bold">tasks </strong>allow<a id="_idIndexMarker834"/> single-action scripts in various languages to be run via Bolt, while <strong class="bold">plans </strong>allow <a id="_idIndexMarker835"/>combinations of tasks to be written using logic and variables in the Puppet or YAML language. The project directory structure will be examined, allowing Bolt content to be stored and shared. This will be compared to how plans and <a id="_idIndexMarker836"/>tasks can be stored in a Puppet module using the <strong class="bold">Puppet Enterprise Cloud Deployment Module </strong>(<strong class="bold">PECDM</strong>) <strong class="bold">Bolt project </strong>as an example. We will then show how Bolt can be extended with plugins to dynamically load information from other sources. We will also show how Bolt can directly be used with Puppet to apply manifest blocks, connect to PuppetDB, and <span class="No-Break">use Hiera.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Exploring and <span class="No-Break">configuring Bolt</span></li>
				<li>Understanding the structure <span class="No-Break">of projects</span></li>
				<li>Introducing tasks <span class="No-Break">and plans</span></li>
				<li><span class="No-Break">Plugins</span></li>
			</ul>
			<h1 id="_idParaDest-225"><a id="_idTextAnchor295"/>Technical requirements</h1>
			<p>Clone the control repo, <strong class="source-inline">controlrepo-chapter12</strong>, from <a href="https://github.com/puppetlabs/control-repo">https://github.com/puppetlabs/control-repo</a> to your GitHub account and update the Puppetfile with the contents <span class="No-Break">of </span><a href="https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch12/Puppetfile"><span class="No-Break">https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch12/Puppetfile</span></a><a href="https://github.com/PacktPublishing/Puppet-7-for-DevOps-Engineering/blob/main/ch12/Puppetfile&#13;"/></p>
			<p>Build a standard cluster with two Unix clients and two Windows clients by downloading the <strong class="source-inline">params.json</strong> file from <a href="https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch12/params.json">https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/blob/main/ch12/params.json</a> and updating it with the location of your control repo and your SSH key for the control repo. Then, run the following command from your <span class="No-Break"><strong class="source-inline">pecdm</strong></span><span class="No-Break"> directory:</span></p>
			<pre class="source-code">
bolt --verbose plan run pecdm::provision --params @params.json</pre>
			<h1 id="_idParaDest-226"><a id="_idTextAnchor296"/>Exploring and configuring Bolt</h1>
			<p>Throughout this book so far, we have focused on Puppet’s strengths as a state-based and idempotent configuration management tool. But there are situations where this approach simply doesn’t fit, such as service restarts as part of troubleshooting or ordering application deployments with vendor-based install scripts. There is any number of tasks that fit into the wider automation effort that are ad hoc and single use; therefore, Bolt was<a id="_idIndexMarker837"/> introduced by Puppet to act as an agentless orchestrator. Bolt is now in its 3.x version, since its release in 2017, and a lot of rapid development has taken place. Over 2022, it stabilized, with far fewer releases and changes to features, but we would strongly advise you to keep Bolt as up to date as possible to avoid <span class="No-Break">any confusion.</span></p>
			<p>Having reviewed the general purpose of Bolt as an ad hoc task runner, the first step is to understand how Bolt can connect to clients with transports <span class="No-Break">and targets.</span></p>
			<h2 id="_idParaDest-227"><a id="_idTextAnchor297"/>Connecting to clients with transports and targets</h2>
			<p>Bolt<a id="_idIndexMarker838"/> is a fully open sourced project available at <a href="https://github.com/puppetlabs/bolt">https://github.com/puppetlabs/bolt</a>, written in <strong class="bold">Ruby </strong>and <a id="_idIndexMarker839"/>installed as a single package with a binary, <strong class="source-inline">bolt</strong>. It connects to devices via one of the various <strong class="bold">transports </strong>it offers, which is the mechanism/protocol that allows it to<a id="_idIndexMarker840"/> establish a connection to multiple platforms, such as virtual machines, network devices, or containers without an agent. The <a id="_idIndexMarker841"/>transports available are <span class="No-Break">as follows.</span></p>
			<p><span class="No-Break">System transports:</span></p>
			<ul>
				<li>Local, which, as would<a id="_idIndexMarker842"/> be expected, just runs commands on a <span class="No-Break">local machine.</span></li>
				<li><strong class="bold">Secure Shell </strong>(<strong class="bold">SSH</strong>), using the <strong class="source-inline">net-ssh</strong> Ruby library or <strong class="source-inline">native ssh</strong>, if selected. Commonly used for <a id="_idIndexMarker843"/>Linux and <span class="No-Break">Unix machines.</span></li>
				<li><strong class="bold">Windows Remote Management </strong>(<strong class="bold">WinRM</strong>) for connecting to Microsoft <span class="No-Break">Windows-based </span><span class="No-Break"><a id="_idIndexMarker844"/></span><span class="No-Break">machines.</span></li>
			</ul>
			<p>Remote, which is used for API- or web-based devices, for example, network devices such <span class="No-Break">as switches.</span></p>
			<p>Puppet <span class="No-Break">Enterprise</span><span class="No-Break"><a id="_idIndexMarker845"/></span><span class="No-Break"> transport:</span></p>
			<ul>
				<li><strong class="bold">Puppet Communication Protocol </strong>(<strong class="bold">PCP</strong>), used with <a id="_idIndexMarker846"/>the Puppet Enterprise orchestrator service, discussed in <a href="B18492_14.xhtml#_idTextAnchor340"><span class="No-Break"><em class="italic">Chapter 14</em></span></a></li>
			</ul>
			<p><span class="No-Break">Container </span><span class="No-Break"><a id="_idIndexMarker847"/></span><span class="No-Break">transports:</span></p>
			<ul>
				<li>Docker, which is an<a id="_idIndexMarker848"/> application container technology developed by <span class="No-Break">Docker Inc</span></li>
				<li><strong class="bold">Pod Manager </strong>(<strong class="bold">Podman</strong>), which is <a id="_idIndexMarker849"/>an application container engine developed by <span class="No-Break">Red Hat</span></li>
				<li><strong class="bold">Linux Container Hypervisor </strong>(<strong class="bold">LXD</strong>), which <a id="_idIndexMarker850"/>is a system container engine that uses <strong class="bold">Linux Containers </strong>(<strong class="bold">LXC</strong>), developed<a id="_idIndexMarker851"/> by <a href="https://linuxcontainers.org">https://linuxcontainers.org</a> and sponsored <span class="No-Break">by</span><span class="No-Break"><a id="_idIndexMarker852"/></span><span class="No-Break"> Canonical</span></li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">Bolt fails to connect to targets from Windows using SSH unless <strong class="source-inline">native-ssh</strong> is set to <strong class="source-inline">true</strong> in the transport settings, as <span class="No-Break">per </span><a href="https://puppet.com/docs/bolt/latest/bolt_known_issues.html#unable-to-authenticate-with-ed25519-keys-over-ssh-transport-on-windows"><span class="No-Break">https://puppet.com/docs/bolt/latest/bolt_known_issues.html#unable-to-authenticate-with-ed25519-keys-over-ssh-transport-on-windows</span></a><span class="No-Break">.</span></p>
			<p>By default, Bolt will use local SSH configuration and at its simplest level can run commands directly on devices that are known in Bolt terminology <a id="_idIndexMarker853"/>as <strong class="bold">targets</strong>. A simple example command is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
bolt command run 'uname' --targets examplehost.example.com</pre>
			<p>Here, the<a id="_idIndexMarker854"/> command is within single quotes and the provided target is a resolvable hostname or an IP address. Bolt also has <strong class="bold">PowerShell cmdlets</strong>, which<a id="_idIndexMarker855"/> provide a more integrated experience for PowerShell users with more flexibility for chaining commands and using structured data for arguments. The same command as previously but as a PowerShell cmdlet would look <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
Invoke-BoltCommand -Command 'uname' -Targets examplehost.example.com</pre>
			<p>This takes the default settings of the SSH transport using the current user and any saved credentials. To make a choice on the command line, a transport choice can be added ahead of the transport name, <strong class="source-inline">&lt;transport_name&gt;://</strong>, multiple targets are listed, separated with commas (<strong class="source-inline">,</strong>) and additional options are set to configure the transport. For example WinRM requires a username, password and the <strong class="source-inline">no-ssl</strong> option set if SSL is not setup for WinRM connections. Take the following <span class="No-Break">example command:</span></p>
			<pre class="source-code">
bolt command run 'systeminfo' --targets winrm:// host1.example.com,winrm://host2.example.com --user windows --password Pupp3tL@b5P0rtl@nd! --no-ssl</pre>
			<p>This command will run <strong class="source-inline">systeminfo</strong> on the <strong class="source-inline">host1.example.com </strong>and <strong class="source-inline">host2.example.com </strong>targets using <strong class="source-inline">winrm</strong> to connect, and the <strong class="source-inline">windows</strong> and <strong class="source-inline">Pupp3tL@b5P0rtl@nd! </strong>credentials with no SSL check. Bolt runs requests concurrently, by default up to 50 at a time. This can be changed using the concurrent <span class="No-Break">argument, </span><span class="No-Break"><strong class="source-inline">--concurrent</strong></span><span class="No-Break">.</span></p>
			<p>A full list of options available to be used with each transport<a id="_idIndexMarker856"/> can be viewed in the <span class="No-Break">documentation: </span><a href="https://puppet.com/docs/bolt/latest/bolt_transports_reference.html"><span class="No-Break">https://puppet.com/docs/bolt/latest/bolt_transports_reference.html</span></a><span class="No-Break">.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Bolt 1.3.6 deprecated the <strong class="source-inline">nodes </strong>flag in favor of <strong class="source-inline">targets </strong>and removed it in <span class="No-Break">Bolt 2.0.0.</span></p>
			<h2 id="_idParaDest-228"><a id="_idTextAnchor298"/>Running ad hoc commands with Bolt</h2>
			<p>In this section, we will show how to<a id="_idIndexMarker857"/> run ad hoc commands with Bolt, using both Windows <a id="_idIndexMarker858"/>PowerShell and Linux Shell command examples. The following table shows how these commands compare across <span class="No-Break">the implementations:</span></p>
			<div>
				<div id="_idContainer053" class="IMG---Figure">
					<img src="image/B18492_12_01.jpg" alt="Figure 12.1 ﻿– PowerShell and Linux Bolt commands"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – PowerShell and Linux Bolt commands</p>
			<p>To run quoted commands, use double quotes or backslashes (<strong class="source-inline">\</strong>) to escape. For example, we could run a search for <strong class="source-inline">lang </strong>in <strong class="source-inline">/etc/locale </strong>with <strong class="source-inline">grep -I 'lang'</strong>. To do this, the following command could be run <span class="No-Break">in PowerShell:</span></p>
			<pre class="source-code">
Invoke-BoltCommand -Command "grep -i 'lang' /etc/locale" -Targets ssh://examplehost.example.com –User centos -PasswordPrompt -RunAs root</pre>
			<p>In this example, the <strong class="source-inline">password-prompt </strong>option would ask for the password securely on the command line rather than directly entering it into the <span class="No-Break">executed command.</span></p>
			<p>To run multiple commands listed in a file, we are not suggesting running a script but a step-by-step set of commands; for multiple targets in a file, the at symbol (<strong class="source-inline">@</strong>) can be used with the filename within quotes (<strong class="source-inline">''</strong>). So, for example, to run a list of commands from a file called <strong class="source-inline">commandlist </strong>on a list of targets in <strong class="source-inline">targetfile</strong>, the following command could <span class="No-Break">be run:</span></p>
			<pre class="source-code">
bolt command run '@commandlist' --targets '@targetfile'</pre>
			<p>For Unix-based systems, to read input from <strong class="source-inline">stdin </strong>for targets or commands, the minus symbol (<strong class="source-inline">-</strong>) can be used in place of a target or command string. So, to take the same <strong class="source-inline">targetfile </strong>and send the output of the <strong class="source-inline">cat </strong>command to the <strong class="source-inline">bolt </strong>command, the following could <span class="No-Break">be run:</span></p>
			<pre class="source-code">
cat targetfile | bolt command run '@commandlist' --targets -</pre>
			<p>To run the <strong class="source-inline">uname </strong>and <strong class="source-inline">date </strong>commands on the <strong class="source-inline">hosts1.example.com </strong>and <strong class="source-inline">host2.example.com </strong>targets, the following could be command could <span class="No-Break">be used:</span></p>
			<pre class="source-code">
echo -e "uname \\ndate" | bolt command run - --targets host1.example.com, host2.example.com</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">Using both a file and <strong class="source-inline">stdin </strong>with a list of commands will result in a single connection to the target to run all <span class="No-Break">the commands.</span></p>
			<p>To run<a id="_idIndexMarker859"/> a script in a file, the <strong class="source-inline">bolt script run </strong>command<a id="_idIndexMarker860"/> or <strong class="source-inline">Invoke-BoltScript -Script </strong>PowerShell cmdlet can be used along with any arguments to be passed at the end of the command. For example, on a Unix host, the following command could be used to run an <strong class="source-inline">install.sh </strong>script on the targets in the <strong class="source-inline">application_clients </strong>file with <strong class="source-inline">10.6 </strong><span class="No-Break"><strong class="source-inline">no-gui </strong></span><span class="No-Break">arguments:</span></p>
			<pre class="source-code">
bolt script run ./scripts/install.sh --targets @application_clients 10.6 no-gui</pre>
			<p>The <strong class="source-inline">arguments </strong>flag can be used to be clearer on the name of the argument for each passed value. Any argument with spaces can be surrounded with quotes (<strong class="source-inline">''</strong>). For example, on a Windows system running the <strong class="source-inline">dotnet-install.ps1 </strong>script on a list of targets on a file with the <strong class="source-inline">-Channel LTS </strong>argument, the command would be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
Invoke-BoltScript -Script dotnet-install.ps1 -Targets @targetsfile '-Channel LTS'</pre>
			<p>In Unix, any script can be executed on a target by including a shebang (<strong class="source-inline">#!</strong>) line at the top of the file specifying the interpreter. For Windows targets, the <strong class="source-inline">.ps1</strong>, <strong class="source-inline">.rb</strong>, and <strong class="source-inline">.pp </strong>files are enabled by default, but further extensions can be enabled in configuration files, which will be discussed in the next section. The scripts can be located  from the <strong class="source-inline">modulepath</strong>, this can be of the form <strong class="source-inline">&lt;modulename&gt;/scripts/install.sh</strong>, a relative path from the root of the <strong class="source-inline">bolt </strong>folder, or as an <span class="No-Break">absolute path.</span></p>
			<p>In Unix systems, Puppet manifest files and sections of Puppet code can be applied to a set of targets with <span class="No-Break">the following:</span></p>
			<pre class="source-code">
bolt apply manifests/exampleapp.pp --targets @targetsfile</pre>
			<p>In PowerShell, this can be achieved with the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
Invoke-BoltApply -Manifest manifests/exampleapp.pp -Targets @targetsfile</pre>
			<p>To apply Puppet code, the following command would ensure that a <strong class="source-inline">/etc/exampleapp </strong>directory exists on the <span class="No-Break">Unix systems:</span></p>
			<pre class="source-code">
bolt apply --execute "file { '/etc/exampleapp: ensure =&gt; present }" --targets servers</pre>
			<p>For PowerShell cmdlets, the command used would be <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
Invoke-BoltApply -Execute "file { '/etc/exampleapp': ensure =&gt; present }" -Targets servers</pre>
			<p>This format <a id="_idIndexMarker861"/>should seem similar to <strong class="source-inline">puppet apply </strong>and <strong class="source-inline">puppet apply -e '&lt;code&gt;'</strong>. Similarly, for code to be applied via Bolt, we must ensure that the code is declared to be included in a catalog and not just defined. When a<a id="_idIndexMarker862"/> class or type is defined, it is available to be used in the catalog but it will not have been added to the catalog. In the previous example, if <strong class="source-inline">exampleapp.pp </strong>contained a class definition with resources, this would result in a warning: <strong class="source-inline">Manifest only contains definitions and will result in no changes on the targets</strong>. The class itself would need to be included for it to be added to the catalog and applied <span class="No-Break">via Bolt.</span></p>
			<p>There are also commands to upload files from your local machine to the target or to download from the targets to your machine. Some simple examples using both the Unix version and the Windows version are shown in the following commands. The first file listed is the source and the second is the target, regardless<a id="_idIndexMarker863"/> of whether you’re uploading <span class="No-Break">or</span><span class="No-Break"><a id="_idIndexMarker864"/></span><span class="No-Break"> downloading:</span></p>
			<pre class="source-code">
bolt file upload /rpms/cowsay.rpm /tmp/ --targets @targets
Send-BoltFile -Source /installer/installer.exe -Destination /users/exampleuser/installer.exe -Targets @targets
bolt file download /etc/exampleapp//logfile.log /var/tmp/logfile.log --targets @targets
Receive-BoltFile -Source /ProgramData/exampleapp/logfile.log\puppet.log -Destination /user/exampleuser/puppet.log -Targets @targets</pre>
			<p>Now, let’s take a look at <span class="No-Break">the output.</span></p>
			<h2 id="_idParaDest-229"><a id="_idTextAnchor299"/>Output and debugging</h2>
			<p>So far, the focus <a id="_idIndexMarker865"/>has been on how to run commands and not the output. Bolt by default logs these commands to the <strong class="source-inline">bolt-debug.log </strong>file in the directory from which the Bolt command was run, as well as<a id="_idIndexMarker866"/> to the console. There are six <span class="No-Break">logging levels:</span></p>
			<ul>
				<li><strong class="source-inline">trace</strong>: The most detailed level of logging, which shows the inner workings <span class="No-Break">of Bolt.</span></li>
				<li><strong class="source-inline">debug</strong>: Information about <span class="No-Break">target-specific steps.</span></li>
				<li><strong class="source-inline">info</strong>: This is high-level logging showing the steps taking place <span class="No-Break">in Bolt.</span></li>
				<li><strong class="source-inline">warn</strong>: Warning about deprecations and other harmful scenarios. This is the default <span class="No-Break">console level.</span></li>
				<li><strong class="source-inline">error</strong>: Error messages experienced during the execution of <span class="No-Break">Bolt commands.</span></li>
				<li><strong class="source-inline">fatal</strong>: Error messages<a id="_idIndexMarker867"/> from Puppet code used <span class="No-Break">with Bolt.</span></li>
			</ul>
			<p>A specific log<a id="_idIndexMarker868"/> level can be chosen using the <strong class="source-inline">--log-level </strong>flag and the output format can be selected using the <strong class="source-inline">format </strong>flag, which can use <strong class="source-inline">human</strong>, <strong class="source-inline">json</strong>, or <strong class="source-inline">rainbow</strong>. The output from a Bolt command running  <strong class="source-inline">uname </strong>on three hosts would look like this <span class="No-Break">in</span><span class="No-Break"><a id="_idIndexMarker869"/></span><span class="No-Break"> JSON:</span></p>
			<pre class="source-code">
{ "items": [
{"target":"host1.example.com","action":"command","object":"uname","status":"success","value":{"stdout":"Linux\n","stderr":"","merged_output":"Linux\n","exit_code":0}}
,
{"target":"host1.example.com","action":"command","object":"uname","status":"success","value":{"stdout":"Linux\n","stderr":"","merged_output":"Linux\n","exit_code":0}}
,
{"target":"host1.example.com","action":"command","object":"uname","status":"success","value":{"stdout":"Linux\n","stderr":"","merged_output":"Linux\n","exit_code":0}}
],
"target_count": 3, "elapsed_time": 2 }</pre>
			<p>In comparison, in <a id="_idIndexMarker870"/>human-readable<a id="_idIndexMarker871"/> format, it would look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
Started on host1.example.com...
Started on host2.example.com...
Started on host3.example.com...
Finished on host1.example.com:
  Linux
Finished on host2.example.com:
  Linux
Finished on host3.example.com:
  Linux
Successful on 3 targets: host1.example.com, host2.example.com, host3.example.com
Ran on 3 targets in 2.89 sec</pre>
			<p>The <strong class="source-inline">rainbow </strong>output looks similar to human-readable format but, as the name suggests, it makes the <span class="No-Break">lines multi-colored.</span></p>
			<p>As part of this output, a <strong class="source-inline">.rerun.json </strong>file will be generated. This will list the targets that were processed during the run, indicating which targets failed and which succeeded. For the next Bolt command, we can use a <strong class="source-inline">--rerun </strong>flag with a value of <strong class="source-inline">success</strong>, <strong class="source-inline">failure</strong>, or <strong class="source-inline">all</strong>. This reads the relevant target section from <strong class="source-inline">.rerun.json </strong>to use targets from the previous run. For example, the following command could be run as a result of an <strong class="source-inline">install </strong>task failing<a id="_idIndexMarker872"/> and choosing to run a cleanup task on <span class="No-Break">all </span><span class="No-Break"><a id="_idIndexMarker873"/></span><span class="No-Break">failures:</span></p>
			<pre class="source-code">
Invoke-BoltTask -Name install_failure_cleanup -Targets @targets.file -Rerun failure</pre>
			<p>There are more options for the commands; the full command reference is available at <a href="https://puppet.com/docs/bolt/latest/bolt_command_reference.html ">https://puppet.com/docs/bolt/latest/bolt_command_reference.html </a>for Unix-based commands and <a href="https://puppet.com/docs/bolt/latest/bolt_cmdlet_reference.html ">https://puppet.com/docs/bolt/latest/bolt_cmdlet_reference.html </a>for <span class="No-Break">PowerShell-based commands.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Bolt has a built-in CLI guide that can be accessed by running <strong class="source-inline">bolt guide </strong>on the Unix or PowerShell <span class="No-Break">command line.</span></p>
			<p>So far, what we have discussed using Bolt for is useful on a very small scale but clearly would work with large numbers of servers and more complex configurations. So, the next area to cover is the project structure and <span class="No-Break">configuration files.</span></p>
			<h1 id="_idParaDest-230"><a id="_idTextAnchor300"/>Understanding the structure of projects</h1>
			<p>A <strong class="bold">Bolt project </strong>is a<a id="_idIndexMarker874"/> simple directory structure providing configuration and data for Bolt to use. Within this structure, Puppet modules from both Forge and private repositories can be stored along with task plans and policies. Bolt identifies a directory as a Bolt project if a <strong class="source-inline">bolt-project.yaml </strong>file exists in it, and this file contains a name key. To create this file, run <strong class="source-inline">bolt project init </strong>for Unix systems or <strong class="source-inline">New-BoltProject </strong>for PowerShell from within a directory in which you wish to add Bolt project files. This will use the name for the project as the name of the directory, but you can override this by running it with a name using the <strong class="source-inline">bolt project init customname </strong>or <strong class="source-inline">New-BoltProject -Name customname </strong>command, for Unix systems and <span class="No-Break">PowerShell, respectively.</span></p>
			<p>This project <a id="_idIndexMarker875"/>name must start with a lowercase letter and can only use lowercase letters, digits, and underscores. This is because Bolt projects are like modules and get loaded into the module path. This is important to note because modules contained within the Bolt project will essentially be overwritten in the module path if the Bolt project has the same name as <span class="No-Break">the module.</span></p>
			<p>In the directory, the <strong class="source-inline">init </strong>command will have created a <strong class="source-inline">bolt-project.yaml</strong>, <strong class="source-inline">inventory.yaml</strong>, and <strong class="source-inline">.</strong><span class="No-Break"><strong class="source-inline">git-ignore </strong></span><span class="No-Break">file.</span></p>
			<p>Now, let’s look at how we can configure a <span class="No-Break">Bolt project.</span></p>
			<h2 id="_idParaDest-231"><a id="_idTextAnchor301"/>Configuring a project</h2>
			<p><strong class="source-inline">bolt-project.yaml </strong>contains<a id="_idIndexMarker876"/> settings to override the default Bolt behavior, a lot of which was discussed in the previous section. The settings to be used with the Bolt command can be set here, as well as project configuration such as paths to configuration files and data. Largely, the defaults for these settings will not need to be changed and the core settings that will be configured include the <strong class="source-inline">modules </strong>attribute, which defines modules to manage in the Bolt project, and the <strong class="source-inline">plans</strong>, <strong class="source-inline">policies</strong>, and <strong class="source-inline">tasks </strong>attributes, which limit the visibility of each item by providing a list that will be visible to project users. A sample <strong class="source-inline">bolt-project.yaml </strong>file containing some modules and choosing plans, policies, and tasks to be publicly visible could look <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
name: packtproject
modules:
- name: puppetlabs-stdlib
- name: puppetlabs-peadm
  version_requirement: 3.9.0
- name: puppetlabs/bolt_shim
- git: https://github.com/binford2k/binford2k-rockstar
  ref: 0.1.0
plans:
- packproject
- peadm::provision
policies:
- packproject::lab
tasks:
- bolt_shim::command</pre>
			<p>The full list of settings can be found <span class="No-Break">at </span><a href="https://puppet.com/docs/bolt/latest/bolt_project_reference.html"><span class="No-Break">https://puppet.com/docs/bolt/latest/bolt_project_reference.html</span></a><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">module </strong>attribute <a id="_idIndexMarker877"/>has multiple ways to be updated. When adding items from Forge, this can be updated via the <strong class="source-inline">bolt module add </strong>Unix command or the <strong class="source-inline">Add-BoltModule </strong>PowerShell cmdlet. For example, in Unix systems, <strong class="source-inline">bolt module add puppetlabs/apt </strong>will update the <strong class="source-inline">modules </strong>parameter to contain <strong class="source-inline">- name:puppetlabs-apt </strong><span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">bolt-project.yaml</strong></span><span class="No-Break">.</span></p>
			<p>Then, the <strong class="source-inline">bolt module install </strong>Unix command or the <strong class="source-inline">Install-BoltModule </strong>PowerShell cmdlet can be used, which will automatically do <span class="No-Break">several things:</span></p>
			<ul>
				<li>Find dependencies on all <span class="No-Break">Forge modules</span></li>
				<li>Find <span class="No-Break">compatible versions</span></li>
				<li>Update <span class="No-Break">the Puppetfile</span></li>
				<li>Install the modules into the <span class="No-Break">Bolt project</span></li>
			</ul>
			<p>The modules can also be added at project creation time using the following command in <span class="No-Break">Unix systems:</span></p>
			<pre class="source-code">
bolt project init example_project --modules puppetlabs-apache,puppetlabs-mysql</pre>
			<p>In PowerShell, this can be done using the <span class="No-Break">following command:</span></p>
			<pre class="source-code">
New-BoltProject -Name example_project -Modules puppetlabs-apache,puppetlabs-mysql</pre>
			<p>If you need modules pinned at a specific version or Git modules added, you will need to add these manually to the Bolt project file and run the <strong class="source-inline">Force </strong>flag with the following Bolt module installation command: <strong class="source-inline">Install-BoltModule -Force </strong>on Windows or <strong class="source-inline">bolt module install --force </strong>on <span class="No-Break">Unix systems.</span></p>
			<p>These modules<a id="_idIndexMarker878"/> allow us to use Puppet code within plans, as well as bring in plans and tasks from modules, which will be shown in detail in the <em class="italic">Introducing tasks and </em><span class="No-Break"><em class="italic">plans </em></span><span class="No-Break">section.</span></p>
			<h2 id="_idParaDest-232"><a id="_idTextAnchor302"/>Configuring transports</h2>
			<p>The <strong class="source-inline">inventory.yaml </strong>file contains <a id="_idIndexMarker879"/>configuration information about targets, creating groups of targets with details about how Bolt connects to them. The inventory contains a top level that includes settings that act as defaults for all targets, group <a id="_idIndexMarker880"/>objects that allow targets to be grouped based on common settings, such as all Windows nodes using certain WinRM settings, and target objects, which are individual settings. For each setting, there are common fields that can <span class="No-Break">be used:</span></p>
			<ul>
				<li><strong class="bold">Alias</strong>: An alias to use instead of<a id="_idIndexMarker881"/> the <strong class="bold">Uniform Resource Identifier </strong>(<strong class="bold">URI</strong>), which can be shorter and more <span class="No-Break">human readable</span></li>
				<li><strong class="bold">Config</strong>: A map of transport configuration options for <span class="No-Break">the target</span></li>
				<li><strong class="bold">Facts</strong>: A map of facts for <span class="No-Break">the target(s)</span></li>
				<li><strong class="bold">Features</strong>: An array of features to be enabled (features will be discussed later in <span class="No-Break">the chapter)</span></li>
				<li><strong class="bold">Name</strong>: Used with groups to give a <span class="No-Break">human-readable name</span></li>
				<li><strong class="bold">Plugin hooks</strong>: A map of <a id="_idIndexMarker882"/>plugin configurations (plugins will be discussed in the <em class="italic">Plugins </em>section of <span class="No-Break">this chapter)</span></li>
				<li><strong class="bold">URI</strong>: A <span class="No-Break">target’s URI</span></li>
				<li><strong class="bold">Vars</strong>: A map <span class="No-Break">of variables</span></li>
			</ul>
			<p>A sample <a id="_idIndexMarker883"/>inventory file <a id="_idIndexMarker884"/>could look <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
config:
  transport: ssh
  ssh:
    host-key-check: false
    run-as: root
    native-ssh: true
    ssh-command: 'ssh'
groups:
  - name: agents
 groups:
  - name: linux_agents
    targets:
      - 20.117.165.119
  -name: windows_agents
    targets:
     - 20.117.165.218
     config:
      winrm:
        user: windowsuser
        password: Pupp3tL@b5P0rtl@nd!
        ssl: false
targets:
  - name: primary:
  - 20.117.166.6</pre>
			<p>This <a id="_idIndexMarker885"/>would provide default settings for SSH transport. It should be noted in this example it was shown how to create groups within groups in any inventory to ease management and settings for groups. In this case, we have an agents group, which contains a <strong class="source-inline">linux_agents </strong>group and a <strong class="source-inline">windows_agents </strong>group. The <strong class="source-inline">windows_agents </strong>group contains WinRM transport configuration. This allows us to run Bolt against all agents but with different transports set. There is then a single target called <strong class="source-inline">Primary </strong>outside<a id="_idIndexMarker886"/> of <span class="No-Break">these groups.</span></p>
			<p>The full <strong class="source-inline">inventory.yaml </strong>configuration documentation is available at <a href="https://puppet.com/docs/bolt/latest/bolt_inventory_reference.html">https://puppet.com/docs/bolt/latest/bolt_inventory_reference.html</a>, while the transport configuration is available <span class="No-Break">at </span><a href="https://puppet.com/docs/bolt/latest/bolt_transports_reference.html"><span class="No-Break">https://puppet.com/docs/bolt/latest/bolt_transports_reference.html</span></a><span class="No-Break">.</span></p>
			<p>To return the contents of the <strong class="source-inline">inventory.yaml </strong>file, the <strong class="source-inline">bolt inventory show </strong>Unix command or the <strong class="source-inline">Get-BoltInventory </strong>PowerShell cmdlet can be used. Specific targets can be viewed with the <span class="No-Break"><strong class="source-inline">targets </strong></span><span class="No-Break">flag.</span></p>
			<p>As was discussed in the previous section, for Windows scripts, additional extensions can be allowed using the inventory file, so in a <strong class="source-inline">config </strong>section, the following could be added to allow <strong class="source-inline">.py </strong>and <strong class="source-inline">.pl </strong>scripts to <span class="No-Break">be run:</span></p>
			<pre class="source-code">
config:
  winrm:
    extensions:
      - .py
      - .pl</pre>
			<p>Having <a id="_idIndexMarker887"/>reviewed how to <a id="_idIndexMarker888"/>configure settings at a project level in Bolt, it is now important to also know how system-level settings can be set in Bolt and also how previous legacy versions of Bolt projects may be <span class="No-Break">configured differently.</span></p>
			<h2 id="_idParaDest-233"><a id="_idTextAnchor303"/>System level and legacy</h2>
			<p>In addition to the project settings, system-level settings<a id="_idIndexMarker889"/> can be set in the <strong class="source-inline">/etc/puppetlabs/bolt/bolt-defaults.yaml </strong>file on Unix-based systems and the <strong class="source-inline">%PROGRAMDATA%\PuppetLabs\bolt\etc\bolt-defaults.yaml </strong>file on Windows systems. User-level settings can be set in <strong class="source-inline">.puppetlabs/etc/bolt/bolt-defaults.yaml </strong>in the user’s <span class="No-Break">home directory.</span></p>
			<p>Bolt will choose which project to use with its commands based on the following order <span class="No-Break">of priority:</span></p>
			<ol>
				<li>The project location set in the <strong class="source-inline">BOLT_PROJECT </strong><span class="No-Break">environment variable</span></li>
				<li>The <strong class="source-inline">project </strong>flag on a Bolt command with the project location set (<strong class="source-inline">--</strong><span class="No-Break"><strong class="source-inline">project /tmp/myproject</strong></span><span class="No-Break">)</span></li>
				<li>By traversing from the current directory up until a <strong class="source-inline">bolt-project.yaml </strong>or <strong class="source-inline">boltdir </strong>directory <span class="No-Break">is found</span></li>
				<li>The <strong class="source-inline">.puppetlabs/bolt/ </strong>folder in the home directory of <span class="No-Break">the user</span></li>
			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">In the Unix environment, Bolt does not load a world-writeable Bolt <span class="No-Break">project directory.</span></p>
			<p>If you want to ship Bolt within an application project but the base Bolt project files would clutter the application, it is possible to embed a Bolt project by creating a <strong class="source-inline">boltdir </strong>directory within the application directory. Bolt could still be run from the parent directory as it would recognize <strong class="source-inline">boltdir </strong>as containing <span class="No-Break">the project.</span></p>
			<p>If you have used older versions of Bolt before 2.36, you will note that projects used to create a single <strong class="source-inline">bolt.yaml </strong>file instead of <strong class="source-inline">bolt-project.yaml </strong>and <strong class="source-inline">inventory.yaml</strong>. Support for v1 <strong class="source-inline">bolt.yaml </strong>projects was removed in v3.0.0 of Bolt. Additionally, Bolt-managed modules changed with the deprecation of manual editing of the Puppetfile in v2.42 and the removal of manual editing in v3.0.0. This also changed the module path from containing the <strong class="source-inline">site-modules </strong>and <strong class="source-inline">site </strong>modules to the modern version of <strong class="source-inline">modules </strong>and <strong class="source-inline">.modules</strong>. Previously, managed modules had existed in <strong class="source-inline">modules </strong>and unmanaged modules in <strong class="source-inline">site </strong>and <strong class="source-inline">site-modules</strong>. This has now been changed to managed modules in <strong class="source-inline">.modules </strong>and unmanaged modules in <strong class="source-inline">modules</strong>. To migrate an old-style Bolt project to the new style, the <strong class="source-inline">bolt project migrate </strong>Unix command or <strong class="source-inline">Update-BoltProject </strong>PowerShell command can be run. As with all automated conversions, ensure your pre-migration configuration is backed up in revision control. The full details of changes made during the migration <a id="_idIndexMarker890"/>process can be found <span class="No-Break">at </span><a href="https://puppet.com/docs/bolt/latest/projects.html#migrate-a-bolt-project"><span class="No-Break">https://puppet.com/docs/bolt/latest/projects.html#migrate-a-bolt-project</span></a><span class="No-Break">.</span></p>
			<p>Having reviewed the structure created for Bolt configuration and target transport, it is now time to look at more structured ways of running Bolt via tasks <span class="No-Break">and plans.</span></p>
			<h1 id="_idParaDest-234"><a id="_idTextAnchor304"/>Introducing tasks and plans</h1>
			<p><strong class="bold">Tasks </strong>and <strong class="bold">plans </strong>are <a id="_idIndexMarker891"/>more forms of<a id="_idIndexMarker892"/> scripts and allow users to manage parameters, logic, and flow between actions. Unlike normal Puppet code, plans and tasks run through the script in sequential order, even for Puppet plans that compile <span class="No-Break">a catalog.</span></p>
			<h2 id="_idParaDest-235"><a id="_idTextAnchor305"/>Creating tasks</h2>
			<p>Tasks are<a id="_idIndexMarker893"/> single-action scripts that can be in any language that will run on a target machine. The key differences between the normal scripts we have run with Bolt previously and a task are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>Tasks are paired with a JSON file to provide metadata such as parameters, which allow them to be shared and reused <span class="No-Break">more easily</span></li>
				<li>Tasks can handle structure/typed input <span class="No-Break">and output</span></li>
				<li>Tasks can handle multiple implementations to make <span class="No-Break">them cross-platform</span></li>
			</ul>
			<p>They can be stored in the task directory of a Bolt project or the task directory in a Puppet module. Task implementations should contain their extension in the name. The name can include digits, underscores, and upper and <span class="No-Break">lowercase letters</span></p>
			<p>When calling these tasks, a namespace is created that is made up of the name of the Bolt project or module containing the task and the task name, except if the task has been named <strong class="source-inline">init</strong>, in which case it will be referred to only by the Bolt project or <span class="No-Break">module name.</span></p>
			<p>For example, the task to install an agent with the <strong class="bold">Puppet Enterprise Administration Module</strong> (<strong class="bold">peadm</strong>) is <span class="No-Break">named </span><span class="No-Break"><strong class="source-inline">peadm::agent_install</strong></span><span class="No-Break">.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The<strong class="source-inline">.json </strong>and <strong class="source-inline">.md </strong>extensions are reserved and cannot be used <span class="No-Break">for tasks.</span></p>
			<p>For Unix shell systems the script part must contain a shebang (<strong class="source-inline">#!</strong>) line at the top of the file specifying <span class="No-Break">the interpreter.</span></p>
			<p>An example of <a id="_idIndexMarker894"/>task implementation is when the PEADM module is used to configure the labs using the following code on Unix systems under the <strong class="source-inline">agent_install.sh </strong><span class="No-Break">task name:</span></p>
			<pre class="source-code">
#!/bin/bash,
set -e
if [ -x "/opt/puppetlabs/bin/puppet" ]; then
echo "ERROR: Puppet agent is already installed. Re-install, re-configuration, or upgrade not supported. Please uninstall the agent before running this task."
exit 1
fi
flags=$(echo $PT_install_flags | sed -e 's/^\["*//' -e 's/"*\]$//' -e 's/", *"/ /g')
curl -k "https://${PT_server}:8140/packages/current/install.bash" | bash -s -- $flags</pre>
			<p>Parameters are passed based on variables starting <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">$PT_</strong></span><span class="No-Break">.</span></p>
			<p>With <a id="_idIndexMarker895"/>PowerShell, which has a built-in argument handler, this can be done without <strong class="source-inline">$PT_ </strong>using the <strong class="source-inline">param </strong>function in a task <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">agent_install.ps1</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
param(
  $install_flags
  $server
)
if (Test-Path "C:\Program Files\Puppet Labs\Puppet\puppet\bin\puppet"){
Write-Host "ERROR: Puppet agent is already installed. Re-install, re-configuration, or upgrade not supported. Please uninstall the agent before running this task."
Exit 1
}
$flags=$install_flags -replace '^\["*','' -replace 's/"*\]$','' -replace '/", *"',' '
[Net.ServicePointManager]::ServerCertificateValidationCallback = {$true}; $webClient = New-Object System.Net.WebClient; $webClient.DownloadFile("https://${server}:8140/packages/current/install.ps1", 'install.ps1'); .\install.ps1 $flags</pre>
			<p>To make these files visible to Bolt commands and allow callers to pass the parameters, a JSON file is written with the same name as the task. For the <strong class="source-inline">agent_install </strong>example, it looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
{
  "description": "Install the Puppet agent from a master",
  "parameters": {
    "server": {
      "type": "String",
      "description": "The resolvable name of the Puppet server to install from"
    },
    "install_flags": {
      "type": "Array[String]",
      "description": "Positional arguments to pass to the shell installer",
      "default": []
    }
  },
  "implementations": [
    {"name": "agent_install.sh", "requirements": ["shell"]},
    {"name": "agent_install.ps1", "requirements": ["powershell"]}
  ]
}</pre>
			<p>The metadata provides a description of the task, which is displayed when listing tasks. In addition, the metadata includes a list of parameters with names that must start with a lowercase letter and only include lowercase letters, underscores, and digits. The parameter type, which may match any Puppet type that can be represented in JSON format, and default values for the parameter can also <span class="No-Break">be specified.</span></p>
			<p>Ensuring the <a id="_idIndexMarker896"/>type is an enum or more specific type, such as an integer within a specified size range, can make the task much more secure, limiting the input and therefore the attack vector. Also, within tasks, you should ensure that the parameters for the implementation you are working on are properly separated and do not allow strings to be called. Precise examples can be seen <span class="No-Break">at </span><a href="https://puppet.com/docs/bolt/latest/writing_tasks.html#secure-coding-practices-for-tasks"><span class="No-Break">https://puppet.com/docs/bolt/latest/writing_tasks.html#secure-coding-practices-for-tasks</span></a><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">implementations </strong>parameter allows us to define what scripts are used in what environments. In this case, ensure the <strong class="source-inline">.sh </strong>implementation is run on the Unix shell and <strong class="source-inline">.ps1 </strong><span class="No-Break">on PowerShell.</span></p>
			<p>With this file in place, the <strong class="source-inline">bolt task show </strong>Unix command or <strong class="source-inline">Get-BoltTask </strong>PowerShell cmdlet will show all modules available in the module path, and specific tasks can be viewed with <strong class="source-inline">bolt task show &lt;name of task&gt; </strong>or <strong class="source-inline">Get-BoltTask –Name &lt;name </strong><span class="No-Break"><strong class="source-inline">of task&gt;</strong></span><span class="No-Break">.</span></p>
			<p>Setting the <strong class="source-inline">private </strong>parameter to <strong class="source-inline">true </strong>prevents the task from being listed and can be useful for hiding tasks that are under development, although as we showed in the <em class="italic">Configuring a project </em>section, the same could be achieved at the Bolt <span class="No-Break">project level.</span></p>
			<p>A parameter can be marked as <strong class="source-inline">sensitive </strong>by setting the parameter value to <strong class="source-inline">true</strong>, and variables can be set to <strong class="source-inline">sensitive </strong>within code to ensure they will be redacted in logs <span class="No-Break">and output.</span></p>
			<p>A <a id="_idIndexMarker897"/>parameter of <strong class="source-inline">supports_noop </strong>in the metadata allows users to pass a <strong class="source-inline">noop </strong>argument to the task and will result in the <strong class="source-inline">_noop </strong>parameter being <strong class="source-inline">true </strong>or <strong class="source-inline">false</strong>. It is then possible to use this parameter in your task code to logically check whether changes should be made or <span class="No-Break">just tested.</span></p>
			<p>If the <strong class="source-inline">remote </strong>parameter is set to <strong class="source-inline">true</strong>, the task will only be able to run on remote transport to prevent tasks from being run on <span class="No-Break">incompatible transports.</span></p>
			<p>For a task with lots of options or that returns a lot of information, it may be better to use structured input and output rather than just <span class="No-Break">simple parameters.</span></p>
			<p>Bolt passes task parameters as a single JSON object on <strong class="source-inline">STDIN</strong>, as well as environment variables by default. These can then be read in as parameters by a Ruby script with the following line: <strong class="source-inline">params = </strong><span class="No-Break"><strong class="source-inline">JSON.parse(STDIN.read)</strong></span><span class="No-Break">.</span></p>
			<p>For complex output, it should be ensured that the task prints a single JSON object to <strong class="source-inline">stdout </strong>in the task. This can be useful if you want to use the result within another task. For example, in Python, the following code snippet would dump the JSON of two value sets to stdout, using <strong class="source-inline">json.dump </strong>to convert the result string into JSON and passing it to the <strong class="source-inline">sys.stdout </strong>method Python uses to print <span class="No-Break">to stdout:</span></p>
			<pre class="source-code">
result = { "example1": "value1 , "example2": "value2" }
json.dump(result, sys.stdout)</pre>
			<p>To return error messages from tasks, an <strong class="source-inline">Error </strong>object can be returned. In structured output, the <strong class="source-inline">_error </strong>key is expected and the <strong class="source-inline">msg </strong>key is available as a human-readable message for the UI, <strong class="source-inline">kind </strong>as the string for script handling, and <strong class="source-inline">details </strong>with structured data about the task failure, such as exit code tails. Take the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
{ "_error": { "msg": "Task exit code 1", "kind": "puppetlabs.tasks/task-error", "details": { "exitcode": 1 } } }</pre>
			<p>If the <strong class="source-inline">_error </strong>key is not present, Bolt generates a generic <span class="No-Break">error instead.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Within a module, <strong class="source-inline">pdk new task &lt;taskname&gt; </strong>can be run to generate a <strong class="source-inline">&lt;taskname&gt;.json </strong>file and a <strong class="source-inline">&lt;taskname&gt;.sh </strong>file in the <span class="No-Break">task folder.</span></p>
			<p>To run <a id="_idIndexMarker898"/>these tasks, the <strong class="source-inline">bolt task run </strong>Unix command or <strong class="source-inline">Invoke-BoltTask </strong>PowerShell cmdlet can be used with the parameters either passed as arguments or using the <strong class="source-inline">@ </strong>symbol via a string of JSON or a filename with the <strong class="source-inline">.json </strong>extension. For example, the first task would install a Puppet agent on targets in the agents group with the server and <strong class="source-inline">install_flags </strong><span class="No-Break">parameters set:</span></p>
			<pre class="source-code">
bolt task run peadm::install_agent --targets agents server=primary.example.com install_flags= ["--puppet-service-ensure","stopped","agent:certname=node.example.com"]</pre>
			<p>The second task would run the <strong class="source-inline">package </strong>task and take a JSON string with the <strong class="source-inline">params </strong>flag to check the status of the <span class="No-Break"><strong class="source-inline">apache2 </strong></span><span class="No-Break">package:</span></p>
			<pre class="source-code">
Invoke-BoltTask -Name package -Targets @targetservers -Params '{action="status";name="apache2"}'</pre>
			<p>Having seen how to create and run tasks, it is now time to review plans, which allow for greater structure, logic,and flow to be applied in managing tasks and the ability to use <span class="No-Break">Puppet code.</span></p>
			<h2 id="_idParaDest-236"><a id="_idTextAnchor306"/>Creating Puppet plans</h2>
			<p>Plans <a id="_idIndexMarker899"/>are written <a id="_idIndexMarker900"/>in Puppet code or YAML and allow multiple tasks and commands to be brought together and to apply logic and control of flow and data <span class="No-Break">between them.</span></p>
			<p>A Puppet plan is written in a manifest and in a similar format to a Puppet class. It starts with the <strong class="source-inline">plan </strong>keyword, then the name of the plan, attributes within brackets <strong class="source-inline">()</strong>, and code between curly braces <strong class="source-inline">{}</strong>. So, for example, a sample plan in a sample project contained in the plan directory would look <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
plan exampleproject::exampleplan(
  TargetSpec $nodes,
  Enum ['true', 'false'] $manage_user,
) {
  &lt;code&gt;
}</pre>
			<p>Plans are named similarly to tasks, with the first segment the name of the module or project and the second segment and all following segments named with lowercase letters, digits, <span class="No-Break">and underscores.</span></p>
			<p>They must not use a reserved word or have the same as a Puppet <span class="No-Break">data type.</span></p>
			<p>The <strong class="source-inline">init.pp </strong>class, as with tasks and modules, is different. It would skip the need for the task to be named directly. However, it can only be used at the base level but not in <span class="No-Break">any subdirectory.</span></p>
			<p>To create a new plan, the following commands can be used for Unix systems and <span class="No-Break">PowerShell, respectively:</span></p>
			<pre class="source-code">
bolt plan new &lt;PLAN NAME&gt; --pp
New-BoltPlan -Name &lt;PLAN NAME&gt; -Pp</pre>
			<p>Having reviewed how to create a plan, we will now see how plans receive their target and transport information via the <span class="No-Break"><strong class="source-inline">TargetSpec </strong></span><span class="No-Break">type.</span></p>
			<h2 id="_idParaDest-237"><a id="_idTextAnchor307"/>Constructing targets</h2>
			<p>In <a id="_idIndexMarker901"/>addition to the normal attribute data types, plans use the <strong class="source-inline">TargetSpec </strong>type, which allows for strings exactly like were used with Bolt command targets in the <em class="italic">Connecting to clients with transports and targets </em>section, such as <strong class="source-inline">ssh://examplehost.com</strong>, arrays of <strong class="source-inline">Target </strong>types, and recursively, an array of <span class="No-Break"><strong class="source-inline">TargetSpec </strong></span><span class="No-Break">types.</span></p>
			<p>The <strong class="source-inline">Target </strong>type represents a target and its specific connections in such a way that they can be added to an <span class="No-Break">inventory file.</span></p>
			<p>Within a plan, the <strong class="source-inline">get_targets </strong>function can be used to return targets from a <strong class="source-inline">TargetSpec</strong>. The following is a simple example of how this <span class="No-Break">is used:</span></p>
			<pre class="source-code">
plan restart_apache_servers(
TargetSpec $apache_servers,
){
 get_targets($apache_servers).each |Target $apache_server | {
 run_task('apache', $target_node, 'action' =&gt; 'reload')
 }
}</pre>
			<p>This plan takes a <strong class="source-inline">TargetSpec </strong>object of <strong class="source-inline">apache_servers</strong>, which is passed to the <strong class="source-inline">get_targets </strong>function. The Apache <strong class="source-inline">reload </strong>task is then run on each individual target server, with the <strong class="source-inline">action </strong>parameter set <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">reload</strong></span><span class="No-Break">.</span></p>
			<p>Target objects can also be constructed and changed within a plan manifest using functions beginning with <strong class="source-inline">set_ </strong>or <strong class="source-inline">add_ </strong>for the various parts of the inventory config, such as the <strong class="source-inline">set_config</strong>, <strong class="source-inline">set_var</strong>, <strong class="source-inline">add_facts</strong>, and <strong class="source-inline">add_to_group </strong>functions. For example, a new target could be assembled <span class="No-Break">like so:</span></p>
			<pre class="source-code">
$example_server = Target.new('name'; =&gt; 'exampleserver')
$example_server.set_config('transport', 'ssh')
$example_server.set_config(['ssh', 'password', 's3cur3!')
$example_server.add_facts({'application' =&gt; 'example'})</pre>
			<p>It is possible to access parts of the target, such as <strong class="source-inline">$example_server.config['ssh']</strong>, but the targets will only last in memory for as long as the<a id="_idIndexMarker902"/> plan <span class="No-Break">is running.</span></p>
			<p>Now that we understand how to connect to clients using plans, we will show how functions can be used in the Puppet code block of a plan to use features of Bolt and the Puppet <span class="No-Break">core language.</span></p>
			<h2 id="_idParaDest-238"><a id="_idTextAnchor308"/>Using plan functions</h2>
			<p>As was <a id="_idIndexMarker903"/>shown in the <em class="italic">Constructing targets </em>section, using <strong class="source-inline">run_task</strong>, Bolt plan functions can be used within the Puppet code block itself, many of which are the same types of commands that were run directly in Bolt, such as <strong class="source-inline">run_command</strong>, <strong class="source-inline">run_script</strong>, and <strong class="source-inline">run_task</strong>. The full list is available <span class="No-Break">at </span><a href="https://puppet.com/docs/bolt/latest/plan_functions.html"><span class="No-Break">https://puppet.com/docs/bolt/latest/plan_functions.html</span></a><span class="No-Break">.</span></p>
			<p>It is also possible to run a plan from within a plan using the <strong class="source-inline">run_plan </strong>function. This can be useful to ensure no plan gets too large and they can be more easily reused. A pattern that can be observed in the PEADM module is the use of the <strong class="source-inline">subplan </strong>folder for plans we only expect to be used within plans, reducing the size and complexity of <span class="No-Break">the catalogs.</span></p>
			<p>It should be noted that most Puppet language features, such as functions, the sensitive type, and lambdas, can be used within this code, but other features, such as deferred functions, cannot since the catalog is not being sent to the node to be applied. The differences are fully documented <span class="No-Break">at </span><a href="https://puppet.com/docs/bolt/latest/writing_plans.html#puppet-and-ruby-functions-in-plans"><span class="No-Break">https://puppet.com/docs/bolt/latest/writing_plans.html#puppet-and-ruby-functions-in-plans</span></a><span class="No-Break">.</span></p>
			<p>For example, within PEADM, the following <strong class="source-inline">run_command </strong>function stops Puppet on all the targets stored in the <strong class="source-inline">$all_targets </strong>variable and then runs a <strong class="source-inline">modify_certificate </strong>plan on the targets in the <strong class="source-inline">covert_target </strong>variable, passing in a primary <strong class="source-inline">add </strong>parameter and the extensions to <span class="No-Break">be added:</span></p>
			<pre class="source-code">
run_command('systemctl stop puppet', $all_targets)
run_plan('peadm::modify_certificate', $convert_targets,
  primary_host =&gt; $primary_target,
  add_extensions =&gt; {
    'pp_auth_role' =&gt; 'pe_compiler',
  },
)</pre>
			<p>Puppet code can also be applied via the <strong class="source-inline">apply </strong>function similar to how a <strong class="source-inline">puppet apply </strong>command would run. For example, PEADM uses the following code to create <span class="No-Break">node groups:</span></p>
			<pre class="source-code">
apply($primary_target) {
class { 'peadm::setup::node_manager_yaml':
  primary_host =&gt; $primary_target.peadm::certname(),
}</pre>
			<p>This applies the <strong class="source-inline">node_manager_yaml </strong>class, passing a <strong class="source-inline">primary_host </strong>parameter. It should be noted that if Puppet libraries are needed in advance of applying Puppet code, the <strong class="source-inline">apply_prep </strong>function can be used to ensure they are available before <a id="_idIndexMarker904"/>using the <span class="No-Break"><strong class="source-inline">apply </strong></span><span class="No-Break">function.</span></p>
			<h2 id="_idParaDest-239"><a id="_idTextAnchor309"/>Logging and results</h2>
			<p>To add logging<a id="_idIndexMarker905"/> to plans, the <strong class="source-inline">out::message </strong>and <strong class="source-inline">out::verbose </strong>functions<a id="_idIndexMarker906"/> are used, with message logging on every run and verbose message output only if Bolt is run in <strong class="source-inline">verbose </strong>mode. Take the <span class="No-Break">following example:</span></p>
			<pre class="source-code">
<strong class="bold">out::message('Error')</strong>
<strong class="bold">out::verbose("Heres the error: $detailed_output")</strong></pre>
			<p><strong class="source-inline">Error </strong>would be printed on every Bolt run, but only when the <strong class="source-inline">–verbose </strong>flag is used would the second message <span class="No-Break">be displayed.</span></p>
			<p>Each function returns an object type of <strong class="source-inline">ResultSet </strong>with each target containing its own <strong class="source-inline">Result </strong>object type, except the <strong class="source-inline">apply </strong>function, whose <strong class="source-inline">ResultSet </strong>contains <strong class="source-inline">ApplyResult </strong>objects. A plan returns a <strong class="source-inline">PlanResult </strong>type as output, which can contain all these data types and just about any Puppet <span class="No-Break">data type.</span></p>
			<p>These objects can be assigned to variables and then functions used to expose data. There are two common functions used in all of these object types. <strong class="source-inline">ok </strong>is a function that returns a simple Boolean confirming whether there were any errors and the <strong class="source-inline">value </strong>function returns the output of <span class="No-Break">the run.</span></p>
			<p>Further type-specific functions can be viewed in the documentation <span class="No-Break">at </span><a href="https://puppet.com/docs/bolt/latest/bolt_types_reference.html"><span class="No-Break">https://puppet.com/docs/bolt/latest/bolt_types_reference.html</span></a><span class="No-Break">.</span></p>
			<p>To return output from the plan, the return<a id="_idIndexMarker907"/> function should be used with any appropriate data type; this could be the direct output from a task or as simple as a string. If no return function is used, the output will be <strong class="source-inline">undef</strong>. For example, the following code will run the task <strong class="source-inline">error_check_task </strong>and only if that is successful will it return the <strong class="source-inline">ResultSet </strong>type output from the task <strong class="source-inline">output_task</strong>; otherwise, it will return the string <span class="No-Break"><strong class="source-inline">OH NO</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
plan return_result( $targets )
$did_this_work = run_task('error_check_task', $targets)
If $did_this_work.ok {
out::message('It worked')
return run_task('output_task', $targets)
}else{
Return "OH NO"
}</pre>
			<p>Now, let’s look at how we can <span class="No-Break">handle errors.</span></p>
			<h2 id="_idParaDest-240"><a id="_idTextAnchor310"/>Handling errors</h2>
			<p>To perform a simple check and fail a <a id="_idIndexMarker908"/>plan as a result, the <strong class="source-inline">fail_plan </strong>function can be used. For example, the following code would check whether the <strong class="source-inline">$targets </strong>variable only contained a <span class="No-Break">single target:</span></p>
			<pre class="source-code">
unless get_targets($targets).size == 1 {
    fail_plan('This plan only accepts one target.')
  }</pre>
			<p>If Bolt functions fail and <strong class="source-inline">_catch_errors </strong>is not set to <strong class="source-inline">true</strong>, then the plan will fail. If <strong class="source-inline">_catch_errors </strong>is used, this allows the plan to continue and the error can <span class="No-Break">be handled:</span></p>
			<pre class="source-code">
$install_agent_results = run_task('agent_install', $agents , '_catch_errors' =&gt; true)
$ install_agent_results.each |$agent_result| {
$target = $agent_result.target.name
if $result.ok
 { notice("${target} installed correctly ${result.value}")
} else {
 notice("${target} failed install with error: ${result.error.message}")
 }
}</pre>
			<p>Alternatively, the <strong class="source-inline">catch_result </strong>function can be used to catch specific types of errors, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
$install_agent_results = catch_error(agent_install/connection_error) || { run_task('agent_install', $agents , '_catch_errors' =&gt; true)
}</pre>
			<p>With an<a id="_idIndexMarker909"/> understanding of logging and error handling in plans, we can now look at how external data can be used in plans. Since Bolt uses Puppet as a library, it can use Hiera to access external data. As was covered in <a href="B18492_09.xhtml#_idTextAnchor233"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, this can ensure we separate code and data into plans as we do with <span class="No-Break">Puppet code.</span></p>
			<h2 id="_idParaDest-241"><a id="_idTextAnchor311"/>Managing data sources</h2>
			<p>Facts<a id="_idIndexMarker910"/> can be collected<a id="_idIndexMarker911"/> from the hosts using the built-in facts plan or from PuppetDB using <strong class="source-inline">puppetdb_facts</strong>, assuming PuppetDB is set up in a Bolt configuration already. Using either plan would cause the targets to query PuppetDB  to automatically have their in-memory inventory updated with the facts. The following example would run <strong class="source-inline">facts </strong>on <strong class="source-inline">targets</strong>, and those targets for which the <strong class="source-inline">os.name </strong>fact is equal to <strong class="source-inline">Windows </strong>are assigned to the <span class="No-Break"><strong class="source-inline">windows_targets </strong></span><span class="No-Break">variable:</span></p>
			<pre class="source-code">
run_plan('facts', 'targets' =&gt; $targets)
$windows_targets = get_targets($targets).filter |$target| { $target.facts['os']['name'] == 'Windows' }</pre>
			<p>PuppetDB can also have general queries run against it using the <strong class="source-inline">puppetdb_query </strong>function. To return all the <strong class="source-inline">certnames  </strong>fact values of <strong class="source-inline">windows </strong>hosts listed in PuppetDB, use the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
$windows_targets = get_targets (puppetdb_query('inventory[certname] { facts.os.name = "windows" }'))</pre>
			<p>Hiera can be used with plans by using either modules or Bolt project-level Hiera and having an appropriate <strong class="source-inline">hiera.yaml</strong>. The <strong class="source-inline">lookup </strong>function can then be used either inside <strong class="source-inline">apply </strong>functions or simply in the plan. If <strong class="source-inline">lookup </strong>is used within an <strong class="source-inline">apply </strong>function, and assuming the <strong class="source-inline">apply_prep </strong>function is run, we can gather all the facts and Hiera will function as expected. When using it within a plan, the important differences to note are that Bolt has no automatic parameter lookup capabilities like normal Puppet code with classes and the Bolt hierarchy can’t use top scope variables or facts. When Hiera is used within Bolt, it uses two levels of hierarchy, the project and module levels, with the project level being higher <span class="No-Break">in precedence.</span></p>
			<p>An example of the Bolt hierarchy would be a <strong class="source-inline">hiera.yaml </strong>project containing a hierarchy with Node data and the <strong class="source-inline">plan_hierarchy </strong>key without <span class="No-Break">Node data:</span></p>
			<pre class="source-code">
Hierarchy: -
- name: "Nodes" path: "targets/%{trusted.certname}.yaml"
- name: "Org" path: "%{org}.yaml"
plan_hierarchy:
- name: "Org" path: "%{org}.yaml"</pre>
			<p>A <strong class="source-inline">lookup </strong>function in the plan could do the following and with an <strong class="source-inline">application </strong>variable be able to <a id="_idIndexMarker912"/>look up the <strong class="source-inline">dns_server_name </strong>variable in the org level of the <span class="No-Break">plan hierarchy:</span></p>
			<pre class="source-code">
plan exampleproject::exampleplan(
TargetSpec $nodes,
String $application
){
$dns_server_name = lookup('dns_server_name)
}</pre>
			<p>In the following section, we will look at how comments can be used to <span class="No-Break">document metadata.</span></p>
			<h2 id="_idParaDest-242"><a id="_idTextAnchor312"/>Documenting plan metadata</h2>
			<p>Unlike tasks, since<a id="_idIndexMarker913"/> plans do not have a <strong class="source-inline">metadata.json </strong>file, it is necessary to document via comments so that when <strong class="source-inline">puppet plans show &lt;plan name&gt; </strong>is run, a description is provided. The first comment line is taken as the description, or an <strong class="source-inline">@summary </strong>tag can be used. Using <strong class="source-inline">@param &lt;param name&gt; </strong>on a comment will indicate it is the description of a parameter and using <strong class="source-inline">@api private </strong>will mark the plan as private. An example of using all of these fields is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
# @summary This plan is just for example
# @api private
# @param example_servers The targets to run this plan on
# @param manage_user Whether the user account should be managed
plan exampleproject::exampleplan(
TargetSpec $example_servers,
Enum ['true', 'false'] $manage_user
){</pre>
			<p>The data type <a id="_idIndexMarker914"/>details are picked up automatically by the <strong class="source-inline">bolt plan </strong><span class="No-Break"><strong class="source-inline">show </strong></span><span class="No-Break">command.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">It can be useful to add plans and tasks to the control repo, but it should be noted that when using PDK validate, PDK cannot validate plans and will only ignore plans in the default bottom-level plan directory. If you have a structure that puts plans at a lower level, you will have to run <strong class="source-inline">pdk </strong>to ignore these lower level directories of plans, such as <strong class="source-inline">pdk set config </strong><span class="No-Break"><strong class="source-inline">project.validate.ignore subdir1/subdir2/plan</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-243"><a id="_idTextAnchor313"/>Plan testing</h2>
			<p>Testing Puppet plans<a id="_idIndexMarker915"/> is beyond the scope of the book. This is because plan testing is currently not fully implemented and difficult compared to the normal RSpec testing we saw in <a href="B18492_08.xhtml#_idTextAnchor212"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>. Certain things are simply not implemented, such as mocking uploading a file or custom functions, which makes it difficult to carry out meaningful and complete testing compared to module testing. The testing functions currently available can be viewed <span class="No-Break">at </span><a href="https://puppet.com/docs/bolt/latest/testing_plans.html"><span class="No-Break">https://puppet.com/docs/bolt/latest/testing_plans.html</span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor314"/>Introducing YAML plans</h2>
			<p>YAML plans will be <a id="_idIndexMarker916"/>summarized <a id="_idIndexMarker917"/>here due to their much lower level of usage than Puppet plans. They are named similarly to Puppet-based plans but end with an extension of <strong class="source-inline">.yaml </strong>(not <strong class="source-inline">.yml</strong>). However, there is no command to create them. YAML plans contain <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">Description</strong>: What will be displayed in the <span class="No-Break"><strong class="source-inline">show </strong></span><span class="No-Break">command</span></li>
				<li><strong class="source-inline">Parameters</strong>: A hash of parameters that can be passed to <span class="No-Break">the plan</span></li>
				<li><strong class="source-inline">Private</strong>: A Boolean stating whether the plan is visible to the <span class="No-Break"><strong class="source-inline">show </strong></span><span class="No-Break">command</span></li>
				<li><strong class="source-inline">Return</strong>: An array, Boolean, hash, number, or string to return from <span class="No-Break">the plan</span></li>
				<li><strong class="source-inline">Steps</strong>: An array of steps to <span class="No-Break">be run</span></li>
			</ul>
			<p>The steps essentially represent the action to be performed in that step and the variables the step needs. There is a similarity between the options available in Bolt and the actions in Puppet plans, such as commands, tasks, scripts, file downloads, and file uploads. As with Puppet plans, YAML plans can call other plans with a <span class="No-Break">plan step.</span></p>
			<p>The following example<a id="_idIndexMarker918"/> task plan, which uses the Docker <strong class="source-inline">puppetlabs </strong>module from Forge <a href="https://forge.puppet.com/modules/puppetlabs/docker">https://forge.puppet.com/modules/puppetlabs/docker</a> to create and join an additional manager node to a Docker swarm, shows some of <a id="_idIndexMarker919"/>these features <span class="No-Break">in use:</span></p>
			<pre class="source-code">
description: configure docker swarm
paramters:
  firstnode
    type: TargetSpec
  Othernodes
    Type: Targetspec
- name: init
    task: docker::swarm_init
    targets: $firstnode
  - name: token
    task: docker::swarm_token
    targets: $firstnode
  - name:facts
    Fact:
    targets: $firstnode
  - name: managersjoin
    task: docker::join_swarm
    targets: $othernodes
    parameters:
      token: $token.map |$token_result| { $token_result['stdout'] }
       manager_ip: $facts.map |$facts_result| { $facts_result['stdout']['networking']['interfaces']['ip'] }
return $managersjoin.map | $managersjoin_result| {$managersjoin_result['stdout']}</pre>
			<p>This task takes the <strong class="source-inline">firstnode </strong>and <strong class="source-inline">othernodes </strong>variables of the <strong class="source-inline">TargetSpec </strong>type to provide the servers to the target. It uses the <strong class="source-inline">swarm_init </strong>task to initialize on the first node and runs the <strong class="source-inline">swarm_token </strong>task on this node. The <strong class="source-inline">Fact </strong>task is then run on <strong class="source-inline">firstnode</strong>, and in the final step, the <strong class="source-inline">join_swarm </strong>task is run on <strong class="source-inline">othernodes</strong>. It can be seen calling a variable with the name of previous step allows us to access the output created by that step. So we can take the output of the token step and map out the taskspec type returned to use the <strong class="source-inline">stdout </strong>as the token. For the <strong class="source-inline">manager_ip </strong>parameter, we perform a similar action, but this time, as there is more content in <strong class="source-inline">stdout</strong>, we must find the <strong class="source-inline">networking.interface.ip </strong>address fact we wish to pass. The plan then sets the return key to take the <strong class="source-inline">stdout </strong>output of the <strong class="source-inline">join </strong>step to confirm the result of <span class="No-Break">the plan.</span></p>
			<p>It is also possible<a id="_idIndexMarker920"/> to use the <strong class="source-inline">eval </strong>step to calculate values, and both Puppet and Bolt<a id="_idIndexMarker921"/> functions can be used with this. The <strong class="source-inline">message </strong>and <strong class="source-inline">verbose </strong>steps are available for output just as they were in Puppet plans, while string interpolation follows the normal Puppet principle of single quotes (<strong class="source-inline">''</strong>) having no interpolation, just printing the text, double quotes (<strong class="source-inline">""</strong>) performing interpolation, and also using a pipe (<strong class="source-inline">|</strong>) with a new line to allow for expressions of a block of Puppet code to be displayed on the <span class="No-Break">next line.</span></p>
			<p>To show some of this, the following plan takes an array of strings to install <span class="No-Break">as packages:</span></p>
			<pre class="source-code">
parameters:
  packages:
    type: Array[String]
  servers:
    type: Targetspec
Steps:
  -name: unique_packages
  eval: $packages.unique
  -name: numer_of_packages
  eval: $unique_packages.size
  - verbose: 'Installing ${number_of_packages} packages'
  - name: install
    task: example::install_packages
    parameters:
      packages:  $unique_packages
      Targets: $servers
Return: $install.map | $install_result| {$install_result['stdout']}</pre>
			<p>We can <a id="_idIndexMarker922"/>see that the <strong class="source-inline">unique_packages eval </strong>step uses the <strong class="source-inline">unique </strong>function<a id="_idIndexMarker923"/> to find only unique values in the array and the <strong class="source-inline">numer_of_packages eval </strong>step uses the <strong class="source-inline">size </strong>function, the result of which is passed to the <strong class="source-inline">verbose </strong>output and interpolated into a string which shows the number of packages. The <strong class="source-inline">example::install_packages </strong>task is run with the output of the <strong class="source-inline">unique_packages </strong>eval step before its output is used in the <span class="No-Break">returned value.</span></p>
			<p>This has been just a summary of using<a id="_idIndexMarker924"/> YAML plans. The full options available on each step and more are available in the <span class="No-Break">documentation: </span><a href="https://puppet.com/docs/bolt/latest/writing_yaml_plans.html"><span class="No-Break">https://puppet.com/docs/bolt/latest/writing_yaml_plans.html</span></a><span class="No-Break">.</span></p>
			<p>In the following section, let’s look at some examples of plugins that are commonly used <span class="No-Break">with Bolt.</span></p>
			<h1 id="_idParaDest-245"><a id="_idTextAnchor315"/>Plugins</h1>
			<p>Plugins allow Bolt<a id="_idIndexMarker925"/> to dynamically load data during a Bolt run. Plugins are essentially just<a id="_idIndexMarker926"/> modules containing tasks with a <strong class="source-inline">bolt_plugin.json </strong>file identifying which tasks are plugins and what type of plugins they are. Some are built into Bolt, while others can be added to extend <span class="No-Break">the functionality.</span></p>
			<p>There are three types of <span class="No-Break">Bolt plugins:</span></p>
			<ul>
				<li><strong class="bold">Reference</strong>: Used to<a id="_idIndexMarker927"/> fetch data from external sources, such as loading <a id="_idIndexMarker928"/>information into the <span class="No-Break">inventory file</span></li>
				<li><strong class="bold">Secret</strong>: Used to <a id="_idIndexMarker929"/>create keys to encrypt text and decrypt <span class="No-Break">cipher</span><span class="No-Break"><a id="_idIndexMarker930"/></span><span class="No-Break"> text</span></li>
				<li><strong class="bold">Puppet library</strong>: Used to install <a id="_idIndexMarker931"/>Puppet libraries when<a id="_idIndexMarker932"/> the <strong class="source-inline">apply_prep </strong>function is called on <span class="No-Break">a target</span></li>
			</ul>
			<p>We will look at these in detail in the <span class="No-Break">following subsections.</span></p>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor316"/>Reference plugins</h2>
			<p><strong class="bold">Reference plugins </strong>can be<a id="_idIndexMarker933"/> used in configuration files such as <strong class="source-inline">inventory.yaml </strong>or <strong class="source-inline">bolt-project.yaml </strong>using a <strong class="source-inline">_plugin </strong>key with the plugin name as the value and <a id="_idIndexMarker934"/>followed by parameters associated with the plugin. For example, to use the <strong class="source-inline">puppetdb </strong>plugin and query and select all the window nodes in PuppetDB, we could add the following group <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">inventory.yaml</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
groups:
  - name: windows
    targets:
      - _plugin: puppetdb
        query: 'inventory[certname] { facts.kernel = "Windows" }'</pre>
			<p>This is assuming the PuppetDB connection configuration details are set in one of the <span class="No-Break">configuration files.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">With the PuppetDB plugin configured a one-time query like this can be used to query PuppetDB: <strong class="source-inline">bolt task run 'inventory[certname] { facts.kernel = "</strong><span class="No-Break"><strong class="source-inline">Windows" }'</strong></span><span class="No-Break">.</span></p>
			<p>Another approach to reference plugins can be with passwords where the <strong class="source-inline">prompt </strong>plugin will result in user input from the command line that sets a password. For example, the following will <a id="_idIndexMarker935"/>ensure that when running against <strong class="source-inline">target1.example.com</strong>, Bolt <a id="_idIndexMarker936"/>will connect on <strong class="source-inline">winrm </strong>with the user <strong class="source-inline">bill </strong>and the password prompted by the message <strong class="source-inline">Enter </strong><span class="No-Break"><strong class="source-inline">your password</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
targets:
  - target1.example.com
  config:
  winrm:
    user: bill
    password:
      _plugin: prompt
      message: Enter your password</pre>
			<p>Plugins can also be used in plans via the <strong class="source-inline">resolve_references </strong>function. The following example shows a subsection of the <strong class="source-inline">pecdm </strong>module using plugins via the <span class="No-Break"><strong class="source-inline">resolve_references </strong></span><span class="No-Break">function:</span></p>
			<pre class="source-code">
$inventory = ['server', 'psql', 'compiler', 'node', 'windows_node' ].reduce({}) |Hash $memo, String $i| {,
$memo + { $i =&gt; resolve_references( {
'_plugin' =&gt; 'terraform',
'dir' =&gt; $tf_dir,</pre>
			<p>In the <a id="_idIndexMarker937"/>preceding code block, it essentially iterates through each group name <a id="_idIndexMarker938"/>and builds an array of target entries read in from the <strong class="source-inline">terraform </strong>directory set by the <strong class="source-inline">tf_dir </strong>variable. To see a further example, look at the contents of the <strong class="source-inline">inventory.yaml </strong>file for your lab setup, which uses the <span class="No-Break"><strong class="source-inline">terraform </strong></span><span class="No-Break">plugin.</span></p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor317"/>Secret plugins</h2>
			<p><strong class="bold">Secret plugins </strong>allow for the <a id="_idIndexMarker939"/>creation of keys and secrets, and encrypted values to be <a id="_idIndexMarker940"/>passed in. Currently, <strong class="source-inline">pckcs7 </strong>is Bolt’s default and only secret plugin. To create the encryption keys, run the <strong class="source-inline">bolt secret createkeys -–force </strong>Unix command or the <strong class="source-inline">New-BoltSecretKey -Force </strong>PowerShell cmdlet. This will create the keys in the <strong class="source-inline">keys </strong>folder of your project. Cipher text can be generated via the <strong class="source-inline">bolt secret encrypt 'N33dt0kn0wba515!' --plugin pckcs7 </strong>Unix command or the <strong class="source-inline">Protect-BoltSecret -Text 'N33dt0kn0wba515! ' -Plugin pckcs7 </strong><span class="No-Break">PowerShell cmdlet.</span></p>
			<p>The cipher text from this command can then be used in places such as <strong class="source-inline">inventory.yaml </strong>using the <strong class="source-inline">pkcs7 </strong>reference plugin, <span class="No-Break">for example:</span></p>
			<pre class="source-code">
targets:
  - uri: target1.example.com
    config:
      ssh:
        password:
          _plugin: pkcs7
          encrypted_value: |
            ENC[PKCS7,MIIBiQYJK]</pre>
			<p>Note the previous encrypted string was shortened and has a default key size of <strong class="source-inline">2048</strong>. This can be changed by configuring the plugin in <strong class="source-inline">bolt-project.yaml </strong>or the default and <span class="No-Break">user configuration.</span></p>
			<h2 id="_idParaDest-248"><a id="_idTextAnchor318"/>Puppet library</h2>
			<p><strong class="bold">Puppet library plugins </strong>install<a id="_idIndexMarker941"/> Puppet libraries on a target when the <strong class="source-inline">apply_prep </strong>function is<a id="_idIndexMarker942"/> called in a plan. Each target the plugin is run on must be able to use the scripting language used by the plugin. Currently, only <strong class="source-inline">puppet-agent </strong>exists as a Puppet library plugin and it is configured to be available by default. But any future libraries or custom written libraries would be added to the Bolt, user, or default configuration in a similar fashion to <span class="No-Break">this example:</span></p>
			<pre class="source-code">
plugin-hooks:
  puppet_library:
    plugin: task
    task: package
    parameters:
      name: puppet-agent
      action: install</pre>
			<p>The full list of supported and built-in plugins can be viewed at <a href="https://puppet.com/docs/bolt/latest/supported_plugins.html">https://puppet.com/docs/bolt/latest/supported_plugins.html</a>. Writing plugins is beyond the scope of this book, but the documentation at <a href="https://puppet.com/docs/bolt/latest/writing_plugins.html">https://puppet.com/docs/bolt/latest/writing_plugins.html</a> <span class="No-Break">advises further.</span></p>
			<p>Having covered Bolt in detail, we will now practice creating and using a bolt project in the <span class="No-Break">following lab.</span></p>
			<h1 id="_idParaDest-249"><a id="_idTextAnchor319"/>Lab – creating and using a Bolt project</h1>
			<p>In this lab, we will create a<a id="_idIndexMarker943"/> Bolt project. We will create a task that runs the <strong class="source-inline">facter </strong>command on a Windows and <span class="No-Break">Linux node.</span></p>
			<p>The steps are <a id="_idIndexMarker944"/><span class="No-Break">as follows:</span></p>
			<ul>
				<li>Create a Bolt project with the following line <span class="No-Break">of code:</span><pre class="source-code">
<strong class="bold">bolt project init packtlab</strong></pre></li>
				<li>Create an <strong class="source-inline">inventory.yaml </strong>file by performing a lookup of Windows and Linux clients from the PECDM Bolt project and copying <span class="No-Break">the output:</span><pre class="source-code">
<strong class="bold">bolt inventory show --targets agent_nodes --detail</strong>
<strong class="bold">bolt inventory show --targets windows_agent_nodes --detail</strong></pre></li>
				<li>Write a task to cover both Windows and Linux that runs the <strong class="source-inline">facter </strong>command, taking a single argument if only a single fact should <span class="No-Break">be returned.</span></li>
				<li>Write a plan that uses <strong class="source-inline">run_command </strong>to run <strong class="source-inline">facter </strong>and return the results of <span class="No-Break">the plan.</span></li>
				<li>Run the task and plan on your Windows and <span class="No-Break">Linux clients.</span></li>
				<li>You can<a id="_idIndexMarker945"/> find example solutions <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch12"><span class="No-Break">https://github.com/PacktPublishing/Puppet-8-for-DevOps-Engineers/tree/main/ch12</span></a><span class="No-Break">.</span></li>
			</ul>
			<h1 id="_idParaDest-250"><a id="_idTextAnchor320"/>Summary</h1>
			<p>In this chapter, we showed how Bolt complements Puppet’s state-based management by providing a capability to run ad hoc actions for anything that doesn’t fit the declarative enforcement methods of Puppet. We also showed how transports provide the ability for Bolt to connect to targets. We saw how, using the Bolt commands via Unix or PowerShell, we could run commands, scripts, Puppet code, and manifests on targets, as well as uploading and downloading files. We reviewed how Bolt logs to <strong class="source-inline">bolt-debug.log </strong>and how to configure logging to get more logs for <span class="No-Break">different issues.</span></p>
			<p>We then showed how Bolt projects provide a directory structure to contain the configuration and data for Bolt. Bolt projects provide the <strong class="source-inline">inventory.yaml </strong>file to contain target and transport configuration and the <strong class="source-inline">bolt-project.yaml </strong>file to contain project-level configuration settings for Bolt and to allow module dependencies to be downloaded into the project. We discussed how the Bolt project is loaded into the module path along with any modules it had downloaded. We then highlighted how the project format has changed over different versions of Bolt and how the <strong class="source-inline">bolt migrate </strong>command can convert older projects to the <span class="No-Break">new format.</span></p>
			<p>We then discussed how tasks are single-action scripts that can be in any language that will run on a target machine, paired with a JSON file to provide metadata such as parameters. We also showed how a task can list multiple implementations depending on the target. We looked at how sensitive parameters allow passwords and other secrets to be used by tasks without logging in the APIs. The <strong class="source-inline">noop </strong>option was introduced as a standard way to pass a parameter to a task and run in no-execute mode. We also showed how remote tasks contain the <strong class="source-inline">remote </strong>parameter, set to <strong class="source-inline">true</strong>, and a remote transport to allow web access services to use tasks despite being unable to log on in the <span class="No-Break">traditional way.</span></p>
			<p>Then, we discussed how tasks are capable of sharing scripts in implementations and referring to other modules. Some security practices were discussed to ensure parameters are safely passed <span class="No-Break">to tasks.</span></p>
			<p>Plans were then discussed as a way of running multiple tasks together and providing logic and control flow. We saw how plans could be written in either the Puppet language or YAML and how targets can be created using the <strong class="source-inline">targetspec </strong>data type and functions. We also saw how structured results can be returned after running <span class="No-Break">a plan.</span></p>
			<p>We then discussed how Bolt plugins provide ways to dynamically load data into Bolt runs using reference plugins to fetch data and store it, such as to fill the inventory with data from Terraform. We can also use secret plugins to provide keys for encrypting and decrypting values in Bolt runs. The third type of plugin we looked at was Puppet library plugins, which has only been implemented currently for the installation of Puppet agent <span class="No-Break">via Bolt.</span></p>
			<p>In this chapter, we saw how Bolt can be paired with Puppet to get the best of both declarative and stateful language approaches to allow for flexibility in <span class="No-Break">Puppet configurations.</span></p>
			<p>Having reviewed how to use Bolt and Puppet Enterprise, in the next chapter, we will look at more advanced topics on how to monitor and scale Puppet infrastructure, review performance issues, and use the <strong class="bold">Puppet Data Service </strong>to implement the external data pattern and allow users to enter data into Puppet setups with <span class="No-Break">self-service APIs.</span></p>
		</div>
	</body></html>