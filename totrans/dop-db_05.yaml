- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: RDBMS with DevOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we’ll delve into the intricate yet rewarding relationship between
    **relational database management systems** (**RDBMSs**) and DevOps. As you traverse
    this chapter, you will gain a deep understanding of how modern DevOps practices
    can be intertwined with RDBMS to create a streamlined, efficient, and secure IT
    environment. This combination offers numerous advantages, and learning how to
    exploit them is pivotal for any organization aiming to stay competitive in today’s
    fast-paced digital landscape.
  prefs: []
  type: TYPE_NORMAL
- en: One of the first critical aspects we will explore is provisioning and configuration
    management. Understanding how to automate these tasks for databases in a DevOps
    culture is essential for rapid deployments and scaling. You’ll discover how to
    implement IaC approaches that enable frictionless environment setup and configuration
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll move on to monitoring and alerting, which serve as the eyes and
    ears of any robust system. You’ll learn the latest tools and techniques for real-time
    database monitoring and how to set up automated alerting mechanisms. This knowledge
    will allow you to identify and fix issues before they escalate, thus ensuring
    continuous uptime and operational efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Following this, this chapter will guide you through the vital areas of backup
    and disaster recovery. Here, you’ll find out how to integrate these critical strategies
    seamlessly into your DevOps pipeline, ensuring that your data is safe and that
    your systems are resilient against unforeseen calamities.
  prefs: []
  type: TYPE_NORMAL
- en: Performance optimization is another key theme. You’ll learn the best practices
    for making your RDBMS run as efficiently as possible, from indexing and query
    optimization to caching and beyond. We’ll show you how to identify bottlenecks
    and improve database performance, all within the framework of a DevOps culture.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, we’ll touch upon DevSecOps, the practice that integrates
    security into DevOps. You’ll understand why security can’t be an afterthought
    and how to embed security measures right into your DevOps workflows and RDBMS
    configurations.
  prefs: []
  type: TYPE_NORMAL
- en: By addressing these essential components, this chapter will serve as a comprehensive
    guide to melding RDBMS and DevOps, replete with actionable insights. For system
    administrators, database administrators, and DevOps engineers alike, the knowledge
    you will acquire here will be indispensable in leveraging the full power of integrating
    RDBMS with DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Embracing DevOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provisioning and configuration management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring and alerting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backup and disaster recovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DevSecOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embracing DevOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a DevOps team, several activities are involved in managing and maintaining
    relational databases. Some of the main activities and challenges include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning and configuration management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring and alerting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backup and disaster recovery
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Performance optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security and access management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following sections, we will discuss each of these activities in detail
    and provide examples of how they can be implemented using various tools.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning and configuration management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the primary activities of a DevOps team is to provision and configure
    relational databases. This includes creating database instances, configuring database
    settings, and managing database users and permissions. Here are some examples
    of how this can be accomplished:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a MySQL database instance using Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring PostgreSQL settings using Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing Oracle users and permissions using Puppet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s look at these examples in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a MySQL database instance using Terraform
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating a MySQL database instance in **Amazon Web Services** (**AWS**) using
    Terraform involves several steps, including setting up the necessary infrastructure,
    configuring the database, and launching the instance. In this example, we will
    use Terraform to automate the process of creating a MySQL database instance in
    AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture overview
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The architecture we’ll use in this example involves the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Virtual Private Cloud** (**VPC**): A VPC is a virtual network that you can
    configure to host your AWS resources. It provides an isolated environment for
    your resources and enables you to control network access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subnet**: A subnet is a range of IP addresses in your VPC that you can use
    to launch your resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security group**: A security group acts as a virtual firewall for your instances
    to control inbound and outbound traffic. You can specify rules for inbound and
    outbound traffic to and from the instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A Relational Database Service** (**RDS**) **instance**: Amazon RDS is a managed
    database service that makes it easier to set up, operate, and scale a relational
    database in the cloud. In this example, we will use RDS to create a MySQL database
    instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Terraform is a tool for building, changing, and versioning infrastructure safely
    and efficiently. It uses a declarative approach to **Infrastructure as Code**
    (**IaC**), meaning that you define the desired state of your infrastructure and
    Terraform will figure out how to create it.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – setting up the necessary infrastructure
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first step in creating a MySQL database instance using Terraform is to
    set up the necessary infrastructure. We will create a VPC, a subnet, and a security
    group for the RDS instance. Here’s some example Terraform code for setting up
    the infrastructure:'
  prefs: []
  type: TYPE_NORMAL
- en: VPC
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This code sets up a VPC with a CIDR block of `10.0.0.0/16` and a subnet with
    a CIDR block of `10.0.1.0/24`. It also creates a security group for the RDS instance
    with an ingress rule that allows traffic on port `3306` from any IP address.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – configuring the database
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The next step is to configure the MySQL database. We will create a parameter
    group and a database instance with the necessary settings. Here’s some example
    Terraform code for configuring the database:'
  prefs: []
  type: TYPE_NORMAL
- en: SQL
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code creates a parameter group for the MySQL database instance
    with two parameters – `innodb_buffer_pool_size` and `max_connections`. The `innodb_buffer_pool_size`
    parameter sets the size of the `InnoDB` buffer pool to 256 MB, and the `max_connections`
    parameter sets the maximum number of connections to `1000`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code also creates an RDS instance with the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: Allocated storage of 20 GB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A storage type of `gp2`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL engine version 5.7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An instance class of `db.t2.micro`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An instance name of `example`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A database username of `admin`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A database password of `password`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Step 3 – launching the instance
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The final step is to launch the RDS instance. Here’s some example Terraform
    code for launching the instance:'
  prefs: []
  type: TYPE_NORMAL
- en: RDS
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This code launches the RDS instance and associates it with the security group
    and subnet we created in *Step 1*. The `vpc_security_group_ids` parameter specifies
    the ID of the security group we created earlier, and the `db_subnet_group_name`
    parameter specifies the name of the subnet group we created in this step.
  prefs: []
  type: TYPE_NORMAL
- en: The subnet group is created to specify the subnet where the database instance
    will be launched. In this example, we are only using one subnet, but you can create
    multiple subnets in different availability zones for high availability and disaster
    recovery.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In conclusion, creating a MySQL database instance in AWS using Terraform involves
    setting up the necessary infrastructure, configuring the database, and launching
    the instance. The infrastructure includes a VPC, a subnet, and a security group
    for the RDS instance. The database is configured using a parameter group and an
    RDS instance with the necessary settings. Finally, the RDS instance is launched
    and associated with the security group and subnet group. Terraform simplifies
    this process by allowing you to automate the creation and management of your IaC.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring PostgreSQL settings using Ansible
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Configuring PostgreSQL settings using Ansible in AWS involves automating the
    configuration of PostgreSQL database settings using Ansible, a popular automation
    tool. In this example, we will use Ansible to install PostgreSQL on an EC2 instance
    in AWS, create a database and user, and configure various settings such as memory
    allocation, connection settings, and logging.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture overview
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The architecture used in this example consists of an AWS EC2 instance running
    Ubuntu 20.04 LTS as the operating system. Ansible will be used to provision the
    instance with PostgreSQL, create a database and user, and configure PostgreSQL
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, we will assume that Ansible is already installed and configured
    on the local machine. We will also assume that an AWS EC2 instance has been launched
    and that we have the necessary credentials to access it via SSH.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – creating an Ansible playbook
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The first step is to create an Ansible playbook that will define the tasks
    to be performed. We will create a file called `postgres.yml` in the `playbooks`
    directory with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: YAML
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This playbook defines four main tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Install PostgreSQL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a database and user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure PostgreSQL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart PostgreSQL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The playbook is divided into several sections, each containing a list of tasks
    to be executed. Each task specifies the name of the module to be used, the parameters
    to be passed, and any notifications that should be triggered upon completion.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 – creating an inventory file
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The next step is to create an inventory file that defines the hosts that will
    be targeted by the playbook. We will create a file called `hosts` in the `inventory`
    directory with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: hosts
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This inventory file defines a single host group called `db` that contains the
    IP address of the EC2 instance and the username to be used for SSH access.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 – running the playbook
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have created the playbook and inventory file, we can run the playbook
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: Bash
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: psql -d mydb -U myuser
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: show all;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: class oracle::users {
  prefs: []
  type: TYPE_NORMAL
- en: 'user { ''user1'':'
  prefs: []
  type: TYPE_NORMAL
- en: ensure     => present,
  prefs: []
  type: TYPE_NORMAL
- en: home       => '/home/user1',
  prefs: []
  type: TYPE_NORMAL
- en: managehome => true,
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'file { ''/home/user1/.profile'':'
  prefs: []
  type: TYPE_NORMAL
- en: ensure => file,
  prefs: []
  type: TYPE_NORMAL
- en: content => "export ORACLE_SID=ORCL\nexport ORACLE_HOME=/u01/app/oracle/product/12.2.0/dbhome_1\nexport
    PATH=$PATH:$ORACLE_HOME/bin\n",
  prefs: []
  type: TYPE_NORMAL
- en: owner => 'user1',
  prefs: []
  type: TYPE_NORMAL
- en: group => 'dba',
  prefs: []
  type: TYPE_NORMAL
- en: mode => '0600',
  prefs: []
  type: TYPE_NORMAL
- en: require => User['user1'],
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'exec { ''create_user1'':'
  prefs: []
  type: TYPE_NORMAL
- en: command => '/u01/app/oracle/product/12.2.0/dbhome_1/bin/sqlplus / as sysdba
    <<EOF\nCREATE USER user1 IDENTIFIED BY password;\nGRANT CONNECT, RESOURCE TO user1;\nEXIT;\nEOF\n',
  prefs: []
  type: TYPE_NORMAL
- en: onlyif  => '/u01/app/oracle/product/12.2.0/dbhome_1/bin/sqlplus / as sysdba
    @/tmp/user1_exists.sql | grep -q "0 rows selected"',
  prefs: []
  type: TYPE_NORMAL
- en: require => File['/home/user1/.profile'],
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: node 'oracle-db-agent' {
  prefs: []
  type: TYPE_NORMAL
- en: include oracle::users
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: sudo puppet agent -t
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: DD_API_KEY=<YOUR_API_KEY> bash -c "$(curl -L https://raw.githubusercontent.com/DataDog/datadog-agent/master/cmd/agent/install_script.sh)"
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '- type: file'
  prefs: []
  type: TYPE_NORMAL
- en: 'path: /var/log/mysql/error.log'
  prefs: []
  type: TYPE_NORMAL
- en: 'service: mysql'
  prefs: []
  type: TYPE_NORMAL
- en: 'source: mysql'
  prefs: []
  type: TYPE_NORMAL
- en: 'sourcecategory: database'
  prefs: []
  type: TYPE_NORMAL
- en: 'log_processing_rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '- type: multi_line'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: new_log_start_with_date'
  prefs: []
  type: TYPE_NORMAL
- en: 'pattern: \d{4}\-\d{2}\-\d{2}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[mysqld_exporter]'
  prefs: []
  type: TYPE_NORMAL
- en: user = root
  prefs: []
  type: TYPE_NORMAL
- en: password = <YOUR_PASSWORD>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: <PROJECT_ID> with your GCP project ID and <TOPIC_NAME> with the name of your
    Pub/Sub topic.
  prefs: []
  type: TYPE_NORMAL
- en: Next, you need to configure Datadog to receive logs from Pub/Sub. To do this,
    create a new log pipeline in Datadog and configure it to receive logs from the
    Pub/Sub subscription.
  prefs: []
  type: TYPE_NORMAL
- en: Step 4 – creating a Datadog dashboard
  prefs: []
  type: TYPE_NORMAL
- en: With the MySQL metrics collected and sent to Datadog, you can now create a dashboard
    to monitor them. To create a new dashboard in Datadog, go to the **Dashboards**
    page and click **New Dashboard**.
  prefs: []
  type: TYPE_NORMAL
- en: On the **New Dashboard** page, select a layout and add widgets to display the
    MySQL metrics you want to monitor. For example, you can add a MySQL overview widget
    to display the total number of queries, connections, and other important metrics.
  prefs: []
  type: TYPE_NORMAL
- en: You can also add widgets to display specific MySQL metrics, such as the number
    of slow queries or the percentage of CPU usage.
  prefs: []
  type: TYPE_NORMAL
- en: Step 5 – setting up alerts
  prefs: []
  type: TYPE_NORMAL
- en: In addition to monitoring MySQL metrics with a dashboard, you can also set up
    alerts to notify you when specific metrics exceed a certain threshold. To create
    a new alert in Datadog, go to the **Alerts** page and click **New Monitor**.
  prefs: []
  type: TYPE_NORMAL
- en: On the **New Monitor** page, select the MySQL metrics you want to monitor and
    configure the alert settings, such as the threshold and notification method.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can create an alert to notify you when the number of slow queries
    exceeds a certain threshold or when the percentage of CPU usage is above a certain
    level.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we explored how to monitor MySQL metrics using Datadog in GCP.
    By setting up the Datadog Agent, Stackdriver, Pub/Sub, and a Datadog dashboard,
    we were able to collect, visualize, and monitor MySQL metrics with ease. With
    alerts set up, we can also receive notifications when important metrics exceed
    a certain threshold, allowing us to quickly identify and resolve any issues with
    the MySQL instance.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up PostgreSQL alarms using Prometheus
  prefs: []
  type: TYPE_NORMAL
- en: PostgreSQL is a powerful open source RDBMS. Prometheus is a monitoring and alerting
    toolkit that collects metrics from monitored targets, stores them, and makes them
    available for querying and alerting. GCP provides a scalable infrastructure for
    deploying and managing applications.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture overview
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up PostgreSQL alarms using Prometheus in GCP, we will follow the following
    architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Deploy PostgreSQL on GCP**: We will deploy PostgreSQL on GCP using Google
    Cloud SQL, a managed SQL database service that makes it easy to set up, manage,
    and administer PostgreSQL databases.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pg_prometheus` extension to export PostgreSQL metrics to Prometheus. `pg_prometheus`
    is an open source PostgreSQL extension that exports PostgreSQL metrics in the
    Prometheus format.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`pg_prometheus` extension. Prometheus can scrape metrics from targets using
    HTTP(S) endpoints. We will expose the PostgreSQL metrics using an HTTP endpoint.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Set up Prometheus alerts**: We will use Prometheus to set up alerts based
    on the collected PostgreSQL metrics. Prometheus alerts are rules that specify
    conditions for triggering an alert. When an alert is triggered, Prometheus sends
    a notification to an alert manager.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Send alerts to a notification channel**: We will use Alertmanager to send
    alerts to a notification channel, such as email or Slack.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here’s the step-by-step guide on how to set up PostgreSQL alarms using Prometheus
    in GCP.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 – deploying PostgreSQL on GCP
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use Google Cloud SQL to deploy PostgreSQL on GCP. Follow these steps
    to deploy PostgreSQL on GCP:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Cloud SQL instance in the GCP console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose PostgreSQL as the database engine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose the desired region and configure the instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new user and database for the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up the connection to the PostgreSQL instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Step 2 – exporting PostgreSQL metrics
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the `pg_prometheus` extension to export PostgreSQL metrics to Prometheus.
    Follow these steps to export PostgreSQL metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the `pg_prometheus` extension on the PostgreSQL instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable the `pg_prometheus` extension in the PostgreSQL instance.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the `pg_prometheus` extension to expose the PostgreSQL metrics using
    an HTTP endpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s an example of how to enable the `pg_prometheus` extension:'
  prefs: []
  type: TYPE_NORMAL
- en: SQL
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example of how to configure the `pg_prometheus` extension to expose
    the PostgreSQL metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Step 3 – collecting PostgreSQL metrics
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use Prometheus to collect PostgreSQL metrics from the `pg_prometheus`
    extension. Follow these steps to collect PostgreSQL metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: Install Prometheus on GCP.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure Prometheus to scrape metrics from the `pg_prometheus` extension using
    an HTTP endpoint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s an example of how to configure Prometheus to scrape metrics from the
    `pg_prometheus` extension:'
  prefs: []
  type: TYPE_NORMAL
- en: YAML
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Step 4 – setting up Prometheus alerts
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use Prometheus to set up alerts based on the collected PostgreSQL metrics.
    Follow these steps to set up Prometheus alerts:'
  prefs: []
  type: TYPE_NORMAL
- en: Define alert rules in Prometheus.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reload the Prometheus configuration to apply the new alert rules.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s an example of how to define an alert rule in Prometheus:'
  prefs: []
  type: TYPE_NORMAL
- en: YAML
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are defining an alert rule named `High CPU usage` that triggers
    a warning when the sum of the rate of CPU usage for PostgreSQL instances is greater
    than 80% over a 5-minute window. The alert has a severity label of `warning` and
    includes annotations for the alert summary and description.
  prefs: []
  type: TYPE_NORMAL
- en: 'To reload the Prometheus configuration, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: Bash
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Step 5 – sending alerts to a notification channel
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use Alertmanager to send alerts to a notification channel, such as
    email or Slack. Follow these steps to set up Alertmanager:'
  prefs: []
  type: TYPE_NORMAL
- en: Install Alertmanager on GCP.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure Alertmanager to send alerts to a notification channel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here’s an example of how to configure Alertmanager to send alerts to an email
    address:'
  prefs: []
  type: TYPE_NORMAL
- en: YAML
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are configuring Alertmanager to send alerts with a severity
    label of `warning` to an email address. We are specifying the email address to
    send the alerts to, as well as the email address and credentials to use for authentication.
  prefs: []
  type: TYPE_NORMAL
- en: Conclusion
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, setting up PostgreSQL alarms using Prometheus in GCP requires
    deploying PostgreSQL on GCP, exporting PostgreSQL metrics using the `pg_prometheus`
    extension, collecting PostgreSQL metrics using Prometheus, setting up Prometheus
    alerts based on the collected PostgreSQL metrics, and sending alerts to a notification
    channel using Alertmanager. With this architecture, you can monitor and alert
    on PostgreSQL metrics in real time, ensuring the availability and performance
    of your PostgreSQL database.
  prefs: []
  type: TYPE_NORMAL
- en: Investigating Oracle Database issues using Jenkins
  prefs: []
  type: TYPE_NORMAL
- en: Investigating Oracle Database issues can be a challenging task for database
    administrators. It involves monitoring and analyzing the database’s performance,
    identifying bottlenecks, and taking corrective actions to optimize the system.
    One way to automate this process is by using Jenkins, an open source automation
    server that enables developers to automate tasks related to building, testing,
    and deploying software.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will explore how to use Jenkins to investigate Oracle Database
    issues by setting up a Jenkins pipeline that performs the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Connects to Oracle Database using JDBC
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Executes a SQL query to retrieve performance data
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Analyzes the data and generates a report
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sends an email notification to the database administrator if any issues are
    found
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Architecture
  prefs: []
  type: TYPE_NORMAL
- en: 'The architecture of the solution involves several components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jenkins server**: This is where the Jenkins pipeline is executed. It runs
    on a separate machine from Oracle Database to avoid interfering with the database’s
    performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Oracle Database**: This is the database being monitored for performance issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JDBC driver**: This is the driver that’s used by the pipeline to connect
    to the Oracle Database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SQL query**: This is the query that’s executed by the pipeline to retrieve
    performance data from the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Python script**: This is a script that analyzes the data retrieved by the
    SQL query and generates a report.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Email server**: This is the server that’s used by the pipeline to send email
    notifications to the database administrator.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The pipeline is triggered either manually or automatically by a scheduler. When
    it runs, it first connects to Oracle Database using the JDBC driver. Then, it
    executes the SQL query to retrieve performance data. The data is then analyzed
    by the Python script, which generates a report. If any issues are found, the pipeline
    sends an email notification to the database administrator.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins pipeline code
  prefs: []
  type: TYPE_NORMAL
- en: 'The Jenkins pipeline code is written in Groovy, a scripting language that runs
    on Java Virtual Machine. Here is an example of what the code might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: Groovy
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This pipeline consists of four stages, each of which has one or more steps.
    The `agent any` directive specifies that the pipeline can run on any available
    agent (machine).
  prefs: []
  type: TYPE_NORMAL
- en: The first stage, `Connect to Oracle Database`, sets up the JDBC connection to
    Oracle Database. The `jdbcUrl`, `dbUser`, and `dbPassword` variables are used
    to specify the connection details. The `DriverManager` class is used to register
    the JDBC driver and obtain a connection to the database. The resulting connection
    object is saved as an environment variable for later stages to use.
  prefs: []
  type: TYPE_NORMAL
- en: The second stage, `Retrieve Performance Data`, executes a SQL query to retrieve
    performance data from the database. The `sqlQuery` variable specifies the query
    to be executed. The resulting result set is saved as an environment variable for
    later stages to use.
  prefs: []
  type: TYPE_NORMAL
- en: The third stage, `Generate Performance Report`, uses a Python script to analyze
    the performance data and generate a report. The `perfData` variable is used to
    pass the result set to the `generateReport` function. The resulting report is
    saved as an environment variable for later stages to use.
  prefs: []
  type: TYPE_NORMAL
- en: The final stage, `Send Email Notification`, checks if the report has any issues
    and sends an email notification to the database administrator if it does. The
    `hasIssues` function is used to determine if the report has any issues. If it
    does, the `sendEmailNotification` function is called to send an email notification.
  prefs: []
  type: TYPE_NORMAL
- en: The `post` section contains a cleanup step that always runs, regardless of the
    outcome of the pipeline. In this case, it closes the database connection that
    was opened in the first stage.
  prefs: []
  type: TYPE_NORMAL
- en: Python script
  prefs: []
  type: TYPE_NORMAL
- en: 'The Python script that’s used to analyze the performance data and generate
    a report might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Python
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This script uses the `pandas` library to load the performance data into a `DataFrame`
    object. The `timestamp` column is converted into a datetime object and used as
    the index. The script then analyzes the data and generates a report if any issues
    are found. In this example, the script checks for high CPU, memory, and disk usage.
  prefs: []
  type: TYPE_NORMAL
- en: Email notification
  prefs: []
  type: TYPE_NORMAL
- en: 'The email notification is sent using the Jenkins Email Extension plugin, which
    allows emails to be sent with customizable content and attachments. Here is an
    example of what the email notification might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: Groovy
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This code uses the `emailext` function to send an email notification to the
    developer’s recipient provider, which is defined in the Jenkins configuration.
    The `subject` parameter specifies the subject of the email, and the `attachmentsPattern`
    parameter specifies a file pattern that matches the CSV report file generated
    by the Python script.
  prefs: []
  type: TYPE_NORMAL
- en: The `reportToString` function is used to convert the report generated by the
    Python script into a string that can be used as the body of the email. If no issues
    are found, it returns a message indicating that no performance issues were found.
    If issues are found, it formats the report as a list of bullet points.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we have seen how Jenkins can be used to automate the process
    of investigating Oracle Database issues. The pipeline connects to the database
    using JDBC, retrieves performance data using a SQL query, analyzes the data using
    a Python script, and sends email notifications to the database administrator if
    any issues are found. The architecture consists of several components, including
    the Jenkins server, the Oracle Database, the JDBC driver, the SQL query, the Python
    script, and the email server. The pipeline code is written in Groovy, and the
    email notification is sent using the Jenkins Email Extension plugin. By automating
    this process, database administrators can save time and improve the performance
    of their Oracle databases.
  prefs: []
  type: TYPE_NORMAL
- en: Backup and disaster recovery
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring that relational databases are backed up and can be recovered in the
    event of a disaster is another critical activity for a DevOps team. This includes
    setting up backup and recovery processes, testing backups, and performing disaster
    recovery exercises. Let’s look at examples of how this can be accomplished.
  prefs: []
  type: TYPE_NORMAL
- en: Creating MySQL backups using Ansible
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we dive into the technical details and code, let’s discuss the architecture
    that we’ll be using in this example. The basic architecture consists of three
    components: the MySQL database, the backup server, and the Ansible controller.'
  prefs: []
  type: TYPE_NORMAL
- en: The MySQL database is the data source that we want to back up. We assume that
    it’s already installed and configured properly on its own server.
  prefs: []
  type: TYPE_NORMAL
- en: The backup server is where we’ll store the backup files. It should have enough
    disk space to accommodate the backups.
  prefs: []
  type: TYPE_NORMAL
- en: The Ansible controller is the machine from which we’ll execute Ansible playbooks.
    This machine should have Ansible installed and configured to connect to the MySQL
    database server and the backup server.
  prefs: []
  type: TYPE_NORMAL
- en: With this architecture in place, we can proceed to create a playbook that performs
    MySQL backups.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example playbook that you can use:'
  prefs: []
  type: TYPE_NORMAL
- en: YAML
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s go through this playbook step by step:'
  prefs: []
  type: TYPE_NORMAL
- en: The first section defines some basic information about the playbook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `hosts` variable specifies the hosts that we want to run the playbook on.
    In this case, we assume that we have a group called `mysql_servers` that contains
    the MySQL database server(s).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `become` variable tells Ansible to run the playbook as the root user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `vars` section defines some variables that we’ll use later in the playbook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `backup_dir` variable specifies the directory where we want to store the
    backups.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `mysql_user` and `mysql_password` variables specify the username and password
    that Ansible will use to connect to the MySQL database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, the `mysql_databases` variable lists the databases that we want to
    back up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first task creates the backup directory if it doesn’t already exist. We
    use the `file` module to create the directory with the appropriate permissions.
  prefs: []
  type: TYPE_NORMAL
- en: The second task performs the actual backup. We use the `mysql_db_backup` module
    to connect to the MySQL database and create a backup of each database in the `mysql_databases`
    variable. We specify the backup directory using the `backup_dir` variable, and
    we set the backup type to `database`.
  prefs: []
  type: TYPE_NORMAL
- en: The third task compresses the backup files using the `tar` command. We use the
    `command` module to execute the `tar` command with the appropriate arguments.
    The `chdir` argument tells `tar` to change to the backup directory before compressing
    the files. We use the `with_items` variable to loop over each database in the
    `mysql_databases` variable and compress the corresponding backup file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have a playbook, we need to create an inventory file that tells
    Ansible about our servers. Here is an example inventory file:'
  prefs: []
  type: TYPE_NORMAL
- en: Inventory
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have one MySQL database server called `mysql.example.com`
    and one backup server called `backup.example.com`. You can modify this file to
    match your own server names and IP addresses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to create a configuration file for Ansible. Here is an example
    configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuration file
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This file specifies the location of our inventory file and sets the remote user
    to `root`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our playbook, inventory file, and configuration file, we can
    run the playbook using the `ansible-playbook` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: +--------------------------+
  prefs: []
  type: TYPE_NORMAL
- en: '|  PostgreSQL Production   |'
  prefs: []
  type: TYPE_NORMAL
- en: +--------------------------+
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: +-----------------+
  prefs: []
  type: TYPE_NORMAL
- en: '|  pg_dump Backup  |'
  prefs: []
  type: TYPE_NORMAL
- en: +-----------------+
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: +-----------------+
  prefs: []
  type: TYPE_NORMAL
- en: '|   S3 Bucket     |'
  prefs: []
  type: TYPE_NORMAL
- en: +-----------------+
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: +-----------------+
  prefs: []
  type: TYPE_NORMAL
- en: '|   Chef Server   |'
  prefs: []
  type: TYPE_NORMAL
- en: +-----------------+
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: +-----------------+
  prefs: []
  type: TYPE_NORMAL
- en: '|   Chef Client   |'
  prefs: []
  type: TYPE_NORMAL
- en: +-----------------+
  prefs: []
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: +-----------------+
  prefs: []
  type: TYPE_NORMAL
- en: '|     Results     |'
  prefs: []
  type: TYPE_NORMAL
- en: +-----------------+
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Install the aws-sdk-s3 gem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: chef_gem 'aws-sdk-s3' do
  prefs: []
  type: TYPE_NORMAL
- en: compile_time true
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: Download the latest backup from the S3 bucket
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 's3 = Aws::S3::Client.new(region: ''us-west-2'')'
  prefs: []
  type: TYPE_NORMAL
- en: bucket_name = 'my-backup-bucket'
  prefs: []
  type: TYPE_NORMAL
- en: backup_prefix = 'postgresql-backups/'
  prefs: []
  type: TYPE_NORMAL
- en: 'latest_backup = s3.list_objects_v2(bucket: bucket_name, prefix: backup_prefix).contents.sort_by(&:last_modified).last.key'
  prefs: []
  type: TYPE_NORMAL
- en: local_backup_path = "/tmp/#{File.basename(latest_backup)}"
  prefs: []
  type: TYPE_NORMAL
- en: FileUtils.mkdir_p(File.dirname(local_backup_path))
  prefs: []
  type: TYPE_NORMAL
- en: File.open(local_backup_path, 'wb') do |file|
  prefs: []
  type: TYPE_NORMAL
- en: 's3.get_object(bucket: bucket_name, key: latest_backup) do |chunk|'
  prefs: []
  type: TYPE_NORMAL
- en: file.write(chunk)
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Verify the integrity of the backup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'cmd = "pg_restore --list #{local_backup_path} > /dev/null"'
  prefs: []
  type: TYPE_NORMAL
- en: system(cmd)
  prefs: []
  type: TYPE_NORMAL
- en: if $?.exitstatus != 0
  prefs: []
  type: TYPE_NORMAL
- en: 'Chef::Log.error("Backup file #{local_backup_path} is invalid!")'
  prefs: []
  type: TYPE_NORMAL
- en: 'raise "Backup file #{local_backup_path} is invalid!"'
  prefs: []
  type: TYPE_NORMAL
- en: else
  prefs: []
  type: TYPE_NORMAL
- en: 'Chef::Log.info("Backup file #{local_backup_path} is valid.")'
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Report the results to the Chef server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: chef_gem 'chef-handler-sns' do
  prefs: []
  type: TYPE_NORMAL
- en: compile_time true
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: require 'chef/handler/sns'
  prefs: []
  type: TYPE_NORMAL
- en: Chef::Config[:s3_backup_test_topic_arn] = 'arn:aws:sns:us-west-2:123456789012:s3-backup-test-results'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chef::Config[:s3_backup_test_subject] = "PostgreSQL backup test results for
    #{node[''hostname'']}"'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chef::Config[:s3_backup_test_body] = "Backup file #{local_backup_path} is valid."'
  prefs: []
  type: TYPE_NORMAL
- en: Chef::Config[:s3_backup_test_aws_access_key_id] = 'my-access-key'
  prefs: []
  type: TYPE_NORMAL
- en: Chef::Config[:s3_backup_test_aws_secret_access_key] = 'my-secret-key'
  prefs: []
  type: TYPE_NORMAL
- en: Chef::Config[:s3_backup_test_aws_region] = 'us-west-2'
  prefs: []
  type: TYPE_NORMAL
- en: chef_handler 'Chef::Handler::SNS' do
  prefs: []
  type: TYPE_NORMAL
- en: source 'chef/handler/sns'
  prefs: []
  type: TYPE_NORMAL
- en: arguments [Chef::Config[:s3_backup_test_topic_arn], {
  prefs: []
  type: TYPE_NORMAL
- en: 'subject: Chef::Config[:s3_backup_test_subject],'
  prefs: []
  type: TYPE_NORMAL
- en: 'message: Chef::Config[:s3_backup_test_body],'
  prefs: []
  type: TYPE_NORMAL
- en: 'access_key_id: Chef::Config[:s3_backup_test_aws_access_key_id],'
  prefs: []
  type: TYPE_NORMAL
- en: 'secret_access_key: Chef::Config[:s3_backup_test_aws_secret_access_key],'
  prefs: []
  type: TYPE_NORMAL
- en: 'region: Chef::Config[:s3_backup_test_aws_region],'
  prefs: []
  type: TYPE_NORMAL
- en: '}]'
  prefs: []
  type: TYPE_NORMAL
- en: action :enable
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: class oracle_production {
  prefs: []
  type: TYPE_NORMAL
- en: 'service { ''oracle'':'
  prefs: []
  type: TYPE_NORMAL
- en: ensure => stopped,
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: class oracle_production {
  prefs: []
  type: TYPE_NORMAL
- en: 'exec { ''backup'':'
  prefs: []
  type: TYPE_NORMAL
- en: command => '/usr/local/bin/backup.sh',
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: class oracle_production {
  prefs: []
  type: TYPE_NORMAL
- en: 'file { ''/mnt/backups'':'
  prefs: []
  type: TYPE_NORMAL
- en: ensure => directory,
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'file { ''/mnt/backups/backup.tar.gz'':'
  prefs: []
  type: TYPE_NORMAL
- en: source => '/path/to/backup.tar.gz',
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'exec { ''copy_backup'':'
  prefs: []
  type: TYPE_NORMAL
- en: command => '/usr/bin/scp /mnt/backups/backup.tar.gz user@disaster-recovery:/mnt/backups/',
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: provider "aws" {
  prefs: []
  type: TYPE_NORMAL
- en: region = "us-west-2"
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: resource "aws_db_instance" "mysql" {
  prefs: []
  type: TYPE_NORMAL
- en: allocated_storage    = 100
  prefs: []
  type: TYPE_NORMAL
- en: engine               = "mysql"
  prefs: []
  type: TYPE_NORMAL
- en: engine_version       = "5.7"
  prefs: []
  type: TYPE_NORMAL
- en: instance_class       = "db.t2.micro"
  prefs: []
  type: TYPE_NORMAL
- en: name                 = "mydb"
  prefs: []
  type: TYPE_NORMAL
- en: username             = "admin"
  prefs: []
  type: TYPE_NORMAL
- en: password             = "password"
  prefs: []
  type: TYPE_NORMAL
- en: parameter_group_name = "default.mysql5.7"
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: resource "aws_db_parameter_group" "mysql" {
  prefs: []
  type: TYPE_NORMAL
- en: name_prefix = "mysql-"
  prefs: []
  type: TYPE_NORMAL
- en: family      = "mysql5.7"
  prefs: []
  type: TYPE_NORMAL
- en: parameter {
  prefs: []
  type: TYPE_NORMAL
- en: name  = "innodb_buffer_pool_size"
  prefs: []
  type: TYPE_NORMAL
- en: 'value = "5368709120" # 5 GB'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: parameter {
  prefs: []
  type: TYPE_NORMAL
- en: name  = "max_connections"
  prefs: []
  type: TYPE_NORMAL
- en: value = "100"
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: resource "aws_rds_cluster_instance" "mysql" {
  prefs: []
  type: TYPE_NORMAL
- en: count              = 1
  prefs: []
  type: TYPE_NORMAL
- en: identifier         = "mydb-${count.index + 1}"
  prefs: []
  type: TYPE_NORMAL
- en: db_subnet_group_name = "${aws_db_subnet_group.mysql.name}"
  prefs: []
  type: TYPE_NORMAL
- en: cluster_identifier   = "${aws_rds_cluster.mysql.id}"
  prefs: []
  type: TYPE_NORMAL
- en: instance_class       = "db.t2.micro"
  prefs: []
  type: TYPE_NORMAL
- en: engine               = "mysql"
  prefs: []
  type: TYPE_NORMAL
- en: engine_version       = "5.7"
  prefs: []
  type: TYPE_NORMAL
- en: db_parameter_group_name = "${aws_db_parameter_group.mysql.name}"
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '---'
  prefs: []
  type: TYPE_NORMAL
- en: '- name: Optimize PostgreSQL Queries'
  prefs: []
  type: TYPE_NORMAL
- en: 'hosts: dbserver'
  prefs: []
  type: TYPE_NORMAL
- en: 'become: yes'
  prefs: []
  type: TYPE_NORMAL
- en: 'vars:'
  prefs: []
  type: TYPE_NORMAL
- en: 'database_name: mydatabase'
  prefs: []
  type: TYPE_NORMAL
- en: 'database_user: myuser'
  prefs: []
  type: TYPE_NORMAL
- en: 'database_password: mypassword'
  prefs: []
  type: TYPE_NORMAL
- en: 'tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '- name: Install PostgreSQL client'
  prefs: []
  type: TYPE_NORMAL
- en: 'apt:'
  prefs: []
  type: TYPE_NORMAL
- en: 'name: postgresql-client'
  prefs: []
  type: TYPE_NORMAL
- en: 'state: present'
  prefs: []
  type: TYPE_NORMAL
- en: '- name: Check query execution time'
  prefs: []
  type: TYPE_NORMAL
- en: 'shell: |'
  prefs: []
  type: TYPE_NORMAL
- en: psql -d {{ database_name }} -U {{ database_user }} -c "EXPLAIN ANALYZE SELECT
    * FROM mytable WHERE id = 1234;"
  prefs: []
  type: TYPE_NORMAL
- en: 'register: query_output'
  prefs: []
  type: TYPE_NORMAL
- en: '- name: Show query plan'
  prefs: []
  type: TYPE_NORMAL
- en: 'debug:'
  prefs: []
  type: TYPE_NORMAL
- en: 'var: query_output.stdout_lines'
  prefs: []
  type: TYPE_NORMAL
- en: '- name: Create index on id column'
  prefs: []
  type: TYPE_NORMAL
- en: 'shell: |'
  prefs: []
  type: TYPE_NORMAL
- en: psql -d {{ database_name }} -U {{ database_user }} -c "CREATE INDEX ON mytable
    (id);"
  prefs: []
  type: TYPE_NORMAL
- en: '- name: Check query execution time with index'
  prefs: []
  type: TYPE_NORMAL
- en: 'shell: |'
  prefs: []
  type: TYPE_NORMAL
- en: psql -d {{ database_name }} -U {{ database_user }} -c "EXPLAIN ANALYZE SELECT
    * FROM mytable WHERE id = 1234;"
  prefs: []
  type: TYPE_NORMAL
- en: 'register: query_output_index'
  prefs: []
  type: TYPE_NORMAL
- en: '- name: Show optimized query plan'
  prefs: []
  type: TYPE_NORMAL
- en: 'debug:'
  prefs: []
  type: TYPE_NORMAL
- en: 'var: query_output_index.stdout_lines'
  prefs: []
  type: TYPE_NORMAL
- en: '- name: Vacuum analyze the table'
  prefs: []
  type: TYPE_NORMAL
- en: 'shell: |'
  prefs: []
  type: TYPE_NORMAL
- en: psql -d {{ database_name }} -U {{ database_user }} -c "VACUUM ANALYZE mytable;"
  prefs: []
  type: TYPE_NORMAL
- en: '- name: Show table statistics'
  prefs: []
  type: TYPE_NORMAL
- en: 'shell: |'
  prefs: []
  type: TYPE_NORMAL
- en: psql -d {{ database_name }} -U {{ database_user }} -c "SELECT relname, n_live_tup,
    n_dead_tup, last_vacuum, last_autovacuum, last_analyze, last_autoanalyze FROM
    pg_stat_user_tables WHERE relname = 'mytable';"
  prefs: []
  type: TYPE_NORMAL
- en: 'register: table_stats'
  prefs: []
  type: TYPE_NORMAL
- en: '- name: Show table statistics output'
  prefs: []
  type: TYPE_NORMAL
- en: 'debug:'
  prefs: []
  type: TYPE_NORMAL
- en: 'var: table_stats.stdout_lines'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '- name: Install packages'
  prefs: []
  type: TYPE_NORMAL
- en: 'become: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'apt:'
  prefs: []
  type: TYPE_NORMAL
- en: 'name:'
  prefs: []
  type: TYPE_NORMAL
- en: '- openssl'
  prefs: []
  type: TYPE_NORMAL
- en: '- python3-certbot'
  prefs: []
  type: TYPE_NORMAL
- en: '- python3-certbot-apache'
  prefs: []
  type: TYPE_NORMAL
- en: 'state: present'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '- name: Generate SSL/TLS certificates and keys'
  prefs: []
  type: TYPE_NORMAL
- en: 'become: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'openssl_certificate:'
  prefs: []
  type: TYPE_NORMAL
- en: 'path: /etc/mysql/ssl/ca.pem'
  prefs: []
  type: TYPE_NORMAL
- en: 'privatekey_path: /etc/mysql/ssl/ca.key'
  prefs: []
  type: TYPE_NORMAL
- en: 'common_name: "My CA"'
  prefs: []
  type: TYPE_NORMAL
- en: 'owner: root'
  prefs: []
  type: TYPE_NORMAL
- en: 'group: root'
  prefs: []
  type: TYPE_NORMAL
- en: 'mode: 0600'
  prefs: []
  type: TYPE_NORMAL
- en: 'self_signed: yes'
  prefs: []
  type: TYPE_NORMAL
- en: 'type: CA'
  prefs: []
  type: TYPE_NORMAL
- en: 'register: ca_cert'
  prefs: []
  type: TYPE_NORMAL
- en: '- openssl_certificate:'
  prefs: []
  type: TYPE_NORMAL
- en: 'path: /etc/mysql/ssl/server.pem'
  prefs: []
  type: TYPE_NORMAL
- en: 'privatekey_path: /etc/mysql/ssl/server.key'
  prefs: []
  type: TYPE_NORMAL
- en: 'common_name: "{{ inventory_hostname }}"'
  prefs: []
  type: TYPE_NORMAL
- en: 'owner: root'
  prefs: []
  type: TYPE_NORMAL
- en: 'group: root'
  prefs: []
  type: TYPE_NORMAL
- en: 'mode: 0600'
  prefs: []
  type: TYPE_NORMAL
- en: 'ca_path: /etc/mysql/ssl/ca.pem'
  prefs: []
  type: TYPE_NORMAL
- en: 'ca_privatekey_path: /etc/mysql/ssl/ca.key'
  prefs: []
  type: TYPE_NORMAL
- en: 'ca_common_name: "My CA"'
  prefs: []
  type: TYPE_NORMAL
- en: 'type: server'
  prefs: []
  type: TYPE_NORMAL
- en: 'register: server_cert'
  prefs: []
  type: TYPE_NORMAL
- en: '- openssl_certificate:'
  prefs: []
  type: TYPE_NORMAL
- en: 'path: /etc/mysql/ssl/client.pem'
  prefs: []
  type: TYPE_NORMAL
- en: 'privatekey_path: /etc/mysql/ssl/client.key'
  prefs: []
  type: TYPE_NORMAL
- en: 'common_name: "MySQL Client"'
  prefs: []
  type: TYPE_NORMAL
- en: 'owner: root'
  prefs: []
  type: TYPE_NORMAL
- en: 'group: root'
  prefs: []
  type: TYPE_NORMAL
- en: 'mode: 0600'
  prefs: []
  type: TYPE_NORMAL
- en: 'ca_path: /etc/mysql/ssl/ca.pem'
  prefs: []
  type: TYPE_NORMAL
- en: 'ca_privatekey_path: /etc/mysql/ssl/ca.key'
  prefs: []
  type: TYPE_NORMAL
- en: 'ca_common_name: "My CA"'
  prefs: []
  type: TYPE_NORMAL
- en: 'type: client'
  prefs: []
  type: TYPE_NORMAL
- en: 'register: client_cert'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '- name: Configure MySQL to use SSL/TLS encryption and mutual authentication'
  prefs: []
  type: TYPE_NORMAL
- en: 'become: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'template:'
  prefs: []
  type: TYPE_NORMAL
- en: 'src: templates/my.cnf.j2'
  prefs: []
  type: TYPE_NORMAL
- en: 'dest: /etc/mysql/my.cnf'
  prefs: []
  type: TYPE_NORMAL
- en: 'notify: restart mysql'
  prefs: []
  type: TYPE_NORMAL
- en: '- name: Set permissions for SSL/TLS certificates and keys'
  prefs: []
  type: TYPE_NORMAL
- en: 'become: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'file:'
  prefs: []
  type: TYPE_NORMAL
- en: 'path: "{{ item.path }}"'
  prefs: []
  type: TYPE_NORMAL
- en: 'owner: root'
  prefs: []
  type: TYPE_NORMAL
- en: 'group: root'
  prefs: []
  type: TYPE_NORMAL
- en: 'mode: 0600'
  prefs: []
  type: TYPE_NORMAL
- en: 'with_items:'
  prefs: []
  type: TYPE_NORMAL
- en: '- "{{ ca_cert }}"'
  prefs: []
  type: TYPE_NORMAL
- en: '- "{{ server_cert }}"'
  prefs: []
  type: TYPE_NORMAL
- en: '- "{{ client_cert }}"'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '- name: Configure Certbot to obtain and renew SSL/TLS certificates'
  prefs: []
  type: TYPE_NORMAL
- en: 'become: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'template:'
  prefs: []
  type: TYPE_NORMAL
- en: 'src: templates/certbot.ini.j2'
  prefs: []
  type: TYPE_NORMAL
- en: 'dest: /etc/letsencrypt/cli.ini'
  prefs: []
  type: TYPE_NORMAL
- en: '- name: Obtain SSL/TLS certificate from Let''s Encrypt'
  prefs: []
  type: TYPE_NORMAL
- en: 'become: true'
  prefs: []
  type: TYPE_NORMAL
- en: 'shell: certbot certonly --non-interactive --agree-tos --email admin@example.com
    --apache --domain example.com --domain www.example.com'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Recipe to install PostgreSQL on the server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '#'
  prefs: []
  type: TYPE_NORMAL
- en: package 'postgresql'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Recipe to create a PostgreSQL user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '#'
  prefs: []
  type: TYPE_NORMAL
- en: execute 'create_postgres_user' do
  prefs: []
  type: TYPE_NORMAL
- en: user 'postgres'
  prefs: []
  type: TYPE_NORMAL
- en: 'command "psql -c \"CREATE USER #{node[''postgresql''][''user'']} WITH PASSWORD
    #{node[''postgresql''][''password'']};\""'
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Recipe to grant permissions to a PostgreSQL user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '#'
  prefs: []
  type: TYPE_NORMAL
- en: execute 'grant_postgres_user_permissions' do
  prefs: []
  type: TYPE_NORMAL
- en: user 'postgres'
  prefs: []
  type: TYPE_NORMAL
- en: 'command "psql -c \"GRANT ALL PRIVILEGES ON DATABASE #{node[''postgresql''][''database'']}
    TO #{node[''postgresql''][''user'']};\""'
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Recipe to revoke permissions from a PostgreSQL user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '#'
  prefs: []
  type: TYPE_NORMAL
- en: execute 'revoke_postgres_user_permissions' do
  prefs: []
  type: TYPE_NORMAL
- en: user 'postgres'
  prefs: []
  type: TYPE_NORMAL
- en: 'command "psql -c \"REVOKE ALL PRIVILEGES ON DATABASE #{node[''postgresql''][''database'']}
    FROM #{node[''postgresql''][''user'']};\""'
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Recipe to delete a PostgreSQL user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '#'
  prefs: []
  type: TYPE_NORMAL
- en: execute 'delete_postgres_user' do
  prefs: []
  type: TYPE_NORMAL
- en: user 'postgres'
  prefs: []
  type: TYPE_NORMAL
- en: 'command "psql -c \"DROP ROLE IF EXISTS #{node[''postgresql''][''user'']};\""'
  prefs: []
  type: TYPE_NORMAL
- en: end
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: class oracle_security {
  prefs: []
  type: TYPE_NORMAL
- en: 'package { ''oracle_security_patches'':'
  prefs: []
  type: TYPE_NORMAL
- en: ensure => latest,
  prefs: []
  type: TYPE_NORMAL
- en: provider => 'yum',
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: sudo puppet agent -t
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Info: Applying configuration version ''1474461465'''
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice: /Stage[main]/Oracle_security/Package[oracle_security_patches]/ensure:
    ensure changed ''1.0.0-1'' to ''1.1.0-1'''
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
