- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing a Robust Mobile App Testing Strategy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed in the previous chapters, mobile applications have become integral
    to our daily lives. With the proliferation of smartphones and tablets, developing
    and delivering mobile apps that provide a seamless user experience across different
    devices and platforms has become essential. Mobile app testing involves testing
    different aspects of the application, including its functionality, performance,
    security, usability, and compatibility. In addition, testing should be done on
    various devices, operating systems, and network configurations to ensure the app
    works seamlessly across all possible scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: It cannot be argued that mobile app testing plays a critical role in ensuring
    the application performs well, booms, and has a positive user experience. By investing
    time and resources into testing, developers are more likely to develop responsive
    applications and deliver exceptional user experiences.
  prefs: []
  type: TYPE_NORMAL
- en: Test automation for mobile apps in Mobile DevOps is like the wheels on a car
    – it provides the necessary traction for driving the project forward efficiently
    and with minimal risk. With it, you will find yourself able to reach your destination.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, developing and testing mobile apps can be challenging due to the diverse
    range of devices, operating systems, and network configurations. In this chapter,
    we will discuss how to implement a robust mobile app testing strategy that can
    help you deliver high-quality mobile apps, including the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding mobile app testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The importance of test automation for mobile apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mobile app testing challenges and pitfalls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a mobile app testing strategy?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing tools, frameworks, and services for mobile apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mobile app UI and functionality testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing on cloud devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How AI and ML are changing mobile testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test case management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Achieving successful mobile test coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s begin by understanding more about mobile app testing.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding mobile app testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mobile app testing involves testing different aspects of the application, including
    functionality, performance, security, usability, and compatibility. In addition,
    testing should be done on various devices, operating systems, and network configurations
    to ensure the app works seamlessly across all possible scenarios. Mobile apps
    should be tested before and after they have been launched to identify and fix
    any bugs and new features that might improve the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s discuss the different testing levels in software development and
    mobile development specifically.
  prefs: []
  type: TYPE_NORMAL
- en: Testing levels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The field of software development is constantly evolving, particularly in the
    realm of mobile development. This is because we are always striving to introduce
    new and improved features and technologies that can better assist our customers
    in their daily tasks. Therefore, all mobile developers need to adopt testing as
    a necessary practice to ensure that all functionalities are performing as intended.
  prefs: []
  type: TYPE_NORMAL
- en: There are various types of testing, each with its own scope. Typically, we categorize
    these types using the test pyramid as a reference.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These are tests that focus on individual components that have a single responsibility.
    Essentially, this is the lowest level of testing. In this level of testing, the
    developer asserts a set of conditions that must be true, along with some that
    need to be false.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine we are developing a calculator app – the developer will assert what
    will happen when we click on the plus (+) button, and the expected results will
    be narrowly defined.
  prefs: []
  type: TYPE_NORMAL
- en: As a unit of code, unit testing cannot detect integration errors or system-level
    errors, which are covered in integration and **end to end** (**E2E**) testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to verifying different aspects of a program, unit testing can
    be used in various ways to find the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The expected cases or “happy paths”
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The edge cases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The boundary conditions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The program’s logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In iOS, we can use the **XCTest** framework to write unit tests for our Xcode
    projects that integrate seamlessly with Xcode’s testing workflow.
  prefs: []
  type: TYPE_NORMAL
- en: In Android, unit tests are compiled to execute on the **Java Virtual Machine**
    (**JVM**) to reduce the amount of time it takes. If your tests rely on objects
    within the Android framework, you can use the **Robolectric** ([https://robolectric.org/](https://robolectric.org/))
    tool. In cases where your tests depend on your dependencies, mock objects can
    be utilized to emulate the expected behavior of those dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: In Flutter, a unit test can be written using the `test` package, and a widget
    can be tested using the `flutter_test` package.
  prefs: []
  type: TYPE_NORMAL
- en: In React Native, developers use testing frameworks such as **Jest** ([https://jestjs.io/](https://jestjs.io/))
    and testing utilities such as **React Testing Library** ([https://testing-library.com/docs/react-testing-library/intro/](https://testing-library.com/docs/react-testing-library/intro/))
    to facilitate unit testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to writing efficient unit tests, there are certain criteria to
    keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Tests should be fast and efficient.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests must be fully automated and should only indicate “pass” or “fail” outcomes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tests should be independent and isolated from one another, meaning they should
    not share states.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is advisable to write tests before writing the production code. This is known
    as **test-driven** **development** (**TDD**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unit testing and code coverage
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The purpose of code coverage testing is to determine how much code is being
    tested. The following formula can be used to calculate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the different techniques for code coverage that are utilized in unit
    testing:'
  prefs: []
  type: TYPE_NORMAL
- en: Statement coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decision coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Branch coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Condition coverage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also different code coverage tools, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JaCoCo** ([https://docs.gradle.org/current/userguide/jacoco_plugin.html](https://docs.gradle.org/current/userguide/jacoco_plugin.html))
    can generate an HTML report for your Android unit tests and integrate it with
    your continuous integration server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flutter Console Coverage Test** ([https://pub.dev/packages/test_cov_console](https://pub.dev/packages/test_cov_console))
    is a Dart tool that’s used to generate a Flutter Coverage Test report.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**dlcov** ([https://pub.dev/packages/dlcov](https://pub.dev/packages/dlcov))
    is a CLI that’s used to verify the code coverage threshold.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SonarQube** ([https://www.sonarsource.com/products/sonarqube/](https://www.sonarsource.com/products/sonarqube/))
    integrates with various build systems and supports Android projects. It provides
    a comprehensive quality analysis platform that includes code coverage metrics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Codecov** ([https://about.codecov.io/](https://about.codecov.io/)) is a service
    that provides code coverage solutions for various programming languages, including
    mobile app development platforms. It can integrate with your CI/CD pipeline to
    gather and display coverage reports.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another technique can be used alongside unit testing to improve the quality
    of a code base: **TDD**. Let’s explore the concept and its benefits.'
  prefs: []
  type: TYPE_NORMAL
- en: Test-driven development
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'TDD is an approach to testing that differs from traditional methods. Instead
    of waiting until the code or feature is fully developed to test it, TDD involves
    creating tests based on the feature requirements and then writing code to ensure
    the tests pass, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – How TDD works](img/Figure_05.01_B18113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – How TDD works
  prefs: []
  type: TYPE_NORMAL
- en: Using TDD is an incredibly valuable technique for improving the internal quality
    of your code base. It also serves as a great tool for training yourself and your
    team to design better software in a disciplined manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an overview of the TDD process and how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a test. In this stage, the developers create tests for each functionality
    they want to add. These tests serve as requirements that the new code must meet
    and writing them first ensures that developers consider potential issues before
    writing any code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the test and intentionally cause it to fail. This step confirms that the
    test is valid and that new code is necessary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write code that passes the failed test. While the code may not be perfect, it
    must meet the test requirements. If it fails, the code must be revised until it
    passes and ensures that the new code does not break any existing features.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refactor the code for better readability and maintainability. Running tests
    at this stage ensures that the functionality is preserved.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat the process from *Step 1* for each piece of functionality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of TDD?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: By writing tests before writing code, TDD challenges us to think more clearly
    and critically about the problem we are trying to solve.
  prefs: []
  type: TYPE_NORMAL
- en: Breaking down the problem into smaller parts leads to the creation of more modular
    code, which ultimately results in higher-quality code and lower maintenance costs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To summarize, the benefits of TDD are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Improves code quality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gives developers the confidence to make changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the cons of TDD?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While TDD can improve software quality, it also has drawbacks. Some developers
    have expressed concerns about the approach and argue that it may not always be
    the best option.
  prefs: []
  type: TYPE_NORMAL
- en: The main criticisms are that TDD can slow down development and create additional
    code maintenance work.
  prefs: []
  type: TYPE_NORMAL
- en: When should you avoid using TDD?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While TDD helps teams prioritize their code base’s internal quality early on,
    it’s not the only way to do so. Whether you adopt TDD should depend on the reality
    of your project and the surrounding situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some scenarios or situations where it may not make sense to use TDD:'
  prefs: []
  type: TYPE_NORMAL
- en: When experimenting or creating a proof of concept
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When dealing with language/framework methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When dealing with GUI development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To TDD or not to TDD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Implementing TDD involves a fundamental shift in culture and testing practices,
    requiring the support of both the engineering team and management.
  prefs: []
  type: TYPE_NORMAL
- en: If you work in an organization that utilizes extensive legacy code, you may
    be curious about how TDD can benefit you. While it may not affect the existing
    code base, you can gradually integrate TDD for new features and bug fixes, resulting
    in an improved code base over time.
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These tests are meant to check the integration of individual components. This
    process ensures that all the different layers of the app, such as the UI, business
    logic, data storage, and external services, work together seamlessly. Integration
    testing helps uncover any issues that may arise due to the interactions between
    these different parts of the app.
  prefs: []
  type: TYPE_NORMAL
- en: Acceptance/E2E testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Acceptance testing focuses on verifying whether a mobile app meets the specified
    requirements and is ready for release. It aims to ensure that the app aligns with
    the intended functionality, user expectations, and business requirements.
  prefs: []
  type: TYPE_NORMAL
- en: '**E2E** testing focuses on testing the complete flow of an application, often
    spanning multiple components and systems. In the context of mobile apps, E2E testing
    ensures that all the different parts of the app work seamlessly together, from
    the UIs to the backend systems.'
  prefs: []
  type: TYPE_NORMAL
- en: The difference between TDD and unit testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unit testing involves writing many small tests that each test one very simple
    function’s or object’s behavior. TDD is a thinking process that results in unit
    tests, and “thinking in tests” tends to result in more fine-grained and comprehensive
    testing and an easier-to-extend software design.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on and learn more about the different types of mobile app testing.
  prefs: []
  type: TYPE_NORMAL
- en: Types of mobile app testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to mobile app testing, there are several types of testing that
    you can perform to ensure that your app is robust and reliable and provides an
    excellent user experience. Here are some of the most common types of mobile app
    testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Functional testing**: This aims to determine whether the app’s functionality
    meets the requirements and works as expected. It involves testing a variety of
    aspects of the app, such as the UI, navigation, data processing, and business
    logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Regression testing**: This ensures that new features or changes do not affect
    the app’s functionality. A regression test checks whether the app’s existing features
    work correctly after introducing new features or changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Usability testing**: This focuses on the user experience and checks whether
    the app is easy to use, navigate, and understand. It involves testing the app’s
    design, layout, colors, font sizes, and other elements that affect the user experience.
    Some of the popular testing activities here are **snapshot** and **visual testing**;
    we will discuss both in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Compatibility testing**: This checks the app’s compatibility with different
    devices, operating systems, and screen sizes. Testing the app’s compatibility
    with hardware, network, and software configurations is necessary. Using cloud
    device testing such as Sauce Labs or Firebase Test Lab helps you run your test
    suites on different devices and configurations to ensure that the app works as
    expected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Localization testing**: This checks whether the app is compatible with different
    languages, regions, and cultures by testing the language support, the date and
    time formats, the currency format, and other cultural elements, especially if
    the app supports languages such as Arabic since it changes the UI to **Right to**
    **Left** (**RTL**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance testing**: This checks the app’s performance and responsiveness
    under different scenarios, such as low battery, weak network connectivity, or
    high usage. It tests the app’s load, response, memory usage, and battery consumption.
    In [*Chapter 7*](B18113_07.xhtml#_idTextAnchor265), *Establishing Mobile App Monitoring,
    Observability, and Analytics*, we will discuss how to monitor the performance
    of mobile apps using different tools and services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Accessibility testing**: This tests the application’s UI for accessibility
    to people with disabilities, such as those with visual impairments. Testing for
    accessibility can identify issues with an application’s layout, design, and UI
    that may prevent users with disabilities from using it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security testing**: This checks the app’s security features and identifies
    vulnerabilities that can compromise user data. It includes testing the app’s authentication,
    authorization, encryption, and data storage mechanisms. In [*Chapter 8*](B18113_08.xhtml#_idTextAnchor306),
    *Keeping Mobile Apps and DevOps Secure*, we will discuss security testing and
    how to inject security into Mobile DevOps processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By performing these types of mobile app testing, you can ensure that your app
    is high quality, meets user expectations, and provides an excellent user experience.
  prefs: []
  type: TYPE_NORMAL
- en: Test automation is essential for mobile apps as it enhances efficiency, reduces
    costs, improves app quality, and ensures a positive user experience across a variety
    of devices and operating systems. By investing in test automation, mobile app
    developers can create and maintain high-quality apps that meet users’ expectations
    and stand out in a competitive market.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s discuss the importance of test automation for mobile apps.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of test automation for mobile apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In mobile DevOps, test automation is essential as it makes the mobile development
    life cycle faster and more reliable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mobile DevOps cannot exist without test automation for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Faster release cycles**: Mobile DevOps aims to deliver mobile apps rapidly
    and consistently. Test automation helps achieve this by allowing teams to execute
    tests quickly and repeatedly, reducing the time it takes to identify and fix issues
    before deployment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Test scripts can be reused, making it easy to retest the app after updates*
    *or modifications.*'
  prefs: []
  type: TYPE_NORMAL
- en: '**Continuous integration and deployment/delivery (CI/CD)**: Mobile DevOps relies
    on **CI/CD** to streamline the mobile release process. Test automation is crucial
    to these processes. As part of the development cycle, automated tests are run
    every time code is committed or changes are made, ensuring the mobile app remains
    stable and functional. For example, the CI workflows and pipelines we implemented
    in the previous chapter can use different test automation tools such as **Espresso**,
    **XCUITest**, and **Appium** to ensure app quality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increased test coverage**: In this way, more tests can be run quickly, resulting
    in better test coverage. Continuous testing identifies issues earlier in the development
    process and reduces the possibility of final production defects. We will discuss
    how to achieve successful mobile test coverage, continuous testing, and shift-left
    testing later in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved collaboration**: Automated mobile tests enable developers and testers
    to collaborate more efficiently by providing immediate feedback on how code changes
    impact the application. They prevent errors from entering the production environment
    and enhance communication among team members.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cost-efficiency**: Manual testing can result in reduced test automation,
    saving time and money. By automating repetitive tasks, teams can focus on more
    complex tasks and increase productivity and the **Return** **On Investment**(**ROI**).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let’s discuss the challenges we come across in mobile development before
    we discuss the need for a robust mobile testing strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile app testing challenges and pitfalls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Mobile technology is rapidly evolving, presenting unique challenges to mobile
    testing teams. Let’s examine the most common challenges teams face when testing
    mobile apps so that we can overcome them:'
  prefs: []
  type: TYPE_NORMAL
- en: Finding suitable automation tools and frameworks can be challenging as mobile
    application testing becomes increasingly essential.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the growing number of devices and operating systems, testing mobile device
    compatibility and cross-platform compatibility can be challenging.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To determine how an app will perform on different networks, such as 2G, 3G,
    4G, and 5G, it is necessary to test the app on each network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To guarantee the app’s compatibility with an **Internet Protocol version 6**
    (**IPv6**) setup, various checks need to be conducted. This includes assessing
    address compatibility, network configuration, and the firewall and NAT, and determining
    how to mitigate any issues that arise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mobile applications should be tested for performance under various conditions
    to ensure an optimal user experience. Teams should ensure that the applications
    are tested for speed, responsiveness, and stability.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security and privacy are increasingly important in mobile testing. Teams must
    ensure that all applications are tested for vulnerabilities and that user data
    is protected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These challenges require teams to have a comprehensive testing strategy that
    covers all mobile application testing aspects. Teams should focus on developing
    a strategy to manage complexity, automate testing, optimize performance, improve
    security and privacy, and ensure cross-platform compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, teams should seek out tools and services that can help them simplify
    the mobile testing process. By planning and preparing strategically, teams can
    effectively face mobile testing challenges.
  prefs: []
  type: TYPE_NORMAL
- en: For their testing strategies to remain relevant and up to date, teams should
    regularly review their processes, evaluate new tools, and adapt their approaches
    as necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '*Mobile testing strategies should be developed and* *maintained continuously.*'
  prefs: []
  type: TYPE_NORMAL
- en: This should include defining your testing efforts’ scope, objectives, and priorities.
    Identify the types of testing required for your app and allocate resources accordingly.
    Review your testing processes, evaluate new tools and technologies, and adjust
    your approaches as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Teams can ensure their mobile applications succeed by taking the right direction
    and leveraging suitable tools. Teams need to review their testing processes regularly
    and evaluate emerging technologies that can help simplify their mobile testing
    process.
  prefs: []
  type: TYPE_NORMAL
- en: The need for a robust testing strategy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As discussed in [*Chapter 1*](B18113_01.xhtml#_idTextAnchor014), *Resolving
    Challenges in Mobile DevOps*, it is essential for Fintech companies or any other
    companies to implement mobile DevOps and follow a testing strategy. Failure to
    do so can lead to numerous issues with manual testing, such as consuming significant
    time and effort, which can ultimately affect the release process and delay the
    rollout of new features. To ensure optimal functionality and user experience in
    a mobile app, a mobile testing strategy encompasses various testing types, tools,
    and techniques, all of which are addressed meticulously to cover every possible
    scenario. This includes **unit**, **integration**, **system**, **performance**,
    **compatibility**, and **usability** testing.
  prefs: []
  type: TYPE_NORMAL
- en: In my opinion, *Don’t follow the test pyramid. It is a model*. There is no silver
    bullet or magic wand; each team or company should create its own testing strategy.
    Some businesses focus more on functional tests, others on performance tests, and
    others on security tests.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The **Mobile Native Foundation** has an interesting discussion ([https://github.com/MobileNativeFoundation/discussions/discussions/6](https://github.com/MobileNativeFoundation/discussions/discussions/6))
    about how companies such as Lyft, Spotify, Uber, and more conduct testing and
    implement testing strategies.
  prefs: []
  type: TYPE_NORMAL
- en: What is a mobile app testing strategy?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A mobile app testing strategy is a comprehensive plan that outlines the testing
    process for a mobile app. It includes various testing techniques and tools that
    help ensure the quality and reliability of the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some essential elements to consider when creating a mobile app testing
    strategy:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Clearly define your testing goals and objectives** by considering what you
    want to achieve through testing, such as ensuring the app works correctly on all
    devices and platforms, identifying and fixing bugs before releasing the app, or
    improving the app’s overall user experience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identify the target devices and platforms** on which you want to test your
    app. To ensure compatibility, consider testing your app on various devices with
    different operating systems, screen sizes, and hardware configurations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Choose testing techniques** that best suit your app’s needs and objectives.
    Consider techniques such as functional testing, usability testing, performance
    testing, security testing, compatibility testing, and localization testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use tools that can help you automate your testing** and provide comprehensive
    coverage. Consider tools such as Appium, XCUITest, Espresso, and Detox.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Define test cases and scenarios** that cover all app features, functionalities,
    and user scenarios. Test cases and scenarios should be designed to cover both
    positive and negative test scenarios.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Establish a test execution plan** that outlines the testing process, test
    schedules, and resources required to execute the tests. This plan should also
    outline the roles and responsibilities of the testing team.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Implement test automation** to save time and ensure consistent testing results.
    Automate repetitive tests that can be executed quickly, such as regression testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Involve end users in user acceptance testing** (**UAT**) to get feedback
    (beta testing) on the app’s usability and functionality. This feedback can help
    you identify any issues and improve the overall user experience. In [*Chapter
    6*](B18113_06.xhtml#_idTextAnchor210), *Mobile App Release Management*, we will
    discuss the concept of beta testing for mobile apps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, sometimes, people confuse a testing strategy with a test plan. Let’s
    take a look at the differences between them:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Test Plan** | **Test Strategy** |'
  prefs: []
  type: TYPE_TB
- en: '| A document that outlines the scope, approach, resources, and schedule of
    the intended testing activities | A high-level document that defines the overall
    approach for testing a system or product, including the testing methodologies,
    tools, and processes to be used |'
  prefs: []
  type: TYPE_TB
- en: '| Defines the specific test objectives and acceptance criteria | Determines
    the overall testing goals and objectives |'
  prefs: []
  type: TYPE_TB
- en: '| Provides detailed information on how testing will be conducted | Provides
    a general overview of the testing approach |'
  prefs: []
  type: TYPE_TB
- en: '| Outlines the roles and responsibilities of the testing team | Outlines the
    testing process and the roles and responsibilities of the testing team |'
  prefs: []
  type: TYPE_TB
- en: '| Provides a detailed schedule of testing activities | Provides a high-level
    plan of testing activities |'
  prefs: []
  type: TYPE_TB
- en: '| Includes a test schedule, test cases, scripts, and data | Includes testing
    methodology, testing tools, and testing process |'
  prefs: []
  type: TYPE_TB
- en: '| Focuses on the testing process and the execution of test cases | Focuses
    on the overall testing approach and the testing goals and objectives |'
  prefs: []
  type: TYPE_TB
- en: Table 5.1 – Test plan versus test strategy
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned earlier in this chapter, test automation helps us increase our
    test coverage, and more tests can be run quickly and continuously in the development
    process, resulting in better test coverage. From this, we got the concept of continuous
    testing and shift-left testing. Let’s explore these concepts in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Continuous testing encourages testing throughout the software development process
    rather than simply at the end. Through early and ongoing input on the software’s
    quality, continuous testing seeks to help teams find and address problems as quickly
    as feasible.
  prefs: []
  type: TYPE_NORMAL
- en: Modern software development methodologies, such as Agile and mobile DevOps,
    where frequent releases and updates are the norms, depend heavily on continuous
    testing. Teams can ensure that every release is high quality and satisfies the
    end user’s needs by incorporating testing into the development process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The practice of continuous testing entails testing software while it is still
    being developed, as opposed to waiting until the end of the development cycle
    or releasing the mobile app, as we covered in [*Chapter 3*](B18113_03.xhtml#_idTextAnchor083),
    *Mobile DevOps Fundamentals*. A high-quality app is crucial for mobile applications,
    which are frequently used by many users and consume a lot of data:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.2 – Continuous testing with \uFEFFCI](img/Figure_05.02_B18113.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Continuous testing with CI
  prefs: []
  type: TYPE_NORMAL
- en: As a result of the continuous testing process, shift-left testing is becoming
    more and more popular.
  prefs: []
  type: TYPE_NORMAL
- en: You can measure your team’s maturity level and receive expert advice from domain
    experts with Katalon’s Continuous Testing Maturity Assessment ([https://katalon.com/continuous-testing-self-assessment](https://katalon.com/continuous-testing-self-assessment)).
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, testing is performed toward the end of the development process,
    once the code has been written. However, with the shift-left testing approach,
    testing is integrated into the development process from the very beginning.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explain the concept and advantages of shift-left testing.
  prefs: []
  type: TYPE_NORMAL
- en: What is shift-left testing?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Shift-left testing is a methodology for software testing that focuses on the
    early phases of the software development life cycle. In conventional software
    development, testing is usually carried out after the majority of the code has
    been produced, toward the conclusion of the development phase.
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, shift-left testing entails incorporating testing tasks into the
    early stages of development, such as requirement collection, design, and implementation,
    as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.3 – Shif\uFEFFt left in testing](img/Figure_05.03_B18113.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – Shift left in testing
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several advantages to continuous testing as well as shift-left testing,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Early detection of defects (test early and often)**: By testing early in
    the development process, defects can be identified and fixed before they propagate
    and become more expensive and difficult to resolve.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved collaboration and communication**: Shift-left testing encourages
    cooperation and communication between developers and testers, which can help identify
    and address potential issues early on and improve the overall quality of the software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Faster delivery and deployment**: By shifting testing to the left, teams
    can deliver and deploy software faster. They can start testing earlier and avoid
    delays and bottlenecks at the end of the development process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizations need to adopt a continuous testing approach to implement shift-left
    testing, where testing is integrated into the development process and performed
    throughout the life cycle. This may require a shift in culture and mindset and
    adopting the appropriate tools and technologies to support continuous testing.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s take a closer look at some of the testing tools, frameworks, and
    cloud services available in the market today for mobile apps to help you decide
    which is most suitable for your company.
  prefs: []
  type: TYPE_NORMAL
- en: Testing tools, frameworks, and services for mobile apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are numerous testing tools, frameworks, and services available for developers
    and testers to assist them in testing their mobile apps rapidly.
  prefs: []
  type: TYPE_NORMAL
- en: But first, let’s begin by discussing the factors to consider when choosing a
    test automation framework or tool for mobile applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'When selecting a mobile test automation tool, there are several factors to
    consider:'
  prefs: []
  type: TYPE_NORMAL
- en: The tool should integrate with other tools in your test automation ecosystem,
    such as CI and test management tools, so that you can use it in CI/CD pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tool should be compatible with the different mobile devices and operating
    systems you plan to test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tool should be easy to set up, configure, and use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tool should provide clear, detailed reports on test results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tool should have a robust support system and a large community of users
    who can provide help and guidance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tool should be able to handle large-scale testing as your mobile app and
    user base grow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s always a good idea to evaluate a few different tools and conduct a pilot
    test or a **proof of concept** project with a small set of tests before you decide
    that a tool or framework is suitable for your business, app, and team.
  prefs: []
  type: TYPE_NORMAL
- en: Mobile app UI and functionality testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An excellent user experience requires testing the UI of a mobile application.
    Testers can identify and address issues with the application’s functionalities
    and UI by performing automated testing in the testing process, resulting in a
    positive customer experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some native and cross-platform mobile testing frameworks to consider
    when testing an app’s functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: 'iOS:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XCUITest
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: EarlGrey
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Android:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Espresso
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Jetpack Compose
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cross-platform:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Appium
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Detox
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Flutter Driver and Flutter integration tests
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Maestro
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start with the native frameworks for iOS apps.
  prefs: []
  type: TYPE_NORMAL
- en: XCUITest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**XCUITest** ([https://developer.apple.com/documentation/xctest](https://developer.apple.com/documentation/xctest))
    is a mobile testing framework created by Apple specifically for iOS, macOS, tvOS,
    and watchOS app testing. Designed to help developers and QA teams automate their
    testing processes, it supports Swift and Objective-C languages, offering flexibility
    in choosing the preferred language.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Built on Apple’s XCTest framework, XCUITest enables unit and UI testing within
    a single framework, streamlining* *the process.*'
  prefs: []
  type: TYPE_NORMAL
- en: XCUITest advocates for accessibility by mandating proper **accessibility identifiers**
    in apps, ensuring universal usability.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, test engineers unfamiliar with Swift or Objective-C may also experience
    a steeper learning curve.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use XCUITest, developers must import the XCTest framework and create a subclass
    of XCTestCase. They can then define test methods and interact with the app’s UI
    using XCUITest’s API:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – The XCUITest directory in the iOS app](img/Figure_05.04_B18113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – The XCUITest directory in the iOS app
  prefs: []
  type: TYPE_NORMAL
- en: The framework also offers additional capabilities, such as taking screenshots,
    performing gestures such as swipes and pinches, and various other element interactions.
    Further information can be found in Apple’s official documentation and API reference.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is some simple XCUITest code to test the login functionality: [https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/iOS/XCUITest/simpleTest.swift](https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/iOS/XCUITest/simpleTest.swift).'
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the Page Object pattern with XCUITest, which involves creating
    separate classes for each screen in your app. These classes will contain the UI
    elements and actions specific to that screen. This promotes better code organization
    and maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the given SwiftUI app, we can create two page objects: `LoginPage` and
    `WelcomePage`. Here are some examples of how to use the Page Object pattern with
    XCUITest:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `LoginPage.swift` file ([https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/iOS/XCUITest/PageObjects/LoginPage.swift](https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/iOS/XCUITest/PageObjects/LoginPage.swift))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the `WelcomePage.swift` file ([https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/iOS/XCUITest/PageObjects/WelcomePage.swift](https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/iOS/XCUITest/PageObjects/WelcomePage.swift))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update your test class to use these page objects ([https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/iOS/XCUITest/TestClassWithPO.swift](https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/iOS/XCUITest/TestClassWithPO.swift))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'XCUITest integrates easily with most CI providers, such as Xcode Cloud, Bitrise,
    GitHub Actions, and Codemagic, but to be able to run UI tests, it must have macOS
    machines with target iOS SDK and iOS simulators. The scheme should also be shared:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Shared scheme in an iOS app](img/Figure_05.05_B18113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Shared scheme in an iOS app
  prefs: []
  type: TYPE_NORMAL
- en: Then, you can run the tests on your preferred CI provider if you have the prerequisites.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, on Codemagic, you can use the code at the following link in your
    `codemagic.yml` file: [https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/iOS/XCUITest/codemagic.yml](https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/iOS/XCUITest/codemagic.yml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'On Bitrise, you can add an Xcode test for the iOS integration step to build
    the app for testing and running the UI tests:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.6 – Bitri\uFEFFse iOS workflow](img/Figure_05.06_B18113.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Bitrise iOS workflow
  prefs: []
  type: TYPE_NORMAL
- en: EarlGrey
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**EarlGrey** ([https://github.com/google/EarlGrey](https://github.com/google/EarlGrey)),
    developed by Google, is a specialized iOS testing framework tailored to support
    native iOS app testing. It allows developers and QA teams to automate UI testing
    for their iOS apps using either Objective-C or Swift, according to their preference.'
  prefs: []
  type: TYPE_NORMAL
- en: EarlGrey ensures smooth and reliable test execution by automatically synchronizing
    with the application’s UI. It also offers a wide range of assertions and matchers,
    enabling developers to create thorough and expressive tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a UI test for the given SwiftUI app using EarlGrey, you’ll need to
    set up EarlGrey in your project. After that, you can write your test cases. Here’s
    a UI test for the given SwiftUI app using EarlGrey: [https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/iOS/EarlGrey/EarlGreyTest.swift](https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/iOS/EarlGrey/EarlGreyTest.swift).'
  prefs: []
  type: TYPE_NORMAL
- en: The same page objects concept can be applied to EarlGrey as well as when you’re
    running the necessary tests in CI/CD workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s discuss the native testing frameworks for Android apps.
  prefs: []
  type: TYPE_NORMAL
- en: Espresso
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Espresso** ([https://developer.android.com/training/testing/espresso](https://developer.android.com/training/testing/espresso)),
    created by Google, is a dedicated Android testing framework designed to support
    native Android app testing. It allows developers and QA teams to automate UI testing
    for their Android apps using either Java or Kotlin, according to their preferences.'
  prefs: []
  type: TYPE_NORMAL
- en: It ensures smooth and reliable test execution by automatically synchronizing
    with the application’s UI, which results in faster and more accurate testing.
    Espresso also provides various assertions and matchers, allowing developers to
    create comprehensive and expressive tests.
  prefs: []
  type: TYPE_NORMAL
- en: Easily integrated with AndroidJUnit4, Espresso allows developers to perform
    both unit and UI testing within a single framework. As an officially supported
    Google product, developers can rely on up-to-date documentation, resources, and
    compatibility with new Android versions. Additionally, those unfamiliar with Java
    and Kotlin may experience a steeper learning curve when starting.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here is some simple Espresso code to test the login functionality: [https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/Android/LoginTest.kt](https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/Android/LoginTest.kt).'
  prefs: []
  type: TYPE_NORMAL
- en: You can use the Page Object pattern to make your Espresso tests more maintainable
    and easier to read ([https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/Android/PageObjects/LoginPage.kt](https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/Android/PageObjects/LoginPage.kt)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of how you can implement the Page Object pattern in your
    Espresso test for a login screen using Kotlin: [https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/Android/LoginScreenTest.kt](https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/Android/LoginScreenTest.kt).'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, you can use **UI Automator** ([https://developer.android.com/training/testing/other-components/ui-automator](https://developer.android.com/training/testing/other-components/ui-automator))
    with Espresso for cross-app functional UI testing across the system and installed
    apps.
  prefs: []
  type: TYPE_NORMAL
- en: Espresso integrates easily with most CI providers, such as Bitrise, GitHub Actions,
    and Codemagic, but to be able to run the UI tests, you must have Ubuntu or Windows
    machines with Gradle installed and the target Android SDK with Android Emulator.
    Then, you need to run the Gradle command `./gradlew connectedDebugAndroidTest`.
    This command combines the building and installation of the main app and the test
    app in a single step using the connectedDebugAndroidTest Gradle task. This task
    builds both the main app and its associated Android test app, installs them on
    the connected device, and then runs the tests defined in the test app.
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve done this, you can run the tests on your preferred CI provider if
    you have the prerequisites.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, on Codemagic, you can use the code at the following link in your
    `codemagic.yml` file: [https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/Android/codemagic.yml](https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/Android/codemagic.yml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'On Bitrise, you can add the **Android Build for UI Testing** and **Virtual
    Device Testing for Android** integration steps to build the app for testing and
    run the UI tests on Firebase Test Lab, which is integrated internally with this
    Bitrise step:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Bitrise Android workflow](img/Figure_05.07_B18113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.7 – Bitrise Android workflow
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, with GitHub Actions, you can use the following YAML file: [https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/.github/android.yml](https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/.github/android.yml).'
  prefs: []
  type: TYPE_NORMAL
- en: Open source project based on Espresso
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many open source UI testing libraries built on top of Espresso for
    Android applications to simplify and streamline the process of writing UI tests,
    enabling developers to create robust and maintainable tests with ease. These include
    Kaspresso ([https://github.com/KasperskyLab/Kaspresso](https://github.com/KasperskyLab/Kaspresso)),
    Barista ([https://github.com/AdevintaSpain/Barista](https://github.com/AdevintaSpain/Barista)),
    and Kakao ([https://github.com/KakaoCup/Kakao](https://github.com/KakaoCup/Kakao)).
    Their fluent interfaces, advanced test interceptors, automatic screenshots, and
    enhanced logging capabilities make them a strong choice for Android developers
    looking to improve their UI testing experience.
  prefs: []
  type: TYPE_NORMAL
- en: Jetpack Compose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Jetpack Compose** ([https://developer.android.com/jetpack/compose](https://developer.android.com/jetpack/compose))
    is Google’s modern UI toolkit for Android applications. The Jetpack Compose Testing
    library ([https://developer.android.com/jetpack/compose/testing](https://developer.android.com/jetpack/compose/testing))
    aims to simplify the process of writing and maintaining UI tests for applications
    built using Jetpack Compose.'
  prefs: []
  type: TYPE_NORMAL
- en: Jetpack Compose Testing provides a Compose Test Rule, which sets up the necessary
    environment for testing Compose UIs and makes it easy to create and manipulate
    composable UIs within tests.
  prefs: []
  type: TYPE_NORMAL
- en: Jetpack Compose Testing supports screenshot testing, allowing developers to
    compare the visual appearance of UI elements against a reference image during
    test execution.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to use Espresso as a test framework since Jetpack Compose is
    an instrumentation test, but Compose already includes testing APIs to find, verify,
    and perform user actions on elements. Time manipulation and other advanced features
    are included.
  prefs: []
  type: TYPE_NORMAL
- en: In general, if you have a particular type of UI element or component, you should
    have specific APIs or methods to test them in their various scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about Compose testing, there is a cheat sheet ([https://developer.android.com/jetpack/compose/testing-cheatsheet](https://developer.android.com/jetpack/compose/testing-cheatsheet))
    that acts as a quick reference to some of the most useful Compose test APIs.
  prefs: []
  type: TYPE_NORMAL
- en: The same Page Object concept can be applied to Jetpack Compose and running the
    tests in the necessary CI/CD workflows ([https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/Android/JetpackCompose/CounterTest.kt](https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/Android/JetpackCompose/CounterTest.kt)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example from Reddit about their E2E UI automation framework for
    Android apps and how they use page objects and Fluent design patterns: [https://shorturl.at/ajH78](https://shorturl.at/ajH78).'
  prefs: []
  type: TYPE_NORMAL
- en: Appium
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Appium** ([https://appium.io](https://appium.io)) is an open source, cross-platform
    mobile testing framework that enables developers and QA teams to automate testing
    for their mobile applications on Android, iOS, and Windows platforms.'
  prefs: []
  type: TYPE_NORMAL
- en: Appium supports multiple programming languages, including Java, Ruby, Python,
    C#, and JavaScript, allowing developers to choose their preferred language.
  prefs: []
  type: TYPE_NORMAL
- en: Appium integrates with popular testing frameworks such as JUnit and TestNG,
    allowing developers to utilize their preferred testing tools.
  prefs: []
  type: TYPE_NORMAL
- en: Appium can easily be integrated with CI tools, such as Bitrise, GitHub Actions,
    and CircleCI, streamlining the testing process within the development workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Appium’s large, active community offers extensive documentation, resources,
    and regular updates. But usually, the initial setup and configuration of Appium
    can be time-consuming and requires significant effort to ensure proper functioning
    ([https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/Appium/AppiumDemo.java](https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/Appium/AppiumDemo.java)).
  prefs: []
  type: TYPE_NORMAL
- en: You can use also the Page Object pattern to make your Appium tests more maintainable
    and easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run Appium tests in your CI workflow, you need to install and run the Appium
    Server, along with Android Emulator or the iOS simulator. You can use the following
    shell script to do this: [https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/Appium/emulator.sh](https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/Appium/emulator.sh).'
  prefs: []
  type: TYPE_NORMAL
- en: Then, you can run the tests using the command line with Gradle or Maven.
  prefs: []
  type: TYPE_NORMAL
- en: Detox
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Detox** ([https://github.com/wix/Detox](https://github.com/wix/Detox)) is
    an E2E mobile testing framework designed specifically for React Native applications.
    It enables developers and QA teams to automate testing for their React Native
    apps on both Android and iOS platforms.'
  prefs: []
  type: TYPE_NORMAL
- en: Detox operates as a gray box testing framework, balancing the speed and reliability
    of white box testing and the realism of black box testing. Detox integrates seamlessly
    with Jest, a popular JavaScript testing framework, allowing developers to utilize
    their preferred testing tools and methodologies.
  prefs: []
  type: TYPE_NORMAL
- en: Detox automatically synchronizes test execution with the application’s UI, ensuring
    that tests run smoothly and reliably.
  prefs: []
  type: TYPE_NORMAL
- en: Detox can easily be integrated with CI tools, such as Jenkins, Travis CI, and
    CircleCI, streamlining the testing process within the development workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Detox has an active community of developers and users who provide resources,
    support, and regular updates.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s an example of a Detox test for a simple React Native login app: [https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/Detox/LoginTest.js](https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/Detox/LoginTest.js).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Detox also requires you to have a configuration JSON file, such as the following:
    [https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/Detox/config.json](https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/Detox/config.json).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To run Detox tests in a CI/CD workflow or a pipeline such as GitHub Actions,
    you need Android Emulator or the iOS simulator. Also, install Node.js and NPM
    and build the app using the preceding configuration file. You can use the following
    YAML file for this: [https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/Detox/.github/detox.yml](https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/Detox/.github/detox.yml).'
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the approaches for Bitrise, Codemagic, and the rest of the CI providers
    we have mentioned, you need to use a script step to install the prerequisites
    and then run your Detox tests.
  prefs: []
  type: TYPE_NORMAL
- en: Flutter Driver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Flutter Driver** ([https://api.flutter.dev/flutter/flutter_driver_extension/flutter_driver_extension-library.html](https://api.flutter.dev/flutter/flutter_driver_extension/flutter_driver_extension-library.html))
    is a testing framework for Flutter applications, enabling developers and QA teams
    to automate integration and UI testing for their Flutter apps.'
  prefs: []
  type: TYPE_NORMAL
- en: It supports testing on Android and iOS platforms, allowing developers to test
    their Flutter apps on various devices and operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Flutter Driver is designed for integration testing, enabling developers to test
    how different components of their application work together.
  prefs: []
  type: TYPE_NORMAL
- en: It uses Dart, the same programming language for developing Flutter applications,
    making it easier for developers to write tests in a familiar language.
  prefs: []
  type: TYPE_NORMAL
- en: Flutter Driver automatically synchronizes test execution with the application’s
    UI, ensuring that tests run smoothly and reliably – Flutter Driver’s automatic
    synchronization with the application’s UI results in stable and reliable test
    execution.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, testers unfamiliar with Dart or the Flutter framework may face
    a steeper learning curve when they start using Flutter Driver.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here’s an example of a Flutter Driver test for a simple Flutter login app:
    https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/Flutter/Flutter%20Driver/LoginTest.dart.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also an integration test (https://docs.flutter.dev/testing#integration-tests)
    that can be used to test the Flutter app. Here’s an example for a simple Flutter
    login app: [https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/Flutter/Integration%20Test/LoginTest.dart](https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/Flutter/Integration%20Test/LoginTest.dart).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To run Flutter tests in a CI/CD workflow or pipeline such as GitHub Actions,
    you need Android Emulator or iOS simulator and the Dart SDK. Yowu can use the
    following YAML file to aid with this: [https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/Flutter/.github/FlutterIntegration.yml](https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/Flutter/.github/FlutterIntegration.yml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a YAML file that runs a Flutter Driver test on both Android
    Emulator and the iOS simulator via GitHub Actions: [https://github.com/PacwktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/Flutter/.github/FlutterDriver.yml](https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/Flutter/.github/FlutterDriver.yml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'On Bitrise, there are integration steps for building and testing Flutter apps:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Bitrise Flutter workflow](img/Figure_05.08_B18113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.8 – Bitrise Flutter workflow
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, on Codemagic, there are steps that support Flutter Driver and Flutter
    tests:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure\uFEFF 5.9 – Codemagic Flutter workflow](img/Figure_05.09_B18113.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.9 – Codemagic Flutter workflow
  prefs: []
  type: TYPE_NORMAL
- en: Maestro
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Maestro** ([https://maestro.mobile.dev/](https://maestro.mobile.dev/)) is
    the simplest and most effective open source mobile UI testing framework and is
    developed by mobile.dev. It allows you to easily define and test your flows (the
    user journey in the app – in other words, the E2E scenarios).'
  prefs: []
  type: TYPE_NORMAL
- en: Maestro is YAML-based, meaning you define the test flows inside a `flow.yml`
    file ([https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/Maestro/flow.yml](https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/Maestro/flow.yml))
    and run them on your devices.
  prefs: []
  type: TYPE_NORMAL
- en: 'Maestro has different features, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: With Maestro, flakiness is tolerated. Apps and devices are built to be unstable,
    and UI elements are designed to counteract this.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not necessary to call `sleep()` repeatedly in your tests. Maestro waits
    for the content to load automatically (but not too long) when this process takes
    a long time (for example, over a network).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maestro automatically reruns your tests when your test files change, so there’s
    no need to compile anything.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maestro supports all of the major mobile development platforms, including Android,
    iOS, Flutter, React Native, and Web Views.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, there is Maestro Studio, Maestro’s personal assistant that will
    assist you in writing your Maestro flows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can easily test your flows on Maestro Cloud since they run in the cloud,
    so you don’t have to configure any simulators or emulators.
  prefs: []
  type: TYPE_NORMAL
- en: Flows can also be run via the Maestro CLI on Android devices/emulators that
    support ADB connections and iOS devices/simulators that support Facebook’s IDB.
    You can manually orchestrate your flow execution against any provider that supports
    these protocols. You can run your flows as you would locally with the Maestro
    CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bitrise has an integration step to help you run your Maestro tests on the cloud.
    If you are using another CI provider, you can use the Maestro CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Bitrise and Maestro workflow](img/Figure_05.10_B18113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.10 – Bitrise and Maestro workflow
  prefs: []
  type: TYPE_NORMAL
- en: 'By exploring the testing frameworks that we have on the market today and how
    to run them in a CI workflow, we have noticed that we have a new challenge: running
    tests on different devices with different operating system versions simultaneously.
    Let’s talk about how to run our tests on cloud devices using different services
    to maximize coverage.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing on cloud devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developers and QA teams can test their applications on a wide range of devices
    and platforms without using physical devices via cloud device testing, a modern
    approach to mobile application testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'A cloud-based infrastructure hosts several emulators or real devices remotely.
    Here is a list of the most popular cloud device testing for mobile apps:'
  prefs: []
  type: TYPE_NORMAL
- en: Sauce Labs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BrowserStack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS Device Farm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firebase Test Lab
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LambdaTest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take a look at these in greater detail.
  prefs: []
  type: TYPE_NORMAL
- en: Sauce Labs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Sauce Labs** ([https://saucelabs.com/products/mobile-testing](https://saucelabs.com/products/mobile-testing))
    streamlines the testing process by removing the need to buy and manage a large
    inventory of devices, enabling users to test their apps on actual devices in the
    cloud. Thanks to the platform’s comprehensive device coverage, users can identify
    problems before they are published by testing apps on the most recent devices.'
  prefs: []
  type: TYPE_NORMAL
- en: Sauce Labs supports Android and iOS platforms, enabling developers to test their
    apps across multiple devices and operating systems. It offers access to a vast
    range of real devices to test mobile apps, ensuring accurate results and minimizing
    the chances of encountering issues on real-world devices. In addition to real
    devices, Sauce Labs offers emulators and simulators for faster and more cost-effective
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: This feature allows multiple tests to be executed simultaneously, significantly
    reducing the overall testing time.
  prefs: []
  type: TYPE_NORMAL
- en: Sauce Labs integrates seamlessly with popular CI tools such as Bitrise, GitHub
    Actions, and Codemagic, allowing for automated testing in the development workflow.
    It supports popular test automation frameworks such as Appium, Espresso, and XCUITest,
    providing flexibility in choosing the proper framework for a project.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, Sauce Labs provides detailed test reports, logs, and video recordings
    of test sessions, facilitating efficient debugging and issue resolution.
  prefs: []
  type: TYPE_NORMAL
- en: You can use the `saucectl` CLI with any CI provider to configure your account
    and run the tests from the relevant `config.yml` file ([https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/SauceLabs/config.yml](https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/SauceLabs/config.yml)).
  prefs: []
  type: TYPE_NORMAL
- en: You can change the configuration to increase concurrency as you need to run
    the tests in parallel on different devices.
  prefs: []
  type: TYPE_NORMAL
- en: BrowserStack
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**BrowserStack** ([https://www.browserstack.com/app-automate](https://www.browserstack.com/app-automate))
    is a cloud-based testing platform that enables developers to test their mobile
    applications across various devices and operating systems. With a wide range of
    features and a user-friendly interface, BrowserStack aims to provide a comprehensive
    testing solution for developers and QA teams.'
  prefs: []
  type: TYPE_NORMAL
- en: BrowserStack provides access to an extensive collection of real devices for
    the accurate testing of mobile apps, ensuring that they perform well on actual
    devices consumers use. In addition to real devices, BrowserStack offers emulators
    and simulators for quick and cost-effective testing.
  prefs: []
  type: TYPE_NORMAL
- en: This feature enables multiple tests to be executed simultaneously, reducing
    overall testing time and increasing productivity.
  prefs: []
  type: TYPE_NORMAL
- en: BrowserStack integrates with widespread CI tools such as Jenkins, TeamCity,
    Bamboo, CircleCI, Travis CI, Azure, Bitrise, and GitLab CI/CD, streamlining the
    testing process within the development workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, Bitrise has integration steps for BrowserStack to upload and run
    Espresso and XCUITest tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.11 – Bitrise and BrowserStack integration steps](img/Figure_05.11_B18113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.11 – Bitrise and BrowserStack integration steps
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.12 – Bitrise and BrowserStack workflow](img/Figure_05.12_B18113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.12 – Bitrise and BrowserStack workflow
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have another CI provider or server, you can use the `curl` command to
    upload your tests to BrowserStack from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: BrowserStack supports various test automation frameworks, including Appium,
    Espresso, and XCUITest, providing flexibility in selecting the most suitable framework
    for a project.
  prefs: []
  type: TYPE_NORMAL
- en: You can test native and hybrid mobile apps with BrowserStack App Automate using
    the Appium automation framework on a wide range of real Android and iOS devices.
  prefs: []
  type: TYPE_NORMAL
- en: LambdaTest
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**LambdaTest** ([https://www.lambdatest.com/mobile-app-testing](https://www.lambdatest.com/mobile-app-testing))
    is a cloud-based testing platform that provides developers and QA teams with access
    to a wide range of devices and operating systems for web and mobile app testing.'
  prefs: []
  type: TYPE_NORMAL
- en: LambdaTest supports Android and iOS mobile app testing, allowing developers
    to test their applications on various devices and operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: LambdaTest also offers real mobile device testing, ensuring accurate results
    and a more realistic testing environment.
  prefs: []
  type: TYPE_NORMAL
- en: LambdaTest integrates with many popular testing frameworks, such as Appium,
    XCUITest, and Espresso, making it easy to incorporate into existing test suites.
    It also enables parallel testing, allowing multiple tests to run simultaneously
    and speeding up the overall testing process.
  prefs: []
  type: TYPE_NORMAL
- en: LambdaTest’s cloud-based infrastructure provides scalability and collaboration
    features, making it suitable for small and large teams.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, LambdaTest integrates with widespread CI tools such as AWS CodePipeline,
    Jenkins, CircleCI, Travis CI, GitLab CI, Azure Pipelines, and Bitrise.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `curl` command from the command line, you can upload and run your
    tests on LambdaTest Cloud, just like you can with Sauce Labs and BrowserStack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of uploading the iOS app and then running the XCUITest test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an example of uploading the Android and test app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If your CI provider supports integration steps, such as Bitrise, you can use
    it directly instead of the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 5.13 – Bitrise and LambdaTest integration steps\uFEFF](img/Figure_05.13_B18113.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 5.13 – Bitrise and LambdaTest integration steps
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – Bitrise and LambdaTest workflow](img/Figure_05.14_B18113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.14 – Bitrise and LambdaTest workflow
  prefs: []
  type: TYPE_NORMAL
- en: AWS Device Farm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**AWS Device Farm** ([https://aws.amazon.com/device-farm/](https://aws.amazon.com/device-farm/))
    is a mobile application testing service provided by **AWS**. It supports testing
    on Android and iOS platforms, allowing developers to test their apps on various
    real mobile devices.'
  prefs: []
  type: TYPE_NORMAL
- en: AWS Device Farm provides access to a selection of real devices for the more
    accurate testing of mobile apps, ensuring better compatibility with real-world
    devices consumers use.
  prefs: []
  type: TYPE_NORMAL
- en: Developers can remotely access devices for manual testing, allowing interactive
    debugging and troubleshooting.
  prefs: []
  type: TYPE_NORMAL
- en: AWS Device Farm supports popular test automation frameworks such as Appium,
    Espresso, and XCUITest, enabling developers to automate their testing processes.
  prefs: []
  type: TYPE_NORMAL
- en: AWS Device Farm integrates with popular CI tools, such as AWS CodePipeline,
    GitHub Actions, Codemagic, and Bitrise, streamlining the testing process within
    the development workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'With AWS Device Farm, you can upload the mobile app and test file manually
    to run your tests, as shown in the following screenshot. You can also upload the
    app with the CI build:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15 – AWS Device Farm – Choose application](img/Figure_05.15_B18113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.15 – AWS Device Farm – Choose application
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you can configure the test type and set up the test framework, such as
    **Instrumentation**, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16 – AWS Device Farm – setting up the test framework](img/Figure_05.16_B18113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.16 – AWS Device Farm – setting up the test framework
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve done this, you can select an APK and choose your execution environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.17 – AWS Device Farm – uploading the test app](img/Figure_05.17_B18113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.17 – AWS Device Farm – uploading the test app
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you can select the devices you wish to use. You can combine different
    device manufacturers, such as Google and Samsung, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.18 – AWS Device Farm – selecting devices](img/Figure_05.18_B18113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.18 – AWS Device Farm – selecting devices
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you’ve run the tests, you will see the test results, including videos,
    logs, and screenshots, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.19 – AWS Device Farm – the test results](img/Figure_05.19_B18113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.19 – AWS Device Farm – the test results
  prefs: []
  type: TYPE_NORMAL
- en: AWS Device Farm offers a flexible pay-as-you-go pricing model, allowing developers
    to pay only for the testing resources they use, making it a cost-effective option
    for some teams.
  prefs: []
  type: TYPE_NORMAL
- en: Firebase Test Lab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Firebase Test Lab** ([https://firebase.google.com/products/test-lab](https://firebase.google.com/products/test-lab)),
    a part of Google’s Firebase suite of development tools, is a cloud-based testing
    service that allows developers to test their mobile applications on a variety
    of real devices and virtual devices (emulators and simulators):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.20 – Firebase Test Lab matrix](img/Figure_05.20_B18113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.20 – Firebase Test Lab matrix
  prefs: []
  type: TYPE_NORMAL
- en: Firebase Test Lab supports testing on Android and iOS platforms, enabling developers
    to test their apps on various devices and operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firebase Test Lab supports popular test automation frameworks such as Espresso
    and XCTest but not Appium and Detox:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.21 – Firebase Test Lab results](img/Figure_05.21_B18113.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.21 – Firebase Test Lab results
  prefs: []
  type: TYPE_NORMAL
- en: Firebase Test Lab integrates with popular CI tools, such as Jenkins, GitLab
    CI, and Bitrise, streamlining the testing process within the development workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Firebase Test Lab automatically generates a pre-launch report with detailed
    test results, performance metrics, and screenshots, helping developers identify
    and resolve issues before they launch their app.
  prefs: []
  type: TYPE_NORMAL
- en: As part of the Firebase suite of tools, Firebase Test Lab seamlessly integrates
    with other Firebase services, such as Cloud Functions, simplifying the overall
    testing and development process.
  prefs: []
  type: TYPE_NORMAL
- en: You can run tests in parallel with **Flank** ([https://github.com/Flank/flank/](https://github.com/Flank/flank/)),
    a massively parallel Android and iOS test runner for Firebase Test Lab.
  prefs: []
  type: TYPE_NORMAL
- en: Flank is YAML-compatible with the `gcloud` CLI. It provides extra features to
    accelerate velocity and increase quality.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use Flank by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Google Cloud project and account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a Firebase account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add your project to Firebase.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a service account to get access to the API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Download the service account JSON file. This will contain a private key that
    can be added directly to your CI server and used for authentication.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you’ve done this, you can create a configuration file for your app, similar
    to the one at [https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/Flank/flank.yml](https://github.com/PacktPublishing/Mobile-DevOps-Playbook/blob/main/Chapter-5/Flank/flank.yml).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you can run the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As a final point, you need to monitor the usage of Flank since you are running
    parallel devices, which will incur costs.
  prefs: []
  type: TYPE_NORMAL
- en: Other services provide us with cloud devices, such as **Genymotion** ([https://www.genymotion.com/](https://www.genymotion.com/)),
    a popular Android emulator and mobile testing platform that enables developers
    and QA teams to test their mobile applications on various virtual devices. Additionally,
    **emulator.wtf** ([https://emulator.wtf/](https://emulator.wtf/)) is an Android
    cloud emulator that’s laser-focused on performance to deliver quick feedback to
    your PRs.
  prefs: []
  type: TYPE_NORMAL
- en: '**Kobiton** ([https://kobiton.com/](https://kobiton.com/)) is a cloud-based
    mobile testing platform that enables developers and QA teams to test their mobile
    applications on various real devices and simulators. It provides extensive features
    to ensure comprehensive app testing across different platforms and devices.'
  prefs: []
  type: TYPE_NORMAL
- en: Also, **Perfecto** ([https://www.perfecto.io/](https://www.perfecto.io/)), the
    mobile testing platform by Perforce, enables developers and QA teams to test their
    mobile applications on various real devices and simulators in a secure cloud environment.
    It provides extensive features to ensure comprehensive app testing across different
    platforms and devices.
  prefs: []
  type: TYPE_NORMAL
- en: How AI and ML are changing mobile testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mobile testing has been revolutionized by AI and ML. Developers can test applications
    more swiftly and precisely because they automate testing. With the help of predictive
    analytics, bugs can be fixed more quickly. Intelligent test case generation develops
    test cases based on user behavior and utilization trends, exposing potential problems.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the expense of mobile testing can be decreased with the assistance
    of AI and ML in addition to the advantages already stated. Companies can reduce
    the expenses associated with manual labor and simplify their testing processes
    by automating them.
  prefs: []
  type: TYPE_NORMAL
- en: Codeless and AI-based testing tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AI can be a game-changer in automation testing. AI-powered testing tools can
    help improve test coverage, reduce the time and effort required for testing, and
    provide more accurate test results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some tools that can help software testers unleash the power of AI
    in automation testing:'
  prefs: []
  type: TYPE_NORMAL
- en: Applitools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Katalon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waldo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s take a closer look.
  prefs: []
  type: TYPE_NORMAL
- en: Applitools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Applitools** ([https://applitools.com/solutions/mobile-testing](https://applitools.com/solutions/mobile-testing))
    is a visual testing platform designed to help developers and QA teams automatically
    validate the appearance of their mobile applications across different devices
    and screen resolutions. It aims to streamline testing and reduce manual effort
    by leveraging AI-powered visual comparison and validation.'
  prefs: []
  type: TYPE_NORMAL
- en: It uses AI to visually compare application UIs, detecting differences with high
    accuracy and reducing false positives, which can be beneficial in usability testing
    and snapshot testing.
  prefs: []
  type: TYPE_NORMAL
- en: Applitools integrates with many popular testing frameworks, such as XCUITest,
    Appium, and Espresso, making incorporating visual validation into existing test
    suites easy.
  prefs: []
  type: TYPE_NORMAL
- en: It offers extensive coverage of different browsers, devices, and screen resolutions,
    ensuring that applications are visually tested on diverse configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Katalon AI Visual Testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to the Katalon ecosystem, Katalon Visual Testing helps you optimize
    your testing performance and save time by integrating seamlessly without any setup
    effort. On top of functional testing, it identifies unexpected visual changes
    to the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Using AI, Katalon identifies and matches various zones between the baseline
    image and the checkpoint image, then highlights changes in the layout. In addition,
    ML models are used to extract and compare texts from the two images, which can
    help users identify texts that have been modified from the original version regardless
    of font family, font size, or color.
  prefs: []
  type: TYPE_NORMAL
- en: You can also run it in parallel with functional tests to cover E2E scenarios
    and visual regressions.
  prefs: []
  type: TYPE_NORMAL
- en: Waldo
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Other services provide us with AI testing tools and platforms, such as **Waldo**
    ([https://www.waldo.com/](https://www.waldo.com/)) from Tricentis. This is a codeless
    mobile app testing platform that’s designed to help developers and QA teams automate
    and simplify the testing process for iOS and Android applications. Its codeless
    approach minimizes the learning curve and reduces the time spent on test script
    creation and maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Waldo enables users to create test scripts without writing code, using a visual
    interface to define and record test scenarios. Waldo automatically runs tests
    on every build, streamlining the process and ensuring that applications are constantly
    tested.
  prefs: []
  type: TYPE_NORMAL
- en: Waldo offers real mobile device testing in the cloud, providing accurate results
    and a realistic testing environment. Waldo’s codeless approach simplifies the
    test script creation process, making it accessible to testers with varying programming
    skills.
  prefs: []
  type: TYPE_NORMAL
- en: Two other tools worth mentioning are Testsigma and Sofy.ai.
  prefs: []
  type: TYPE_NORMAL
- en: '**Testsigma** ([https://testsigma.com/ai-driven-test-automation](https://testsigma.com/ai-driven-test-automation))
    integrates seamlessly with mobile CI/CD tools, making it easy to incorporate into
    existing development workflows.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sofy.ai** ([https://sofy.ai/](https://sofy.ai/)) is an AI-powered mobile
    app testing platform designed to help developers and QA teams automate and simplify
    the testing process for Android and iOS applications. Its AI-driven approach aims
    to reduce the time spent on test script creation and maintenance while enhancing
    overall testing efficiency. In this review, we will focus on Sofy.ai’s mobile
    testing capabilities, discuss its key features, pros, and cons, and compare it
    with other technologies on the market. Sofy.ai integrates seamlessly with mobile
    CI/CD tools, making it easy to incorporate into existing development workflows.'
  prefs: []
  type: TYPE_NORMAL
- en: By effectively managing test cases, testing teams can ensure comprehensive coverage
    of software functionality, identify and fix defects, and ultimately deliver high-quality
    software to end users.
  prefs: []
  type: TYPE_NORMAL
- en: Test case management tools play a vital role in streamlining this process and
    enhancing the efficiency of the testing effort. Let’s discuss the concept of test
    case management and cover some popular test case management tools.
  prefs: []
  type: TYPE_NORMAL
- en: Test case management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To ensure high-quality mobile applications are delivered to customers, test
    case management must be integrated with test automation and mobile DevOps. Integration
    involves using a test case management system that integrates seamlessly with automation
    tools and offers real-time reporting.
  prefs: []
  type: TYPE_NORMAL
- en: This integration allows developers to automate tests for different scenarios
    and execute them across multiple devices in a controlled environment.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, integrating testing into the DevOps pipeline facilitates automated
    testing, early defect identification, and rapid feedback.
  prefs: []
  type: TYPE_NORMAL
- en: Test case management integrated with test automation and mobile DevOps can improve
    the quality of mobile apps, reduce development time, and increase efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: A popular test case management tool that integrates well with test automation
    and mobile DevOps is **TestRail**. It is a web-based test case management tool
    that allows teams to create, manage, and organize test cases. TestRail can be
    embedded into CI/CD pipelines such as Jenkins, GitLab, GitHub Actions, and more,
    as well as mobile testing frameworks such as Appium, Espresso, and XCUITest.
  prefs: []
  type: TYPE_NORMAL
- en: With TestRail’s extensive API, webhooks, or CLI, you can easily customize your
    QA processes so that they fit your specific testing workflows and integrate with
    your tech stack.
  prefs: []
  type: TYPE_NORMAL
- en: Some other test case management tools are **Zephyr** ([https://smartbear.com/test-management/zephyr/](https://smartbear.com/test-management/zephyr/))
    and **Testmo** ([https://www.testmo.com/](https://www.testmo.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: Test reports, insights, and analytics are critical components of a successful
    testing process and strategy. When you’re measuring the success of your test automation
    progress, test reports, insights, and analytics help stakeholders understand the
    root causes of defects and make data-driven decisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the difference between test reports, test insights, and test
    analytics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Test reports**: With reports, you can summarize the testing results, including
    the number of tests executed, the number of tests that are passed and failed,
    and the overall test coverage. Test reports should be easy to understand and provide
    insights into the quality of the software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test insights**: Test insights provide deeper insights into the testing process
    by analyzing the root causes of defects and identifying areas for improvement.
    Test insights can help stakeholders understand the reasons behind test failures
    and take corrective actions to improve the quality of the software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Test analytics**: Test analytics involves analyzing test data over time to
    identify trends and patterns. Test analytics can help stakeholders identify application
    areas that are prone to defects and make data-driven decisions on improving the
    software’s quality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some examples of testing insights and analytics:'
  prefs: []
  type: TYPE_NORMAL
- en: Test coverage metrics show how much of the application has been tested and remains
    untested
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Failure rates and defect density provide information on the number of defects
    found and the rate at which they are discovered
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test execution time and efficiency can help identify bottlenecks and areas for
    improvement in the testing process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test results and pass/fail rates summarize the overall quality of the application
    and the effectiveness of the tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many tools and techniques can be used to gather testing insights and analytics,
    such as **Buildkite Test Analytics** ([https://buildkite.com/test-analytics](https://buildkite.com/test-analytics)),
    **Bitrise Insights** ([https://bitrise.io/bitrise-insights](https://bitrise.io/bitrise-insights)),
    and **Sauce Labs** **Insights** ([https://saucelabs.com/products/sauce-insights](https://saucelabs.com/products/sauce-insights)).
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to software testing, test automation tools and test case management
    are crucial for creating, organizing, and managing test cases. This helps ensure
    that software applications are thoroughly tested. However, achieving mobile test
    coverage is also important. Let’s learn how to do this.
  prefs: []
  type: TYPE_NORMAL
- en: Achieving successful mobile test coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When ensuring mobile app quality and functionality, it can be challenging to
    test mobile apps and even more difficult to get successful mobile test coverage.
    The following guidelines can be helpful:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Understand the app’s goals and requirements**: It is essential to thoroughly
    understand the needs and goals of the mobile app before you start the testing
    process. The purpose and functionality of the app should be understood, as well
    as their specific features and capabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Determine the most essential features and functions**: Prioritize test cases
    based on impact and risk. A mobile app’s most critical features and functions
    should be prioritized since not all features and functions are equally important.
    It may be necessary to identify which features and functions are most commonly
    used by users or which are most likely to affect the app’s performance or stability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**A comprehensive test plan should be developed**: After identifying the key
    features and functions of the mobile app, you can develop a comprehensive test
    plan that covers all of these features and functions. This test plan includes
    various test cases and scenarios to identify and address potential app defects
    and issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Combine manual and automated testing**: Manual and automated testing are
    essential. The use of manual testing can be effective for identifying defects
    and issues that are hard to automate, while automated testing can quickly and
    efficiently run large numbers of tests. Incorporate continuous testing into the
    development process and use appropriate testing tools and frameworks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collaborate with developers and other stakeholders**: To achieve successful
    mobile test coverage, it’s crucial to collaborate with developers and other stakeholders
    throughout the testing process. Working together to identify and fix potential
    app issues and defects can involve sharing test results and feedback.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These guidelines will help you ensure your mobile app is thoroughly tested,
    ready for release, and effective.
  prefs: []
  type: TYPE_NORMAL
- en: Tips for successful CI/CD pipelines and test automation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Any successful software development project needs to have a CI/CD pipeline and
    test automation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some tips for ensuring success in these areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Building a solid foundation for your CI pipeline and test automation strategy
    involves identifying your requirements, selecting the right tools and technologies,
    and developing a clear implementation plan.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to choose the right testing tools and frameworks for the testing
    you’ll be doing. There are many tools available for manual, automated, and performance
    testing.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provide the necessary devices, emulators, simulators, and network conditions
    to set up the required environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select the target devices and platforms for your testing based on your market
    analysis. Use both real devices and emulators/simulators. To ensure wide coverage,
    ensure a mix of popular devices, operating system versions, screen resolutions,
    and form factors are included.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzing the results of your CI pipeline and test automation can help you identify
    trends, areas for improvement, and potential issues. Using these insights, you
    can continuously refine and improve your processes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Investing in training for your team can help them develop the necessary skills
    and knowledge to implement and maintain your CI pipeline and test automation strategy
    successfully.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure the highest level of quality for your mobile application by continuously
    improving your testing strategy based on results and feedback. Update your test
    cases, scripts, and tools as needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Skills for mobile testers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Mobile testers play a critical role in ensuring the quality and reliability
    of mobile applications. Here are some essential skills that mobile testers should
    have:'
  prefs: []
  type: TYPE_NORMAL
- en: A mobile tester should be able to communicate and collaborate effectively with
    other stakeholders, including developers, product owners, and business analysts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A mobile tester must be able to identify, analyze, and troubleshoot issues and
    defects in mobile applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mobile testers need to understand the operating system, device types, and screen
    sizes of the mobile platforms they are testing on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To identify potential issues and defects, mobile testers should be familiar
    with the mobile app architecture, including how the frontend and backend interact.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To automate repetitive tests and increase test coverage, mobile testers should
    be familiar with test automation tools and techniques, including frameworks such
    as Appium, Espresso, and XCUITest.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mobile testers need to be able to test the performance of mobile applications,
    including checking for issues such as app crashes and slow loading times.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To be a successful mobile tester, testers should have a strong understanding
    of app security and be able to test for potential security issues such as malware
    and unauthorized access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mobile testers must be proficient in using bug tracking and reporting tools
    so that they can log, track, and report bugs to the development teams effectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to improve your mobile testing skills
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve discussed the skills that mobile testers require, let’s discuss
    how to improve our mobile testing skills.
  prefs: []
  type: TYPE_NORMAL
- en: 'Keeping up with the ever-evolving world of mobile applications requires improving
    your mobile testing skills. You can do this in various ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the various mobile platforms and operating systems available,
    such as Android and iOS, is a great place to start.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Participate in real-world projects to experience mobile testing in the real
    world.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping up with the latest trends in mobile technology, such as 5G or IoT, will
    enable you to anticipate challenges and opportunities in the future.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Become familiar with different mobile devices, operating systems, and browsers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about Appium, XCUITest, Espresso, Detox, and Maestro, some of the most
    popular mobile testing tools and frameworks available today.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To exchange knowledge and best practices, join a community of mobile testers,
    such as an online forum or a local meetup.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continue your education by taking online courses, reading blogs, joining webinars,
    and attending industry events. Keeping up with these resources will help you stay
    informed and adaptable in the rapidly changing mobile testing world.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testers should be able to combine technical skills, such as knowledge of mobile
    platforms and test automation, with soft skills, such as communication and problem-solving.
    Mobile testers must have a diverse skill set to assist with ensuring the quality
    and reliability of mobile applications, ultimately ensuring the best possible
    customer experience.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we examined the numerous aspects of mobile app testing. We
    learned how vital it is to test mobile applications to provide users with high-quality
    experiences. We also explored the advantages of test automation, such as quicker
    testing cycles and consistent results across platforms and devices. This helped
    us understand the significance of a well-planned testing strategy to overcome
    the challenges and obstacles in mobile app testing.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, we gained valuable insights into the various testing tools, frameworks,
    and services available for mobile apps. We understood the importance of testing
    the mobile app UI and functionality to ensure seamless user experiences. Our exploration
    of testing on cloud devices and the impact of AI and ML on mobile testing deepened
    our understanding, leading us to recognize the necessity of comprehensive test
    case management.
  prefs: []
  type: TYPE_NORMAL
- en: This streamlines the testing process, resulting in successful mobile test coverage
    across various devices, operating system versions, and network conditions. By
    incorporating these concepts, developers can implement effective mobile app testing
    strategies to create robust and reliable applications that meet user expectations.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will cover mobile app release management. It’s important to
    release mobile apps efficiently due to fast-paced technology and user experience
    needs. We’ll also discuss the top practices and challenges.
  prefs: []
  type: TYPE_NORMAL
