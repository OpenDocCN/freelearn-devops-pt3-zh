["```\ntype record []string\nfunc (r record) validate() error {\n     if len(r) != 2 {\n          return errors.New(\"data format is incorrect\")\n     }\n     return nil\n}\nfunc (r record) first() string {\n     return r[0]\n}\nfunc (r record) last() string {\n     return r[1]\n}\nfunc readRecs() ([]record, error) {\n     b, err := os.ReadFile(\"data.csv\")\n     if err != nil {\n          return nil, err\n     }\n     content := string(b)\n     lines := strings.Split(content, \"\\n\") // Split by line\n     var records []record\n     for i, line := range lines {\n          // Skip empty lines\n          if strings.Trimspace(line) == \"\" {\n               continue\n          }\n          var rec record = strings.Split(line, \",\")  \n          if err := rec.validate(); err != nil {\n               return nil, fmt.Errorf(\"entry at line %d was invalid: %w\", i, err)\n          }\n          records = append(records, rec)\n     }\n     return records, nil\n}\n```", "```\nfunc readRecs() ([]record, error) { \n    file, err := os.Open(\"data.csv\") \n    if err != nil { \n        return nil, err \n    } \n    defer file.Close() \n    scanner := bufio.NewScanner(fakeFile) \n    var records []record \n    lineNum := 0 \n    for scanner.Scan() { \n        line := scanner.Text() \n        if strings.TrimSpace(line) == \"\" { \n            continue \n        } \n        var rec record = strings.Split(line, \",\") \n        if err := rec.validate(); err != nil { \n            return nil, fmt.Errorf(\"entry at line %d was invalid: %w\", lineNum, err) \n        } \n        records = append(records, rec) \n        lineNum++ \n    } \nreturn records, scanner.Err()\n}\n```", "```\nfunc writeRecs(recs []record) error {\n     file, err := os.OpenFile(\"data-sorted.csv\", os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0644)\n     if err != nil {\n          return err\n     }\n     defer file.Close()\n     // Sort by last name\n     sort.Slice(\n           recs, \n           func(i, j int) bool { \n               return recs[i].last() < recs[j].last()\n           },\n     )\n     for _, rec := range recs {\n          _, err := file.Write(rec.csv())\n          if err != nil {\n               return err\n          }\n     }\n     return nil\n}\n```", "```\n// csv outputs the data in CSV format.\nfunc (r record) csv() []byte {\n     b := bytes.Buffer{}\n     for _, field := range r {\n          b.WriteString(field + \",\")\n     }\n     b.WriteString(\"\\n\")\n     return b.Bytes()\n}\n```", "```\nfunc readRecs() ([]record, error) { \n    file, err := os.Open(\"data.csv\") \n    if err != nil { \n        return nil, err \n    } \n    defer file.Close() \n    reader := csv.NewReader(file) \n    reader.FieldsPerRecord = 2 \n    reader.TrimLeadingSpace = true \n    var recs []record \n    for { \n        data, err := reader.Read() \n        if err != nil { \n            if err == io.EOF{ \n                break \n            } \n            return nil, err \n        } \n        rec := record(data) \n        recs = append(recs, rec) \n    } \n    return recs, nil \n}\n```", "```\nw := csv.NewWriter(file) \ndefer w.Flush() \nfor _, rec := range recs {\n     if err := w.Write(rec); err != nil {\n          return err\n     }\n}\nreturn nil\n```", "```\nfunc main() {\n    const sheet = \"Sheet1\"\n    xlsx := excelize.NewFile()    \n    xlsx.SetCellValue(sheet, \"A1\", \"Server Name\")\n    xlsx.SetCellValue(sheet, \"B1\", \"Generation\")\n    xlsx.SetCellValue(sheet, \"C1\", \"Acquisition Date\")\n    xlsx.SetCellValue(sheet, \"D1\", \"CPU Vendor\")\n    xlsx.SetCellValue(sheet, \"A2\", \"svlaa01\")\n    xlsx.SetCellValue(sheet, \"B2\", 12)\n    xlsx.SetCellValue(sheet, \"C2\", mustParse(\"10/27/2021\"))\n    xlsx.SetCellValue(sheet, \"D2\", \"Intel\")\n    xlsx.SetCellValue(sheet, \"A3\", \"svlac14\")\n    xlsx.SetCellValue(sheet, \"B3\", 13)\n    xlsx.SetCellValue(sheet, \"C3\", mustParse(\"12/13/2021\"))\n    xlsx.SetCellValue(sheet, \"D3\", \"AMD\")\n    if err := xlsx.SaveAs(\"./Book1.xlsx\"); err != nil {\n        panic(err)\n    }\n}\n```", "```\ntype serverSheet struct {\n    mu sync.Mutex\n    sheetName string\n    xlsx *excelize.File\n    nextRow int\n}\nfunc newServerSheet() (*serverSheet, error) {\n    s := &serverSheet{\n        sheetName: \"Sheet1\",\n        xlsx: excelize.NewFile(),\n        nextRow: 2,\n    }\n    s.xlsx.SetCellValue(s.sheetName, \"A1\", \"Server Name\")\n    s.xlsx.SetCellValue(s.sheetName, \"B1\", \"Generation\")\n    s.xlsx.SetCellValue(s.sheetName, \"C1\", \"Acquisition\")\n    s.xlsx.SetCellValue(s.sheetName, \"D1\", \"CPU Vendor\")\n    return s, nil\n}\n```", "```\nfunc (s *serverSheet) add(name string, gen int, acquisition time.Time, vendor CPUVendor) error {\n    s.mu.Lock()\n    defer s.mu.Unlock()\n    if name == \"\" {\n            return errors.New(\"name cannot be blank\")\n    }\n    if gen < 1 || gen > 13 {\n            return errors.New(\"gen was not in range\")\n    }\n    if acquisition.IsZero() {\n            return errors.New(\"acquisition must be set\")\n    }\n    if !validCPUVendors[vendor] {\n            return errors.New(\"vendor is not valid )\n    }\n    s.xlsx.SetCellValue(s.sheetName, \"A\" +\nstrconv.Itoa(s.nextRow), name)\n    s.xlsx.SetCellValue(s.sheetName, \"B\" + strconv.Itoa(s.nextRow), gen)\n    s.xlsx.SetCellValue(s.sheetName, \"C\" + strconv.Itoa(s.nextRow), acquisition)\n    s.xlsx.SetCellValue(s.sheetName, \"D\" + strconv.Itoa(s.nextRow), vendor)\n    s.nextRow++\n    return nil\n}\n```", "```\ntype summaries struct {\n     cpuVendor cpuVendorSum\n}\ntype cpuVendorSum struct {\n     unknown, intel, amd int\n}\n```", "```\n     ...\n     s.xlsx.SetCellValue(s.sheetName, \"D\" + strconv.Itoa(s.nextRow), vendor)\n     switch vendor {\n     case Intel:\n          s.sum.cpuVendor.intel++\n     case AMD:\n          s.sum.cpuVendor.amd++\n     default:\n          s.sum.cpuVndor.unknown++\n     }\n     s.nextRow++\n     return nil\n}\nfunc (s *serverSheet) writeSummaries() {\n    s.xlsx.SetCellValue(s.sheetName, \"F1\", \"Vendor Summary\")\n    s.xlsx.SetCellValue(s.sheetName, \"F2\", \"Vendor\")\n    s.xlsx.SetCellValue(s.sheetName, \"G2\", \"Total\")\n    s.xlsx.SetCellValue(s.sheetName, \"F3\", Intel)\n    s.xlsx.SetCellValue(s.sheetName, \"G3\", s.summaries.cpuVendor.intel)\n    s.xlsx.SetCellValue(s.sheetName, \"F4\", AMD)\n    s.xlsx.SetCellValue(s.sheetName, \"G4\", s.summaries.cpuVendor.amd)\n}\n```", "```\nfunc (s *serverSheet) createCPUChart() error {\n    c := chart.New()\n\n    c.Type = \"pie3D\"\n    c.Dimension = chart.FormatChartDimension{640, 480}\n    c.Title = chart.FormatChartTitle{Name: \"Server CPU Vendor Breakdown\"}\n    c.Format = chart.FormatPicture{\n            FPrintsWithSheet: true,\n            NoChangeAspect: false,\n            FLocksWithSheet: false,\n            OffsetX: 15,\n            OffsetY: 10,\n            XScale: 1.0,\n            YScale: 1.0,\n    }\n    c.Legend = chart.FormatChartLegend{\n            Position: \"bottom\",\n            ShowLegendKey: true,\n    }\n    c.Plotarea.ShowBubbleSize = true\n    c.Plotarea.ShowCatName = true\n    c.Plotarea.ShowLeaderLines = false\n    c.Plotarea.ShowPercent = true\n    c.Plotarea.ShowSerName = true\n    c.ShowBlanksAs = \"zero\"\n    c.Series = append(\n            c.Series,\n            chart.FormatChartSeries{\n                    Name: `%s!$F$1`,\n                    Categories: fmt.Sprintf(`%s!$F$3:$F$4`, s.sheetName),\n                    Values: fmt.Sprintf(`%s!$G$3:$G$4`, s.sheetName),\n            },\n    )\n    b, err := json.Marshal(c)\n    if err != nil {\n            return err\n    }\n    if err := s.xlsx.AddChart(s.sheetName,  \"I1\", string(b)); err != nil {\n            return err\n    }\n    return nil\n}\n```", "```\ntype Record struct {\n     Last string `json:\"last_name\"`\n}\n```", "```\nb, err := os.ReadFile(\"data.json\") \nif err != nil { \n    return \"\", \n    err\n} \ndata := map[string]interface{}{} \nif err := json.Unmarshal(b, &data); err != nil { \n    return \"\", err \n}\nv, ok := data[\"user\"]\nif !ok {\n     return \"\", errors.New(\"json does not contain key 'user'\")\n}\nswitch user := v.(type) {\ncase string:\n     return user, nil\n}\nreturn \"\", fmt.Errorf(\"key 'user' is not a string, was %T\", v)\n```", "```\nif err := json.Marshal(data); err != nil {\n     return err\n}\n```", "```\ntype Record struct {\n     Name string `json:\"user_name\"`\n     User string `json:\"user\"`\n     ID int\n     Age int `json:\"-\"`\n}\nfunc main() {\n     rec := Record{\n          Name: \"John Doak\",\n          User: \"jdoak\",\n          ID: 23,\n     }\n     b, err := json.Marshal(rec)\n     if err != nil {\n          panic(err)\n     }\n     fmt.Printf(\"%s\\n\", b)\n}\n```", "```\nrec := Record{}\nif err := json.Unmarshal(b, &rec); err != nil {\n     return err\n}\n```", "```\nconst jsonStream = `\n     {\"Name\": \"Ed\", \"Text\": \"Knock knock.\"}\n     {\"Name\": \"Sam\", \"Text\": \"Who's there?\"}\n`\ntype Message struct {\n     Name, Text string\n}\nreader := strings.NewReader(jsonStream)\ndec := json.NewDecoder(reader)\nmsgs := make(chan Message, 1)\nerrs := make(chan error, 1)\n// Parse the messages concurrently with printing the message.\ngo func() {\n     defer close(msgs)\n     defer close(errs)\n     for {\n          var m Message\n          if err := dec.Decode(&m); err == io.EOF {\n               break\n          } else if err != nil {\n               errs <- err\n               return\n          }\n          msgs <- m\n     }\n}()\n// This will print the messages as we decode them.\nfor m := range msgs {\n     fmt.Printf(\"%+v\\n\", m)\n}\nif err := <-errs; err != nil {\n     fmt.Println(\"stream error: \", err)\n}\n```", "```\nconst jsonStream = `[\n     {\"Name\": \"Ed\", \"Text\": \"Knock knock.\"},\n     {\"Name\": \"Sam\", \"Text\": \"Who's there?\"}\n]`\ndec := json.NewDecoder(reader)\n_, err := dec.Token() // Reads [\nif err != nil {\n     return fmt.Errorf(`outer [ is missing`))\n}\nfor dec.More() {\n     var m Message\n     // decode an array value (Message)\n     err := dec.Decode(&m)\n     if err != nil {\n          return err\n     }\n     fmt.Printf(\"%+v\\n\", m)\n}\n_, err = dec.Token() // Reads ]\nif err != nil {\n     return fmt.Errorf(`final ] is missing`)\n}\n```", "```\nfunc encodeMsgs(in chan Message, output io.Writer) chan error {\n     errs := make(chan error, 1)\n     go func() {\n          defer close(errs)\n          enc := json.NewEncoder(output)\n          for msg := range in {\n               if err := enc.Encode(msg); err != nil {\n                    errs <- err\n                    return\n               }\n          }\n     }()\n     return errs\n}\n```", "```\ndata := map[string]interface{}{}\nif err := yaml.Unmarshal(yamlContent, &data); err != nil {\n     return \"\", err\n}\nv, ok := data[\"user\"]\nif !ok {\n     return \"\", errors.New(\"'user' key not found\")\n}\n```", "```\nif err := yaml.Marshal(data); err != nil {\n     return err\n}\n```", "```\ntype Config struct {\n     Jobs []Job\n}\ntype Job struct {\n     Name     string\n     Interval time.Duration\n     Cmd      string\n}\nfunc main() {\n     c := Config{\n          Jobs: []Job{\n               {\n                    Name:     \"Clear tmp\",\n                    Interval: 24 * time.Hour,\n                    Cmd:      \"rm -rf \" + os.TempDir(),\n               },\n          },\n     }\n     b, err := yaml.Marshal(c)\n     if err != nil {\n          panic(err)\n     }\n     fmt.Printf(\"%s\\n\", b)\n}\n```", "```\njobs:\n- name: Clear tmp dir\n  interval: 24h0m0s\n  cmd: rm -rf /tmp\n```", "```\n     data := []byte(`\njobs:\n  - name: Clear tmp\n    interval: 24h0m0s\n    whatever: is not in the Job type\n    cmd: rm -rf /tmp\n`)\n     c := Config{}\n     if err := yaml.Unmarshal(data, &c); err != nil {\n          panic(err)\n     }\n     for _, job := range c.Jobs {\n          fmt.Println(\"Name: \", job.Name)\n          fmt.Println(\"Interval: \", job.Interval)\n     }\n\n```", "```\nline 5: field whaterver not found in type main.Job\n```"]