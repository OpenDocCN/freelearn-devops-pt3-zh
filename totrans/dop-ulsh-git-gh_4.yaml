- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Elevating Team Collaboration with GitHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations on reaching this pivotal chapter of our journey! Now, it is
    time to delve deeper, moving beyond the perception of GitHub as merely a code
    hosting platform. GitHub is where the world builds software, where development
    processes are streamlined, and where the spirit of DevOps truly comes to life.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will dive into the practical aspects of using GitHub, transforming
    theory into action. Our focus will be on specific GitHub features crucial for
    teamwork and collaboration in a DevOps environment. Each section is crafted to
    enhance your understanding and skills, ensuring a smooth transition from traditional
    systems to modern DevOps practices. Let’s embark on this exciting journey with
    GitHub, a powerful ally in the DevOps toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following main headings in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Issues – Collaboration excellence at GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pull request excellence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting the best out of GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub repository excellence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start with a hands-on experience working with GitHub. If you want to
    grasp the big picture of GitHub again, please go back to [*Chapter 1*](B21203_01.xhtml#_idTextAnchor014)
    to see what GitHub is all about.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Configuration instructions for proceeding with this section can be found in
    the following repository. Please make sure the Git and SSH tools are installed.
    For Windows users, it is recommended to use PowerShell. I also encourage you to
    get the most up-to-date information written about the different commands and environments:
    [https://github.com/PacktPublishing/DevOps-Unleashed-with-Git-and-GitHub](https://github.com/PacktPublishing/DevOps-Unleashed-with-Git-and-GitHub).'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with GitHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let’s get started with the GitHub experience. This section explains how
    to get started with GitHub and covers basic repository operations. You will also
    learn how to use Git to interact with remote repositories, completing the journey
    of Git basics here!
  prefs: []
  type: TYPE_NORMAL
- en: Setting up your GitHub account
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Embarking on your GitHub journey begins with a simple sign-up process. Navigate
    to the GitHub website and register by providing a username, email, and password.
    This step is your gateway to the realms of collaborative development, offering
    a suite of features for team collaboration and project management.
  prefs: []
  type: TYPE_NORMAL
- en: Once registered, you are all set to create repositories and push your code to
    GitHub, marking the start of your Git journey. GitHub serves not just as a tool
    but as a cornerstone in your DevOps journey, fostering collaboration and driving
    innovation. If you already have a GitHub account, feel free to move to the next
    steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sign up, visit [https://github.com/](https://github.com/) and click the
    **Sign up** button located at the top right of the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Home page of github.com](img/B21203_04_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Home page of github.com
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter your email, choose a password, and select a unique username. After completing
    a few confirmation steps, you will receive a confirmation email. Use the code
    provided to finalize your GitHub account setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Registration page on github.com and confirmation email](img/B21203_04_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Registration page on github.com and confirmation email
  prefs: []
  type: TYPE_NORMAL
- en: With these steps, your GitHub account is ready, paving the way to create your
    first repository. The account creation experience is current at the time of writing.
    It may change in the future, but it is basically a straightforward way.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your first GitHub repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When logging in to GitHub, the menu for creating a new repository varies depending
    on your user status. New users are directly presented with a **Create repository**
    button, while existing users will find the **New** button within their list of
    repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – The button to create a new repository](img/B21203_04_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – The button to create a new repository
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the repository creation settings screen appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Creating a new repository](img/B21203_04_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Creating a new repository
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a repository involves a few key decisions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Repository location**: Choose the owner (yourself or an organization you
    are part of) and provide a unique name for your repository under the selected
    owner.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visibility**: Decide whether your repository will be public or private. With
    a **public** repository, your project is accessible to anyone around the world,
    making it a part of the open source community where sharing and collaboration
    are encouraged. On the other hand, a **private** repository is for work you want
    to keep to yourself or share with selected individuals, offering confidentiality.
    For members of organizations under a GitHub Enterprise plan, there is an option
    to create **internal** repositories. These repositories are perfect for InnerSource
    initiatives as they are only visible within your enterprise, providing a secure
    environment for collaborative projects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`README.md`, `.gitignore`, or `LICENSE` file. Including a `README.md` file
    is like providing a welcoming guidebook for your project; it is where you explain
    what your project is about, how to use it, and any other important information
    a visitor should know. If your project is open source, picking the right license
    from the get-go is especially essential. It sets the rules for how others can
    use and contribute to your project. Selecting these options means GitHub will
    automatically run the `git init` command inside. If you are planning to push an
    existing project to GitHub, leave these unchecked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For this example, leave all initialization checkboxes unchecked, resulting
    in a blank repository. This sets the stage for uploading your local files in the
    next steps. After filling in the repository details, click the **Create repository**
    button. This action will bring your new repository to life:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Created repository](img/B21203_04_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Created repository
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations on creating your new GitHub repository! This milestone marks
    a significant step in your journey as a developer, opening doors to collaboration,
    innovation, and growth in the world of DevOps and open source development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will connect your local repository to a remote repository, which includes
    generating and registering an SSH key for GitHub. The details of setting up SSH
    connections will be crucial in upcoming sections, so make sure to take note of
    the SSH URL string. Click the **SSH** button and then the copy icon to copy the
    values as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Information on SSH connection](img/B21203_04_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Information on SSH connection
  prefs: []
  type: TYPE_NORMAL
- en: Registering your SSH key
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, it is time to set up your SSH keys. To do this, navigate to the settings
    by clicking the top-right menu button on GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Opening the menu](img/B21203_04_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Opening the menu
  prefs: []
  type: TYPE_NORMAL
- en: 'From this menu bar, you have the ability to navigate to various sections of
    your GitHub account. You can view your profile and manage the repositories and
    organizations you are a part of. Now, select **Settings** in the menu bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – Clicking Settings in the menu bar to open the setting](img/B21203_04_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – Clicking Settings in the menu bar to open the setting
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you are in the **Settings** section, look for **SSH and GPG keys** in
    the left-hand menu. Here, you will have the option to create a new SSH key:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Settings](img/B21203_04_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – Settings
  prefs: []
  type: TYPE_NORMAL
- en: After clicking on the **New SSH key** button, you will be prompted to input
    a title and select the key type. At this stage, you should choose **Authentication
    Key**. Then, you can input the SSH key into the given field.
  prefs: []
  type: TYPE_NORMAL
- en: Now, here you will need your SSH key to register! Let’s see how to make one
    next. You can skip this process if you have already registered
  prefs: []
  type: TYPE_NORMAL
- en: Creating your SSH key is a crucial step in setting up a secure environment for
    managing your code on GitHub. This process is especially important if you are
    new to SSH keys or do not already have one. You can check if you have an existing
    key by navigating to the `~/.ssh` directory in your terminal. This directory typically
    holds your SSH configuration files and keys. If you find no existing keys or want
    to create a new one specifically for GitHub, let’s create it.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open your terminal and navigate to the SSH directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, generate a new SSH key with the `ssh-keygen` command. You will be using
    an RSA key for this purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This command initiates the process of key generation and shows up the following
    message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When prompted, enter the filename in which to save the key. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this scenario, I will use `git_key` as the key name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you will be asked to enter a passphrase. This adds an extra layer of
    security:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: For further insight, adding a passphrase to your SSH key is a key security step.
    If someone gets your private key without permission, they still cannot use it
    without the passphrase. This protects against unauthorized use. You need to enter
    the passphrase every time you use the key, making sure only people with both the
    key and passphrase can get in. This extra layer of security makes your SSH connections
    much safer and is advised for protecting important information and access. After
    these steps, you will see a confirmation that your identification (private key)
    and your public key have been saved. A unique key fingerprint and a random art
    image will also be displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you need to check and copy your new public SSH key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the displayed SSH key (begins with `ssh-rsa`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s add this SSH key to your GitHub account. Again, navigate to GitHub
    settings, find the **SSH and GPG keys** section, and paste and save your key there:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – Adding a new SSH key](img/B21203_04_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – Adding a new SSH key
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up or modify your SSH connections, let’s start by creating a configuration
    file using the `touch` command, which creates a new file or updates the last modified
    time of an existing one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, with the config file ready, it is time to add specific configurations
    for GitHub SSH connections. Ensure you replace `git_rsa` with the name of your
    private SSH key file. For those who have followed the earlier steps to create
    a new key, your filename should be `git_rsa`. If you are an experienced Git user,
    you might already have some SSH configurations in this file. In such a scenario,
    you should update or replace the existing configurations. For those adding new
    configurations, input these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: After inputting these lines, save and close the file. This configuration instructs
    your system on which SSH key to use for GitHub and under which user account.
  prefs: []
  type: TYPE_NORMAL
- en: It is also recommended to verify your SSH connection to GitHub to ensure everything
    is set up correctly. You can do this by running the `ssh -T git@github.com` command.
    This step helps confirm that your system can successfully communicate with GitHub
    using the SSH key specified in your configuration.
  prefs: []
  type: TYPE_NORMAL
- en: git remote – Connecting local and remote repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is time to bridge your local development with the world of GitHub. If you
    are continuing from an existing repository in an earlier section, simply move
    into that directory with the `cd` command, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'For those who want to create a new project, setting up a fresh repository is
    a straightforward affair. Begin by creating a new directory, initializing a Git
    repository, and preparing a `README` file—the hallmark of any new project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Remember to use the SSH URL you noted in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Connecting your local repository to a remote repository on GitHub involves
    adding a remote URL. This linkage allows you to push your local changes to GitHub.
    Establish this connection with the `git remote add` command, ensuring to replace
    `[Username]` and `[Repository]` with your GitHub username and the repository’s
    name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'For cases where your repository already has a remote URL but needs an update,
    `git remote set-url` is the command of choice. This command updates your Git configuration
    to the new remote repository URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With these steps, you have successfully linked your local and remote repositories.
    This connection is a pivotal point in managing your project, ensuring that your
    local developments are mirrored on GitHub for further progress and collaboration.
  prefs: []
  type: TYPE_NORMAL
- en: As we move forward, the next step will be to push your local code to GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: git push – Making your code count
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, it is time to push your local commits to the remote repository. This
    step updates the remote repository with the changes you have made locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When you use `-u` or `--set-upstream` with `git push`, you are effectively setting
    the upstream for the current branch in your local repository to the `main` origin.
  prefs: []
  type: TYPE_NORMAL
- en: By specifying this upstream, you simplify your future interactions with the
    remote repository. Once the upstream is set, you can use `git push` without additional
    parameters to push to the same branch on the remote repository. This means that
    a subsequent `git push` operation will automatically know to push your commits
    to the `main` origin.
  prefs: []
  type: TYPE_NORMAL
- en: Examining code on GitHub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let’s examine what the pushed code looks like on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you visit a GitHub repository, the first thing that greets you is the
    repository’s main page. Here, you can see the most recently updated files, the
    `README.md` file (if available), and various repository details. This view provides
    a quick snapshot of the project’s contents and purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – GitHub repository page after pushing the code](img/B21203_04_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 – GitHub repository page after pushing the code
  prefs: []
  type: TYPE_NORMAL
- en: Editing code on GitHub
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One of the key features is the ability to interact with code directly on GitHub.
    You can add or edit files using the interface itself, which is particularly useful
    for small changes or quick fixes. Here’s how to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the *edit* button in the upper-right corner to enter the edit mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.12 – Entering the edit mode](img/B21203_04_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 – Entering the edit mode
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then edit and commit your changes. Remember that this commits directly
    to your code base:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.13 – Edit page on GitHub](img/B21203_04_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.13 – Edit page on GitHub
  prefs: []
  type: TYPE_NORMAL
- en: 'This action commits your changes directly to your remote repository. However,
    you also have the flexibility to select a destination and branch for your commit.
    While the default is typically the branch you are currently working on, you have
    the option to create a new branch simultaneously, which can be particularly useful
    when starting a new contribution. If you choose to create a new branch, you can
    still merge it later into the mainline:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.14 – Committing changes](img/B21203_04_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.14 – Committing changes
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you should see the changes reflected, as in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 4.15 – After the commit, you will return to the code screen](img/B21203_04_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.15 – After the commit, you will return to the code screen
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing code and changes on GitHub
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let’s look inside GitHub via the code we just updated. For a closer look
    at the code, GitHub provides several views in the file browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Preview** mode is the default, available for certain file types such as Markdown,
    and displays the file as it would appear in its formatted state:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 4.16 – Preview mode](img/B21203_04_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.16 – Preview mode
  prefs: []
  type: TYPE_NORMAL
- en: '**Code** mode shows the contents of the file as it is in the latest commit,
    with beautiful syntax highlighting:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 4.17 – Code mode](img/B21203_04_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.17 – Code mode
  prefs: []
  type: TYPE_NORMAL
- en: '**Blame** mode is particularly insightful, as it breaks down the file by lines,
    showing who last modified each line and in which commit. This is invaluable for
    understanding the evolution of code and tracking changes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 4.18 – Blame mode](img/B21203_04_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.18 – Blame mode
  prefs: []
  type: TYPE_NORMAL
- en: 'This is useful when you do not want to get code locally and review it but want
    to take a look at the code on GitHub first. Within the GitHub repository interface,
    you have the ability to explore the commit history of the project. This feature
    allows you to delve into the specifics of each commit, examining changes made:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.19 – Change history on GitHub](img/B21203_04_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.19 – Change history on GitHub
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, GitHub offers the functionality to comment on these changes,
    enabling you to engage in discussions or provide feedback on specific alterations
    made in the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.20 – GitHub commit view](img/B21203_04_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.20 – GitHub commit view
  prefs: []
  type: TYPE_NORMAL
- en: Managing branches on GitHub
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Managing branches on GitHub is easy. Here is a brief overview of branch management
    on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, navigating between different branches in a repository is a common task.
    On GitHub, you can easily switch between branches using the branch drop-down menu,
    typically found at the top of the repository page. This feature allows you to
    swiftly move from one branch to another, enabling you to review different versions
    or stages of the project efficiently:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.21 – Switching branches on GitHub](img/B21203_04_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.21 – Switching branches on GitHub
  prefs: []
  type: TYPE_NORMAL
- en: 'With repositories that have multiple branches, finding a specific branch can
    become challenging. GitHub provides a search functionality within the branch drop-down
    menu. This feature allows you to quickly filter and find the branch you are looking
    for, saving time and improving your workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.22 – Searching for branches on GitHub](img/B21203_04_022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.22 – Searching for branches on GitHub
  prefs: []
  type: TYPE_NORMAL
- en: 'Starting a new line of development is often done by creating a new branch.
    GitHub simplifies this process to create a new branch. You can name the new branch
    and base it on an existing one, making it straightforward to branch off for new
    features or experiments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.23 – Creating a branch on GitHub](img/B21203_04_023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.23 – Creating a branch on GitHub
  prefs: []
  type: TYPE_NORMAL
- en: GitHub branch management features provide a seamless and efficient way to handle
    multiple lines of development within a single repository. Whether you are switching
    to view different project states, searching for a specific branch, or creating
    a new branch for development, the GitHub interface makes these tasks intuitive
    and accessible. This streamlined approach to branch management is integral to
    maintaining an organized and productive development environment.
  prefs: []
  type: TYPE_NORMAL
- en: git pull – Bridging local and remote work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have seen how GitHub manages the code we push, let’s get back to
    the command line. Get the new changes made to the local repository. We have edited
    `README.md` on GitHub, but how do we bring those changes to our local environment?
    The answer lies in the `git` `pull` command.
  prefs: []
  type: TYPE_NORMAL
- en: In the realm of version control with Git, staying updated with the latest changes
    in a remote repository is crucial for seamless collaboration and development.
    The `git pull` command is the tool designed precisely for this purpose. It serves
    as a bridge, bringing changes made remotely on platforms such as GitHub into your
    local working directory.
  prefs: []
  type: TYPE_NORMAL
- en: Using `git pull` is particularly important when working in a collaborative environment.
    Suppose your team members are committing changes to a shared repository on GitHub.
    In that case, regularly pulling these changes ensures that everyone’s work aligns
    and reduces the likelihood of conflicts or inconsistencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use `git pull`, navigate to your repository’s directory in your command
    line or terminal and enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It is a simple yet powerful command that maintains the harmony of your collaborative
    efforts and keeps your local repository up to date with the latest developments.
  prefs: []
  type: TYPE_NORMAL
- en: When you execute `git pull`, what essentially happens is a two-step process.
    First, Git fetches the updates from the remote repository—this includes all commits
    and branches that have been pushed since your last update. Then, it merges these
    updates into your local repository. This merge is critical as it integrates remote
    changes with your local work, keeping your local repository in sync with its remote
    counterpart.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `git pull` command might come across as straightforward at first glance,
    but it is actually a combination of two fundamental Git commands: `git fetch`
    and `git merge`. This dual nature makes `git pull` a powerful tool in the Git
    arsenal.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on, let’s delve deeper into the first component of this process: `git
    fetch`. This command is an essential piece of the version control puzzle, allowing
    you to see what others have been working on without merging those changes into
    your own work just yet.'
  prefs: []
  type: TYPE_NORMAL
- en: git fetch – Syncing without disruption
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`git fetch` plays a crucial role in how developers interact with remote repositories.
    At its core, `git fetch` is about safely and efficiently updating your local repository
    with changes from its remote counterpart.'
  prefs: []
  type: TYPE_NORMAL
- en: When you run `git fetch`, Git contacts the specified remote repository and pulls
    down all data from it that you do not have yet. This includes new commits, branches,
    and tags. The beauty of `git fetch` is that it does this without making any changes
    to your working files. It is like taking a sneak peek at what others have been
    doing without actually integrating their changes into your work. This feature
    makes it a non-destructive operation, ensuring your current development work remains
    untouched.
  prefs: []
  type: TYPE_NORMAL
- en: The fetched data is stored in your local repository, but it is kept separate
    from your actual project files. To incorporate these fetched changes into your
    work, you would typically follow up with a `git merge` command, which merges the
    fetched branch into your current branch. Yes—`git fetch` can show its true power
    when used with `git merge`.
  prefs: []
  type: TYPE_NORMAL
- en: Fetch versus pull
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s come back to `git pull` here a little bit. When you run `git pull`, it
    first initiates a `git fetch` operation. This part of the process reaches out
    to the remote repository and pulls in all new data it finds. This data includes
    commits, files, and references updated in the remote repository since your last
    fetch. It is a vital step to ensure you have all the latest information from the
    remote repository, but it does not automatically integrate these changes into
    your working files.
  prefs: []
  type: TYPE_NORMAL
- en: The second part of the `git pull` command is where `git merge` comes into play.
    After fetching updates, `git merge` takes these newly downloaded references and
    incorporates them into your local repository. This merging process is what actually
    updates your current working files with changes from the remote repository. It
    is a seamless integration of remote changes with your local work, keeping your
    repository in perfect sync with its remote counterpart.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the dual nature of `git pull` as a combination of fetching and
    merging operations reveals its true power in managing and synchronizing code changes
    in a collaborative environment.
  prefs: []
  type: TYPE_NORMAL
- en: Also, knowing the difference between `git fetch` and `git pull` is crucial.
    It allows you to more accurately control when and how changes from your remote
    repository are incorporated into your local work. This clear understanding is
    essential for smooth collaboration and adept repository management as it lets
    you strategically decide whether to just review changes or fully integrate them.
  prefs: []
  type: TYPE_NORMAL
- en: git clone – Bringing GitHub repos to your workspace
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Speaking of cloning and downloading, these options are readily available for
    every repository. By going to the repository page and pressing the **< > Code**
    button, you will see that there are those options. Cloning creates a local copy
    of the repository on your machine, allowing you to work on the project offline,
    while downloading provides a ZIP file of the project for backup or review purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.24 – git clone](img/B21203_04_024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.24 – git clone
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the `git clone` command is a straightforward process, making it easily
    accessible for anyone wanting to engage with a project hosted on a platform such
    as GitHub. To clone a repository, all you need is the URL of the repository you
    want to clone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`git clone` stands out as a core command, enabling you to create a precise
    local copy of an existing repository. This process involves more than just duplicating
    current files; it replicates the repository in its entirety. This includes all
    file versions, the full commit history, and all branches. By using `git clone`,
    you bring a complete, functional version of the project onto your local machine.
    This not only gives you the ability to work offline but also provides a comprehensive
    view of the project’s development history, aiding in understanding and effective
    contribution.'
  prefs: []
  type: TYPE_NORMAL
- en: Forking – More than just copying code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to `git clone`, there is another way to duplicate a repository
    on GitHub. This is especially useful for open source development. The concept
    of forking in Git, particularly on platforms such as GitHub, is a cornerstone
    of collaborative and open source development. Forking a repository means creating
    your own personal copy of someone else’s project under your account:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.25 – Forking on GitHub](img/B21203_04_025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.25 – Forking on GitHub
  prefs: []
  type: TYPE_NORMAL
- en: When you fork a repository, you create a personal copy of someone else’s project
    within your GitHub account. While this copy starts as a mirror of the original,
    it operates independently, meaning you can make modifications, additions, or experiments
    without affecting the original project. However, it is important to understand
    that this independence has limits. For example, if the original repository is
    deleted or its visibility changes, it can affect the fork’s status. Despite these
    dependencies, forking remains a pivotal practice in open source development, enabling
    developers to contribute through pull requests without needing direct write access
    to the source repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Forking is particularly significant in the open source world. It allows developers
    to contribute to projects by making changes in their forks and then proposing
    these changes to the original project through a process called a **pull request**.
    This is how you can contribute to a project without having direct writing access
    to the source repository. When you fork, a copy is made in your new environment,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.26 – The forked repository is managed under your environment](img/B21203_04_026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.26 – The forked repository is managed under your environment
  prefs: []
  type: TYPE_NORMAL
- en: Forking provides a unique platform where anyone, regardless of their relationship
    or level of trust with the original project maintainers, can freely experiment
    and contribute. This approach significantly lowers barriers to entry in collaborative
    coding.
  prefs: []
  type: TYPE_NORMAL
- en: By forking a repository, you create an environment where you can add your ideas,
    enhancements, or fixes to the project without impacting the upstream repository.
    This is particularly empowering for new contributors who might not yet have gained
    the trust of the project maintainers for direct access to the main repository.
    It allows them to demonstrate their capabilities and contributions in a separate,
    personal space.
  prefs: []
  type: TYPE_NORMAL
- en: 'This independent yet connected nature of a fork is crucial. It enables a two-phase
    contribution process: first, in your own fork, where you freely experiment and
    make changes, and second, via a pull request, where you propose these changes
    to be merged into the original project. This workflow fosters a culture of open
    collaboration, where ideas and contributions are freely exchanged, and the best
    ones are seamlessly integrated into projects.'
  prefs: []
  type: TYPE_NORMAL
- en: In essence, forking is more than just copying a repository; it is about participating
    in a larger community. Whether you are contributing to an existing project, starting
    a new one based on someone else’s work, or just experimenting, forking is an essential
    aspect of working with Git and GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: You have learned the basics of Git commands and how to manage Git repositories,
    both individually and in a collaborative remote environment. Now, you are ready
    to dive into GitHub Issues and pull requests, essential tools for communication
    in GitHub. These features, although seemingly straightforward, play a crucial
    role in the success of open source projects. They serve as platforms for idea
    generation, discussions, and reviews, fostering a culture of communal development
    and innovation. As we proceed, we will explore how these functionalities enhance
    communication and collaboration, contributing to development on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Issues – Collaboration excellence at GitHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitHub Issues stands as a multifaceted tool within the GitHub ecosystem, essential
    for orchestrating collaborative efforts. It functions not merely as a place to
    report problems but as a comprehensive system for tracking various types of tasks
    and activities related to your projects. This includes managing bugs, proposing
    enhancements, and monitoring other essential tasks within your GitHub repositories.
  prefs: []
  type: TYPE_NORMAL
- en: In the DevOps environment, GitHub Issues plays a crucial role by facilitating
    continuous feedback and seamless collaboration. It acts as a transparent, efficient
    platform where developers can flag issues, team members can suggest new features,
    and stakeholders can engage in meaningful discussions about potential enhancements.
    This functionality is in perfect harmony with the core principles of DevOps, which
    emphasize breaking down organizational barriers, promoting open communication,
    and nurturing a culture of continuous improvement and adaptation.
  prefs: []
  type: TYPE_NORMAL
- en: By leveraging GitHub Issues, teams can create a shared, accessible space that
    fosters collaboration and ensures that everyone involved in a project is on the
    same page. It is not just about tracking problems; it is about building a dynamic,
    responsive environment where ideas can flourish and be efficiently managed.
  prefs: []
  type: TYPE_NORMAL
- en: What makes GitHub Issues unique
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s now look at the unique role of GitHub Issues in fostering transparency
    and enhancing developer experience.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Issues stands as a unique tool in the landscape of software development,
    particularly in its approach to transparency and collaboration. This tool, integral
    to GitHub, has redefined how development teams, and indeed broader open source
    communities, communicate and collaborate on projects. The significance of GitHub
    Issues lies not just in its functionality as a bug-tracking or feature-request
    tool, but in its role in cultivating an open, transparent, and community-driven
    approach to software development, echoing the ethos of the open source movement.
  prefs: []
  type: TYPE_NORMAL
- en: The importance of transparency in development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Transparency in software development is about making the entire process of
    creating, modifying, and maintaining software visible and understandable to all
    stakeholders involved, from developers to end users. This transparency is crucial
    for several reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Improved collaboration**: When all aspects of a project are visible, team
    members can collaborate more effectively. Everyone has access to the same information,
    leading to better decision-making and a shared understanding of goals and challenges.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increased accountability**: Transparency leads to a clearer allocation of
    responsibilities. Team members are more accountable for their work when it is
    visible to others, fostering a sense of ownership and commitment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhanced quality and innovation**: Open access to project data allows for
    more eyes on the project, resulting in more feedback, ideas, and critiques. This
    collective scrutiny not only enhances quality but also spurs innovation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Trust building**: Transparency builds trust among team members and with external
    stakeholders, including users and customers. Trust is crucial for long-term project
    success and for establishing reliable, user-focused software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub Issues – A catalyst for transparent collaboration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GitHub Issues exemplifies this transparent approach. Unlike tools that allow
    for detailed, hierarchical permissions, GitHub Issues typically operates on a
    more open-access model. Every issue, its discussion thread, and the decisions
    made are visible to all team members, and often to the public in open source projects.
    This openness prevents information silos and encourages a bottom-up culture where
    ideas and feedback can come from any level within the organization or the community.
  prefs: []
  type: TYPE_NORMAL
- en: This approach aligns seamlessly with the ethos of open source development, which
    values community contribution, shared responsibility, and open dialogue. By adopting
    a similar model internally, companies can reap the benefits of this open source
    approach, breaking down organizational silos and fostering a community-like atmosphere
    within teams. It encourages developers to take initiative, contribute ideas, and
    engage in healthy, constructive debates.
  prefs: []
  type: TYPE_NORMAL
- en: Open source as a model for internal collaboration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The open source way of working, facilitated by tools such as GitHub Issues,
    is an excellent strategy for enhancing the developer experience. It brings the
    collaborative, transparent nature of open source communities into the internal
    workings of an organization. Developers feel more engaged and valued when they
    can see the impact of their work and contribute to discussions beyond their immediate
    tasks. This open environment nurtures a sense of community, improves morale, and
    can significantly boost innovation and productivity.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the transparency and openness fostered by GitHub Issues and the open
    source model provide invaluable learning opportunities. Developers can learn from
    each other, gain insights from different perspectives, and grow by being exposed
    to a variety of challenges and solutions. This environment is conducive to personal
    and professional development, crucial for retaining talent and keeping teams motivated
    and productive.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Issues is a collaboration catalyst
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In summary, GitHub Issues plays a pivotal role in promoting transparency and
    a community-driven approach to software development. Drawing inspiration from
    open source practices helps break down organizational barriers, fosters a collaborative
    and transparent work culture, and significantly enhances the developer experience.
    In an era where software development is increasingly about community and collaboration,
    GitHub Issues stands as a beacon, guiding teams toward a more open, inclusive,
    and effective way of working.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a look at an issue from that perspective.
  prefs: []
  type: TYPE_NORMAL
- en: Crafting an issue – Essentials for a well-structured issue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating your first issue on GitHub may initially seem challenging because
    of its simplicity, but mastering this skill is crucial for effective collaboration.
    A well-structured issue is key: it should be clear, concise, and actionable. The
    goal is to provide enough context to make your point understandable without bombarding
    your collaborators with excessive information. Begin by clearly identifying the
    issue, explaining its importance, and outlining the desired outcome.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The process begins in your GitHub repository. If you have an existing repository
    or have just created one, you will find the **Issues** tab in the repository menu.
    Here, you can initiate a new issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.27 – New issue](img/B21203_04_027.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.27 – New issue
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating an issue is straightforward. The interface presents fields for the
    title and main description, along with metadata options such as assignees and
    labels. The focus should be on the content of the issue. GitHub supports Markdown
    for documentation formatting, so it is beneficial to familiarize yourself with
    Markdown syntax. However, remember that simplicity is key—Markdown is not as feature-rich
    as Microsoft Word, but it is perfect for creating clean, straightforward documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.28 – Creating an issue on GitHub](img/B21203_04_028.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.28 – Creating an issue on GitHub
  prefs: []
  type: TYPE_NORMAL
- en: 'Within an issue, you can assign it to team members and also mention individuals
    or teams directly in the content for notifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.29 – Assigning an issue to other users](img/B21203_04_029.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.29 – Assigning an issue to other users
  prefs: []
  type: TYPE_NORMAL
- en: Labeling tasks (for example, as a bug, documentation, or enhancement) is also
    possible. While custom labels can be created, it is advisable to start with default
    labels and enhance them gradually. Overusing labels can lead to confusion and
    categorization challenges. If your team or organization has specific labeling
    standards, it is best to adhere to those.
  prefs: []
  type: TYPE_NORMAL
- en: 'The approach to using issues in GitHub is not top-down but rather encourages
    a community-driven, bottom-up style. Imposing strict rules from the outset can
    limit the freedom necessary for fostering an open, agile, and collaborative culture.
    Balance is crucial; as you and your team become more accustomed to GitHub workflow,
    you can adjust your approach accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.30 – Many types of labels can be applied](img/B21203_04_030.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.30 – Many types of labels can be applied
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, you will see the submitted issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.31 – After submission of the issue](img/B21203_04_031.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.31 – After submission of the issue
  prefs: []
  type: TYPE_NORMAL
- en: So, as you can see, managing issues on GitHub is straightforward. The key lies
    in fostering collaboration and communication. In the following section, we delve
    into effective communication techniques and explore how to enhance collaboration
    within your organization using GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Effective communication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, there are a few things that go into making a great issue: the title, the
    way the description is written, and the basic way replies are made. Even if we
    actually try to write clearly, we tend to write messily in the midst of a busy
    workday. The accumulation of such contextual deficiencies can lead to miscommunication.
    By following some of the rules that will be covered, you will be able to communicate
    more wonderfully with your peers.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing effective titles – Key principles for clarity and impact
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The title of your issue is the first thing collaborators see, making it crucial
    for capturing attention and conveying the issue’s essence. Aim for a title that
    is concise yet descriptive. Avoid vague titles such as “*Problem*” or “*Feature
    Request*”—be specific. For instance, “*Fix Broken Link in README*” is far more
    informative. But why is clarity so important?
  prefs: []
  type: TYPE_NORMAL
- en: When working within an organization, you are often part of multiple repositories,
    each potentially containing a multitude of unresolved issues. To effectively manage
    and attract attention to these issues, the title plays a crucial role. It should
    be engaging yet accurate, clear but not exaggerated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are guidelines to ensure your issue titles stand out while remaining truthful
    and easy to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Concise and clear description**: Ensure your title is brief yet descriptive,
    using straightforward language that avoids technical jargon. This clarity helps
    team members quickly understand the issue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Begin with a categorical keyword**: Start with a term such as “*Fix*,” “*Enhance*,”
    or “*Optimize*” to immediately convey the nature of the issue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Summarize the core issue**: The title should succinctly capture the main
    problem or request without extraneous details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Neutral and specific**: Focus on the issue, not on who reported or will resolve
    it. If applicable, include the specific component or feature affected for better
    categorization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clarity over priority**: Avoid using the title to indicate urgency or severity.
    Instead, employ labels or the issue’s content for this purpose, ensuring the title
    remains unambiguous and focused.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, there are exceptions, and these guidelines should be customized for
    each project, but effective titles on GitHub issues **speed up triage** by quickly
    sorting and identifying issues, **enhance discoverability** for easy issue location,
    and **facilitate clear communication** across the team, ensuring everyone understands
    the issue at a glance. This streamlined approach is key to efficient repository
    management.
  prefs: []
  type: TYPE_NORMAL
- en: Providing context in descriptions – Strategies for clear and concise communication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Effective issue descriptions are the cornerstone of collaborative problem-solving
    in DevOps. To craft a compelling and clear issue description, begin by outlining
    the present scenario. This sets the stage for understanding. Next, succinctly
    state the problem or the enhancement you are suggesting. Conclude by articulating
    the preferred outcome or solution. This methodical approach ensures both comprehension
    and a constructive dialogue direction.
  prefs: []
  type: TYPE_NORMAL
- en: Context is pivotal in issue descriptions. It gives your teammates insight into
    your perspective and the circumstances in which a problem arose or the necessity
    for a feature emerged. If possible, include steps that can reproduce the issue.
    This is not just about explaining a problem; it is about bringing your collaborators
    into your experience, enabling them to gauge the issue effectively.
  prefs: []
  type: TYPE_NORMAL
- en: You can also leverage Markdown to enhance your issue’s readability and engagement.
    This simple markup language allows you to structure your issue with headers, organize
    points with bullet lists or numbered lists, and include code snippets using code
    blocks and syntax highlighting. These elements not only make your issue straightforward
    to navigate but also more appealing and easier to engage with.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are guidelines to ensure your issue description is clear, concise, and
    effectively communicates the problem or enhancement you are addressing:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Context and clarity**: Start with a clear background of the current situation,
    and define the problem or enhancement in specific terms. This sets the stage for
    understanding the issue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Outcome and reproduction steps**: Describe the desired outcome for resolution
    and, if reporting a bug, provide detailed steps for reproducing it. This clarity
    helps others visualize the solution and understand the issue’s scope.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Beautiful Markdown and emojis**: Employ Markdown and emojis to structure
    your description, making it reader-friendly with headers, lists, and code blocks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual aids and solutions**: Include screenshots or links for additional
    context. Suggesting potential solutions or workarounds can also help in initiating
    the problem-solving process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Focus and collaboration**: Keep the description focused on the issue, avoiding
    unrelated topics. Encourage feedback and be open to suggestions, promoting a collaborative
    approach to resolving the issue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Good issue descriptions **improve understanding** by providing a clear comprehension
    of the issue, **facilitate efficient problem-solving** by enabling quick assessment
    and resolution, and **enhance collaboration** by inviting constructive feedback
    and joint solution-finding. This concise approach streamlines project progress
    and teamwork.
  prefs: []
  type: TYPE_NORMAL
- en: Issue replies for a collaborative culture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GitHub issues are more than just a tool for tracking bugs; they serve as a hub
    for collaboration and documentation. When you respond to an issue, you are not
    just addressing a specific problem or query, but you are also contributing to
    the project’s passive documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replying to an issue is easy. Just write your reply in Markdown and reply.
    But even here, you need to have a philosophy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.32 – Commenting on an issue](img/B21203_04_032.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.32 – Commenting on an issue
  prefs: []
  type: TYPE_NORMAL
- en: 'On GitHub, commenting on an issue is really important, not just a mail reply.
    Let’s look at the following perspectives:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Passive documentation**: Passive documentation is a concept emerging from
    the InnerSource context, where documentation is not actively created but rather
    evolves naturally through interactions within the repository. In GitHub, every
    issue, pull request, and discussion thread becomes part of this passive documentation.
    This process is organic and bottom-up; as team members engage in conversations,
    ask for features, resolve problems, or implement solutions, their interactions
    get recorded. This creates a comprehensive, evolving record of decisions, discussions,
    and changes, contributing to a living document that captures the project’s history
    and rationale.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Centralizing communication for transparency**: In a collaborative environment,
    communication often happens through various channels such as Slack, Teams, Jira,
    and GitHub. However, centralizing project-related discussions on GitHub has significant
    advantages. It not only creates valuable documentation but also fosters a transparent
    culture. All decision-making processes and collaborations are visible and accessible
    to all team members, fostering inclusivity and understanding. When conversations
    occur on other platforms such as Slack, guiding those discussions back to GitHub
    ensures that crucial information and decisions are documented and shared within
    the entire team. This approach prevents silos and ensures that everyone, regardless
    of when they join the project, has access to the same information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Embracing positive and inclusive communication**: Effective collaboration
    is rooted in positive and inclusive communication. When replying to issues, it
    is important to acknowledge and praise good behavior, thank team members for their
    contributions, and maintain a respectful and supportive tone. This not only encourages
    a healthy team dynamic but also boosts morale and fosters a sense of belonging
    and appreciation. Inclusive communication means ensuring that everyone’s voice
    is heard and valued and their contributions are recognized. This approach not
    only strengthens team cohesion but also drives better problem-solving and innovation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In GitHub, replying to issues is more than just a response; it is an integral
    part of building passive documentation, fostering team transparency, and encouraging
    positive, inclusive communication. By treating issue replies as contributions
    to a living document, we create a rich history of the project’s evolution. Centralizing
    communication on GitHub ensures that all team members have equal access to information,
    aiding in transparent decision-making. Lastly, embracing a positive communication
    style strengthens team bonds and ensures that everyone feels valued and heard.
    This holistic approach to issue replies is not only about solving problems but
    also about building a strong, inclusive, and transparent team culture.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at pull requests in the next section. This has a very similar
    interface to GitHub Issues, with the main difference being that it involves implementation
    in addition to comments.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s get down to the heart of engineering collaboration.
  prefs: []
  type: TYPE_NORMAL
- en: Pull request excellence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GitHub pull requests feature stands as a pivotal innovation in the landscape
    of software development, one that can be credited with significantly shaping the
    **Open Source Software** (**OSS**) movement. Its introduction marked a transformative
    moment, redefining how collaboration, code integration, and **Quality Assurance**
    (**QA**) are conducted in software projects, particularly in OSS.
  prefs: []
  type: TYPE_NORMAL
- en: Pull requests in GitHub are more than just a feature; they are a foundational
    mechanism for collaboration in the world of software development. A pull request
    is essentially a request to merge a set of changes from one branch of a repository
    to another, typically from a feature or topic branch into the main or master branch.
    But the significance of pull requests goes well beyond mere code merging; they
    are a nexus for discussion, review, and refinement of code in a collaborative
    project setting.
  prefs: []
  type: TYPE_NORMAL
- en: What makes pull requests unique?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The pull request model transformed collaborative coding. It shifted the focus
    from individual code patches sent in isolation to a more interactive and community-driven
    approach. Developers could now not only submit changes but also engage in discussions
    about those changes directly within the GitHub platform. This fostered a culture
    of collaborative review and continuous feedback, essential for maintaining high
    code quality and aligning contributions with the project’s goals. Pull requests
    introduced a structured, transparent method for code reviews. Code changes are
    now easily visible and discussable within the context of a pull request, allowing
    for more detailed and productive feedback. This process ensures that changes are
    thoroughly vetted, leading to higher code quality and more robust software projects.
  prefs: []
  type: TYPE_NORMAL
- en: Pull requests have not only revolutionized the way code is reviewed and merged
    but also significantly streamlined development workflows in GitHub. By integrating
    seamlessly with GitHub native features and a plethora of third-party tools, they
    support and enhance **Continuous Integration** (**CI**) and **Continuous Deployment**
    (**CD**) practices. This integration transforms the development process, making
    it more efficient, reliable, and automated.
  prefs: []
  type: TYPE_NORMAL
- en: A fascinating development in the use of pull requests is the integration of
    pre-release testing within the pull request thread itself. This advancement has
    led to a more comprehensive and cohesive approach to ensuring code quality and
    project management. Whenever a developer initiates a pull request, it triggers
    a series of automated checks and tests. These can range from code quality assessments
    and security vulnerability scans to performance tests. The results of these tests
    are then displayed directly in the pull request, providing immediate and actionable
    feedback.
  prefs: []
  type: TYPE_NORMAL
- en: Beyond the command line
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When discussing the historical context and evolution of GitHub pull requests,
    it is important to note that the term *pull request* itself has roots in the `git
    request-pull` command in Git. This connection might lead some to view GitHub’s
    contribution as primarily providing a user interface for an existing concept rather
    than inventing something entirely new. However, a deeper exploration of the history
    and development of pull requests reveals a more significant impact.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub took a basic command-line function and transformed it into a rich, interactive,
    and collaborative feature within its web interface. This transformation was not
    just about adding a user interface layer; it was about reimagining how collaboration
    around code changes could be done.
  prefs: []
  type: TYPE_NORMAL
- en: Crafting a pull request
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Begin by selecting or creating a repository on GitHub. For this demonstration,
    we will focus on the GitHub user interface rather than the command-line interface.
    Consider a repository with only a `README.md` file as a starting point. The goal
    is to add detailed content to this file and submit a pull request for merging:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.33 – Repository page](img/B21203_04_033.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.33 – Repository page
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step involves creating a branch named `adding-details-to-readme`.
    This branch is where you will make your edits before merging them into the main
    branch. While you can create and push new branches using Git commands, GitHub
    also offers an intuitive interface for this purpose. Use the branch drop-down
    button in the top-left corner to create a branch derived from the main branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.34 – Creating a new branch via the drop-down menu](img/B21203_04_034.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.34 – Creating a new branch via the drop-down menu
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a branch is created, you can make changes on any branch, not just the
    main or master branches:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.35 – Branch creation notification](img/B21203_04_035.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.35 – Branch creation notification
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, let’s edit `README.md`. Ensure you are on the correct branch by checking
    the drop-down menu in the top-left corner before starting your edits. Then, use
    the edit button in the top-right corner to begin editing the `README` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.36 – Clicking the edit button](img/B21203_04_036.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.36 – Clicking the edit button
  prefs: []
  type: TYPE_NORMAL
- en: 'The `README.md` file is the face and gateway of your repository, welcoming
    team members and new contributors. Here, let your imagination run wild and craft
    a compelling `README`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.37 – Editing the README.md file](img/B21203_04_037.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.37 – Editing the README.md file
  prefs: []
  type: TYPE_NORMAL
- en: Well, now we are all set. Let’s get your commit reflected. Since you are already
    in the branch for editing, you may commit your edits as they are. However, if
    you open the edit window and commit it while still in the `main` branch, you still
    have the option of creating a new branch. But it is safer to consciously create
    a branch initially and commit. On the other hand, there is a branch protection
    policy configuration at GitHub that prevents you from committing directly to the
    team’s shared environment, such as `main`, `production`, and `release`, which
    will be covered in this chapter later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The title becomes the Git commit message, so think about this carefully as
    you read the previous chapters and commit it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.38 – Committing changes](img/B21203_04_038.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.38 – Committing changes
  prefs: []
  type: TYPE_NORMAL
- en: 'Once your changes are committed, you will likely see an alert on the repository’s
    home page for creating a pull request. You can also create a pull request from
    the **New pull request** button if an alert does not appear or you wish to select
    a different branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.39 – Pull request alert](img/B21203_04_039.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.39 – Pull request alert
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do not see this alert or want to select a different branch, you can
    start the same process by clicking the **New pull request** button under the **Pull**
    **requests** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21203_04_040.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.40 – Clicking the New pull request button
  prefs: []
  type: TYPE_NORMAL
- en: When navigating the interface, you may find yourself on the pull request page
    whether by following an alert or by clicking the **New pull request** button.
    Regardless of how you arrive, this is the place where you will check the history
    of your changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The way changes are presented in GitHub can vary. As illustrated in the screenshot,
    differences (or diffs) can be displayed inline, interspersed within each line
    of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.41 – Reviewing changes screen in the unified mode](img/B21203_04_041.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.41 – Reviewing changes screen in the unified mode
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, GitHub offers a split view, showcasing differences side by side.
    This bifurcated display allows for a clearer comparison between the original and
    modified code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.42 – Reviewing changes screen in the split mode](img/B21203_04_042.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.42 – Reviewing changes screen in the split mode
  prefs: []
  type: TYPE_NORMAL
- en: 'When satisfied, let’s write your pull request. A good pull request includes
    a clear title, a detailed description, and designated reviewers. As for reviewers,
    you can specify individuals or teams. The content here is somewhat like what you
    would write in an issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.43 – You can check the differences between the commits](img/B21203_04_043.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.43 – You can check the differences between the commits
  prefs: []
  type: TYPE_NORMAL
- en: Now, your writing skills are put to the test once again. The content to be concerned
    with when writing here is the same as what we were concerned with regarding issues
    in the previous section. Write in an easy-to-read, Markdown format. However, in
    this context, understanding the distinct objectives of these tools is crucial.
    The primary aim of a pull request is to be merged, typically addressed to specific
    individuals authorized to approve it. In contrast, an issue can be directed toward
    a wider and undefined audience. Therefore, when writing a description for this
    pull request, it is crucial to consider who will be reviewing it and how to write
    it.
  prefs: []
  type: TYPE_NORMAL
- en: If the review is to be conducted by a specific person, there might be some shared
    understanding or context, which could reduce the need for extensive comments in
    the review. The basic technique is the same as for an issue, but it is important
    to tailor your approach to your target audience.
  prefs: []
  type: TYPE_NORMAL
- en: 'You might notice that there are two options available when creating a pull
    request, which can be accessed via the drop-down button on the right. You can
    either create a standard pull request or opt for a draft pull request. Draft pull
    requests may not be applicable to private repositories depending on your plan,
    but anyone can try it for public repositories. I encourage you to check it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.44 – There is another option: Create a draft pull request](img/B21203_04_044.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.44 – There is another option: Create a draft pull request'
  prefs: []
  type: TYPE_NORMAL
- en: Both draft and regular pull requests do not differ much in terms of the user
    interface. However, a draft pull request is used to indicate that the pull request
    is not yet finalized or that the overall work is still in progress, incomplete,
    or in a specific stage of development.
  prefs: []
  type: TYPE_NORMAL
- en: It allows for intermediate reviews, signifying that it is not intended for formal
    review yet. Reviewers usually appreciate receiving interim results or reports.
    Early reviews can provide valuable insights and share progress with the team,
    which is beneficial.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of a draft pull request, the merge cannot be done immediately by
    mistake, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.45 – Draft pull request explicitly indicates it is not ready for
    review](img/B21203_04_045.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.45 – Draft pull request explicitly indicates it is not ready for review
  prefs: []
  type: TYPE_NORMAL
- en: In an extreme scenario, you can create a pull request even without writing a
    single line of code with the `git empty commit` command. This can be incredibly
    useful from the early stages of development, allowing team members or a pair-programming
    partner to review the code, helping to identify mistakes early. Therefore, it
    is highly recommended to make use of draft pull requests as well.
  prefs: []
  type: TYPE_NORMAL
- en: An empty commit in Git is a commit that does not contain any changes; it is
    like sending a message without altering any files. This can be particularly useful
    for initiating discussions in the early stages of development without the need
    for actual code changes. To create an empty commit, you can use the `git commit
    --allow-empty -m "Your message"` command, which enables you to make a commit with
    a message but no content changes. This feature is handy for creating pull requests
    that serve as placeholders for future code reviews or to mark specific milestones
    in the development process. It is recommended to keep this empty commit in mind
    along with the draft pull request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, once you have conducted appropriate communication and completed the review,
    it is time to merge. The great thing about GitHub here is not the command interface,
    but the ability to perform merges on the user interface. You can go ahead and
    merge as it is, but let’s look at the options before doing so:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.46 – Merge can be done with the web user interface](img/B21203_04_046.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.46 – Merge can be done with the web user interface
  prefs: []
  type: TYPE_NORMAL
- en: Upon inspecting the **Merge** dropdown, you will find three options. These are
    creating a merge commit, then squashing to combine commits into one and merge,
    and finally, performing a rebase merge. While these merging techniques were covered
    in a previous chapter and will not be elaborated on here, the beauty of GitHub
    lies in the flexibility it offers to choose each of these options for managing
    your Git history. If you want to preserve the history of contributions, you will
    first incorporate the commits, ensuring as much of the change history remains
    as possible. On the other hand, if you prefer a cleaner history, options such
    as **Squash and merge** and **Rebase and merge** are also available to consider.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note, however, that GitHub’s `git rebase` command. **Rebase
    and merge** on GitHub effectively reapplies each commit from the feature branch
    onto the base branch individually, without creating a merge commit. This allows
    for a linear history while preserving the chronological order of commits. Whether
    you aim to maintain a detailed record of contributions or prefer a streamlined
    history, GitHub provides the tools to accommodate your project’s needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.47 – Merge options](img/B21203_04_047.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.47 – Merge options
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, we chose to create a merge commit. Creating a merge commit is easy;
    simply write a title and a description. Then, click on the **Confirm merge** button
    to merge:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.48 – Creating a merge commit](img/B21203_04_048.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.48 – Creating a merge commit
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, you will confirm that the merge was successfully done on the GitHub platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.49 – Checking if the merge was successful](img/B21203_04_049.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.49 – Checking if the merge was successful
  prefs: []
  type: TYPE_NORMAL
- en: You have observed the simplicity of managing pull requests on GitHub. This platform
    demonstrates how intricate actions and reviews, traditionally executed via the
    command line, can be efficiently conducted within a unified platform enhanced
    by a streamlined user interface.
  prefs: []
  type: TYPE_NORMAL
- en: Moving forward, we will delve deeper into the nuances of proficient pull request
    management. Our focus will be on how you can adeptly leverage these features within
    a DevOps-centric communication framework to drive the success of your projects
    or products. Additionally, we will discuss key aspects that call for your attention
    and consideration.
  prefs: []
  type: TYPE_NORMAL
- en: Pull request review 101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First and foremost, it is essential to grasp how to conduct reviews on GitHub
    and then explore best practices that merit attention. When you begin learning
    GitHub, you might not immediately engage in full-fledged code reviews. However,
    understanding how reviews should be conducted can influence your expectations
    and the content you include when writing a pull request.
  prefs: []
  type: TYPE_NORMAL
- en: Remember—these are practices that can be gradually improved and, ultimately,
    should be optimized for your team.
  prefs: []
  type: TYPE_NORMAL
- en: Review basics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Accessing the review interface on GitHub is straightforward. From the pull
    request page, open the **Files changed** tab to see how many files have been modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.50 – Tab for reviewing pull requests](img/B21203_04_050.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.50 – Tab for reviewing pull requests
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have opened the `-` indicate deletions, while those with `+` are additions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.51 – Viewing line-by-line differences on GitHub](img/B21203_04_051.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.51 – Viewing line-by-line differences on GitHub
  prefs: []
  type: TYPE_NORMAL
- en: 'To comment on specific line changes, use the **+** button on the left. This
    also allows for selecting multiple lines, facilitating efficient discussion initiation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.52 – Reviewing changes](img/B21203_04_052.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.52 – Reviewing changes
  prefs: []
  type: TYPE_NORMAL
- en: 'When reviewing, you may want to propose specific changes. This can be done
    by pressing the **Suggestion** button on the screen, which copies the content
    of the relevant line. Edit this content in your comment, but be aware that while
    comments can be added to deleted lines, suggestions cannot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.53 – Proposing changes using the Suggestion button](img/B21203_04_053.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.53 – Proposing changes using the Suggestion button
  prefs: []
  type: TYPE_NORMAL
- en: 'If you find a suggestion to be good, press the **Add single comment** button
    to comment. For multiple review comments, use the **Start a review** button, which
    is handy when there are many edits. Review comments, including suggestions, appear
    both in the pull request thread and interspersed between code differences, making
    code reviews more straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.54 – Suggestion appears as a comment](img/B21203_04_054.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.54 – Suggestion appears as a comment
  prefs: []
  type: TYPE_NORMAL
- en: 'After completing the review, you will see **Commit suggestion** and **Add suggestion
    to batch** buttons. GitHub’s brilliance lies in allowing these changes to be committed
    directly through the user interface, rather than needing to do so via the command-line
    interface or an editor. **Commit suggestion** commits an individual change, while
    **Add suggestion to batch** enables recording multiple changes as a single commit.
    This prevents unnecessary commits when your pull requests receive many changes.
    Pressing the **Commit suggestion** button brings up a screen for entering a commit
    message and description, after which the change is committed to the pull request
    branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.55 – Committing changes](img/B21203_04_055.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.55 – Committing changes
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the review is complete, it is time for you to conduct a review. Note that
    approving a review does not automatically merge the pull request, but it does
    mark it as approved by you. Here, you can choose between **Commit**, **Approve**,
    and **Request changes**. The **Comment** option is for just only making a comment,
    **Approve** indicates approval, and **Request changes** is used to suggest necessary
    amendments:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.56 – Three options for the review](img/B21203_04_056.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.56 – Three options for the review
  prefs: []
  type: TYPE_NORMAL
- en: 'If you approve, your comment and approval status are posted in the thread like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.57 – Post-review status](img/B21203_04_057.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.57 – Post-review status
  prefs: []
  type: TYPE_NORMAL
- en: Thus, GitHub simplifies the review process and enables many functionalities
    through its GUI. The blend of code changes and related comments enriches the context,
    allowing reviewers, reviewees, and current or future team members seeking historical
    context to understand and interact with the information effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering this feature can lead to highly transparent communication within your
    team.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at what to consider when reviewing or being reviewed
  prefs: []
  type: TYPE_NORMAL
- en: Review best practices
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the dynamic landscape of software development, GitHub reviews stand as a
    pivotal component in bridging individual effort and collective excellence. These
    reviews extend beyond mere code examination to fostering a collaborative and learning-rich
    environment. Mastering GitHub reviews is crucial for teams aiming for high-quality
    development processes. Here are some guidelines on how to achieve that:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cultivating the reviewer’s mindset**: The effectiveness of GitHub reviews
    starts with the reviewer’s mindset. Emphasizing prompt feedback is key, as it
    maintains the momentum of development. However, speed should be balanced with
    thoroughness, recognizing that the code is a collective asset of the team. This
    mindset fosters a constructive and ego-free approach to reviews, seeing them not
    just as a task but as an opportunity for meaningful dialogue and documentation
    for current and future team members.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enhancing communication in reviews**: Effective communication is central
    to GitHub reviews. Utilizing Markdown for clarity and structured feedback ensures
    that reviews are accessible and understandable. Being specific and concise in
    comments avoids confusion and expedites the review process. Positive reinforcement
    and constructive feedback, often supplemented with emojis, create a welcoming
    and psychologically safe review environment, encouraging prompt and enthusiastic
    adoption of changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Promoting diversity and authorship in reviews**: Diversity in the review
    process introduces varied perspectives, enriching the review and safeguarding
    against blind spots. Encouraging developers to revise their code based on feedback
    fosters empowerment and skill development. Additionally, preserving authorship,
    even in practices such as squash merging, is crucial for maintaining individual
    motivation and accountability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintaining standards in urgent scenarios**: Even in urgent scenarios, such
    as hotfixes, the quality and thoroughness of reviews should not be compromised.
    Upholding standards under pressure is essential, as each review contributes to
    the team’s overall work ethic and code quality.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integrating automation for efficiency**: Incorporating automation into the
    review process, through automated tests, syntax checks, and linter rules, streamlines
    the review process. This allows human reviewers to focus on more complex aspects
    of the code. Employing templates for reviews also ensures consistency and thoroughness,
    maintaining a high quality of review across the board.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In conclusion, reviews on GitHub are more than just a mechanism for code QA;
    they are a vital part of fostering team growth, learning, and collaboration. By
    adopting these best practices, teams elevate not just their code but also their
    working environment, promoting mutual respect, continuous improvement, and a collaborative
    spirit. A well-executed review is indeed a step toward a more cohesive, efficient,
    and resilient development process.
  prefs: []
  type: TYPE_NORMAL
- en: We have now gone through an overview of pull requests, basic usage, and best
    practices. So far, it seems like you have a pretty good grasp of how to collaborate
    on GitHub. From here, we will look at other features of GitHub to help you collaborate
    better.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the best out of GitHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring additional features in GitHub can greatly enhance your repository
    management experience. While a detailed exploration of each feature would be extensive,
    a brief introduction to each can highlight their significance.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Projects – Managing your issues and pull requests in one place
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GitHub Projects is a tool that allows you to manage issues, issue drafts, and
    pull requests in one place.
  prefs: []
  type: TYPE_NORMAL
- en: 'GitHub Projects will allow for more flexible management than just GitHub issues
    and pull requests. It represents a significant evolution in how development teams
    can organize, track, and manage their work on GitHub. Unlike the linear and somewhat
    limited scope of issues and pull requests, GitHub Projects offers a multifaceted
    approach to project management, aligning seamlessly with the collaborative and
    iterative nature of modern software development:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.58 – GitHub Projects table view](img/B21203_04_058.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.58 – GitHub Projects table view
  prefs: []
  type: TYPE_NORMAL
- en: 'At the heart of GitHub Projects lies the Kanban board, a highly visual tool
    that enhances workflow visualization. This board allows teams to create custom
    columns that mirror their workflow stages—from **To Do** to **In Progress** and
    **Done**. The simplicity of dragging and dropping issues and pull requests across
    these columns significantly improves workflow transparency and helps in tracking
    the progress of tasks more intuitively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.59 – GitHub Projects Kanban board view](img/B21203_04_059.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.59 – GitHub Projects Kanban board view
  prefs: []
  type: TYPE_NORMAL
- en: Collaboration is further enhanced through tools such as assignees and milestones.
    Assignees ensure that responsibilities are clearly defined, while milestones help
    in tracking progress toward key objectives or deadlines. This structured approach
    to collaboration ensures that every team member is aligned with the project goals
    and understands their role in achieving them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Integrated project reporting is another facet that sets GitHub Projects apart.
    It provides a comprehensive overview of the project’s progress. DevOps metrics
    are invaluable for assessing team performance and identifying areas for improvement.
    This data-driven approach to project management enables teams to make informed
    decisions and optimize their workflows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.60 – GitHub Projects status chart](img/B21203_04_060.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.60 – GitHub Projects status chart
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Projects also offers a range of project templates—from predefined ones
    for common project types such as bug tracker or Kanban to the ability to create
    custom templates tailored to specific team workflows. These templates save time
    and provide a consistent structure that teams can rely on.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, the inclusion of issue and pull request filters within the project
    board enhances the ability to manage tasks efficiently. Teams can filter by labels,
    assignees, milestones, and more, allowing them to quickly find and focus on tasks
    that matter most.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most significant advantages of GitHub Projects is its ability to
    manage issues and pull requests from multiple repositories in a single project.
    This feature is particularly beneficial for larger projects that span multiple
    repositories, providing a holistic view and cohesive management experience.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Projects goes beyond the traditional confines of issue tracking and pull
    request management, offering a comprehensive, flexible, and highly collaborative
    platform for project management. By using its features, development teams can
    enhance their productivity, improve collaboration, and drive their projects toward
    successful outcomes, all within the familiar ecosystem of GitHub. This alignment
    with the principles of DevOps culture—prioritizing collaboration, efficiency,
    and transparency—makes GitHub Projects a great tool in the modern software development
    landscape.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Codespaces – Transforming development workflows with cloud-based environments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: GitHub Codespaces revolutionizes the way developers work by offering fully configurable,
    cloud-based development environments directly within GitHub. It marks a significant
    step in the evolution of development workflows, making it easier for teams to
    collaborate and streamline their DevOps practices.
  prefs: []
  type: TYPE_NORMAL
- en: 'GitHub Codespaces streamlines development with critical features:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Quick Start and Uniform Workspaces**: Enables instant setup of cloud-based
    environments, aligning team efforts and reducing setup complexity'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collaboration and Pull Request Integration**: Facilitates easier code reviews
    and discussions within the Codespaces environment, enhancing teamwork across locations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secure and Isolated Environments**: Offers secure, containerized workspaces
    for each user, protecting project integrity and data security'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As an implementation of Visual Studio Code available in the browser, GitHub
    Codespaces offers the features and extensions available in VS Code. Although there
    are limitations to the extensions available in the Codespaces version, this familiarity
    is a tremendous advantage. It allows developers to leverage a powerful and popular
    development tool with the added benefits of cloud accessibility and integration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.61 – GitHub Codespaces](img/B21203_04_061.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.61 – GitHub Codespaces
  prefs: []
  type: TYPE_NORMAL
- en: Starting a new codespace is straightforward. With just a few clicks, developers
    can spin up a development environment that is automatically configured with the
    settings and tools specified in the repository’s `.devcontainer` configuration.
    This ensures consistency across development environments, a fundamental aspect
    of DevOps practices that emphasizes reproducibility and reduces “*works on my*
    *machine*” issues.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most significant benefits of GitHub Codespaces is the elimination
    of the need to clone heavy files and set up complex development environments locally.
    This not only saves significant new engineers’ onboarding time but also simplifies
    the process of switching between different projects, each with its unique environment
    requirements. By hosting the development environment in the cloud, Codespaces
    significantly reduces the overhead of managing local development setups.
  prefs: []
  type: TYPE_NORMAL
- en: 'Performance and customization are key aspects of GitHub Codespaces. Developers
    can choose hardware specifications for their codespaces, ensuring they have the
    necessary resources for their tasks. Customization extends to the development
    environment itself, with support for Visual Studio Code extensions and personalized
    editor settings, reinforcing the DevOps focus on developer experience. From an
    administrative perspective, GitHub Codespaces allows organization leaders to set
    specific policies regarding the development environment, including constraints
    on the types of machines users can select for their codespaces. This capability
    ensures that development environments align with organizational standards and
    resource management strategies, offering a balanced approach to cost and performance
    within the company’s guidelines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.62 – Restricting access to machine types](img/B21203_04_062.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.62 – Restricting access to machine types
  prefs: []
  type: TYPE_NORMAL
- en: Also, it offers a remarkable blend of collaboration and security, striking a
    perfect balance for modern development teams. Integrating pull requests directly
    into the Codespaces environment significantly enhances the collaborative process,
    making it easier for teams to propose, discuss, and merge changes efficiently,
    regardless of their physical locations. This streamlined workflow for code reviews
    and collaboration is coupled with a powerful security advantage. Codespaces reduce
    the risks associated with employees downloading whole source code data locally,
    addressing common security concerns that arise from local file storage and management.
    Each user’s workspace is securely isolated, further mitigating potential security
    issues tied to local development practices. This thoughtful integration of collaboration
    and security within Codespaces not only boosts productivity but also strengthens
    the safeguarding of project data, offering a secure, collaborative development
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Codespaces is more than just a development environment; it is a catalyst
    for enhancing DevOps practices. By offering a flexible, collaborative, and integrated
    platform, it empowers teams to innovate faster, collaborate more effectively,
    and deliver higher-quality software, all within the GitHub ecosystem. This makes
    GitHub Codespaces an indispensable tool in the modern software development and
    DevOps landscape.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Discussions – Fostering community and collaboration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'GitHub Discussions serves as a vital platform for building and nurturing community
    within GitHub repositories. It represents a significant advancement in how developers,
    contributors, and users interact and collaborate. This feature extends beyond
    the traditional issue and pull request communication, offering a dedicated space
    for questions, ideas, and discussions. GitHub Discussions creates an environment
    where the broader community—including those who may not be directly involved in
    code contributions—can engage, share insights, and provide feedback:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.63 – GitHub Discussions thread](img/B21203_04_063.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.63 – GitHub Discussions thread
  prefs: []
  type: TYPE_NORMAL
- en: 'A key aspect of GitHub Discussions is its ability to organize communication
    effectively. Discussions can be categorized into different types, such as Q&As,
    announcements, or general discussions. This categorization helps to maintain clarity
    and focus, making it easier for users to find relevant conversations and contribute
    meaningfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.64 – GitHub Discussions categories](img/B21203_04_064.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.64 – GitHub Discussions categories
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Discussions also plays a crucial role in knowledge sharing and preservation.
    Unlike transient communication channels such as chat rooms, discussions are persistent
    and searchable, making them a valuable resource for current and future community
    members. This archival quality ensures that knowledge shared in discussions continues
    to benefit the community long after conversations have taken place.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, GitHub Discussions is not only a powerful tool for fostering community
    engagement and collaboration but also plays a crucial role in maintaining the
    organization and clarity of GitHub issues. As projects grow and evolve, the volume
    and diversity of issues can become overwhelming, leading to clutter and confusion.
    GitHub Discussions acts as a catalyst for communication, enabling teams to channel
    various topics and conversations into a more structured and appropriate space.
  prefs: []
  type: TYPE_NORMAL
- en: This capability of GitHub Discussions to segregate broad, general discussions
    from more specific, technical conversations typically housed in GitHub Issues
    is invaluable. It helps in keeping the **Issues** section focused and manageable,
    reducing noise and making it easier for teams to track and address specific code-related
    tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, by providing a dedicated platform for wide-ranging discussions, GitHub
    Discussions smooths the path for collaboration in numerous ways. It not only ensures
    that valuable insights and ideas are shared and preserved but also prevents the
    dilution of technical discussions in the **Issues** section. This distinction
    between general discussions and specific issues is essential for maintaining an
    efficient workflow and aligning with DevOps practices, which emphasize streamlined
    processes and clear communication.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, GitHub Discussions is more than a mere addition to the GitHub ecosystem;
    it is an integral component that enhances the overall functionality and effectiveness
    of project management on the platform. It aids in keeping GitHub issues clean
    and focused while offering a robust environment for broader, community-driven
    conversations, thereby smoothing collaboration and driving projects toward success.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub repository excellence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many configurations in GitHub repositories that can promote collaboration.
    These settings can reduce the need to fear failure and make the review process
    more standardized. We will not cover all of them here, but some of the major ones
    are particularly important.
  prefs: []
  type: TYPE_NORMAL
- en: Repository rules – Streamlining workflow and ensuring code quality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Branch rules are important for managing a repository in a way that strikes a
    balance between security and collaboration. While GitHub allows setting permissions
    for the repository or specific functions, it does not offer code-based permissions.
    Relying solely on write permissions can restrict participation and hinder open
    communication. Branch rules allow repository administrators to enforce specific
    policies on branches, particularly critical ones such as the main or master branches.
    These policies include requirements for pull request reviews, status checks, and
    restrictions on who can push to the branch. By setting up these rules, teams can
    ensure that the code merged into important branches meets predetermined quality
    standards and that the process aligns with the team’s workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ruleset allows for a variety of settings. They can be applied only to specific
    branches, or administrators can be authorized to bypass them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.65 – Setting up branch rules in GitHub](img/B21203_04_065.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.65 – Setting up branch rules in GitHub
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the primary benefits of branch rules is the enforcement of code review.
    By requiring that pull requests receive a certain number of approvals before merging,
    teams can ensure that every change is scrutinized and validated. This peer review
    process not only improves code quality but also fosters knowledge sharing and
    collaboration among team members:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.66 – Code review requirements in branch rules](img/B21203_04_066.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.66 – Code review requirements in branch rules
  prefs: []
  type: TYPE_NORMAL
- en: 'Status checks are another critical part of branch rules. These checks can include
    automated tests, code linter results, or any other type of automated process that
    verifies the quality and functionality of the code. By requiring these checks
    to pass before merging, teams can prevent bugs and issues from making their way
    into the main code base, thus maintaining high standards of code quality:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.67 – Status checks in branch rules](img/B21203_04_067.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.67 – Status checks in branch rules
  prefs: []
  type: TYPE_NORMAL
- en: Branch rules are a fundamental configuration in GitHub for safeguarding code
    quality and enforcing workflow discipline. They enable teams to automate and enforce
    critical aspects of their development process, aligning with the principles of
    DevOps. By utilizing branch rules, teams can ensure that their code base remains
    stable, secure, and consistent, thereby supporting the delivery of high-quality
    software in a collaborative environment. This makes branch rules an essential
    element in modern software development and an invaluable asset in the DevOps toolkit.
  prefs: []
  type: TYPE_NORMAL
- en: CODEOWNERS – Streamlined review and ownership
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `CODEOWNERS` file in GitHub is a simple yet powerful tool for automatically
    assigning reviewers to pull requests and clarifying ownership of specific code
    areas. This file, placed in the root, `docs/`, or `.github/` directory of the
    repository, lists individuals or teams alongside file patterns. When changes are
    made to files matching these patterns, the specified code owners are requested
    for review:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.68 – Example of a CODEOWNERS file](img/B21203_04_068.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.68 – Example of a CODEOWNERS file
  prefs: []
  type: TYPE_NORMAL
- en: 'The benefits of using a `CODEOWNERS` file include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automated reviewer assignment**: Streamlines the pull request process by
    automatically assigning the right reviewers, ensuring that changes are checked
    by the appropriate experts'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clear ownership**: Clarifies who is responsible for specific parts of the
    code base, aiding in quicker decision-making and more efficient maintenance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This aspect of `CODEOWNERS` is particularly important as it directly relates
    to deployment safety. In environments where CI/CD is the norm, ensuring that only
    well-reviewed and approved code is deployed is critical. This adds a layer of
    security and efficiency to the deployment process, embodying the preventive and
    proactive principles central to effective DevOps practices.
  prefs: []
  type: TYPE_NORMAL
- en: Issue and pull request templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Templates in GitHub enhance collaboration and maintain consistency across various
    aspects of project management:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.69 – Issue template menu](img/B21203_04_069.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.69 – Issue template menu
  prefs: []
  type: TYPE_NORMAL
- en: 'Issue templates guide contributors in creating detailed and structured issue
    reports. By providing specific templates for different types of issues (bug reports,
    feature requests, and so on), you ensure that all necessary information is included,
    facilitating easier understanding and quicker resolution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.70 – Example of an issue template](img/B21203_04_070.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.70 – Example of an issue template
  prefs: []
  type: TYPE_NORMAL
- en: Pull request templates ensure that every pull request adheres to the project’s
    standards and requirements. These templates typically include checklists, sections
    for describing changes, referencing relevant issues, and any additional notes.
    This standardization simplifies the review process and enhances the quality of
    contributions.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these components plays a vital role in shaping a well-organized, accessible,
    and contributor-friendly GitHub repository. By implementing these standard base
    documentations and templates, you lay down a strong foundation for collaboration
    and project management, resonating with the best practices in DevOps and open
    source culture.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have gained valuable insights into fundamental aspects
    of collaborating on GitHub, setting a strong foundation for DevOps practices.
    While we have explored various topics around Git, GitHub, and DevOps, this chapter
    has specifically focused on how to effectively use GitHub for collaboration, a
    crucial skill in the world of DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: This knowledge is not just theoretical but highly practical, setting the stage
    for the next phase of our journey—applying these Git techniques and GitHub skills
    in the actual DevOps release process. As we transition to the next chapter, we
    will build upon this foundation, diving deeper into how these skills and practices
    are directly applied and leveraged in DevOps workflows, ultimately enhancing the
    efficiency and effectiveness of the software development and deployment process.
  prefs: []
  type: TYPE_NORMAL
- en: Ready to embark on this next phase? Let’s move forward to the next chapter,
    where we will see these principles in action, witnessing the transformative impact
    of Git and GitHub in the realm of DevOps.
  prefs: []
  type: TYPE_NORMAL
