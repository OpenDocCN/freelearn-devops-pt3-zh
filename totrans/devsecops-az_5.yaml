- en: <st c="0">5</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">5</st>
- en: <st c="2">Implementing Source Control Security</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2">实施源代码控制安全</st>
- en: '<st c="38">In the previous chapter, we divided the DevOps code development
    process into two key phases: the pre-commit phase and the source control management
    phase.</st> <st c="194">This division was made to simplify our discussion of security
    integration.</st> <st c="269">We’ve already discussed the security practices in
    the pre-commit phase.</st> <st c="341">Next, we will shift our focus to the security
    aspects within</st> <st c="402">source control.</st>'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38">在前一章中，我们将 DevOps 代码开发过程分为两个关键阶段：提交前阶段和源代码管理阶段。</st> <st c="194">这种划分是为了简化我们关于安全集成的讨论。</st>
    <st c="269">我们已经讨论了提交前阶段的安全实践。</st> <st c="341">接下来，我们将把焦点转向</st> <st c="402">源代码控制中的安全方面。</st>
- en: <st c="417">Source</st> <st c="425">control in DevOps is a way to organize and
    track the code for a project using a</st> **<st c="505">source control management</st>**
    <st c="530">(</st>**<st c="532">SCM</st>**<st c="535">) system such as</st> <st
    c="553">Git or</st> **<st c="560">Team Foundation Version Control</st>** <st c="591">(</st>**<st
    c="593">TFVC</st>**<st c="597">).</st> <st c="601">When implementing DevSecOps
    in source control, it is important to consider how the code repository is managed
    and secured.</st> <st c="724">If access to the code repository is compromised
    or protections can be easily bypassed, it is hard to trust the code stored in
    it.</st> <st c="854">By the end of this chapter, you will have gained a solid
    understanding of the following</st> <st c="942">key areas:</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="417">源代码控制在 DevOps 中是通过</st> **<st c="505">源代码管理</st>** <st c="530">(</st>**<st
    c="532">SCM</st>**<st c="535">) 系统（如</st> <st c="553">Git 或</st> **<st c="560">团队基础版本控制</st>**
    <st c="591">(</st>**<st c="593">TFVC</st>**<st c="597">））来组织和跟踪项目代码的方式。</st> <st
    c="601">在源代码控制中实施 DevSecOps 时，重要的是要考虑如何管理和保护代码仓库。</st> <st c="724">如果代码仓库的访问被破坏，或保护措施容易被绕过，那么很难信任其中存储的代码。</st>
    <st c="854">本章结束时，你将对以下关键领域有一个深入的了解：</st> <st c="942">关键领域：</st>
- en: <st c="952">Understanding the post-commit phase</st> <st c="989">of DevOps</st>
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="952">理解 DevOps 的提交后阶段</st> <st c="989">的内容</st>
- en: <st c="998">Securing the source</st> <st c="1019">code environment</st>
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="998">保障源代码</st> <st c="1019">环境的安全</st>
- en: <st c="1035">Addressing common coding security issues in</st> <st c="1080">source
    control</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1035">解决源代码控制中的常见编码安全问题</st> <st c="1080">源代码控制</st>
- en: <st c="1094">These topics will equip you with the necessary knowledge and skills
    to integrate security practices into the source control phase of a DevOps workflow.</st>
    <st c="1247">Let’s</st> <st c="1253">dive in!</st>
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1094">这些主题将为你提供必要的知识和技能，以将安全实践集成到 DevOps 工作流的源代码控制阶段。</st> <st c="1247">让我们</st>
    <st c="1253">深入了解吧！</st>
- en: <st c="1261">Technical requirements</st>
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1261">技术要求</st>
- en: <st c="1284">To follow along with the instructions in this chapter, you will
    need</st> <st c="1354">the following:</st>
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1284">要跟随本章的指示，你将需要</st> <st c="1354">以下资源：</st>
- en: <st c="1368">A PC with</st> <st c="1379">internet connection</st>
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1368">一台带有</st> <st c="1379">互联网连接的 PC</st>
- en: <st c="1398">An active</st> <st c="1409">Azure subscription</st>
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1398">一个活跃的</st> <st c="1409">Azure 订阅</st>
- en: <st c="1427">An Azure</st> <st c="1437">DevOps organization</st>
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1427">一个 Azure</st> <st c="1437">DevOps 组织</st>
- en: <st c="1456">A GitHub</st> <st c="1466">Enterprise organization</st>
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="1456">一个 GitHub</st> <st c="1466">企业组织</st>
- en: <st c="1489">Understanding the post-commit phase of DevOps</st>
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1489">理解 DevOps 的提交后阶段</st>
- en: <st c="1535">After committing code changes locally, the developer’s next step
    is to synchronize these changes with</st> <st c="1638">the central remote repository,
    as indicated in</st> *<st c="1685">Figure 5</st>**<st c="1693">.1</st>* <st c="1695">(</st>`<st
    c="1730">git push</st>` <st c="1738">operation.</st> <st c="1750">The central
    repository serves as the collective storage for code contributed by all developers
    working on</st> <st c="1856">a project:</st>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1535">在本地提交代码更改后，开发者的下一步是将这些更改同步到</st> <st c="1638">中央远程代码库，如</st> *<st
    c="1685">图 5</st>**<st c="1693">.1</st>* <st c="1695">(</st>`<st c="1730">git
    push</st>` <st c="1738">操作。</st> <st c="1750">中央代码库作为所有参与项目的开发者共同存储代码的地方：</st>
- en: '![Figure 5.1 – The code development phase of DevOps](img/B19710_05_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – DevOps 的代码开发阶段](img/B19710_05_01.jpg)'
- en: <st c="2059">Figure 5.1 – The code development phase of DevOps</st>
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2059">图 5.1 – DevOps 的代码开发阶段</st>
- en: '<st c="2108">The central repository can be hosted on a source control platform
    that is either self-hosted or cloud-hosted.</st> <st c="2219">According to the
    2022 Stack Overflow Developer Survey, GitHub leads as the most favored source
    control platform for both personal and professional projects.</st> <st c="2376">Other
    platforms such as GitLab, Bitbucket, and Azure Repos are more common in professional
    environments (</st>*<st c="2481">Figure 5</st>**<st c="2490">.2</st>*<st c="2492">).</st>
    <st c="2496">In</st> [*<st c="2499">Chapter 1</st>*](B19710_01.xhtml#_idTextAnchor016)<st
    c="2508">, we provided an overview of Microsoft’s two DevOps platforms: GitHub
    and Azure DevOps.</st> <st c="2596">Both platforms offer source control</st> <st
    c="2632">management services.</st> <st c="2653">In GitHub, we have</st> **<st
    c="2672">GitHub repositories</st>**<st c="2691">, and in Azure DevOps, we</st>
    <st c="2717">have</st> **<st c="2722">Azure Repos</st>**<st c="2733">. Both GitHub
    repositories and Azure Repos have self-hosted and cloud-hosted options.</st> <st
    c="2819">Self-hosted versions offer more control but require more management,
    and the cloud-hosted</st> <st c="2909">versions have less management overhead
    but may offer less control in</st> <st c="2978">certain scenarios:</st>'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2108">中央仓库可以托管在自托管或云托管的源代码管理平台上。</st> <st c="2219">根据2022年Stack Overflow开发者调查，GitHub在个人和专业项目中都是最受欢迎的源代码管理平台。</st>
    <st c="2376">其他平台，如GitLab、Bitbucket和Azure Repos，在专业环境中更为常见（</st>*<st c="2481">图5</st>**<st
    c="2490">.2</st>*<st c="2492">）。</st> <st c="2496">在</st> [*<st c="2499">第1章</st>*](B19710_01.xhtml#_idTextAnchor016)<st
    c="2508">中，我们提供了微软两个DevOps平台的概述：GitHub和Azure DevOps。</st> <st c="2596">这两个平台都提供源代码管理</st>
    <st c="2632">服务。</st> <st c="2653">在GitHub中，我们有</st> **<st c="2672">GitHub仓库</st>**<st
    c="2691">，而在Azure DevOps中，我们</st> <st c="2717">有</st> **<st c="2722">Azure Repos</st>**<st
    c="2733">。GitHub仓库和Azure Repos都提供自托管和云托管选项。</st> <st c="2819">自托管版本提供更多控制权，但需要更多管理，而云托管版本管理开销较小，但在</st>
    <st c="2909">某些情况下可能会提供较少的控制。</st> <st c="2978">这些场景包括：</st>
- en: '![Figure 5.2 – Stack Overflow’s source control platform survey (2022)](img/B19710_05_02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2 – Stack Overflow的源代码管理平台调查（2022）](img/B19710_05_02.jpg)'
- en: <st c="3183">Figure 5.2 – Stack Overflow’s source control platform survey (2022)</st>
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3183">图5.2 – Stack Overflow的源代码管理平台调查（2022）</st>
- en: <st c="3250">Note</st>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3250">注意</st>
- en: <st c="3255">You might</st> <st c="3266">encounter the terms</st> *<st c="3286">version
    control</st>* <st c="3301">and</st> *<st c="3306">source control</st>* <st c="3320">in
    various</st> <st c="3332">documentation and articles.</st> <st c="3360">Both terms
    refer to the same thing and can be used interchangeably.</st> <st c="3428">Throughout
    this book, we will use the term</st> *<st c="3471">source control</st>* <st c="3485">for
    consistency.</st>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3255">你可能会</st> <st c="3266">遇到</st> *<st c="3286">版本控制</st>* <st c="3301">和</st>
    *<st c="3306">源代码管理</st>* <st c="3320">这两个术语在各种</st> <st c="3332">文档和文章中。</st>
    <st c="3360">这两个术语指的是同一件事，可以互换使用。</st> <st c="3428">在本书中，我们将使用术语</st> *<st c="3471">源代码管理</st>*
    <st c="3485">以保持一致性。</st>
- en: <st c="3502">Understanding the security measures in the source control management
    phase</st>
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="3502">了解源代码管理阶段的安全措施</st>
- en: <st c="3577">Given its</st> <st c="3588">critical role as the</st> *<st c="3609">source
    of truth</st>* <st c="3624">for code that will be deployed to production, it is
    essential to ensure that code is protected and tested for security in source control.</st>
    <st c="3763">In this phase, there are two primary categories of security measures
    that we will</st> <st c="3845">focus on:</st>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3577">鉴于其</st> <st c="3588">作为将要部署到生产环境的代码的</st> *<st c="3609">真相来源</st>*
    <st c="3624">的关键作用，确保代码在源代码管理中得到保护并经过安全性测试是至关重要的。</st> <st c="3763">在这个阶段，我们将关注两类主要的安全措施：</st>
- en: '**<st c="3854">Securing the SCM environment</st>**<st c="3883">: This category
    emphasizes safeguarding the environment where the code is stored.</st> <st c="3966">It
    involves ensuring the integrity and security of the source control itself, protecting
    it against unauthorized access, data breaches, and other potential security threats
    to the</st> <st c="4146">SCM system.</st>'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="3854">保护SCM环境的安全</st>**<st c="3883">：这一类措施强调保护存储代码的环境。</st> <st c="3966">它涉及确保源代码管理本身的完整性和安全，防止未经授权的访问、数据泄露以及其他潜在的安全威胁。</st>
    <st c="4146">SCM系统的安全。</st>'
- en: '**<st c="4157">Addressing common coding security issues</st>**<st c="4198">:
    This mirrors the objectives discussed in the previous chapter but is applied in
    the context of source control.</st> <st c="4312">It focuses on identifying and
    rectifying common security vulnerabilities in code both before and after it is
    merged into the main code base.</st> <st c="4453">This includes frequently reviewing
    code for security flaws (both third-party and first-party), implementing automated
    security scans, and ensuring best coding practices are followed to</st> <st c="4638">minimize
    risks.</st>'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="4157">解决常见的编码安全问题</st>**<st c="4198">：这与前一章讨论的目标类似，但应用于源代码控制的背景。</st>
    <st c="4312">它重点识别并纠正代码中常见的安全漏洞，无论是在代码合并到主代码库之前还是之后。</st> <st c="4453">这包括定期审查代码中的安全缺陷（无论是第三方还是第一方的），实施自动化安全扫描，并确保遵循最佳编码实践以</st>
    <st c="4638">最小化风险。</st>'
- en: <st c="4653">The following figure shows the two categories we</st> <st c="4703">have
    discussed:</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4653">下图展示了我们已经讨论过的两个类别：</st>
- en: '![Figure 5.3 – The two primary categories of security measures in the source
    control phase of DevOps](img/B19710_05_03.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![图5.3 – DevOps源代码控制阶段的两大安全措施类别](img/B19710_05_03.jpg)'
- en: <st c="4795">Figure 5.3 – The two primary categories of security measures in
    the source control phase of DevOps</st>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4795">图5.3 – DevOps源代码控制阶段的两大安全措施类别</st>
- en: <st c="4893">Let’s start</st> <st c="4906">by addressing the first category
    – securing the source code</st> <st c="4966">management environment.</st>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4893">让我们从</st> <st c="4906">解决第一类问题——保护源代码管理环境</st> <st c="4966">开始。</st>
- en: <st c="4989">Securing the source code management environment</st>
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="4989">保护源代码管理环境</st>
- en: <st c="5037">In a DevOps workflow, securing the source code management platform
    is essential for maintaining</st> <st c="5134">the integrity of software releases.</st>
    <st c="5170">To achieve this, we strongly recommend adhering to the guidelines
    outlined in the</st> *<st c="5252">Source Code</st>* <st c="5263">section</st>
    <st c="5272">of the</st> *<st c="5279">Center for Internet Security (CIS) Software
    Supply Chain</st>* *<st c="5336">Security Guide</st>*<st c="5350">.</st>
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5037">在DevOps工作流中，保护源代码管理平台对于维护</st> <st c="5134">软件发布的完整性至关重要。</st>
    <st c="5170">为了实现这一点，我们强烈建议遵循</st> *<st c="5252">源代码</st>* <st c="5263">部分中概述的指导方针</st>
    <st c="5272">，这些指导方针来自</st> *<st c="5279">互联网安全中心（CIS）软件供应链</st>* *<st c="5336">安全指南</st>*<st
    c="5350">。</st>
- en: <st c="5351">CIS Software Supply Chain Security Guide</st>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5351">CIS软件供应链安全指南</st>
- en: '<st c="5392">The</st> *<st c="5397">CIS Software Supply Chain Security Guide</st>*
    <st c="5437">provides a comprehensive framework</st> <st c="5473">for secure software
    supply chain management.</st> <st c="5518">At the time of writing, the guide consists
    of 100+ recommendations organized into five main categories: Source Code, Build
    pipelines, Dependencies, Artifacts, and Deployment.</st> <st c="5693">To access
    the full guide, you can download it</st> <st c="5739">from</st> [<st c="5744">https://www.cisecurity.org/insights/white-papers/cis-software-supply-chain-security-guide</st>](https://www.cisecurity.org/insights/white-papers/cis-software-supply-chain-security-guide)<st
    c="5833">.</st>'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5392">《</st> *<st c="5397">CIS软件供应链安全指南</st>* <st c="5437">提供了一个全面的框架</st>
    <st c="5473">用于安全的软件供应链管理。</st> <st c="5518">截至写作时，该指南包含100多条建议，分为五大类：源代码、构建流水线、依赖关系、工件和部署。</st>
    <st c="5693">要访问完整指南，你可以从</st> <st c="5739">下载</st> [<st c="5744">https://www.cisecurity.org/insights/white-papers/cis-software-supply-chain-security-guide</st>](https://www.cisecurity.org/insights/white-papers/cis-software-supply-chain-security-guide)<st
    c="5833">。</st>
- en: <st c="5834">The guide</st> <st c="5845">offers a set of recommendations across</st>
    *<st c="5884">five key areas</st>* <st c="5898">to securely manage source</st>
    <st c="5925">code platforms:</st>
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5834">该指南</st> <st c="5845">提供了一系列建议，涵盖</st> *<st c="5884">五个关键领域</st>*
    <st c="5898">以安全地管理源代码平台：</st>
- en: '**<st c="5940">Managing code repositories securely</st>**<st c="5976">: This
    section includes 7 recommendations that focus on the security of code repositories,
    ensuring they are properly set up, maintained, and protected against unauthorized
    access</st> <st c="6157">or breaches.</st>'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="5940">安全地管理代码仓库</st>**<st c="5976">：本节包括7条建议，重点关注代码仓库的安全性，确保它们得到正确设置、维护，并防止未经授权的访问</st>
    <st c="6157">或泄露。</st>'
- en: '**<st c="6169">Managing code contributions securely</st>**<st c="6206">: This
    section includes 13 recommendations that focus on safely handling code contributions.</st>
    <st c="6300">This includes guidelines for reviewing, accepting, and merging contributions
    from various developers/contributors in a</st> <st c="6419">secure manner.</st>'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="6169">安全管理代码贡献</st>**<st c="6206">：本节包括13项建议，重点关注如何安全地处理代码贡献。</st>
    <st c="6300">这些建议包括审查、接受和合并来自不同开发者/贡献者的贡献的安全指导方针。</st> <st c="6419">这些操作应以安全的方式进行。</st>'
- en: '**<st c="6433">Managing code changes securely</st>**<st c="6464">: This section
    includes 19 recommendations on securely managing code changes in the repository.</st>
    <st c="6561">It covers guidelines on reviewing, testing, and approving changes
    to ensure that they don’t</st> <st c="6653">introduce vulnerabilities.</st>'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="6433">安全管理代码更改</st>**<st c="6464">：本节包括19项建议，指导如何安全地管理代码库中的代码更改。</st>
    <st c="6561">它包括审查、测试和批准更改的指导方针，以确保这些更改不会</st> <st c="6653">引入漏洞。</st>'
- en: '**<st c="6679">Managing code risks securely</st>**<st c="6708">: This section
    includes 6 recommendations with guidelines on identifying, assessing, and mitigating
    risks associated with code development.</st> <st c="6849">It includes practices
    for regular security audits and</st> <st c="6903">risk assessments.</st>'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="6679">安全管理代码风险</st>**<st c="6708">：本节包括6项建议，提供了识别、评估和缓解与代码开发相关的风险的指导方针。</st>
    <st c="6849">其中包括定期进行安全审计和</st> <st c="6903">风险评估的做法。</st>'
- en: '**<st c="6920">Managing third-party integrations securely</st>**<st c="6963">:
    The final section has 3 recommendations that focus on securely integrating third-party
    tools into source control repositories.</st> <st c="7093">It emphasizes the importance
    of vetting these integrations for security vulnerabilities and maintaining</st>
    <st c="7197">their updates.</st>'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="6920">安全管理第三方集成</st>**<st c="6963">：最后一节包含3项建议，专注于如何安全地将第三方工具集成到源代码控制库中。</st>
    <st c="7093">该部分强调了对这些集成进行安全漏洞审查并维护其更新的重要性。</st> <st c="7197">确保其安全性。</st>'
- en: <st c="7211">Due to limited space in this book, we cannot cover the implementation
    of all recommendations.</st> <st c="7306">However, we will focus on a few</st>
    <st c="7338">key ones.</st>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7211">由于本书篇幅有限，我们无法涵盖所有建议的实施细节。</st> <st c="7306">然而，我们将重点介绍一些</st> <st
    c="7338">关键建议。</st>
- en: <st c="7347">Managing code repositories securely</st>
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="7347">安全管理代码库</st>
- en: <st c="7383">The starting point of securing code repositories is ensuring that
    these repositories are created</st> <st c="7481">and maintained securely, protecting
    the code at all stages of its life cycle.</st> <st c="7559">Rather than enforcing
    a one-size-fits-all repository life cycle model (which rarely works), it is more
    effective to focus on defining organization</st> *<st c="7706">standards</st>*
    <st c="7715">for how a repository should be set up and operated securely.</st>
    <st c="7777">To achieve the best security results, the engineering and security
    teams need to work together to set these standards.</st> <st c="7896">They should
    consider how different teams work to make these standards practical</st> <st c="7976">and
    effective.</st>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7383">确保代码库的安全的起点是确保这些库在创建和维护过程中都是安全的，保护代码的整个生命周期。</st> <st c="7481">与其强制执行一个适用于所有情况的代码库生命周期模型（这种模型很少有效），不如更加有效地专注于定义组织</st>
    *<st c="7706">标准</st>* <st c="7715">，明确如何安全地设置和操作代码库。</st> <st c="7777">为了达到最佳的安全效果，工程团队和安全团队需要共同合作，制定这些标准。</st>
    <st c="7896">他们应该考虑不同团队的工作方式，以确保这些标准既切实可行又有效。</st> <st c="7976">确保在实施过程中可以真正发挥作用。</st>
- en: <st c="7990">As the organization matures, these standards should be turned into
    automated processes.</st> <st c="8079">This way, new secure repositories can be
    set up quickly and in line with the organization’s security needs, while reducing
    the chance of mistakes that often happen with manual steps.</st> <st c="8262">This
    approach not only boosts security but also makes the process of setting up repositories</st>
    <st c="8355">more efficient.</st>
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7990">随着组织的成熟，这些标准应转化为自动化流程。</st> <st c="8079">这样，新的安全代码库可以快速建立，并与组织的安全需求保持一致，同时减少手动操作中常出现的错误。</st>
    <st c="8262">这种方法不仅可以提升安全性，还能使设置代码库的过程</st> <st c="8355">更加高效。</st>
- en: <st c="8370">The following are some guidelines to follow in this area.</st>
    <st c="8429">We will discuss how to implement them in both GitHub and</st> <st
    c="8486">Azure DevOps.</st>
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8370">以下是该领域的一些指导方针。</st> <st c="8429">我们将讨论如何在GitHub和</st> <st c="8486">Azure
    DevOps中实施这些指导方针。</st>
- en: <st c="8499">Recommendation 1 – Ensuring repository creation is limited to specific
    members</st>
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="8499">推荐 1 – 确保仓库创建仅限于特定成员</st>
- en: <st c="8578">In GitHub, when</st> <st c="8595">setting up repositories within
    an organization, there are three visibility options:</st> **<st c="8679">Public</st>**<st
    c="8685">,</st> **<st c="8687">Private</st>**<st c="8694">, and</st> **<st c="8700">Internal</st>**<st
    c="8708">.</st> **<st c="8710">Public</st>** <st c="8716">repositories are visible
    to everyone, including non-organization members.</st> **<st c="8791">Private</st>**
    <st c="8798">repositories are visible only to organization members who have been
    given access.</st> <st c="8881">Finally,</st> **<st c="8890">Internal</st>** <st
    c="8898">repositories are visible to all members of any organization within the
    same enterprise.</st> <st c="8987">No matter which visibility option is used,
    it is important to secure the code so that only authorized users can access and</st>
    <st c="9110">modify it.</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8578">在 GitHub 中，当</st> <st c="8595">在组织内设置仓库时，有三种可见性选项：</st> **<st c="8679">公开</st>**<st
    c="8685">，</st> **<st c="8687">私有</st>**<st c="8694">，和</st> **<st c="8700">内部</st>**<st
    c="8708">。</st> **<st c="8710">公开</st>** <st c="8716">仓库对所有人可见，包括非组织成员。</st> **<st
    c="8791">私有</st>** <st c="8798">仓库仅对已授权的组织成员可见。</st> <st c="8881">最后，</st> **<st
    c="8890">内部</st>** <st c="8898">仓库对同一企业内任何组织的所有成员可见。</st> <st c="8987">无论使用哪种可见性选项，保护代码安全非常重要，以确保只有授权用户能够访问并</st>
    <st c="9110">修改它。</st>
- en: <st c="9120">By default, all members of an organization can create repositories
    of any of these types (</st>*<st c="9211">Figure 5</st>**<st c="9220">.4</st>*<st
    c="9222">).</st> <st c="9226">However, it is good practice to modify this default
    setting to</st> <st c="9289">enhance security:</st>
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9120">默认情况下，所有组织成员都可以创建任何类型的仓库（</st>*<st c="9211">图 5</st>**<st c="9220">.4</st>*<st
    c="9222">）。</st> <st c="9226">然而，修改此默认设置以</st> <st c="9289">增强安全性是一个好做法：</st>
- en: '![Figure 5.4 – Default repository creation permission in a GitHub organization](img/B19710_05_04.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – GitHub 组织中的默认仓库创建权限](img/B19710_05_04.jpg)'
- en: <st c="9477">Figure 5.4 – Default repository creation permission in a GitHub
    organization</st>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9477">图 5.4 – GitHub 组织中的默认仓库创建权限</st>
- en: <st c="9553">We can</st> <st c="9561">either prevent members from being able
    to create repositories altogether or we can restrict the types of repositories
    they are allowed to create.</st> <st c="9707">This change can be made either at
    the organization level or at the enterprise level if you have an enterprise account
    and wish to apply changes across</st> <st c="9858">multiple organizations.</st>
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9553">我们可以</st> <st c="9561">要么完全禁止成员创建仓库，要么限制他们可以创建的仓库类型。</st> <st c="9707">此更改可以在组织级别进行，也可以在企业级别进行，如果您有企业账户并希望在多个组织中应用更改。</st>
- en: '`<st c="9936">https://github.com/enterprises/{ENTERPRISE_NAME}</st>`<st c="9985">)
    go to</st> `<st c="10051">ENTERPRISE_NAME</st>` <st c="10066">is a placeholder
    for your valid GitHub</st> <st c="10106">Enterprise name.</st>'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="9936">https://github.com/enterprises/{ENTERPRISE_NAME}</st>`<st c="9985">)
    访问</st> `<st c="10051">ENTERPRISE_NAME</st>` <st c="10066">是您有效的 GitHub</st> <st
    c="10106">企业名称的占位符。</st>'
- en: '**<st c="10122">Organization level</st>**<st c="10141">: From the</st> **<st
    c="10153">Organization settings</st>** <st c="10174">page, go to</st> **<st c="10187">Member
    privileges</st>** <st c="10204">|</st> **<st c="10207">Repository creation</st>**<st
    c="10226">:</st>'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="10122">组织级别</st>**<st c="10141">：在</st> **<st c="10153">组织设置</st>**
    <st c="10174">页面，访问</st> **<st c="10187">成员权限</st>** <st c="10204">|</st> **<st
    c="10207">仓库创建</st>**<st c="10226">：</st>'
- en: '![Figure 5.5 – Modifying the default repository creation permission for members](img/B19710_05_05.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 修改成员的默认仓库创建权限](img/B19710_05_05.jpg)'
- en: <st c="10656">Figure 5.5 – Modifying the default repository creation permission
    for members</st>
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10656">图 5.5 – 修改成员的默认仓库创建权限</st>
- en: <st c="10733">Regardless of this setting, certain roles at the organization
    level still retain the permission to create repositories.</st> <st c="10854">These
    roles include</st> **<st c="10874">Owners</st>**<st c="10880">,</st> **<st c="10882">Moderators</st>**<st
    c="10892">, and</st> **<st c="10898">Security Managers</st>** <st c="10915">(</st>*<st
    c="10917">Figure 5</st>**<st c="10925">.4</st>*<st c="10927">).</st> <st c="10931">Also,
    at the enterprise level, the role of</st> **<st c="10974">Enterprise Owner</st>**
    <st c="10990">has the privilege to modify permissions at the organization level,
    so it can be leveraged as a path to create</st> <st c="11101">a repository.</st>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10733">无论此设置如何，某些组织级别的角色仍然保留创建仓库的权限。</st> <st c="10854">这些角色包括</st> **<st
    c="10874">所有者</st>**<st c="10880">、</st> **<st c="10882">版主</st>**<st c="10892">和</st>
    **<st c="10898">安全管理员</st>** <st c="10915">(</st>*<st c="10917">图 5</st>**<st
    c="10925">.4</st>*<st c="10927">)。</st> <st c="10931">此外，在企业级别，</st> **<st c="10974">企业所有者</st>**
    <st c="10990">角色具有修改组织级别权限的特权，因此可以作为创建仓库的路径。</st>
- en: <st c="11114">In Azure DevOps, the process for managing repository creation
    permission is slightly different from GitHub due to the platform’s structure.</st>
    <st c="11255">Repositories in Azure Repos can be set as</st> **<st c="11297">Public</st>**
    <st c="11303">or</st> **<st c="11307">Private</st>**<st c="11314">. A</st> **<st
    c="11318">Public</st>** <st c="11324">repository is accessible to everyone, including
    those outside of an organization.</st> <st c="11407">On the other hand, a</st>
    **<st c="11428">Private</st>** <st c="11435">repository is only visible to organization
    members who have been specifically granted access.</st> <st c="11530">Azure DevOps
    does not have</st> <st c="11557">an</st> *<st c="11560">internal</st>* <st c="11568">visibility
    option like GitHub, mainly because it doesn’t support an enterprise account structure.</st>
    <st c="11667">To enhance security, you can restrict the creation of public repositories
    by disabling the option to create public projects within your Azure DevOps organization.</st>
    <st c="11830">This change affects all members of the organization, regardless
    of their role or permission level, preventing anyone from creating public repositories.</st>
    <st c="11982">To implement this, we can navigate to</st> **<st c="12020">Azure
    DevOps</st>** <st c="12032">|</st> **<st c="12035">Organization settings</st>**
    <st c="12056">|</st> **<st c="12059">Security</st>** <st c="12067">|</st> **<st
    c="12070">Policies</st>** <st c="12078">|</st> **<st c="12081">Security policies</st>**
    <st c="12098">|</st> **<st c="12101">Allow public projects</st>**<st c="12122">.
    Microsoft recently announced that this is now disabled</st> <st c="12179">by default.</st>
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11114">在 Azure DevOps 中，管理仓库创建权限的流程与 GitHub 略有不同，这是由于平台结构的原因。</st> <st
    c="11255">Azure Repos 中的仓库可以设置为</st> **<st c="11297">公开</st>** <st c="11303">或</st>
    **<st c="11307">私有</st>**<st c="11314">。一个</st> **<st c="11318">公开</st>** <st
    c="11324">仓库对所有人开放，包括组织外的人。</st> <st c="11407">另一方面，</st> **<st c="11428">私有</st>**
    <st c="11435">仓库仅对已被特别授权的组织成员可见。</st> <st c="11530">Azure DevOps 没有</st> <st c="11557">像
    GitHub 那样的</st> *<st c="11560">内部</st>* <st c="11568">可见性选项，主要是因为它不支持企业账户结构。</st>
    <st c="11667">为了增强安全性，你可以通过禁用在 Azure DevOps 组织内创建公开项目的选项来限制公开仓库的创建。</st> <st c="11830">此更改会影响组织中的所有成员，无论其角色或权限级别如何，从而阻止任何人创建公开仓库。</st>
    <st c="11982">要实现这一点，我们可以导航至</st> **<st c="12020">Azure DevOps</st>** <st c="12032">|</st>
    **<st c="12035">组织设置</st>** <st c="12056">|</st> **<st c="12059">安全</st>** <st
    c="12067">|</st> **<st c="12070">策略</st>** <st c="12078">|</st> **<st c="12081">安全策略</st>**
    <st c="12098">|</st> **<st c="12101">允许公开项目</st>**<st c="12122">。微软最近宣布此选项已默认禁用</st>
    <st c="12179">。</st>
- en: <st c="12190">By default, only users who are assigned the following roles can
    create repositories in</st> <st c="12278">Azure DevOps:</st>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12190">默认情况下，只有被分配以下角色的用户才能在</st> <st c="12278">Azure DevOps</st> <st
    c="12278">中创建仓库：</st>
- en: '**<st c="12291">Organization level</st>**<st c="12310">: Project Collection
    Administrators; Project Collection Service Accounts; Project Collection Valid
    Users; Project Collection Build Administrators; Project Collection Build Service
    Accounts; Project Collection Proxy Service Accounts; Project Collection Test</st>
    <st c="12568">Service Accounts</st>'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="12291">组织级别</st>**<st c="12310">：项目集合管理员；项目集合服务账户；项目集合有效用户；项目集合构建管理员；项目集合构建服务账户；项目集合代理服务账户；项目集合测试服务账户</st>'
- en: '**<st c="12584">Project level</st>**<st c="12598">:</st> <st c="12601">Project
    Administrators</st>'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="12584">项目级别</st>**<st c="12598">：</st> <st c="12601">项目管理员</st>'
- en: <st c="12623">We can tightly control assignments into the roles to implement</st>
    <st c="12687">this recommendation.</st>
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12623">我们可以通过严格控制角色分配来实施</st> <st c="12687">此推荐。</st>
- en: <st c="12707">Recommendation 2 – Ensuring sensitive repository operations are
    limited to specific members</st>
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="12707">推荐 2 – 确保敏感仓库操作仅限特定成员执行</st>
- en: <st c="12799">Certain</st> <st c="12808">repository operations are considered
    to be high-risk or sensitive because of the potential impact they could have if
    they’re exploited in a malicious attack.</st> <st c="12966">This includes operations
    such as repository deletion, forking, and visibility change.</st> <st c="13052">It
    is recommended to restrict the number of members that are allowed to perform</st>
    <st c="13132">these operations.</st>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12799">某些</st> <st c="12808">仓库操作因其潜在的恶意攻击风险，被认为是高风险或敏感的。</st> <st c="12966">这包括如删除仓库、分叉仓库和更改仓库可见性等操作。</st>
    <st c="13052">建议限制允许执行</st> <st c="13132">这些操作的成员数量。</st>
- en: <st c="13149">To restrict who can delete repositories and change their visibility
    on GitHub, go to</st> **<st c="13235">Organization</st>** <st c="13247">|</st>
    **<st c="13250">Settings</st>** <st c="13258">|</st> **<st c="13261">Access</st>**
    <st c="13267">|</st> **<st c="13270">Member privileges</st>** <st c="13287">|</st>
    **<st c="13290">Admin repository permissions</st>**<st c="13318">. Uncheck the
    options for</st> **<st c="13344">Allow members to delete or transfer repositories
    for this organization</st>** <st c="13414">and</st> **<st c="13419">Allow members
    to change repository visibilities for this organization</st>**<st c="13488">,
    then save</st> <st c="13500">your changes.</st>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13149">要限制谁可以删除仓库并更改其在 GitHub 上的可见性，请前往</st> **<st c="13235">组织</st>**
    <st c="13247">|</st> **<st c="13250">设置</st>** <st c="13258">|</st> **<st c="13261">访问</st>**
    <st c="13267">|</st> **<st c="13270">成员权限</st>** <st c="13287">|</st> **<st c="13290">管理员仓库权限</st>**<st
    c="13318">。取消勾选</st> **<st c="13344">允许成员删除或转移该组织的仓库</st>** <st c="13414">和</st>
    **<st c="13419">允许成员更改该组织仓库的可见性</st>**<st c="13488">，然后保存</st> <st c="13500">您的更改。</st>
- en: <st c="13513">To</st> <st c="13517">restrict who can delete repositories in
    an Azure DevOps project, go to</st> **<st c="13588">Project Settings</st>** <st
    c="13604">|</st> **<st c="13607">Repos</st>** <st c="13612">|</st> **<st c="13615">Repositories</st>**
    <st c="13627">|</st> **<st c="13630">Security</st>** <st c="13638">and edit the
    permissions for the user or group (</st>*<st c="13687">Figure 5</st>**<st c="13696">.6</st>*<st
    c="13698">):</st>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13513">要</st> <st c="13517">限制谁可以在 Azure DevOps 项目中删除仓库，请前往</st> **<st
    c="13588">项目设置</st>** <st c="13604">|</st> **<st c="13607">仓库</st>** <st c="13612">|</st>
    **<st c="13615">仓库</st>** <st c="13627">|</st> **<st c="13630">安全</st>** <st c="13638">并编辑该用户或组的权限（</st>*<st
    c="13687">图 5</st>**<st c="13696">.6</st>*<st c="13698">）：</st>
- en: '![Figure 5.6 – Configuring the permission to delete repositories](img/B19710_05_06.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 配置删除仓库的权限](img/B19710_05_06.jpg)'
- en: <st c="14423">Figure 5.6 – Configuring the permission to delete repositories</st>
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14423">图 5.6 – 配置删除仓库的权限</st>
- en: <st c="14485">By default, the contributors role in an Azure DevOps project can</st>
    <st c="14551">fork repositories.</st>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14485">默认情况下，Azure DevOps 项目中的贡献者角色可以</st> <st c="14551">分叉仓库。</st>
- en: <st c="14569">Recommendation 3 – Ensuring inactive repositories are reviewed
    and archived periodically</st>
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="14569">推荐 3 – 确保定期审查和归档非活动仓库</st>
- en: <st c="14658">Inactive repositories can become security liabilities or clutter.</st>
    <st c="14725">For example, they might lead</st> <st c="14754">to false alarms,
    making security teams spend valuable time on non-issues.</st> <st c="14828">It
    is recommended to regularly review such repositories to determine if they should
    be archived.</st> <st c="14925">Doing so not only improves security but also helps
    in keeping the monitoring environment clean of</st> <st c="15023">unnecessary
    distractions.</st>
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14658">非活动仓库可能成为安全隐患或杂乱无章。</st> <st c="14725">例如，它们可能会导致</st> <st c="14754">误报，使安全团队花费宝贵时间处理无关紧要的问题。</st>
    <st c="14828">建议定期审查此类仓库，以确定是否应该将其归档。</st> <st c="14925">这样做不仅能提高安全性，还能帮助保持监控环境的清洁，避免</st>
    <st c="15023">不必要的干扰。</st>
- en: <st c="15048">To review recent repository-related activities in GitHub, go to
    the repository, then click on</st> **<st c="15143">Insights</st>**<st c="15151">.
    Review the</st> **<st c="15164">Pulse</st>**<st c="15169">,</st> **<st c="15171">Commits</st>**<st
    c="15178">, and</st> **<st c="15184">Code</st>** **<st c="15189">frequency</st>**
    <st c="15198">areas:</st>
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15048">要审查 GitHub 中最近的仓库相关活动，请进入仓库，然后点击</st> **<st c="15143">洞察</st>**<st
    c="15151">。审查</st> **<st c="15164">脉冲</st>**<st c="15169">、</st> **<st c="15171">提交</st>**<st
    c="15178">和</st> **<st c="15184">代码</st>** **<st c="15189">频率</st>** <st c="15198">区域：</st>
- en: '![Figure 5.7 – Reviewing recent code repository activity in GitHub](img/B19710_05_07.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7 – 审查 GitHub 最近的代码仓库活动](img/B19710_05_07.jpg)'
- en: <st c="15585">Figure 5.7 – Reviewing recent code repository activity in GitHub</st>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15585">图 5.7 – 审查 GitHub 最近的代码仓库活动</st>
- en: <st c="15649">To review recent repository-related activities for an Azure DevOps
    project, navigate to an Azure DevOps project, select</st> **<st c="15770">Overview</st>**
    <st c="15778">|</st> **<st c="15781">Summary</st>**<st c="15788">, and review
    the</st> **<st c="15805">Project stats</st>** <st c="15818">area, especially the
    recent commits and</st> <st c="15859">pull requests:</st>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15649">要审查 Azure DevOps 项目的最近仓库相关活动，请导航到 Azure DevOps 项目，选择</st> **<st
    c="15770">概览</st>** <st c="15778">|</st> **<st c="15781">摘要</st>**<st c="15788">，并审查</st>
    **<st c="15805">项目统计信息</st>** <st c="15818">区域，特别是最近的提交和</st> <st c="15859">拉取请求：</st>
- en: '![Figure 5.8 – Azure DevOps project summary](img/B19710_05_08.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8 – Azure DevOps 项目概览](img/B19710_05_08.jpg)'
- en: <st c="16301">Figure 5.8 – Azure DevOps project summary</st>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16301">图 5.8 – Azure DevOps 项目概览</st>
- en: <st c="16342">This</st> <st c="16348">information can also be retrieved via
    the API to generate an automated report, though you can also implement third-party
    solutions that surface the information in a</st> <st c="16513">streamlined way.</st>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16342">这些</st> <st c="16348">信息也可以通过 API 获取，用于生成自动化报告，虽然你也可以实施第三方解决方案，以更</st>
    <st c="16513">简化的方式呈现这些信息。</st>
- en: <st c="16529">Recommendation 4 – Repositories should be created with auditing
    enabled</st>
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="16529">推荐 4 – 应创建启用审计的仓库</st>
- en: <st c="16601">In the event of a security breach, auditing is important for identifying
    and analyzing the attacker’s</st> <st c="16704">actions within our environment.</st>
    <st c="16736">From a proactive perspective, we can use the logs to monitor for
    access patterns that are suspicious, indicative of malicious activity, or violate
    key</st> <st c="16887">organization policies.</st>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16601">在发生安全漏洞时，审计对识别和分析攻击者在我们环境中的</st> <st c="16704">行为至关重要。</st> <st
    c="16736">从主动的角度来看，我们可以利用日志监控可疑的访问模式，这些模式可能是恶意活动的迹象，或违反了关键的</st> <st c="16887">组织政策。</st>
- en: <st c="16909">To enable event logging for repository activities in GitHub Enterprise,
    follow</st> <st c="16989">these steps:</st>
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16909">要在 GitHub Enterprise 中启用仓库活动的事件日志，请按照</st> <st c="16989">以下步骤操作：</st>
- en: <st c="17001">Go to your GitHub</st> <st c="17020">organization’s</st> **<st
    c="17035">Settings</st>**<st c="17043">.</st>
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="17001">进入你的 GitHub</st> <st c="17020">组织的</st> **<st c="17035">设置</st>**<st
    c="17043">。</st>
- en: <st c="17044">Select the</st> **<st c="17056">Archive</st>** <st c="17063">|</st>
    **<st c="17066">Logs</st>** <st c="17070">|</st> **<st c="17073">Audit</st>**
    **<st c="17079">log</st>** <st c="17082">section.</st>
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="17044">选择</st> **<st c="17056">归档</st>** <st c="17063">|</st> **<st c="17066">日志</st>**
    <st c="17070">|</st> **<st c="17073">审计</st>** **<st c="17079">日志</st>** <st c="17082">部分。</st>
- en: <st c="17091">Audit logging is enabled by default.</st> <st c="17129">However,
    to ensure that source IP information is also logged, click</st> **<st c="17197">Settings</st>**
    <st c="17205">and enable the</st> **<st c="17221">Enable source IP</st>** **<st
    c="17238">disclosure</st>** <st c="17248">option:</st>
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="17091">审计日志默认启用。</st> <st c="17129">但是，为了确保源 IP 信息也被记录，请点击</st> **<st
    c="17197">设置</st>** <st c="17205">并启用</st> **<st c="17221">启用源 IP</st>** **<st
    c="17238">披露</st>** <st c="17248">选项：</st>
- en: '![Figure 5.9 – Reviewing GitHub audit log settings](img/B19710_05_09.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.9 – 审查 GitHub 审计日志设置](img/B19710_05_09.jpg)'
- en: <st c="17815">Figure 5.9 – Reviewing GitHub audit log settings</st>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17815">图 5.9 – 审查 GitHub 审计日志设置</st>
- en: <st c="17863">By</st> <st c="17867">default, GitHub tracks various repository
    events, including creation, modification, deletion, and other significant actions.</st>
    <st c="17992">For a full understanding of the events that are captured by GitHub’s
    audit log, refer to GitHub’s official documentation on</st> *<st c="18116">audit
    log events</st>* <st c="18132">here:</st> [<st c="18139">https://docs.github.com/en/enterprise-cloud@latest/organizations/keeping-your-organization-secure/managing-security-settings-for-your-organization/audit-log-events-for-your-organization</st>](mailto:https://docs.github.com/en/enterprise-cloud@latest/organizations/keeping-your-organization-secure/managing-security-settings-for-your-organization/audit-log-events-for-your-organization)<st
    c="18324">.</st>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17863">默认情况下，GitHub 跟踪各种仓库事件，包括创建、修改、删除以及其他重要操作。</st> <st c="17992">要全面了解
    GitHub 审计日志中记录的事件，请参考 GitHub 官方文档中的</st> *<st c="18116">审计日志事件</st>* <st c="18132">，链接如下：</st>
    [<st c="18139">https://docs.github.com/en/enterprise-cloud@latest/organizations/keeping-your-organization-secure/managing-security-settings-for-your-organization/audit-log-events-for-your-organization</st>](mailto:https://docs.github.com/en/enterprise-cloud@latest/organizations/keeping-your-organization-secure/managing-security-settings-for-your-organization/audit-log-events-for-your-organization)<st
    c="18324">。</st>
- en: <st c="18325">To set up event logging for repository-related activities in Azure
    Repos, follow</st> <st c="18407">these steps:</st>
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18325">要为 Azure Repos 中与仓库相关的活动设置事件日志，请按照</st> <st c="18407">以下步骤操作：</st>
- en: <st c="18419">Navigate to</st> **<st c="18432">Organization Settings</st>**<st
    c="18453">.</st>
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="18419">前往</st> **<st c="18432">组织设置</st>**<st c="18453">。</st>
- en: <st c="18454">Select</st> **<st c="18462">Security</st>**<st c="18470">.</st>
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="18454">选择</st> **<st c="18462">安全性</st>**<st c="18470">。</st>
- en: <st c="18471">Go</st> <st c="18475">to</st> **<st c="18478">Policies</st>**<st
    c="18486">.</st>
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="18471">前往</st> <st c="18475">**政策**</st> <st c="18486">。</st>
- en: <st c="18487">Enable the</st> **<st c="18499">Log Audit</st>** **<st c="18509">Events</st>**
    <st c="18515">option:</st>
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="18487">启用</st> **<st c="18499">审计日志</st>** **<st c="18509">事件</st>**
    <st c="18515">选项：</st>
- en: '![Figure 5.10 – Enabling audit logs in Azure DevOps](img/B19710_05_10.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.10 – 在 Azure DevOps 中启用审计日志](img/B19710_05_10.jpg)'
- en: <st c="18856">Figure 5.10 – Enabling audit logs in Azure DevOps</st>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18856">图 5.10 – 在 Azure DevOps 中启用审计日志</st>
- en: <st c="18905">By turning on this feature, we will be able to log various events
    related to repositories, such</st> <st c="19002">as creation, forking, modification,
    enabling, disabling, deletion, and undeletion.</st> <st c="19085">For a comprehensive
    list of all the events that Azure DevOps audits, please refer to the official</st>
    <st c="19183">documentation:</st> [<st c="19198">https://learn.microsoft.com/en-us/azure/devops/organizations/audit/auditing-events?view=azure-devops</st>](https://learn.microsoft.com/en-us/azure/devops/organizations/audit/auditing-events?view=azure-devops)<st
    c="19298">.</st>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18905">开启此功能后，我们将能够记录与仓库相关的各种事件，如创建、分叉、修改、启用、禁用、删除和恢复删除。</st> <st c="19085">有关
    Azure DevOps 审计的所有事件的完整列表，请参阅官方</st> <st c="19183">文档：</st> [<st c="19198">https://learn.microsoft.com/en-us/azure/devops/organizations/audit/auditing-events?view=azure-devops</st>](https://learn.microsoft.com/en-us/azure/devops/organizations/audit/auditing-events?view=azure-devops)<st
    c="19298">。</st>
- en: <st c="19299">Note</st>
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19299">注意</st>
- en: <st c="19304">Many organizations send these logs to a SIEM solution for further
    aggregation and analysis.</st> <st c="19397">For example, the Sentinel Connector
    for GitHub can be used to ingest GitHub audit logs</st> <st c="19484">into Microsoft
    Sentinel.</st> <st c="19509">More information is available</st> <st c="19539">here:</st>
    [<st c="19545">https://learn.microsoft.com/en-us/azure/sentinel/data-connectors/github-enterprise-audit-log</st>](https://learn.microsoft.com/en-us/azure/sentinel/data-connectors/github-enterprise-audit-log)<st
    c="19637">.</st>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19304">许多组织将这些日志发送到 SIEM 解决方案中，以便进一步汇总和分析。</st> <st c="19397">例如，可以使用
    GitHub 的 Sentinel 连接器将 GitHub 审计日志</st> <st c="19484">导入 Microsoft Sentinel。</st>
    <st c="19509">更多信息，请参阅</st> <st c="19539">此处：</st> [<st c="19545">https://learn.microsoft.com/en-us/azure/sentinel/data-connectors/github-enterprise-audit-log</st>](https://learn.microsoft.com/en-us/azure/sentinel/data-connectors/github-enterprise-audit-log)<st
    c="19637">。</st>
- en: <st c="19638">Addressing common coding security issues in source control</st>
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="19638">解决源代码管理中的常见编码安全问题</st>
- en: '<st c="19697">Securing</st> <st c="19707">our source control platform is crucial,
    but it is equally important to continuously test code for security and compliance
    within source control systems.</st> <st c="19860">This is necessary even if we
    already have pre-commit or IDE security integrations in place.</st> <st c="19952">The
    reason is simple: pre-commit code security measures can be bypassed; developers
    might disable git hooks or bypass</st> <st c="20070">checks by changing the configurations</st>
    <st c="20108">of</st> **<st c="20111">static application security testing</st>**
    <st c="20146">(</st>**<st c="20148">SAST</st>**<st c="20152">) or</st> **<st c="20158">software
    composition analysis</st>** <st c="20187">(</st>**<st c="20189">SCA</st>**<st
    c="20192">) tools.</st> <st c="20202">Security integrations in source control
    systems, however, provide more enforceable and</st> <st c="20289">reliable protection.</st>'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19697">保护</st> <st c="19707">我们的源代码管理平台至关重要，但同样重要的是在源代码管理系统中持续测试代码的安全性和合规性。</st>
    <st c="19860">即使我们已经有了预提交或 IDE 安全集成，也需要这样做。</st> <st c="19952">原因很简单：预提交的代码安全措施可能被绕过；开发人员可能禁用
    Git 钩子或通过修改</st> <st c="20070">配置来绕过</st> <st c="20108">**<st c="20111">静态应用程序安全测试</st>**
    </st> <st c="20146">(</st>**<st c="20148">SAST</st>**<st c="20152">) 或</st> **<st
    c="20158">软件组成分析</st>** <st c="20187">(</st>**<st c="20189">SCA</st>**<st c="20192">)
    工具的检查。</st> <st c="20202">然而，源代码管理系统中的安全集成提供了更具执行力和</st> <st c="20289">更可靠的保护。</st>
- en: <st c="20309">Also, scanning code in source control systems provides a wider
    coverage than IDE scans.</st> <st c="20398">It</st> <st c="20401">captures commits
    that might not be present in the developer’s workspace at pre-commit.</st> <st
    c="20488">This increases the chances of detecting vulnerabilities that have been
    missed in pre-commit scans.</st> <st c="20587">A third reason is that vulnerabilities
    are dynamic.</st> <st c="20639">For example, a dependency might have passed security
    checks in the development and pre-commit phases, but new vulnerabilities have
    since been uncovered.</st> <st c="20792">We need to have a routine process for
    regularly scanning the code in our source control systems to detect and resolve</st>
    <st c="20910">these issues.</st>
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20309">此外，在源代码管理系统中扫描代码比在 IDE 中扫描提供了更广泛的覆盖。</st> <st c="20398">它</st>
    <st c="20401">捕获了在开发者的工作空间中可能不存在的提交，尤其是在预提交时。</st> <st c="20488">这增加了发现预提交扫描中遗漏的漏洞的机会。</st>
    <st c="20587">第三个原因是漏洞具有动态性。</st> <st c="20639">例如，一个依赖项可能在开发和预提交阶段通过了安全检查，但此后却发现了新的漏洞。</st>
    <st c="20792">我们需要定期扫描源代码管理系统中的代码，以检测和解决</st> <st c="20910">这些问题。</st>
- en: <st c="20923">When it comes to addressing common coding security issues in source
    control, the focus is generally on the same issues we discussed in the pre-commit
    phase:</st> *<st c="21081">detecting vulnerabilities in both first-party code
    and third-party dependencies</st>* <st c="21160">(direct and transitive) and</st>
    *<st c="21189">identifying/preventing secrets in code commits</st>*<st c="21235">.
    If you need a refresher on these issues, feel free to review the</st> *<st c="21302">Addressing
    common development security mistakes</st>* <st c="21349">section of</st> [*<st
    c="21361">Chapter 4</st>*](B19710_04.xhtml#_idTextAnchor072)<st c="21370">.</st>
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20923">当涉及到在源代码管理中处理常见的编码安全问题时，重点通常是我们在预提交阶段讨论过的相同问题：</st> *<st c="21081">检测第一方代码和第三方依赖项中的漏洞</st>*
    <st c="21160">(直接和传递的依赖)以及</st> *<st c="21189">识别/防止代码提交中的密钥</st>*<st c="21235">。如果你需要回顾这些问题，请随时查阅</st>
    *<st c="21302">处理常见开发安全错误</st>* <st c="21349">部分</st> [*<st c="21361">第 4 章</st>*](B19710_04.xhtml#_idTextAnchor072)<st
    c="21370">。</st>
- en: <st c="21371">However, the points where we integrate these security measures
    differ and the tools we use may be different.</st> <st c="21481">The following
    figure shows four of these integration points that we will cover in</st> <st c="21563">this
    chapter:</st>
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21371">然而，我们集成这些安全措施的具体位置有所不同，使用的工具也可能不同。</st> <st c="21481">以下图展示了我们将在本章中介绍的四个集成点：</st>
- en: '![Figure 5.11 – Code security integration points in source control](img/B19710_05_11.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.11 – 代码安全集成点在源代码管理中的位置](img/B19710_05_11.jpg)'
- en: <st c="21936">Figure 5.11 – Code security integration points in source control</st>
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="21936">图 5.11 – 代码安全集成点在源代码管理中的位置</st>
- en: <st c="22000">Speaking</st> <st c="22010">of tooling, the GitHub Enterprise
    platform has a great suite of tools (</st>**<st c="22081">GitHub code security</st>**<st
    c="22102">) for integrating security scans within its source control system.</st>
    <st c="22170">It includes various tools for identifying and resolving code security
    issues in</st> <st c="22250">source control.</st>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22000">说到工具，GitHub Enterprise 平台有一套出色的工具套件（</st>**<st c="22081">GitHub
    代码安全</st>**<st c="22102">），用于在其源代码控制系统中集成安全扫描。</st> <st c="22170">它包括各种工具，用于识别和解决源代码控制中的代码安全问题。</st>
- en: <st c="22265">Understanding GitHub code security</st>
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="22265">理解 GitHub 代码安全</st>
- en: <st c="22300">GitHub</st> <st c="22308">code security is</st> *<st c="22325">not</st>*
    <st c="22328">a tool; it is a collection of features</st> <st c="22368">provided
    by the GitHub platform to identify and fix code security issues in source control.</st>
    <st c="22460">The following figure provides an overview of</st> <st c="22505">these
    features:</st>
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22300">GitHub</st> <st c="22308">代码安全不是工具；它是 GitHub 平台提供的一组功能，用于识别和修复源代码控制中的代码安全问题。</st>
    <st c="22460">下图概述了</st> <st c="22505">这些功能：</st>
- en: '![Figure 5.12 – GitHub code security features](img/B19710_05_12.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.12 – GitHub 代码安全功能](img/B19710_05_12.jpg)'
- en: <st c="22707">Figure 5.12 – GitHub code security features</st>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22707">图 5.12 – GitHub 代码安全功能</st>
- en: <st c="22750">Note</st>
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22750">注意</st>
- en: <st c="22755">In the preceding figure, the star denotes the features that are
    available for both GitHub Enterprise and</st> <st c="22861">Azure DevOps.</st>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22755">在上图中，星号表示适用于 GitHub Enterprise 和</st> <st c="22861">Azure DevOps
    的功能。</st>
- en: <st c="22874">In the</st> <st c="22882">next few sections, we will cover some
    of the code security integrations that we can implement in source control.</st>
    <st c="22995">Some of these integrations can be implemented using GitHub code
    security capabilities.</st> <st c="23082">We will expand more on them in the</st>
    <st c="23117">relevant sections.</st>
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22874">在接下来的几节中，我们将介绍一些可以在源代码控制中实现的代码安全集成。</st> <st c="22995">其中一些集成可以使用
    GitHub 的代码安全功能来实现。</st> <st c="23082">我们将在相关章节中进一步展开讨论。</st>
- en: <st c="23135">Recommendation 1 – Implementing dependency tracking in source
    control</st>
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="23135">建议 1 – 在源代码控制中实施依赖跟踪</st>
- en: <st c="23205">One</st> <st c="23210">of the starting points for integrating
    code security in source control is to constantly</st> <st c="23298">assess and
    track dependencies that are used across the projects in your organization.</st>
    <st c="23384">Having a centralized location to check if a package is in use across
    an organization’s projects is beneficial during a security incident.</st> <st
    c="23522">It allows us to quickly determine if we are impacted by a newly disclosed
    vulnerability, as in the case of Log4j vulnerability disclosure (</st>**<st c="23661">CVE-2021-44228</st>**<st
    c="23676">).</st> <st c="23680">The GitHub platform has a native capability that
    we can use for</st> <st c="23744">this called</st> **<st c="23756">dependency
    graph</st>**<st c="23772">. Unfortunately, this capability isn’t directly available
    in Azure DevOps yet.</st> <st c="23851">However, multiple third-party solutions
    can be used to implement</st> <st c="23916">similar functionality.</st>
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23205">在源代码控制中集成代码安全的起点之一是持续评估和跟踪组织中项目中使用的依赖关系。</st> <st c="23384">在安全事件期间，拥有一个集中的位置来检查包是否在组织的各个项目中使用，对于快速确定我们是否受到新披露的漏洞的影响非常有益，例如
    Log4j 漏洞披露的情况（</st>**<st c="23661">CVE-2021-44228</st>**<st c="23676">）。</st>
    <st c="23680">GitHub 平台具有我们可以用于此的本地能力，称为</st> **<st c="23756">依赖图</st>**<st c="23772">。不幸的是，Azure
    DevOps 尚未直接提供此功能。</st> <st c="23851">但是，可以使用多种第三方解决方案来实现类似的功能。</st>
- en: <st c="23938">Understanding and implementing the dependency graph in GitHub
    Enterprise</st>
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="23938">理解并实现 GitHub Enterprise 中的依赖图</st>
- en: <st c="24011">The dependency graph provides a summary of direct and transitive
    dependencies that are</st> <st c="24099">referenced in a GitHub</st> <st c="24122">code
    repository.</st> <st c="24139">It does this by analyzing the dependencies listed
    in the manifest and locking files within</st> <st c="24230">each repository.</st>
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24011">依赖图提供了在 GitHub</st> <st c="24099">代码仓库中引用的直接和传递依赖的摘要。</st> <st
    c="24122">它通过分析每个仓库中清单文件和锁定文件中列出的依赖关系来实现这一点。</st>
- en: <st c="24246">As previously discussed, detecting dependencies through manifest
    file analysis has limitations, including noise from unused dependencies that are
    yet to be cleaned up and phantom dependencies that may be used in code but not
    listed in the manifest files.</st> <st c="24502">If you need a refresher on this,
    please see</st> *<st c="24546">The challenges of SCA tools</st>* <st c="24573">section
    of</st> [*<st c="24585">Chapter 4</st>*](B19710_04.xhtml#_idTextAnchor072)<st
    c="24594">.</st>
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24246">如前所述，通过清单文件分析检测依赖关系有其局限性，包括未清理的未使用依赖项带来的噪声以及可能在代码中使用但未在清单文件中列出的虚假依赖项。</st>
    <st c="24502">如果需要回顾此内容，请参见</st> *<st c="24546">SCA 工具的挑战</st>* <st c="24573">章节</st>
    [*<st c="24585">第 4 章</st>*](B19710_04.xhtml#_idTextAnchor072)<st c="24594">。</st>
- en: <st c="24595">At the time of writing, the dependency graph supports 14 package
    manager types across 13 languages.</st> <st c="24696">This includes NuGet (.NET),
    pip (Python), and npm (JavaScript).</st> <st c="24760">The full and current list
    is available</st> <st c="24799">at</st> [<st c="24802">https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph#supported-package-ecosystems</st>](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph#supported-package-ecosystems)<st
    c="24961">.</st>
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24595">截至写作时，依赖关系图支持 13 种语言中的 14 种包管理器类型。</st> <st c="24696">这包括 NuGet（.NET）、pip（Python）和
    npm（JavaScript）。</st> <st c="24760">完整且最新的列表可以在</st> <st c="24799">以下位置查看：</st>
    [<st c="24802">https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph#supported-package-ecosystems</st>](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph#supported-package-ecosystems)<st
    c="24961">。</st>
- en: <st c="24962">The dependency graph is automatically generated for all public
    repositories in a GitHub Enterprise organization.</st> <st c="25076">It can also
    be enabled for private and forked repositories either at the organization level
    or directly at the repository level.</st> <st c="25205">To enable it at the organization
    level, organization admins can navigate to</st> **<st c="25281">Organization</st>**
    <st c="25293">|</st> **<st c="25296">Settings</st>** <st c="25304">|</st> **<st
    c="25307">Security</st>** <st c="25315">|</st> **<st c="25318">Code security</st>**
    <st c="25331">|</st> **<st c="25334">Configurations</st>**<st c="25348">|</st>
    **<st c="25351">New Configuration</st>** <st c="25368">|</st> **<st c="25371">Dependency
    graph</st>**<st c="25387">:</st>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24962">依赖关系图会自动为 GitHub 企业版组织中的所有公共仓库生成。</st> <st c="25076">它也可以在组织级别或直接在仓库级别为私有仓库和派生仓库启用。</st>
    <st c="25205">要在组织级别启用，组织管理员可以导航到</st> **<st c="25281">组织</st>** <st c="25293">|</st>
    **<st c="25296">设置</st>** <st c="25304">|</st> **<st c="25307">安全</st>** <st c="25315">|</st>
    **<st c="25318">代码安全</st>** <st c="25331">|</st> **<st c="25334">配置</st>**<st
    c="25348">|</st> **<st c="25351">新建配置</st>** <st c="25368">|</st> **<st c="25371">依赖关系图</st>**<st
    c="25387">：</st>
- en: '![Figure 5.13 – Enabling the dependency graph for private repositories at the
    organization level](img/B19710_05_13.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.13 – 在组织级别为私有仓库启用依赖关系图](img/B19710_05_13.jpg)'
- en: <st c="25535">Figure 5.13 – Enabling the dependency graph for private repositories
    at the organization level</st>
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25535">图 5.13 – 在组织级别为私有仓库启用依赖关系图</st>
- en: <st c="25629">After creating a new code security configuration, we can apply
    it to individual repositories, all repositories, or repositories with no existing
    configuration by going to</st> **<st c="25801">Organization</st>** <st c="25813">|</st>
    **<st c="25816">Settings</st>** <st c="25824">|</st> **<st c="25827">Security</st>**
    <st c="25835">|</st> **<st c="25838">Code security</st>** <st c="25851">|</st>
    **<st c="25854">Configuration</st>** <st c="25867">and then choosing</st> **<st
    c="25886">Apply configuration</st>** <st c="25905">or</st> **<st c="25909">Apply
    to</st>**<st c="25917">:</st>
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25629">创建新的代码安全配置后，我们可以将其应用于单个仓库、所有仓库，或没有现有配置的仓库，方法是前往</st> **<st c="25801">组织</st>**
    <st c="25813">|</st> **<st c="25816">设置</st>** <st c="25824">|</st> **<st c="25827">安全</st>**
    <st c="25835">|</st> **<st c="25838">代码安全</st>** <st c="25851">|</st> **<st c="25854">配置</st>**
    <st c="25867">然后选择</st> **<st c="25886">应用配置</st>** <st c="25905">或</st> **<st
    c="25909">应用至</st>**<st c="25917">：</st>
- en: '![Figure 5.14 – Applying code security configuration to repositories](img/B19710_05_14.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.14 – 将代码安全配置应用于仓库](img/B19710_05_14.jpg)'
- en: <st c="26512">Figure 5.14 – Applying code security configuration to repositories</st>
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26512">图 5.14 – 将代码安全配置应用于仓库</st>
- en: <st c="26578">Once</st> <st c="26584">enabled, we can review</st> <st c="26607">discovered
    dependencies at the repository level by navigating to</st> **<st c="26672">Repository</st>**
    <st c="26682">|</st> **<st c="26685">Insights</st>** <st c="26693">|</st> **<st
    c="26696">Dependency graph</st>** <st c="26712">|</st> **<st c="26715">Dependencies</st>**<st
    c="26727">. At the organization level, we can do this by navigating to</st> **<st
    c="26788">Organization</st>** <st c="26800">|</st> **<st c="26803">Insights</st>**
    <st c="26811">|</st> **<st c="26814">Dependencies</st>**<st c="26826">:</st>
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26578">启用后，我们可以通过导航到</st> **<st c="26672">仓库</st>** <st c="26682">|</st>
    **<st c="26685">洞察</st>** <st c="26693">|</st> **<st c="26696">依赖图</st>** <st
    c="26712">|</st> **<st c="26715">依赖项</st>**<st c="26727">，在仓库级别查看发现的依赖项。在组织级别，我们可以通过导航到</st>
    **<st c="26788">组织</st>** <st c="26800">|</st> **<st c="26803">洞察</st>** <st c="26811">|</st>
    **<st c="26814">依赖项</st>**<st c="26826">：</st>
- en: '![Figure 5.15 – Reviewing dependency insights](img/B19710_05_15.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.15 – 审查依赖项洞察](img/B19710_05_15.jpg)'
- en: <st c="27333">Figure 5.15 – Reviewing dependency insights</st>
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27333">图 5.15 – 审查依赖项洞察</st>
- en: <st c="27376">For</st> <st c="27381">each dependency, we can</st> <st c="27405">review
    the license information and the vulnerability’s severity.</st> <st c="27470">We
    can also search for a specific dependency using the provided</st> <st c="27534">search
    bar.</st>
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27376">对于</st> <st c="27381">每个依赖项，我们可以</st> <st c="27405">查看许可证信息和漏洞的严重性。</st>
    <st c="27470">我们还可以通过提供的</st> <st c="27534">搜索框</st> <st c="27333">来搜索特定的依赖项。</st>
- en: <st c="27545">Note</st>
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27545">注意</st>
- en: <st c="27550">The dependency graph also has an API that can be used to submit
    project dependencies.</st> <st c="27637">This is typically used to submit dependencies
    that have not been identified by the standard process of scanning manifest and
    lock files.</st> <st c="27774">These could be dependencies referenced directly
    in code or those from unsupported manifest file types or languages.</st> <st c="27890">This
    way, the dependency graph will have a more accurate picture of the dependencies
    that are being used in the project.</st> <st c="28011">For more details on using
    the API, go</st> <st c="28049">to</st> [<st c="28052">https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/using-the-dependency-submission-api</st>](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/using-the-dependency-submission-api)<st
    c="28191">.</st>
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27550">依赖图还提供了一个 API，可以用来提交项目的依赖关系。</st> <st c="27637">通常用于提交未通过标准扫描清单和锁定文件流程识别的依赖项。</st>
    <st c="27774">这些可能是直接在代码中引用的依赖项，或来自不支持的清单文件类型或语言。</st> <st c="27890">通过这种方式，依赖图将能更准确地反映项目中使用的依赖项。</st>
    <st c="28011">有关如何使用 API 的更多信息，请访问</st> <st c="28049">这里</st> [<st c="28052">https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/using-the-dependency-submission-api</st>](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/using-the-dependency-submission-api)<st
    c="28191">。</st>
- en: <st c="28192">Recommendation 2 – Implementing dependency vulnerability assessment
    and management in source control</st>
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="28192">建议 2 – 在源代码控制中实施依赖漏洞评估和管理</st>
- en: <st c="28293">Identifying</st> <st c="28306">the packages that are used in our
    projects is an important first step.</st> <st c="28377">However, we also need</st>
    <st c="28399">to implement processes to detect vulnerabilities in the packages,
    prioritize the vulnerabilities, and automatically fix them when possible.</st>
    <st c="28539">This is important even if we have</st> <st c="28573">pre-commit
    checks in place, as discussed in the previous chapter.</st> <st c="28639">Pre-commit
    checks can be bypassed so that implementing a similar check</st> <st c="28710">in
    source control serves as another layer of security.</st> <st c="28765">Also, vulnerabilities
    are dynamic.</st> <st c="28800">A package that passed vulnerability checks during
    development might have new vulnerabilities that have been identified since then.</st>
    <st c="28931">Regularly performing dependency vulnerability checks in source control
    ensures we stay ahead of</st> <st c="29027">these issues.</st>
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="28293">识别</st> <st c="28306">我们项目中使用的包是一个重要的第一步。</st> <st c="28377">然而，我们还需要</st>
    <st c="28399">实施流程来检测包中的漏洞，优先处理这些漏洞，并在可能的情况下自动修复它们。</st> <st c="28539">即使我们已经有了</st>
    <st c="28573">预提交检查，如上一章所讨论的那样，这一点仍然很重要。</st> <st c="28639">预提交检查可以被绕过，因此在源代码管理中实施类似的检查</st>
    <st c="28710">可以作为另一层安全防护。</st> <st c="28765">此外，漏洞是动态变化的。</st> <st c="28800">一个在开发过程中通过了漏洞检查的包，可能会在之后被发现有新的漏洞。</st>
    <st c="28931">定期在源代码管理中进行依赖项漏洞检查，确保我们能够领先于</st> <st c="29027">这些问题。</st>
- en: <st c="29040">GitHub Enterprise offers features such as Dependabot alerts, Dependabot
    security updates, dependency version updates, and Dependabot auto-triage rules,
    which can address some of these needs, though there may be gaps and limitations.</st>
    <st c="29274">Unfortunately, these capabilities are not yet directly available
    in Azure DevOps, but various third-party SCA solutions exist that integrate directly
    with Azure Repos to implement similar functionalities.</st> <st c="29479">The
    main thing is that you have the processes implemented using the tools that fit
    your</st> <st c="29567">use cases.</st>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29040">GitHub Enterprise 提供了如 Dependabot 警报、Dependabot 安全更新、依赖项版本更新和
    Dependabot 自动分类规则等功能，可以解决其中的一些需求，尽管可能会有一些空白和限制。</st> <st c="29274">不幸的是，这些功能目前在
    Azure DevOps 中尚不可用，但有多种第三方 SCA 解决方案可以直接与 Azure Repos 集成，实现类似的功能。</st> <st c="29479">最重要的是，你需要使用适合你</st>
    <st c="29567">使用场景的工具来实施这些流程。</st>
- en: <st c="29577">Understanding and implementing Dependabot alerts in GitHub Enterprise</st>
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="29577">在 GitHub Enterprise 中理解和实现 Dependabot 警报</st>
- en: <st c="29647">Identifying</st> <st c="29660">packages in our</st> <st c="29676">projects
    with the dependency graph is an important first step.</st> <st c="29739">However,
    Dependabot takes this further by alerting and notifying us when vulnerabilities
    are detected in packages that have been identified.</st> <st c="29880">Dependabot
    offers three features for managing vulnerabilities in</st> <st c="29945">project
    dependencies:</st>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="29647">识别</st> <st c="29660">我们项目中的包使用依赖项图是一个重要的第一步。</st> <st c="29676">然而，Dependabot
    更进一步，通过在检测到已识别的包中存在漏洞时提醒并通知我们。</st> <st c="29739">Dependabot 提供了三种功能来管理项目依赖项中的漏洞：</st>
- en: '**<st c="29966">Dependabot alerts</st>**<st c="29984">: This</st> <st c="29992">feature</st>
    <st c="30000">generates alerts and notifications for vulnerabilities identified
    in our</st> <st c="30073">repository’s dependencies.</st>'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="29966">Dependabot 警报</st>**<st c="29984">：此</st> <st c="29992">功能</st>
    <st c="30000">会生成关于我们仓库依赖项中发现的漏洞的警报和通知。</st>'
- en: '**<st c="30099">Dependabot security updates</st>**<st c="30127">: This</st>
    <st c="30135">feature automatically creates pull requests to update dependencies</st>
    <st c="30202">with known</st> <st c="30213">security vulnerabilities.</st>'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="30099">Dependabot 安全更新</st>**<st c="30127">：此</st> <st c="30135">功能会自动创建拉取请求以更新具有已知</st>
    <st c="30202">安全漏洞的</st> <st c="30213">依赖项。</st>'
- en: '**<st c="30238">Dependabot version updates</st>**<st c="30265">: This</st>
    <st c="30273">feature</st> <st c="30281">automatically creates pull requests to
    update your dependencies to the</st> <st c="30352">latest versions.</st>'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="30238">Dependabot 版本更新</st>**<st c="30265">：此</st> <st c="30273">功能</st>
    <st c="30281">会自动创建拉取请求，以将你的依赖项更新到</st> <st c="30352">最新版本。</st>'
- en: <st c="30368">Note</st>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30368">注意</st>
- en: <st c="30373">Dependabot features require the dependency graph to</st> <st c="30426">be
    enabled.</st>
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="30373">Dependabot 功能需要启用依赖项图</st> <st c="30426">。</st>
- en: <st c="30437">To get</st> <st c="30445">notifications from Dependabot alerts,
    it must be enabled.</st> <st c="30503">You can do this at the enterprise, organization,
    or</st> <st c="30555">repository levels.</st> <st c="30574">To enable Dependabot
    alerts for future repositories, follow</st> <st c="30634">these steps:</st>
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要接收来自Dependabot警报的通知，必须启用该功能。您可以在企业、组织或仓库级别启用。要为未来的仓库启用Dependabot警报，请按照以下步骤操作：
- en: '**<st c="30646">Enterprise level</st>**<st c="30663">: Go to</st> **<st c="30672">Enterprise</st>**
    <st c="30682">|</st> **<st c="30685">Settings</st>** <st c="30693">|</st> **<st
    c="30696">Code security and analysis</st>** <st c="30722">|</st> **<st c="30725">Dependabot</st>**
    <st c="30735">|</st> **<st c="30738">Dependabot alerts</st>**<st c="30755">:</st>'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**企业级**：前往**企业** | **设置** | **代码安全与分析** | **Dependabot** | **Dependabot警报**：'
- en: <st c="30757">To enable it for all existing repositories, click on</st> **<st
    c="30810">Enable all</st>** <st c="30821">(</st>*<st c="30822">Figure 5</st>**<st
    c="30830">.16</st>*<st c="30833">).</st>
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要为所有现有仓库启用此功能，请点击**启用全部**（*图 5.16*）。
- en: <st c="30836">To automatically enable it for all new repositories that are created
    in your enterprise, toggle</st> **<st c="30933">Automatically enable for new</st>**
    **<st c="30962">repositories</st>** <st c="30974">on:</st>
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要为在您的企业中创建的所有新仓库自动启用此功能，请切换**自动为新** **仓库**启用：
- en: '![Figure 5.16 – Enabling Dependabot alerts at the organization level](img/B19710_05_16.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.16 – 在组织级别启用Dependabot警报](img/B19710_05_16.jpg)'
- en: <st c="31329">Figure 5.16 – Enabling Dependabot alerts at the organization level</st>
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.16 – 在组织级别启用Dependabot警报
- en: <st c="31395">To enable Dependabot alerts at the repository level, navigate
    to</st> **<st c="31461">Repository</st>** <st c="31471">|</st> **<st c="31474">Settings</st>**
    <st c="31482">|</st> **<st c="31485">Security</st>** <st c="31493">|</st> **<st
    c="31496">Code security and analysis</st>** <st c="31522">|</st> **<st c="31525">Dependabot</st>**
    <st c="31535">|</st> **<st c="31538">Dependabot alerts</st>** <st c="31555">|</st>
    **<st c="31558">Enable</st>**<st c="31564">.</st>
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在仓库级别启用Dependabot警报，请导航到**仓库** | **设置** | **安全性** | **代码安全与分析** | **Dependabot**
    | **Dependabot警报** | **启用**。
- en: <st c="31565">Once</st> **<st c="31571">Dependabot alerts</st>** <st c="31588">has
    been enabled, we can review the raised alerts at any</st> <st c="31646">of the
    scopes – enterprise, organization,</st> <st c="31688">and repository:</st>
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦**Dependabot警报**启用，我们可以在任意一个范围内审查触发的警报——企业、组织和仓库：
- en: <st c="31703">To</st> <st c="31707">review Dependabot alerts at the enterprise
    level, we can navigate to</st> **<st c="31776">Enterprise</st>** <st c="31786">|</st>
    **<st c="31789">Code Security</st>** <st c="31802">|</st> **<st c="31805">Dependabot
    alerts</st>**<st c="31822">.</st>
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在企业级别审查Dependabot警报，我们可以导航到**企业** | **代码安全** | **Dependabot警报**。
- en: <st c="31823">To review at the organization level, navigate to</st> **<st c="31873">Organization</st>**
    <st c="31885">|</st> **<st c="31888">Security</st>** <st c="31896">|</st> **<st
    c="31899">Alerts</st>** <st c="31905">|</st> **<st c="31908">Dependabot</st>**
    <st c="31918">(</st>*<st c="31920">Figure 5.17</st>*<st c="31931">):</st>
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在组织级别进行审查，请导航到**组织** | **安全性** | **警报** | **Dependabot**（*图 5.17*）：
- en: '![Figure 5.17 – Reviewing Dependabot alerts at the organization level](img/B19710_05_17.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.17 – 在组织级别审查Dependabot警报](img/B19710_05_17.jpg)'
- en: <st c="32466">Figure 5.17 – Reviewing Dependabot alerts at the organization
    level</st>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.17 – 在组织级别审查Dependabot警报
- en: <st c="32533">To review at the repository level, navigate to</st> **<st c="32581">Repository</st>**
    <st c="32591">|</st> **<st c="32594">Security</st>** <st c="32602">|</st> **<st
    c="32605">Vulnerability alerts</st>** <st c="32625">|</st> **<st c="32628">Dependabot</st>**<st
    c="32638">.</st>
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="32533">要在仓库级别进行审查，请导航到</st> **<st c="32581">仓库</st>** <st c="32591">|</st>
    **<st c="32594">安全</st>** <st c="32602">|</st> **<st c="32605">漏洞警报</st>** <st
    c="32625">|</st> **<st c="32628">Dependabot</st>**<st c="32638">。</st>
- en: <st c="32639">To review the status of Dependabot features (alerts, security
    updates, and more) across repositories in an enterprise or within an organization,
    we can navigate to</st> **<st c="32804">Enterprise</st>** <st c="32814">|</st>
    **<st c="32817">Code Security</st>** <st c="32830">|</st> **<st c="32833">Coverage</st>**
    *<st c="32841">or</st>* **<st c="32844">Organization</st>** <st c="32857">|</st>
    **<st c="32860">Security</st>** <st c="32868">|</st> **<st c="32871">Coverage</st>**
    <st c="32879">(</st>*<st c="32881">Figure 5</st>**<st c="32889">.18</st>*<st c="32892">):</st>
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="32639">要查看在企业或组织内跨多个仓库的 Dependabot 功能（警报、安全更新等）的状态，可以导航到</st> **<st c="32804">企业</st>**
    <st c="32814">|</st> **<st c="32817">代码安全</st>** <st c="32830">|</st> **<st c="32833">覆盖情况</st>**
    *<st c="32841">或</st>* **<st c="32844">组织</st>** <st c="32857">|</st> **<st c="32860">安全</st>**
    <st c="32868">|</st> **<st c="32871">覆盖情况</st>** <st c="32879">(</st>*<st c="32881">图
    5</st>**<st c="32889">.18</st>*<st c="32892">)：</st>
- en: '![Figure 5.18 – Reviewing Dependabot coverage in an organization](img/B19710_05_18.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.18 – 审查组织中的 Dependabot 覆盖情况](img/B19710_05_18.jpg)'
- en: <st c="34034">Figure 5.18 – Reviewing Dependabot coverage in an organization</st>
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34034">图 5.18 – 审查组织中的 Dependabot 覆盖情况</st>
- en: <st c="34096">Understanding vulnerability prioritization</st>
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="34096">理解漏洞优先级排序</st>
- en: <st c="34139">Simply identifying vulnerabilities does not fix them.</st> <st
    c="34194">Surfacing a scan report with a list of unprioritized</st> <st c="34247">vulnerabilities
    to the engineering team and instructing them to</st> *<st c="34311">fix these
    issues urgently</st>* <st c="34336">is not an effective security strategy and
    will not work in a DevSecOps framework.</st> <st c="34419">It is also not practical
    to “</st>*<st c="34448">just focus on all critical and high vulnerabilities</st>*<st
    c="34500">” as this is usually a high number.</st> <st c="34537">According to</st>
    [<st c="34550">https://www.cvedetails.com/</st>](https://www.cvedetails.com/)<st
    c="34577">, 55% of CVEs have a CVSS score of 7</st> <st c="34614">and above.</st>
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34139">仅仅识别漏洞并不能解决它们。</st> <st c="34194">将未经优先排序的漏洞扫描报告呈现给工程团队，并指示他们</st>
    *<st c="34311">紧急修复这些问题</st>* <st c="34336">并不是一种有效的安全策略，在 DevSecOps 框架下也无法奏效。</st>
    <st c="34419">同样，" </st>*<st c="34448">只关注所有关键性和高危漏洞</st>*<st c="34500">" 这种做法也不可行，因为通常这些漏洞数量较多。</st>
    <st c="34537">根据</st> [<st c="34550">https://www.cvedetails.com/</st>](https://www.cvedetails.com/)<st
    c="34577">，55%的CVE的CVSS评分为7分及以上。</st>
- en: <st c="34624">When a vulnerability is identified in an OSS package in your software
    stack, it is important to perform a risk assessment to determine if it poses a
    real threat.</st> <st c="34787">This assessment should guide how developers prioritize
    fixing the issue.</st> <st c="34860">However, accurate prioritization often depends
    on a deep understanding of the environment where the software operates and its
    interaction with other components.</st> <st c="35021">This information might be
    limited in the early, pre-commit stage of development, making it challenging to
    fully assess the impact and urgency of</st> <st c="35166">a vulnerability.</st>
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="34624">当在软件堆栈中的开源软件包（OSS）中发现漏洞时，进行风险评估是很重要的，以确定该漏洞是否构成真实威胁。</st> <st
    c="34787">此评估应指导开发人员如何优先处理该问题。</st> <st c="34860">然而，准确的优先级排序通常依赖于对软件运行环境及其与其他组件交互的深入理解。</st>
    <st c="35021">在开发的早期、提交前阶段，这些信息可能是有限的，因此很难全面评估漏洞的影响和紧迫性。</st>
- en: <st c="35182">In a DevSecOps workflow, where speed is a critical factor, this
    risk assessment should be quick and, preferably, automated.</st> <st c="35307">This
    is where the value of a good SCA tool becomes evident.</st> <st c="35367">A good
    SCA tool does more than just identify vulnerabilities; it should also provide
    a meaningful risk assessment to help developers prioritize what should be fixed
    before proceeding, even with the limited context available at this early stage.</st>
    <st c="35612">There are several methods that SCA tools use in prioritizing risks
    of discovered vulnerabilities in this phase.</st> <st c="35724">We’ll provide
    a summary of some of these methods and the value that they</st> <st c="35797">provide
    next.</st>
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35182">在一个DevSecOps工作流中，速度是一个关键因素，因此此风险评估应该是快速的，并且最好是自动化的。</st> <st c="35307">这就是一个好的SCA工具价值所在。</st>
    <st c="35367">一个好的SCA工具不仅仅是识别漏洞；它还应该提供有意义的风险评估，帮助开发人员在继续之前优先处理需要修复的部分，即使在此早期阶段上下文信息有限。</st>
    <st c="35612">SCA工具在此阶段优先排序已发现漏洞的风险时使用了几种方法。</st> <st c="35724">接下来，我们将总结一些这些方法及其所提供的价值。</st>
    <st c="35797">提供的价值如下。</st>
- en: <st c="35810">Understanding vulnerability severity scoring</st>
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="35810">理解漏洞严重性评分</st>
- en: <st c="35855">Severity</st> <st c="35865">scoring methods provide standardized
    ways to evaluate the impact and urgency of known vulnerabilities.</st> <st c="35968">The
    most widely used framework is the</st> **<st c="36006">Common Vulnerability Scoring
    System</st>** <st c="36041">(</st>**<st c="36043">CVSS</st>**<st c="36047">) version
    3.1\.</st> <st c="36063">It assigns</st> <st c="36074">scores to vulnerabilities
    based on various metric groups (base score metrics, temporal score metrics, and
    environmental score metrics).</st> <st c="36210">The base score metric (which
    is the most widely used) measures the technical severity of a vulnerability,</st>
    <st c="36316">not risk.</st>
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35855">严重性</st> <st c="35865">评分方法提供了评估已知漏洞影响和紧急性的标准化方式。</st> <st c="35968">最广泛使用的框架是**<st
    c="36006">Common Vulnerability Scoring System</st>** <st c="36041">(**<st c="36043">CVSS</st>**<st
    c="36047">)版本3.1。</st> <st c="36063">它根据不同的指标组（基本评分指标、时间评分指标和环境评分指标）为漏洞分配分数。</st>
    <st c="36210">基本评分指标（最广泛使用的指标）衡量漏洞的技术严重性，</st> <st c="36316">而不是风险。</st>
- en: <st c="36325">However, one limitation of the CVSS 3.1 framework’s base score
    metrics is its focus on technical severity rather than the actual risk of exploitation.</st>
    <st c="36477">For example, only 10% of vulnerabilities in open source libraries
    are exploitable.</st> <st c="36560">Why should your developers spend valuable
    time focusing on vulnerabilities that are not exploitable?</st> <st c="36661">This
    is where newer</st> <st c="36681">scoring methods such as the</st> **<st c="36709">Exploit
    Prediction Scoring System</st>** <st c="36742">(</st>**<st c="36744">EPSS</st>**<st
    c="36748">) become valuable.</st> <st c="36768">EPSS aims to predict the likelihood
    of a vulnerability being exploited, drawing on various data sources such as cybersecurity
    advisories, social media, and public mentions.</st> <st c="36941">This prediction
    is vital because two vulnerabilities with identical CVSS scores might differ significantly
    in their real-world exploitation likelihood.</st> <st c="37093">Prioritizing remediation
    based on EPSS can be more effective in managing</st> <st c="37166">actual risks.</st>
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="36325">然而，CVSS 3.1框架的基本评分指标有一个局限性，即它侧重于技术严重性，而非实际的利用风险。</st> <st c="36477">例如，开源库中只有10%的漏洞是可被利用的。</st>
    <st c="36560">为什么开发人员要花费宝贵的时间关注那些不可利用的漏洞呢？</st> <st c="36661">这就是为什么像**<st c="36709">Exploit
    Prediction Scoring System</st>** <st c="36742">(**<st c="36744">EPSS</st>**<st
    c="36748">)这样更新的评分方法变得有价值。</st> <st c="36768">EPSS旨在预测漏洞被利用的可能性，依托于各种数据源，如网络安全建议、社交媒体和公开提及。</st>
    <st c="36941">这一预测至关重要，因为两个具有相同CVSS分数的漏洞，在实际被利用的可能性上可能会有显著差异。</st> <st c="37093">基于EPSS优先进行修复工作，在管理实际风险方面可能更为有效。</st>
    <st c="37166">实际风险。</st>
- en: <st c="37179">In practice, combining CVSS and EPSS offers a comprehensive approach
    to vulnerability prioritization.</st> <st c="37282">While CVSS provides a baseline
    understanding of severity, EPSS adds the dimension of exploit likelihood.</st>
    <st c="37387">This dual perspective helps developers determine what’s important
    to address before proceeding with</st> <st c="37487">their commits.</st>
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37179">实际上，结合CVSS和EPSS提供了一种全面的漏洞优先排序方法。</st> <st c="37282">虽然CVSS提供了严重性的基准理解，EPSS则增加了漏洞被利用可能性的维度。</st>
    <st c="37387">这种双重视角帮助开发人员在继续提交之前，确定需要优先处理的事项。</st> <st c="37487">他们的提交。</st>
- en: <st c="37501">Understanding dependency path analysis and vulnerability context
    analysis</st>
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="37501">理解依赖路径分析和漏洞上下文分析</st>
- en: <st c="37575">While CVSS</st> <st c="37587">and EPSS provide a solid starting
    point for prioritizing</st> <st c="37644">vulnerabilities, they should be part
    of a larger strategy.</st> <st c="37703">CVSS and EPSS help score security vulnerabilities,
    but they both focus on innate and external attributes of the OSS package vulnerabilities
    without considering if the vulnerable functions are used in your code or how they
    are used.</st> <st c="37935">For example, many of the open source packages that
    developers import may not be used in the final application, thereby posing no
    immediate risk of being exploited.</st> <st c="38099">However, vulnerability ranking
    scores do not capture or account</st> <st c="38163">for this.</st>
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="37575">虽然 CVSS</st> <st c="37587">和 EPSS 提供了一个可靠的起点来优先排序</st> <st c="37644">漏洞，但它们应当作为更大策略的一部分。</st>
    <st c="37703">CVSS 和 EPSS 帮助对安全漏洞进行评分，但它们都侧重于开源软件包漏洞的内在和外部属性，而没有考虑这些脆弱功能是否在您的代码中被使用，或如何被使用。</st>
    <st c="37935">例如，许多开发者导入的开源包可能在最终的应用中没有被使用，从而不会立即构成被利用的风险。</st> <st c="38099">然而，漏洞排名分数并没有捕捉或考虑到这一点。</st>
- en: <st c="38172">So, even if EPSS scores a vulnerability as likely to be exploited
    and CVSS scores it as critical, it might not matter if your code does not call
    the vulnerable functions.</st> <st c="38344">Without this prioritization technique,
    developers could end up spending too much time fixing vulnerabilities that may
    not be exploitable in the context of</st> <st c="38499">your code.</st>
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38172">所以，即使 EPSS 将漏洞评分为可能被利用，而 CVSS 将其评分为严重漏洞，如果您的代码没有调用脆弱的功能，这可能并不重要。</st>
    <st c="38344">没有这种优先排序技术，开发者可能会花费过多时间修复那些在</st> <st c="38499">您的代码上下文中无法被利用的漏洞。</st>
- en: <st c="38509">Both dependency path analysis and vulnerability context analysis
    are advanced techniques for prioritizing vulnerabilities based on the specific
    ways your software project uses the vulnerable OSS package.</st> <st c="38714">Here’s
    how</st> <st c="38725">they work:</st>
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="38509">依赖路径分析和漏洞上下文分析都是基于您的软件项目如何使用脆弱的开源软件包来优先排序漏洞的高级技术。</st> <st c="38714">它们的工作原理如下：</st>
    <st c="38725">它们是如何工作的：</st>
- en: '**<st c="38735">Dependency path analysis</st>**<st c="38760">: This method
    examines the dependency tree of your</st> <st c="38812">project.</st> <st c="38821">The
    dependency tree is a map of how different software components (such as libraries
    and packages) are connected and depend on each other in your application.</st>
    <st c="38980">By analyzing this tree, you can see how a vulnerable component fits
    into your overall</st> <st c="39066">application structure.</st>'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="38735">依赖路径分析</st>**<st c="38760">：该方法检查您的项目的依赖树。</st> <st c="38812">依赖树是一个展示不同软件组件（如库和包）如何在您的应用中相互连接和依赖的图谱。</st>
    <st c="38821">通过分析这棵树，您可以看到一个脆弱组件如何融入到整个</st> <st c="39066">应用结构中。</st>'
- en: '**<st c="39088">Understanding vulnerability pathways</st>**<st c="39125">:
    This part of the analysis looks at the potential</st> <st c="39177">routes through
    which a vulnerability could be exploited.</st> <st c="39234">It is like tracing
    the paths an attacker could take through the interconnected components of</st>
    <st c="39327">your software.</st>'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="39088">了解漏洞路径</st>**<st c="39125">：这部分分析查看漏洞可能被利用的路径。</st> <st c="39177">它就像是追踪攻击者可能通过互联组件进入</st>
    <st c="39327">您的软件的路径。</st>'
- en: '**<st c="39341">Vulnerability context analysis</st>**<st c="39372">: This step
    goes deeper into the specifics of a vulnerability.</st> <st c="39436">It</st>
    <st c="39439">considers where in your code base the vulnerability is located,
    which functions are affected, and how your application uses the vulnerable component.</st>
    <st c="39589">This context is crucial because a vulnerability in a part of the
    code that’s never used or executed might not be a</st> <st c="39704">real threat.</st>'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="39341">漏洞上下文分析</st>**<st c="39372">：这一步骤深入到漏洞的具体细节。</st> <st c="39436">它</st>
    <st c="39439">考虑到漏洞在代码库中的位置、哪些函数受影响，以及您的应用如何使用该脆弱组件。</st> <st c="39589">这个上下文非常重要，因为代码中某部分的漏洞如果从未被使用或执行，可能就不会构成</st>
    <st c="39704">真正的威胁。</st>'
- en: '**<st c="39716">Impact assessment</st>**<st c="39734">: After</st> <st c="39743">analyzing
    both the dependency paths and the context, you get a clear picture of whether
    a vulnerability is just theoretically dangerous or a real, practical risk in</st>
    <st c="39908">your application.</st>'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**<st c="39716">影响评估</st>**<st c="39734">：在分析了依赖路径和上下文之后，你能清楚地了解漏洞是否仅仅是理论上危险，还是在</st>
    <st c="39908">你的应用程序中实际存在的风险。</st>'
- en: <st c="39925">The main thing to watch out for is that many SCA tools (including
    Dependabot) haven’t implemented these techniques as they can be complex and time-consuming,
    especially in large projects with many dependencies.</st> <st c="40137">An example
    of a vendor implementation of this prioritization</st> <st c="40198">technique
    is the</st> *<st c="40215">reachability analysis</st>* <st c="40236">method used
    by</st> <st c="40252">Endor Labs.</st>
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="39925">需要注意的主要问题是，许多SCA工具（包括Dependabot）并未实现这些技术，因为它们可能复杂且耗时，尤其是在依赖关系多的大型项目中。</st>
    <st c="40137">一种供应商实现这种优先级排序技术的例子是</st> *<st c="40215">可达性分析</st>* <st c="40236">方法，Endor
    Labs就使用了这种方法。</st>
- en: <st c="40263">No matter which combination of techniques your tools use, we cannot
    emphasize enough the importance of working with your development team to ensure
    this process is as smooth as possible.</st> <st c="40451">Ideally, your SCA tool
    or process should focus on clearly presenting the prioritized risks that need
    fixing to your development team, without overloading them with unnecessary information.</st>
    <st c="40640">The prioritized risks need to be aligned with your organization’s
    risk appetite and balance the impact of fixing vulnerabilities on</st> <st c="40772">developer
    productivity.</st>
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40263">无论你的工具使用哪种技术组合，我们都不能过分强调与开发团队合作的重要性，以确保这一过程尽可能顺利。</st> <st c="40451">理想情况下，你的SCA工具或流程应专注于清晰地向开发团队呈现需要修复的优先级风险，而不会因为不必要的信息而使他们不堪重负。</st>
    <st c="40640">这些优先级风险需要与你组织的风险承受度相一致，并平衡修复漏洞对</st> <st c="40772">开发者生产力的影响。</st>
- en: <st c="40795">Fixing prioritized vulnerabilities</st>
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="40795">修复优先级漏洞</st>
- en: <st c="40830">When a vulnerability is identified as high/critical by CVSS, exploitable
    by EPSS, and further</st> <st c="40925">analysis confirms that the vulnerable
    function is called in the code, the next step is for developers to fix it and
    then recommit the code.</st> <st c="41065">This depends on the availability of
    an official fix.</st> <st c="41118">Most SCA tools will highlight this as part
    of the scan result.</st> <st c="41181">They will even highlight the version of
    the package that has the security fix.</st> <st c="41260">If an official fix is
    available, the development team can upgrade their package to the new version with
    the security fix (</st>*<st c="41382">Figure 5</st>**<st c="41391">.19</st>*<st
    c="41394">):</st>
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="40830">当一个漏洞被CVSS评定为高危/严重漏洞，EPSS评估为可利用，且进一步</st> <st c="40925">分析确认该漏洞的函数在代码中被调用时，下一步是开发人员修复漏洞并重新提交代码。</st>
    <st c="41065">这取决于是否有官方修复。</st> <st c="41118">大多数SCA工具会在扫描结果中突出显示这一点。</st> <st
    c="41181">它们甚至会突出显示包含安全修复的包版本。</st> <st c="41260">如果有官方修复，开发团队可以将其包升级到带有安全修复的新版本（</st>*<st
    c="41382">图 5</st>**<st c="41391">.19</st>*<st c="41394">）：</st>
- en: '![Figure 5.19 – Decision-making on fixing prioritized vulnerabilities](img/B19710_05_19.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.19 – 修复优先级漏洞的决策过程](img/B19710_05_19.jpg)'
- en: <st c="41761">Figure 5.19 – Decision-making on fixing prioritized vulnerabilities</st>
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41761">图 5.19 – 修复优先级漏洞的决策过程</st>
- en: <st c="41828">However, this new version might bring its own set of issues, such
    as bugs, compatibility problems, performance degradation, or even new vulnerabilities.</st>
    <st c="41982">This can lead to unexpected</st> <st c="42010">behavior in previously
    stable code.</st> <st c="42046">Therefore, it is important to perform basic automated
    build tests before</st> <st c="42119">applying it.</st>
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41828">然而，这个新版本可能会带来一系列问题，比如错误、兼容性问题、性能下降，甚至新的漏洞。</st> <st c="41982">这可能导致之前稳定的代码出现意外</st>
    <st c="42010">行为。</st> <st c="42046">因此，在应用新版本之前，进行基本的自动化构建测试是很重要的。</st>
- en: <st c="42131">On the other hand, if there is no official fix, your approach
    depends on whether the OSS package is</st> <st c="42232">still maintained:</st>
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="42131">另一方面，如果没有官方修复，你的处理方式取决于OSS包是否</st> <st c="42232">仍在维护：</st>
- en: '**<st c="42249">For maintained packages</st>**<st c="42273">: It is important
    to get the guidance of the project maintainers.</st> <st c="42340">They might
    offer an estimated timeline for a fix or recommend temporary measures to mitigate
    the vulnerability.</st> <st c="42452">In this case, the developers can flag this
    as a work item and carry on with</st> <st c="42528">their work.</st>'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="42249">对于仍在维护的包</st>**<st c="42273">：获取项目维护者的指导非常重要。</st> <st c="42340">他们可能会提供修复的预计时间表，或建议采取临时措施来缓解安全漏洞。</st>
    <st c="42452">在这种情况下，开发者可以将其标记为工作项，并继续</st> <st c="42528">进行其他工作。</st>'
- en: '**<st c="42539">For unmaintained packages</st>**<st c="42565">: This situation
    is trickier.</st> <st c="42596">Without an expected update from the original developers,
    you have</st> <st c="42662">several options:</st>'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="42539">对于不再维护的包</st>**<st c="42565">：这种情况更为棘手。</st> <st c="42596">如果原开发者没有提供预期的更新，你有</st>
    <st c="42662">几种选择：</st>'
- en: '**<st c="42678">Fork the dependency</st>**<st c="42698">: You can create and
    maintain your own version of the dependency, applying necessary security fixes.</st>
    <st c="42800">However, this requires</st> <st c="42823">continuous maintenance.</st>'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="42678">分叉依赖</st>**<st c="42698">：你可以创建并维护自己的依赖版本，应用必要的安全修复。</st> <st
    c="42800">然而，这需要</st> <st c="42823">持续的维护。</st>'
- en: '**<st c="42846">Mitigate the risk</st>**<st c="42864">: Seek</st> <st c="42872">alternatives
    to mitigate the risk without updating</st> <st c="42923">the library.</st>'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="42846">缓解风险</st>**<st c="42864">：寻求不更新</st> <st c="42872">库的替代方案以降低风险。</st>'
- en: '**<st c="42935">Replace the dependency</st>**<st c="42958">: Find and switch
    to an actively maintained alternative.</st> <st c="43016">Relying on an unmaintained
    component in your code base is typically not a viable</st> <st c="43097">long-term
    strategy.</st>'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="42935">替换依赖</st>**<st c="42958">：寻找并切换到一个积极维护的替代品。</st> <st c="43016">依赖一个不再维护的组件通常不是一个可行的</st>
    <st c="43097">长期策略。</st>'
- en: <st c="43116">Understanding and implementing Dependabot security and version
    updates in GitHub Enterprise</st>
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="43116">在 GitHub Enterprise 中理解并实现 Dependabot 安全与版本更新</st>
- en: <st c="43208">Earlier in this chapter, we discussed how to implement Dependabot
    alerts to get notifications</st> <st c="43303">of vulnerabilities in packages
    that are used in our projects.</st> <st c="43365">For each alert, we can manually
    create a Dependabot security update pull request (</st>*<st c="43447">Figure 5</st>**<st
    c="43456">.20</st>*<st c="43459">).</st> <st c="43463">This action generates a
    pull request that triggers a GitHub Actions workflow.</st> <st c="43541">The workflow
    tests the patched package version against our code base to confirm compatibility
    before merging.</st> <st c="43651">While this is a good feature, having to manually
    manage this for multiple packages in a project can be a drain on developer productivity
    and cause friction in the development process.</st> <st c="43835">This is where
    the other features of Dependabot come in –</st> **<st c="43892">Dependabot security
    updates</st>** <st c="43919">and</st> **<st c="43924">Dependabot</st>** **<st
    c="43935">version updates</st>**<st c="43950">:</st>
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43208">在本章前面，我们讨论了如何实现 Dependabot 警报，以获取项目中所用包的漏洞通知。</st> <st c="43303">对于每个警报，我们可以手动创建一个
    Dependabot 安全更新拉取请求（</st>*<st c="43447">图 5</st>**<st c="43456">.20</st>*<st c="43459">）。</st>
    <st c="43463">此操作会生成一个拉取请求，并触发 GitHub Actions 工作流。</st> <st c="43541">该工作流会测试修补后的包版本与我们的代码库的兼容性，确保合并前无问题。</st>
    <st c="43651">虽然这是一个不错的功能，但需要手动管理项目中多个包的更新可能会拖慢开发效率，并且给开发过程带来摩擦。</st> <st c="43835">这时，Dependabot
    的其他功能就派上用场了——</st> **<st c="43892">Dependabot 安全更新</st>** <st c="43919">和</st>
    **<st c="43924">Dependabot</st>** **<st c="43935">版本更新</st>**<st c="43950">：</st>
- en: '![Figure 5.20 – Manually creating a Dependabot security update pull request](img/B19710_05_20.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.20 – 手动创建 Dependabot 安全更新拉取请求](img/B19710_05_20.jpg)'
- en: <st c="44334">Figure 5.20 – Manually creating a Dependabot security update pull
    request</st>
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="44334">图 5.20 – 手动创建 Dependabot 安全更新拉取请求</st>
- en: '**<st c="44407">Dependabot security updates</st>** <st c="44435">can automate
    this process for us by automatically creating</st> <st c="44495">pull requests
    to update dependencies with known security vulnerabilities.</st> <st c="44569">To
    enable this feature at the repository level, navigate to</st> **<st c="44629">Repository</st>**
    <st c="44639">|</st> **<st c="44642">Settings</st>** <st c="44650">|</st> **<st
    c="44653">Code security and analysis</st>** <st c="44679">|</st> **<st c="44682">Dependabot
    security updates</st>** <st c="44709">|</st> **<st c="44712">Enable all</st>**<st
    c="44722">:</st>'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="44407">Dependabot 安全更新</st>** <st c="44435">可以通过自动创建</st> <st c="44495">拉取请求来更新具有已知安全漏洞的依赖项，从而自动化这一过程。</st>
    <st c="44569">要在仓库级别启用此功能，请导航到</st> **<st c="44629">仓库</st>** <st c="44639">|</st>
    **<st c="44642">设置</st>** <st c="44650">|</st> **<st c="44653">代码安全与分析</st>**
    <st c="44679">|</st> **<st c="44682">Dependabot 安全更新</st>** <st c="44709">|</st>
    **<st c="44712">启用所有</st>**<st c="44722">:</st>'
- en: '![Figure 5.21 – Enabling Dependabot security updates at the organization level](img/B19710_05_21.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.21 – 在组织级别启用 Dependabot 安全更新](img/B19710_05_21.jpg)'
- en: <st c="45079">Figure 5.21 – Enabling Dependabot security updates at the organization
    level</st>
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45079">图 5.21 – 在组织级别启用 Dependabot 安全更新</st>
- en: '**<st c="45155">Dependabot version updates</st>** <st c="45182">can take this
    further by automatically creating pull requests to update dependencies even if
    they don’t have security vulnerabilities.</st> <st c="45318">To enable this feature,
    navigate to</st> **<st c="45354">Repository</st>** <st c="45364">|</st> **<st
    c="45367">Settings</st>** <st c="45375">|</st> **<st c="45378">Security</st>**
    <st c="45386">|</st> **<st c="45389">Code security and analysis</st>** <st c="45415">|</st>
    **<st c="45418">Dependabot version updates</st>** <st c="45444">|</st> **<st c="45447">Enable
    all</st>**<st c="45457">.</st>'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**<st c="45155">Dependabot 版本更新</st>** <st c="45182">可以进一步通过自动创建拉取请求来更新依赖项，即使它们没有安全漏洞。</st>
    <st c="45318">要启用此功能，请导航到</st> **<st c="45354">仓库</st>** <st c="45364">|</st>
    **<st c="45367">设置</st>** <st c="45375">|</st> **<st c="45378">安全</st>** <st c="45386">|</st>
    **<st c="45389">代码安全与分析</st>** <st c="45415">|</st> **<st c="45418">Dependabot
    版本更新</st>** <st c="45444">|</st> **<st c="45447">启用所有</st>**<st c="45457">。</st>'
- en: <st c="45458">Recommendation 3 – Implementing an open source license compliance
    scan</st>
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="45458">建议 3 – 实施开源许可证合规扫描</st>
- en: <st c="45529">Open source licensing is a critical aspect of any software project.</st>
    <st c="45598">When open source packages</st> <st c="45624">are used in your projects,
    it is a good practice to regularly assess their license risk rating.</st> <st
    c="45720">This rating should consider the impact of the package’s license terms
    on your organization’s compliance, intellectual property, and exclusive rights.</st>
    <st c="45870">You can rate the risk from LOW to HIGH, with a HIGH risk indicating
    a potential impact on your organization’s compliance.</st> <st c="45992">As mentioned
    earlier, the dependency graph displays the license information for each identified
    dependency but to enforce specific license types, we need to implement</st> **<st
    c="46159">Dependency Review Action</st>**<st c="46183">. We will cover this in
    the next chapter when we discuss how to implement security in the BUILD and TEST
    phases of DevOps.</st> <st c="46306">For now, let’s examine various open source
    license categories and their governing rules.</st> *<st c="46395">Figure 5</st>**<st
    c="46403">.22</st>* <st c="46406">shows a spectrum of open</st> <st c="46432">source
    licenses:</st>
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="45529">开源许可证是任何软件项目中的一个关键方面。</st> <st c="45598">当在你的项目中使用开源软件包时，定期评估它们的许可证风险等级是一种良好的做法。</st>
    <st c="45624">这个风险等级应考虑包的许可证条款对你组织合规性、知识产权和独占权的影响。</st> <st c="45720">你可以将风险从低到高进行评级，高风险意味着可能对你组织的合规性产生影响。</st>
    <st c="45870">如前所述，依赖图显示了每个已识别依赖项的许可证信息，但为了强制执行特定类型的许可证，我们需要实施</st> **<st c="46159">依赖审查操作</st>**<st
    c="46183">。我们将在下一章中讨论如何在 DevOps 的构建和测试阶段实现安全性时介绍这一点。</st> <st c="46306">现在，让我们来看看各种开源许可证类别及其管理规则。</st>
    *<st c="46395">图 5</st>**<st c="46403">.22</st>* <st c="46406">展示了一个开源许可证的范围：</st>
- en: '![Figure 5.22 – Open source license categories](img/B19710_05_22.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.22 – 开源许可证类别](img/B19710_05_22.jpg)'
- en: <st c="46547">Figure 5.22 – Open source license categories</st>
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46547">图 5.22 – 开源许可证类别</st>
- en: <st c="46591">On the left, we have</st> **<st c="46613">attribution</st>** <st
    c="46624">licenses, which are more permissive, while on the right, we have</st>
    **<st c="46690">copyleft</st>** <st c="46698">licenses, which are more restrictive.</st>
    <st c="46737">Let’s explore these license types in</st> <st c="46774">more detail:</st>
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="46591">左侧是</st> **<st c="46613">署名</st>** <st c="46624">许可证，它们更为宽松；而右侧是</st>
    **<st c="46690">copyleft</st>** <st c="46698">许可证，它们更为严格。</st> <st c="46737">让我们更详细地探索这些许可证类型：</st>
- en: '**<st c="46786">Attribution licenses</st>**<st c="46807">: These</st> <st c="46816">are
    very flexible.</st> <st c="46835">We are allowed to use the library for any purpose,
    including commercial software.</st> <st c="46917">The main requirement is to give
    credit to the original package creator.</st> <st c="46989">This type of license
    generally poses a</st> **<st c="47028">low risk</st>** <st c="47036">in terms
    of compliance and intellectual property rights.</st> <st c="47094">It is worth
    noting that not all permissive licenses are merely attribution licenses.</st>
    <st c="47179">For example, the MIT License and the Apache License are permissive
    but include additional terms beyond</st> <st c="47282">simple attribution.</st>'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="46786">署名许可证</st>**<st c="46807">：这些</st> <st c="46816">许可证非常灵活。</st>
    <st c="46835">我们可以将库用于任何目的，包括商业软件。</st> <st c="46917">主要要求是给予原始包创建者署名。</st> <st
    c="46989">这种类型的许可证在合规性和知识产权方面通常具有</st> **<st c="47028">较低的风险</st>** <st c="47036">。</st>
    <st c="47094">值得注意的是，并非所有的宽松许可证仅仅是署名许可证。</st> <st c="47179">例如，MIT 许可证和 Apache
    许可证是宽松的，但它们包含了比简单署名更多的额外条款。</st>'
- en: '**<st c="47301">Copyleft licenses</st>**<st c="47319">: These are more restrictive.</st>
    <st c="47350">You can only use these libraries in projects</st> <st c="47395">that
    have the same license terms.</st> <st c="47429">This can be tricky for commercial
    software.</st> <st c="47473">They are often called “viral” licenses because they
    can</st> <st c="47529">extend their terms to other software components used in
    your project.</st> <st c="47599">The GNU</st> **<st c="47607">General Public License</st>**
    <st c="47629">(</st>**<st c="47631">GPL</st>**<st c="47634">) is a well-known
    example.</st> <st c="47662">If you implement a package with the GPL license, any
    derived work must also be distributed under the GPL license terms.</st> <st c="47782">This
    ensures that the freedoms of the GPL are maintained in all derivative works.</st>
    <st c="47864">These licenses</st> <st c="47879">typically have a</st> **<st c="47896">high
    risk rating</st>** <st c="47912">due to their potential impact on compliance,
    intellectual property, and</st> <st c="47985">exclusive rights.</st>'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="47301">Copyleft 许可证</st>**<st c="47319">：这些许可证更加严格。</st> <st c="47350">你只能在具有相同许可证条款的项目中使用这些库。</st>
    <st c="47395">这对于商业软件来说可能会很棘手。</st> <st c="47429">它们通常被称为“病毒”许可证，因为它们可以</st> <st
    c="47529">将条款扩展到你项目中使用的其他软件组件。</st> <st c="47599">GNU</st> **<st c="47607">通用公共许可证</st>**
    <st c="47629">(</st>**<st c="47631">GPL</st>**<st c="47634">) 就是一个著名的例子。</st>
    <st c="47662">如果你实现了一个使用 GPL 许可证的软件包，那么任何派生作品也必须在 GPL 许可证条款下分发。</st> <st c="47782">这确保了
    GPL 的自由在所有派生作品中得以保持。</st> <st c="47864">这些许可证</st> <st c="47879">通常具有</st> **<st
    c="47896">较高的风险评级</st>** <st c="47912">，因为它们可能对合规性、知识产权和</st> <st c="47985">独占权产生影响。</st>'
- en: '**<st c="48002">Downstream or weak copyleft licenses</st>**<st c="48039">:
    These are a middle ground.</st> <st c="48069">They are more permissive than the
    strong copyleft licenses.</st> <st c="48129">Unlike the copyleft licenses, they</st>
    *<st c="48164">do not</st>* <st c="48170">require that the entire derived project
    carry the same license</st> <st c="48234">terms.</st> <st c="48241">A common example
    is the GNU</st> **<st c="48269">Lesser General Public License</st>** <st c="48298">(</st>**<st
    c="48300">LGPL</st>**<st c="48304">).</st> <st c="48308">Unlike the GPL, LGPL
    lets you link libraries with non-LGPL software without having to license the entire
    combined work under LGPL.</st> <st c="48439">However, any changes to the LGPL-licensed
    component must be released under LGPL.</st> <st c="48520">This makes LGPL more
    suitable for mixing with proprietary software, while still keeping improvements
    to the LGPL component open.</st> <st c="48649">These</st> <st c="48655">licenses
    have a</st> **<st c="48671">moderate risk rating</st>** <st c="48691">as they
    are more permissive for proprietary integration but still ensure openness for
    the</st> <st c="48782">LGPL-licensed components.</st>'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="48002">下游或弱复制左许可证</st>**<st c="48039">：这些是中间地带。</st> <st c="48069">它们比强复制左许可证更宽松。</st>
    <st c="48129">与复制左许可证不同，它们</st> *<st c="48164">不</st>* <st c="48170">要求整个衍生项目采用相同的许可证</st>
    <st c="48234">条款。</st> <st c="48241">一个常见的例子是 GNU</st> **<st c="48269">较宽松通用公共许可证</st>**
    <st c="48298">(</st>**<st c="48300">LGPL</st>**<st c="48304">)。</st> <st c="48308">与
    GPL 不同，LGPL 允许你将库与非 LGPL 软件链接，而无需将整个合并作品以 LGPL 许可证发布。</st> <st c="48439">然而，对
    LGPL 许可证组件的任何更改必须以 LGPL 发布。</st> <st c="48520">这使得 LGPL 更适合与专有软件混合使用，同时仍保持对 LGPL
    组件的改进开放。</st> <st c="48649">这些</st> <st c="48655">许可证具有</st> **<st c="48671">中等风险评级</st>**
    <st c="48691">因为它们对于专有集成更加宽松，但仍确保 LGPL 许可证组件的开放性。</st>'
- en: <st c="48807">Recommendation 4 – Implementing secret protection in source control</st>
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="48807">推荐 4 – 在源代码控制中实施机密保护</st>
- en: <st c="48875">We previously</st> <st c="48890">discussed GitHub Advanced Security.</st>
    <st c="48926">One of the capabilities that it offers is secret scanning.</st>
    <st c="48985">This means we can implement this capability to continuously scan
    our code bases, to detect exposed credentials.</st> <st c="49097">In addition</st>
    <st c="49109">to this, it also offers</st> **<st c="49133">push protection</st>**<st
    c="49148">, which enables pre-receive secret scanning for both GitHub Enterprise
    and Azure DevOps platforms.</st> <st c="49247">This functionality blocks code
    commits that contain secrets, to prevent accidental</st> <st c="49330">secret
    exposure.</st>
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="48875">我们之前</st> <st c="48890">讨论了 GitHub 高级安全性。</st> <st c="48926">它提供的其中一个功能是机密扫描。</st>
    <st c="48985">这意味着我们可以实施此功能来持续扫描我们的代码库，以检测暴露的凭证。</st> <st c="49097">此外</st> <st
    c="49109">它还提供了</st> **<st c="49133">推送保护</st>**<st c="49148">，该功能可为 GitHub 企业版和
    Azure DevOps 平台启用接收前机密扫描。</st> <st c="49247">该功能会阻止包含机密的代码提交，以防止意外</st> <st c="49330">机密泄露。</st>
- en: <st c="49346">Push protection should be automatically enabled for all repositories.</st>
    <st c="49417">To audit if this capability is</st> <st c="49448">enabled across
    our GitHub organization, we can use the DevOps Security feature of Microsoft Defender
    for Cloud, which includes a recommendation for this (</st>*<st c="49602">Figure
    5</st>**<st c="49611">.23</st>*<st c="49614">).</st> <st c="49618">At the time
    of writing (April 2024), an equivalent recommendation is yet to be added for</st>
    <st c="49707">Azure DevOps:</st>
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="49346">推送保护应自动启用在所有仓库中。</st> <st c="49417">为了审计该功能是否</st> <st c="49448">在我们的
    GitHub 组织中启用，我们可以使用 Microsoft Defender for Cloud 的 DevOps 安全功能，其中包含对此的推荐（</st>*<st
    c="49602">图 5</st>**<st c="49611">.23</st>*<st c="49614">）。</st> <st c="49618">在撰写本文时（2024年4月），还未为</st>
    <st c="49707">Azure DevOps 添加等效的推荐：</st>
- en: '![Figure 5.23 – Microsoft Defender for Cloud push protection recommendation](img/B19710_05_23.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.23 – Microsoft Defender for Cloud 推送保护推荐](img/B19710_05_23.jpg)'
- en: <st c="50367">Figure 5.23 – Microsoft Defender for Cloud push protection recommendation</st>
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50367">图 5.23 – Microsoft Defender for Cloud 推送保护推荐</st>
- en: <st c="50440">Hands-on exercise – Performing pre-receive checks and dependency
    reviews</st>
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="50440">实操练习 – 执行接收前检查和依赖项审核</st>
- en: <st c="50513">In this</st> <st c="50522">exercise, we will be performing pre-receive
    checks on GitHub and Azure DevOps.</st> <st c="50601">We will also review the
    dependencies of the</st> `<st c="50645">eShopOnWeb</st>` <st c="50655">application
    for any</st> <st c="50676">security vulnerabilities.</st>
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50513">在本次练习中，我们将在 GitHub 和 Azure DevOps 上执行预接收检查。</st> <st c="50601">我们还将审查</st>
    `<st c="50645">eShopOnWeb</st>` <st c="50655">应用程序的依赖关系，查找任何</st> <st c="50676">安全漏洞。</st>
- en: <st c="50701">We’ll undertake the</st> <st c="50722">following tasks:</st>
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50701">我们将执行以下任务：</st>
- en: '**<st c="50738">Task 1</st>**<st c="50745">: Enabling push protection on</st>
    <st c="50776">Azure DevOps</st>'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="50738">任务 1</st>**<st c="50745">：在 Azure DevOps 上启用推送保护</st>'
- en: '**<st c="50788">Task 2</st>**<st c="50795">: Enabling push protection</st>
    <st c="50823">on GitHub</st>'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="50788">任务 2</st>**<st c="50795">：在 GitHub 上启用推送保护</st>'
- en: '**<st c="50832">Task 3</st>**<st c="50839">: Reviewing dependencies</st> <st
    c="50865">on GitHub</st>'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="50832">任务 3</st>**<st c="50839">：审查 GitHub 上的依赖关系</st>'
- en: <st c="50874">Let’s begin!</st>
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50874">让我们开始吧！</st>
- en: <st c="50887">Task 1 – Enabling push protection on Azure DevOps</st>
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="50887">任务 1 – 在 Azure DevOps 上启用推送保护</st>
- en: <st c="50937">This task</st> <st c="50948">aims to configure pre-receive conditions
    to enforce repository or organization policies before the push is accepted into
    the repository.</st> <st c="51085">For this task, we will enable push protection
    to block any commits that</st> <st c="51157">have secrets:</st>
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="50937">此任务</st> <st c="50948">旨在配置预接收条件，以便在推送被接受到仓库之前，强制执行仓库或组织的政策。</st>
    <st c="51085">在本任务中，我们将启用推送保护，以阻止包含机密的提交：</st>
- en: <st c="51170">On the Azure portal home page, in the search box, type</st> `<st
    c="51226">Azure DevOps Organizations</st>` <st c="51252">and select the</st> **<st
    c="51268">Azure DevOps Organizations</st>**<st c="51294">. Choose one of your
    existing organizations or</st> **<st c="51341">Create</st>** **<st c="51348">new
    organization</st>**<st c="51364">.</st>
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="51170">在 Azure 门户主页上，在搜索框中输入</st> `<st c="51226">Azure DevOps Organizations</st>`
    <st c="51252">并选择</st> **<st c="51268">Azure DevOps Organizations</st>**<st c="51294">。选择你现有的组织之一，或者</st>
    **<st c="51341">创建</st>** **<st c="51348">新组织</st>**<st c="51364">。</st>
- en: <st c="51365">Create a private project and name</st> <st c="51400">it</st> `<st
    c="51403">eShopOnWeb</st>`<st c="51413">:</st>
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="51365">创建一个私有项目，并命名为</st> `<st c="51403">eShopOnWeb</st>`<st c="51413">：</st>
- en: '![Figure 5.24 – Creating a private project on Azure DevOps](img/B19710_05_24.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.24 – 在 Azure DevOps 上创建私有项目](img/B19710_05_24.jpg)'
- en: <st c="51784">Figure 5.24 – Creating a private project on Azure DevOps</st>
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="51784">图 5.24 – 在 Azure DevOps 上创建私有项目</st>
- en: <st c="51840">Click on</st> **<st c="51850">Repos</st>** <st c="51855">on the
    left and select</st> **<st c="51879">Import</st>** <st c="51885">from the</st>
    **<st c="51895">Import a</st>** **<st c="51904">repository</st>** <st c="51914">section.</st>
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="51840">点击左侧的</st> **<st c="51850">Repos</st>** <st c="51855">，然后选择</st>
    **<st c="51879">Import</st>** <st c="51885">，位于</st> **<st c="51895">Import a</st>**
    **<st c="51904">repository</st>** <st c="51914">部分。</st>
- en: <st c="51923">Under</st> `<st c="51992">.git</st>`<st c="51996">, then</st>
    <st c="52003">click</st> **<st c="52009">Import</st>**<st c="52015">:</st>
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="51923">在</st> `<st c="51992">.git</st>`<st c="51996">中，然后点击</st> **<st
    c="52009">Import</st>**<st c="52015">：</st>
- en: '![Figure 5.25 – Cloning eShopOnWeb](img/B19710_05_25.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.25 – 克隆 eShopOnWeb](img/B19710_05_25.jpg)'
- en: <st c="52157">Figure 5.25 – Cloning eShopOnWeb</st>
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="52157">图 5.25 – 克隆 eShopOnWeb</st>
- en: <st c="52189">We will</st> <st c="52198">be using the secret scanning push protection
    functionality of</st> **<st c="52260">GitHub Advanced Security</st>** <st c="52284">on
    Azure DevOps.</st> <st c="52302">Push protection prevents credentials from being
    committed in the first place in the source code.</st> <st c="52399">Another feature
    of</st> **<st c="52418">GitHub Advanced Security</st>** <st c="52442">is</st>
    **<st c="52446">Secret scanning</st>**<st c="52461">, which scans for secrets
    within your existing</st> <st c="52508">source code.</st>
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="52189">我们将使用</st> **<st c="52260">GitHub 高级安全</st>** <st c="52284">的秘密扫描推送保护功能，</st>
    <st c="52302">推送保护可以防止凭证首次被提交到源代码中。</st> <st c="52399">另一个功能是</st> **<st c="52418">GitHub
    高级安全</st>** <st c="52442">中的</st> **<st c="52446">秘密扫描</st>**<st c="52461">，它可以扫描你现有的</st>
    <st c="52508">源代码中的机密信息。</st>
- en: <st c="52520">When</st> **<st c="52526">GitHub Advanced Security</st>** <st
    c="52550">for Azure DevOps is enabled, secret scanning starts in the background,
    and it generates secret scanning alerts.</st> <st c="52663">You can find these
    by going to the</st> **<st c="52698">Advanced Security</st>** <st c="52715">tab’s</st>
    **<st c="52722">Repos</st>** <st c="52727">|</st> **<st c="52730">Advanced Security</st>**
    <st c="52747">area, then clicking the</st> **<st c="52772">Secrets</st>** <st
    c="52779">tab.</st>
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="52520">当</st> **<st c="52526">GitHub 高级安全功能</st>** <st c="52550">为 Azure
    DevOps 启用时，秘密扫描会在后台启动，并生成秘密扫描警报。</st> <st c="52663">你可以通过进入</st> **<st c="52698">高级安全</st>**
    <st c="52715">标签下的</st> **<st c="52722">仓库</st>** <st c="52727">|</st> **<st c="52730">高级安全</st>**
    <st c="52747">区域，然后点击</st> **<st c="52772">秘密</st>** <st c="52779">标签来查看这些警报。</st>
- en: <st c="52784">First, we need to enable</st> **<st c="52810">GitHub Advanced
    Security</st>**<st c="52834">. You can enable</st> **<st c="52851">Advanced Security</st>**
    <st c="52868">at the organization, project, or repository level.</st> <st c="52920">We
    will enable it for our repository by navigating to</st> **<st c="52974">Project
    Settings</st>** <st c="52990">|</st> **<st c="52993">Repos</st>** <st c="52998">|</st>
    **<st c="53001">Repositories</st>** <st c="53013">and selecting the</st> **<st
    c="53032">eShopOnWeb</st>** <st c="53042">repository.</st> <st c="53055">Under</st>
    **<st c="53061">Settings</st>**<st c="53069">, toggle the</st> **<st c="53082">Advanced
    Security</st>** <st c="53099">button.</st> <st c="53108">A popup to enable and
    begin billing will appear.</st> <st c="53157">Click the</st> **<st c="53167">Begin</st>**
    **<st c="53173">Billing</st>** <st c="53180">button:</st>
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="52784">首先，我们需要启用</st> **<st c="52810">GitHub 高级安全功能</st>**<st c="52834">。你可以在组织、项目或仓库级别启用</st>
    **<st c="52851">高级安全功能</st>** <st c="52868">。我们将通过导航到</st> **<st c="52974">项目设置</st>**
    <st c="52990">|</st> **<st c="52993">仓库</st>** <st c="52998">|</st> **<st c="53001">Repositories</st>**
    <st c="53013">并选择</st> **<st c="53032">eShopOnWeb</st>** <st c="53042">仓库来启用它。</st>
    <st c="53055">在</st> **<st c="53061">设置</st>**<st c="53069">下，切换</st> **<st c="53082">高级安全功能</st>**
    <st c="53099">按钮。</st> <st c="53108">一个启用并开始计费的弹出窗口将出现。</st> <st c="53157">点击</st>
    **<st c="53167">开始</st>** **<st c="53173">计费</st>** <st c="53180">按钮：</st>
- en: '![Figure 5.26 – Enabling Advanced Security](img/B19710_05_26.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.26 – 启用高级安全功能](img/B19710_05_26.jpg)'
- en: <st c="54052">Figure 5.26 – Enabling Advanced Security</st>
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54052">图 5.26 – 启用高级安全功能</st>
- en: <st c="54092">Secret</st> <st c="54100">scanning push protection and repository
    scanning are now</st> <st c="54157">enabled automatically:</st>
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54092">秘密</st> <st c="54100">扫描推送保护和仓库扫描现已自动启用：</st>
- en: '![Figure 5.27 – Secret scanning push protection and secret scanning repo scanning
    enabled once Advanced Security and Block secrets on push are checked](img/B19710_05_27.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.27 – 启用高级安全功能后，推送保护和仓库扫描中的秘密扫描功能会被激活](img/B19710_05_27.jpg)'
- en: <st c="54574">Figure 5.27 – Secret scanning push protection and secret scanning
    repo scanning enabled once Advanced Security and Block secrets on push are checked</st>
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54574">图 5.27 – 启用高级安全功能后，推送保护和仓库扫描中的秘密扫描功能会被激活</st>
- en: <st c="54722">Push protection alerts are issued by push protection whenever
    secrets are identified before a commit.</st> <st c="54825">These alerts are issued
    via the command line, Azure DevOps web interface, and even through</st> <st c="54916">your
    IDE.</st>
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54722">当秘密在提交之前被识别时，推送保护会发出警报。</st> <st c="54825">这些警报通过命令行、Azure DevOps
    Web 界面，甚至通过</st> <st c="54916">你的 IDE</st> <st c="54916">发出。</st>
- en: <st c="54925">Let’s try to commit a file with secrets and see if</st> <st c="54977">it’s
    blocked:</st>
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="54925">让我们尝试提交一个包含秘密的文件，看看它是否会被阻止：</st>
- en: <st c="54990">Navigate to</st> **<st c="55003">Repos</st>**<st c="55008">, select
    the three dots at the top right, and choose</st> **<st c="55061">New</st>** <st
    c="55064">|</st> **<st c="55067">File</st>**<st c="55071">:</st>
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="54990">导航到</st> **<st c="55003">仓库</st>**<st c="55008">，选择右上角的三个点，并选择</st>
    **<st c="55061">新建</st>** <st c="55064">|</st> **<st c="55067">文件</st>**<st c="55071">：</st>
- en: '![Figure 5.28 – Creating a new file](img/B19710_05_28.jpg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.28 – 创建新文件](img/B19710_05_28.jpg)'
- en: <st c="55223">Figure 5.28 – Creating a new file</st>
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="55223">图 5.28 – 创建新文件</st>
- en: <st c="55256">Name the file</st> `<st c="55271">secrets.txt</st>` <st c="55282">and
    click the</st> **<st c="55297">Create</st>** <st c="55303">button.</st>
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="55256">将文件命名为</st> `<st c="55271">secrets.txt</st>` <st c="55282">并点击</st>
    **<st c="55297">创建</st>** <st c="55303">按钮。</st>
- en: <st c="55311">Add the</st> <st c="55320">following content to the new file created,
    then click the</st> **<st c="55378">Commit</st>** <st c="55385">button:</st>
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="55311">将以下内容添加到新创建的文件中，然后点击</st> **<st c="55378">提交</st>** <st c="55385">按钮：</st>
- en: '[PRE0]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '*<st c="55457">Figure 5</st>**<st c="55466">.29</st>* <st c="55469">shows the
    secrets file created.</st> <st c="55502">Add the slack</st> <st c="55516">API
    token.</st>'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*<st c="55457">图 5</st>**<st c="55466">.29</st>* <st c="55469">展示了创建的秘密文件。</st>
    <st c="55502">添加 Slack</st> <st c="55516">API 令牌。</st>'
- en: '![Figure 5.29 – Adding secrets to the secrets.txt file](img/B19710_05_29.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.29 – 向 secrets.txt 文件添加秘密](img/B19710_05_29.jpg)'
- en: <st c="55650">Figure 5.29 – Adding secrets to the secrets.txt file</st>
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="55650">图 5.29 – 向 secrets.txt 文件添加秘密</st>
- en: <st c="55702">We’ll see that the push was rejected because it</st> <st c="55751">contains
    secrets:</st>
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="55702">我们将看到推送被拒绝，因为它</st> <st c="55751">包含了秘密：</st>
- en: '![Figure 5.30 – File with secrets blocked by Advanced Security](img/B19710_05_30.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.30 – 被高级安全阻止的秘密文件](img/B19710_05_30.jpg)'
- en: <st c="56208">Figure 5.30 – File with secrets blocked by Advanced Security</st>
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="56208">图 5.30 – 被高级安全阻止的秘密文件</st>
- en: <st c="56268">Now, let’s</st> <st c="56280">learn how to enable push protection</st>
    <st c="56316">on GitHub.</st>
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="56268">现在，让我们</st> <st c="56280">学习如何在 GitHub 上启用推送保护。</st>
- en: <st c="56326">Task 2 – Enabling push protection on GitHub</st>
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="56326">任务 2 – 在 GitHub 上启用推送保护</st>
- en: <st c="56370">At this</st> <st c="56379">point, we need to learn how to prevent
    secrets from being committed on GitHub repositories through push protection.</st>
    <st c="56495">Let’s</st> <st c="56501">get started:</st>
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="56370">在此</st> <st c="56379">时，我们需要学习如何通过推送保护防止在 GitHub 仓库中提交秘密。</st>
    <st c="56495">让我们</st> <st c="56501">开始吧：</st>
- en: <st c="56513">Navigate to the GitHub repository</st> <st c="56548">for</st>
    [<st c="56552">https://github.com/PacktPublishing/eShopContainers</st>](https://github.com/PacktPublishing/eShopContainers)<st
    c="56602">.</st>
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="56513">导航到 GitHub 仓库</st> <st c="56548">网址</st> [<st c="56552">https://github.com/PacktPublishing/eShopContainers</st>](https://github.com/PacktPublishing/eShopContainers)<st
    c="56602">。</st>
- en: <st c="56603">Fork the repository to your GitHub.</st> <st c="56640">Make sure
    the repository</st> <st c="56665">is public.</st>
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="56603">将仓库 Fork 到你的 GitHub。</st> <st c="56640">确保仓库</st> <st c="56665">是公开的。</st>
- en: <st c="56675">Now, select the</st> **<st c="56692">Settings</st>** <st c="56700">tab.</st>
    <st c="56706">In the left sidebar, under</st> **<st c="56733">Security</st>**<st
    c="56741">, click</st> **<st c="56749">Code security</st>** **<st c="56763">and
    analysis</st>**<st c="56775">.</st>
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="56675">现在，选择</st> **<st c="56692">设置</st>** <st c="56700">选项卡。</st> <st
    c="56706">在左侧边栏中，点击</st> **<st c="56733">安全</st>**<st c="56741">，然后点击</st> **<st
    c="56749">代码安全</st>** **<st c="56763">与分析</st>**<st c="56775">。</st>
- en: <st c="56776">Under</st> **<st c="56783">Secret scanning</st>**<st c="56798">,
    enable</st> **<st c="56807">Push protection</st>** <st c="56822">by</st> <st c="56826">clicking</st>
    **<st c="56835">Enable</st>**<st c="56841">:</st>
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="56776">在</st> **<st c="56783">秘密扫描</st>**<st c="56798">下，启用</st> **<st
    c="56807">推送保护</st>** <st c="56822">，点击</st> **<st c="56835">启用</st>**<st c="56841">：</st>
- en: '![Figure 5.31 – Enabling push protection on GitHub](img/B19710_05_31.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.31 – 在 GitHub 上启用推送保护](img/B19710_05_31.jpg)'
- en: <st c="57131">Figure 5.31 – Enabling push protection on GitHub</st>
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="57131">图 5.31 – 在 GitHub 上启用推送保护</st>
- en: <st c="57179">Secret</st> <st c="57187">scanning as push protection is available
    at the enterprise, organization, and</st> <st c="57265">repository levels.</st>
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="57179">秘密</st> <st c="57187">扫描作为推送保护可在企业、组织和</st> <st c="57265">仓库级别启用。</st>
- en: <st c="57283">Now, let’s try to commit a file with secrets and see if it will</st>
    <st c="57348">be rejected.</st>
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="57283">现在，让我们尝试提交一个包含秘密的文件，看看它是否会</st> <st c="57348">被拒绝。</st>
- en: <st c="57360">Add a new file by clicking</st> **<st c="57388">Add file</st>**
    <st c="57396">|</st> **<st c="57399">Create</st>** **<st c="57406">new file</st>**<st
    c="57414">:</st>
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="57360">点击</st> **<st c="57388">添加文件</st>** <st c="57396">|</st> **<st
    c="57399">创建</st>** **<st c="57406">新文件</st>**<st c="57414">：</st>
- en: '![Figure 5.32 – Adding a new file on GitHub](img/B19710_05_32.jpg)'
  id: totrans-257
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.32 – 在 GitHub 上添加新文件](img/B19710_05_32.jpg)'
- en: <st c="57886">Figure 5.32 – Adding a new file on GitHub</st>
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="57886">图 5.32 – 在 GitHub 上添加新文件</st>
- en: <st c="57927">Name the file</st> `<st c="57942">secrets.txt</st>`<st c="57953">,
    add the following secrets, and then click</st> **<st c="57997">Commit changes…</st>**<st
    c="58012">:</st>
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="57927">命名文件为</st> `<st c="57942">secrets.txt</st>`<st c="57953">，添加以下秘密内容，然后点击</st>
    **<st c="57997">提交更改…</st>**<st c="58012">：</st>
- en: '[PRE1]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*<st c="58189">Figure 5</st>**<st c="58198">.33</st>* <st c="58201">shows the
    secrets file</st> <st c="58225">with secrets.</st>'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*<st c="58189">图 5</st>**<st c="58198">.33</st>* <st c="58201">展示了带有机密信息的文件。</st>'
- en: '![Figure 5.33 – Adding secrets to the new file](img/B19710_05_33.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.33 – 向新文件中添加机密信息](img/B19710_05_33.jpg)'
- en: <st c="58520">Figure 5.33 – Adding secrets to the new file</st>
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="58520">图 5.33 – 向新文件中添加机密信息</st>
- en: <st c="58564">The commit</st> <st c="58576">will be rejected because the secrets
    were detected using</st> <st c="58633">push protection:</st>
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="58564">提交</st> <st c="58576">将被拒绝，因为使用</st> <st c="58633">推送保护检测到了机密信息：</st>
- en: '![Figure 5.34 – Commit rejected due to secrets in the source code](img/B19710_05_34.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.34 – 因源代码中的机密信息而被拒绝的提交](img/B19710_05_34.jpg)'
- en: <st c="59457">Figure 5.34 – Commit rejected due to secrets in the source code</st>
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="59457">图 5.34 – 因源代码中的机密信息而被拒绝的提交</st>
- en: <st c="59520">You can now try to commit using other platforms, such as VS Code.</st>
    <st c="59587">The commits will</st> <st c="59604">be rejected.</st>
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="59520">您现在可以尝试使用其他平台进行提交，例如 VS Code。</st> <st c="59587">提交将</st> <st
    c="59604">被拒绝。</st>
- en: <st c="59616">Task 3 – Reviewing dependencies on GitHub</st>
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="59616">任务 3 – 审查 GitHub 上的依赖项</st>
- en: <st c="59658">For this</st> <st c="59668">task, we’ll check on the security
    vulnerabilities available in our dependencies.</st> <st c="59749">We will</st>
    <st c="59757">review the dependency graph, export the dependencies as a</st> **<st
    c="59815">software bill of materials</st>** <st c="59841">(</st>**<st c="59843">SBOM</st>**<st
    c="59847">), and perform a dependency review using Dependabot.</st> <st c="59901">Follow</st>
    <st c="59908">these steps:</st>
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="59658">对于这个</st> <st c="59668">任务，我们将检查依赖项中存在的安全漏洞。</st> <st c="59749">我们将</st>
    <st c="59757">审查依赖关系图，导出依赖项为</st> **<st c="59815">软件材料清单</st>** <st c="59841">(</st>**<st
    c="59843">SBOM</st>**<st c="59847">)，并使用 Dependabot 执行依赖项审查。</st> <st c="59901">请按照</st>
    <st c="59908">以下步骤进行操作：</st>
- en: <st c="59920">Note</st>
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="59920">注意</st>
- en: <st c="59925">The tool that we’ll be using for this task works for the GitHub
    platform.</st> <st c="60000">For other SCM platforms, Microsoft has a public one
    for SBOM generation that can be accessed</st> <st c="60093">here:</st> [<st c="60099">https://github.com/microsoft/sbom-tool</st>](https://github.com/microsoft/sbom-tool)<st
    c="60137">.</st>
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="59925">我们将用于此任务的工具适用于 GitHub 平台。</st> <st c="60000">对于其他 SCM 平台，微软有一个公共工具用于
    SBOM 生成，您可以通过以下链接访问</st> <st c="60093">这里：</st> [<st c="60099">https://github.com/microsoft/sbom-tool</st>](https://github.com/microsoft/sbom-tool)<st
    c="60137">。</st>
- en: <st c="60138">First, let’s configure the dependency graph so that it can identify
    all our project dependencies and dependents.</st> <st c="60252">Each dependency
    will have license information and its vulnerability severity specified.</st> <st
    c="60340">The dependency graph is automatically generated for all public repositories
    and can be enabled for private repositories</st> <st c="60460">as well.</st>
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="60138">首先，让我们配置依赖关系图，以便它能够识别我们所有的项目依赖关系和依赖者。</st> <st c="60252">每个依赖项将具有许可证信息和指定的漏洞严重性。</st>
    <st c="60340">该依赖关系图会自动为所有公共仓库生成，也可以为私有仓库启用</st> <st c="60460">。</st>
- en: <st c="60468">To enable the dependency graph on a private repository, navigate
    to</st> **<st c="60537">Settings</st>** <st c="60545">|</st> **<st c="60548">Code
    security and analysis</st>** <st c="60574">(under</st> **<st c="60582">Security</st>**<st
    c="60590">) |</st> **<st c="60595">Dependency graph</st>** <st c="60611">and</st>
    <st c="60616">click</st> **<st c="60622">Enable</st>**<st c="60628">:</st>
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="60468">要在私有仓库上启用依赖关系图，请导航至</st> **<st c="60537">设置</st>** <st c="60545">|</st>
    **<st c="60548">代码安全性与分析</st>** <st c="60574">(在</st> **<st c="60582">安全</st>**
    <st c="60590">下)</st> **<st c="60595">依赖关系图</st>** <st c="60611">并</st> <st c="60616">点击</st>
    **<st c="60622">启用</st>** <st c="60628">：</st>
- en: '![Figure 5.35 – Dependency graph](img/B19710_05_35.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.35 – 依赖关系图](img/B19710_05_35.jpg)'
- en: <st c="60685">Figure 5.35 – Dependency graph</st>
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="60685">图 5.35 – 依赖关系图</st>
- en: <st c="60715">You can view the dependency graph by navigating</st> <st c="60764">to</st>
    **<st c="60767">Insights</st>**<st c="60775">:</st>
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="60715">您可以通过导航到</st> <st c="60764">**Insights**</st> <st c="60775">来查看依赖关系图：</st>
- en: '![Figure 5.36 – Insights](img/B19710_05_36.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.36 – Insights](img/B19710_05_36.jpg)'
- en: <st c="60863">Figure 5.36 – Insights</st>
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="60863">图 5.36 – Insights</st>
- en: <st c="60885">Then, click</st> **<st c="60898">Dependency graph</st>**<st c="60914">:</st>
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="60885">然后，点击</st> **<st c="60898">依赖关系图</st>**<st c="60914">：</st>
- en: '![Figure 5.37 – Dependency graph under Insights](img/B19710_05_37.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.37 – Insights 下的依赖关系图](img/B19710_05_37.jpg)'
- en: <st c="61078">Figure 5.37 – Dependency graph under Insights</st>
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="61078">图 5.37 – Insights 下的依赖关系图</st>
- en: <st c="61123">After</st> <st c="61130">clicking the</st> **<st c="61143">Dependency
    graph</st>** <st c="61159">option on the sidebar, the list of dependencies will
    be listed with details of their versions and security severity.</st> <st c="61277">For
    each of the dependencies, there will be details of the manifest file it was found
    in, as well as</st> <st c="61378">its license:</st>
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="61123">点击</st> <st c="61130">侧边栏中的</st> **<st c="61143">依赖关系图</st>**
    <st c="61159">选项后，依赖项列表将显示其版本和安全严重性详情。</st> <st c="61277">每个依赖项都会列出其所在的清单文件的详情，以及</st>
    <st c="61378">其许可证：</st>
- en: '![Figure 5.38 – Dependency graph details](img/B19710_05_38.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.38 – 依赖关系图详情](img/B19710_05_38.jpg)'
- en: <st c="62145">Figure 5.38 – Dependency graph details</st>
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="62145">图 5.38 – 依赖关系图详情</st>
- en: <st c="62183">You can</st> <st c="62192">also export an SBO</st><st c="62210">M
    for your repository from the dependency graph.</st> <st c="62260">SBOMs show open
    source usage and supply chain vulnerabilities.</st> <st c="62323">The SBOM will
    be generated in SPDX format via the GitHub user interface or the</st> <st c="62402">REST
    API.</st>
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="62183">您还可以从依赖关系图导出您的仓库的 SBOM。</st> <st c="62210">SBOM 显示开源使用和供应链漏洞。</st>
    <st c="62260">SBOM 将通过 GitHub 用户界面或</st> <st c="62323">REST API 生成，并采用 SPDX 格式。</st>
- en: <st c="62411">An SBOM is a structured and machine-readable list detailing a
    project’s dependencies, along with relevant information such as versions, package
    identifiers, and licenses.</st> <st c="62583">SBOMs play a crucial role in mitigating
    supply chain risks by doing</st> <st c="62651">the following:</st>
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="62411">SBOM 是一个结构化且机器可读的列表，详细列出了项目的依赖关系，以及版本、包标识符和许可证等相关信息。</st> <st
    c="62583">SBOM 在通过以下方式减轻供应链风险中起着至关重要的作用：</st>
- en: <st c="62665">Enhancing transparency regarding the dependencies that are employed
    in</st> <st c="62737">your repository</st>
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="62665">增强关于在</st> <st c="62737">您的仓库中使用的依赖关系的透明度</st>
- en: <st c="62752">Facilitating early detection of vulnerabilities within the</st>
    <st c="62812">development process</st>
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="62752">促进在</st> <st c="62812">开发过程中的早期漏洞检测</st>
- en: <st c="62831">Offering insights into potential license compliance, security,
    or quality issues present in your</st> <st c="62929">code base</st>
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="62831">提供关于代码库中潜在许可证合规性、安全性或质量问题的见解</st> <st c="62929">代码库</st>
- en: <st c="62938">Empowering adherence to various data protection standards for</st>
    <st c="63001">improved compliance</st>
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="62938">帮助遵守各种数据保护标准，以提高</st> <st c="63001">合规性</st>
- en: <st c="63020">To generate the SBOM, click</st> **<st c="63049">Export SBOM</st>**<st
    c="63060">:</st>
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="63020">要生成 SBOM，请点击</st> **<st c="63049">导出 SBOM</st>**<st c="63060">：</st>
- en: '![Figure 5.39 – Export SBOM](img/B19710_05_39.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.39 – 导出 SBOM](img/B19710_05_39.jpg)'
- en: <st c="63852">Figure 5.39 – Export SBOM</st>
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="63852">图 5.39 – 导出 SBOM</st>
- en: <st c="63877">The</st> <st c="63882">export will be in a machine-readable format
    so that the data can be</st> <st c="63950">processed further.</st>
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="63877">导出将采用机器可读格式，以便数据可以进一步</st> <st c="63950">处理。</st>
- en: <st c="63968">Lastly, let’s enable Dependabot.</st> <st c="64002">You can enable
    it by going to</st> **<st c="64032">Settings</st>** <st c="64040">|</st> **<st
    c="64043">Code security and analysis</st>** <st c="64069">|</st> **<st c="64072">Dependency
    alerts</st>** <st c="64089">and choosing</st> **<st c="64103">Enable all or directly</st>**
    <st c="64125">from the</st> **<st c="64135">Dependency graph</st>** <st c="64151">page,
    as</st> <st c="64161">shown here:</st>
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="63968">最后，让我们启用 Dependabot。</st> <st c="64002">您可以通过访问</st> **<st c="64032">设置</st>**
    <st c="64040">|</st> **<st c="64043">代码安全性和分析</st>** <st c="64069">|</st> **<st
    c="64072">依赖项警报</st>** <st c="64089">并选择</st> **<st c="64103">启用全部或直接</st>** <st
    c="64125">从</st> **<st c="64135">依赖关系图</st>** <st c="64151">页面启用，如下所示：</st>
- en: '![Figure 5.40 – Enabling Dependabot from the Dependency graph page](img/B19710_05_40.jpg)'
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.40 – 从依赖关系图页面启用 Dependabot](img/B19710_05_40.jpg)'
- en: <st c="64411">Figure 5.40 – Enabling Dependabot from the Dependency graph page</st>
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="64411">图 5.40 – 从依赖关系图页面启用 Dependabot</st>
- en: <st c="64475">Either of the two options work.</st> <st c="64508">This will prompt
    a new workflow and the security vulnerabilities from Dependabot will be available
    in the</st> **<st c="64614">Security</st>** <st c="64622">tab:</st>
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: <st c="64475">这两种选项都有效。</st> <st c="64508">这将触发一个新的工作流，并且来自 Dependabot 的安全漏洞将在</st>
    **<st c="64614">安全性</st>** <st c="64622">标签页中可见：</st>
- en: '![Figure 5.41 – Dependabot alerts on GitHub (126 Dependabot alerts on the left)](img/B19710_05_41.jpg)'
  id: totrans-299
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.41 – GitHub 上的 Dependabot 警报（左侧有 126 个 Dependabot 警报）](img/B19710_05_41.jpg)'
- en: <st c="65335">Figure 5.41 – Dependabot alerts on GitHub (126 Dependabot alerts
    on the left)</st>
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="65335">图 5.41 – GitHub 上的 Dependabot 警报（左侧为 126 个 Dependabot 警报）</st>
- en: <st c="65412">Go through</st> <st c="65424">the issues found by Dependabot and
    review the severity of the</st> <st c="65486">security vulnerabilities.</st>
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="65412">查看</st> <st c="65424">Dependabot 发现的问题并审查这些安全漏洞的严重性。</st>
- en: <st c="65511">Summary</st>
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="65511">总结</st>
- en: <st c="65519">In this chapter, we examined two primary security concerns for
    the source control phase of DevOps.</st> <st c="65619">First, we looked at guidelines
    that we can follow to implement a protected source control environment.</st> <st
    c="65722">Second, we tackled how to integrate security tools to identify and remediate
    common coding errors that can lead to</st> <st c="65837">security issues.</st>
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="65519">在本章中，我们讨论了 DevOps 源代码控制阶段的两个主要安全问题。</st> <st c="65619">首先，我们查看了可以遵循的指南，以实现受保护的源代码控制环境。</st>
    <st c="65722">其次，我们探讨了如何整合安全工具来识别和修复可能导致</st> <st c="65837">安全问题的常见编码错误。</st>
- en: <st c="65853">In the upcoming chapter, we will discuss implementing security
    in the BUILD and TEST phases</st> <st c="65946">of DevOps.</st>
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="65853">在接下来的章节中，我们将讨论如何在 DevOps 的构建和测试阶段</st> <st c="65946">实施安全性。</st>
- en: '<st c="0">Part 3: Securing the Build, Test, Release, and Operate Phases of
    DevOps</st>'
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">第三部分：确保 DevOps 构建、测试、发布和操作阶段的安全性</st>
- en: <st c="72">In this part, you will explore the best security practices in the
    Build, Test, Release, and Operate phases in the</st> <st c="187">Azure cloud.</st>
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="72">在本部分中，你将探索在 Azure 云中构建、测试、发布和操作阶段的最佳安全实践。</st>
- en: <st c="199">This part contains the</st> <st c="223">following chapters:</st>
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="199">本部分包含以下章节：</st>
- en: '[*<st c="242">Chapter 6</st>*](B19710_06.xhtml#_idTextAnchor122)<st c="252">,</st>
    *<st c="254">Implementing Security in the Build Phase of DevOps</st>*'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*<st c="242">第六章</st>*](B19710_06.xhtml#_idTextAnchor122)<st c="252">,</st>
    *<st c="254">在 DevOps 的构建阶段实施安全性</st>*'
- en: '[*<st c="304">Chapter 7</st>*](B19710_07.xhtml#_idTextAnchor145)<st c="314">,</st>
    *<st c="316">Implementing Security in the Test and Release Phases of DevOps</st>*'
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*<st c="304">第七章</st>*](B19710_07.xhtml#_idTextAnchor145)<st c="314">,</st>
    *<st c="316">在 DevOps 的测试和发布阶段实施安全性</st>*'
- en: '[*<st c="378">Chapter 8</st>*](B19710_08.xhtml#_idTextAnchor168)<st c="388">,</st>
    *<st c="390">Continuous Security Monitoring on Azure</st>*'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*<st c="378">第八章</st>*](B19710_08.xhtml#_idTextAnchor168)<st c="388">,</st>
    *<st c="390">在 Azure 上进行持续安全监控</st>*'
