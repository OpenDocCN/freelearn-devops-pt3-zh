- en: '*Chapter 14*: Securing Your Code'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In 2016, a dispute about the name *Kik* between the messenger service Kik ([https://www.kik.com/](https://www.kik.com/))
    and open source contributor *Azer Koçulu*, who maintained a project with the same
    name, led to a complete outage of the internet. At least everybody noticed that
    day that something was wrong. What happened? Because of the dispute and npm siding
    with the messenger service, Azer retracted all his packages from the npm registry.
    Among the packages was a package called `left-pad`. Its purpose was to add characters
    to the beginning of a string of text. `left-pad` was a simple module with only
    11 lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple, single-purpose function that every developer should be able
    to write on their own. And yet the package made it into globally used frameworks
    such as *React*. React didn't require these 11 lines of code directly, of course.
    But it depended on packages that depend on other packages – and one package in
    this tree depended on `left-pad`. And that package missing basically broke the
    internet (see *Keith Collins 2016* and *Tyler Eon 2016*).
  prefs: []
  type: TYPE_NORMAL
- en: Software today depends on a lot of different software – tools, packages, frameworks,
    compilers, and languages – and each of these has its own dependency tree. It's
    important to ensure security and license compliance not just for your code but
    for your entire software supply chain.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you'll learn how GitHub Actions and Advanced Security can help
    you to eliminate bugs and security issues in your code and successfully manage
    your software supply chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key topics in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Dependency management and Dependabot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secret scanning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code scanning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing your own CodeQL queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub Advanced Security
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Many features discussed in this chapter are only available for GitHub Enterprise
    if you acquire the **Advanced Security License**. Some of them are free for open
    source – but if some are not available in your organization, then you probably
    have not acquired the corresponding license.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Dependency management and Dependabot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To manage your dependencies, you can use **Software Composition Analysis** (**SCA**)
    tools. GitHub offers **Dependency graphs**, **Dependabot alerts**, and **Dependabot
    security updates** to manage your software dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: '**Dependency graph** helps you to understand your dependency tree. **Dependabot
    alerts** check your dependencies for known vulnerabilities and alert you in case
    Dependabot finds any. If you enable **Dependabot security updates**, Dependabot
    will automatically create pull requests that update your dependencies if the author
    of the dependent package releases a fix for a vulnerability.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The dependency graph is enabled by default for public repositories but not
    for private ones. Dependabot alerts and updates must be enabled for all repositories.
    You can do this under **Settings** | **Security & Analysis** (see *Figure 14.1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1 – Enable the dependency graph and Dependabot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_14_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.1 – Enable the dependency graph and Dependabot
  prefs: []
  type: TYPE_NORMAL
- en: On the organizational level, you can enable these options for all repositories
    and make them the default for new repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring your dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you enable the dependency graph, it will start looking for dependencies.
    The following package ecosystems are supported (see *Table 14.1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 14.1 – Supported formats for the dependency graph and Dependabot'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_table_14.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 14.1 – Supported formats for the dependency graph and Dependabot
  prefs: []
  type: TYPE_NORMAL
- en: 'To explore your dependencies, you can navigate to **Insights** | **Dependency
    graph**. On the **Dependencies** tab, you can find all the dependencies for the
    manifest files that were found in your repository. You can open the dependencies
    for each dependency and navigate the tree. If the dependency has a known vulnerability,
    you can see it on the right side. The vulnerability has an assigned severity and
    a **Common Vulnerabilities and Exposures** (**CVE**) identifier. With this identifier,
    you can look up the details for the vulnerability in the **National Vulnerability
    Database** ([nvd.nist.gov](http://nvd.nist.gov)). Click on the link, and it will
    direct you to the entry in the database ([https://nvd.nist.gov/vuln/detail/CVE-2021-3749](https://nvd.nist.gov/vuln/detail/CVE-2021-3749))
    or to the **GitHub Advisory Database** ([https://github.com/advisories](https://github.com/advisories)).
    If there is a fix for the vulnerability, the dependency graph suggests the version
    you should upgrade the dependency to (see *Figure 14.2*):'
  prefs: []
  type: TYPE_NORMAL
- en: '`'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2 – Exploring your dependencies with the dependency graph'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_14_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.2 – Exploring your dependencies with the dependency graph
  prefs: []
  type: TYPE_NORMAL
- en: 'On the *organization level*, under **Insights** | **Dependencies**, you can
    find all dependencies from all repositories that have turned on the dependency
    graph. In addition to the repository insights, you can find all the used licenses
    here. This can help you to check the license compliance of your products (see
    *Figure 14.3*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3 – Dependency insights on the organization level'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_14_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.3 – Dependency insights on the organization level
  prefs: []
  type: TYPE_NORMAL
- en: If you want to leverage GitHub to inform others that depend on your packages,
    you can draft a new **security advisory** under **Security** | **Security Advisories**
    | **New draft security advisory**. The security advisor contains a title, description,
    the ecosystem, the package name, the affected versions (that is, < 1.2.3), the
    patched versions (1.2.3), and the severity. You can optionally add multiple **Common
    Weakness Enumerators** (**CWEs**) (see [https://cwe.mitre.org/](https://cwe.mitre.org/)).
    If you already have a CVE ID, you can add it here; if not, you can select to add
    it later.
  prefs: []
  type: TYPE_NORMAL
- en: The draft is only visible to repository owners until it is published. Once published,
    security advisories on public repositories are visible to everyone and are added
    to the **GitHub Advisory Database** ([https://github.com/advisories](https://github.com/advisories)).
    For private repositories, they are only visible to everyone that has access to
    the repository, and they do not get added to the advisory database until you request
    an official CVE identifier.
  prefs: []
  type: TYPE_NORMAL
- en: Dependabot
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Dependabot** is a bot in GitHub that can check your dependencies for known
    vulnerabilities. It can also automatically create pull requests to keep your dependencies
    up to date.'
  prefs: []
  type: TYPE_NORMAL
- en: Dependabot supports npm, GitHub Actions, Docker, git submodules, .NET (NuGet),
    pip, Terraform, Bundler, Maven, and many other ecosystems. For a complete list,
    see [https://docs.github.com/en/code-security/supply-chain-security/keeping-your-dependencies-updated-automatically/about-dependabot-version-updates#supported-repositories-and-ecosystems](https://docs.github.com/en/code-security/supply-chain-security/keeping-your-dependencies-updated-automatically/about-dependabot-version-updates#supported-repositories-and-ecosystems).
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable Dependabot, create a `dependabot.yml` file in the `.github` directory.
    You select the package ecosystem and the directory that contains the package file
    (that is, the `package.json` file). You have to specify whether Dependabot should
    check for updates `daily`, `weekly`, or `monthly`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can authenticate to private registries using **Dependabot secrets**. Add
    a new secret under **Settings** | **Secrets** | **Dependabot** (see Figure 14.4**)**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.4 – Adding a Dependabot secret'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_14_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.4 – Adding a Dependabot secret
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, add the registry to the `dependabot.yml` file and access the secret from
    the `secret` context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: There are many more options to configure Dependabot – you can allow or deny
    certain packages, apply metadata to pull requests (such as labels, milestones,
    and reviewers), customize the commit message, or you can change the merge strategy.
    For a complete list of options, see [https://docs.github.com/en/code-security/supply-chain-security/keeping-your-dependencies-updated-automatically/configuration-options-for-dependency-updates](https://docs.github.com/en/code-security/supply-chain-security/keeping-your-dependencies-updated-automatically/configuration-options-for-dependency-updates).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check the status of Dependabot updates under **Insights** | **Dependency
    graph** | **Dependabot**. Each update entry has a row with a status and warning
    icons if something is wrong. Click the status to see the complete log (see *Figure
    14.5*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.5 – Viewing Dependabot status and log files'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_14_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.5 – Viewing Dependabot status and log files
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find all the Dependabot alerts under **Security** | **Dependabot alerts**.
    You can click on each item to see details. If Dependabot has already created a
    pull request to fix the vulnerability, you can see a link with a fly-out menu
    in the list (see *Figure 14.6*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.6 – Viewing Dependabot alerts'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_14_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.6 – Viewing Dependabot alerts
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that only the security alerts are in this list – not all the pull requests
    that get created to update your dependencies. There are also a lot of security
    alerts here that don''t have a fix yet. Sometimes, the only fix is a downgrade,
    and if one of your dependents states a minimum higher version, there is no automated
    fix (see *Figure 14.7*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.7 – Details of a vulnerability that has no fix'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_14_007.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.7 – Details of a vulnerability that has no fix
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have a closer look at the pull requests of Dependabot, you''ll notice
    a lot of additional information. Of course, the changes themselves are only updated
    version numbers in a manifest file. But in the description, it adds the release
    notes from the package – if there are any – and a complete list of the commits
    that are in the new release. Dependabot also adds a compatibility score that indicates
    how likely it is that this update will be compatible with your code (see *Figure
    14.8*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.8 – Details of a Dependabot pull request'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_14_008.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.8 – Details of a Dependabot pull request
  prefs: []
  type: TYPE_NORMAL
- en: 'In the description, you will also find a list of commands that you can send
    to the bot by commenting on the pull request. You can use any of the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@dependabot cancel merge`: Cancels a previously requested merge.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@dependabot close`: Closes the pull request and prevents Dependabot from recreating
    it. You can achieve the same result by closing the pull request manually.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@dependabot ignore this dependency`: Closes the pull request and prevents
    Dependabot from creating any more pull requests for this dependency (unless you
    reopen the pull request or upgrade to the suggested version of the dependency
    yourself).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@dependabot ignore this major version`: Closes the pull request and prevents
    Dependabot from creating any more pull requests for this major version (unless
    you reopen the pull request or upgrade to this major version yourself).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@dependabot ignore this minor version`: Closes the pull request and prevents
    Dependabot from creating any more pull requests for this minor version (unless
    you reopen the pull request or upgrade to this minor version yourself).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@dependabot merge`: Merges the pull request once your CI tests have passed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@dependabot rebase`: Rebases the pull request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@dependabot recreate`: Recreates the pull request, overwriting any edits that
    have been made to the pull request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@dependabot reopen`: Reopens the pull request if the pull request is closed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@dependabot squash and merge`: Squashes and merges the pull request once your
    CI tests have passed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Just comment on one of the commands in the pull request, and Dependabot will
    do the rest for you.
  prefs: []
  type: TYPE_NORMAL
- en: Automate Dependabot updates with GitHub Actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use GitHub Actions to add even more automation to Dependabot updates,
    but there are some things you have to be aware of. If Dependabot triggers a workflow,
    the GitHub actor is Dependabot (`github.actor == "Dependabot[bot]"`). This means
    that `GITHUB_TOKEN` has only read-only permissions by default, and you must grant
    write permissions if necessary. The secrets that are populated in the secret context
    are the Dependabot secrets! GitHub Actions secrets are not available to the workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a workflow that only gets triggered by Dependabot
    pull requests and gets granted write permissions to pull requests, issues, and
    projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `Dependabot/fetch-metadata` action to extract information about
    the dependencies being updated. Here is an example that uses the information to
    apply a label to the pull request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the GitHub CLI, it''s really easy to add automation. You can, for example,
    auto-approve and auto-merge all new patches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The combination of GitHub Actions and Dependabot is very powerful and can remove
    nearly all manual tasks to keep your software up to date. In combination with
    a good CI build and a test suite you trust, you can basically auto-merge all the
    Dependabot pull requests that pass the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Use Dependabot to keep your GitHub actions up to date
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'GitHub actions are also dependencies you must manage. Each action is pinned
    to a version (the part behind `@`, such as `uses: Dependabot/fetch-metadata@v1.1.1`).
    The version can also be a branch name – but this would result in flaky workflows,
    as your actions would change without you knowing. It''s better to pin the versions
    to a tag or an individual commit SHA. You can let Dependabot check for updates
    and create pull requests for you as with any other ecosystem. Add the following
    section to your `Dependabot.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: Dependabot will create pull requests if new versions of your actions are available.
  prefs: []
  type: TYPE_NORMAL
- en: Secret scanning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most common attack vectors is secrets in plain text files. Secrets
    should never be stored unencrypted and unprotected. GitHub helps you with this
    by constantly scanning all your public repositories for secrets. You can also
    enable this for private repositories that belong to an organization where **GitHub
    Advanced Security** is enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Currently, there are nearly 100 secrets in public and 145 in private repositories
    that get detected – Adobe, Alibaba, Amazon, Atlassian, Azure, and so on. For a
    complete list, see [https://docs.github.com/en/code-security/secret-scanning/about-secret-scanning](https://docs.github.com/en/code-security/secret-scanning/about-secret-scanning).
  prefs: []
  type: TYPE_NORMAL
- en: As a service provider, you can sign up for the **secret scanning partner program**
    (see [https://docs.github.com/en/developers/overview/secret-scanning-partner-program](https://docs.github.com/en/developers/overview/secret-scanning-partner-program)).
    Your secrets get detected by a regular expression and are then sent to an endpoint,
    where you can verify whether the secret is real or whether it is a false positive.
    It is the decision of the partner to revoke the secret or just inform the customer
    that the secret is compromised.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can enable secret scanning for private repositories in **Settings** | **Security
    & analysis** | **GitHub Advanced Security**. Here, you can also define custom
    patterns by clicking **New pattern** (see *Figure 14.9*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.9 – Enabling secret scanning and adding custom patterns'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_14_009.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.9 – Enabling secret scanning and adding custom patterns
  prefs: []
  type: TYPE_NORMAL
- en: 'A custom pattern is a regular expression that matches the secrets you want
    to detect. You have to provide some test strings to see whether your pattern works.
    GitHub marks the secrets found in the test strings yellow (see *Figure 14.10*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.10 – Adding a custom secret pattern'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_14_010.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.10 – Adding a custom secret pattern
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also customize the patterns before and after the secret, and you can
    add patterns that must match or must not patch – for example, you can enforce
    with the additional pattern (`[A-Z]`) that the string must at least contain one
    uppercase letter (see *Figure 14.11*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.11 – Advanced options for custom patterns'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_14_011.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.11 – Advanced options for custom patterns
  prefs: []
  type: TYPE_NORMAL
- en: Custom patterns can also be defined on the organization and enterprise level,
    and GitHub will scan all repositories in the enterprise or organization with GitHub
    Advanced Security enabled.
  prefs: []
  type: TYPE_NORMAL
- en: When a new secret is detected, GitHub notifies all users with access to security
    alerts for the repository according to their notification preferences. You will
    receive alerts if you are watching the repository, have enabled notifications
    for security alerts or all activity on the repository, are the author of the commit
    that contains the secret, and are not ignoring the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can manage the alerts under **Security** | **Secret scanning alerts** (see
    *Figure 14.12*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.12 – Managing secret scanning alerts'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_14_012.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.12 – Managing secret scanning alerts
  prefs: []
  type: TYPE_NORMAL
- en: You should consider a secret that has been committed to GitHub compromised –
    even if it has only been to a private repository. Rotate and revoke the secret.
    Some service providers will revoke it for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can close an alert with the `Revoked`, `False positive`, `Used in tests`,
    or `Won''t fix` status (see *Figure 14.13*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.13 – Managing the status for a secret scanning alert'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_14_013.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.13 – Managing the status for a secret scanning alert
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also exclude paths in your source code from secret scanning by adding
    a `secret_scanning.yml` file to the `.github` folder. The file supports multiple
    path patterns with wildcard support:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: But be careful! This should not be used to store real secrets in source files,
    even for testing – store secrets as GitHub encrypted secrets or in a secure vault.
  prefs: []
  type: TYPE_NORMAL
- en: Secret scanning is easy – you basically just have to turn it on. But the value
    of security should not be underestimated.
  prefs: []
  type: TYPE_NORMAL
- en: Code scanning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To find vulnerabilities in your own code, you can use **Static** **Application
    Security Testing** (**SAST**). SAST is considered white-box testing, as it has
    full access to the source code. It is not a pure static code analysis, as that
    normally includes building software. But unlike **Dynamic Application Security
    Testing** (**DAST**) – we will learn more about that in [*Chapter 15*](B17827_15_Epub.xhtml#_idTextAnchor313),
    *Securing Your Deployments* – it is not executed at runtime but at compile time.
  prefs: []
  type: TYPE_NORMAL
- en: Code scanning in GitHub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In GitHub, SAST is called **code scanning**, and it is available for all public
    repositories and for private repositories that have GitHub Advanced Security enabled.
    You can use code scanning with all tools that support the **Static Analysis Results
    Interchange Format** (**SARIF**). SARIF is an **OASIS Standard** based upon JSON
    that defines the output format for static analysis tools. GitHub code scanning
    currently supports **SARIF 2.1.0**, which is the newest version of the standard
    (see https://docs.github.com/en/code-security/code-scanning/integrating-with-code-scanning/sarif-support-for-code-scanning).
    So, any tool that supports SARIF 2.1.0 can integrate into code scanning.
  prefs: []
  type: TYPE_NORMAL
- en: Running your code scans
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Code scanning uses GitHub Actions to execute the analysis. Most code scanning
    tools automatically upload the results to GitHub – but if your code scanning tool
    does not, you can upload any SARIF file using the following action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The action accepts individual `.sarif` (or `.sarif.json`) files or a folder
    with multiple files. This is useful if your scanning tool does not support SARIF,
    but the results can be converted. An example would be `ESLint`. You can use `@microsoft/eslint-formatter-sarif`
    to convert the output to SARIF and upload the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: However, most code scanning tools integrate natively into GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get started with code scanning, go to `/security/code-scanning/setup`, which
    shows you a list of code scanning options. On top, you can see the native GitHub
    code scanning tool – **CodeQL Analysis**. But GitHub analyses your repository
    and also shows you all the other tools it can find in the marketplace that fit
    the languages that were detected in your repository – **42Crunch**, **Anchore**,
    **CxSAST**, **Veracode**, and many more. In this book, we''ll focus on **CodeQL**
    – but the integration of the other tools works the same way. If you click **Set
    up this workflow**, GitHub will create a workflow for you (see *Figure 14.14*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.14 – Setting up code scanning'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_14_014.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.14 – Setting up code scanning
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have already set up code scanning, you can add additional tools from
    the results page by clicking **Add more scanning tools** (see *Figure 14.15*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.15 – Code scanning alerts in a repository'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_14_015.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.15 – Code scanning alerts in a repository
  prefs: []
  type: TYPE_NORMAL
- en: 'The workflow template has a trigger for `push`, `pull_request`, and `schedule`.
    The schedule might surprise you, but it has a simple explanation – there might
    be new rules that detect vulnerabilities in your codebase that have not been recognized
    before. So, it is a good idea to run the build also on a scheduled basis. The
    trigger runs once per week on a random day and to a random time. Of course, GitHub
    does not want all code scans to run at the same time. Adjust the schedule to your
    needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'The workflow needs write permissions for security events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'CodeQL supports C++ (`cpp`), C# (`csharp`), Go, Java, JavaScript, Python, and
    Ruby. GitHub tries to detect the languages used in your repository and sets up
    the matrix so that each language gets built independently. Add additional languages
    if necessary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'The analysis itself is quite simple – check out the repository, initialize
    the analysis for the given language, run `autobuild`, and perform the analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'The `autobuild` step tries to build your source code. If it fails, you have
    to change the workflow and build the code yourself. Sometimes, it is enough to
    set up the right version in the environment – for example, the version of Node.js
    or .NET:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Code scanning alerts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can manage your code scanning alerts in each repository under **Settings**
    | **Security & analysis** | **Code scanning** – as you saw in *Figure 14.15*.
    On the organization level, you get an overview of all repositories, and you can
    jump to the individual results page (see *Figure 14.16*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.16 – The security overview for an organization'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_14_016.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.16 – The security overview for an organization
  prefs: []
  type: TYPE_NORMAL
- en: You can filter, sort, and search alerts the same way you can with issues.
  prefs: []
  type: TYPE_NORMAL
- en: Severity
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every code scanning alert has a severity assigned. The severity is calculated
    using the **Common Vulnerability Scoring System** (**CVSS**). The CVSS is an open
    framework for communicating the characteristics and severity of software vulnerabilities
    (see *GitHub Blog 2021* for more information).
  prefs: []
  type: TYPE_NORMAL
- en: The severity helps you to triage your alerts.
  prefs: []
  type: TYPE_NORMAL
- en: Tracking alerts in issues
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The best way to track a code scanning alert is in an issue. You can create
    one by clicking **Create issue** inside the alert (see *Figure 14.17*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.17 – Creating an issue from a code scanning alert'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_14_017.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.17 – Creating an issue from a code scanning alert
  prefs: []
  type: TYPE_NORMAL
- en: 'But it is just opening a new issue and adding the link to the alert into a
    Markdown task list (see *Figure 14.18*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.18 – Linking an issue to a code scanning alert'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_14_018.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.18 – Linking an issue to a code scanning alert
  prefs: []
  type: TYPE_NORMAL
- en: The alert will have an indicator that it is being tracked in an issue – like
    nested issues do (see *Figure 14.19* in the next).
  prefs: []
  type: TYPE_NORMAL
- en: Data-flow analysis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the area under the code, you can see the details of the alert in your code.
    CodeQL supports **data-flow analysis** and can detect issues that arise from the
    flow of data through your application. Click on **Show paths** to see how the
    data flows through your application (see *Figure 14.19*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.19 – Details of the code scanning alert'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_14_019.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.19 – Details of the code scanning alert
  prefs: []
  type: TYPE_NORMAL
- en: 'You can follow the data through your entire application. In the example here,
    you can see 12 steps where the data is assigned and passed along until it is logged
    (see *Figure 14.20*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.20 – An example data flow'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_14_020.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.20 – An example data flow
  prefs: []
  type: TYPE_NORMAL
- en: This is the real power of CodeQL. It is not just a semantic analysis of your
    source code.
  prefs: []
  type: TYPE_NORMAL
- en: CodeQL queries
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the code scanning alert, you can find a reference to the query that detected
    the issue. Click on **View source** to see the query on GitHub (see *Figure 14.21*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.21 – The CodeQL queries are open source'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_14_021.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.21 – The CodeQL queries are open source
  prefs: []
  type: TYPE_NORMAL
- en: The queries are open source, and you'll find them under [https://github.com/github/codeql](https://github.com/github/codeql).
    Every language has a folder here, and inside the CodeQL folder, you'll find the
    queries under `ql/src`. The queries have the `.ql` file extension.
  prefs: []
  type: TYPE_NORMAL
- en: Timeline
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The code scanning alert also contains a concrete timeline with git blame information
    – when and in what commit was the issue first detected? When and where was it
    fixed? Did it reappear? This can help you to triage the alerts (see *Figure 14.22*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.22 – A timeline of a code scanning alert'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_14_022.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.22 – A timeline of a code scanning alert
  prefs: []
  type: TYPE_NORMAL
- en: Pull request integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Code scanning integrates well with pull requests. Code scanning results are
    integrated into the pull request checks, and the details page shows you the overview
    of the results (see *Figure 14.23*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.23 – Code scanning results in a pull request'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_14_023.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.23 – Code scanning results in a pull request
  prefs: []
  type: TYPE_NORMAL
- en: 'Code scanning also adds comments for the alerts in the code, and you can directly
    triage the findings there, changing the status to **False positive**, **Used in
    tests**, or **Won''t fix** (see *Figure 14.24*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.24 – Code scanning comment in the source of a pull request'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_14_024.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.24 – Code scanning comment in the source of a pull request
  prefs: []
  type: TYPE_NORMAL
- en: 'You can define which alert severity should cause the pull request to fail for
    security issues and other findings under **Settings** | **Security & analysis**
    | **Code scanning** (see *Figure 14.25*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.25 – Configure which level of severity causes pull requests to
    fail'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_14_025.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.25 – Configure which level of severity causes pull requests to fail
  prefs: []
  type: TYPE_NORMAL
- en: The pull request integration helps you to keep your main branch clean and detect
    issues before merging and making the code analysis part of the review process.
  prefs: []
  type: TYPE_NORMAL
- en: Code scanning configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many options to configure code scanning. The `init` CodeQL action
    in your workflow has a parameter called `queries`. You can use it to pick one
    of the default query suits:'
  prefs: []
  type: TYPE_NORMAL
- en: '`security-extended`: More queries of lower severity than the default'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`security-and-quality`: Queries from `security-extended`, plus maintainability
    and reliability queries'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use the `queries` parameter to add custom queries. The parameter
    accepts local paths or references to other repositories, including a git reference
    (`branch`, `tag`, or `SHA`). Add a plus sign to add the queries on top of the
    default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '`packs` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: '**CodeQL packs** are still in beta at the time of writing. See [https://codeql.github.com/docs/codeql-cli/about-codeql-packs/](https://codeql.github.com/docs/codeql-cli/about-codeql-packs/)
    for more information about packs.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use a configuration file – for example, `./.github/codeql/codeql-config.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'If any of the preceding is located in another private repository, then you
    can add an access token that is used to load queries, packs, or the config file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: 'In the config file, you normally disable the default queries and specify your
    own. You can also exclude specific paths. Here is an example – `codeql-config.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Your custom query suit (`custom-javascript.qls`) can then import other query
    suites (`javascript-security-extended.qls`) from *CodeQL packs* ( `codeql-javascript`)
    and exclude specific rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also add individual queries (`- query : <path to query>`), multiple
    queries (`-queries: <path to folder>`), or packs (`- qlpack: <name of pack>`).'
  prefs: []
  type: TYPE_NORMAL
- en: CodeQL is very powerful, and you have many options to finetune the configuration.
    See [https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning](https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/configuring-code-scanning)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Writing your own CodeQL queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CodeQL comes with a lot of out-of-the-box queries – especially if you use the
    `security-and-quality` suite. But the full power of CodeQL comes if you start
    to write your own queries. Of course, this is not trivial. CodeQL is a complex
    query language, and if you look at some of the queries at [https://github.com/github/codeql](https://github.com/github/codeql),
    you'll see that they can get quite complex. But if you know your coding language,
    it should be quite easy to create some simple queries.
  prefs: []
  type: TYPE_NORMAL
- en: To write CodeQL queries, you need **Visual Studio Code** (**VS Code**) and the
    **GitHub CodeQL extension** ([https://marketplace.visualstudio.com/items?itemName=GitHub.vscode-codeql](https://marketplace.visualstudio.com/items?itemName=GitHub.vscode-codeql)).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have both installed, clone the starter workspace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the `--recursive` parameter! If you forget it, you have to load the submodules
    manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: In VSCode, select `vscode-codeql-starter.code-workspace` file from the starter
    workspace.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a database from your source code, you need the **CodeQL CLI**. On
    a Mac, you can install it using Homebrew:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'For other platforms, you can download the binaries here: [https://github.com/github/codeql-cli-binaries/releases/latest.](https://github.com/github/codeql-cli-binaries/releases/latest)'
  prefs: []
  type: TYPE_NORMAL
- en: Extract them to a folder and add them to the `$PATH` variable (`%PATH%` on windows).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, go into the folder where you want to store the database and run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: This will create a database for the language in your repository. Repeat the
    step for all the languages in your repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, open the QL extension in VSCode and click **Databases** | **From a folder**.
    Select the database that you''ve created in the previous step. You can attach
    multiple databases and switch between them (see *Figure 14.26*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.26 – Attaching databases to the VSCode CodeQL extension'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_14_026.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.26 – Attaching databases to the VSCode CodeQL extension
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find sample queries for all supported languages in the starter workspace
    (`codeql-custom-queries-<language>/example.ql`). The queries have a comment header
    with metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, they import the necessary modules. They are normally named after the
    language (`javascript`, `csharp`, `java`, and so on), but they could also be something
    like `DataFlow::PathGraph`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'The query itself has a variable declaration, an optional `where` block to limit
    the results, and the `select` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at the CodeQL samples on GitHub to get an idea of how to start. The better
    you know a language, the easier it is to write the queries. The following query
    would search for empty catch blocks in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'You have full IntelliSense support in VSCode (see *Figure 14.27*), which helps
    a lot when writing the queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.27 – IntelliSense in VSCode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_14_027.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.27 – IntelliSense in VSCode
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run a query from the context menu (**CodeQL: Run query**), it will display
    the results in the results window (see *Figure 14.28*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.28 – CodeQL query results'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B17827_14_028.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 14.28 – CodeQL query results
  prefs: []
  type: TYPE_NORMAL
- en: Every element in the `select` clause has a column. You can click on code elements
    and VSCode will open the corresponding source file at the exact location.
  prefs: []
  type: TYPE_NORMAL
- en: You could easily fill an entire book just about CodeQL. This is just a very
    brief introduction, but I see a lot of value in being able to extend code scanning
    with your own rules.
  prefs: []
  type: TYPE_NORMAL
- en: See the CodeQL documentation and language reference for further information.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you''ve learned how to secure your code and control your dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: You've learned about SCA, and you know how to use dependency graphs, Dependabot
    alerts, and Dependabot security updates to manage your software dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You've learned about secret scanning, which prevents secrets from being leaked
    in your source code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You've learned about SAST, and you know how to use code scanning with CodeQL
    or other tools that support SARIF to find problems already during development.
    You can now write your own queries to enforce quality and coding standards.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we'll have a look into how we can secure our release pipeline
    and our deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are the references from this chapter that you can also use to get more
    information on the topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '*How one programmer broke the internet by deleting a tiny piece of code*, *Keith
    Collins* (2016): [https://qz.com/646467/how-one-programmer-broke-the-internet-by-deleting-a-tiny-piece-of-code/](https://qz.com/646467/how-one-programmer-broke-the-internet-by-deleting-a-tiny-piece-of-code/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Kik, Left-Pad, and NPM – Oh My!*, *Tyler Eon* (2016): [https://medium.com/@kolorahl/kik-left-pad-and-npm-oh-my-e6f216a22766](https://medium.com/@kolorahl/kik-left-pad-and-npm-oh-my-e6f216a22766)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Secure at every step: What is software supply chain security and why does
    it matter?*, *Maya Kaczorowski* (2020): [https://github.blog/2020-09-02-secure-your-software-supply-chain-and-protect-against-supply-chain-threats-github-blog/](https://github.blog/2020-09-02-secure-your-software-supply-chain-and-protect-against-supply-chain-threats-github-blog/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '*About the dependency graph*: [https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '*About Dependabot version updates*: [https://docs.github.com/en/code-security/supply-chain-security/keeping-your-dependencies-updated-automatically/about-Dependabot-version-updates](https://docs.github.com/en/code-security/supply-chain-security/keeping-your-dependencies-updated-automatically/about-Dependabot-version-updates'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '*About secret scanning*: [https://docs.github.com/en/code-security/secret-scanning/about-secret-scanning](https://docs.github.com/en/code-security/secret-scanning/about-secret-scanning
    )'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*About GitHub Advanced Security*: [https://docs.github.com/en/get-started/learning-about-github/about-github-advanced-security](https://docs.github.com/en/get-started/learning-about-github/about-github-advanced-security'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '*About code scanning*: [https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/about-code-scanning](https://docs.github.com/en/code-security/code-scanning/automatically-scanning-your-code-for-vulnerabilities-and-errors/about-code-scanning)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*CodeQL code scanning: new severity levels for security alerts*, GitHub Blog
    (2021): [https://github.blog/changelog/2021-07-19-codeql-code-scanning-new-severity-levels-for-security-alerts/](https://github.blog/changelog/2021-07-19-codeql-code-scanning-new-severity-levels-for-security-alerts/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '*Common Vulnerability Scoring System (CVSS)*: [https://www.first.org/cvss/v3.1/specification-document](https://www.first.org/cvss/v3.1/specification-document)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*CodeQL documentation*: https://codeql.github.com/docs/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*QL language reference*: [https://codeql.github.com/docs/ql-language-reference](https://codeql.github.com/docs/ql-language-reference)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
