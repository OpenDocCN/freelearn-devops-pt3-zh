<html><head></head><body>
<div id="book-content">
<div id="sbo-rt-content"><div id="_idContainer022">
			<h1 id="_idParaDest-35" class="chapter-number"><a id="_idTextAnchor035"/>2</h1>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor036"/>Practicing Basic Git Commands</h1>
			<p>The <strong class="bold">GitLab</strong> product is built around a separate tool called <strong class="bold">Git</strong>. GitLab makes <a id="_idTextAnchor037"/>Git easier to use and gives you a central place to store all the files that Git is looking after, in addition to providing many other non-Git-related features. We like to think of GitLab as a <em class="italic">wrapper</em> around Git, making it more pleasant to use and <span class="No-Break">more powerful.</span></p>
			<p>Although GitLab and Git are different tools, GitLab borrows many concepts from Git. This means that to understand GitLab, you need to understand Git. Fortunately, you only need to get to grips with the very basics of Git. We say “fortunately” because Git is an enormous and complicated tool and learning all of its nooks and crannies would take a huge effort. But trust us: if you understand the first 10% of Git, you can use GitLab effectively. That 10% is exactly what we’re going to introduce you to in <span class="No-Break">this chapter.</span></p>
			<p>First, we’ll show you why version control systems such as Git are such a useful part of software development. Then, we’ll explain how you can store your code in Git, including any edits that you or your team members make to that code. We’ll also show you how to develop your code in a safe place called a branch, which is isolated from other team members. This ensures that you don’t step on other people’s toes and overwrite their code. You’ll learn how to mark a particular version of your code so that you can easily refer to it later or release it to customers. Finally, you’ll learn about storing code in remote locations. You’ll learn how to sync local and remote copies of files, and you’ll understand how this architecture enables an entire team to work on a single code base at the <span class="No-Break">same time.</span></p>
			<p>In this chapter, we’re going to cover the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Why <span class="No-Break">use Git?</span></li>
				<li>Committing code to keep <span class="No-Break">it safe</span></li>
				<li>Tagging commits to identify versions <span class="No-Break">of code</span></li>
				<li>Branching code for developing in an <span class="No-Break">isolated space</span></li>
				<li>Syncing local and remote copies <span class="No-Break">of repositories</span></li>
				<li>Additional resources for <span class="No-Break">learning Git</span></li>
			</ul>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor038"/>Technical requirements</h1>
			<p>For this chapter, you need to have Git installed on your local computer. Git works on Linux, macOS, and Windows, as well as many Unix variants. There are easy-to-follow instructions for installing Git on any of these operating systems at <a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a>. If you’re asked to set configuration options during installation, it’s safe to accept all the <span class="No-Break">default values.</span></p>
			<p>To type the Git commands that you’ll see in this chapter, use your favorite terminal application on Linux or macOS. If you’re a Windows user, you can type them in Command Shell, PowerShell, or Git Bash. The default configuration options while installing Git on Windows should make Git available on any of these types of Windows terminals, and they should all produce identical results when you run Git commands <span class="No-Break">in them.</span></p>
			<p>The Git examples you’ll see in this book are operating system-agnostic: <em class="italic">Git works the same no matter where you </em><span class="No-Break"><em class="italic">run it</em></span><span class="No-Break">.</span></p>
			<p>To see if it’s already installed, or to verify that you installed it correctly, open the appropriate terminal for your operating system and run the following command. If the output shows a version number instead of an error, Git has been installed properly on <span class="No-Break">your computer:</span></p>
			<pre class="console">
$ git --version
git version 2.25.1</pre>
			<p>Don’t worry about seeing a particular version number; virtually any version of Git will perform identically for the simple commands we use in <span class="No-Break">this book.</span></p>
			<p>Before using Git, you must tell it your name and email address. This information is added to every edit you store in Git so that other team members know which edits you are <span class="No-Break">responsible for.</span></p>
			<p>First, check if Git is already configured with <span class="No-Break">this information:</span></p>
			<pre class="console">
$ git config --list</pre>
			<p>If the output includes entries for <strong class="source-inline">user.email</strong> and <strong class="source-inline">user.name</strong>, you’re all set and can skip the following two commands. Otherwise, let Git know who you are by running these two one-time commands, replacing the email address and name with <span class="No-Break">your information:</span></p>
			<pre class="console">
$ git config --global user.email "george.spelvin@example.com"
$ git config --global user.name "George Spelvin"</pre>
			<p>An optional but recommended step is to configure Git to use <strong class="source-inline">main</strong> instead of <strong class="source-inline">master</strong> as the name of the default branch in new projects. We haven’t discussed what branches are yet, so this may not make much sense. For now, it’s enough for you to know that many software companies are shifting to <strong class="source-inline">main</strong> as the name for the place where a project’s stable code base lives. You’ll see both terms in use in the wild (and even in this book), but if you’d like to configure your computer so that new projects use <strong class="source-inline">main</strong>, run the following <span class="No-Break">command once:</span></p>
			<pre class="console">
$ git config --global init.defaultBranch main</pre>
			<p>With all the technical requirements done and dusted, let <span class="No-Break">us begin!</span></p>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor039"/>Why use Git?</h1>
			<p>Just like it was helpful to<a id="_idIndexMarker094"/> understand how we built software before automation tools such as GitLab CI/CD pipelines came along (as discussed in <a href="B18073_01.xhtml#_idTextAnchor013"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>), it’s helpful to know how teams coordinated the complicated process of making edits to the same files before Git or similar tools <span class="No-Break">came along.</span></p>
			<p>These tools are designed to solve many problems that developers face, but let’s look at just one. Imagine that you and your teammate Elizabeth are working on the same code base and both of you want to edit some of the same files. Furthermore, imagine that this is a time before the advent of Git or <a id="_idIndexMarker095"/>any other <strong class="bold">version control system</strong> (<strong class="bold">VCS</strong>). The only way to write software in this pre-Git era is for you to edit a file and then email it, put it on a shared network drive, or copy it to a portable disk. Then, you must let Elizabeth know that she’s free to edit it. She <em class="italic">checks it out</em> in some sense (maybe by adding an entry to a spreadsheet saying that she’s got control of the file, or maybe through some other mechanism), and she retains control of the file for as long as she needs it. If you have new ideas and want to edit the file again, you need to ask her to stop editing it and transfer it back to you. When she does, you need to scan through the whole file to see what changes she’s made, in the hope that they don’t conflict with the changes you want to make. Then, you repeat this process for each file the two of you are working on, every time either of you wants to edit any of those files. You can imagine how slow and cumbersome this process is, and how many chances there are to mess something up during all the transfers <span class="No-Break">of ownership!</span></p>
			<p>With this understanding of how things worked in the bad old days, we can look at what a VCS is, how it <a id="_idIndexMarker096"/>solves this problem, and in what other ways it makes developers’ <span class="No-Break">lives easier.</span></p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor040"/>What is a version control system?</h2>
			<p>A VCS is a tool designed to make it easier for one or more developers to work with a set of files. It does this by making snapshots<a id="_idIndexMarker097"/> of all the files in your project at a particular time and letting you view, compare, and restore files in <span class="No-Break">different snapshots.</span></p>
			<p>Each VCS has slightly different<a id="_idIndexMarker098"/> functionality, but here are some features that <span class="No-Break">most offer:</span></p>
			<ul>
				<li>Provides backups of files in case current versions are lost or <span class="No-Break">accidentally overwritten.</span></li>
				<li>Shows how a file’s contents have changed <span class="No-Break">over time.</span></li>
				<li>Shows who made which changes to which files, <span class="No-Break">and when.</span></li>
				<li>Labels certain file snapshots for <span class="No-Break">future reference.</span></li>
				<li>Provides a human-readable description of each set of changes so that team members can understand why changes <span class="No-Break">were made.</span></li>
				<li>Allows developers to edit files in a way that’s compatible with other developers editing the same files at the <span class="No-Break">same time.</span></li>
			</ul>
			<p>There have been many competing VCSs over the years, both open source and proprietary. Some of the best-known examples are Microsoft Visual SourceSafe, CVS, Apache Subversion, and now Git. For reasons we’ll explain shortly, Git has largely taken over the VCS space and now serves as the default VCS for any team that doesn’t have a company mandate to use one of Git’s competitors. In other words, Git has <em class="italic">won</em> the VCS competition, to the extent that such a victory <span class="No-Break">is possible.</span></p>
			<p>VCSs work with any computer language. For example, you could use the same VCS to manage files in separate Java, Python, and Ruby projects. And although we typically think of a VCS as helping you work with source code files in a computer language, they can be used with <em class="italic">any</em> file in a software project, including (but not limited to) <span class="No-Break">the following:</span></p>
			<ul>
				<li>Documentation, such as Markdown or <span class="No-Break">PDF files</span></li>
				<li>Configuration, such as JSON or <span class="No-Break">YAML files</span></li>
				<li>Test code <span class="No-Break">and data</span></li>
				<li>Metadata or configuration information for your <strong class="bold">integrated development </strong><span class="No-Break"><strong class="bold">environment</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">IDE</strong></span><span class="No-Break">)</span></li>
				<li>Other project assets, such as pictures, video, or <span class="No-Break">sound files</span></li>
			</ul>
			<p>There’s no need to<a id="_idIndexMarker099"/> limit VCSs to just software projects! You could use Git or any VCS to manage the poems in an anthology, recipes in a cookbook, or chapters in a novel. VCSs are useful for literally any project that involves files on <span class="No-Break">a computer.</span></p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor041"/>What problems does a VCS solve?</h2>
			<p>Now that you<a id="_idIndexMarker100"/> understand what kinds of features a VCS such as Git offers, your mind is probably spinning with all the possible ways a VCS could solve everyday problems faced by software developers. Here are just some scenarios, but you can no doubt think <span class="No-Break">up more.</span></p>
			<h3>Why was this code changed?</h3>
			<p>You may open some source <a id="_idIndexMarker101"/>code in your text editor one morning only to discover that a method that you’re familiar with now uses an entirely different algorithm. Why was it changed? Was the old algorithm broken? Is the new algorithm faster? Is the code that implements it shorter or easier to read? By looking at the <em class="italic">commit message</em> of your VCS, you can read a description of why the change was made. Some of these messages are more complete than others, depending on how conscientious the developer who made the commit was, but you can usually get the general picture of what motivated <span class="No-Break">the change.</span></p>
			<h3>When was this code changed?</h3>
			<p>Imagine that you revisit a Java class that you haven’t looked at in a few months, and notice that it has had some features added and others removed. When did these changes take place? More importantly, did they take place before or after the last deployment to production? Your VCS’s commit log will tell you each time that class was touched, and even what lines were modified each time it was edited. That will let you pinpoint which changes were made when so that you know which version of the class is being used by <span class="No-Break">customers today.</span></p>
			<h3>Who added this buggy code?</h3>
			<p>Git has a feature called <em class="italic">blame</em> that tells you<a id="_idIndexMarker102"/> which developer edited which lines of a file. This is helpful when<a id="_idIndexMarker103"/> you discover that some newly added code is buggy or slow because you know exactly whom to ask to fix it! But it also has a positive use case: if you spot an especially clever piece of code, your VCS can let you know whom you should praise and, hopefully, learn from. So, the <em class="italic">blame</em> feature provides a great way to improve professional relationships between developers and strengthen <span class="No-Break">team morale.</span></p>
			<h3>I need to restore my copy of Foo.java</h3>
			<p>I’m sure <em class="italic">you’ve</em> never accidentally deleted a file after working on it all day, but we sure have. And I’m sure <em class="italic">you</em> are scrupulous about making backups for exactly that sort of event, but we sure aren’t. But since we always use a VCS, restoring a lost file is easy: every VCS gives you a simple way to view and restore the last version of any file that <span class="No-Break">it manages.</span></p>
			<h3>I want to revert to this morning’s version of all the files in the test directory</h3>
			<p>You’re not limited to restoring just the last version of a file; you can restore <em class="italic">any</em> version of a file, no matter how old it might be, so long as you added a snapshot that includes that version. For example, imagine that you spent hours rewriting automated tests to make them run faster, only to discover that your new tests are either slower or don’t work at all. Your VCS will let you replace just one file, all the files in a directory, or all the files in a project, with any old version of those files. Go ahead and edit whatever files you want, as often as you want. If you’re careful to regularly check your changes into your VCS, you can quit worrying about losing work or reverting to old code if the new code doesn’t <span class="No-Break">work out.</span></p>
			<h3>A colleague and I want to edit Foo.java at the same time</h3>
			<p>Probably the most frequently used feature of VCSs is their ability to safely partition the edits you’re making in a file so that they don’t overwrite work that other people are doing in the same file. Each developer has a <em class="italic">branch</em> of the code, where they can edit whatever files they want, even if other people are editing the same files on their branches. As each<a id="_idIndexMarker104"/> developer finishes their work, they <em class="italic">merge</em> their branch into the project’s stable code base. In this way, multiple developers can all edit the same file at the same time without anyone losing any work or having to coordinate ownership of <span class="No-Break">the file.</span></p>
			<h3>I need to deploy last Friday’s version of the code to the production environment</h3>
			<p>VCSs let you <em class="italic">tag</em> specific versions of your files so that it’s easy to view or restore those versions. For example, you may tag your entire code base before undertaking a major refactoring project so that it will be easy to revert to a known-good state if the refactoring doesn’t work out. More commonly, development teams often tag a specific version of the code so that they know exactly which code was deployed with a particular release. For example, you may apply a <strong class="source-inline">version-6-1-0</strong> tag to code that you deployed as version 6.1.0 of your product. When someone reports a bug in that version of your product, you know which version of your product’s files <span class="No-Break">to troubleshoot.</span></p>
			<h3>I want all my coworkers to have access to my edited code</h3>
			<p>When you edit a file, your team members must know that you’ve edited it and be able to see your edits. VCSs make it easy for you to <em class="italic">push up</em> your edits to a centralized location. Then other team members can <em class="italic">pull down</em> those changes onto their local computers, keeping the entire team <span class="No-Break">in sync.</span></p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor042"/>Why Git is popular</h2>
			<p>We’ve already mentioned that <a id="_idIndexMarker105"/>Git has become the dominant VCS. Why is that? Different Git users would give different explanations for its rise to the top, but here are some characteristics that <span class="No-Break">probably helped.</span></p>
			<h3>Pedigree</h3>
			<p>Git was invented by Linus Torvalds as a tool for storing and managing the source code for the Linux kernel. The fact that Git was originally used to store high-profile, successful, and widely adopted code such as the Linux kernel no doubt gave it instant credibility and cachet: if it’s robust and reliable enough for Linus and Linux, it’s good enough <span class="No-Break">for you.</span></p>
			<p>As an aside, it’s amazing that one programmer is responsible for launching two major software projects: Linux and Git. It’s as if Shakespeare invented the pencil just to make his plays easier <span class="No-Break">to write.</span></p>
			<h3>Simple branch management</h3>
			<p>As you’ll learn shortly, branches<a id="_idIndexMarker106"/> are one of the most important components of any VCS. Git was designed from the beginning to make it simple to create, use, and merge branches. The ease with which developers can work with branches encourages them to use lots of branches, which promotes safe and rapid <span class="No-Break">development workflows.</span></p>
			<h3>Speed</h3>
			<p>Git is fast. Adding new files, checking in changes, reverting to old code, and syncing files to incorporate coworkers’ edits – these operations all happen in just a few seconds, even with large projects. In particular, creating, using, and merging branches are all lightning-fast operations, and that’s one of the key reasons why developers love working with Git <span class="No-Break">so much.</span></p>
			<h3>Reliability</h3>
			<p>You may think that reliability would be basic table stakes for any VCS: if the VCS loses your files or edits, it’s useless at its role. But a surprising number of VCSs over the years have been less than 100% reliable. A hundred-person development team that one of us worked on in the early 2000s used the dominant proprietary VCS of the time, and even though it was thought of as the best-in-breed of that sort of tool, it frequently lost or scrambled <span class="No-Break">our edits.</span></p>
			<p>Git is famously reliable. It’s a complex tool, and if you don’t understand exactly how to use its commands, you could inadvertently lose data through human error. But it’s virtually unheard of for Git to suffer from technical glitches that result in data loss. It’s trusted by countless teams of skeptical software engineers around the world, and that trust <span class="No-Break">is well-earned.</span></p>
			<h3>Distributed architecture</h3>
			<p>Before Git, many VCSs used a <em class="italic">centralized</em> architecture. That means that to work on a file, you needed to fetch its latest version from a central server, make edits, and then resubmit that file to the <a id="_idIndexMarker107"/>central server so that other team members could <span class="No-Break">access it.</span></p>
			<p>There are a few problems with a centralized architecture. First, some (but not all) centralized VCSs <em class="italic">lock</em> any files that you’ve checked out, so no one else can make changes to those files while you’re editing them. This results in a lot of “<em class="italic">Hey, are you done with </em><strong class="source-inline">Foo.java</strong><em class="italic"> yet?</em>” conversations in the workplace, which creates an awkward, inconvenient, and <span class="No-Break">annoying workflow.</span></p>
			<p>The second problem with using a VCS with a centralized architecture is that it requires you to be connected to that central server whenever you need to check out a file or check in edits. You can’t work effectively without internet connectivity. This is less of a problem than it used to be, but there are still times when you’re between hot spots and still want to get <span class="No-Break">work done.</span></p>
			<p>Centralized architectures also create a single point of failure. If the server goes down, all the developers are dead in the water. If it loses data or is physically destroyed, it could be days before the data is restored or the hardware <span class="No-Break">is rebuilt.</span></p>
			<p>Finally, centralized architectures don’t always scale well as development teams grow. Rapidly growing teams that rely on an underpowered VCS server can find their work blocked as they queue to access <span class="No-Break">that server.</span></p>
			<p>Fortunately, the distributed architecture that Git is built around solves all these problems. These problems vanish when you have many copies of the project’s files on different computers. When using a distributed VCS, each developer has a copy of the entire project on their local computer. This includes all the files, edit history, tags, commit messages, and other metadata needed to let them work on the files without any connection to a <span class="No-Break">central server.</span></p>
			<p>How does this strategy help with the problems faced by centralized VCSs? First, if every developer has a local copy of all the files in the project, there’s no concept of <em class="italic">locking</em> a file that you’re editing: anyone can edit their local copy of any files at any time. Second, there’s no need to contact a central server to check out files, and there’s no need to contact a server to check in your edits. You can work locally for as long as you want. It’s true that, eventually, you’ll need to sync your edits to a server so that your coworkers can see your edits (and you can see theirs), but you can do that as often or as infrequently as makes sense for your team. Third, since there’s a copy of the entire project’s files on every developer’s machine, there’s no longer a single point of failure. If the central server that you use to sync changes goes down, you can designate any developer’s machine as a <a id="_idIndexMarker108"/>temporary central server while you rebuild the original server. Finally, because developers who use a distributed VCS sync their code with the central server far less often than developers who use a centralized VCS to check files in and out of that server, distributed VCSs scale much better than their centralized competitors. Most teams who use Git experience no VCS-related scaling problems as they add new <span class="No-Break">team members.</span></p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor043"/>Drawbacks of Git</h2>
			<p>Remember how <a id="_idIndexMarker109"/>we mentioned that Git gained credibility by being invented by Linus Torvalds? Unfortunately, there’s a downside to this: it was designed to fit Linus’s mind, not yours. This means that its commands can be inconsistent, confusing, and counterintuitive. To give just one example, let’s look at how one command uses three different ways to modify <span class="No-Break">its behavior:</span></p>
			<ul>
				<li><strong class="source-inline">git branch</strong> lists all <span class="No-Break">available branches.</span></li>
				<li><strong class="source-inline">git branch foo</strong> makes a new branch <span class="No-Break">called </span><span class="No-Break"><em class="italic">foo</em></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">git branch --delete foo</strong> deletes a branch <span class="No-Break">called </span><span class="No-Break"><em class="italic">foo</em></span><span class="No-Break">.</span></li>
			</ul>
			<p>You might expect these commands to be the <span class="No-Break">following instead:</span></p>
			<ul>
				<li><strong class="source-inline">git branch --list</strong> (this does work but isn’t necessary and no one <span class="No-Break">uses it)</span></li>
				<li><strong class="source-inline">git branch --</strong><span class="No-Break"><strong class="source-inline">create foo</strong></span></li>
				<li><strong class="source-inline">git branch --</strong><span class="No-Break"><strong class="source-inline">delete foo</strong></span></li>
			</ul>
			<p>But that’s not the case; you must remember the different option syntaxes instead. And that’s just for <span class="No-Break">one command.</span></p>
			<p>The other big problem with Git is that it’s so big. It has so many features and options and configurable settings that it can seem overwhelming. The official reference documentation, a book called <em class="italic">Pro Git</em>, is 511 pages long! When you’re getting started with the tool, it’s easy to get the sense that you’ll never know enough about Git’s concepts and commands to be able to use it productively, and you may wonder how anyone is ever able to get to grips with something <span class="No-Break">so complicated.</span></p>
			<p>Fortunately, you don’t need to know all the ins and outs of Git’s inconsistencies and syntactical complexities, and<a id="_idIndexMarker110"/> you don’t need to know all the features that Git provides. You just need to know a handful of common commands and their variants to perform 95% of the Git-related tasks you need. Most Git users learn 20 or so common operations, commit those to memory over time, and look up the details of other Git operations only as needed. <em class="italic">So, don’t panic, and don’t try to learn and memorize all of Git.</em> If you feel comfortable with the simple commands and concepts described in this chapter, you’re equipped to do real work with Git. It may turn out to be all you’ll ever need from <span class="No-Break">the tool.</span></p>
			<p>That’s enough of an introduction to Git. Now, it’s time to look at some <span class="No-Break">actual commands.</span></p>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor044"/>Committing code to keep it safe</h1>
			<p>To benefit from all the <a id="_idIndexMarker111"/>advantages described previously, you need to know how to add files to Git. How do you <span class="No-Break">do that?</span></p>
			<p>First, let’s discuss the concept of a <strong class="bold">repository</strong>, which is often shortened to <strong class="bold">repo</strong> A repository is a place where Git <a id="_idIndexMarker112"/>stores a project’s files and a history of all the changes made to those files. It’s the bank vault where it puts files to keep <span class="No-Break">them safe.</span></p>
			<p>There are two main ways to create a repository. The first way is to convert an ordinary directory on your Linux, macOS, or Windows filesystem into a Git repository. This is easy: use the <strong class="source-inline">git init</strong> command from inside the directory, and voilà – it turns into a Git repository. Then, you can use the <strong class="source-inline">git status</strong> command to prove that it’s <span class="No-Break">a repo.</span></p>
			<p>Let’s use those commands to create a new repository for our Hats for Cats project. First, make a new directory that will become a repository, and move into that directory (the example in this chapter is using a Linux Terminal, so the prompt and output may look slightly different if you use another terminal or OS, but the concepts will be <span class="No-Break">the same):</span></p>
			<pre class="console">
$ mkdir hats-for-cats
$ cd hats-for-cats</pre>
			<p>Pro<a id="_idTextAnchor045"/>ve that it’s not a Git <span class="No-Break">repo yet:</span></p>
			<pre class="console">
$ git status
fatal: not a git repository (or any of the <a id="_idTextAnchor046"/>parent directories): .git</pre>
			<p>Turn th<a id="_idTextAnchor047"/>e directory into a Git repo with the <strong class="source-inline">git </strong><span class="No-Break"><strong class="source-inline">init</strong></span><span class="No-Break"> command:</span></p>
			<pre class="console">
$ git init</pre>
			<p>Now, watch how <strong class="source-inline">git status</strong> doesn’t explicitly tell us that we’re in a repo, but it does provide information that only makes sense if the directory has been turned into a repository. It tells <a id="_idIndexMarker113"/>us that we’re on the <strong class="source-inline">main</strong> branch, that Git is not tracking any files in the repository, and that we haven’t edited any files in this directory that we may want to ask Git <span class="No-Break">to manage:</span></p>
			<pre class="console">
$ git status
On branch main
Your branch is up to date with 'origin/main'.
nothing to commit, working tree clean</pre>
			<p>The second, and probably more common, way to create a repository is to copy an existing repository from another computer using the <strong class="source-inline">git clone</strong> command. Earlier in this chapter, we talked about how Git’s distributed architecture means that each team member has a full copy of their project’s Git repository on their computer. Cloning is how you download a new copy of that repo from someone else’s computer to your computer. We’ll talk about this process in detail later when we discuss remote repositories. For now, just understand that if you’re working as a member of a software development team, most of the time, you’ll be cloning a repository from another computer instead of creating a new repository just on <span class="No-Break">your computer.</span></p>
			<p>Now that we have a repository, let’s add a file to it. For this example, let’s add a to-do list. First, use the <strong class="source-inline">touch</strong> command or a text editor to create a file called <strong class="source-inline">todo.txt</strong> in the <strong class="source-inline">hats-for-cats/</strong> directory. Fill the file with whatever content you want or leave it empty. Git can manage empty files <span class="No-Break">just fine:</span></p>
			<pre class="console">
$ touch todo.txt</pre>
			<p>Your directory contains a file, but Git is not tracking that file yet, since you haven’t officially added it to the repository. Doing so is a <span class="No-Break">two-step process:</span></p>
			<ol>
				<li>Move one or more files into something called the <span class="No-Break"><em class="italic">staging area.</em></span></li>
				<li><em class="italic">Commit</em> all the files in the <span class="No-Break">staging area.</span></li>
			</ol>
			<p>It’s important to understand that a file is not stored in Git, meaning that Git will not manage the versions of that file until<em class="italic"> you stage it and then </em><span class="No-Break"><em class="italic">commit it</em></span><span class="No-Break">.</span></p>
			<p>Remember how we talked about VCSs making “snapshots” of the state of your files at a particular time? This stage-and-commit process is how you make a new snapshot with Git. This means you <a id="_idIndexMarker114"/>are in complete control of when to make snapshots, and also of what files are included in each snapshot. If you’re editing <strong class="source-inline">foo.py</strong> and <strong class="source-inline">bar.py</strong> but only want to snapshot <strong class="source-inline">foo.py</strong> right now, just add that file to your staging area and commit it. When it’s time to make a snapshot with edits to <strong class="source-inline">bar.py</strong>, add that file to the staging area, optionally add <strong class="source-inline">foo.py</strong> as well if you want to snapshot any edits you made to it since the last time you snapshotted it, and then commit the file(s) that is in the <span class="No-Break">staging area.</span></p>
			<p>You may have noticed that we’ve talked about staging and committing both new files and edits to existing files. That’s because you use the same stage-and-commit process for both cases. You may find it easiest to think of staging and committing as something you do to capture <em class="italic">any changes to files</em>, where changes can take four <span class="No-Break">different forms:</span></p>
			<ul>
				<li>Creating a <span class="No-Break">new file</span></li>
				<li>Editing the content of an <span class="No-Break">existing file</span></li>
				<li>Renaming or moving a file (as far as the filesystem is concerned, these are the <span class="No-Break">same operation)</span></li>
				<li>Deleting <span class="No-Break">a file</span></li>
			</ul>
			<p>No matter which of these operations you perform, when you add one or more files to the staging area and then commit, you’re making a new Git snapshot of the state of whatever files were in the <span class="No-Break">staging area.</span></p>
			<p>You might be wondering why the stage-and-commit dance contains two separate steps. Couldn’t Git just provide a single command to make a new snapshot of a file? The reason for this extra complication is to allow you to include <em class="italic">multiple files in a single commit</em>. For example, you may edit a source code file, edit some associated test code that lives in a different file, and finally edit a documentation file, all as part of one bug fix. You’d want to include all three of these files in a single commit since the edits to all the files logically <span class="No-Break">belong together.</span></p>
			<p>First, let’s stage your new <strong class="source-inline">todo.txt</strong> file using the <strong class="source-inline">git add</strong> command. This doesn’t move or copy the file anywhere. Rather, it adds an invisible label to the file saying that it is in the <span class="No-Break">staging area:</span></p>
			<pre class="console">
$ git add todo.txt</pre>
			<p>If you run <strong class="source-inline">git status</strong> again, you’ll see that <strong class="source-inline">todo.txt</strong> is now included in a list of <em class="italic">changes to be committed</em>, which means that it’s been added to the staging area but hasn’t been <span class="No-Break">committed yet:</span></p>
			<pre class="console">
$ git status
On branch main
Your branch is up to date with 'origin/main'.
Changes to be committed:
  (use "git restore --staged &lt;file&gt;..." to unstage)
        new file:   todo.txt</pre>
			<p>Now, you can commit it with the <strong class="source-inline">git commit</strong> command. But first, a word about commit messages. An<a id="_idIndexMarker115"/> important part of every commit is the human-readable commit message that the committer must provide. The easiest way to add this message is as a parameter to <strong class="source-inline">git commit</strong>, using the <strong class="source-inline">--</strong><span class="No-Break"><strong class="source-inline">message</strong></span><span class="No-Break"> option:</span></p>
			<pre class="console">
$ git commit --message "add list of tasks to do"</pre>
			<p>If you run <strong class="source-inline">git status</strong> again, you’ll see that no files are waiting to be committed, which means your to-do list has been safely stashed in the repository, and all future edits to it will be tracked by Git. Congratulations, you’ve just performed your first work <span class="No-Break">with Git!</span></p>
			<p>Let’s pause for a minute and talk about what Git includes with every commit. You’ve already learned that a commit contains the contents of any file(s) included in that commit and a message that describes the purpose of the commit, but there are a few other pieces of information it includes as well. Here’s the <span class="No-Break">complete list:</span></p>
			<ul>
				<li>Any changes made to the file’s contents (or the filename or location in <span class="No-Break">the filesystem).</span></li>
				<li>A 40-character string of hexadecimal<a id="_idIndexMarker116"/> digits that’s called a <strong class="bold">Secure Hash Algorithm</strong> (<strong class="bold">SHA</strong>), which is the code that generates this string based on the contents of the committed files. A commit’s SHA uniquely identifies that commit; think of it as a unique <em class="italic">name</em> for that commit. SHAs are not sequential: each SHA is<a id="_idIndexMarker117"/> completely different from the SHA of the <span class="No-Break">previous commit.</span></li>
				<li>The name and email of the person who made <span class="No-Break">the commit.</span></li>
				<li>A timestamp of when they made <span class="No-Break">the commit.</span></li>
				<li>A human-readable message describing why they made <span class="No-Break">the commit.</span></li>
				<li>A pointer to the previous commit (or parent commit) on the branch. We’ll introduce the concept of branches in the next section and talk about this pointer <span class="No-Break">more then.</span></li>
			</ul>
			<p>The <strong class="source-inline">git log</strong> command shows you all this information for all the commits on your current branch (again, we’ll explain branches in more detail later). Let’s imagine that you’ve made two commits: one to create an empty to-do list and another to add an item to that list. Running <strong class="source-inline">git log</strong> gives an output similar to <span class="No-Break">the following:</span></p>
			<pre class="console">
$ git log
commit 7d4c98438ade780531e1baa283b3239c21943171 (HEAD -&gt; master)
Author: George Spelvin &lt;george.spelvin@example.com&gt;
Date:   Tue Jan 4 09:57:37 2022 -0800
    add first item to list
commit 63ea581d1bc693dac159c146fa10d1cbfa4e6366
Author: George Spelvin &lt;george.spelvin@example.com&gt;
Date:   Sun Jan 2 12:31:27 2022 -0800
    add list of tasks to do</pre>
			<p>This output includes information for your two commits, with the most recent commit at the top. Can you spot the SHA, author information, timestamps, and commit message for each commit? If you’re running these commands on your computer, you’ll see different details for each commit, but the format of the output will be <span class="No-Break">the same.</span></p>
			<p>In this example, all the commit information is for commits that you’ve made. But that’s simply because you’re the only person who has added commits to this branch. If other people had made commits to the same branch, you would see information for their commits in this output <span class="No-Break">as well.</span></p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor048"/>Excluding files from a repository</h2>
			<p>At this point, you might be<a id="_idIndexMarker118"/> thinking that it would be wise to stage and commit <em class="italic">all</em> the files in a project. But there are a few types of files that you usually do not want to store in Git or any other VCS. These include, but are not limited to, <span class="No-Break">the following:</span></p>
			<ul>
				<li>Files that are generated from <span class="No-Break">other files</span></li>
				<li>Extremely <span class="No-Break">big files</span></li>
				<li>Files that <span class="No-Break">contain secrets</span></li>
			</ul>
			<p>The first category includes files such as executables that are compiled from source code, or PDFs that are generated from the source text that’s stored in Markdown. Since you can always regenerate these files from their sources, there’s no need to store them in Git. Also, putting them in Git introduces the possibility of <em class="italic">drift</em>, where the source files and the generated files are out of sync with each other. For example, the source file may contain code from last week, while the compiled executable may contain code from last month. This can cause all sorts of <span class="No-Break">unexpected problems.</span></p>
			<p>Big files pose a different sort of problem. If you add a 5 GB ISO file or a 10 GB dataset, then anyone who copies your project’s repository to their local machine will be forced to download that file. We mentioned earlier that Git is fast, but there’s nothing it can do about congested or slow networks. Since copying repositories is a fairly common operation among Git users, including enormous files in your repository is something you’d generally like to avoid. It often makes more sense to put these files outside of Git, on a shared drive or some other accessible data storage system. Removing a large file after you’ve added it won’t solve the problem. Because Git keeps a record of the entire edit history of every file ever added to the repository, that large file will stick around in your repository forever, annoying you and your coworkers every time someone copies the repo to their <span class="No-Break">local computer.</span></p>
			<p>Finally, secrets such as deploy keys, SSH private keys, or passwords usually should not be stored in Git. As explained in the previous paragraph, any secrets that you commit to a repository will be there forever. Unless your IT and Git administrators are extremely careful about limiting permissions to repositories, this means they can be viewed by anyone with access to your repository. So, these sorts of things are normally stored not in Git, but in a specially designed system that’s dedicated to keeping sensitive <span class="No-Break">data safe.</span></p>
			<p>This is an important topic, so let’s investigate it further by looking at a concrete example. Imagine that your <strong class="source-inline">hats-for-cats/</strong> directory contains a file called <strong class="source-inline">personal-notes.txt</strong> and a directory called <strong class="source-inline">.ide-config/</strong>. The former is where you store ideas for project features as they occur to you, while the latter holds several files that your IDE uses to <a id="_idIndexMarker119"/>configure the project on your local machine. You may not want to share either of these with the other members of your development team since the ideas are meant just for your eyes and the configuration files will only work with your <span class="No-Break">computer setup.</span></p>
			<p>You can keep this file and directory private simply by never using the <strong class="source-inline">git add</strong> command to add them to your project’s Git repository. That works, but there’s a problem with this approach. Whenever you run <strong class="source-inline">git status</strong> to find out if there are any edited files that you should add and commit, Git will always point out that <strong class="source-inline">personal-notes.txt</strong> and <strong class="source-inline">.ide-config/</strong> are not in <span class="No-Break">the repository:</span></p>
			<pre class="console">
$ git status
On branch main
Untracked files:
  (use "git add &lt;file&gt;..." to include in what will be committed)
        .ide-config/
        personal-notes.txt</pre>
			<p>There’s a simple solution to this problem: create a new file called <strong class="source-inline">.gitignore</strong> in the root of your project’s directory. For the content of this file, add the names of any files or directories that you’d like Git to ignore. You can add explanatory comments by starting a line with a hash character. The following code in <strong class="source-inline">.gitignore</strong> instructs Git to exclude the files we’ve been <span class="No-Break">talking about:</span></p>
			<pre class="console">
# notes to myself that are not for public consumption personal-notes.txt # configuration files for my IDE .ide-config/</pre>
			<p>You need to add this <strong class="source-inline">.gitignore</strong> file to the repository, just like any other file you want Git <span class="No-Break">to track:</span></p>
			<pre class="console">
$ git add .gitignore
$ git commit --message "exclude notes file and IDE config directory"</pre>
			<p>Thanks to <strong class="source-inline">.gitignore</strong>, Git no longer warns you about uncommitted files and directories when you run <span class="No-Break"><strong class="source-inline">git status</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
$ git status
On branch main
nothing to commit, working tree clean</pre>
			<p>It’s not unusual for large projects to <a id="_idIndexMarker120"/>end up with tens or even hundreds of entries in <strong class="source-inline">.gitignore</strong>, and we encourage you to use this feature to keep your Git repository clean and your <strong class="source-inline">git status</strong> <span class="No-Break">output uncluttered.</span></p>
			<p>Let’s review the commands and concepts you’ve learned about in this section for keeping code safe by committing it to a <span class="No-Break">Git repository:</span></p>
			<ul>
				<li>Use <strong class="source-inline">git init</strong> or <strong class="source-inline">git clone</strong> to create a Git repository on <span class="No-Break">your computer.</span></li>
				<li>Use <strong class="source-inline">git add</strong> to add one or more files to Git’s <span class="No-Break">staging area.</span></li>
				<li>Use <strong class="source-inline">git commit --message "&lt;MESSAGE&gt;"</strong> to make a new Git commit (or snapshot) that includes any files that were in the <span class="No-Break">staging area.</span></li>
				<li>Use <strong class="source-inline">git status</strong> to see if you have edited files waiting to be moved to the staging area, or staged files waiting to <span class="No-Break">be committed.</span></li>
				<li>Use <strong class="source-inline">git log</strong> to see information about all the commits that have been made to your <span class="No-Break">current branch.</span></li>
				<li>Use a <strong class="source-inline">.gitignore</strong> file to exclude certain files or directories from <span class="No-Break">the repository.</span></li>
			</ul>
			<p>Now, let’s learn how to <em class="italic">tag</em> a particular<a id="_idIndexMarker121"/> version of the files that you so carefully committed to Git so that you can easily view or revert to that version in <span class="No-Break">the future.</span></p>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor049"/>Tagging commits to identify versions of code</h1>
			<p>Now that you understand <a id="_idIndexMarker122"/>how and why developers commit code to Git, we can explain tagging. Tagging is simple: it’s a way to add a permanent label to a commit. There are many reasons to tag, but the two most common are to mark the <a id="_idIndexMarker123"/>exact version of code that is released to customers and to have a convenient way to return to a particular version of the code if you need to revert a large batch of changes. Let’s look at an example <span class="No-Break">of each.</span></p>
			<p>Imagine that Hats for Cats is ready to release version <strong class="bold">0.1-beta</strong> to users. Tagging a particular commit with that version number lets you know exactly what features have been deployed into production and are available to your users, which tells you which version of the code to fix as you triage bug reports. Adding this sort of identification via a tag is easy in Git. First, make sure that you have committed all the edits to all the files you want to include in your release. Then, use the <strong class="source-inline">git tag</strong> command to add a tag representing the version number to the latest commit on <span class="No-Break">your branch:</span></p>
			<pre class="console">
$ git tag version-1-0-beta</pre>
			<p>If you run <strong class="source-inline">git log</strong>, you’ll see that Git has applied the tag to your <span class="No-Break">latest commit.</span></p>
			<p>As a separate example, imagine that you decide to undertake a major refactoring to change your classes to use a more complicated class inheritance structure. You know how easy it is to mess up this kind of large-scale change, and you want an easy way to return to today’s version of pre-refactored code in case everything goes sideways. Tagging is just <span class="No-Break">the solution:</span></p>
			<pre class="console">
$ git tag before-class-reorganization</pre>
			<p>Tagging has many options, but two of the most useful are <strong class="source-inline">--delete</strong> and <strong class="source-inline">--list</strong>, both of which do exactly what you would expect. Try them <span class="No-Break">and see:</span></p>
			<pre class="console">
$ git tag --list
$ git tag --delete version-1-0-beta</pre>
			<p>That’s tagging in a nutshell. As with most Git commands, there’s much more you can do with tagging, but this covers the basics. Fortunately, you now know as much about tagging as most Git users, so <a id="_idIndexMarker124"/>don’t worry about exploring <strong class="source-inline">git tag</strong> further unless you need more flexibility or features when it comes to marking versions of <span class="No-Break">your files.</span></p>
			<p>You’ve now mastered<a id="_idIndexMarker125"/> the fundamentals of storing your files in Git for safekeeping, excluding files that you don’t want to store in Git, and labeling certain commits for easy future reference. Now, it’s time to learn how to edit, store, and label files in a way that doesn’t step on the toes of other developers who might be working on the same files. It’s time to look at <span class="No-Break">Git branches!</span></p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor050"/>Branching code for developing in an isolated space</h1>
			<p>After commits, <strong class="bold">branches</strong> are probably the most important concept in Git. Strictly speaking, you don’t need to know anything about branches and branching to use Git. This is especially true if you’re a solo <a id="_idIndexMarker126"/>developer. But any non-trivial software development effort that involves more than one person will generally make heavy use of branches. Let’s figure out what they are and why we <span class="No-Break">need them.</span></p>
			<p>A branch is just a series of ordered commits. Remember when we said that each commit includes a backward pointer to the previous commit? If you follow those backward pointers from the latest commit back to the first commit ever made to the repository, you’ve just described the branch that your commit is on. <em class="italic">Again, a branch is just a series of commits, assembled in a particular order, linked by </em><span class="No-Break"><em class="italic">backward-pointing arrows</em></span><span class="No-Break">.</span></p>
			<p>Whenever you’re working on files within a Git repository, you’re <em class="italic">on</em> exactly one branch. This means that you can only see the versions of files that are on that branch, and any commits you make will only be added to that branch. Or, more technically, any commits you make while on that branch will include a backward-pointing arrow that links the commit to the previous commit on that <span class="No-Break">same branch.</span></p>
			<p>You can think of being on a branch as analogous to driving down a street. Imagine a town with only two streets. Main Street runs south to north. First Street forks off Main Street, runs parallel to it for a few blocks, and then eventually merges back into Main Street. Your car must be on exactly one of these two streets at any time. To stretch the analogy a little, imagine there’s a helicopter with a huge magnet that can pick your car up and move it between Main Street and First Street whenever you want. To make the analogy even stranger, pretend <a id="_idIndexMarker127"/>there’s a child in the back seat of your car who throws marbles out of the open window onto the street every block or so. In this analogy, the streets represent <em class="italic">branches</em>, the car represents <em class="italic">a developer</em>, the marbles represent <em class="italic">commits</em> that the developer adds to whatever branch they’re on, and the helicopter represents a <em class="italic">Git command</em> (which we’ll learn about soon) that lets the developer switch to any branch they want, whenever <span class="No-Break">they want:</span></p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/B18073_Fig_2.1.jpg" alt="Figure 2.1 – Streets and marbles, representing branches and commits" width="913" height="679"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Streets and marbles, representing branches and commits</p>
			<p>Every repository has at least one branch, informally referred to as the <strong class="bold">default branch</strong>. Branches have formal names, and the <a id="_idIndexMarker128"/>default branch is almost always formally named <strong class="bold">main</strong> or <strong class="bold">master</strong>, with the former now <span class="No-Break">generally preferred.</span></p>
			<p>For reasons explained earlier, drawings of branches usually include arrows from each commit to the previous commit on<a id="_idIndexMarker129"/> the branch. In other words, the arrows point backward in time, from later branches to earlier branches. So, if your repository has one<a id="_idIndexMarker130"/> branch called <strong class="bold">main</strong> with three commits on it (called <strong class="bold">A</strong>, <strong class="bold">B</strong>, and <strong class="bold">C</strong>), and another branch called <strong class="bold">branch-a</strong> with two commits on it (called <strong class="bold">D</strong> and <strong class="bold">E</strong>), and <strong class="bold">branch-a</strong> branched off from <strong class="bold">main</strong>, you could draw your repository’s state <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/B18073_Fig_2.2.jpg" alt="Figure 2.2 – Branches and commits" width="832" height="329"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Branches and commits</p>
			<p>Why do you need branches? <em class="italic">They let you develop code that is safely isolated from the stable code base until it’s ready to be added to that code base</em>. Here’s a typical workflow to demonstrate how <span class="No-Break">this happens:</span></p>
			<ol>
				<li value="1">Your product code lives in a Git repository. The stable version of that code lives in a branch within that repo <span class="No-Break">called </span><span class="No-Break"><strong class="bold">main</strong></span><span class="No-Break">.</span></li>
				<li>You are assigned to write a feature for your product that lets users <span class="No-Break">log in.</span></li>
				<li>You create a branch <span class="No-Break">called </span><span class="No-Break"><strong class="bold">login-feature</strong></span><span class="No-Break">.</span></li>
				<li>You switch to the <span class="No-Break"><strong class="bold">login-feature</strong></span><span class="No-Break"> branch.</span></li>
				<li>You edit files and add one or more commits to <span class="No-Break">that branch.</span></li>
				<li>Other team members review the edits in those commits and give <span class="No-Break">you feedback.</span></li>
				<li>You add another commit that incorporates <span class="No-Break">the feedback.</span></li>
				<li>Your team lead approves your work, declaring that the login feature has been implemented properly. Your QA team may also sign off on <span class="No-Break">your work.</span></li>
				<li>You <em class="italic">merge</em> the <strong class="bold">login-feature</strong> branch into the <strong class="bold">main</strong> branch. This means that all the commits you <a id="_idIndexMarker131"/>made to the <strong class="bold">login-feature</strong> branch are now part of the <strong class="bold">main</strong> branch as well. Your login <a id="_idIndexMarker132"/>feature is now part of the product’s main <span class="No-Break">code base.</span></li>
				<li>Since the <strong class="bold">login-feature</strong> branch has been merged and no longer serves any purpose, you can safely <span class="No-Break">delete it.</span></li>
			</ol>
			<p>The important thing to notice in this workflow is that while you were developing the login feature, your partially complete code was <em class="italic">not</em> available in the main code base (that is, in the <strong class="bold">main</strong> branch). Your incomplete code was safely separated from your product’s stable code so that your code couldn’t destabilize it. The login feature wasn’t added to the main code base until it was formally reviewed, approved, and was passing all its tests. That’s what we mean by saying that branches let you develop your code in an isolated environment, away from other developers’ work and away from the stable <span class="No-Break">code base.</span></p>
			<p>This example involved just one developer, but typically, several developers will work on separate branches at the same time. For example, two developers might be working on branches to add new features (each on their own branches), and two other developers might be working on separate branches to fix bugs (each on their own branches). One particular developer may switch back and forth between multiple branches in a single day, as the focus of their work shifts from one task to another. The point is that branches are all separate from each other – when you’re on one branch, you can’t see or change code on the other branches until they are all eventually merged into the <span class="No-Break"><strong class="bold">main</strong></span><span class="No-Break"> branch.</span></p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor051"/>Git commands for managing branches</h2>
			<p>Let’s learn the Git commands<a id="_idIndexMarker133"/> that you need to follow the <a id="_idIndexMarker134"/>workflow <span class="No-Break">described previously.</span></p>
			<p>Here’s how to create a new branch <span class="No-Break">called </span><span class="No-Break"><strong class="source-inline">login-feature</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
$ git branch login-feature</pre>
			<p>This command shows a list of all the branches that exist in this repository, with an asterisk next to the branch that you’re <span class="No-Break">currently on:</span></p>
			<pre class="console">
$ git branch</pre>
			<p>There are two different commands you can use to switch to a different branch. They do the same thing, and you’ll see both in use. In this case, they switch you to the<strong class="source-inline"> </strong><span class="No-Break"><strong class="source-inline">login-feature</strong></span><span class="No-Break"> branch:</span></p>
			<pre class="console">
$ git checkout login-feature
$ git switch login-feature</pre>
			<p>It takes two commands to merge one<a id="_idIndexMarker135"/> branch (called the <em class="italic">source branch</em>) into another branch (called the <em class="italic">target branch</em>) so that all the commits on the source branch become part of the<a id="_idIndexMarker136"/> target branch. To merge all the commits that are in <strong class="source-inline">login-feature</strong> into <strong class="source-inline">main</strong>, first, make sure you are on the <span class="No-Break"><em class="italic">target</em></span><span class="No-Break"> branch:</span></p>
			<pre class="console">
$ git checkout main</pre>
			<p>Then, perform the merge while specifying the <span class="No-Break"><em class="italic">source</em></span><span class="No-Break"> branch:</span></p>
			<pre class="console">
$ git merge login-feature</pre>
			<p>Some organizations like to keep all branches around forever as a matter of historical record, but most organizations ask you to delete a branch once you’ve merged it into <strong class="source-inline">main</strong>. Here’s how to delete the <span class="No-Break"><strong class="source-inline">login-feature</strong></span><span class="No-Break"> branch:</span></p>
			<pre class="console">
$ git branch -–delete login-feature</pre>
			<p>If you haven’t merged a branch before you try to delete it, Git will warn you and will <em class="italic">not</em> delete that branch. You can force the branch to be deleted (for example, if you’ve created an experimental branch and want to delete it without merging), <span class="No-Break">like this:</span></p>
			<pre class="console">
$ git branch -–delete -–force experimental-branch</pre>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor052"/>Handling merge conflicts</h2>
			<p>When you try to merge one branch into another, you will sometimes run into what’s called a <em class="italic">merge conflict</em>. This <a id="_idIndexMarker137"/>means that someone else has edited the same lines of the same file that you have, and that they’ve already merged their branch into <strong class="source-inline">main</strong> before you got a chance to merge your branch into <strong class="source-inline">main</strong>. When you try to merge your branch, Git isn’t sure whether to keep the edits made by the other developer or the edits that you’re trying <span class="No-Break">to merge.</span></p>
			<p>To continue with your merge, you first need to resolve the merge conflict. There are several ways to do this. Many people find dedicated Git GUI tools such as Sourcetree (macOS and Windows) or Sublime Merge (Linux, macOS, and Windows) to be the easiest and most intuitive way to handle merge conflicts. Other people prefer to resolve merge conflicts manually, using Git terminal commands and a text editor. GitLab users have another option: you can use GitLab’s built-in graphical merge conflict resolution tool. Regardless of what approach you take, you’ll have to somehow tell Git which changes to accept, which changes to throw away, and when to continue with <span class="No-Break">the merge.</span></p>
			<p>Let’s see how the GitLab merge conflict resolution tool works. Imagine that you’re working on the <strong class="source-inline">login.py</strong> file on the <strong class="source-inline">new-login-message</strong> branch. After creating a merge request for that branch and committing some edits, you return to the merge request so that you can merge the branch, only to discover that the MR is blocked by a <span class="No-Break">merge conflict:</span></p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/B18073_Fig_2.3.jpg" alt="Figure 2.3 – Merge request blocked by a merge conflict" width="756" height="225"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Merge request blocked by a merge conflict</p>
			<p>Since you only edited one file, you know that someone else must have edited the same lines of the same file and merged their edits into the <strong class="source-inline">main</strong> branch before you had a chance to do so yourself. Now, Git is understandably confused about whether to accept your edits, their edits, or some hybrid. Until that gets straightened out, it can’t merge your <strong class="source-inline">new-login-message</strong> branch <span class="No-Break">into </span><span class="No-Break"><strong class="source-inline">main</strong></span><span class="No-Break">.</span></p>
			<p>GitLab gives you two options to proceed: you can either click <strong class="bold">Resolve conflicts</strong> to use the built-in GUI tool to resolve the merge conflict, or you can click <strong class="bold">Resolve locally</strong> to manually instruct Git on how to handle the merge by editing files on your computer’s copy of the repository and then pushing those edits back up to GitLab. The second of these strategies is beyond the scope of this book, so let’s focus on the first strategy: using GitLab to resolve the merge conflict. Note that this option only appears in the GUI during simple merge <a id="_idIndexMarker138"/>conflicts such as the one in this example. If you need to resort to complicated edits to combine parts of two separate commits, you will probably need to resolve the merge conflict locally and then push the resolution back up <span class="No-Break">to GitLab.</span></p>
			<p>In this example, you will want to use GitLab’s built-in merge conflict tool, so you must click <strong class="bold">Resolve conflicts</strong>. You will be taken to a page that shows which lines have conflicting edits. You will see that there’s only one line with conflicting edits, with your edit highlighted in green and the edit already made by someone else highlighted in blue. Let’s say you’ve changed the line “We’re glad you’re here” to “We’re really glad you’re here,” whereas the existing edit changes the same line to “We’re super glad <span class="No-Break">you’re here!”.</span></p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/B18073_Fig_2.4.jpg" alt="Figure 2.4 – Resolving a merge conflict within GitLab" width="729" height="493"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – Resolving a merge conflict within GitLab</p>
			<p>You decide that you like your edit better, so you click the <strong class="bold">Use ours</strong> button. This tells GitLab to keep your edit and throw away the existing, conflicting edit. After you enter a commit message and click <strong class="bold">Commit to source branch</strong>, GitLab creates a new commit on your <strong class="source-inline">new-login-message</strong> branch that resolves the merge conflict. This new commit triggers a pipeline run on<a id="_idIndexMarker139"/> your branch. Once that finishes, you’re free to merge the MR just like you normally would. Congratulations – the merge conflict has been successfully resolved and the merge <span class="No-Break">is complete!</span></p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/B18073_Fig_2.5.jpg" alt="Figure 2.5 – Merge conflict is resolved and MR is unblocked" width="661" height="216"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – Merge conflict is resolved and MR is unblocked</p>
			<p>It would be irresponsible to pretend that all merge conflicts are as straightforward to resolve as this example, but the general approach remains the same no matter how complicated things get: you tell GitLab which edits to keep, which edits to throw away, and how to combine edits when you want to mix and match edits on the same line of code or text. Many third-party, GUI-based Git tools have more powerful merge conflict resolution tools than GitLab offers, so don’t be afraid to try a different tool for this task if you find you need more firepower or just a different view of what’s <span class="No-Break">going on.</span></p>
			<p>This concludes our explanation of creating, committing to, and merging branches. We hope you now have an idea of why branches are one of Git’s most essential and popular features! But branches become even more powerful when you share them with other developers on your team, and when you can get access to branches that they’ve been working on. In the next section, you’ll learn how to work collaboratively <span class="No-Break">with branches.</span></p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor053"/>Syncing local and remote copies of repositories</h1>
			<p>Git can be a useful tool for solo developers, but it’s most often used within a team of developers. As we’ve already discussed, Git’s distributed architecture means that every developer on the team has a complete copy of the project’s repository, including all its commits, commit messages, branches, and all the other data and metadata that is included in a repository. Keeping<a id="_idIndexMarker140"/> these repositories synced, so that they all have the same information in them, is critically important. If my copy of the repository and your copy of the repository contain different files or different edits to the same files, then I can’t see what work you’ve done and vice versa. And if my copy of the repository doesn’t contain the branches that you’re adding commits to, I can’t review and approve your work. Synchronizing repositories isn’t an automatic process: it involves active participation by the developers. This section will explain how to <span class="No-Break">do this.</span></p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor054"/>The “golden” repository</h2>
			<p>Before showing you the commands for syncing repositories, we need to partially retract something we said earlier. Remember <a id="_idIndexMarker141"/>how we explained that one of the advantages of Git’s distributed architecture is that there’s no central server that all <a id="_idIndexMarker142"/>developers need to talk to when doing their work? That’s not strictly true. Git’s distributed architecture does require every developer to have a complete copy of the project’s repository, but the team needs to designate one of those repository copies as what we’ll call the <strong class="bold">golden</strong> repository. That’s the repository that is considered to contain the <em class="italic">latest version of the stable code base</em> and is the repository where your team releases software. I might be working on a feature on a branch on my computer, and you might be working on a bug fix on a branch on your computer, and we might have completed all of the edits needed to finish those tasks, but until we put our edits into the golden repository, they aren’t officially part of the project’s stable code base. Because of the special role that this golden repository has, I tend to think of it as a “first among equals” or the “repository <span class="No-Break">of record.”</span></p>
			<p><em class="italic">The golden repository is the copy of the repository that lives on the GitLab instance</em>. If your team of 20 developers uses GitLab, there will be at least 21 copies of your project’s repository: one on each developer’s computer and the golden copy on the GitLab instance. If the computer that hosts your GitLab instance is unavailable for some reason, you could temporarily designate the repository that’s on any developer’s computer as the team’s golden repository. But you would want to revert to using the GitLab instance’s copy as the golden repository as soon as it’s <span class="No-Break">available again.</span></p>
			<p>When we talk about syncing edits between different copies of the repository, this syncing always happens via the GitLab instance. In other words, if I’ve made commits to the repository on my local computer and want to make them available to my coworkers, I would <em class="italic">not</em> send those <a id="_idIndexMarker143"/>commits directly to each of their computers. Instead, I would send my commits to the golden repository, and then each developer would retrieve my commits from the <span class="No-Break">golden repository.</span></p>
			<p>The following diagram shows a workflow that allows one developer to share their commits with another developer by pushing and pulling the branch that contains those commits to and from the <span class="No-Break">golden repo:</span></p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/B18073_Fig_2.6.jpg" alt="Figure 2.6 – Sharing commits with coworkers via the golden repo" width="897" height="388"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – Sharing commits with coworkers via the golden repo</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor055"/>Configuring remote repositories</h2>
			<p>Before you can sync your<a id="_idIndexMarker144"/> repository with the golden repository, Git needs to know that the golden repository exists. Any repository copy that’s not on your local computer is called a “remote,” so an important prerequisite for syncing commits is to <span class="No-Break">configure remotes.</span></p>
			<p>You can use the following command to see a list of the names and URLs for any remotes that Git <span class="No-Break">knows about:</span></p>
			<pre class="console">
git remote --verbose</pre>
			<p>Earlier, we described two ways to get a repository onto your computer: <strong class="source-inline">git init</strong> and <strong class="source-inline">git clone</strong>. If you’re in a repository that you created with <strong class="source-inline">git init</strong>, and you ask Git to give you a list of remotes, it will return no output. It doesn’t know about any remotes yet, because you haven’t told it about any. But if you copied a repository to your machine using <strong class="source-inline">git clone</strong>, then Git already knows about one remote: the copy of the repository that you <span class="No-Break">cloned from.</span></p>
			<p>Before we get ahead of<a id="_idIndexMarker145"/> ourselves, let’s discuss how to clone a repository. As we mentioned previously, that’s the most common way to get a repository onto your computer, so it’s an important practice to be <span class="No-Break">familiar with.</span></p>
			<p>You can clone a repository from a computer that your local computer has network access to, but let’s concentrate on cloning a repository that’s hosted on a GitLab instance. This example assumes that the repository is hosted by the instance of GitLab that lives at <a href="https://www.gitlab.com">www.gitlab.com</a>. If you’re using a self-hosted version of GitLab instead of the <strong class="bold">Software-as-a-Service</strong> (<strong class="bold">SaaS</strong>) version that <a id="_idIndexMarker146"/>we’re using in this example, the cloning process is the same, except that the address of the repository you’re cloning will look <span class="No-Break">slightly different.</span></p>
			<p>To clone a GitLab-hosted repository, you need to know the address of that repository. There are several forms this address can take, but the two most common forms use the <strong class="bold">HTTPS</strong> protocol or the <strong class="bold">SSH</strong> protocol. Although either protocol will work, using the SSH protocol is generally preferred. It requires you to configure SSH keys to get started, but then you never need to enter credentials when interacting with that remote: the key infrastructure takes care of all authentications automatically. The HTTPS protocol, on the other hand, requires you to enter a username and password every time you use a Git command that talks to <span class="No-Break">that remote.</span></p>
			<p>You’ve already seen how to create a repository for our Hats for Cats project using <strong class="source-inline">git init</strong>, but now, let’s change gears and assume that there’s already a Hats for Cats repository on a GitLab instance, and you want to clone that repository to <span class="No-Break">your computer.</span></p>
			<p>First, you need to create public and private SSH keys using the <strong class="source-inline">ssh-keygen</strong> command in your computer’s terminal, and then upload the public key to your GitLab instance. GitLab has excellent documentation on how to do this that’s available at <a href="https://docs.gitlab.com/ee/ssh">https://docs.gitlab.com/ee/ssh</a>, so we’ll <a id="_idIndexMarker147"/>refer you to that instead of rehashing the instructions here. Note that you only have to do this process once, and then you’ll be authenticated whenever you’re interacting with any project on that GitLab instance from your same local computer. If you change to a different GitLab instance or a different local computer, you’ll need to repeat <span class="No-Break">the process.</span></p>
			<p>Now, you need to find the <a id="_idIndexMarker148"/>SSH address of the project. Log in to GitLab and navigate to the project. We haven’t formally introduced you to the GitLab GUI yet, so the instructions and the following screenshot may seem a little mysterious, but they’ll make more sense later when you’re more familiar with GitLab components <span class="No-Break">and navigation.</span></p>
			<p>On the main page for your project, as shown in <span class="No-Break"><em class="italic">Figure 2</em></span><em class="italic">.7,</em> click the <strong class="bold">Clone</strong> button. In the dropdown that appears, copy the address next to the <strong class="bold">Clone with </strong><span class="No-Break"><strong class="bold">SSH</strong></span><span class="No-Break"> label:</span></p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/B18073_Fig_2.7.jpg" alt="Figure 2.7 – Cloning a repository from GitLab" width="1153" height="754"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – Cloning a repository from GitLab</p>
			<p>Now that you’ve set up a key pair and have the project’s SSH address on your clipboard, navigate to the directory on the local filesystem that you want to contain the repository, and clone the remote repository to your computer using <strong class="source-inline">git clone</strong> and the repository’s SSH address. Your SSH address will look different from the one <span class="No-Break">shown here:</span></p>
			<pre class="console">
$ cd ~/code
$ git clone git@gitlab.com:cwcowell/hats-for-cats.git</pre>
			<p>The process of cloning defines<a id="_idIndexMarker149"/> a remote repository for you: it lets your local copy of the repo know that a remote copy exists at whatever URL you cloned it from. You can see this remote copy listed in the output of <strong class="source-inline">git </strong><span class="No-Break"><strong class="source-inline">remote -–verbose</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
$ git remote --verbose
origin  git@gitlab.com:cwcowell/hats-for-cats.git (fetch)
origin  git@gitlab.com:cwcowell/hats-for-cats.git (push)</pre>
			<p>Here, two remotes have been defined: the first is for getting other people’s commits, while the other is for sending your commits. Don’t worry about the distinction between these two; you can think of them as a single remote. You’ll also notice the word “origin” in the output. The golden copy of any repo is usually referred to as the “origin,” for reasons known only to the designers <span class="No-Break">of Git.</span></p>
			<p>If you created a repository using <strong class="source-inline">git init</strong> instead of <strong class="source-inline">git clone</strong>, you’ll need to create a Git project and repository on your GitLab instance to serve as the remote repository; then, you can use the <strong class="source-inline">git remote add</strong> command to let your local repo know that this remote repo exists. Because this is a much less common workflow than using <strong class="source-inline">git clone</strong>, we’ll let you look up the syntax for this command if you ever <span class="No-Break">need it.</span></p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor056"/>Pushing</h2>
			<p>So far, we’ve used the word “send” to describe the process of copying your local commits to the golden repo. But the official Git term is “push.” And the <a id="_idIndexMarker150"/>command you use to push commits is, unsurprisingly, <span class="No-Break"><strong class="source-inline">git push</strong></span><span class="No-Break">.</span></p>
			<p>Let’s go back to the scenario where you created a branch on your local repository called <strong class="bold">login-feature</strong>. Imagine that you’ve added a few commits to that branch and now, you want to push that branch up to the golden repository on the GitLab instance so that your teammates can look at the branch and the commits you made to it. To do this, make sure you’re in the branch you want to push, and then <span class="No-Break">push it.</span></p>
			<p>Before we show you the command for that, we should explain that there’s one wrinkle whenever you push a branch to a remote repository <em class="italic">for the first time</em>: you must tell the remote repository what to name its copy of your branch. Almost always, you will want the remote copy of the branch to have the same name as the local copy of the branch. The remote copy of your branch on the golden repo is sometimes informally called the “upstream” branch. To tell the <a id="_idIndexMarker151"/>remote repo to name the upstream branch <strong class="source-inline">login-feature</strong>, change to the branch you want to push, and then pass a few extra options to <span class="No-Break"><strong class="source-inline">git push</strong></span><span class="No-Break">:</span></p>
			<pre class="console">
$ git switch login-feature
$ git push --set-upstream origin login-feature</pre>
			<p>Notice that the word <strong class="source-inline">origin</strong> is included in these options. This tells Git which remote to push to, even though you only have one remote defined at this point. Also, it’s important to understand that you only have to set the upstream branch name once. From that point on, you can just run <strong class="source-inline">git push</strong> without any additional options to push the commits of your current branch up to the remote golden copy of <span class="No-Break">the repo.</span></p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor057"/>Fetching</h2>
			<p>So far, you’ve seen how to push <a id="_idIndexMarker152"/>your edits up to the golden repo so that your coworkers can see them. But how do you get their edits into your local repo? The first command you need to know is <strong class="source-inline">git fetch</strong>. This command talks to the golden repo and finds out if anyone has pushed any new branches or commits to existing branches up to the golden repo. Then, it relays that information to your local repository. <em class="italic">It does not update any branches or files on your local computer</em>. It simply collects metadata about any edits that have been made on the golden repo and tells your local repo about them, without making any changes to your local repo. This means that <strong class="source-inline">git fetch</strong> is a non-destructive, completely safe command that you can run whenever you want, as often as <span class="No-Break">you want.</span></p>
			<p>This command is useful because it lets you know if your branch is “behind” the golden repo’s copy of that branch: is it missing commits that are on the golden repo’s copy of the branch? This lets you know if you may experience a merge conflict if you try to push your changes up to the golden repo. If someone else has already changed the same files on the same branch on the golden repo, there’s no way you could know that unless you use <strong class="source-inline">git fetch</strong> to learn about changes that have happened there. So, if you’re wondering whether you’ve got all the latest edits on a branch, or you want to know if anyone has added any brand-new branches to the golden repo, <strong class="source-inline">git fetch</strong> is the way to get <span class="No-Break">that information.</span></p>
			<p>It’s worth repeating that <strong class="source-inline">git fetch</strong> gives you up-to-date information about the state of branches on the golden repo, but it <a id="_idIndexMarker153"/>doesn’t update any files on your local computer. To update your local files, you need to learn about one final <span class="No-Break">Git command.</span></p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor058"/>Pulling</h2>
			<p>To replace all the files on a local branch with updated versions of those files that may exist on the golden repo’s copy<a id="_idIndexMarker154"/> of that branch, switch to the appropriate branch and then <em class="italic">pull</em> <span class="No-Break">the changes:</span></p>
			<pre class="console">
$ git switch login-feature
$ git pull</pre>
			<p>If any edits have been made to that branch since you last ran <strong class="source-inline">git pull</strong>, Git will replace any local files on that branch with updated files from the golden repo’s copy of that <span class="No-Break">same branch.</span></p>
			<p>Remember that <strong class="source-inline">git pull</strong> only operates on one branch at a time. That is, it will only grab updated files from the golden repo <em class="italic">for the branch that you’re currently on</em>. There’s no way to grab all the edits from all the branches with a single use of <strong class="source-inline">git pull</strong>, but there’s also no obvious reason why you’d <span class="No-Break">want to.</span></p>
			<p>Let’s combine all the sync-related Git commands into a single workflow, to show you how you would keep your copy of the project’s repository in sync with the golden copy of <span class="No-Break">the repository:</span></p>
			<ol>
				<li value="1">On your local computer, use <strong class="source-inline">git switch</strong> to switch to the branch that you want to do your <span class="No-Break">work on.</span></li>
				<li>Use <strong class="source-inline">git fetch</strong> to grab information about whether the golden repo’s copy of your branch has any <span class="No-Break">new edits.</span></li>
				<li>Run <strong class="source-inline">git status</strong> to see if your local branch is “behind” the golden repo’s copy of the <span class="No-Break">same branch.</span></li>
				<li>If it is, update your local files with <span class="No-Break"><strong class="source-inline">git pull</strong></span><span class="No-Break">.</span></li>
				<li>Make and commit edits to the local copy of <span class="No-Break">the branch.</span></li>
				<li>Send all the commits on your local copy of the branch up to the golden copy of the branch with <span class="No-Break"><strong class="source-inline">git push</strong></span><span class="No-Break">.</span></li>
			</ol>
			<p>Having completed this explanation of syncing repository branches, you’re now equipped with all you need to know<a id="_idIndexMarker155"/> to do real work with Git! But if you find that you need to learn about concepts and commands we haven’t covered here, or if you’d like to see these same topics addressed with different explanations and examples, there are plenty of other places you can look for more information. Now, let’s take a look at some of the best <span class="No-Break">alternative resources.</span></p>
			<h1 id="_idParaDest-55"><a id="_idTextAnchor059"/>Additional resources for learning Git</h1>
			<p>A word of caution is needed at this point. You’ve only seen the most basic usages of the Git commands introduced in this chapter. There are <em class="italic">many</em> options available to change the behavior of these commands, and there are many different wrinkles and nuances to using them correctly in different situations. We’ve already mentioned that the important concept of resolving <a id="_idIndexMarker156"/>merge conflicts is beyond the scope of this lightning-fast introduction to Git, but some other important concepts and practices are likely to crop<a id="_idIndexMarker157"/> up in daily Git usage that we don’t have space to cover here, including <strong class="bold">rebasing</strong> and choosing between <strong class="bold">fast-forward merges</strong> and <strong class="bold">commit merges</strong>. We also can’t describe common troubleshooting processes when you find your files in an unwanted or unfamiliar condition while using Git. What we can do, however, is point you to some other resources that you can use to continue to expand your knowledge of Git and your repertoire of Git commands <span class="No-Break">and practices.</span></p>
			<p>With that in mind, here are our favorite Git references and <span class="No-Break">learning materials:</span></p>
			<ul>
				<li>GitLab has a very good four-page PDF cheat sheet that covers the most common Git concepts and commands. This is the first place we look when we need to remember how a basic command <span class="No-Break">works: </span><a href="https://about.gitlab.com/images/press/git-cheat-sheet.pdf"><span class="No-Break">https://about.gitlab.com/images/press/git-cheat-sheet.pdf</span></a><span class="No-Break">.</span></li>
				<li><em class="italic">Ry’s Git Tutorial</em>, by Ryan Hodson, is a fantastic tutorial for learning Git or refreshing your knowledge of its commands and concepts. It’s only available as a free Kindle ebook <span class="No-Break">on Amazon.</span></li>
				<li><em class="italic">Pro Git</em>, by Scott Chacon and Ben Straub, is too dense and dry to use as a tutorial, but it is a good reference. It’s where we turn when we need to look up an exotic command or find out all the options available for a common command such as <strong class="source-inline">git commit</strong>. It’s a free ebook available on the Git <span class="No-Break">website: </span><a href="https://git-scm.com/book/en/v2"><span class="No-Break">https://git-scm.com/book/en/v2</span></a><span class="No-Break">.</span></li>
				<li><em class="italic">Dangit Git!?!</em> is a website <a id="_idIndexMarker158"/>that shows you how to get out of a dozen or so of the most<a id="_idIndexMarker159"/> common Git jams. When we’ve made a mistake with Git commands and need to fix what we broke, this is where we look for <span class="No-Break">guidance: </span><a href="https://dangitgit.com/"><span class="No-Break">https://dangitgit.com/</span></a><span class="No-Break">.</span></li>
			</ul>
			<p>Remember that there’s no way you can learn or remember all of Git’s commands and options. We believe that it’s best to learn a handful of commands that you use every day, and then look up the additional commands and syntax for more complicated operations only as the need arises. A reference source such as <em class="italic">Pro Git</em> or the Git man pages will dazzle you with all the different ways you can configure these commands to make them work differently, and with all the additional commands that Git provides for unlocking the tool’s advanced features. But only wade into those waters if you want to; there’s no need to understand all the commands or options available to use Git productively. Even if you could somehow learn all of Git, the effort required would be far beyond the point of diminishing returns. Get comfortable with the concepts and commands presented here, practice with throwaway repositories, dip into reference sources as needed, and you’ll be all set to be a happy and effective <span class="No-Break">Git user.</span></p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor060"/>Summary</h1>
			<p>Pause, take a deep breath, and pat yourself on the back. You’ve learned a lot about a complicated tool in a very <span class="No-Break">short time.</span></p>
			<p>You now understand how and why programmers use VCSs to handle a wide variety of daily tasks and problems, and why Git’s features and architecture have helped it become the preferred VCS. You also know about the most used Git concepts <span class="No-Break">and commands.</span></p>
			<p>Now that you’ve completed this chapter, you can create new Git repositories using <strong class="source-inline">git init</strong> and <strong class="source-inline">git clone</strong>; add file edits with <strong class="source-inline">git add</strong> and <strong class="source-inline">git commit</strong>; tag commits for future reference with <strong class="source-inline">git tag</strong>; list, create, or delete branches with <strong class="source-inline">git branch</strong>; merge branches with <strong class="source-inline">git merge</strong> and resolve any merge conflicts that arise; and sync local branches with branches on the golden repo with <strong class="source-inline">git push</strong>, <strong class="source-inline">git fetch</strong>, and <span class="No-Break"><strong class="source-inline">get pull</strong></span><span class="No-Break">.</span></p>
			<p>You also know where to look to learn more about Git, whether you need tutorial steps, reference material, or <span class="No-Break">troubleshooting help.</span></p>
			<p>With this background in Git under your belt, it’s time to move from Git to GitLab. In the next chapter, you’ll learn how GitLab can make Git easier and more powerful. We’ll give you a basic understanding of GitLab’s components and GUI so that we can introduce you to the powerful concept of GitLab <span class="No-Break">CI/CD pipelines.</span></p>
		</div>
	</div>
</div>
</body></html>