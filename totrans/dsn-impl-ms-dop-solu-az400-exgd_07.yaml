- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Dependency Management
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖管理
- en: In part one of this book, you learned how to continuously deploy your application.
    In modern enterprise software development, applications are developed by cross-functional
    teams and involve complex solutions and projects. Complex solutions with hundreds
    of modules and functions have a greater probability of code duplication – that
    is, identical implementation for the same functionality within projects. Duplicated
    code is one of the cardinal sins of programming. You can solve problems by copying
    and pasting, but it usually creates maintenance nightmares later. **Don’t Repeat
    Yourself** (**DRY**) is a basic principle of software development aimed at reducing
    the repetition of information.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第一部分，你学习了如何持续部署你的应用程序。在现代企业软件开发中，应用程序是由跨职能团队开发的，涉及复杂的解决方案和项目。具有数百个模块和功能的复杂解决方案，更容易出现代码重复的情况——也就是说，在项目中同样的功能可能有相同的实现。重复的代码是编程中的严重错误之一。你可以通过复制粘贴解决问题，但这通常会在后期导致维护上的噩梦。**不要重复自己**（**DRY**）是软件开发的基本原则，旨在减少信息的重复。
- en: For a small or a single project, you may be able to handle dependencies on your
    own, but for complex solutions, a team will descend into **dependency hell**.
    One approach to solve this is by introducing package management. Developers need
    to identify the components to reuse within internal projects or from open source.
    Reusing libraries will increase the development velocity and the quality of the
    solution. Instead of copying and pasting code from one project to another, you
    can create a shared library using it. In this chapter, you will learn how to identify
    shared components and how to make them reusable using Azure Artifacts. In addition
    to this, you will learn how you can use Azure Artifacts for storing pipeline artifacts
    when working in a heterogeneous architecture. Here, you will also work with other
    **Continuous Integration** (**CI**)/**Continuous Deployment** (**CD**) tools than
    just Azure DevOps. To do so, you will learn how to use Azure Artifacts for Universal
    Packages.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个小型项目或单一项目，你可能能够自己处理依赖关系，但对于复杂的解决方案，团队将会陷入**依赖地狱**。解决这一问题的一种方法是引入软件包管理。开发人员需要识别在内部项目或开源项目中可复用的组件。重用库将提高开发效率和解决方案的质量。与其将代码从一个项目复制到另一个项目，不如使用它创建一个共享库。在本章中，你将学习如何识别共享组件，并如何使用Azure
    Artifacts使它们可复用。除此之外，你还将学习如何在异构架构中使用Azure Artifacts存储管道工件。在这里，你还将使用除了Azure DevOps之外的其他**持续集成**（**CI**）/**持续部署**（**CD**）工具。为此，你将学习如何使用Azure
    Artifacts进行通用软件包的管理。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Identifying shared components
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别共享组件
- en: Creating a feed for publishing packages
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建发布软件包的源
- en: Consuming packages
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用软件包
- en: Working with Universal Packages
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用通用软件包
- en: Exploring other tools
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索其他工具
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To experiment with the topics mentioned in this chapter, an Azure DevOps organization
    is required.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要实验本章提到的主题，需要一个Azure DevOps组织。
- en: Identifying shared components
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 识别共享组件
- en: Adopting DevOps practices, such as CI/CD, can greatly reduce the amount of time
    you have to spend on building and testing your applications. Besides building
    your applications, there are also many other concerns that you can address in
    your pipelines.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 采用如CI/CD等DevOps实践可以大大减少你在构建和测试应用程序时所需花费的时间。除了构建你的应用程序之外，你还可以在管道中解决许多其他问题。
- en: When you start adding more and more tasks to your pipelines, you might run into
    a situation in which a single execution of your pipeline starts taking too long.
    In order to combat this, you might be interested in splitting your solution up
    into smaller builds and maybe even repositories. Splitting solutions into smaller
    builds is not viable with monolithic applications, since it would break the build
    process. Microservice applications or solutions, which have components decoupled
    into separate projects, could adopt this approach to split the build process.
    To do this, you could build parts of that application in isolation and then use
    the results of these builds in your main application as ready-built components.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始在管道中添加越来越多的任务时，可能会遇到一个问题，即管道的单次执行时间过长。为了应对这一问题，你可能会希望将解决方案拆分为更小的构建，甚至可能是不同的仓库。将解决方案拆分为更小的构建对于单体应用程序而言是不可行的，因为这会破坏构建过程。微服务应用程序或解决方案，其中组件已解耦成独立的项目，可以采用这种方法来拆分构建过程。为此，你可以单独构建该应用程序的某些部分，然后将这些构建的结果作为现成的组件在主应用程序中使用。
- en: Componentization is a process to structure your projects into reusable components
    that application developers independently write and deploy.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 组件化是一个将项目结构化为可重用组件的过程，这些组件是应用开发人员独立编写和部署的。
- en: 'With source componentization, you split your solution into parts to use as
    shared projects. Imagine that you have two solutions that work closely together:
    one is a REST API and the other is a client package that you ship to your customers
    to work with that API. It is likely that in their source code, these two solutions
    share at least one project comprising common reusable objects, such as data models,
    that will serve as data contracts to exchange data between the two solutions.
    Here, you can also leverage package componentization and make a third solution
    with only the shared project, which you could then use as a package in your other
    solutions. Packages are rarely functional as a standalone unit.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过源组件化，你将解决方案拆分为多个部分，并作为共享项目使用。假设你有两个紧密协作的解决方案：一个是 REST API，另一个是你提供给客户使用该 API
    的客户端包。这两个解决方案在其源代码中很可能共享至少一个项目，包含共同的可重用对象，如数据模型，它们将作为数据契约来在这两个解决方案之间交换数据。在这里，你还可以利用包组件化，创建一个仅包含共享项目的第三个解决方案，然后将其作为包在其他解决方案中使用。包通常不是作为独立单元功能齐全的。
- en: 'Alternatively, what if you work in a team that is responsible for maintaining
    a whole series of solutions, and you find that you have complete namespaces that
    are copied and pasted between these solutions? It is not a desirable situation
    and one that probably comes with a lot of issues. What if you could write all
    of this code just once, build it, package it, and then reuse it in all these solutions?
    To summarize, three reasons for starting to work with packages and artifact feeds
    are as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你在一个团队工作，负责维护一整系列的解决方案，并且发现这些解决方案之间有完整的命名空间被复制和粘贴？这并不是一个理想的情况，而且可能会带来许多问题。如果你能够只编写一次这些代码，构建、打包，然后在所有这些解决方案中重用它们，会怎么样？总的来说，开始使用包和工件源的三个原因如下：
- en: Extracting shared components into packages
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将共享组件提取到包中
- en: Building packages that are used by other teams
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建其他团队使用的包
- en: Reducing build and CI times by splitting a larger solution into parts
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将较大的解决方案拆分为多个部分来减少构建和 CI 时间
- en: Tip
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: The three main aspects of dependency management are standardization, package
    formats and sources, and versioning.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖管理的三个主要方面是标准化、包格式和源、以及版本控制。
- en: In the remainder of this chapter, you will learn techniques for doing this by
    building packages out of (parts of) your application code, hosting them in a centralized
    location, and reusing them in one or more solutions.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章剩余部分中，你将学习如何通过将（部分）应用程序代码构建成包，托管在一个集中位置，并在一个或多个解决方案中重用它们。
- en: In all three scenarios, you might be looking to increase the reusability of
    the code, but also to reduce the time taken between checking for a change and
    receiving feedback for that change in the form of automated test results. Before
    you start breaking up your application, remember that moving a part of your solution
    to a separate component does not always achieve this.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在这三种情境中，你可能希望提高代码的可重用性，同时减少从检查更改到接收更改反馈（以自动化测试结果的形式）之间的时间。在开始拆分应用程序之前，请记住，将应用程序的某一部分移到独立组件中并不总是能实现这个目标。
- en: If you break your application up into three components and one remaining main
    part, make sure that you can build and test these three components completely
    in isolation, or at least close to 100% isolation. If you cannot test a component
    of your application in isolation, creating a separate repository and build for
    that component will actually increase the time between checking for a change and
    receiving feedback to you as a developer. Both separate builds might run quicker,
    but now you need to wait for two builds before you receive any feedback.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将应用程序拆分为三个组件和一个剩余的主要部分，请确保你能够完全在隔离环境中构建和测试这三个组件，或者至少接近 100% 的隔离。如果你无法在隔离环境中测试应用程序的某个组件，那么为该组件创建一个单独的代码库和构建过程实际上会增加你作为开发者检查变更和收到反馈之间的时间。两个单独的构建可能会更快运行，但现在你需要等待两个构建过程完成，才能收到任何反馈。
- en: Tip
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: If you break your application up into separate components, make sure that each
    component can be built and tested in a high degree of isolation.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将应用程序拆分为单独的组件，请确保每个组件能够在高度隔离的环境中构建和测试。
- en: As well as this, you have to make sure that making a reusable component out
    of part of your application makes sense from a conceptual point of view. For example,
    components that are addressing a cross-cutting concern such as logging libraries
    or database abstraction layers are great candidates for factoring out to shared
    libraries. (On a side note, after you have done so, you might also want to consider
    replacing your own general-purpose libraries with off-the-shelf alternatives –
    for example, for database abstraction, use Entity Framework, and for logging providers,
    use Serilog, NLog, and so on wherever possible.)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还必须确保将应用程序的一部分制作成可重用组件在概念上是合理的。例如，处理跨领域关注点的组件，如日志库或数据库抽象层，是非常适合提取到共享库中的候选者。（顺便提一下，完成此操作后，你可能还想考虑用现成的替代品替换自己的通用库——例如，对于数据库抽象，使用
    Entity Framework；对于日志提供程序，使用 Serilog、NLog 等，尽可能使用这些现成工具。）
- en: However, if splitting your solution into components makes sense, it can bring
    great benefits.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果将解决方案拆分为组件是合理的，它将带来很大的好处。
- en: Types of feeds
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 信息源的类型
- en: Once the solution has been separated into different components. some components
    will be reused by multiple teams and projects. A feed will be required to store,
    share, and manage these reusable components/packages.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦解决方案被拆分成不同的组件，一些组件将被多个团队和项目重用。此时将需要一个信息源来存储、共享和管理这些可重用的组件/包。
- en: There are many types of package feeds that can be hosted in Azure Artifacts.
    How you will use an artifact feed depends on the language and ecosystem used by
    the application.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure Artifacts 中，可以托管许多类型的包信息源。你将如何使用信息源取决于应用程序所使用的语言和生态系统。
- en: 'The following ecosystems are supported in Azure Artifacts:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 以下生态系统在 Azure Artifacts 中得到支持：
- en: '`.nupkg` extension and whose contents match certain conventions.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.nupkg` 扩展名，并且其内容符合某些约定。'
- en: '**npm**: The npm protocol is used when building applications with JavaScript
    or TypeScript.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**npm**：当使用 JavaScript 或 TypeScript 构建应用程序时，使用 npm 协议。'
- en: '**Maven or Gradle**: Maven and Gradle are used for the Java ecosystem.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Maven 或 Gradle**：Maven 和 Gradle 用于 Java 生态系统。'
- en: '**pip and Twine**: When working with Python packages, they can be obtained
    using these pip and Twine utilities.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pip 和 Twine**：在使用 Python 包时，可以通过这些 pip 和 Twine 工具获取它们。'
- en: '**Universal Packages**: Universal Packages are not associated with a specific
    ecosystem but are a generic means for uploading and retrieving packages.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用包**：通用包与特定生态系统无关，而是一种通用的上传和检索包的方式。'
- en: Whenever a new feed is created, no type needs to be specified. In fact, every
    feed can be accessed using any protocol, even with different protocols over time.
    However, in general, this does not make sense.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 每当创建一个新的信息源时，无需指定类型。实际上，每个信息源都可以通过任何协议访问，甚至随着时间的推移使用不同的协议。然而，通常情况下，这样做没有意义。
- en: Creating a feed
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建信息源
- en: 'Once you have identified one or more packages that you want to publish, you
    will need a place to store them. For this, you can use Azure Artifacts. The following
    diagram shows the structural makeup of Azure Artifacts:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦确定了一个或多个你希望发布的包，你将需要一个存储它们的地方。你可以使用 Azure Artifacts。以下图表展示了 Azure Artifacts
    的结构构成：
- en: '![Figure 7.1 – Azure Artifacts views ](img/B18655_07_01.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – Azure Artifacts 视图](img/B18655_07_01.jpg)'
- en: Figure 7.1 – Azure Artifacts views
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – Azure Artifacts 视图
- en: Within Azure Artifacts, you can create one or more feeds where you can store
    your packages. For each package, you can have multiple versions in a feed. The
    feed is the level at which you can set up authorizations for publishing packages.
    Within a feed, you can create one or more views that you can use for setting up
    authorizations for consuming packages. A specific version of any given package
    can be in more than one view at the same time. The following sections discuss
    all these concepts in more detail.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure Artifacts 中，你可以创建一个或多个信息流来存储你的包。对于每个包，你可以在一个信息流中拥有多个版本。信息流是你可以设置发布包权限的级别。在一个信息流中，你可以创建一个或多个视图，用于设置消费包的权限。任何特定版本的包可以同时存在于多个视图中。接下来的小节将更详细地讨论这些概念。
- en: Setting up a feed
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置信息流
- en: 'Within Azure Artifacts, the feed is the location where your packages are stored.
    Each feed is a separate and fully isolated repository. To create a new feed, follow
    these steps:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Azure Artifacts 中，信息流是存储包的位置。每个信息流都是一个独立且完全隔离的仓库。要创建新的信息流，请按照以下步骤操作：
- en: 'First, navigate to Azure Artifacts in the menu on the left and then click on
    the **Create feed** button (partially visible in the following screenshot behind
    the pane for creating a new feed):'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在左侧菜单中导航至 Azure Artifacts，然后点击**创建信息流**按钮（在以下截图中，按钮部分可见，在创建新信息流的面板后面）：
- en: '![Figure 7.2 – Creating a new feed ](img/B18655_07_02.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – 创建新信息流 ](img/B18655_07_02.jpg)'
- en: Figure 7.2 – Creating a new feed
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 创建新信息流
- en: Specify a name for the feed. It should not contain any spaces and should preferably
    contain only letters and numbers, since it will become part of a URL.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为信息流指定一个名称。该名称不应包含空格，最好只包含字母和数字，因为它将成为 URL 的一部分。
- en: Next, it is possible to specify the initial settings for visibility. This determines
    which users can view the feed. This will be discussed in more detail in a later
    subsection, *Managing views on a feed*.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，可以指定初始的可见性设置。这决定了哪些用户可以查看该信息流。这个内容将在后续小节中更详细地讨论，*管理信息流的视图*。
- en: Configure the use of upstream sources. This will also be covered in more detail
    in a later subsection, *Configuring upstream sources*.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置上游源的使用。此部分内容将在后续小节中更详细地讨论，*配置上游源*。
- en: A few seconds after selecting **Create**, your feed will be available.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择**创建**后几秒钟，你的信息流就会变得可用。
- en: 'Once the feed is created, you can configure various settings, such as hiding
    deleted packages, enabling package batches, and configuring retention policies.
    To learn how to do this, follow these steps:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦信息流创建完成，你可以配置各种设置，如隐藏已删除的包、启用包批处理和配置保留策略。要了解如何操作，请按照以下步骤执行：
- en: After the feed is created, access the settings for the feed by clicking on the
    gearbox in the top-right corner.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建信息流后，通过点击右上角的齿轮图标访问信息流的设置。
- en: 'Choose **Feed settings** in the view shown in the following screenshot. In
    this view, you can configure a few more things:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下图所示的视图中，选择**信息流设置**。在这个视图中，你可以配置更多设置：
- en: '![Figure 7.3 – Feed settings ](img/B18655_07_03.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – 信息流设置 ](img/B18655_07_03.jpg)'
- en: Figure 7.3 – Feed settings
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 信息流设置
- en: Besides changing the name and adding a description, you can choose to hide deleted
    packages. When you do this, versions of a package that have been removed are no
    longer visible to administrators of the feed. Regular users are never able to
    view or use deleted packages, but this setting enables the same view logic as
    administrators.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 除了更改名称和添加描述外，你还可以选择隐藏已删除的包。当你这样做时，已删除的包版本将不再对信息流的管理员可见。普通用户永远无法查看或使用已删除的包，但此设置使管理员与普通用户具有相同的视图逻辑。
- en: Another setting you can enable is that of package badges. A package badge is
    a visual element with the name of a package and the latest available version.
    If you enable this option, Azure DevOps Feed management will provide a direct
    URL link to the package badge. Using this link, you can always reference the latest
    version of the package. This is useful for people who want to keep tabs on the
    latest version of a package.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个可以启用的设置是包徽章。包徽章是一个视觉元素，显示了包的名称和最新的可用版本。如果启用此选项，Azure DevOps Feed 管理将提供一个直接的
    URL 链接指向该包徽章。通过这个链接，你可以随时引用该包的最新版本。这对于想要跟踪包的最新版本的人非常有用。
- en: Finally, you can configure a retention policy. Here, you can configure the automated
    removal when the number of versions of a package exceeds a certain threshold.
    While this helps you to save disk space and therefore costs, this can have the
    unintended effect of breaking the code references to these specific versions for
    downstream users of the feed. To safeguard against this, you can prevent removing
    a package for **x** number of days after it has been downloaded for the last time.
    Furthermore, keep in mind that any package version that is currently a member
    of a feed will not be removed.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你可以配置保留策略。在这里，你可以配置当某个包的版本数超过某个阈值时自动删除。虽然这有助于节省磁盘空间，从而减少成本，但这也可能导致下游用户的代码引用无法找到这些特定版本。因此，为了防止这种情况发生，你可以在最后一次下载该包后的**x**天内阻止删除该包。此外，请记住，当前属于某个feed的任何包版本将不会被删除。
- en: Once done, click on the **Save** button.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，点击**保存**按钮。
- en: After you have created and configured your feed, it is time to specify which
    users have access to the feed and what permissions they have. Let’s learn how
    to do that next.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在你创建并配置了feed后，接下来是指定哪些用户可以访问该feed以及他们的权限。接下来我们来学习如何做。
- en: Securing access
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全访问
- en: 'There are four roles you can assign to a user or group, where the rights of
    each successive role include the rights of the previous roles as well:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以为用户或组分配四个角色，其中每个后续角色的权限包括前一个角色的权限：
- en: '**Readers** are able to list all packages in a feed and can download them.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读者**可以列出feed中的所有包，并可以下载它们。'
- en: '**Collaborators** are also able to use packages from upstream sources.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**协作者**也可以使用来自上游源的包。'
- en: '**Contributors** can also publish their own packages and unlist and deprecate
    packages.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**贡献者**也可以发布自己的包，并且可以将包取消列出或弃用。'
- en: Finally, **owners** have full control over a feed and can also change permissions,
    rename the feed, or delete it.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，**所有者**拥有对feed的完全控制权，并且可以更改权限、重命名feed或删除它。
- en: 'To change the permission of a user, follow these steps:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 若要更改用户的权限，请按照以下步骤操作：
- en: 'Navigate to the **Permissions** view that you can see in the following screenshot.
    In this view, you can see a list of every user or group that has permissions assigned:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到**权限**视图，你可以在下面的截图中看到。在此视图中，你可以看到已分配权限的每个用户或组的列表：
- en: '![Figure 7.4 – Feed settings – adding/removing permissions ](img/B18655_07_04.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – Feed设置 – 添加/移除权限](img/B18655_07_04.jpg)'
- en: Figure 7.4 – Feed settings – adding/removing permissions
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – Feed设置 – 添加/移除权限
- en: To remove permissions, select the row and click on **Delete**.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 若要移除权限，选择该行并点击**删除**。
- en: To add a new row, click on the **Add users/groups** button. This will open the
    view you see on the right.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 若要添加新行，点击**添加用户/组**按钮。这将打开你右侧看到的视图。
- en: As an alternative to adding users or groups as a reader on the whole feed, it
    is also possible to create one or more views on the feed and set access rights
    per view.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将用户或组作为整个feed的读者添加外，你还可以在feed上创建一个或多个视图，并为每个视图设置访问权限。
- en: Managing views on a feed
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理feed上的视图
- en: A feed is a repository of packages that you can publish and download packages
    to and from. However, there are many cases where you do not want every uploaded
    package to be available for download. Often, you might find that you want to control
    who can use which versions of a package – for example, when you are implementing
    the CD of a shared library but want to share only stable versions with the rest
    of your organization.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: feed是一个包的仓库，你可以在其中发布和下载包。然而，在许多情况下，你不希望每个上传的包都可以供下载。你可能会发现，你希望控制谁可以使用哪个版本的包——例如，在你实现共享库的持续交付时，但又只想与组织中的其他人共享稳定版本。
- en: To do this, you can create views. A view is a subset of the package versions
    within a feed. As a consumer, when working with a view, it behaves just as if
    it were a feed.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，你可以创建视图。视图是feed中包版本的一个子集。作为消费者，在使用视图时，它的行为就像一个feed一样。
- en: 'Views can be managed as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 视图可以按照以下方式进行管理：
- en: 'Navigate and click on **Views**; you should see something similar to the following
    screenshot:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航并点击**视图**；你应该会看到类似以下截图的内容：
- en: '![Figure 7.5 – Feed settings – managing views ](img/B18655_07_05.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – Feed设置 – 管理视图](img/B18655_07_05.jpg)'
- en: Figure 7.5 – Feed settings – managing views
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – Feed设置 – 管理视图
- en: Here, you can see a list of all the current views and remove any views by selecting
    the row and clicking on **Delete**.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，您可以看到当前所有视图的列表，并通过选择某行并点击**删除**来移除任何视图。
- en: Adding new views can be done using the **Add view** button, which opens the
    view you see on the right.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加新视图可以通过点击**添加视图**按钮来完成，按钮会打开右侧的视图。
- en: You can set permissions for reading from a view here as well. You can allow
    read access to your whole Azure DevOps organization, or specify specific users.
    Any user or group you add here will get reader permissions on this view only.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以在此设置对视图的读取权限。您可以允许整个Azure DevOps组织读取权限，或指定特定用户。您在此添加的任何用户或组将仅对该视图获得读取权限。
- en: Editing permissions can be done by selecting any row and choosing **Edit**.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑权限可以通过选择任意行并点击**编辑**来完成。
- en: Once one or more views are available, packages can be promoted to a view for
    consumption through it.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦有一个或多个视图可用，包就可以被提升到该视图中供使用。
- en: Configuring upstream sources
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置上游源
- en: The final thing that you can configure on your feed is the upstream sources.
    Azure Artifacts feeds give you a repository where you can publish your own packages
    for reuse from one or more locations.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在源上配置的最后一项是上游源。Azure Artifacts源为您提供了一个存储库，您可以在一个或多个位置发布您自己的包，以便重复使用。
- en: However, you will probably also use packages that are publicly available on
    repositories such as `NuGet.org` or `npmjs.org`. In this case, you could use a
    combination of an Artifacts feed and `NuGet.org`, but you can also configure your
    feed to serve packages from `NuGet.org` as well. If you do this, `NuGet.org` is
    called an upstream source.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，您可能还会使用一些公开可用的包，这些包托管在像`NuGet.org`或`npmjs.org`这样的仓库中。在这种情况下，您可以将Azure Artifacts源和`NuGet.org`结合使用，或者您也可以将您的源配置为从`NuGet.org`提供包。如果您这么做，`NuGet.org`被称为上游源。
- en: Along with simplicity, this gives you the added benefit of having one central
    location where you can see all the packages you are using in your solution(s).
    This enables you to quickly check which packages and versions you are using, which
    can be useful for compliance or security checks. Using the different permissions
    between the reader and collaborator roles, you can also configure which users
    are authorized to pull packages from `NuGet.org` to your feed and which users
    are not.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简化操作外，这还为您提供了一个额外的好处，即可以在一个中心位置查看您在解决方案中使用的所有包。这使得您可以快速检查正在使用的包和版本，这对合规性或安全检查很有帮助。通过设置阅读者和协作者角色之间的不同权限，您还可以配置哪些用户被授权从`NuGet.org`拉取包到您的源中，哪些用户则没有权限。
- en: 'Of course, you can do this for any repository that is accessible over the internet
    and implements one of the protocols that Azure Artifacts supports. To configure
    upstream sources, follow these steps:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可以对任何可以通过互联网访问且实现了Azure Artifacts支持的协议的仓库执行此操作。要配置上游源，请按照以下步骤操作：
- en: 'Upstream sources can be configured after navigating to the following screen:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上游源可以在导航到以下屏幕后进行配置：
- en: '![Figure 7.6 – Configuring upstream sources ](img/B18655_07_06.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – 配置上游源](img/B18655_07_06.jpg)'
- en: Figure 7.6 – Configuring upstream sources
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 配置上游源
- en: Upstream sources are configured in the same way as permissions and views. You
    can delete upstream sources using the **Delete** button in the menu bar.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 上游源的配置方式与权限和视图相同。您可以通过菜单栏中的**删除**按钮删除上游源。
- en: Adding upstream sources is done by clicking on the **Add upstream source** button,
    which opens the view on the right.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加上游源可以通过点击**添加上游源**按钮来完成，按钮会打开右侧的视图。
- en: Important Note
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: A final thing to note about the use of upstream sources is that it is not possible
    to have the same version of a package published to your own feed if it is already
    available on an upstream source.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个关于使用上游源的注意事项是，如果包的版本已经在上游源中存在，您将无法将该版本的包发布到您自己的源。
- en: For instance, when you enable the `NuGet.org` upstream, you cannot publish the
    `Newtonsoft.Json` 10.0.3 package because that same package version is already
    present on `NuGet.org`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当您启用`NuGet.org`上游源时，您无法发布`Newtonsoft.Json` 10.0.3版本的包，因为该版本的包已经存在于`NuGet.org`上。
- en: This section discussed how to create and connect feeds. Now that these are in
    place, we will learn how to publish packages to those feeds in the next section.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了如何创建和连接源。现在这些已配置完成，我们将在下一节学习如何将包发布到这些源。
- en: Publishing packages
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布包
- en: 'Now that you know how to create and manage feeds, it is time to learn how to
    publish packages to them. If you have experience of publishing packages to public
    feeds, you will see that publishing to Azure Artifacts works in precisely the
    same way. There are two ways in which you can publish packages to a feed:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道如何创建和管理 feed，是时候学习如何将包发布到这些 feed 中了。如果您有将包发布到公共 feed 的经验，您会发现发布到 Azure
    Artifacts 的方式完全相同。有两种方法可以将包发布到 feed 中：
- en: Manually from your own computer
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从您自己的计算机手动发布
- en: By using Azure Pipelines
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用 Azure 管道
- en: Both options are explored in the following sections.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个选项在以下部分中进行了探讨。
- en: Publishing packages manually
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动发布包
- en: 'To upload packages manually, the following steps need to be performed:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 要手动上传包，需要执行以下步骤：
- en: 'First, you will have to retrieve the URL to your feed. To do this, click on
    **Connect to feed** for any of your feeds, as shown in the following screenshot:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，您需要检索 feed 的 URL。要做到这一点，请单击任何 feed 的 **连接到 feed**，如以下截图所示：
- en: '![Figure 7.7 – Connect to feed ](img/B18655_07_07.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7 – 连接到 feed](img/B18655_07_07.jpg)'
- en: Figure 7.7 – Connect to feed
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – 连接到 feed
- en: In the list on the left, select the protocol to use for accessing the feed.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧列表中，选择用于访问 feed 的协议。
- en: Select the correct view to use. Remember that for publishing packages, the full
    feed URL needs to be used, since views are read-only.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择正确的视图使用。请记住，对于发布包，需要使用完整的 feed URL，因为视图是只读的。
- en: After making the correct selections, copy the correct URL to the clipboard using
    the **Copy** button.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在进行正确选择之后，使用 **复制** 按钮将正确的 URL 复制到剪贴板。
- en: 'Execute the following command to create a NuGet package from a regular `.csproj`
    file. If you do not have the `NuGet.exe` tool already available, you can download
    it using the link provided at the end of this chapter:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令，从常规的 `.csproj` 文件创建一个 NuGet 包。如果您尚未拥有 `NuGet.exe` 工具，请使用本章末尾提供的链接下载它：
- en: '[PRE0]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Execute the final command for uploading the package to NuGet:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行最后一个命令将包上传到 NuGet：
- en: '[PRE1]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: After executing the final command, the package will be published and becomes
    available in your feed.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 执行最后一个命令后，该包将被发布，并在您的 feed 中可用。
- en: Publishing packages from a pipeline
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从管道发布包
- en: Uploading a package manually is not a convenient solution if you need to do
    it more than once. In cases where you want to frequently generate and publish
    a new version of a library, you can use an Azure pipeline. As well as the automation
    that this gives you, it is also a great way to introduce repeatability and reliability,
    since you can now use all of the benefits that pipelines offer you.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要频繁生成和发布库的新版本，手动上传包不是一个方便的解决方案。在您希望频繁生成和发布库的情况下，您可以使用 Azure 管道。除了提供自动化外，这也是引入重复性和可靠性的一个好方法，因为现在您可以利用管道所提供的所有优势。
- en: You can find a possible build definition for creating and publishing an `npm`
    package, as shown in the following example. The sources for this build are from
    an open source Microsoft GitHub repository called `tfs-cli`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以找到一个可能的构建定义，用于创建和发布一个 `npm` 包，如下例所示。这个构建的源自于一个名为 `tfs-cli` 的开源 Microsoft
    GitHub 仓库。
- en: 'In this pipeline, there are three usages of the built-in `npm` task:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个流水线中，内置的 `npm` 任务被使用了三次：
- en: 'The first occurrence is an `npm install` command. This command is used for
    installing the dependencies for this package:'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一次出现的是一个 `npm install` 命令。此命令用于为该包安装依赖项：
- en: '![Figure 7.8 – Publishing an npm package through an Azure pipeline   ](img/B18655_07_08.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.8 – 通过 Azure 管道发布 npm 包](img/B18655_07_08.jpg)'
- en: Figure 7.8 – Publishing an npm package through an Azure pipeline
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 – 通过 Azure 管道发布 npm 包
- en: 'The second occurrence is running a custom command, `build`. This command is
    defined in the source code itself using `package.json` and is used for transpiling
    the source files from TypeScript to JavaScript:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二次出现的是运行自定义命令，`build`。这个命令在源代码中使用 `package.json` 自身定义，并用于将 TypeScript 源文件转译为
    JavaScript：
- en: '![Figure 7.9 – Building the npm package command in an Azure pipeline  ](img/B18655_07_09.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.9 – 在 Azure 管道中构建 npm 包命令](img/B18655_07_09.jpg)'
- en: Figure 7.9 – Building the npm package command in an Azure pipeline
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9 – 在 Azure 管道中构建 npm 包命令
- en: 'The final and third task is running the `npm publish` command to publish the
    generated package to an `npm` feed. In this instance, there is no external feed
    selected but a built-in target registry, the Azure Artifacts feed:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后的第三个任务是运行`npm publish`命令，将生成的软件包发布到`npm`源。在此实例中，没有选择外部源，而是选择了内置的目标注册表——Azure
    Artifacts 源：
- en: '![Figure 7.10 – Publishing an npm package in an Azure pipeline  ](img/B18655_07_10.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.10 – 在 Azure 管道中发布 npm 包](img/B18655_07_10.jpg)'
- en: Figure 7.10 – Publishing an npm package in an Azure pipeline
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10 – 在 Azure 管道中发布 npm 包
- en: After running this build, your package is available in your feed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此构建后，您的软件包将可用于您的源。
- en: Versioning packages
  id: totrans-135
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 软件包版本控制
- en: One thing that is not done automatically when using the tasks to upload an `npm`
    package, or most types of packages for that matter, is managing the version number.
    Of course, there are many ways in which you can make sure your packages have proper
    versions, but a common approach is setting (part of) the version number during
    the build of a package.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用任务上传`npm`包（或大多数类型的包）时，有一件事不会自动完成，那就是管理版本号。当然，有许多方法可以确保您的软件包具有正确的版本，但常见的方法是在构建软件包时设置（部分）版本号。
- en: Tip
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Semantic versioning, also known as SemVer, is the most common practice to use
    within a versioning system.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 语义版本控制，简称 SemVer，是版本控制系统中最常用的做法。
- en: Version basics
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 版本基础
- en: 'Applications adopting `Major.Minor.Patch[-Suffix]` form. The SemVer standard
    constructs a version in four parts and has the following meanings:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 采用`Major.Minor.Patch[-Suffix]`形式的应用程序。SemVer 标准将版本构建为四个部分，含义如下：
- en: '**Major**: This indicates that this release includes breaking changes or incompatible
    changes with previous versions.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Major**：表示此版本包含破坏性变更或与以前版本不兼容的更改。'
- en: '**Minor**: This indicates that this release includes new features but is compatible
    with a previous version – that is, backward-compatible.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Minor**：表示此版本包含新功能，但与先前版本兼容——即向后兼容。'
- en: '**Patch**: This indicates that this release is backward-compatible but only
    for minor bug fixes.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Patch**：表示此版本向后兼容，但仅用于修复较小的错误。'
- en: '**Suffix (optional)**: This is a hyphen followed by a string, denoting a pre-release
    version.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Suffix （可选）**：这是一个连字符后跟一个字符串，表示预发布版本。'
- en: A recommended approach is to publish a new version of the package with an updated
    version number in the `package.json` file.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐的做法是在`package.json`文件中更新版本号后，发布软件包的新版本。
- en: 'Expanding on the `npm` package build that we demonstrated before, three changes
    can be made to the build definition:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前演示的`npm`包构建的基础上，可以对构建定义进行三处更改：
- en: 'First, the build number format for the build definition is updated to the following:
    `1.0$(Rev:.rrr)`. This guarantees that a unique number is automatically generated
    for every build. The `Ref:.rrr` variable will generate a number with three positions,
    leading with zeros if needed. The first time, this number will be `000`, and it
    will increase by one every time the rest of the build number is not changed.'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，构建定义的构建编号格式更新为以下格式：`1.0$(Rev:.rrr)`。这确保每个构建都会自动生成一个唯一编号。`Ref:.rrr`变量将生成一个三位数的编号，必要时以零填充。第一次时，这个编号将为`000`，每次其余构建编号不变时，这个编号将增加1。
- en: Second, a task is added to replace the version number that is currently specified
    in the source control, using the `{#Build.BuildNumber#}` token. This is a reference
    to the build variable with the name `Build.BuildNumber`, which contains the build
    number that was specified in *step 1*.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，添加一个任务，使用`{#Build.BuildNumber#}`令牌替换当前在源控制中指定的版本号。这是对名为`Build.BuildNumber`的构建变量的引用，它包含在*步骤
    1*中指定的构建号。
- en: 'Finally, a **Replace Tokens** task is added to the build before all other tasks.
    A possible configuration to replace the fixed-version number with the automatic
    version number for this task is shown as follows:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在所有其他任务之前，添加了一个**替换令牌**任务。以下是配置该任务以将固定版本号替换为自动版本号的可能配置：
- en: '![Figure 7.11 – Replace Tokens tasks ](img/B18655_07_11.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.11 – 替换令牌任务](img/B18655_07_11.jpg)'
- en: Figure 7.11 – Replace Tokens tasks
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11 – 替换令牌任务
- en: This task can be configured to replace the tokens in one or more target files
    (`{#` and ending in `#}`, take the text between these two markers, and then replace
    the whole text with the value of the corresponding variable.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 该任务可以配置为替换一个或多个目标文件中的令牌（`{#`，并以`#}`结束），取出这两个标记之间的文本，然后将整个文本替换为相应变量的值。
- en: 'For example, if we send the following `json` file as input, it will replace
    the `variable1` pipeline variable values within the tag:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们将以下 `json` 文件作为输入，它将在标签内替换 `variable1` 管道变量的值：
- en: '[PRE2]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If the value is configured as `Variable1: “validToken”`, then the output `json`
    file will be as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '如果值被配置为 `Variable1: “validToken”`，则输出的 `json` 文件将如下所示：'
- en: '[PRE3]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With this in place, every package that is built using the definition will have
    a unique and ever-increasing patch version number. Whenever the major or minor
    version number needs to be updated, this can be done by updating the build number
    format.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好之后，每个使用定义构建的包将拥有一个唯一且不断增加的补丁版本号。每当需要更新主版本号或次版本号时，可以通过更新构建号格式来完成。
- en: As an alternative to this approach, there are many tasks available from the
    extensions marketplace that can help with versioning, including more complex scenarios.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这种方法的替代方案，扩展市场中有许多任务可以帮助进行版本控制，包括更复杂的场景。
- en: This section discussed how to publish packages to a feed. With packages published
    to a feed, the next section will detail how these can be used with either Visual
    Studio or an Azure pipeline.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 本节讨论了如何将包发布到源中。通过发布到源中的包，下一节将详细介绍如何在 Visual Studio 或 Azure 管道中使用这些包。
- en: Restoring packages
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恢复包
- en: Uploading packages to an Azure Artifacts feed or repository makes them available
    for use in many different scenarios. Two common scenarios are using your own packages
    with Visual Studio or from Azure Pipelines. Both scenarios will be detailed in
    the following sections.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 将包上传到 Azure Artifacts 源或仓库使其在多种不同场景下可用。两个常见的场景是：在 Visual Studio 中使用您自己的包，或通过
    Azure Pipelines 使用它们。接下来的部分将详细描述这两种场景。
- en: Restoring packages from Visual Studio
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Visual Studio 恢复包
- en: Once you have your shared libraries available as NuGet packages in an Azure
    Artifacts feed, you can start using them from Visual Studio. Before you can do
    this, you will have to register your feed in your Visual Studio instance.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您的共享库作为 NuGet 包在 Azure Artifacts 源中可用，您就可以开始在 Visual Studio 中使用它们。在此之前，您需要在您的
    Visual Studio 实例中注册您的源。
- en: 'To do this, you first have to grab the URL of your feed. In order to do this,
    refer to the *Publishing packages manually* section. Once you have your URL ready,
    go to manage NuGet files for your solution, as you would do normally. If you are
    not familiar with working with NuGet packages in Visual Studio, you can find this
    option in the Solution Explorer on the solution and project headers:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为此，您首先需要获取您源的 URL。为此，请参考*手动发布包*部分。准备好 URL 后，按常规方式进入管理 NuGet 文件的界面。如果您不熟悉在 Visual
    Studio 中操作 NuGet 包，您可以在解决方案资源管理器中找到该选项，位于解决方案和项目的标题处：
- en: '![Figure 7.12 – Configuring the NuGet package sources ](img/B18655_07_12.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.12 – 配置 NuGet 包源](img/B18655_07_12.jpg)'
- en: Figure 7.12 – Configuring the NuGet package sources
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12 – 配置 NuGet 包源
- en: 'Once you are here, follow the following steps:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您到达这里，按照以下步骤操作：
- en: Click on the small gearbox in the top-right corner to open the dialog where
    you can configure which NuGet feeds to use.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单击右上角的小齿轮按钮，打开对话框，您可以在其中配置使用哪些 NuGet 源。
- en: Add a new feed.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的源。
- en: Fill in both the name and the source of your own feed.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写您的源的名称和来源。
- en: After doing so, do not forget to click on **Update**; otherwise, your changes
    to the **Name** and **Source** fields will not be saved, and there will be no
    warning prompting you that you have unsaved changes.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，不要忘记点击**更新**；否则，您的**名称**和**源**字段的更改将不会被保存，并且不会有任何提示您尚未保存更改的警告。
- en: After you have made these changes, you can now select your feed as the package
    source at the top right of the screen.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您做出这些更改后，您现在可以在屏幕右上角选择您的源作为包源。
- en: From here onward, it is possible to work with these packages from your own feed,
    just as you do with packages from `NuGet.org`.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 从此以后，您可以像使用 `NuGet.org` 的包一样，使用您自己源中的这些包。
- en: Restoring packages from a pipeline
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从管道恢复包
- en: Once you start using your packages in Visual Studio, it is very likely you will
    need them in Azure Pipelines as well. This is in order to perform CI/CD on the
    dependent application that uses your packages.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您开始在 Visual Studio 中使用您的包，很可能您也需要在 Azure Pipelines 中使用它们。这是为了在使用您包的依赖应用程序中执行
    CI/CD。
- en: 'Fortunately, this can be achieved with a small configuration change on your
    NuGet restore task, as shown in the following screenshot. The following screenshot
    relates to the NuGet restore task that can be used with both the Visual Studio
    build tasks and the .NET Core build tasks. Both contain the same interface and
    can be used in the same way:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这可以通过在你的 NuGet 恢复任务中做一个小的配置更改来实现，具体如下面的截图所示。以下截图与 NuGet 恢复任务相关，既可与 Visual
    Studio 构建任务一起使用，也可与 .NET Core 构建任务一起使用。两者包含相同的界面，可以以相同的方式使用：
- en: '![Figure 7.13 – Restoring the NuGet package feed configuration ](img/B18655_07_13.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.13 – 恢复 NuGet 包管理源配置](img/B18655_07_13.jpg)'
- en: Figure 7.13 – Restoring the NuGet package feed configuration
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13 – 恢复 NuGet 包管理源配置
- en: By default, only the radio button for using packages from NuGet is checked;
    therefore, to include packages from your own feeds as well, you need to select
    the correct feed in the drop-down list.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，仅勾选了使用来自 NuGet 的包的单选按钮；因此，如果你还需要包含来自自己源的包，你需要在下拉列表中选择正确的源。
- en: If you ever find the need to include packages from more than one feed, you will
    be forced to create one aggregator feed and use the other feeds as upstream sources
    for it.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现需要从多个源中包含包，你将被迫创建一个聚合源，并将其他源作为上游源使用。
- en: This section covered how to consume component packages from Visual Studio. The
    next section will dive into working with Universal Packages to share general binary
    packages.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分介绍了如何从 Visual Studio 中使用组件包。下一部分将深入探讨如何使用 Universal Packages 来共享通用的二进制包。
- en: Working with Universal Packages
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Universal Packages
- en: The previous sections have all focused on using Azure Artifacts as a means for
    redistributing application packages, such as libraries or other shared components.
    However, there is also another important use for Azure Artifacts – to maintain
    Universal Packages.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的部分都专注于使用 Azure Artifacts 作为重新分发应用程序包（如库或其他共享组件）的一种方式。然而，Azure Artifacts 还有另一个重要用途——用于维护
    Universal Packages。
- en: A Universal Packages feed can be used to store different types of packages other
    than those widely used, such as **NuGet** for .NET, **npm** for Node.js, **pypi**
    for Python, and **Maven** for Java application development.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Universal Packages 源可以用于存储不同类型的包，而不仅限于广泛使用的包，例如用于 .NET 的 **NuGet**、用于 Node.js
    的 **npm**、用于 Python 的 **pypi** 和用于 Java 应用程序开发的 **Maven**。
- en: You can use Universal Packages for storing and serving your build artifacts
    in sizes up to 4 TB. Packaging build artifacts into a Universal Package enables
    quick rollback to the desired version. Packages can be published and retrieved
    to and from Artifacts feeds using the Azure CLI or Azure Pipelines.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 Universal Packages 存储和提供最大为 4 TB 的构建工件。将构建工件打包成 Universal Package 可以快速回滚到所需版本。可以使用
    Azure CLI 或 Azure Pipelines 将包发布和从 Artifacts 源中检索。
- en: Tip
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Universal Packages are only available in Azure DevOps services.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Universal Packages 仅在 Azure DevOps 服务中可用。
- en: 'To use Universal Packages for staging your build artifacts in a heterogeneous
    architecture, there are four basic operations you should understand: uploading
    and downloading Universal Packages from an Azure pipeline and uploading and downloading
    Universal Packages using the Azure CLI. The latter one you can invoke from other
    tools.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在异构架构中使用 Universal Packages 来暂存构建工件，你需要理解四个基本操作：从 Azure pipeline 上传和下载 Universal
    Packages，以及使用 Azure CLI 上传和下载 Universal Packages。后者可以通过其他工具调用。
- en: Universal Packages are a lightweight, easy-to-use, and efficient way to transfer
    files with dependency management. Universal Packages provide client- and server-side
    deduplication, which can substantially reduce the network traffic you’re using
    to move files around. These Universal Packages are managed as part of feeds in
    package management, so you can easily control access to them.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Universal Packages 是一种轻量级、易于使用且高效的文件传输方式，具有依赖性管理功能。Universal Packages 提供客户端和服务器端去重功能，可以显著减少在传输文件时使用的网络流量。这些
    Universal Packages 作为包管理的一部分通过源进行管理，因此你可以轻松控制对它们的访问。
- en: Uploading and downloading Universal Packages from Azure Pipelines
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Azure Pipelines 上传和下载 Universal Packages
- en: Uploading build artifacts to a Universal Packages feed works in a similar way
    as uploading a regular build artifact. There are two changes you need to consider.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 将构建工件上传到 Universal Packages 源的方式与上传常规构建工件相似。你需要考虑两个变化。
- en: Firstly, you have to use another task for performing the upload. Instead of
    using the *publish build artifact* or *publish pipeline artifact* tasks, you have
    to use the task named **Universal Packages**. When using this task, you can still
    give a name to the artifact and specify a location on the filesystem of the build
    agent to upload it from. Next, you can specify a target feed and a version to
    use. This version can be either automatically incremented whenever a new package
    is uploaded or specified using a build variable.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要使用另一个任务来执行上传操作。您不能使用*发布构建工件*或*发布管道工件*任务，而必须使用名为**通用包**的任务。在使用此任务时，您仍然可以为工件指定一个名称，并指定构建代理文件系统上的上传位置。接下来，您可以指定目标源和使用的版本。该版本可以在每次上传新包时自动递增，或者通过构建变量进行指定。
- en: Secondly, you have to consider the fact that the uploaded package is not associated
    directly with the build that produced it – as is standard with regular build or
    pipeline artifacts. This means that no matter where you are using the package
    that has been uploaded, you have to find another way to find the correct version
    to download.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，您需要考虑到上传的包与生成它的构建没有直接关联——这与常规构建或管道工件的标准做法不同。这意味着，无论您在哪个位置使用已上传的包，您都必须找到其他方式来找到正确的版本进行下载。
- en: 'To perform the actual download, you can use the **Universal Packages** task
    again, as shown in the following screenshot:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行实际的下载，您可以再次使用**通用包**任务，如下截图所示：
- en: '![Figure 7.14 – The Universal Packages download ](img/B18655_07_14.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.14 – 通用包下载](img/B18655_07_14.jpg)'
- en: Figure 7.14 – The Universal Packages download
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.14 – 通用包下载
- en: 'Refer to the screenshot and follow these steps:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考截图并按照以下步骤操作：
- en: After adding the task, you can toggle it between **Upload** and **Download**.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加任务后，您可以在**上传**和**下载**之间切换。
- en: You can also specify a directory that is uploaded as the artifact for the **Upload**
    command. Alternatively, for the **Download** command, you can specify where the
    artifacts should be downloaded.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您还可以为**上传**命令指定一个作为工件上传的目录。或者，对于**下载**命令，您可以指定工件应下载到的地方。
- en: Furthermore, the name of the feed needs to be specified.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，还需要指定源的名称。
- en: Also, specify the name of the package.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还需要指定包的名称。
- en: Specify the version to be either an upload or a download.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定要上传或下载的版本。
- en: Important Note
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that you can also use feeds that are not part of your own organization
    by choosing to use another feed at *step 5*. If you do so, you will need to create
    a service endpoint to reach that feed.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您还可以通过在*步骤 5*中选择使用其他源来使用不属于您自己组织的源。如果这样做，您需要创建一个服务端点来访问该源。
- en: Uploading and downloading Universal Packages using the Azure CLI
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Azure CLI 上传和下载通用包
- en: 'When you want to work with Universal packages from a product other than Azure
    Pipelines, you will have to use the Azure CLI. To do this, perform the following
    steps:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 当您想要处理来自 Azure Pipelines 以外产品的通用包时，您必须使用 Azure CLI。为此，请执行以下步骤：
- en: The first thing you have to do to work with Universal Packages using the Azure
    CLI is to install the CLI itself. The link to the CLI can be found at the end
    of this chapter.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用 Azure CLI 处理通用包，您需要首先安装 CLI 本身。CLI 的链接将在本章末尾提供。
- en: 'Next, it is time to install the extension for Azure DevOps. This can be done
    using the following command:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您需要安装 Azure DevOps 扩展。可以使用以下命令完成此操作：
- en: '[PRE4]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After making the extension for Azure DevOps available, you have to log in using
    the a ccount that you also use to work within the Azure DevOps UI. You can log
    in by giving the following command:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使 Azure DevOps 扩展可用后，您必须使用您在 Azure DevOps UI 中也使用的账户进行登录。您可以通过以下命令进行登录：
- en: '[PRE5]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once logged in, you can upload a file as an artifact using the following command:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录后，您可以使用以下命令将文件作为工件上传：
- en: '[PRE6]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To download a particular version of an artifact again, you can use the following:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要重新下载某个版本的工件，您可以使用以下命令：
- en: '[PRE7]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using the CLI and these commands, you can use Azure Artifacts as a means to
    share build artifacts between multiple tools. When working with a number of tools
    on the same project, Universal Packages are a great tool for moving binaries around.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 CLI 和这些命令，您可以将 Azure Artifacts 作为在多个工具之间共享构建工件的手段。在同一项目中使用多个工具时，通用包是移动二进制文件的好工具。
- en: In the next section, other tools available for package management will be explored.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，将探讨用于包管理的其他工具。
- en: Exploring other tools
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many other tools available to do binary management. Four commonly
    used products are MyGet, Artifactory, GitHub Packages, and **Azure Container Registry**
    (**ACR**). The features they deliver do overlap, but they also have unique attributes
    at which they excel.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: MyGet
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MyGet is an alternative location for hosting your NuGet packages and allows
    you to create both public and private feeds that are managed by you. It also supports
    defining upstream sources and delivers built-in dependency scanning to give you
    continuous feedback on the level of security of your dependencies.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Since MyGet is an implementation of the NuGet protocol, you can publish and
    use packages using the default NuGet tasks from Azure Pipelines.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Artifactory
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Artifactory, a product by JFrog, is another tool that you can use to host your
    package feeds. Artifactory was originally an on-premises product, but it is now
    also available as a **Software as a Service** (**SaaS**) offering. Just like Azure
    Artifacts, it supports multiple protocols to interact with package feeds. At the
    time of writing, Artifactory supports more repository protocols than Azure Artifacts.
    Examples of this include PHP Composer and **Red Hat Package Manager** (**RPM**).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: JFrog has published an Azure Pipelines extension to download and upload packages.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Azure Container Registry
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another type of storage for reusable packages is ACR. This was designed specifically
    for container images and was developed with the layering of containers in mind.
    This allows it to receive only partial uploads when a new version of an image
    becomes available if not all of the layers have changed. This makes ACR a very
    good location for storing container images. Uploads are faster and ACR storage
    is cheaper than Azure Artifacts storage. This is a big benefit, since container
    images can be large.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: You can integrate with ACR from Azure Pipelines using the Docker integration
    extensions.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to identify shared components in your solutions
    – pieces of code that appear not only in multiple locations but that are also
    logical units for reuse. You learned how to use Azure Artifacts feeds for hosting
    packages that contain these libraries. Furthermore, you learned how to use these
    hosted packages to build dependent solutions using both Visual Studio and Azure
    Pipelines. You also learned about using Universal Packages to share build artifacts
    between Azure Pipelines and other tools that you might use for CI/CD.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, you will now be able to identify shared components in your
    solutions. Once you have identified such a component, you will also be able to
    isolate it in source control, build it, and publish it to an artifact feed. From
    here, you can distribute it to one or more consuming solutions. Finally, you are
    now also capable of using Artifacts feeds to share build artifacts between different
    CI/CD products.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about infrastructure and configuration as
    code. This is one of the fundamental DevOps practices that allows you to have
    your infrastructure definition in source control and use that as part of your
    release pipeline.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter’s material. You will find the answers in the *Assessments*
    section of the *Appendix*:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: 'True or false: Any version of a package can be deployed to only one view within
    a feed.'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: Pipeline artifacts can be used for sharing build outcomes (packages)
    from Azure DevOps to other products.'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: Azure Artifacts feeds with Universal Packages can be used to
    share build outcomes (packages) from Azure DevOps to other products.'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: **Standardization**, **package formats and sources**, and **versioning**
    are valid aspects of a dependency management strategy.'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is needed to enable building a solution that uses packages
    from an Azure Artifacts feed in Visual Studio? (You can select more than one option.)
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding the full package URL to your project dependencies, instead of only the
    package name
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Having at least *reader* access to the feed or one of the views in the feed
  id: totrans-241
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Having at least *consumer* access to the feed
  id: totrans-242
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring the location of the feed as a package source for Visual Studio
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some reasons for splitting a solution into multiple parts that are
    separated by Azure Artifacts feeds?
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s create a shared component to maintain model classes and extract it as
    a package. This package, as it has model classes, can be used with multiple projects,
    such as mobile, API, or website projects.
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a `packtbookslibrary.Shared.Models.`
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add a new class for the `Book` model as follows:'
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In Azure Artifacts, create a `PacktBooksLibraryFeed` feed.
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Under `[PacktBookLibrary]` group named **Build Administrators**.
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, set the **Project Collection Build Service** identity to be a
    contributor on your feed:![Figure 7.15 – The PacktBooksLibraryFeed settings ](img/B18655_07_15.jpg)
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure 7.15 – The PacktBooksLibraryFeed settings
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Now, create a `packtbookslibrary-Shared-Models-ci-pipeline.yaml` pipeline to
    create a NuGet package for our `packtbookslibrary.Shared.Models` class library
    project.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add the YAML code from the file present in the following directory in `packtbookslibrary-Shared-Models-ci-pipeline.yaml`:
    [https://github.com/PacktPublishing/Designing-and-Implementing-Microsoft-DevOps-Solutions-AZ-400-Exam-Guide](https://github.com/PacktPublishing/Designing-and-Implementing-Microsoft-DevOps-Solutions-AZ-400-Exam-Guide)'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To push a package, run `packtbookslibrary-Shared-Models-ci-pipeline.yaml`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the package is successfully executed, you will see a new entry in the
    list for `packtbookslibrary.Shared.Models`:'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.16 – The shared model package published in Azure Artifacts ](img/B18655_07_16.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
- en: Figure 7.16 – The shared model package published in Azure Artifacts
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.16 – 发布在 Azure Artifacts 中的共享模型包
- en: 'Now, add this NuGet feed to your project by navigating to **Manage NuGet packages**
    and **Settings**:'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，导航到 **管理 NuGet 包** 和 **设置**，将此 NuGet 源添加到你的项目中：
- en: '![Figure 7.17 – Managing the NuGet package sources for packtbooklibrary-api
    ](img/B18655_07_17.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.17 – 管理 packtbooklibrary-api 的 NuGet 包源](img/B18655_07_17.jpg)'
- en: Figure 7.17 – Managing the NuGet package sources for packtbooklibrary-api
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.17 – 管理 packtbooklibrary-api 的 NuGet 包源
- en: 'Select the package and install it in your project:'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择包并将其安装到你的项目中：
- en: '![Figure 7.18 – Installing the package in the packtbooklibrary-api project
    ](img/B18655_07_18.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.18 – 在 packtbooklibrary-api 项目中安装包](img/B18655_07_18.jpg)'
- en: Figure 7.18 – Installing the package in the packtbooklibrary-api project
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.18 – 在 packtbooklibrary-api 项目中安装包
- en: 'You can use this package in `BookController.cs` as follows:'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在 `BookController.cs` 中按如下方式使用这个包：
- en: '![Figure 7.19 – The shared model package in packtbooklibrary-api ](img/B18655_07_19.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.19 – packtbooklibrary-api 中的共享模型包](img/B18655_07_19.jpg)'
- en: Figure 7.19 – The shared model package in packtbooklibrary-api
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.19 – packtbooklibrary-api 中的共享模型包
- en: Further reading
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: Exercises for practicing with Azure Artifacts can be found at [https://docs.microsoft.com/en-us/learn/modules/manage-build-dependencies/](https://docs.microsoft.com/en-us/learn/modules/manage-build-dependencies/).
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在 [https://docs.microsoft.com/zh-cn/learn/modules/manage-build-dependencies/](https://docs.microsoft.com/en-us/learn/modules/manage-build-dependencies/)
    找到与 Azure Artifacts 一起练习的练习题。
- en: You can find and download `NuGet.exe` from [https://www.nuget.org/downloads.](https://www.nuget.org/downloads.%0D)
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在 [https://www.nuget.org/downloads.](https://www.nuget.org/downloads.%0D)
    下载 `NuGet.exe`。
- en: More information on creating a package can be found at [https://docs.microsoft.com/en-us/nuget/create-packages/creating-a-package](https://docs.microsoft.com/en-us/nuget/create-packages/creating-a-package).
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于创建包的更多信息可以在 [https://docs.microsoft.com/zh-cn/nuget/create-packages/creating-a-package](https://docs.microsoft.com/en-us/nuget/create-packages/creating-a-package)
    上找到。
- en: Information on downloading and installing the Azure CLI can be found at [https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest).
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关下载和安装 Azure CLI 的信息可以在 [https://docs.microsoft.com/zh-cn/cli/azure/install-azure-cli?view=azure-cli-latest](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest)
    上找到。
- en: More information about JFrog Artifactory is available at [https://jfrog.com/artifactory/](https://jfrog.com/artifactory/).
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于 JFrog Artifactory 的信息可以在 [https://jfrog.com/artifactory/](https://jfrog.com/artifactory/)
    上找到。
- en: The extension for Azure Pipelines can be found at [https://marketplace.visualstudio.com/items?itemName=JFrog.jfrog-artifactory-vsts-extension](https://marketplace.visualstudio.com/items?itemName=JFrog.jfrog-artifactory-vsts-extension).
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Pipelines 的扩展可以在 [https://marketplace.visualstudio.com/items?itemName=JFrog.jfrog-artifactory-vsts-extension](https://marketplace.visualstudio.com/items?itemName=JFrog.jfrog-artifactory-vsts-extension)
    上找到。
- en: More information about ACR is available at [https://azure.microsoft.com/en-in/services/container-registry/](https://azure.microsoft.com/en-in/services/container-registry/).
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于 ACR 的信息可以在 [https://azure.microsoft.com/zh-cn/services/container-registry/](https://azure.microsoft.com/en-in/services/container-registry/)
    上找到。
- en: You can find the Docker extensions for Azure Pipelines at [https://marketplace.visualstudio.com/items?itemName=ms-vscs-rm.docker](https://marketplace.visualstudio.com/items?itemName=ms-vscs-rm.docker).
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以在 [https://marketplace.visualstudio.com/items?itemName=ms-vscs-rm.docker](https://marketplace.visualstudio.com/items?itemName=ms-vscs-rm.docker)
    找到适用于 Azure Pipelines 的 Docker 扩展。
- en: More information on semantic versioning can be found at [https://semver.org/](https://semver.org/).
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于语义版本控制的信息可以在 [https://semver.org/](https://semver.org/) 上找到。
- en: More information on `tfs-cli` is available at [https://github.com/microsoft/tfs-cli](https://github.com/microsoft/tfs-cli).
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于 `tfs-cli` 的信息可以在 [https://github.com/microsoft/tfs-cli](https://github.com/microsoft/tfs-cli)
    找到。
- en: More information on Universal Packages can be found at [https://docs.microsoft.com/en-us/azure/devops/pipelines/artifacts/universal-packages?toc=%2Fazure%2Fdevops%2Fartifacts%2Ftoc.json&bc=%2Fazure%2Fdevops%2Fartifacts%2Fbreadcrumb%2Ftoc.json&view=azure-devops&tabs=yaml](https://docs.microsoft.com/en-us/azure/devops/pipelines/artifacts/universal-packages?toc=%2Fazure%2Fdevops%2Fartifacts%2Ftoc.json&bc=%2Fazure%2Fdevops%2Fartifacts%2Fbreadcrumb%2Ftoc.json&view=azure-devops&tabs=yaml).
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于通用包的更多信息，请参见[https://docs.microsoft.com/zh-cn/azure/devops/pipelines/artifacts/universal-packages?toc=%2Fazure%2Fdevops%2Fartifacts%2Ftoc.json&bc=%2Fazure%2Fdevops%2Fartifacts%2Fbreadcrumb%2Ftoc.json&view=azure-devops&tabs=yaml](https://docs.microsoft.com/en-us/azure/devops/pipelines/artifacts/universal-packages?toc=%2Fazure%2Fdevops%2Fartifacts%2Ftoc.json&bc=%2Fazure%2Fdevops%2Fartifacts%2Fbreadcrumb%2Ftoc.json&view=azure-devops&tabs=yaml)。
