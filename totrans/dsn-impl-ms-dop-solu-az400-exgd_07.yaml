- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dependency Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In part one of this book, you learned how to continuously deploy your application.
    In modern enterprise software development, applications are developed by cross-functional
    teams and involve complex solutions and projects. Complex solutions with hundreds
    of modules and functions have a greater probability of code duplication – that
    is, identical implementation for the same functionality within projects. Duplicated
    code is one of the cardinal sins of programming. You can solve problems by copying
    and pasting, but it usually creates maintenance nightmares later. **Don’t Repeat
    Yourself** (**DRY**) is a basic principle of software development aimed at reducing
    the repetition of information.
  prefs: []
  type: TYPE_NORMAL
- en: For a small or a single project, you may be able to handle dependencies on your
    own, but for complex solutions, a team will descend into **dependency hell**.
    One approach to solve this is by introducing package management. Developers need
    to identify the components to reuse within internal projects or from open source.
    Reusing libraries will increase the development velocity and the quality of the
    solution. Instead of copying and pasting code from one project to another, you
    can create a shared library using it. In this chapter, you will learn how to identify
    shared components and how to make them reusable using Azure Artifacts. In addition
    to this, you will learn how you can use Azure Artifacts for storing pipeline artifacts
    when working in a heterogeneous architecture. Here, you will also work with other
    **Continuous Integration** (**CI**)/**Continuous Deployment** (**CD**) tools than
    just Azure DevOps. To do so, you will learn how to use Azure Artifacts for Universal
    Packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying shared components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a feed for publishing packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consuming packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Universal Packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring other tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To experiment with the topics mentioned in this chapter, an Azure DevOps organization
    is required.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying shared components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adopting DevOps practices, such as CI/CD, can greatly reduce the amount of time
    you have to spend on building and testing your applications. Besides building
    your applications, there are also many other concerns that you can address in
    your pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: When you start adding more and more tasks to your pipelines, you might run into
    a situation in which a single execution of your pipeline starts taking too long.
    In order to combat this, you might be interested in splitting your solution up
    into smaller builds and maybe even repositories. Splitting solutions into smaller
    builds is not viable with monolithic applications, since it would break the build
    process. Microservice applications or solutions, which have components decoupled
    into separate projects, could adopt this approach to split the build process.
    To do this, you could build parts of that application in isolation and then use
    the results of these builds in your main application as ready-built components.
  prefs: []
  type: TYPE_NORMAL
- en: Componentization is a process to structure your projects into reusable components
    that application developers independently write and deploy.
  prefs: []
  type: TYPE_NORMAL
- en: 'With source componentization, you split your solution into parts to use as
    shared projects. Imagine that you have two solutions that work closely together:
    one is a REST API and the other is a client package that you ship to your customers
    to work with that API. It is likely that in their source code, these two solutions
    share at least one project comprising common reusable objects, such as data models,
    that will serve as data contracts to exchange data between the two solutions.
    Here, you can also leverage package componentization and make a third solution
    with only the shared project, which you could then use as a package in your other
    solutions. Packages are rarely functional as a standalone unit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, what if you work in a team that is responsible for maintaining
    a whole series of solutions, and you find that you have complete namespaces that
    are copied and pasted between these solutions? It is not a desirable situation
    and one that probably comes with a lot of issues. What if you could write all
    of this code just once, build it, package it, and then reuse it in all these solutions?
    To summarize, three reasons for starting to work with packages and artifact feeds
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Extracting shared components into packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building packages that are used by other teams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing build and CI times by splitting a larger solution into parts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The three main aspects of dependency management are standardization, package
    formats and sources, and versioning.
  prefs: []
  type: TYPE_NORMAL
- en: In the remainder of this chapter, you will learn techniques for doing this by
    building packages out of (parts of) your application code, hosting them in a centralized
    location, and reusing them in one or more solutions.
  prefs: []
  type: TYPE_NORMAL
- en: In all three scenarios, you might be looking to increase the reusability of
    the code, but also to reduce the time taken between checking for a change and
    receiving feedback for that change in the form of automated test results. Before
    you start breaking up your application, remember that moving a part of your solution
    to a separate component does not always achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: If you break your application up into three components and one remaining main
    part, make sure that you can build and test these three components completely
    in isolation, or at least close to 100% isolation. If you cannot test a component
    of your application in isolation, creating a separate repository and build for
    that component will actually increase the time between checking for a change and
    receiving feedback to you as a developer. Both separate builds might run quicker,
    but now you need to wait for two builds before you receive any feedback.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you break your application up into separate components, make sure that each
    component can be built and tested in a high degree of isolation.
  prefs: []
  type: TYPE_NORMAL
- en: As well as this, you have to make sure that making a reusable component out
    of part of your application makes sense from a conceptual point of view. For example,
    components that are addressing a cross-cutting concern such as logging libraries
    or database abstraction layers are great candidates for factoring out to shared
    libraries. (On a side note, after you have done so, you might also want to consider
    replacing your own general-purpose libraries with off-the-shelf alternatives –
    for example, for database abstraction, use Entity Framework, and for logging providers,
    use Serilog, NLog, and so on wherever possible.)
  prefs: []
  type: TYPE_NORMAL
- en: However, if splitting your solution into components makes sense, it can bring
    great benefits.
  prefs: []
  type: TYPE_NORMAL
- en: Types of feeds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the solution has been separated into different components. some components
    will be reused by multiple teams and projects. A feed will be required to store,
    share, and manage these reusable components/packages.
  prefs: []
  type: TYPE_NORMAL
- en: There are many types of package feeds that can be hosted in Azure Artifacts.
    How you will use an artifact feed depends on the language and ecosystem used by
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following ecosystems are supported in Azure Artifacts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`.nupkg` extension and whose contents match certain conventions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**npm**: The npm protocol is used when building applications with JavaScript
    or TypeScript.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maven or Gradle**: Maven and Gradle are used for the Java ecosystem.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pip and Twine**: When working with Python packages, they can be obtained
    using these pip and Twine utilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Universal Packages**: Universal Packages are not associated with a specific
    ecosystem but are a generic means for uploading and retrieving packages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever a new feed is created, no type needs to be specified. In fact, every
    feed can be accessed using any protocol, even with different protocols over time.
    However, in general, this does not make sense.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a feed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you have identified one or more packages that you want to publish, you
    will need a place to store them. For this, you can use Azure Artifacts. The following
    diagram shows the structural makeup of Azure Artifacts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Azure Artifacts views ](img/B18655_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Azure Artifacts views
  prefs: []
  type: TYPE_NORMAL
- en: Within Azure Artifacts, you can create one or more feeds where you can store
    your packages. For each package, you can have multiple versions in a feed. The
    feed is the level at which you can set up authorizations for publishing packages.
    Within a feed, you can create one or more views that you can use for setting up
    authorizations for consuming packages. A specific version of any given package
    can be in more than one view at the same time. The following sections discuss
    all these concepts in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a feed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Within Azure Artifacts, the feed is the location where your packages are stored.
    Each feed is a separate and fully isolated repository. To create a new feed, follow
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, navigate to Azure Artifacts in the menu on the left and then click on
    the **Create feed** button (partially visible in the following screenshot behind
    the pane for creating a new feed):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Creating a new feed ](img/B18655_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Creating a new feed
  prefs: []
  type: TYPE_NORMAL
- en: Specify a name for the feed. It should not contain any spaces and should preferably
    contain only letters and numbers, since it will become part of a URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, it is possible to specify the initial settings for visibility. This determines
    which users can view the feed. This will be discussed in more detail in a later
    subsection, *Managing views on a feed*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the use of upstream sources. This will also be covered in more detail
    in a later subsection, *Configuring upstream sources*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A few seconds after selecting **Create**, your feed will be available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the feed is created, you can configure various settings, such as hiding
    deleted packages, enabling package batches, and configuring retention policies.
    To learn how to do this, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: After the feed is created, access the settings for the feed by clicking on the
    gearbox in the top-right corner.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Choose **Feed settings** in the view shown in the following screenshot. In
    this view, you can configure a few more things:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Feed settings ](img/B18655_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Feed settings
  prefs: []
  type: TYPE_NORMAL
- en: Besides changing the name and adding a description, you can choose to hide deleted
    packages. When you do this, versions of a package that have been removed are no
    longer visible to administrators of the feed. Regular users are never able to
    view or use deleted packages, but this setting enables the same view logic as
    administrators.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another setting you can enable is that of package badges. A package badge is
    a visual element with the name of a package and the latest available version.
    If you enable this option, Azure DevOps Feed management will provide a direct
    URL link to the package badge. Using this link, you can always reference the latest
    version of the package. This is useful for people who want to keep tabs on the
    latest version of a package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, you can configure a retention policy. Here, you can configure the automated
    removal when the number of versions of a package exceeds a certain threshold.
    While this helps you to save disk space and therefore costs, this can have the
    unintended effect of breaking the code references to these specific versions for
    downstream users of the feed. To safeguard against this, you can prevent removing
    a package for **x** number of days after it has been downloaded for the last time.
    Furthermore, keep in mind that any package version that is currently a member
    of a feed will not be removed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once done, click on the **Save** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After you have created and configured your feed, it is time to specify which
    users have access to the feed and what permissions they have. Let’s learn how
    to do that next.
  prefs: []
  type: TYPE_NORMAL
- en: Securing access
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are four roles you can assign to a user or group, where the rights of
    each successive role include the rights of the previous roles as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Readers** are able to list all packages in a feed and can download them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Collaborators** are also able to use packages from upstream sources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Contributors** can also publish their own packages and unlist and deprecate
    packages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, **owners** have full control over a feed and can also change permissions,
    rename the feed, or delete it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To change the permission of a user, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the **Permissions** view that you can see in the following screenshot.
    In this view, you can see a list of every user or group that has permissions assigned:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Feed settings – adding/removing permissions ](img/B18655_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Feed settings – adding/removing permissions
  prefs: []
  type: TYPE_NORMAL
- en: To remove permissions, select the row and click on **Delete**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To add a new row, click on the **Add users/groups** button. This will open the
    view you see on the right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As an alternative to adding users or groups as a reader on the whole feed, it
    is also possible to create one or more views on the feed and set access rights
    per view.
  prefs: []
  type: TYPE_NORMAL
- en: Managing views on a feed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A feed is a repository of packages that you can publish and download packages
    to and from. However, there are many cases where you do not want every uploaded
    package to be available for download. Often, you might find that you want to control
    who can use which versions of a package – for example, when you are implementing
    the CD of a shared library but want to share only stable versions with the rest
    of your organization.
  prefs: []
  type: TYPE_NORMAL
- en: To do this, you can create views. A view is a subset of the package versions
    within a feed. As a consumer, when working with a view, it behaves just as if
    it were a feed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Views can be managed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate and click on **Views**; you should see something similar to the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Feed settings – managing views ](img/B18655_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Feed settings – managing views
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see a list of all the current views and remove any views by selecting
    the row and clicking on **Delete**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding new views can be done using the **Add view** button, which opens the
    view you see on the right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can set permissions for reading from a view here as well. You can allow
    read access to your whole Azure DevOps organization, or specify specific users.
    Any user or group you add here will get reader permissions on this view only.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Editing permissions can be done by selecting any row and choosing **Edit**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once one or more views are available, packages can be promoted to a view for
    consumption through it.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring upstream sources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final thing that you can configure on your feed is the upstream sources.
    Azure Artifacts feeds give you a repository where you can publish your own packages
    for reuse from one or more locations.
  prefs: []
  type: TYPE_NORMAL
- en: However, you will probably also use packages that are publicly available on
    repositories such as `NuGet.org` or `npmjs.org`. In this case, you could use a
    combination of an Artifacts feed and `NuGet.org`, but you can also configure your
    feed to serve packages from `NuGet.org` as well. If you do this, `NuGet.org` is
    called an upstream source.
  prefs: []
  type: TYPE_NORMAL
- en: Along with simplicity, this gives you the added benefit of having one central
    location where you can see all the packages you are using in your solution(s).
    This enables you to quickly check which packages and versions you are using, which
    can be useful for compliance or security checks. Using the different permissions
    between the reader and collaborator roles, you can also configure which users
    are authorized to pull packages from `NuGet.org` to your feed and which users
    are not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you can do this for any repository that is accessible over the internet
    and implements one of the protocols that Azure Artifacts supports. To configure
    upstream sources, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Upstream sources can be configured after navigating to the following screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Configuring upstream sources ](img/B18655_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – Configuring upstream sources
  prefs: []
  type: TYPE_NORMAL
- en: Upstream sources are configured in the same way as permissions and views. You
    can delete upstream sources using the **Delete** button in the menu bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding upstream sources is done by clicking on the **Add upstream source** button,
    which opens the view on the right.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: A final thing to note about the use of upstream sources is that it is not possible
    to have the same version of a package published to your own feed if it is already
    available on an upstream source.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, when you enable the `NuGet.org` upstream, you cannot publish the
    `Newtonsoft.Json` 10.0.3 package because that same package version is already
    present on `NuGet.org`.
  prefs: []
  type: TYPE_NORMAL
- en: This section discussed how to create and connect feeds. Now that these are in
    place, we will learn how to publish packages to those feeds in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that you know how to create and manage feeds, it is time to learn how to
    publish packages to them. If you have experience of publishing packages to public
    feeds, you will see that publishing to Azure Artifacts works in precisely the
    same way. There are two ways in which you can publish packages to a feed:'
  prefs: []
  type: TYPE_NORMAL
- en: Manually from your own computer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By using Azure Pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both options are explored in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing packages manually
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To upload packages manually, the following steps need to be performed:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you will have to retrieve the URL to your feed. To do this, click on
    **Connect to feed** for any of your feeds, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Connect to feed ](img/B18655_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – Connect to feed
  prefs: []
  type: TYPE_NORMAL
- en: In the list on the left, select the protocol to use for accessing the feed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the correct view to use. Remember that for publishing packages, the full
    feed URL needs to be used, since views are read-only.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After making the correct selections, copy the correct URL to the clipboard using
    the **Copy** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute the following command to create a NuGet package from a regular `.csproj`
    file. If you do not have the `NuGet.exe` tool already available, you can download
    it using the link provided at the end of this chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the final command for uploading the package to NuGet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After executing the final command, the package will be published and becomes
    available in your feed.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing packages from a pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Uploading a package manually is not a convenient solution if you need to do
    it more than once. In cases where you want to frequently generate and publish
    a new version of a library, you can use an Azure pipeline. As well as the automation
    that this gives you, it is also a great way to introduce repeatability and reliability,
    since you can now use all of the benefits that pipelines offer you.
  prefs: []
  type: TYPE_NORMAL
- en: You can find a possible build definition for creating and publishing an `npm`
    package, as shown in the following example. The sources for this build are from
    an open source Microsoft GitHub repository called `tfs-cli`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this pipeline, there are three usages of the built-in `npm` task:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first occurrence is an `npm install` command. This command is used for
    installing the dependencies for this package:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.8 – Publishing an npm package through an Azure pipeline   ](img/B18655_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – Publishing an npm package through an Azure pipeline
  prefs: []
  type: TYPE_NORMAL
- en: 'The second occurrence is running a custom command, `build`. This command is
    defined in the source code itself using `package.json` and is used for transpiling
    the source files from TypeScript to JavaScript:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Building the npm package command in an Azure pipeline  ](img/B18655_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – Building the npm package command in an Azure pipeline
  prefs: []
  type: TYPE_NORMAL
- en: 'The final and third task is running the `npm publish` command to publish the
    generated package to an `npm` feed. In this instance, there is no external feed
    selected but a built-in target registry, the Azure Artifacts feed:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.10 – Publishing an npm package in an Azure pipeline  ](img/B18655_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – Publishing an npm package in an Azure pipeline
  prefs: []
  type: TYPE_NORMAL
- en: After running this build, your package is available in your feed.
  prefs: []
  type: TYPE_NORMAL
- en: Versioning packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One thing that is not done automatically when using the tasks to upload an `npm`
    package, or most types of packages for that matter, is managing the version number.
    Of course, there are many ways in which you can make sure your packages have proper
    versions, but a common approach is setting (part of) the version number during
    the build of a package.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Semantic versioning, also known as SemVer, is the most common practice to use
    within a versioning system.
  prefs: []
  type: TYPE_NORMAL
- en: Version basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Applications adopting `Major.Minor.Patch[-Suffix]` form. The SemVer standard
    constructs a version in four parts and has the following meanings:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Major**: This indicates that this release includes breaking changes or incompatible
    changes with previous versions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minor**: This indicates that this release includes new features but is compatible
    with a previous version – that is, backward-compatible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Patch**: This indicates that this release is backward-compatible but only
    for minor bug fixes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Suffix (optional)**: This is a hyphen followed by a string, denoting a pre-release
    version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A recommended approach is to publish a new version of the package with an updated
    version number in the `package.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Expanding on the `npm` package build that we demonstrated before, three changes
    can be made to the build definition:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, the build number format for the build definition is updated to the following:
    `1.0$(Rev:.rrr)`. This guarantees that a unique number is automatically generated
    for every build. The `Ref:.rrr` variable will generate a number with three positions,
    leading with zeros if needed. The first time, this number will be `000`, and it
    will increase by one every time the rest of the build number is not changed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Second, a task is added to replace the version number that is currently specified
    in the source control, using the `{#Build.BuildNumber#}` token. This is a reference
    to the build variable with the name `Build.BuildNumber`, which contains the build
    number that was specified in *step 1*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, a **Replace Tokens** task is added to the build before all other tasks.
    A possible configuration to replace the fixed-version number with the automatic
    version number for this task is shown as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Replace Tokens tasks ](img/B18655_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – Replace Tokens tasks
  prefs: []
  type: TYPE_NORMAL
- en: This task can be configured to replace the tokens in one or more target files
    (`{#` and ending in `#}`, take the text between these two markers, and then replace
    the whole text with the value of the corresponding variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we send the following `json` file as input, it will replace
    the `variable1` pipeline variable values within the tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If the value is configured as `Variable1: “validToken”`, then the output `json`
    file will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, every package that is built using the definition will have
    a unique and ever-increasing patch version number. Whenever the major or minor
    version number needs to be updated, this can be done by updating the build number
    format.
  prefs: []
  type: TYPE_NORMAL
- en: As an alternative to this approach, there are many tasks available from the
    extensions marketplace that can help with versioning, including more complex scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: This section discussed how to publish packages to a feed. With packages published
    to a feed, the next section will detail how these can be used with either Visual
    Studio or an Azure pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Restoring packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Uploading packages to an Azure Artifacts feed or repository makes them available
    for use in many different scenarios. Two common scenarios are using your own packages
    with Visual Studio or from Azure Pipelines. Both scenarios will be detailed in
    the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Restoring packages from Visual Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have your shared libraries available as NuGet packages in an Azure
    Artifacts feed, you can start using them from Visual Studio. Before you can do
    this, you will have to register your feed in your Visual Studio instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, you first have to grab the URL of your feed. In order to do this,
    refer to the *Publishing packages manually* section. Once you have your URL ready,
    go to manage NuGet files for your solution, as you would do normally. If you are
    not familiar with working with NuGet packages in Visual Studio, you can find this
    option in the Solution Explorer on the solution and project headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – Configuring the NuGet package sources ](img/B18655_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.12 – Configuring the NuGet package sources
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you are here, follow the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the small gearbox in the top-right corner to open the dialog where
    you can configure which NuGet feeds to use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new feed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill in both the name and the source of your own feed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After doing so, do not forget to click on **Update**; otherwise, your changes
    to the **Name** and **Source** fields will not be saved, and there will be no
    warning prompting you that you have unsaved changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After you have made these changes, you can now select your feed as the package
    source at the top right of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From here onward, it is possible to work with these packages from your own feed,
    just as you do with packages from `NuGet.org`.
  prefs: []
  type: TYPE_NORMAL
- en: Restoring packages from a pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you start using your packages in Visual Studio, it is very likely you will
    need them in Azure Pipelines as well. This is in order to perform CI/CD on the
    dependent application that uses your packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, this can be achieved with a small configuration change on your
    NuGet restore task, as shown in the following screenshot. The following screenshot
    relates to the NuGet restore task that can be used with both the Visual Studio
    build tasks and the .NET Core build tasks. Both contain the same interface and
    can be used in the same way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13 – Restoring the NuGet package feed configuration ](img/B18655_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.13 – Restoring the NuGet package feed configuration
  prefs: []
  type: TYPE_NORMAL
- en: By default, only the radio button for using packages from NuGet is checked;
    therefore, to include packages from your own feeds as well, you need to select
    the correct feed in the drop-down list.
  prefs: []
  type: TYPE_NORMAL
- en: If you ever find the need to include packages from more than one feed, you will
    be forced to create one aggregator feed and use the other feeds as upstream sources
    for it.
  prefs: []
  type: TYPE_NORMAL
- en: This section covered how to consume component packages from Visual Studio. The
    next section will dive into working with Universal Packages to share general binary
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Universal Packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous sections have all focused on using Azure Artifacts as a means for
    redistributing application packages, such as libraries or other shared components.
    However, there is also another important use for Azure Artifacts – to maintain
    Universal Packages.
  prefs: []
  type: TYPE_NORMAL
- en: A Universal Packages feed can be used to store different types of packages other
    than those widely used, such as **NuGet** for .NET, **npm** for Node.js, **pypi**
    for Python, and **Maven** for Java application development.
  prefs: []
  type: TYPE_NORMAL
- en: You can use Universal Packages for storing and serving your build artifacts
    in sizes up to 4 TB. Packaging build artifacts into a Universal Package enables
    quick rollback to the desired version. Packages can be published and retrieved
    to and from Artifacts feeds using the Azure CLI or Azure Pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Universal Packages are only available in Azure DevOps services.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Universal Packages for staging your build artifacts in a heterogeneous
    architecture, there are four basic operations you should understand: uploading
    and downloading Universal Packages from an Azure pipeline and uploading and downloading
    Universal Packages using the Azure CLI. The latter one you can invoke from other
    tools.'
  prefs: []
  type: TYPE_NORMAL
- en: Universal Packages are a lightweight, easy-to-use, and efficient way to transfer
    files with dependency management. Universal Packages provide client- and server-side
    deduplication, which can substantially reduce the network traffic you’re using
    to move files around. These Universal Packages are managed as part of feeds in
    package management, so you can easily control access to them.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading and downloading Universal Packages from Azure Pipelines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Uploading build artifacts to a Universal Packages feed works in a similar way
    as uploading a regular build artifact. There are two changes you need to consider.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, you have to use another task for performing the upload. Instead of
    using the *publish build artifact* or *publish pipeline artifact* tasks, you have
    to use the task named **Universal Packages**. When using this task, you can still
    give a name to the artifact and specify a location on the filesystem of the build
    agent to upload it from. Next, you can specify a target feed and a version to
    use. This version can be either automatically incremented whenever a new package
    is uploaded or specified using a build variable.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, you have to consider the fact that the uploaded package is not associated
    directly with the build that produced it – as is standard with regular build or
    pipeline artifacts. This means that no matter where you are using the package
    that has been uploaded, you have to find another way to find the correct version
    to download.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform the actual download, you can use the **Universal Packages** task
    again, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14 – The Universal Packages download ](img/B18655_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.14 – The Universal Packages download
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the screenshot and follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: After adding the task, you can toggle it between **Upload** and **Download**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also specify a directory that is uploaded as the artifact for the **Upload**
    command. Alternatively, for the **Download** command, you can specify where the
    artifacts should be downloaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Furthermore, the name of the feed needs to be specified.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, specify the name of the package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Specify the version to be either an upload or a download.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can also use feeds that are not part of your own organization
    by choosing to use another feed at *step 5*. If you do so, you will need to create
    a service endpoint to reach that feed.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading and downloading Universal Packages using the Azure CLI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you want to work with Universal packages from a product other than Azure
    Pipelines, you will have to use the Azure CLI. To do this, perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you have to do to work with Universal Packages using the Azure
    CLI is to install the CLI itself. The link to the CLI can be found at the end
    of this chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, it is time to install the extension for Azure DevOps. This can be done
    using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After making the extension for Azure DevOps available, you have to log in using
    the a ccount that you also use to work within the Azure DevOps UI. You can log
    in by giving the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once logged in, you can upload a file as an artifact using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To download a particular version of an artifact again, you can use the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using the CLI and these commands, you can use Azure Artifacts as a means to
    share build artifacts between multiple tools. When working with a number of tools
    on the same project, Universal Packages are a great tool for moving binaries around.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, other tools available for package management will be explored.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring other tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many other tools available to do binary management. Four commonly
    used products are MyGet, Artifactory, GitHub Packages, and **Azure Container Registry**
    (**ACR**). The features they deliver do overlap, but they also have unique attributes
    at which they excel.
  prefs: []
  type: TYPE_NORMAL
- en: MyGet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: MyGet is an alternative location for hosting your NuGet packages and allows
    you to create both public and private feeds that are managed by you. It also supports
    defining upstream sources and delivers built-in dependency scanning to give you
    continuous feedback on the level of security of your dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Since MyGet is an implementation of the NuGet protocol, you can publish and
    use packages using the default NuGet tasks from Azure Pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Artifactory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Artifactory, a product by JFrog, is another tool that you can use to host your
    package feeds. Artifactory was originally an on-premises product, but it is now
    also available as a **Software as a Service** (**SaaS**) offering. Just like Azure
    Artifacts, it supports multiple protocols to interact with package feeds. At the
    time of writing, Artifactory supports more repository protocols than Azure Artifacts.
    Examples of this include PHP Composer and **Red Hat Package Manager** (**RPM**).
  prefs: []
  type: TYPE_NORMAL
- en: JFrog has published an Azure Pipelines extension to download and upload packages.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Container Registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another type of storage for reusable packages is ACR. This was designed specifically
    for container images and was developed with the layering of containers in mind.
    This allows it to receive only partial uploads when a new version of an image
    becomes available if not all of the layers have changed. This makes ACR a very
    good location for storing container images. Uploads are faster and ACR storage
    is cheaper than Azure Artifacts storage. This is a big benefit, since container
    images can be large.
  prefs: []
  type: TYPE_NORMAL
- en: You can integrate with ACR from Azure Pipelines using the Docker integration
    extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to identify shared components in your solutions
    – pieces of code that appear not only in multiple locations but that are also
    logical units for reuse. You learned how to use Azure Artifacts feeds for hosting
    packages that contain these libraries. Furthermore, you learned how to use these
    hosted packages to build dependent solutions using both Visual Studio and Azure
    Pipelines. You also learned about using Universal Packages to share build artifacts
    between Azure Pipelines and other tools that you might use for CI/CD.
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, you will now be able to identify shared components in your
    solutions. Once you have identified such a component, you will also be able to
    isolate it in source control, build it, and publish it to an artifact feed. From
    here, you can distribute it to one or more consuming solutions. Finally, you are
    now also capable of using Artifacts feeds to share build artifacts between different
    CI/CD products.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about infrastructure and configuration as
    code. This is one of the fundamental DevOps practices that allows you to have
    your infrastructure definition in source control and use that as part of your
    release pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter’s material. You will find the answers in the *Assessments*
    section of the *Appendix*:'
  prefs: []
  type: TYPE_NORMAL
- en: 'True or false: Any version of a package can be deployed to only one view within
    a feed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: Pipeline artifacts can be used for sharing build outcomes (packages)
    from Azure DevOps to other products.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: Azure Artifacts feeds with Universal Packages can be used to
    share build outcomes (packages) from Azure DevOps to other products.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: **Standardization**, **package formats and sources**, and **versioning**
    are valid aspects of a dependency management strategy.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is needed to enable building a solution that uses packages
    from an Azure Artifacts feed in Visual Studio? (You can select more than one option.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding the full package URL to your project dependencies, instead of only the
    package name
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Having at least *reader* access to the feed or one of the views in the feed
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Having at least *consumer* access to the feed
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Configuring the location of the feed as a package source for Visual Studio
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some reasons for splitting a solution into multiple parts that are
    separated by Azure Artifacts feeds?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let’s create a shared component to maintain model classes and extract it as
    a package. This package, as it has model classes, can be used with multiple projects,
    such as mobile, API, or website projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a `packtbookslibrary.Shared.Models.`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add a new class for the `Book` model as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Azure Artifacts, create a `PacktBooksLibraryFeed` feed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Under `[PacktBookLibrary]` group named **Build Administrators**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternatively, set the **Project Collection Build Service** identity to be a
    contributor on your feed:![Figure 7.15 – The PacktBooksLibraryFeed settings ](img/B18655_07_15.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure 7.15 – The PacktBooksLibraryFeed settings
  prefs: []
  type: TYPE_NORMAL
- en: Now, create a `packtbookslibrary-Shared-Models-ci-pipeline.yaml` pipeline to
    create a NuGet package for our `packtbookslibrary.Shared.Models` class library
    project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add the YAML code from the file present in the following directory in `packtbookslibrary-Shared-Models-ci-pipeline.yaml`:
    [https://github.com/PacktPublishing/Designing-and-Implementing-Microsoft-DevOps-Solutions-AZ-400-Exam-Guide](https://github.com/PacktPublishing/Designing-and-Implementing-Microsoft-DevOps-Solutions-AZ-400-Exam-Guide)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To push a package, run `packtbookslibrary-Shared-Models-ci-pipeline.yaml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the package is successfully executed, you will see a new entry in the
    list for `packtbookslibrary.Shared.Models`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.16 – The shared model package published in Azure Artifacts ](img/B18655_07_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.16 – The shared model package published in Azure Artifacts
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add this NuGet feed to your project by navigating to **Manage NuGet packages**
    and **Settings**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.17 – Managing the NuGet package sources for packtbooklibrary-api
    ](img/B18655_07_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.17 – Managing the NuGet package sources for packtbooklibrary-api
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the package and install it in your project:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.18 – Installing the package in the packtbooklibrary-api project
    ](img/B18655_07_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.18 – Installing the package in the packtbooklibrary-api project
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use this package in `BookController.cs` as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 7.19 – The shared model package in packtbooklibrary-api ](img/B18655_07_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.19 – The shared model package in packtbooklibrary-api
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exercises for practicing with Azure Artifacts can be found at [https://docs.microsoft.com/en-us/learn/modules/manage-build-dependencies/](https://docs.microsoft.com/en-us/learn/modules/manage-build-dependencies/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find and download `NuGet.exe` from [https://www.nuget.org/downloads.](https://www.nuget.org/downloads.%0D)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information on creating a package can be found at [https://docs.microsoft.com/en-us/nuget/create-packages/creating-a-package](https://docs.microsoft.com/en-us/nuget/create-packages/creating-a-package).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information on downloading and installing the Azure CLI can be found at [https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli?view=azure-cli-latest).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about JFrog Artifactory is available at [https://jfrog.com/artifactory/](https://jfrog.com/artifactory/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The extension for Azure Pipelines can be found at [https://marketplace.visualstudio.com/items?itemName=JFrog.jfrog-artifactory-vsts-extension](https://marketplace.visualstudio.com/items?itemName=JFrog.jfrog-artifactory-vsts-extension).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about ACR is available at [https://azure.microsoft.com/en-in/services/container-registry/](https://azure.microsoft.com/en-in/services/container-registry/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the Docker extensions for Azure Pipelines at [https://marketplace.visualstudio.com/items?itemName=ms-vscs-rm.docker](https://marketplace.visualstudio.com/items?itemName=ms-vscs-rm.docker).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information on semantic versioning can be found at [https://semver.org/](https://semver.org/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information on `tfs-cli` is available at [https://github.com/microsoft/tfs-cli](https://github.com/microsoft/tfs-cli).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information on Universal Packages can be found at [https://docs.microsoft.com/en-us/azure/devops/pipelines/artifacts/universal-packages?toc=%2Fazure%2Fdevops%2Fartifacts%2Ftoc.json&bc=%2Fazure%2Fdevops%2Fartifacts%2Fbreadcrumb%2Ftoc.json&view=azure-devops&tabs=yaml](https://docs.microsoft.com/en-us/azure/devops/pipelines/artifacts/universal-packages?toc=%2Fazure%2Fdevops%2Fartifacts%2Ftoc.json&bc=%2Fazure%2Fdevops%2Fartifacts%2Fbreadcrumb%2Ftoc.json&view=azure-devops&tabs=yaml).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
