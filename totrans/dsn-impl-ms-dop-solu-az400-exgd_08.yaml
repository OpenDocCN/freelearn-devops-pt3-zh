- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implement Infrastructure and Configuration as Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, the focus was on storing and building application code
    and releasing the created binaries. You learned how to create a pipeline, from
    source control to a target environment, for the automated, repeatable deployment
    of your applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to apply the same principles to the infrastructure
    that your application runs on and the runtime configuration of your application.
    Doing so will help you to further increase the speed at which changes can be delivered
    to production, increasing the flow of value to your end users.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will start off by explaining the value of having everything, infrastructure
    and configuration included, as code. After that, it continues by explaining **Azure
    Resource Manager** (**ARM**) templates. The syntax will be explained, as well
    as how to deploy ARM templates. Then, it proceeds to explain the Azure Automation
    offering, available in the Azure cloud. Azure Automation can be used to run scripts
    on a schedule or load and apply PowerShell DSC modules. Next up is managing application
    settings for PaaS offerings, such as Azure App Service. Finally, it concludes
    by discussing several other tools that have similar capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Having everything as code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with ARM templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying ARM templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reverse engineering a template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Azure Automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing application settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To experiment with one or more of the technologies described in this chapter,
    one or more of the following may be required:'
  prefs: []
  type: TYPE_NORMAL
- en: An Azure subscription, for executing ARM templates and running Azure Automation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PowerShell with the Azure PowerShell modules, for executing ARM templates, available
    from [https://docs.microsoft.com/en-us/powershell/azure/install-az-ps?view=azps-7.3.0](https://docs.microsoft.com/en-us/powershell/azure/install-az-ps?view=azps-7.3.0)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Azure CLI, for executing ARM templates, available from https://docs.microsoft.com/en-us/cli/azure/
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having everything as code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have been responsible for creating and maintaining application infrastructure
    and configuration in the past, you have most likely experienced what is called
    **configuration drift**. Configuration drift is the name for the phenomenon where
    the configuration between servers in acceptance and the production environment
    differs. Or, even worse, when having multiple servers in the production environment,
    it might be the case that the configuration of these is not always the same.
  prefs: []
  type: TYPE_NORMAL
- en: The most common cause of configuration drift is manual change. When making changes
    manually, maybe under the pressure of a production issue, there is always the
    risk that you apply different settings to different servers or hosts. If you ever
    need to scale out and add another server to your production environment, the chance
    of that server taking on the same configuration as all already-existing servers
    is very slim.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Declarative (functional) and imperative (procedural) are two of the main approaches
    adopted to implement **Infrastructure as Code** (**IaC**) and **Configuration
    as Code** (**CaC**).
  prefs: []
  type: TYPE_NORMAL
- en: With IaC and CaC, you no longer make changes to application configuration and
    infrastructure manually, but through automation. The first step to do this is
    specifying the desired state of configuration and infrastructure. The desired
    state is then fed into configuration management tooling that enforces this configuration
    on your infrastructure. Specifying only the desired state is called a *declarative*
    approach, which differs from an *imperative* approach, where you specify all of
    the steps that need to be taken.
  prefs: []
  type: TYPE_NORMAL
- en: Some of these tools are often also capable of checking the current state of
    your infrastructure and configuration at regular intervals and reapplying your
    desired state if any deviation is detected. This is possible due to the declarative
    approach. This makes applying configuration an idempotent operation.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: An operation is idempotent if it can be repeated one or more times, while the
    outcome remains the same.
  prefs: []
  type: TYPE_NORMAL
- en: When adopting IaC and CaC, you can even go so far as to recreate the complete
    infrastructure before deploying an application, deploy the application on that
    new infrastructure, and then disregard the old infrastructure after switching
    to the new deployment. This is an extreme form of immutable servers. The added
    benefit of this approach is that you are now guaranteed that there will be no
    traces from any configuration or binaries from the previous deployment.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, you will learn about different IaC technologies and
    how to use them. It is important to understand that they are complementary and
    are often used together. For example, ARM templates can be used to create virtual
    machines in Azure and, once that is done, PowerShell DSC or Ansible can be used
    to configure those virtual machines.
  prefs: []
  type: TYPE_NORMAL
- en: Working with ARM templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When working on the Azure platform, infrastructure is described using ARM templates.
    ARM templates are written in JSON, and a skeleton template looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The template itself is, at the highest level, a JSON object. There is a mandatory
    property, `$schema`.
  prefs: []
  type: TYPE_NORMAL
- en: '`$schema` is a required element and the value version number depends on the
    scope of the deployment and the JSON editor. The `contentVersion` property is
    also required and can be specified to version the contents. This version can be
    used by the author to version the template if necessary.'
  prefs: []
  type: TYPE_NORMAL
- en: The rest of this chapter will discuss the different parts that make up ARM templates
    in more detail. You will find a link to the online documentation at the end of
    this chapter. A link to a formal, detailed breakdown of the structure and syntax
    of ARM templates is also provided at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The parameters section is usually near the top of the template. Before beginning
    deployment activities, ARM will resolve the parameter values. The resolved value
    is referenced whenever the parameter is found in the template by ARM.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section takes the form of a JSON object, which can be empty but cannot
    be left out. The use of this section is to declare one or more parameters that
    can be specified by the caller of the ARM template before deploying it. A common
    reason for using the parameters section is to use the same template for both the
    test and production environments but vary the names of resources between the two.
    An example parameters section might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: For every parameter, a new key is specified with the parameter’s name. The value
    is an object. This object has one mandatory key, `type`. The allowed values for
    `type` are `string`, `int`, `bool`, `object`, `array`, `secureString`, and `secureObject`.
    The `secureString` and `secureObject` variations can be used to make sure that
    the runtime values of these parameters are scrubbed from any log and output. They
    are intended to hold passwords, keys, or other secrets.
  prefs: []
  type: TYPE_NORMAL
- en: The `metadata` object, with the `description` key, is optional and can be used
    to add a description to the parameter for future reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other properties that can be specified on a parameter object are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`minValue` and `maxValue` for specifying bounds on an integer value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`minLength` and `maxLength` for specifying bounds on the length of a string
    value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defaultValue` for specifying a default value that will be used if no value
    is specified when applying the template'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`allowedValues` for specifying an array of allowed values, limiting valid inputs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let’s understand what parameter files are.
  prefs: []
  type: TYPE_NORMAL
- en: Parameter files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can make use of a JSON file that contains the parameter values instead
    of specifying them as inline values in your script. In this section, we will discuss
    how to use parameter files to use with the templates. Often, a single template
    is accompanied by more than one parameter file, for example, one for test and
    one for production. The JSON for a parameter file appears as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Just like an ARM template, every parameter file is a JSON object with mandatory
    `$schema` and `contentVersion` properties. The third property parameter is used
    to specify one or more parameter values. For each parameter, specify its name
    as the key and an object as the value. This object can hold the `value` key for
    providing the actual value of the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: While very valuable for specifying names for resources, scaling options, and
    other things that have to vary between environments, this solution is not useful
    for secrets.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how the parameter file references the secret and
    passes that value to the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Using secrets in an Azure template ](img/B18655_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Using secrets in an Azure template
  prefs: []
  type: TYPE_NORMAL
- en: 'Keys, passwords, and other secrets should not be stored as plaintext in source
    control in a parameter file. For secrets, another notation is available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With this notation, instead of specifying the value directly, there is a pointer
    to a location in an Azure key vault where the correct value is stored. When deploying
    the template, this secret is (within Azure!) taken from the key vault and used
    in deployment. This is allowed only if the user or service starting the deployment
    has either an owner or contributor role in relation to the key vault, and the
    key vault is enabled for template deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Strictly speaking, any role that includes the `Microsoft.KeyVault/vaults/deploy/action`
    permission will work. By default, these are the owner and contributor roles, but
    you can create custom roles that include this action as well.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The variables section is used to specify one or more values that will be used
    throughout the template. A common approach is building the names of all resources
    in the variables section, based on a single parameter called `environmentName`.
    This ensures that resources will have the same name between environments. Variables
    are also used to specify values that cannot be specified from outside the template
    but should be recognized as configurable. An example might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the example for `appServiceName` contains functions, which
    are discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Functions are used to allow the dynamic evaluation of properties in ARM templates.
    Calling functions uses a notation very similar to that of many programming languages:
    `functionName(arg1, arg2, …)`. Functions can return either a value, such as `string`
    or `int,` or an object or array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When an object is returned, any property can be accessed using the `.propertyName`
    notation. Accessing elements in an array can be done using `[index]`. To indicate
    which parts of a string should be evaluated as a function, they must be enclosed
    in brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding section shows two examples of functions. In the first, the `concat`
    function is called to concatenate two string values. One is hardcoded and the
    other one is the result of a second function call to retrieve the value of a template
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: There are a fair number of functions available. They can be used for string
    manipulation, retrieving details about the current subscription, resource group,
    or **Azure Active Directory** (**AAD**) tenant, or getting resource details.
  prefs: []
  type: TYPE_NORMAL
- en: Functions can also be used to retrieve account keys or other secrets. This is
    often done to automatically insert keys directly from the service that exposes
    the key to the application settings or a key vault. This eliminates the need for
    the manual transfer of secrets. Variables and functions can help make your templates
    easier to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: You can also add your own functions to your template. These functions can be
    used in your template. User-defined functions exist independently of regular template
    functions. In most cases, you define complex expressions that you don’t want to
    repeat throughout your template.
  prefs: []
  type: TYPE_NORMAL
- en: Comments and metadata
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An ARM template can contain sections that aren’t related to the JSON language
    itself. You have a few options to add comments and metadata.
  prefs: []
  type: TYPE_NORMAL
- en: Comments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To comment the rest of a line, `//` is used, or to comment a block, the `/*
    */` notation is used. This makes the following snippets both valid as part of
    an ARM template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Another deviation from JSON is that ARM templates allow for a multiline string.
    You can break a string into multiple lines. See the `location` property in the
    preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding example, you will notice the use of comments and metadata in
    your templates.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: To deploy templates with multiline strings and comments, use Azure PowerShell
    or the Azure CLI. For the CLI, use version 2.3.0 or later, and specify the `--handle-extended-json-format` switch.
  prefs: []
  type: TYPE_NORMAL
- en: metadata
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Text you add to a metadata description is automatically used as a tip for that
    parameter. ARM will ignore the `metadata` object, and this can be added anywhere
    in the template.
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Resources are the main part of the template, where all of the resources to
    be created are specified. This section is the only one that is not an object,
    but an array. Within that array, one or more objects of the following form are
    specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Each resource is specified in the form of an object. The first four properties
    are mandatory for every type of resource:'
  prefs: []
  type: TYPE_NORMAL
- en: The type of the resource to be created or updated needs to be specified. This
    takes the form of the name of `resourceprovider` followed by a slash and the name
    of a resource type that belongs to that `resourceprovider`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The version of the REST API to use for this resource: A list of supported API
    versions can be retrieved from [https://docs.microsoft.com/en-us/azure/templates/microsoft.resources/allversions](https://docs.microsoft.com/en-us/azure/templates/microsoft.resources/allversions).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The name for the resource: Every resource type has its own rules for determining
    what a valid name is. These can also available in the reference link shared in
    preceding point.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many resources will need to have a location. If the resources require a location,
    you must specify one for each resource. The location does not have to be the same
    as the location of the resource group. The location must be a valid Azure region.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All other properties on the object vary from resource type to resource type
    and are all specified in the resource.
  prefs: []
  type: TYPE_NORMAL
- en: Dependent resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A special type of resource is the dependent resource. For example, SQL databases
    are hosted on SQL Server and Service Bus topics are located within a Service Bus
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'For a nested resource type, the type and name reflect this nesting. The following
    example shows the explicit dependency of Service Bus topics on a Service Bus namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Next to nesting the type and the name, the extra property, `dependsOn`, is also
    mandatory to specify that this nested resource can only be created after the containing
    resource exists. A `location` property is not necessary since this will be inherited
    from the containing resource.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following sample depicts a logical dependency between Azure SQL Server
    and Azure SQL Database. When the `dependson` property is utilized, an explicit
    deployment dependency between a child resource and the parent resource is established
    automatically. The child resource will be deployed after the parent resource.
    Here, you will notice the use of the built-in important `resourceID` function.
    The `resourceID` function returns the unique identifier of a resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: A **circular dependency** is a problem with dependency order, resulting in the
    deployment running in a loop, unable to continue and complete the deployment.
    ARM identifies circular dependencies during template validation.
  prefs: []
  type: TYPE_NORMAL
- en: Nested templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A second special type of resource is template deployment. This way, one template
    can trigger the deployment of another. An example of defining a template deployment
    as a resource in a template looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The locations of the template and parameter file can be specified using both
    HTTP and HTTPS, that is, with a valid **Uniform Resource Identifier** (**URI**),
    but have to be publicly accessible locations. Although the template URI needs
    to be accessed externally, we would like to enable security and restrict access
    for these templates. To gain access during deployment, append an SAS token to
    the template file URI As an alternative, a single property template can be specified.
    This should then contain a whole template as a JSON object. However, you can’t
    use both inline parameters and a link to a parameter file.
  prefs: []
  type: TYPE_NORMAL
- en: Outputs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next section of a template is the outputs section. Here are the keys returned
    to the caller of the template. The caller can use these values to start another
    task or script and use one or more of the values created or used by the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main use for this is to prevent hardcoding names and other dynamic values,
    especially IPs, in downstream automation. The outputs section is a JSON object
    of the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When specifying outputs, the same types can be used as for parameters. Of course,
    it does not make much sense hardcoding the values, so functions are used to retrieve
    values from parameters, variables, or even created resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'To continue with the previous example in the *Dependent resources* section
    for creating a SQL server, a sample of the output would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Well, so far, we have learned about the different parts that make up an ARM
    template, which you should be able to write on your own. Now it’s time to learn
    how we can deploy them with the help of various tools.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying ARM templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once an ARM template and its accompanying parameter files are written, they
    can be applied to an Azure environment. There are PowerShell cmdlet and Azure
    CLI commands available for applying an ARM template from a scripting environment.
    When ARM templates are used for the infrastructure of an application, Azure Pipelines
    can be used for deploying not only code but also ARM templates. Other alternatives
    for deploying templates in Azure include the Azure portal, Azure CLI, REST API,
    and Azure Cloud Shell or ARM template specs.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever deployment method is used (REST API, Azure CLI, or ARM templates),
    it will all have a *deployment mode*. This can be either *Incremental* or *Complete*.
    In Incremental mode, all resources specified in the template will be created in
    Azure or their properties will be updated if the resource already exists. In Complete
    deployment mode, any resources that are not defined in the ARM template will be
    deleted. This mode does not redeploy all resources; instead, it verifies that
    the resources stated in the template have been created and removes those that
    have not been defined and already exist in Azure.
  prefs: []
  type: TYPE_NORMAL
- en: The default deployment mode is Incremental.
  prefs: []
  type: TYPE_NORMAL
- en: In the next sections, several tools for executing deployments are discussed,
    starting with PowerShell.
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For the local development and testing of ARM templates on a local machine,
    PowerShell has a quick command to apply an ARM template to a resource group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will pick up the specified template and parameter file
    and apply it to the specified resource group. This command assumes that the current
    session has already been logged in to Azure.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few variations of the command available:'
  prefs: []
  type: TYPE_NORMAL
- en: A parameter called `-Mode` with a `Complete` or `Incremental` value is available.
    This can be used to specify `deploymentmode`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If no parameter file is specified and the template requires parameters, the
    cmdlet will prompt for these values on the command line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As an alternative, the `-TemplateUri` and `-TemplateParametersUri` options can
    be used to specify the location of the template and parameters to be retrieved
    from another location.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next tool that we’ll look into is the Azure CLI.
  prefs: []
  type: TYPE_NORMAL
- en: The Azure CLI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Azure CLI is another way of deploying ARM templates from the command line.
    The benefit of the CLI is that it is completely cross-platform and runs on Windows,
    macOS, and Linux. The Azure CLI command for deploying an ARM template is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: All other options that are available in PowerShell are also available in the
    CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Pipelines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A third mechanism for deploying ARM templates is from an Azure pipeline. This
    is particularly useful for deploying the infrastructure and configuration of an
    application, together with the binaries. To deploy an ARM template deployment
    from a pipeline, at least one service connection of the ARM template needs to
    be configured. After doing this, a pipeline can be configured, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Azure Pipelines ARM template deployment ](img/B18655_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Azure Pipelines ARM template deployment
  prefs: []
  type: TYPE_NORMAL
- en: In this example, there are two deployments of an ARM template, surrounding the
    deployment of the application code. The first deployment is of the Incremental
    mode, while the second deployment is of the Complete mode.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The ARM template test toolkit is available at [https://github.com/Azure/arm-ttk](https://github.com/Azure/arm-ttk)
    for you to make ARM templates compliant with standard practices.
  prefs: []
  type: TYPE_NORMAL
- en: Using this approach, the first deployment will create all new infrastructure
    needed by the new version of the application. This deployment is done in Incremental
    mode, so infrastructure that is no longer present in the template but still in
    use by the currently deployed version of the application will not yet be removed.
    The second deployment will take care of removing these elements after the new
    version of the code is deployed.
  prefs: []
  type: TYPE_NORMAL
- en: ARM REST API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ARM provides REST API operational groups to deploy and manage infrastructure
    to Azure. In order to get a list of resources in a subscription, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use ARMClient, a simple command-line tool, to send HTTP requests to
    the new ARM REST API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command gets a list of resources in the subscription. Please note
    that ARM client is not an official Microsoft tool. It is an OSS project that is
    maintained on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, you can use the `az rest` command to run these commands. Take the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Azure Cloud Shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Azure Cloud Shell provides a Bash and PowerShell experience to manage and deploy
    Azure resources from within the browser itself. Azure Cloud Shell is hosted in
    Azure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Azure Cloud Shell ](img/B18655_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Azure Cloud Shell
  prefs: []
  type: TYPE_NORMAL
- en: 'The Azure Cloud Shell command for deploying an ARM template in a resource group
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: All other options that are available in the Azure CLI are also available in
    Azure Cloud Shell.
  prefs: []
  type: TYPE_NORMAL
- en: Reverse engineering a template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Writing an ARM template from scratch can be a tedious and time-consuming task.
    Luckily, there are two approaches available to generate an ARM template from existing
    infrastructure:'
  prefs: []
  type: TYPE_NORMAL
- en: Using **Export template**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using **Resource Explorer**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s discuss both of these in the upcoming subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Using Export template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first approach is using the **Export template** option, which can be found
    on every resource and resource group in the Azure portal. This will generate an
    ARM template of the current state of the resource (group), as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Exporting an ARM template  ](img/B18655_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – Exporting an ARM template
  prefs: []
  type: TYPE_NORMAL
- en: Please note that not every service currently supports reverse engineering an
    ARM template using this approach. For any service not supported, there will be
    a warning at the top of the screen. To work around this limitation for retrieving
    the JSON template for an individual resource, there is another approach, which
    is our next topic of discussion. The E`xport template` process will create a reusable
    ARM template. However, most exported templates require some modifications before
    they can be used to deploy Azure resources.
  prefs: []
  type: TYPE_NORMAL
- en: Using Resource Explorer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To retrieve the JSON template for an individual resource, we can use **Resource
    Explorer**. Resource Explorer is shown here and can be found in the Azure portal
    by using the menu (**1**):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Azure Resource Explorer  ](img/B18655_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – Azure Resource Explorer
  prefs: []
  type: TYPE_NORMAL
- en: After opening Resource Explorer, two new panes open up. The left pane can be
    used to navigate through subscriptions and drill down into the resource groups,
    down to the individual resources. For every element that is selected, the corresponding
    JSON will be displayed on the right. In the preceding example, the JSON for a
    hard disk is shown. This JSON is the same as the JSON that can be used in the
    resources array of an ARM template, except the ID element. Note that due to the
    different API versions used, the JSON output and the relevant template resource
    may vary.
  prefs: []
  type: TYPE_NORMAL
- en: Subscription-level templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The discussion of ARM templates up to this point has all been about ARM templates
    for a resource group deployment. A template describes one or more resources that
    are deployed to a resource group. Additionally, there are also subscription-level
    templates. An example ARM template for a resource group is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The format for a subscription template is completely the same as that for a
    resource group. The differences are `$schema`, which points to another schema
    location, and the types of resources that are supported. Subscription templates
    do not support the creation of resources directly and support only the creation
    of resource groups, the initiation of template deployments, creating and assigning
    Azure policies, and the creation of role assignments.
  prefs: []
  type: TYPE_NORMAL
- en: Azure Blueprints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Next to subscription-level templates, there is also another offering available:
    Azure Blueprints. Blueprints can be used to describe the desired state of an Azure
    subscription and apply that to an existing subscription.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the things that can be done using a blueprint can nowadays also be done
    using an ARM template. However, the other way around is not true. Azure Blueprints
    only supports the following constructs, which are called artifacts:'
  prefs: []
  type: TYPE_NORMAL
- en: Policy assignments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Role (RBAC) assignments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Resource group creation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested ARM templates at the subscription or resource group level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are all of the elements that are needed to build the default layout, or
    a blueprint, for Azure subscriptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of key differences between blueprints and ARM templates:'
  prefs: []
  type: TYPE_NORMAL
- en: A blueprint is a resource you can create and navigate to in the portal. The
    authoring experience is also in the portal, not in text files on a local computer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The relationship between a subscription and the blueprint that was used to create
    it remains, also after the deployment completes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the assignment of a blueprint to a subscription, it is possible to mark
    the assignment as locked. If this is done, all of the resources deployed through
    the blueprint cannot be deleted or edited as long as the blueprint is applied—not
    even by the owners of the subscription that it is assigned to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many built-in blueprints available that can be used to implement controls
    from well-known standards such as ISO, NIST, or HIPAA.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Blueprints is still in preview at the time of writing. While using Blueprints,
    you can install RBAC roles, ARM templates, and Azure policies all at once and
    assign them to a certain scope. Removing the assignment does not delete or remove
    the resources, thus this soon becomes tedious, and Azure DevOps has no tasks or
    automation to manage blueprints at scale.
  prefs: []
  type: TYPE_NORMAL
- en: Bicep
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bicep is a **Domain-Specific Language** (**DSL**) that allows the declarative
    deployment of Azure resources. Everything you can do with an ARM template can
    be accomplished with Bicep as well.
  prefs: []
  type: TYPE_NORMAL
- en: Bicep provides all resource types and API versions. Bicep provides a better
    authoring experience as it supports type safety and a simple declarative syntax.
    Bicep files are idempotent, and one file will represent the desired state. You
    can then use that file to repeatedly deploy your infrastructure in a consistent
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: Bicep is a transparent abstraction over ARM template JSON and supports JSON
    template capabilities. The Bicep CLI converts a Bicep file into ARM template JSON.
    You can use the Bicep Playground ([https://aka.ms/bicepdemo](https://aka.ms/bicepdemo)) to
    view Bicep and equivalent JSON side by side.
  prefs: []
  type: TYPE_NORMAL
- en: 'To decompile ARM template JSON to Bicep in the Azure CLI, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The command creates a file named `deployment.bicep`. Decompiling an ARM template
    helps you get started with Bicep development.
  prefs: []
  type: TYPE_NORMAL
- en: Using Azure Automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Azure Automation is a service in Azure that is designed to help users to create,
    manage, deploy, and maintain their Azure resources. Azure Automation contains
    several concepts that remove some of the complexities and low-level details from
    these actions. Azure Automation allows for the formulation of workflows in the
    form of runbooks. These runbooks can be executed against Azure resources on behalf
    of the user.
  prefs: []
  type: TYPE_NORMAL
- en: Automation account resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Within an Azure Automation account, there are several resources that make this
    more than just a scripting engine. These resources are shared on the level of
    the Automation account and can hence be reused within multiple runbooks.
  prefs: []
  type: TYPE_NORMAL
- en: Run As account
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first of these constructs is the *Run As* account. This account is a service
    principal that will be created in the AAD that the Azure subscription containing
    the Automation account is linked to. The credentials to authenticate as this service
    principal are securely stored within the Automation account. These credentials
    are non-retrievable directly from an Automation account. The service principal
    is also added as a contributor to the Azure subscription. As a result, runbooks
    can now be set up to execute using this account. Run As accounts can be automatically
    created when creating the Automation account.
  prefs: []
  type: TYPE_NORMAL
- en: Run As account functionality is still available for current and new Automation
    accounts. However, the Run As account has been replaced with managed identities.
    Managed identities are the recommended way to authenticate in your runbooks and
    the default authentication method for your Automation account. Because no credentials
    are saved, a managed identity is more secure and easier to use. If you use Run
    As in your runbook code, you should change it to use managed identities instead.
  prefs: []
  type: TYPE_NORMAL
- en: Schedules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A common way of automating workflows is scheduling them to run on a specific
    date and time or at a fixed interval. Instead of specifying a schedule for every
    workflow, shared schedules can be created and reused in runbooks. To create a
    new schedule, first, open the list of all schedules. After that, a new schedule
    can be added, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Azure Automation workflow schedules ](img/B18655_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – Azure Automation workflow schedules
  prefs: []
  type: TYPE_NORMAL
- en: A schedule has a name and a description. These values are for the users interacting
    with the schedule only. Next, a starting date and time can be configured, along
    with an optional recurrence interval, and, if a recurrence interval is specified,
    an expiration date and time.
  prefs: []
  type: TYPE_NORMAL
- en: Once the schedule is created, it can be used for a runbook.
  prefs: []
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The runbooks that are used in Azure Automation are written in PowerShell or
    Python. PowerShell has a very rich ecosystem of modules with predefined functionalities
    that can be used. To use PowerShell modules from an Automation account, only modules
    that have been uploaded to the modules section can be used. One major benefit
    of this is that it is possible to fix the version of a module to use. This guarantees
    that scripts will keep working and not break in case of updates to dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: The PowerShell modules for interacting with Azure are by default installed into
    every Automation account. Furthermore, more modules can be added, and existing
    modules can be upgraded or removed by administrators.
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Within runbooks, a lot of variables might come into play: the names of resource
    groups, virtual machines, startup or shutdown times, and so on. Hardcoding these
    values inside a script is not good practice but storing them together with a runbook
    also has downsides. For example, in the case that there are three runbooks for
    the same virtual machine, this would mean that a number of variable values (for
    example, resource group name and virtual machine name) would be repeated at least
    three times. To prevent this, it is possible to store variable values at the Automation
    account level, from where they can be reused throughout every runbook that is
    executed in that account.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a variable is set, it can be accessed from a runbook using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to reading and using variables inside a runbook, they can also
    be updated from within a runbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: While a very powerful feature, updating variables from within runbooks can have
    unexpected consequences. If a variable value that is used in multiple runbooks
    gets updated by one of them, this might break the other runbooks. Keeping track
    of which variables are read-only and which are written to as well is important.
  prefs: []
  type: TYPE_NORMAL
- en: Credentials
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'A special type of variable is the credential. Credentials contain not one but
    two values: a username and a password. Credentials are treated as secrets everywhere
    they are used. This means that they will not appear in logs and that they have
    to be retrieved using a specific PowerShell syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: After executing this command, the `myCredential` object can be used to retrieve
    both the username and password.
  prefs: []
  type: TYPE_NORMAL
- en: Connections
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: It is a very common scenario to have to connect to one or more external services
    from within a runbook. A common example is the ARM template that is used to manage
    all resources within Azure. To avoid having to store a series of variables and
    build the corresponding connection in a runbook, Automation accounts allow for
    the creation beforehand of one or more connections.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: In most scenarios, it is not necessary to create connections manually as they
    are provided along with a Run As account.
  prefs: []
  type: TYPE_NORMAL
- en: Once all of the shared resources are in place, it is time to start writing one
    or more runbooks, which is our next topic of discussion.
  prefs: []
  type: TYPE_NORMAL
- en: Runbooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Azure Automation supports a number of types of runbooks: PowerShell, Python
    2, and graphical. The first two allow for writing scripts in the specified language.
    Graphical runbooks allow for composing a runbook from all uploaded PowerShell
    modules, assets, and existing runbooks using drag and drop.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these three basic types of runbooks, there are PowerShell workflow
    and graphical workflow types available. The difference between a regular runbook
    and a workflow runbook is that workflow runbooks also support parallelism. Another
    benefit of PowerShell workflow is that it supports the use of checkpoints, which
    allow a script to be resumed if it encounters an exception mid-execution.
  prefs: []
  type: TYPE_NORMAL
- en: Runbook execution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once the runbook is written, there are a number of ways to execute it:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Manually**: Any runbook can be run at any time by opening it in the Azure
    portal and pressing **Start**. Of course, these operations are also available
    using PowerShell or the Azure CLI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**By attaching a webhook**: Once a runbook is published, one or more webhooks
    can be generated for executing the runbook. Each webhook can be enabled or disabled
    or given an expiration date. These tools allow a new webhook to be generated for
    every user of the runbook and fine-grained control to be initiated if ever, in
    the future, access should not be accorded to a particular user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**On a schedule**: Published runbooks can be attached to one or more of the
    shared schedules. Being able to attach to multiple schedules means that it is
    easy to precreate a series of schedules for typical reoccurrences, such as hourly,
    daily, or every Monday, and reuse and combine these for the appropriate runbooks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When executing the runbook from a webhook or on a schedule, the option to run
    it manually will stay available.
  prefs: []
  type: TYPE_NORMAL
- en: Jobs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every time a runbook is executed, a new entry is created in the **Jobs** log.
    This log will show an entry for every time the runbook has run, no matter how
    the execution was initiated. Every entry will contain the date and time the run
    was started, whether there were errors, and a full execution log.
  prefs: []
  type: TYPE_NORMAL
- en: Runbooks gallery
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Runbooks are a great way of automating common tasks. Of course, there are tasks
    that are only for specific customers, but there are also many tasks that are applicable
    to all Azure customers. Examples include the automated startup of a virtual machine
    every Monday at 8 A.M. or scaling up a database every morning and back down every
    evening.
  prefs: []
  type: TYPE_NORMAL
- en: For these common scenarios, there is the runbooks gallery, which is enabled
    within every Automation account. In this gallery, hundreds of premade runbooks
    can be browsed and searched. Once an appropriate runbook has been found, it can
    be imported directly into the account as a runbook.
  prefs: []
  type: TYPE_NORMAL
- en: Besides executing scripts at set intervals or upon the invocation of a webhook,
    Azure Automation can also be used as a PowerShell DSC pull server. Let’s discuss
    this next.
  prefs: []
  type: TYPE_NORMAL
- en: Before you run a new runbook that you’ve created or imported, you must first
    publish it. Each Azure Automation runbook has a Draft and a Published edition.
    Only the Published version can be run, and the Draft version can be modified.
    Any modifications to the Draft version have no effect on the Published version.
    When the Draft version is ready, you publish it, replacing the existing Published
    version with the Draft version.
  prefs: []
  type: TYPE_NORMAL
- en: PowerShell DSC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: PowerShell DSC is a notion for specifying the configuration of servers. This
    configuration is stored on a pull server, where it can be accessed by one or more
    virtual machines. These virtual machines are configured to check this server at
    a specified interval for the latest DSC configuration and update themselves to
    comply with this configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'PowerShell DSC is an extension to the PowerShell language specification that
    is used for writing desired state configurations. A configuration enables the
    desired state of one or more nodes to be specified. A node specifies which server,
    or set of servers, is to be configured. The configuration for a node is written
    in the form of one or more resources. An example configuration is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the configuration for a server farm with a single type of server
    is described. This server contains two resources. The first one, of the `WindowsFeature`
    type, with the name `IIS` is installed together with all of its subfeatures. The
    second resource, of the `File` type, ensures that a directory, `c:\logs`, exists.
    The resource types of `IIS` and `File` and many more are built into the PowerShell
    DSC specification. A full reference of all resources is available online and a
    link is included at the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Compiling and applying PowerShell DSC
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: PowerShell DSC files are saved in plaintext, often in a `.ps1` file. These files
    can be compiled into **Managed Object Format** (**MOF**) files. These MOF files
    can then be pushed to one or more servers to update the state of the server to
    the state described in the MOF file. This is called **push mode**.
  prefs: []
  type: TYPE_NORMAL
- en: Besides push mode, there is another mode for deploying MOF files. This is called
    **pull mode**. In pull mode, MOF files are not directly pushed to individual servers
    but stored on a central server, which is called the **pull server**. This way,
    the pull server has a complete record of all configurations and node definitions
    within those configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Once the pull server is up and running, individual servers are configured to
    fetch their DSC configuration at a fixed interval and apply that configuration.
    Applying a configuration means that, for every defined resource, the described
    state will be enacted. This can be done by doing nothing if the actual state already
    matches the desired state, or by running commands to achieve the desired state.
    In this process, all previous changes—even by administrators—will be reverted
    if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Using PowerShell DSC with Azure Automation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Azure Automation has built-in capabilities for PowerShell DSC and can fulfill
    the role of pull server for one or more virtual machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start using the built-in pull server capabilities, upload one or more configuration
    files to the Automation account. This is done from the **State configuration**
    view that is shown in the following screenshot. Now, complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open by clicking the menu option on the left.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Configurations** in the tab bar at the top.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.7 – Azure Automation state configuration ](img/B18655_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – Azure Automation state configuration
  prefs: []
  type: TYPE_NORMAL
- en: Once the overview of all configurations is opened, new configurations can be
    added using the `topHere`, a local `ps1` file can be selected, and that will be
    added to the list. Any valid configuration in the list can be clicked on and compiled
    in place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, the configuration will also be shown in the tab with compiled configurations
    and can be applied to one or more virtual machines.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once a compiled configuration is available, the **Nodes** tab can be used for
    adding one or more virtual machines from the subscription to a configuration node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Clicking the **Add** button while this tab is shown opens the view shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Azure Automation – adding a new virtual machine ](img/B18655_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – Azure Automation – adding a new virtual machine
  prefs: []
  type: TYPE_NORMAL
- en: In this view, a virtual machine can be selected to which the selected configuration
    should be applied.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The local configuration manager on that machine will be configured to refresh
    the configuration at fixed intervals.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Whenever the configuration is refreshed, it will be reapplied to the server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Azure Automation enables users to manage virtual machines, for example, to apply
    application configuration. When working with PaaS offerings, this cannot be done
    using techniques such as PowerShell DSC; other techniques have to be used to manage
    application settings. These will be discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Managing application settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another part of the infrastructure of an application is the application configuration.
    In this section, a number of approaches for storing and loading the application
    configuration for an Azure App Service are discussed. They include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Storing the configuration in the app settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a combination of a managed identity and key vault
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Azure App Configuration service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The disadvantage of the first approach is that the app settings can be read
    by any user who has administrative (read) access to the app service that is configured.
    The next two approaches do not have this disadvantage.
  prefs: []
  type: TYPE_NORMAL
- en: Azure App Service settings from an ARM template
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first way to configure application settings as code is by specifying app
    settings as a resource in an ARM template. This should be specified as a nested
    resource. This can be done as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The use of the `listKeys` function is especially useful in these scenarios.
    It allows for the direct copying of secrets from supported services to the application
    settings without ever storing them in an intermediate solution. For secrets that
    do not come from Azure sources, template parameters should be used.
  prefs: []
  type: TYPE_NORMAL
- en: The configuration specified in the ARM template corresponds to the configuration
    of an app service that can be found in the portal. These settings are used to
    override corresponding entries in the `appsettings.json` or `appsettings.config`
    files. Updating this configuration automatically reloads the application as well.
  prefs: []
  type: TYPE_NORMAL
- en: The downside of this approach is that secrets that are stored this way are readable
    through the Azure portal. Any user with read access to the app service can retrieve
    all secrets stored this way.
  prefs: []
  type: TYPE_NORMAL
- en: Loading settings at runtime from a key vault
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next possible location for storing app service settings is in an Azure key
    vault, where the application loads them at runtime. To make this possible, the
    following has to be in place.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to authorize an application with access to a key vault, the application
    first has to be able to authenticate itself against AAD. Of course, this can be
    done by registering a service principal manually, but this would return a username
    and password that have to be stored somewhere. Usernames and passwords are secrets
    but cannot be stored in the key vault since they are needed for accessing it.
    This problem of how to keep the key to the vault safe can be solved by using an
    Azure capability called a **managed identity**.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: The problem of securely storing secrets but getting another secret in return
    for accessing them is often referred to as the problem of *turtles all the way
    down*. This refers to an old anecdote to which a link is included at the end of
    this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: With an Azure managed identity enabled on an app service, Azure automatically
    generates a service principal with a non-retrievable username and password. Only
    at runtime, using specific code, can an application authenticate itself as this
    principal. Azure will ensure that this will only work for code that is running
    with the app service that the managed identity belongs to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that an application can have its own identity, that identity has to be
    granted access to the key vault. This can be done in the key vault description
    in an ARM template, using the following syntax for reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `reference()` function is used to retrieve the information
    of the managed identity and uses this to create an access policy on the key vault.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, with the key vault and access to it set up, the application has to
    retrieve the contents at startup time. To do this, config builders can be used.
    They are introduced with .NET Core 2.0 (and .NET Framework 4.7.1) and are used
    in the `StartUp` class, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: All types in this code example are available in the NuGet `Microsoft.Configuration.ConfigurationBuilders.Azure`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: Azure App Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another location for storing the configuration of applications is Azure App
    Configuration. This is a new service, and at the time of writing, it is still
    in preview. App Configuration allows for the creation of a central register of
    key-value pairs that can be used as configuration by such a register, but also
    multiple applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'App Configuration is another type of resource that can be created from the
    portal. The main component is a **Configuration explorer,** as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – Azure App Configuration ](img/B18655_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – Azure App Configuration
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the Configuration explorer, there is a keys section for retrieving
    access keys that applications can use to read the configuration. There are also
    options to view recent changes to the configuration and restore earlier versions
    and for importing or exporting all configuration settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the App Configuration resource has been created and configuration keys
    added, they can be retrieved from within an application by using an extension
    method of the **IConfiguration** framework type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The loader for settings from an app configuration is part of the NuGet `Microsoft.Azure.AppConfiguration.AspNetCore`
    package.
  prefs: []
  type: TYPE_NORMAL
- en: 'Compared to storing settings in Azure Key Vault, App Configuration has two
    downsides:'
  prefs: []
  type: TYPE_NORMAL
- en: First, the application needs to be configured with a connection string to the
    Azure App Configuration, storing at least one new secret in the app settings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second App Configuration does not have access control options that are as rigid
    as Key Vault. For this reason, it might make sense to distribute configuration
    over both App Configuration and Key Vault, depending on the type of configuration
    value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This concludes our discussion of Azure and Azure DevOps capabilities for IaC.
    The next section will discuss a series of other tools available that offer similar
    capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Other tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are many other tools available for managing infrastructure and configuration
    through code. Next to the native Azure and Windows options discussed in the previous
    sections, there are many alternatives widely in use and some of them are listed
    in this section. It is important to know which tool can be used for which scenarios
    and how to integrate with them.
  prefs: []
  type: TYPE_NORMAL
- en: CloudFormation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CloudFormation is the IaC language for the AWS cloud. CloudFormation templates
    can be written in either JSON or YAML format. One example of creating an AWS S3
    storage bucket that is publicly readable would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: There is an extension available that allows the execution of CloudFormation
    templates on AWS from Azure DevOps. This extension provides tasks for creating,
    updating, or deleting AWS stacks. A stack has a function that is comparable to
    a resource group in Azure and the tasks are comparable to the tasks for applying
    an ARM template.
  prefs: []
  type: TYPE_NORMAL
- en: Chef
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Chef is a tool for CaC, with support for describing and enforcing the configuration
    of servers. Chef uses a centralized server, the **Chef server**, where all configuration
    for all servers is saved. Here, the correct desired state for every server is
    determined, which is then pulled by the **Chef client**, an agent that runs on
    the *node* that is being managed.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the desired state for a server is done using a number of constructs.
    The lowest level is the recipe. A recipe contains one or more resources, which
    are built-in capabilities that can be used. An example resource is `execute`,
    which runs a Bash command. Another example resource is `apt_update`, which provides
    the means to interact with the `apt` package manager. One or more recipes are
    combined in cookbooks, which describe a capability that can be assigned to a node.
    The assignment of one or more cookbooks to a node is done using the run list.
    The run list contains all cookbooks that have to be applied to a node.
  prefs: []
  type: TYPE_NORMAL
- en: Interaction with the Chef server is done using a command-line tool called `knife`.
  prefs: []
  type: TYPE_NORMAL
- en: While the terminology is completely different, there are many conceptual parallels
    between PowerShell DSC and Chef.
  prefs: []
  type: TYPE_NORMAL
- en: Puppet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Puppet is a deployment and configuration management tool that operates using
    a server-client model. There is a centralized server called the **Puppet master**
    that is responsible for taking in all of the desired state descriptions and compiling
    them to an internal catalog that holds the desired state for every managed server.
    All servers that are managed by Puppet need to have the Puppet agent installed
    on the local server. The agent connects to the server to pull the state for the
    server it manages, and applies that locally. A managed server is called a **node**.
  prefs: []
  type: TYPE_NORMAL
- en: The base building block used by Puppet is called a **resource**. A resource
    is defined by specifying a resource type and a series of attributes. There are
    many resource types available, for example, for managing users and installed applications.
    Resources are grouped into one or more *classes*. These classes are, in turn,
    assigned to one or more nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Puppet can be installed on any Linux or Windows virtual machine in Azure. There
    is also a prebuilt image with Puppet Enterprise available in the Azure Marketplace.
  prefs: []
  type: TYPE_NORMAL
- en: Puppet is comparable to Chef and PowerShell DSC. All three have a comparable
    model for describing the desired state and they all serve the same purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ansible is yet another configuration management tool that is mostly used on
    Linux but also has support for Windows. One aspect that differentiates Ansible
    from other tools is that it does not have a centralized server that hosts all
    of the desired states, nor does it work with agents. All commands executed by
    Ansible are executed using SSH or other relevant protocols—HTTP(S), WinRM, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: Any server can initiate the deployment of a *playbook* against one or more *items*
    in an *inventory*. An Ansible inventory contains all of the servers that can be
    managed by Ansible. They can be grouped into one or more groups, which can be
    nested into other groups as well. Each individual server and every group is an
    inventory item. In Ansible, the desired state is written in playbooks. A playbook
    is a series of tasks or roles that need to be run on the target server. A role
    is a group of tasks. Roles are intended to be reused in more than one playbook
    and should, therefore, be general enough to be usable in multiple situations.
    Roles should also be idempotent. This means that the tasks in the role should
    ensure that the outcome of running the playbook is the same, no matter the number
    of times it is run.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible scripts can be executed using command-line tools or an Azure DevOps
    extension that wraps this tool. There are also other management systems available,
    such as Ansible Tower, which provides a graphical user interface on top of the
    capabilities of the Ansible command-line tools.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Terraform** is a multicloud infrastructure management solution. It is comparable
    to ARM templates or Bicep, the difference being that it also supports Amazon Web
    Services, Google Cloud Platform, and other supported cloud services. Terraform
    uses a custom file format for specifying one or more resources to be created using
    one or more providers. The resources correspond to the cloud resources, and the
    providers are responsible for knowing how to interact with the APIs of the different
    vendors.'
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, you can use a JSON format instead of the Terraform proprietary format
    called **HashiCorp Configuration Language** (**HCL**). Terraform also supports
    the use of modules for creating packages that are reusable components.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform configuration files are executed using CLIs.
  prefs: []
  type: TYPE_NORMAL
- en: You can refer to the Terraform fundamentals ([https://learn.hashicorp.com/collections/terraform/cli](https://learn.hashicorp.com/collections/terraform/cli))
    to learn about these core components.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the concepts of IaC and CaC, their value,
    and how to use them in practice. To implement these, you learned about ARM templates,
    the IaC mechanism for Azure. You also learned about PowerShell DSC to manage the
    configuration of virtual machines and about different techniques for managing
    the configuration of your applications. Finally, you learned about several other
    tools available on the market. You learned which tool can be used in which situation
    and whether these tools can integrate with Azure DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, you are now able to start describing the infrastructure
    and configuration of your application(s) in source control using one or more of
    the tools you have read about. You are also capable of setting up the means to
    deliver the infrastructure using automation, either from a release pipeline or
    using dedicated infrastructure management tools. But no matter which solution
    you choose, you now have the capabilities to incorporate infrastructure into your
    DevOps processes.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about another challenge you might encounter
    when implementing DevOps practices, related to databases. When increasing the
    speed at which features flow to production, you may also have to change the way
    you manage your database schema and how you apply changes. The next chapter will
    discuss this subject.
  prefs: []
  type: TYPE_NORMAL
- en: Activity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Create And Deploy Empty ARM template using Azure CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a resource to create Storage account in your ARM template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we conclude, here is a list of questions for you to test your knowledge
    regarding this chapter’s material. You will find the answers in the *Assessments*
    section of the Appendix:'
  prefs: []
  type: TYPE_NORMAL
- en: 'True or False: ARM templates in Incremental deployment mode can be used for
    creating, updating, and deleting Azure resources.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the following is not an Azure Automation account resource?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Containers
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Managed identities
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or False: One disadvantage of IaC is that you have to put sensitive information
    in source control as ARM template parameter files.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or False: Azure Automation accounts allow for the execution of PowerShell
    runbooks at a predefined schedule.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are some of the benefits of using IaC?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A formal breakdown of the ARM template structure and syntax can be found at
    [https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-expressions](https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-expressions).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The complete ARM template documentation can be found at [https://docs.microsoft.com/en-us/azure/templates/](https://docs.microsoft.com/en-us/azure/templates/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of all functions that can be used in ARM templates can be found
    at [https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-functions](https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/template-functions).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about Azure Blueprints can be found at [https://docs.microsoft.com/en-us/azure/governance/blueprints/overview](https://docs.microsoft.com/en-us/azure/governance/blueprints/overview).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Details about the `WhatIf` command for ARM templates can be found at [https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/deploy-what-if](https://docs.microsoft.com/en-us/azure/azure-resource-manager/templates/deploy-what-if).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation for all PowerShell DSC built-in resources, can be found at [https://docs.microsoft.com/en-us/powershell/dsc/overview/decisionmaker?view=dsc-1.1](https://docs.microsoft.com/en-us/powershell/dsc/overview/decisionmaker?view=dsc-1.1).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about CloudFormation can be found at [https://aws.amazon.com/cloudformation/](https://aws.amazon.com/cloudformation/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about Chef can be found at [https://www.chef.io/](https://www.chef.io/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about Puppet can be found at [https://puppet.com/](https://puppet.com/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about Ansible can be found at [https://www.ansible.com/](https://www.ansible.com/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about Terraform can be found at `https://www.terraform.io/`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More information about Azure resource manager commands [https://docs.microsoft.com/en-us/cli/azure/deployment/group?view=azure-cli-latest#az-deployment-group-create](https://docs.microsoft.com/en-us/cli/azure/deployment/group?view=azure-cli-latest#az-deployment-group-create)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Bicep overview:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/Azure/bicep](https://github.com/Azure/bicep)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/azure-resource-manager/bicep/learn-bicep](https://docs.microsoft.com/en-us/azure/azure-resource-manager/bicep/learn-bicep)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Learning path to explore the *Infrastructure as Code*: [https://docs.microsoft.com/en-us/learn/paths/az-400-manage-infrastructure-as-code-using-azure/](https://docs.microsoft.com/en-us/learn/paths/az-400-manage-infrastructure-as-code-using-azure/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are many online references to the story of *turtles all the way down*,
    but an early reference can be found digitized at [https://dspace.mit.edu/handle/1721.1/15166](https://dspace.mit.edu/handle/1721.1/15166).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
