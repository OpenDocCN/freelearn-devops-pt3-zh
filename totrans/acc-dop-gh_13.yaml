- en: '*Chapter 11*: Trunk-Based Development'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第11章*：基于主干的开发'
- en: One of the capabilities that are highly correlated with accelerated engineering
    velocity is `git` **workflow** but rather a branching model of choice that has
    been in use since the 80s. It is not well defined and leaves a lot of room for
    interpretation, especially when it comes to using it with GitHub. Also, I personally
    find that only moving to a trunk-based workflow does not increase the performance
    too much. Only large teams with a highly complex workflow that are already stuck
    in **merge hell** really have this high impact. For most teams, it is more a combination
    of different capabilities such as feature flags and **continuous integration/continuous
    deployment** (**CI/CD**), together with a trunk-based workflow, that makes a big
    difference.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 与加速工程速度高度相关的能力之一是`git` **工作流**，但它实际上是一种自80年代以来一直使用的分支模型选择。它定义不够明确，留有很多解释的空间，尤其是在与GitHub结合使用时。此外，我个人认为，仅仅转向基于主干的工作流并不会显著提升性能。只有那些在**合并地狱**中困扰的大型团队，才会有显著的影响。对于大多数团队来说，真正有效的是将不同的能力结合起来使用，比如功能标志和**持续集成/持续部署**（**CI/CD**），并与基于主干的工作流配合使用，这才会产生显著的效果。
- en: In this chapter, I'll explain the benefits of trunk-based workflows. We'll also
    cover their difference from other branching workflows, and I'll introduce you
    to what I believe is the best `git` workflow to accelerate your software delivery.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将解释基于主干的工作流的好处。我们还将讨论它们与其他分支工作流的区别，我将向你介绍我认为是加速软件交付的最佳`git`工作流。
- en: 'The chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖以下主题：
- en: Trunk-based development
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于主干的开发
- en: Why you should avoid complex branching
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么你应该避免复杂的分支
- en: Other `git` workflows
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他`git`工作流
- en: Accelerating with MyFlow
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MyFlow加速
- en: Case study
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 案例研究
- en: Trunk-based development
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于主干的开发
- en: Trunk-based development is a source-control branching model, where developers
    merge small and frequent updates to a single branch (often called a `git`, this
    is commonly referred to as the `main` branch) and resist any pressure to create
    other long-lived development branches (see https://trunkbaseddevelopment.com).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 基于主干的开发是一种源代码管理的分支模型，在这种模型中，开发者将小而频繁的更新合并到一个单一的分支（通常称为`git`，常被称为`main`分支），并抵制任何创建长期存在的开发分支的压力（见
    https://trunkbaseddevelopment.com）。
- en: The base idea is that the main branch is always in a clean state so that any
    developer, at any time, can create a new branch based upon the main branch that
    builds successfully.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 其基本理念是，主分支始终保持干净的状态，以便任何开发者在任何时候都能基于主分支创建一个构建成功的新分支。
- en: 'To keep the branch in a clean state, developers must take multiple measures
    to ensure only code that does not break anything is merged back to the main branch,
    as outlined here:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持分支的干净状态，开发者必须采取多项措施，确保只有不破坏任何东西的代码才能被合并回主分支，具体措施如下：
- en: Fetch the newest changes from the main branch
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取主分支的最新更改
- en: Perform a clean test
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行干净测试
- en: Run all tests
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行所有测试
- en: Have high cohesion with your team (pair programming or code review)
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与团队保持高度凝聚（结对编程或代码审查）
- en: As you can see, this is predestined for a protected main branch and `main` without
    branch protection. In small, highly cohesive, and co-located teams that practice
    pair-programming, this can be very effective, but it takes a lot of discipline.
    In complex environments or in distributed teams that work asynchronously, I would
    always recommend using branch protection and PRs.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这种方式特别适用于保护的主分支和没有分支保护的`main`。在小型、高度凝聚和共同工作的团队中，实践结对编程时，这种方式非常有效，但需要高度的纪律性。在复杂的环境中，或者在分布式、异步工作的团队中，我始终建议使用分支保护和PR。
- en: Why you should avoid complex branching
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么你应该避免复杂的分支
- en: When we talk about branches, we often use the terms long-lived and short-lived,
    which refer to time. I find this somehow misleading. Branches are about changes,
    and changes can hardly be measured in time. Developers can write 8 hours of code
    with a lot of refactoring and try to merge that very complex branch in 1 day.
    This would still be considered short-lived if they measured it in time only. Conversely,
    if they have a branch with just one line changed—for example, the update of a
    package that the code depends on—but the branch stays open for 3 weeks as the
    team must solve some architectural questions regarding the change, from a time
    perspective it would be long-lived, even if it would be very simple to rebase
    the changes on top of `main`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论分支时，我们经常使用长期存在和短期存在这些术语，这些术语涉及时间。我发现这有些误导。分支是关于变更的，而变更几乎无法用时间来衡量。开发人员可以花8小时编写大量重构的代码，并试图在1天内合并那个非常复杂的分支。即使他们只用时间来衡量，这仍然被认为是短期存在的。相反，如果他们有一个只改变了一行代码的分支——例如，更新代码依赖的包——但是团队必须解决一些关于变更的架构问题，从时间的角度来看，它会是长期存在的，即使在`main`分支上重新基于这些变更会非常简单。
- en: Time doesn't seem to be the best measure to distinguish good and bad practices
    for branches; it is a combination of complexity and time.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 时间似乎不是区分分支好坏实践的最佳衡量标准；它是复杂性和时间的组合。
- en: The more changes that happen in the base branch from which you created your
    branch until you try to merge your changes back, the harder it is to merge these
    changes with changes in your branch. The complexity can come from one very complex
    merge, or from many developers merging many small changes. To avoid merging, many
    teams try to finish work on a feature before merging back. This, of course, leads
    to more complex changes that then make it difficult for the other features to
    merge—so-called **merge hell**—whereby before releasing, all the features have
    to be integrated into the new release.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 基础分支从您创建分支到尝试合并您的更改之间发生的更改越多，合并这些变更与您的分支的变更就越困难。复杂性可能来自一个非常复杂的合并，或者来自许多开发人员合并许多小的变更。为了避免合并，许多团队试图在合并回去之前完成功能工作。当然，这会导致更复杂的变更，然后使得其他功能合并变得困难——所谓的**合并地狱**——在发布之前，所有功能必须集成到新版本中。
- en: 'To avoid merge hell, you should pull the latest version of the main branch
    regularly. As long as you can merge or rebase without problems, the integration
    of your branch is not a problem, but if your changes get too complex, it is a
    problem for the other developers, as they will probably have a problem if you
    merge your changes back. That''s why you should merge your changes before they
    exceed a certain amount of complexity. The extent of the complexity depends a
    lot on the code you modify and you would need to consider the following points:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免合并地狱，你应该定期拉取主分支的最新版本。只要您能够无问题地合并或重新基于，您的分支的集成就不是问题，但如果您的更改变得过于复杂，对其他开发人员来说就是个问题，因为如果您合并您的更改回去，他们可能会遇到问题。这就是为什么在复杂度超过一定程度之前，您应该合并您的更改的原因。复杂性的程度很大程度上取决于您修改的代码，并且您需要考虑以下几点：
- en: Are you working with existing code or new code?
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你是在处理现有代码还是新代码？
- en: Is the code complex with a lot of dependencies, or is it simple code?
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码是复杂且具有许多依赖关系，还是简单的代码？
- en: Are you working with isolated code or code with high cohesion?
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您是在处理隔离的代码还是具有高内聚力的代码？
- en: How many people change the code at the same time?
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时有多少人改变了代码？
- en: Is there refactoring of a lot of code at the same time?
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同时进行大量代码重构吗？
- en: 'I believe this is why people tend to use time as a measure instead of complexity—there
    is just no good measure for complexity. So, as a rule of thumb: if you work on
    a more complex feature, you should at least merge your changes back to the main
    branch once a day, but if your changes are simple, there is no problem leaving
    your branch/PR open for a longer time. Remember that it is not about time but
    complexity!'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这就是人们倾向于以时间作为衡量标准而不是复杂性的原因——没有一个好的复杂性衡量标准。因此，作为一个经验法则：如果你在处理更复杂的功能，你应该每天至少将你的更改合并回主分支，但如果你的更改很简单，将你的分支/PR保持打开更长时间也没有问题。记住，重点不在于时间，而在于复杂性！
- en: Other git workflows
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他的 git 工作流程
- en: Before we have a closer look into what I believe to be the most effective `git`
    **workflow** for DevOps teams using GitHub, I want to make an introduction to
    the most popular workflows.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究我认为对使用 GitHub 的 DevOps 团队来说最有效的`git`**工作流程**之前，我想介绍一下最流行的工作流程。
- en: Gitflow
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Gitflow
- en: '`git` such as releasing using tags and working with branches that get deleted
    after they have been merged (see *Figure 11.1*):'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`git` 如使用标签发布并与合并后会被删除的分支协作（见 *图 11.1*）：'
- en: '![Figure 11.1 – Gitflow overview'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.1 – Gitflow 概览'
- en: '](img/B17827_11_001.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_11_001.jpg)'
- en: Figure 11.1 – Gitflow overview
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 – Gitflow 概览
- en: Gitflow is great if you ship your software every few months to different customers,
    want to bundle some features to a new major version that is licensed separately,
    and have to maintain many versions for many years. In 2010, this was the common
    release flow for nearly all software, but in complex environments, the workflow
    raises some problems. The workflow is *not* trunk-based and has multiple long-lived
    branches. The integration between these branches can lead to merge hell in complex
    environments. With the rise of DevOps and CI/CD practices, the workflow got a
    bad reputation.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Gitflow 非常适合那些每几个月向不同客户交付软件、希望将一些特性打包成一个单独授权的新版，并且需要维护多个版本多年的人。在 2010 年，这几乎是所有软件的常见发布流程，但在复杂环境中，这种工作流会引发一些问题。该工作流*不是*基于主干的，并且有多个长期存在的分支。这些分支之间的整合可能会在复杂环境中导致“合并地狱”。随着
    DevOps 和 CI/CD 实践的兴起，这种工作流名声不好。
- en: If you want to accelerate your software delivery with DevOps, Gitflow is not
    the right branching workflow for you! But many of the concepts can be found in
    other workflows.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想通过 DevOps 加速软件交付，Gitflow 不是适合你的分支工作流！但很多概念可以在其他工作流中找到。
- en: GitHub flow
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitHub 流程
- en: '**GitHub flow** focuses a lot on collaboration with PRs. You create a branch
    with a descriptive name and make your first changes. Then, you create a PR and
    collaborate with your reviewers through comments on the code. Once the PR is ready,
    it gets shipped to production *before* merging it to the main branch (see *Figure
    11.2*)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**GitHub 流程**非常注重与 PR 的协作。你创建一个有描述性名称的分支并进行首次更改。然后，创建一个 PR，通过对代码的评论与评审者进行协作。一旦
    PR 准备好，它会被部署到生产环境中，*在*合并到主分支之前（见 *图 11.2*）。'
- en: '![Figure 11.2 – GitHub flow'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.2 – GitHub 流程'
- en: '](img/B17827_11_002.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_11_002.jpg)'
- en: Figure 11.2 – GitHub flow
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 – GitHub 流程
- en: GitHub flow is trunk-based, and it is very popular. The basic part—without the
    deployment of PRs—is the base for most other workflows. The problem is the deployment.
    Deploying each PR to production creates a bottleneck and does not scale very well.
    GitHub itself uses ChatOps and deploy trains to solve that issue (Aman Gupta,
    2015), but this seems a bit of overkill to me. The idea that only changes that
    have proven to work in production are merged to `main` is compelling, but it is
    a goal that basically cannot be reached in complex environments. You would need
    quite some time to see the changes work isolated in production to really be sure
    that they did not break anything, but with that time, the bottleneck prevents
    other teams or team members to merge their changes. I think that in a DevOps world
    with the principles of `push` trigger of your main branch. If the changes break
    production, you still can deploy the last version that worked (**roll back**),
    or you fix the error and deploy the fix right away (**roll forward**). You don't
    need a clean main branch to perform either of these options.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 流程是基于主干的，且非常流行。基本部分——没有 PR 部署——是大多数其他工作流的基础。问题在于部署。将每个 PR 部署到生产环境会造成瓶颈，且扩展性不佳。GitHub
    本身使用 ChatOps 和部署列车来解决这个问题（Aman Gupta, 2015），但对我来说，这似乎有些过度。只有在生产环境中证明有效的变更才会被合并到
    `main` 分支上，这个观点很有说服力，但在复杂环境中基本上无法实现。你需要相当长的时间才能确认变更在生产环境中独立运行有效，从而确保它们没有破坏任何东西，但在这段时间里，瓶颈阻止了其他团队或团队成员合并他们的变更。我认为，在一个
    DevOps 的世界中，采用 `push` 触发主分支的原则。如果变更破坏了生产环境，你仍然可以部署最后一个有效版本（**回滚**），或者修复错误并立即部署修复（**前进回滚**）。你不需要一个干净的主分支就能执行这两种操作。
- en: Another thing I dislike about GitHub flow is that it is not very explicit about
    the number of users, branches, and PRs. A feature branch might imply that multiple
    persons commit to the same feature branch. I don't see this happen often, but
    just from the documentation, it is not unambiguous.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我不喜欢 GitHub 流程的另一点是，它对用户数量、分支和 PR 数量不够明确。一个特性分支可能暗示多个开发者会在同一个分支上提交。我并不常看到这种情况，但仅从文档上来看，这并不明确。
- en: Release flow
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布流程
- en: 'Release flow is based upon GitHub flow, but instead of deploying PRs continuously,
    it adds one-way release branches. The branches do not get merged back, and bug
    fixes follow the `main`, and changes get cherry-picked into a branch of the release
    branch (Edward Thomson, 2018). This way, it is impossible to forget to apply a
    bug fix to `main` (see *Figure 11.3*):'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 发布流程基于 GitHub 流程，但它不是持续地部署 PR，而是加入了单向的发布分支。这些分支不会被合并回去，bug 修复跟随 `main`，并且变更会被精确挑选合并到发布分支的分支中（Edward
    Thomson, 2018）。通过这种方式，无法忘记将 bug 修复应用到 `main`（见 *图 11.3*）：
- en: '![Figure 11.3 – Release flow'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.3 – 发布流程'
- en: '](img/B17827_11_003.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_11_003.jpg)'
- en: Figure 11.3 – Release flow
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 – 发布流程
- en: Release flow is not CD! Creating releases is still a process that has to be
    triggered separately. If you have to maintain different versions of your software,
    release flow is a good way to do it. But if you can, you should try to achieve
    CD.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 发布流程不是 CD！创建发布仍然是一个必须单独触发的过程。如果你必须维护软件的不同版本，发布流程是一个不错的选择。但如果可能的话，你应该尝试实现 CD。
- en: GitLab flow
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitLab 流程
- en: 'GitLab flow is also based upon GitHub flow. It adds environment branches (such
    as development, staging, pre-production, and production), and each deployment
    happens on a merge to these environments (see *Figure 11.4*):'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: GitLab 流程同样基于 GitHub 流程。它增加了环境分支（如开发、预发布、预生产和生产），每次部署都发生在合并到这些环境时（见 *图 11.4*）：
- en: '![Figure 11.4 – GitLab environment branches'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.4 – GitLab 环境分支'
- en: '](img/B17827_11_004.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_11_004.jpg)'
- en: Figure 11.4 – GitLab environment branches
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 – GitLab 环境分支
- en: Since the changes only flow downstream, you can be sure that all changes are
    tested in all environments. GitLab flow also follows the `main` and cherry-pick
    changes to all environments. Bug fixing works in GitLab flow the same way it works
    in release flow.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于变更仅向下游流动，你可以确保所有的变更都在所有环境中经过了测试。GitLab 流程同样跟随 `main`，并将变更挑选到所有环境中。Bug 修复在
    GitLab 流程中与发布流程中的工作方式相同。
- en: If you don't have pipelines that support multiple environments—such as GitHub
    Actions—GitLab flow might provide a nice way to automate your approvals and deployments
    for your environments. Personally, I don't see the value in having code for environments
    separated if you perform bug fixes upstream anyway. I prefer to build the code
    once and then deploy the output to all environments in a sequence. But there might
    be situations in which this workflow makes sense—for example, for static websites
    that deploy directly from the repository.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有支持多个环境的管道——比如 GitHub Actions——GitLab 流程可能提供了一种很好的方式来自动化你的审批和部署到各个环境。就个人而言，如果你在上游执行
    bug 修复，我不认为将环境代码分开有什么价值。我更倾向于一次构建代码，然后按顺序将输出部署到所有环境。但在某些情况下，这种工作流是有意义的——例如，对于直接从代码库部署的静态网站。
- en: Accelerating with MyFlow
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MyFlow 加速
- en: 'As you can see, `git` workflows are just a collection of solutions for different
    use cases. The main difference is in whether they are trunk-based or not and if
    they are explicit about some things or not. As I find all workflows lacking something,
    I created my own workflow: **MyFlow**.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，`git` 工作流仅仅是为不同使用场景提供的一些解决方案集合。它们之间的主要区别在于是否基于主干，是否在某些方面明确。如果我发现所有工作流都有缺失，我便创建了自己的工作流：**MyFlow**。
- en: MyFlow is a lightweight, trunk-based workflow based on PRs. MyFlow is not a
    new invention! Many teams already work this way. It is a very natural way to branch
    and merge if you focus on collaboration with PRs. I just gave it a name, and I
    can see people picking it up easily.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: MyFlow 是一种基于 PR 的轻量级主干式工作流。MyFlow 并不是一种新发明！许多团队已经在这样工作了。如果你专注于与 PR 的协作，这是一种非常自然的分支和合并方式。我只是给它起了个名字，我相信人们会很容易接受它。
- en: The main branch
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主分支
- en: 'Since MyFlow is trunk-based, there is only one main branch called `main`, and
    it should always be in a clean state. The main branch should always build, and
    it should be possible to release it to production at any time. That''s why you
    should protect `main` with a branch protection rule. A good branch protection
    rule would include at least the following criteria:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 MyFlow 是基于主干的，所以只有一个名为 `main` 的主分支，并且它应该始终保持干净状态。主分支应该始终能够构建，并且应该能够随时发布到生产环境。这就是为什么你应该用分支保护规则来保护
    `main`。一个好的分支保护规则至少应该包括以下标准：
- en: Require a minimum of two PR reviews before merging
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并前需要至少两次 PR 审查
- en: Dismiss stale PR approvals when new commits are pushed
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 推送新提交时撤销过时的 PR 审批
- en: Require reviews from code owners
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要代码所有者的审查
- en: Require status checks to pass before merging that includes your CI build, test
    execution, code analysis, and linters
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在合并之前要求通过状态检查，包括你的CI构建、测试执行、代码分析和代码检查工具
- en: Include administrators in restrictions
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将管理员包括在限制中
- en: Permit force pushes
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许强制推送
- en: The more you automate using the CI build, the more likely you can keep your
    branch in a clean state.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你通过CI构建自动化的程度越高，你的分支保持干净的可能性就越大。
- en: All other branches are always branched off `main`. Since this is the default
    branch, you never have to specify a source branch when you create a new one. This
    simplifies things and removes a source of error.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他分支总是从`main`分支分出。由于这是默认分支，你在创建新分支时不必指定源分支。这简化了操作并消除了错误的源。
- en: Private topic branches
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 私有主题分支
- en: 'Figure 11.5 shows the basic concept of MyFlow:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5显示了MyFlow的基本概念：
- en: '![Figure 11.5 – Basics of MyFlow'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图11.5 – MyFlow基础'
- en: '](img/B17827_11_005.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_11_005.jpg)'
- en: Figure 11.5 – Basics of MyFlow
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.5 – MyFlow基础
- en: Private topic branches can be used to work on new features, documentation, bugs,
    infrastructure, and everything else that is in your repository. They are private,
    which means they only belong to one specific user. Other team members can check
    out the branch to test the solution, but they are not allowed to directly push
    changes to this branch. Instead, they must use `suggestions` in PRs to suggest
    changes to the author of the PR.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 私有主题分支可用于处理新特性、文档、漏洞、基础设施以及你仓库中的其他一切。它们是私有的，意味着它们只属于一个特定用户。其他团队成员可以检出该分支进行测试，但不允许直接推送更改到该分支。相反，他们必须通过PR中的`suggestions`建议更改给PR的作者。
- en: 'To indicate that branches are private, I recommend a naming convention such
    as `users/*` or `private/*` that makes this obvious. I also recommend including
    the **identifier** (**ID**) of the issue or bug in the name. This makes it easy
    to reference it later in the commit message. A good convention would look like
    this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示分支是私有的，我建议使用一种命名约定，比如`users/*`或`private/*`，这样可以使其一目了然。我还建议在名称中包含**问题标识符**（**ID**）。这样做可以方便日后在提交信息中引用它。一个好的约定可能是这样的：
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To start working on a new topic, you create a new local branch, as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始处理一个新主题，你需要创建一个新的本地分支，如下所示：
- en: '[PRE1]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You can see an example here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里看到一个示例：
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create your first modifications and commit and push them to the server. It
    does not matter what you modify—you could just add a blank to a file. You can
    overwrite it later anyway. You can see an example here:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 创建你的第一次修改并提交，之后推送到服务器。无论你修改了什么都没关系——你可以只是给文件加一个空格。反正以后可以覆盖它。你可以在这里看到一个示例：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, here''s the preceding example with further information:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这是前面的示例，附加了更多信息：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Note that I use GitHub **command-line interface** (**GitHub CLI**) ([https://cli.github.com/](https://cli.github.com/))
    to interact with PRs as I find it easier to read and understand than to use screenshots
    of the web **user interface** (**UI**). You can do the same using the web UI.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我使用**GitHub命令行界面**（**GitHub CLI**）([https://cli.github.com/](https://cli.github.com/))与PR交互，因为我觉得它比使用网页**用户界面**（**UI**）的截图更容易阅读和理解。你也可以使用网页UI进行相同的操作。
- en: 'Create a PR and mark it as `draft`, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个PR并将其标记为`草稿`，如下所示：
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This way, the team knows that you are working on that topic. A quick view of
    a list of open PRs should give you a nice overview of the topics the team currently
    is working on.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，团队就知道你正在处理这个主题。快速查看打开的PR列表应能让你清楚地看到团队目前正在处理的主题。
- en: Note
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can omit the `-m` argument when committing changes and add a multiline commit
    message in your default editor. The first line will be the title of the PR; the
    rest of the message will be the body. You could also set title (`--title` or `-t`)
    and body (`--body` or `-b`) when creating a PR instead of `--fill`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 提交更改时，你可以省略`-m`参数，并在默认编辑器中添加多行提交信息。第一行将是PR的标题，其余部分将是正文。你也可以在创建PR时设置标题（`--title`或`-t`）和正文（`--body`或`-b`），而不是使用`--fill`。
- en: 'You can now start working on your topic, and you can use the full power of
    `git`. If you want to add changes to your previous commit, for example, you can
    do so with the `--amend` option, as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以开始在你的主题上工作，并可以使用`git`的全部功能。例如，如果你想向之前的提交添加更改，可以使用`--amend`选项，如下所示：
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Or, if you want to combine the last three commits into one single commit, you
    can run the following command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你想将最后三个提交合并为一个提交，可以运行以下命令：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If you want to merge all commits in a branch into one commit, you can run the
    following command:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将一个分支中的所有提交合并为一个提交，可以运行以下命令：
- en: '[PRE8]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Or, if you want complete freedom to rearrange and squash all your commits,
    you can use interactive rebase, like this:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你希望完全自由地重新排列并合并所有提交，可以使用交互式变基，如下所示：
- en: '[PRE9]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To push changes to the server, you use the following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要将更改推送到服务器，你可以使用以下命令：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Here''s the preceding example with the branch name populated:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这是前面示例中已填充分支名称的版本：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Note the `+` plus sign before the branch name. This causes a force push, but
    only to a specific branch. If you are not messing with your branch history, you
    can perform a normal `git push` operation, and if your branches are well protected
    and you know what you are doing, a normal force push might be more convenient,
    as illustrated here:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意在分支名称前的 `+` 加号。这会导致强制推送，但仅限于特定分支。如果你不想更改分支历史，可以执行正常的 `git push` 操作，并且如果你的分支已得到良好的保护，并且你知道自己在做什么，正常的强制推送可能会更方便，如下所示：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: If you already want help or the opinions of teammates on your code, you can
    mention them in comments in the PR. If they want to propose changes, they use
    the `suggestions` feature in PR comments. This way, *you* apply the changes, and
    you can make sure that you have a clean state in your repository before doing
    so.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望得到同事对代码的帮助或意见，可以在PR评论中提及他们。如果他们想提出更改，他们可以使用PR评论中的 `suggestions` 功能。这样，*你*
    应用更改，并确保在此之前你的仓库处于干净的状态。
- en: 'Whenever you feel your work is ready, you change the state of your PR from
    `draft` to `ready` and activate auto-merge, as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 每当你觉得工作已准备好时，可以将PR的状态从 `draft` 改为 `ready`，并激活自动合并，方法如下：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Note that I specified `--rebase` as the merge method. This is a good merge strategy
    for small teams that like to craft a good and concise commit history. If you prefer
    `--squash` or `--merge`, adjust your merge strategy accordingly.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我指定了 `--rebase` 作为合并方式。这是一个适合喜欢打造简洁且精确提交历史的小团队的合并策略。如果你更喜欢 `--squash` 或
    `--merge`，请相应调整你的合并策略。
- en: Your reviewers can still create suggestions in their comments, and you can keep
    collaborating. But once all approvals and all automated checks have completed,
    the PR will be merged automatically and the branch gets deleted. Automated checks
    run on the `pull_request` trigger and can include installing the application in
    an isolated environment and running all sorts of tests.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 你的审阅者仍然可以在评论中提出建议，你可以继续协作。但一旦所有批准和自动化检查完成，PR将自动合并，且分支将被删除。自动化检查会在 `pull_request`
    触发器上运行，可能包括在隔离环境中安装应用程序并运行各种测试。
- en: 'If your PR has been merged and the branch has been deleted, you clean up your
    local environment, like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的PR已被合并且分支已被删除，你可以像这样清理本地环境：
- en: '[PRE14]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This will change your current branch to `main`, pull the changed branch from
    the server, and delete local branches that have been deleted on the server.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把你当前的分支切换到 `main`，从服务器拉取更改后的分支，并删除已在服务器上删除的本地分支。
- en: Releasing
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 发布
- en: Once your changes are merged to `main`, the `push` trigger on `main` will start
    the deployment to production, independent of whether you use environments or a
    ring-based approach.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的更改合并到 `main`，`main` 上的 `push` 触发器将启动生产环境的部署，不管你是否使用环境或基于环的方式。
- en: 'If you have to maintain multiple versions, you can use tags together with `release`
    trigger in a workflow and deploy the application, and use `GitVersion` to automatically
    generate your version numbers, as illustrated here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要维护多个版本，可以在工作流中将标签与 `release` 触发器一起使用来部署应用程序，并使用 `GitVersion` 自动生成版本号，如下所示：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here''s an example of this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个示例：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You can also take advantage of the autogeneration of release notes. Unfortunately,
    this feature is not yet available through the CLI. You must create your release
    using the UI for that to work.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以利用自动生成发布说明。不幸的是，这个功能目前通过CLI不可用。你必须通过UI来创建发布，才能使其生效。
- en: As we fix bugs following the **upstream-first** principle anyway, there is no
    real benefit in creating a release branch for every release if we don't have to
    perform a hotfix. The tag that is generated when you create your release works
    just fine.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们遵循 **上游优先** 原则修复bug，如果不需要进行热修复，实际上没有必要为每个版本创建发布分支。在你创建发布时生成的标签就足够了。
- en: Hotfix
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 热修复
- en: 'If you have to provide a hotfix for older releases, you can check out the tag
    and create a new hotfix branch, like this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要为旧版本提供热修复，可以检出标签并创建一个新的热修复分支，像这样：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here''s an example of this:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE18]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, switch back to `main` and fix the bug in a `users/kaufm/666_fix-bug`).
    Now, **cherry-pick** the commit with the fix to the hotfix branch, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，切换回 `main` 并修复 `users/kaufm/666_fix-bug` 中的错误。接着，**挑选**带有修复的提交并合并到修复分支，如下所示：
- en: '[PRE19]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You can use the **secure hash algorithm** (**SHA**) of the commit you want
    to cherry-pick. Or you can use the name of the branch if the commit is the tip
    of the branch, as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用你想要挑选的提交的**安全哈希算法**（**SHA**）。或者，如果提交是分支的最新提交，你也可以使用分支的名称，如下所示：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This will cherry-pick the tip of the topic branch. *Figure 11.6* shows how
    a hotfix for an older release works:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这将会挑选出主题分支的最新提交。*图 11.6* 展示了如何对旧版本进行热修复：
- en: '![Figure 11.6 – Performing hotfixes on older releases'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.6 – 对旧版本进行热修复](img/B17827_11_006.jpg)'
- en: '](img/B17827_11_006.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17827_11_006.jpg)'
- en: Figure 11.6 – Performing hotfixes on older releases
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6 – 对旧版本进行热修复
- en: You could also merge the fix to `main` first and then cherry-pick the commit
    from there. This ensures that the code adheres to all your branch policies.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以先将修复合并到 `main` 分支，然后再从那里挑选提交。这样可以确保代码遵循所有分支策略。
- en: You could also cherry-pick into a temporary branch based on the hotfix branch
    and merge the cherry-picked fix using another PR. This depends on how complex
    your environment is and how big the differences between the main and hotfix branches
    are.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以基于修复分支创建一个临时分支并挑选修复，然后通过另一个PR合并该修复。这取决于你的环境复杂程度以及主分支和修复分支之间的差异有多大。
- en: Automation
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化
- en: 'If you have a workflow with naming conventions, there are certain sequences
    of commands that you use very often. To reduce typos and simplify your workflow,
    you can automate these using `git` `.gitconfig` file in the editor of your choice,
    like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的工作流程中有命名约定，那么你可能会非常频繁地使用某些命令序列。为了减少输入错误并简化工作流程，你可以使用 `git` 的 `.gitconfig`
    文件在你选择的编辑器中自动化这些命令，像这样：
- en: '[PRE21]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add a section, `[alias]`, if it does not exist yet and add an alias, like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `[alias]` 部分还不存在，添加它，并添加一个别名，像这样：
- en: '[PRE22]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This alias is called `mfstart` and would be called specifying the username,
    issue ID, and topic, as illustrated here:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这个别名叫做 `mfstart`，在指定用户名、问题ID和主题时会被调用，如下所示：
- en: '[PRE29]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: It switches to a new branch and commits the current changes in the index, pushes
    them to the server, and creates a PR.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 它会切换到一个新分支并提交当前在索引中的更改，推送到服务器，并创建一个PR。
- en: You can reference individual arguments (`$1`, `$2`, …) or all arguments using
    `$@`. If you want to chain commands independent of the exit code, you must terminate
    a command using `;`. If you want the next command only to execute if the first
    one was successful, you can use `&&`. Note that you have to end each line with
    a backslash (`\`). This is also the character you use to escape quotation marks.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以引用单个参数（`$1`，`$2`，……）或使用 `$@` 引用所有参数。如果你想要独立于退出代码串联命令，你必须使用 `;` 来终止命令。如果你只希望第一个命令成功后才执行下一个命令，可以使用
    `&&`。请注意，你必须在每一行末尾加上反斜杠（`\`）。这个符号也是用来转义引号的。
- en: 'You can add `if` statements to branch your logic, like so:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以添加 `if` 语句来分支你的逻辑，像这样：
- en: '[PRE30]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Or, you can store values in variables to use them later, as in this example—the
    current name of the branch your head (`HEAD`) points to:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以将值存储在变量中以便稍后使用，像这个示例一样——当前分支名称（`HEAD` 指向的分支）：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: These are just examples and the automation depends a lot on the details of the
    way you work, but it is a very powerful tool and can help you to become more productive.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这些仅仅是示例，自动化依赖于你的工作方式的细节，但它是一个非常强大的工具，可以帮助你提高生产力。
- en: Case study
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: With the automation of the release process in place, the two pilot teams have
    already noted a great boost in productivity. Metrics for **lead time** and **deployment
    frequency** have increased significantly.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在自动化发布流程之后，两个试点团队已经注意到生产力大幅提高。**交付时间**和**部署频率**的指标显著上升。
- en: The team that used `git` before they moved from Bitbucket to GitHub followed
    **Gitflow** as their branching workflow. Since their web application can be released
    continuously using their staged deployment workflow, they move to a **trunk-based**
    workflow with PR and private branches and deploy after the merge to the main branch
    using their CI/CD workflow (**MyFlow**). To integrate often, they decide to use
    **feature flags**. As the company needs feature management in the cloud and on-premises,
    they decide to go with **Unleash**. The team can use the **software-as-a-service**
    (**SaaS**) service and can start using it right away without having to wait for
    an on-premises solution.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 该团队在从Bitbucket迁移到GitHub之前使用了`git`，并遵循了**Gitflow**作为他们的分支工作流。由于他们的Web应用程序可以通过分阶段部署工作流持续发布，他们转向了**基于主干**的工作流，使用PR和私有分支，并在合并到主分支后通过CI/CD工作流（**MyFlow**）进行部署。为了频繁集成，他们决定使用**功能标志**。由于公司需要在云端和本地管理功能，他们决定选择**Unleash**。团队可以使用**软件即服务**（**SaaS**）服务，且无需等待本地解决方案即可立即开始使用。
- en: The second team that migrated from **Team Foundation Server** (**TFS**) had
    been used to a complex branching workflow with a long-living release, service
    pack, hotfix branches, and a development branch where all features were integrated.
    As the software is installed on hardware products, multiple releases are stabilized
    in parallel, and also multiple versions that have to be maintained for years.
    This means the software cannot be continuously released. The team chooses **release
    flow** to manage releases and hotfixes. For development, they also use private
    branches with PRs and a trunk-based approach. As the products are not connected
    to the internet, the team relies on their configuration system for feature flags.
    This technique had been used before to enable the testing of new features on hardware.
    The team now extends it to integrate changes more frequently.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个从**Team Foundation Server**（**TFS**）迁移过来的团队，习惯于使用复杂的分支工作流，包括长期存在的发布、服务包、热修复分支和集成所有功能的开发分支。由于软件安装在硬件产品上，多个版本会并行稳定，并且有多个版本需要维护多年。这意味着软件不能持续发布。该团队选择了**发布流**来管理发布和热修复。对于开发，他们还使用了带PR的私有分支和基于主干的方法。由于这些产品未连接到互联网，团队依赖配置系统来启用功能标志。这项技术之前已经用于在硬件上测试新功能。现在，团队扩展了这一技术，以更频繁地集成更改。
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: '`git` workflows are not so different from each other, and most are built on
    top of others. It is more important to follow the principles of **fail fast**
    and **roll forward** instead of treating a certain workflow like a dogma. All
    workflows are just a collection of best practices, and you should only take what
    you need.'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`git`工作流彼此之间没有太大差异，大多数工作流都是基于其他工作流构建的。重要的是遵循**快速失败**和**快速前进**的原则，而不是将某个特定工作流视为教条。所有工作流只是最佳实践的集合，你应该根据需要选择合适的部分。'
- en: What is important is the size of your changes and the frequency in which you
    merge them back.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是你更改的大小和合并回去的频率。
- en: 'Always follow these rules:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 始终遵循以下规则：
- en: Always branch your topic branches of the main branch (**trunk-based**).
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 始终从主分支（**基于主干**）分支出你的主题分支。
- en: If you're working on complex features, make sure to commit at least **once per
    day** (using feature flags).
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你在开发复杂的功能，确保至少**每天提交一次**（使用功能标志）。
- en: If your changes are simple and you only need to change a few lines of code,
    you can leave your PR open for a longer time. But check that you don't have too
    many **open PRs**.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你的更改很简单，只需更改几行代码，你可以让你的PR保持开放状态更长时间。但要确保你的**开放PR**不太多。
- en: With these rules, the workflow you are actually using is not so important. Pick
    the things that work for you.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 只要遵循这些规则，你实际使用的工作流并不那么重要。选择对你有效的部分。
- en: In this chapter, you learned about the benefits of TBD and how you can use it
    together with `git` workflows to increase your engineering velocity.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了TBD的好处，以及如何将其与`git`工作流结合使用，以提高你的工程效率。
- en: In the next chapter, I will explain how you can use shift-left testing for increased
    quality and to release with more confidence.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我将解释如何使用Shift-left测试来提高质量并以更大的信心进行发布。
- en: Further reading
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can use the following references from this chapter to get more information
    on the topics covered:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以参考本章以下内容，获取更多关于所涵盖主题的信息：
- en: '*Forsgren N.*, *Humble, J.*, and *Kim, G.* (2018). *Accelerate: The Science
    of Lean Software and DevOps: Building and Scaling High Performing Technology Organizations*
    (1st ed.) [E-book]. IT Revolution Press.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Trunk-based development: [https://trunkbaseddevelopment.com](https://trunkbaseddevelopment.com)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Gitflow: *Vincent Driessen* (2010), *A successful Git branching model*: [https://nvie.com/posts/a-successful-git-branching-model/](https://nvie.com/posts/a-successful-git-branching-model/)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*GitLab flow*: [https://docs.gitlab.com/ee/topics/gitlab_flow.html](https://docs.gitlab.com/ee/topics/gitlab_flow.html)'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Edward Thomson* (2018). *Release Flow: How We Do Branching on the VSTS Team*:
    [https://devblogs.microsoft.com/devops/release-flow-how-we-do-branching-on-the-vsts-team/](https://devblogs.microsoft.com/devops/release-flow-how-we-do-branching-on-the-vsts-team/)'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Aman Gupta* (2015). *Deploying branches to GitHub.com*: [https://github.blog/2015-06-02-deploying-branches-to-github-com/](https://github.blog/2015-06-02-deploying-branches-to-github-com/)'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*GitHub flow*: [https://docs.github.com/en/get-started/quickstart/github-flow](https://docs.github.com/en/get-started/quickstart/github-flow)'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'GitHub CLI: [https://cli.github.com/](https://cli.github.com/)'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
