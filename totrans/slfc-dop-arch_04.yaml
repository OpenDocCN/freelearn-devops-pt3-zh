- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing Your Changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the core tenets of DevOps is the ability to deliver robust changes that
    stand up to scrutiny, have fewer defects, and ultimately reduce the **Change Failure
    Rate** (**CFR**) metric. This can be largely achieved through testing our development
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll explore the importance of robustly testing Salesforce
    changes, the different types of testing that apply to your components, and how
    to ensure proper testing as part of your DevOps process.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The importance of testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apex testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing your **Lightning Web** **Components** (**LWCs**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing your flows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you should be well equipped to create and run tests
    within Salesforce that exercise much of the functionality you implement, whether
    programmatically or declaratively. This will in turn help you deliver better quality
    deployments as your DevOps process matures.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want to follow along with the examples in this chapter, as a minimum
    you will need to have the following installed:'
  prefs: []
  type: TYPE_NORMAL
- en: The Salesforce CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Salesforce extensions for Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, for the *Testing your LWCs* section, you will need to install
    Node.js (which will include **Node Package** **Manager** (**npm**)).
  prefs: []
  type: TYPE_NORMAL
- en: The importance of testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Conventional wisdom states that the earlier a software bug is found, the easier
    it is to fix and the less impact and cost it is likely to have. Often referred
    to as a **shift-left** approach—in that given a process diagram moving from left
    to right in sequence, the further left you deal with an issue, the better—the
    idea is that by including robust and thorough testing in your DevOps workflow,
    you stand a much better chance of catching potential issues early. This approach
    applies not only to functional testing of your Salesforce changes but also to
    the security aspects of your design and development too—part of what has been
    dubbed *DevSecOps* in the wider IT industry.
  prefs: []
  type: TYPE_NORMAL
- en: If we look at the impact of testing in the context of our DORA metrics discussed
    in [*Chapter 2*](B19436_02.xhtml#_idTextAnchor032), we can easily see that testing
    directly impacts the CFR metric. Put simply, the more well tested your changes
    are, the less likely that errors are to be deployed into your later environments.
    *Test early, test often* is a phrase I’ve used across my years in software development
    to nicely summarize my approach.
  prefs: []
  type: TYPE_NORMAL
- en: When we look at testing in the wider aspect of DevOps, it’s important to consider
    it in the context of not just the development or delivery phases of the application
    life cycle, but across every step from design to delivery. As architects, we should
    be mentally testing the requirements and design long before we get to implement
    any changes—picking holes and finding flaws is one of the greatest skills of a
    Salesforce architect. By making sure that a request is valid and its design stands
    up to scrutiny, with questions satisfactorily answered, you’ve tested the approach
    well ahead of time. This is considered to be the cheapest time to uncover flaws
    before developer hours (and thus cost) are spent on a project. It can be thought
    of as the software development equivalent to the phrase *measure twice, cut once*
    often quoted in the construction world.
  prefs: []
  type: TYPE_NORMAL
- en: There is an array of different aspects to testing that should be considered
    as part of your overall application delivery model. We’ll cover some of the ones
    that are specific to the Salesforce platform’s technology stack here, but to get
    a holistic view of testing as an architect, you should consider the following
    types of testing.
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Thorough integration testing is critical for validating that different components
    and systems work together as expected. For Salesforce projects, key integrations
    to test include connections between Salesforce and external databases, third-party
    web services, interactions between Salesforce products such as Sales Cloud and
    Service Cloud, and custom Lightning components or other customizations.
  prefs: []
  type: TYPE_NORMAL
- en: Use a combination of automated API and UI testing, **end-to-end** (**E2E**)
    process validation, and manual spot checks to confirm all integration points consistently
    function as designed from end to end. Import and export data between systems to
    check for accuracy and completeness. Where possible, send test requests to web
    services to validate response handling, or as a fallback, provide mock responses
    for these requests.
  prefs: []
  type: TYPE_NORMAL
- en: Regression testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Regression testing helps verify that existing functionality and integrations
    continue to work as expected after changes are made. Prioritize regression testing
    after deploying major updates, new features, or structural changes such as altering
    permissions or record-sharing rules. By building automated regression test suites
    that run quickly and frequently, focusing on critical business processes and key
    integration points most likely to be impacted by changes, you can quickly check
    and resolve any breaking changes.
  prefs: []
  type: TYPE_NORMAL
- en: Use a combination of automated UI testing, Apex tests to validate logic and
    handlers, cross-browser testing, and Salesforce API checks for data validation,
    and integrate regression testing into the deployment pipeline to run automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Regression testing gives confidence that the system remains stable through ongoing
    enhancements and changes.
  prefs: []
  type: TYPE_NORMAL
- en: User acceptance testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**User acceptance testing** (**UAT**) usually requires a dedicated Salesforce
    sandbox with test data, roles, and processes modeled on real usage patterns. Involve
    real users in UAT, to validate that new features meet business needs before full
    release. Identify power users across **business units** (**BUs**) to serve as
    UAT testers who deeply understand needs and workflows.'
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to structure formal test plans and reporting to ensure thorough real-world
    validation. Ahead of the start of your UAT process, you should provide testers
    with account access, sample data, and clear test scenarios mapped to business
    use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Track and triage all issues uncovered during UAT, clarifying requirements with
    users and addressing issues before proceeding to production. It should be noted
    that in many larger organizations, much of this process is done by either a business
    analyst or dedicated testing resources, rather than the architect (whose role
    is more that of overseeing the process and ensuring it is carried out).
  prefs: []
  type: TYPE_NORMAL
- en: Large volume testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Special testing is required to confirm the Salesforce platform can handle large
    data volumes and heavy user load. Use realistically large datasets in a test org
    to validate performance and stability at scale. Load the database with maximum
    expected data sizes, and import representative sample data. Use performance testing
    tools to simulate peak numbers of concurrent users, identifying governor limits
    or bottlenecks. Optimize configuration to support caching, indexing, and scalability
    best practices. Check for degradation over time as data volumes grow, tuning and
    adding resources as needed. Modeling production-level usage through large volume
    testing helps validate that the system can support business growth.
  prefs: []
  type: TYPE_NORMAL
- en: In the world of Salesforce DevOps, the two most common types of testing are
    unit testing and E2E testing, but as we’ll see shortly, other important tests
    such as integration tests and regression tests should be considered as well.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing concentrates on verifying individual and separate functions within
    an application—these often relate to a specific individual change that you’re
    developing. It’s important to note that Salesforce enforces a minimum of 75% of
    Apex test coverage across your entire org for production deployments, and even
    more important to note is that this is not a guarantee that functionality is correct.
    A poorly written test can hide or distort actual issues, so unit testing should
    only be considered a part of your overall testing strategy. Additionally, if you
    specify a subset of specific test classes to run as part of a production deployment,
    then every Apex class being deployed needs 75%+ coverage individually rather than
    the org-wide or even deployment-package-wide average. All the more reason to aim
    for as high a percentage of coverage as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing works best when you construct your application from small, testable
    units instead of monolithic Apex classes, flows, or even objects. Creating brief,
    quick unit tests that can be effortlessly executed motivates developers to include
    them in their development, regression testing, and **continuous integration**
    (**CI**) procedures. As a result, bugs are detected and resolved earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Apex testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Writing Apex code without proper testing can lead to issues, such as bugs and
    errors, which can negatively impact the user experience and ultimately harm the
    overall success of the project. This is where Apex unit testing comes in as a
    critical part of the development process that helps ensure that the code is functioning
    as intended, meets requirements, and can handle different scenarios. In this regard,
    Apex unit testing is essential for creating high-quality, robust, and maintainable
    code in Salesforce.
  prefs: []
  type: TYPE_NORMAL
- en: These tests should be designed to simulate both positive and negative scenarios.
    This means the code should not only be tested to ensure that it does what it is
    supposed to, but also tested to check that it *doesn’t* do things it’s not supposed
    to. Additionally, Apex unit tests should be written to test operations in a single
    context or a bulkified context, meaning they can test either a single record or
    multiple records at once. To improve test efficiency and isolate code under test,
    mocks and stubs can be used to simulate external dependencies, such as web services
    or database operations. By writing comprehensive unit tests that cover all possible
    scenarios and using best practices such as mock testing, Salesforce developers
    can build reliable, maintainable, and scalable applications.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, Salesforce enforces a minimum of 75% of unit test coverage
    of your code, but as good architects, we should always strive to get as close
    to 100% coverage as possible. The reality is that there will be some corner cases
    that are not reachable via unit tests—by targeting 100% coverage, these fall into
    a buffer between this high standard and the required 75%, so we should never have
    insufficient coverage in a well-written set of unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate a simple example of an Apex unit test, first, consider the following
    Apex class. It contains a static method that calculates the total price of products
    in a shopping cart. These products use a `Product__c` custom object that contains
    a `Price__c` custom field—the custom object is far simpler than the standard `Product2`
    object and associated objects for example purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'An initial attempt at a corresponding unit test class that includes both single
    and bulkified tests and covers positive and negative scenarios could look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the unit test class includes four test methods: `testSingleProduct`,
    `testMultipleProducts`, `testNullProducts`, and `testProductsWithoutPrice`. The
    first two methods test the `calculateTotal` method with different numbers of products,
    while the third and fourth methods test it with null and incomplete product data,
    respectively. The use of both single and bulkified tests ensures that the code
    can handle different scenarios and scales well. Additionally, the use of both
    positive and negative flows helps ensure that the code can handle both expected
    and unexpected input data.'
  prefs: []
  type: TYPE_NORMAL
- en: Although this test class would work, many code scenarios would benefit from
    a `@testSetup` method, which creates the data used by the test. This data is rolled
    back at the end of the test.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we consider the following trigger and corresponding handler class—which
    is illustrative, not a useful real-world example—we can create a test class for
    it that makes use of the `@testSetup` annotation. The trigger, handler class,
    and its test are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: With this method, the `@testSetup` annotation is used to create multiple products
    that are used in the subsequent test methods. This eliminates the need to create
    duplicate product records in each test method, making the test code more efficient
    and easier to read. The first two test methods from our original test class now
    rely on the `@testSetup` method to create products and calculate the total price,
    while the remaining methods test different scenarios. The use of `@testSetup`
    helps ensure that the test data is consistent and the tests are more reliable.
  prefs: []
  type: TYPE_NORMAL
- en: We can further improve this test class by making use of the `test.startTest()`
    and `test.stopTest()` methods. These are used to separate the setup and execution
    phases of each test method and should be called immediately before and after the
    line(s) of code that specifically execute the code we wish to test. This ensures
    that the performance metrics captured by `Limits.get*()` methods and asynchronous
    operations started by the test method are isolated and not mixed with other operations
    performed before or after the test as part of preparing the test for execution.
    The use of `test.startTest()` and `test.stopTest()` also helps to avoid hitting
    governor limits during test execution, especially when testing bulk data operations.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to be thorough and diligent in your Apex unit tests, but as we’ll
    see in the next section, this should not be the only place that you apply a commitment
    to quality. We’ll start by looking at how we can test LWCs.
  prefs: []
  type: TYPE_NORMAL
- en: Testing your LWCs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Salesforce still has more than one approach for developing Lightning components,
    we’re going to focus on testing LWCs, rather than the older Aura components. Salesforce
    introduced LWCs in December 2018, with the release of Salesforce’s Spring ’19
    version. This was announced in a blog post by Salesforce on December 13, 2018,
    titled Introducing Lightning Web Components, available at [https://developer.salesforce.com/blogs/2018/12/introducing-lightning-web-components](https://developer.salesforce.com/blogs/2018/12/introducing-lightning-web-components).
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to testing LWCs, we can take advantage of the fact that the architecture
    of this type of component is based on more common JavaScript standards and an
    open framework. This allows us to write our unit tests using the popular Jest
    testing framework ([https://jestjs.io/](https://jestjs.io/)), which is already
    used in the wider JavaScript community outside of Salesforce too. Jest is itself
    written in JavaScript and uses the Node.js engine to execute, and npm for installation
    and to manage its dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: In the Salesforce world, there is a plugin for the SFDX command line called
    `sfdx-lwc-jest` that makes it easy to add Jest and its dependencies to your Salesforce
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you run the following command in your project directory, it will install
    the necessary npm tools and the `@``salesforce/sfdx-lwc-jest` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With the capability to run Jest tests set up in your project, you next need
    to configure some tests for your LWCs. These tests are run locally on your development
    machine, independently of Salesforce, which makes it a lot easier to both run
    them at the development stage of your project and to include them as part of any
    test automation you add in your DevOps pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: If you create an SFDX project using the standard template, it already has all
    these ready-to-write Jest tests. The `project.json` file is configured, as is
    `.forceignore`. This also creates a `__tests__` directory and a skeleton test
    file. However, if you have not created your project from the template, the steps
    for creating the appropriate structure are detailed next—in most cases, the template
    will take care of this for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Your first task should be to create a `__tests__` folder under the top-level
    folder of each component. For example, consider this example LWC folder structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Example LWC folder structure without tests](img/Figure_4.1_B19436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Example LWC folder structure without tests
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, adding the required `__tests__` folder would result in a structure
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – The same LWC folder structure, with the test folder and file
    in place](img/Figure_4.2_B19436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – The same LWC folder structure, with the test folder and file in
    place
  prefs: []
  type: TYPE_NORMAL
- en: 'You should also add a wildcarded path to the `__tests__` folder to your `.forceignore`
    file in your project since you shouldn’t deploy Jest tests to your Salesforce
    org—in fact, it will throw an error if you try to do this. Adding the following
    line to the `.forceignore` file should address this issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '`**/``__tests__/**`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, you will need to add the following line to the `scripts` section in your
    project’s `package.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"``test:unit": "sfdx-lwc-jest"`'
  prefs: []
  type: TYPE_NORMAL
- en: Your project is now configured for running Jest tests, and we’ll now look at
    how to construct those tests for your components.
  prefs: []
  type: TYPE_NORMAL
- en: An example Jest test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have set up the prerequisites for running the Jest tests, we can
    look at a lightweight example test for our `teamComponent` component shown previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this test class, we import the `createElement` function from LWC to create
    an instance of the `teamComponent` component, and then we use Jest’s `describe`
    and `it` functions to define a test case that checks that the component renders
    the correct message.
  prefs: []
  type: TYPE_NORMAL
- en: The `afterEach` function is used to reset the DOM between test cases, to ensure
    that each test case starts with a clean slate.
  prefs: []
  type: TYPE_NORMAL
- en: In the `it` function, we create an instance of the `teamComponent` component
    using `createElement`, add it to the DOM using `document.body.appendChild`, and
    then use `querySelector` to find the element that contains the message. Finally,
    we use Jest’s expect function to check that the text content of the `p` element
    is equal to *Welcome to* *the team!*.
  prefs: []
  type: TYPE_NORMAL
- en: This is just an example and your test class will likely need to be more complex
    and cover additional use cases, but this should give you an idea of how to get
    started with writing unit tests for LWCs using Jest. Salesforce Trailhead has
    more detailed examples of testing your LWCs, including those that make use of
    `@wire` services. Now that we have our Jest tests written, let’s look at how we
    run the tests against our code.
  prefs: []
  type: TYPE_NORMAL
- en: Running your Jest tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test an LWC in a Salesforce project using Jest, you can follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to the root directory of your LWC component in your terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the `npm run test` command. This will execute the Jest test runner and run
    any tests in the `__tests__` directory or in the same directory as the LWCs being
    tested.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Jest test runner will display the results of the tests in your terminal.
    If any tests fail, the Jest runner will output detailed information about the
    test failure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also run individual tests by specifying the name of the test file or
    test suite that you want to run. For example, you can run a test named `teamComponent.test.js`
    by running the `npm run test` `teamComponent.test.js` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use additional options to customize the behavior of Jest, such as running
    tests in `watch` mode or generating code coverage reports. You can find more information
    on Jest options in the Jest documentation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, we now have a means of testing our LWCs, but that’s only part
    of the puzzle. In the next section, we’ll start exploring how to test the main
    declarative tool that Salesforce offers—flows.
  prefs: []
  type: TYPE_NORMAL
- en: Testing your flows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Flows are another extremely common means of developing complex functionality
    in Salesforce, and while they fall into the *clicks not code* category of Salesforce
    development, it is just as important to provide them with rigorous testing as
    it is for code-based solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Flow Builder, you can test your flow without leaving the interface. The
    UI contains two buttons for testing your flow: Run and Debug. Let’s look at what
    they do:'
  prefs: []
  type: TYPE_NORMAL
- en: The Run button executes the most recently saved version of the flow that is
    currently open in the editor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Debug button provides additional features beyond Run. In addition to running
    the flow, Debug allows you to input values for the flow’s input variables and
    view debug details during the flow’s execution. This allows you to verify how
    the flow processes data and identify any issues or errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Every time a flow runs in Salesforce, it initiates a flow interview. A flow
    interview is a unique instance of a flow that follows a specific path based on
    the parameters provided. These parameters can include input variables or components
    on a screen, which can lead the interview down different paths through the flow
    and trigger different actions.
  prefs: []
  type: TYPE_NORMAL
- en: By creating flow interviews that cover both positive and negative scenarios,
    you can test your flow’s criteria, much like you would with Apex testing. However,
    breaking a flow into smaller tests may be challenging, as a flow interview tests
    the entire flow rather than just one decision at a time. You may need to create
    multiple flow interviews to cover all possible paths through the flow.
  prefs: []
  type: TYPE_NORMAL
- en: To simplify testing and ensure comprehensive coverage, it may be beneficial
    to break up the flow into subflows where possible. This architectural approach
    can help create more manageable and efficient tests for your flow.
  prefs: []
  type: TYPE_NORMAL
- en: 'As of the Summer ’22 Salesforce release, it is possible to convert these flow
    interviews into flow tests. After successfully executing a flow interview in the
    flow debugger in Salesforce, you will see a **Convert to Test** action appear
    in the top-right corner of the page, next to **Edit Flow**. To convert the debug
    run to a flow test, click on **Convert to Test**, and a new test screen will appear
    in a modal window. You can create up to 200 tests per flow, so it should be possible
    to create a test for every path your flow can take:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Creating a new flow test](img/Figure_4.3_B19436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Creating a new flow test
  prefs: []
  type: TYPE_NORMAL
- en: 'During testing of a flow in Salesforce, each assertion is evaluated to confirm
    that the flow behaves as intended, as illustrated in the following screenshot.
    However, it’s important to note that a test can only verify whether a flow element
    was executed and whether the flow resource values were correctly set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Providing assertions for our new test, to validate our flow](img/Figure_4.4_B19436.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Providing assertions for our new test, to validate our flow
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, there are some important considerations around flow
    tests that an architect should consider when assessing them as part of an overall
    DevOps design:'
  prefs: []
  type: TYPE_NORMAL
- en: Flow tests are available only for record-triggered flows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flow tests don’t support flows that run when a record is deleted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flow tests don’t support flow paths that run asynchronously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flow tests cannot be automatically triggered as part of a deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flow tests can be based upon specific record IDs, but this can make the tests
    fragile since record IDs are not guaranteed to exist in other environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flow tests don’t count toward flow test coverage requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This last point is of particular note because if you want to be able to deploy
    flows as **Active**, they need to have test coverage in just the same way that
    Apex code requires coverage (and at the same minimum level of 75%)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process for this is less mature than that for code, but as a guide, for
    active processes and autolaunched flows, there is a requirement that at least
    one Apex test must achieve the required test coverage percentage of the flow tests.
    However, it’s important to note that flow test coverage requirements do not apply
    to flows that include screens.
  prefs: []
  type: TYPE_NORMAL
- en: The lack of maturity in flow testing is largely around the absence of consistency
    between the flow tests that you can generate in the Flow Builder UI versus the
    tests required for coverage. Not only do these tests need to be written in code
    as Apex unit tests, but to see the current state of code coverage for the flows
    in your org, you need to query the `FlowTestCoverage` object—for example, from
    the Developer Console.
  prefs: []
  type: TYPE_NORMAL
- en: To determine the test coverage of your flows in Salesforce, you need to consider
    all active versions, regardless of whether they have test coverage or not, and
    all inactive versions that are the latest versions and have test coverage. Here
    are example queries for this purpose—to run them, you will need to ensure the
    **Use Tooling API** box is checked in the Developer Console.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to determine the number of flows (the latest versions of each)
    that have test coverage, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, get the number of all active versions of flows—with or without test coverage—plus
    the inactive versions that are the latest versions that have test coverage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To determine the test coverage percentage for your Salesforce flows, divide
    the count of the most recent flow versions with test coverage (second script)
    by the overall sum of active and inactive versions that possess test coverage,
    incorporating those lacking test coverage as well (initial script). If all this
    sounds unnecessarily complicated, you’d be right, and we can only hope that this
    area improves with subsequent Salesforce releases.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the reasons why testing your changes is a core
    principle of Salesforce DevOps. We also dove into some example tests, showing
    the differences in how they are constructed, depending on the approach you used
    to implement your Salesforce functionality—Apex code, LWC, or flows.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve looked at some of the building blocks of architecting a Salesforce
    DevOps process—culture, version control, and robust testing—in the next chapter,
    we’ll start to look at how we bring these elements together by looking at some
    example workflows and scenarios of day-to-day delivery using the SFDX tool and
    Git. While these tools are one of many approaches to Salesforce DevOps, you’ll
    benefit from seeing some of the principles we’ve discussed as real-world examples,
    which will bring a typical workflow to life.
  prefs: []
  type: TYPE_NORMAL
