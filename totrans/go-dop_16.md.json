["```\n.\n├── main.tf\n```", "```\nresource \"local_file\" \"foo\" {\n    content  = \"foo!\"\n    filename = \"${path.module}/foo.txt\"\n}\n```", "```\n$ terraform init && terraform apply\n```", "```\n$ terraform init && terraform apply\nInitializing the backend...\nInitializing provider plugins...\n- Finding latest version of hashicorp/local...\n- Installing hashicorp/local v2.2.2...\n- Installed hashicorp/local v2.2.2 (signed by HashiCorp)\nTerraform has created a lock file .terraform.lock.hcl to record the provider\nselections it made preceding. Include this file in your version control repository\nso that Terraform can guarantee to make the same selections by default when\nyou run \"terraform init\" in the future.\nTerraform has been successfully initialized!\nYou may now begin working with Terraform. Try running \"terraform plan\" to see\nany changes that are required for your infrastructure. All Terraform commands\nshould now work.\nIf you ever set or change modules or backend configuration for Terraform,\nrerun this command to reinitialize your working directory. If you forget, other\ncommands will detect it and remind you to do so if necessary.\n```", "```\nTerraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:\n  + create\nTerraform will perform the following actions:\n  # local_file.foo will be created\n  + resource \"local_file\" \"foo\" {\n      + content              = \"foo!\"\n      + directory_permission = \"0777\"\n      + file_permission      = \"0777\"\n      + filename             = \"./foo.txt\"\n      + id                   = (known after apply)\n    }\nPlan: 1 to add, 0 to change, 0 to destroy.\nDo you want to perform these actions?\n  Terraform will perform the actions described preceding.\n  Only 'yes' will be accepted to approve.\n  Enter a value: yes\nlocal_file.foo: Creating...\nlocal_file.foo: Creation complete after 0s [id=4bf3e335199107182c6f7638efaad377acc7f452]\nApply complete! Resources: 1 added, 0 changed, 0 destroyed.\n```", "```\n.\n├── .terraform\n│   └── providers\n│       └── registry.terraform.io\n│           └── hashicorp\n│               └── local\n│                   └── 2.2.2\n│                       └── darwin_arm64\n│                           └── terraform-provider-local_v2.2.2_x5\n├── .terraform.lock.hcl\n├── foo.txt\n├── main.tf\n└── terraform.tfstate\n```", "```\n$ cat foo.txt\nfoo!\n```", "```\n$ cat terraform.tfstate\n{\n  \"version\": 4,\n  \"terraform_version\": \"1.1.7\",\n  \"serial\": 1,\n  \"lineage\": \"384e96a1-5878-ed22-5368-9795a3231a00\",\n  \"outputs\": {},\n  \"resources\": [\n    {\n      \"mode\": \"managed\",\n      \"type\": \"local_file\",\n      \"name\": \"foo\",\n      \"provider\": \"provider[\\\"registry.terraform.io/hashicorp/local\\\"]\",\n      \"instances\": [\n        {\n          \"schema_version\": 0,\n          \"attributes\": {\n            \"content\": \"foo!\",\n            \"content_base64\": null,\n            \"directory_permission\": \"0777\",\n            \"file_permission\": \"0777\",\n            \"filename\": \"./foo.txt\",\n            \"id\": \"4bf3e335199107182c6f7638efaad377acc7f452\",\n            \"sensitive_content\": null,\n            \"source\": null\n          },\n          \"sensitive_attributes\": [],\n          \"private\": \"bnVsbA==\"\n        }\n      ]\n    }\n  ]\n}\n```", "```\nresource \"local_file\" \"foo\" {\n    content  = \"foo changed!\"\n    filename = \"${path.module}/foo.txt\"\n    file_permissions = \"0644\"\n}\n```", "```\n$ terraform apply -auto-approve\nlocal_file.foo: Refreshing state... [id=4bf3e335199107182c6f7638efaad377acc7f452]\nTerraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:\n-/+ destroy and then create replacement\nTerraform will perform the following actions:\n  # local_file.foo must be replaced\n-/+ resource \"local_file\" \"foo\" {\n      ~ content              = \"foo!\" -> \"foo changed!\" # forces replacement\n      ~ file_permission      = \"0777\" -> \"0644\" # forces replacement\n      ~ id                   = \"4bf3e335199107182c6f7638efaad377acc7f452\" -> (known after apply)\n        # (2 unchanged attributes hidden)\n    }\nPlan: 1 to add, 0 to change, 1 to destroy.\nlocal_file.foo: Destroying... [id=4bf3e335199107182c6f7638efaad377acc7f452]\nlocal_file.foo: Destruction complete after 0s\nlocal_file.foo: Creating...\nlocal_file.foo: Creation complete after 0s [id=5d6b2d23a15b5391d798c9c6a6b69f9a57c41aa5]\nApply complete! Resources: 1 added, 0 changed, 1 destroyed.\n```", "```\n$ cat foo.txt\nfoo changed!\n```", "```\n.\n├── foo.txt\n├── main.tf\n├── terraform.tfstate\n└── terraform.tfstate.backup\n```", "```\n$ terraform destroy\nlocal_file.foo: Refreshing state... [id=5d6b2d23a15b5391d798c9c6a6b69f9a57c41aa5]\nTerraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:\n  - destroy\nTerraform will perform the following actions:\n  # local_file.foo will be destroyed\n  - resource \"local_file\" \"foo\" {\n      - content              = \"foo changed!\" -> null\n      - directory_permission = \"0777\" -> null\n      - file_permission      = \"0644\" -> null\n      - filename             = \"./foo.txt\" -> null\n      - id                   = \"5d6b2d23a15b5391d798c9c6a6b69f9a57c41aa5\" -> null\n    }\nPlan: 0 to add, 0 to change, 1 to destroy.\nDo you really want to destroy all resources?\n  Terraform will destroy all your managed infrastructure, as shown above.\n  There is no undo. Only 'yes' will be accepted to confirm.\n  Enter a value: yes\nlocal_file.foo: Destroying... [id=5d6b2d23a15b5391d798c9c6a6b69f9a57c41aa5]\nlocal_file.foo: Destruction complete after 0s\nDestroy complete! Resources: 1 destroyed.\n```", "```\n# Configure the Azure provider\nterraform {\n  required_providers {\n    azurerm = {\n      source  = \"hashicorp/azurerm\"\n      version = \"~> 3.0\"\n    }\n  }\n}\nprovider \"azurerm\" {\n  features {}\n}\nresource \"azurerm_resource_group\" \"mygroup\" {\n  name     = \"mygroup\"\n  location = \"southcentralus\"\n}\n```", "```\n$ az login\n```", "```\n$ az account show\n{\n  \"environmentName\": \"AzureCloud\",\n  \"isDefault\": true,\n  \"managedByTenants\": [],\n  \"name\": \"mysubscription\",\n  \"state\": \"Enabled\",\n  \"tenantId\": \"888bf....db93\",\n  \"user\": {\n      ...\n  }\n}\n```", "```\n$ terraform init && terraform apply\n```", "```\nInitializing the backend...\nInitializing provider plugins...\n- Finding hashicorp/azurerm versions matching \"~> 3.0\"...\n- Installing hashicorp/azurerm v3.0.2...\n- Installed hashicorp/azurerm v3.0.2 (signed by HashiCorp)\nTerraform has created a lock file .terraform.lock.hcl to record the provider\nselections it made above. Include this file in your version control repository\nso that Terraform can guarantee to make the same selections by default when\nyou run \"terraform init\" in the future.\nTerraform has been successfully initialized!\nYou may now begin working with Terraform. Try running \"terraform plan\" to see\nany changes that are required for your infrastructure. All Terraform commands\nshould now work.\nIf you ever set or change modules or backend configuration for Terraform,\nrerun this command to reinitialize your working directory. If you forget, other\ncommands will detect it and remind you to do so if necessary.\n```", "```\nTerraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:\n  + create\nTerraform will perform the following actions:\n  # azurerm_resource_group.rg will be created\n  + resource \"azurerm_resource_group\" \"mygroup\" {\n      + id       = (known after apply)\n      + location = \"southcentralus\"\n      + name     = \"mygroup\"\n    }\nPlan: 1 to add, 0 to change, 0 to destroy.\nDo you want to perform these actions?\n  Terraform will perform the actions described above.\n  Only 'yes' will be accepted to approve.\n  Enter a value: yes\nazurerm_resource_group.mygroup: Creating...\nazurerm_resource_group.mygroup: Creation complete after 2s [id=/subscriptions/8ec-...-24a/resourceGroups/mygroup]\n```", "```\n.\n├── .terraform\n│   └── providers\n│       └── registry.terraform.io\n│           └── hashicorp\n│               └── azurerm\n│                   └── 3.0.2\n│                       └── darwin_arm64\n│                           └── terraform-provider-azurerm_v3.0.2_x5\n├── .terraform.lock.hcl\n├── main.tf\n└── terraform.tfstate\n```", "```\nresource \"azurerm_resource_group\" \"mygroup\" {\n  name     = \"mygroup\"\n  location = \"southcentralus\"\n}\nresource \"azurerm_service_plan\" \"myplan\" {\n  name                = \"myplan\"\n  resource_group_name = azurerm_resource_group.mygroup.name\n  location            = azurerm_resource_group.mygroup.location\n  os_type             = \"Linux\"\n  sku_name            = \"S1\"\n}\nresource \"random_integer\" \"ri\" {\n  min = 10000\n  max = 99999\n}\nresource \"azurerm_linux_web_app\" \"myapp\" {\n  name                = \"myapp-${random_integer.ri.result}\"\n  resource_group_name = azurerm_resource_group.mygroup.name\n  location            = azurerm_service_plan.myplan.location\n  service_plan_id     = azurerm_service_plan.myplan.id\n  site_config {\n      application_stack {\n          docker_image = \"nginxdemos/hello\"\n          docker_image_tag = \"latest\"\n      }\n  }\n}\noutput \"host_name\" {\n    value = azurerm_linux_web_app.myapp.default_hostname\n}\n```", "```\n$ terraform apply\n│\n│ Error: Inconsistent dependency lock file\n│\n│ The following dependency selections recorded in the lock file are inconsistent with the current configuration:\n│   - provider registry.terraform.io/hashicorp/random: required by this configuration but no version is selected\n│\n│ To update the locked dependency selections to match a changed configuration, run:\n│   terraform init -upgrade\n│\n```", "```\n$ terraform init -upgrade\nInitializing the backend...\nInitializing provider plugins...\n- Finding latest version of hashicorp/random...\n- Finding hashicorp/azurerm versions matching \"~> 3.0\"...\n- Installing hashicorp/random v3.1.2...\n- Installed hashicorp/random v3.1.2 (signed by HashiCorp)\n- Using previously-installed hashicorp/azurerm v3.0.2\n```", "```\n.\n├── .terraform\n│   └── providers\n│       └── registry.terraform.io\n│           └── hashicorp\n│               ├── azurerm\n│               │   └── 3.0.2\n│               │       └── darwin_arm64\n│               │           └── terraform-provider-azurerm_v3.0.2_x5\n│               └── random\n│                   └── 3.1.2\n│                       └── darwin_arm64\n│                           └── terraform-provider-random_v3.1.2_x5\n```", "```\n$ terraform apply -auto-approve\nazurerm_resource_group.mygroup: Refreshing state...\n...\nPlan: 3 to add, 0 to change, 0 to destroy.\nChanges to Outputs:\n  + host_name = (known after apply)\nrandom_integer.ri: Creating...\nrandom_integer.ri: Creation complete after 0s [id=18515]\nazurerm_service_plan.myplan: Creating...\nazurerm_service_plan.myplan: Still creating... [10s elapsed]\nazurerm_service_plan.myplan: Creation complete after 12s [id=/subscriptions/8ec-...-24a/resourceGroups/mygroup/providers/Microsoft.Web/serverfarms/myplan]\nazurerm_linux_web_app.myapp: Creating...\nazurerm_linux_web_app.myapp: Still creating... [10s elapsed]\nazurerm_linux_web_app.myapp: Still creating... [20s elapsed]\nazurerm_linux_web_app.myapp: Creation complete after 28s [id=/subscriptions/8ec-...-24a/resourceGroups/mygroup/providers/Microsoft.Web/sites/myapp-18515]\nApply complete! Resources: 3 added, 0 changed, 0 destroyed.\nOutputs:\nhost_name = \"myapp-18515.azurewebsites.net\"\n```", "```\n.\n├── Makefile\n├── docker-compose.yml\n├── examples\n│   └── main.tf\n├── go.mod\n├── go.sum\n├── internal\n│   ├── client # contains the grpc pet store API client\n│   │   └── ...\n│   ├── data_source_pet.go\n│   ├── provider.go\n│   ├── resource_pets.go\n│   └── schema.go\n└── main.go\n```", "```\nHOSTNAME=example.com\nNAMESPACE=gofordevops\nNAME=petstore\nBINARY=terraform-provider-${NAME}\nVERSION=0.1.0\nGOARCH  := $(shell go env GOARCH)\nGOOS := $(shell go env GOOS)\ndefault: install\nbuild:\n     go build -o ${BINARY}\ninstall: build\n     mkdir -p ~/.terraform.d/plugins/${HOSTNAME}/${NAMESPACE}/${NAME}/${VERSION}/${GOOS}_${GOARCH}\n     mv ${BINARY} ~/.terraform.d/plugins/${HOSTNAME}/${NAMESPACE}/${NAME}/${VERSION}/${GOOS}_${GOARCH}\ntest:\n     go test ./... -v\ntestacc:\n     TF_ACC=1 go test ./... -v $(TESTARGS) -timeout 120m\n```", "```\nversion: '3.7'\nservices:\n  petstore:\n    build:\n      context: ../../10/petstore/.\n    command:\n      - /go/bin/petstore\n      - --localDebug\n    ports:\n      - \"6742:6742\"\n```", "```\nterraform {\n  required_providers {\n    petstore = {\n      version = \"0.1.0\"\n      source  = \"example.com/gofordevops/petstore\"\n    }\n  }\n}\n...\nresource \"petstore_pet\" \"thor\" {\n  name     = \"Thor\"\n  type     = \"dog\"\n  birthday = \"2021-04-01T00:00:00Z\"\n}\nresource \"petstore_pet\" \"tron\" {\n  name     = \"Tron\"\n  type     = \"cat\"\n  birthday = \"2020-06-25T00:00:00Z\"\n}\ndata \"petstore_pet\" \"all\" {\n  depends_on = [petstore_pet.thor, petstore_pet.tron]\n}\n```", "```\npackage main\nimport (\n     \"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema\"\n     \"github.com/hashicorp/terraform-plugin-sdk/v2/plugin\"\n     petstore \"github.com/PacktPublishing/Go-for-DevOps/chapter/13/petstore-provider/internal\"\n)\nfunc main() {\n     plugin.Serve(&plugin.ServeOpts{\n          ProviderFunc: func() *schema.Provider {\n               return petstore.Provider()\n          },\n     })\n}\n```", "```\n// Provider is the entry point for defining the Terraform provider, and will create a new Pet Store provider.\nfunc Provider() *schema.Provider {\n     return &schema.Provider{\n          Schema: map[string]*schema.Schema{\n               \"host\": {\n                    Type:        schema.TypeString,\n                    Optional:    true,\n                    DefaultFunc: schema.EnvDefaultFunc(\"PETSTORE_HOST\", nil),\n               },\n          },\n          ResourcesMap: map[string]*schema.Resource{\n               \"petstore_pet\": resourcePet(),\n          },\n          DataSourcesMap: map[string]*schema.Resource{\n               \"petstore_pet\": dataSourcePet(),\n          },\n          ConfigureContextFunc: configure,\n     }\n}\n```", "```\n// configure builds a new Pet Store client the provider will use to interact with the Pet Store service\nfunc configure(_ context.Context, data *schema.ResourceData) (interface{}, diag.Diagnostics) {\n     // Warning or errors can be collected in a slice type\n     var diags diag.Diagnostics\n     host, ok := data.Get(\"host\").(string)\n     if !ok {\n          return nil, diag.Errorf(\"the host (127.0.0.1:443) must be provided explicitly or via env var PETSTORE_HOST\")\n     }\n     c, err := client.New(host)\n     if err != nil {\n          return nil, append(diags, diag.Diagnostic{\n               Severity: diag.Error,\n               Summary:  \"Unable to create Pet Store client\",\n               Detail:   \"Unable to connect to the Pet Store service\",\n          })\n     }\n     return c, diags\n}\n```", "```\nfunc dataSourcePet() *schema.Resource {\n     return &schema.Resource{\n          ReadContext: dataSourcePetRead,\n          Schema:      getPetDataSchema(),\n     }\n}\n```", "```\nfunc getPetDataSchema() map[string]*schema.Schema {\n     return map[string]*schema.Schema{\n          \"pet_id\": {\n               Type:     schema.TypeString,\n               Optional: true,\n          },\n          \"name\": {\n               Type:             schema.TypeString,\n               Optional:         true,\n               ValidateDiagFunc: validateName(),\n          },\n          \"type\": {\n               Type:             schema.TypeString,\n               Optional:         true,\n               ValidateDiagFunc: validateType(),\n          },\n          \"birthday\": {\n               Type:             schema.TypeString,\n               Optional:         true,\n               ValidateDiagFunc: validateBirthday(),\n          },\n```", "```\n          \"pets\": {\n               Type:     schema.TypeList,\n               Computed: true,\n               Elem: &schema.Resource{\n                    Schema: map[string]*schema.Schema{\n                         \"id\": {\n                              Type:     schema.TypeString,\n                              Computed: true,\n                         },\n                         \"name\": {\n                              Type:     schema.TypeString,\n                              Computed: true,\n                         },\n                         \"type\": {\n                              Type:     schema.TypeString,\n                              Computed: true,\n                         },\n                         \"birthday\": {\n                              Type:     schema.TypeString,\n                              Computed: true,\n                         },\n                    },\n               },\n          },\n     }\n}\n```", "```\n// dataSourcePetRead finds pets in the pet store given an ID\nfunc dataSourcePetRead(ctx context.Context, data *schema.ResourceData, meta interface{}) diag.Diagnostics {\n     psClient, err := clientFromMeta(meta)\n     if err != nil {\n          return diag.FromErr(err)\n     }\n     pets, err := findPetsInStore(ctx, psClient, findPetsRequest{\n          Name:     data.Get(\"name\").(string),\n          Birthday: data.Get(\"birthday\").(string),\n          Type:     PetType(data.Get(\"type\").(string)),\n          ID:       data.Get(\"pet_id\").(string),\n     })\n     if err != nil {\n          return diag.FromErr(err)\n     }\n     // always run\n     data.SetId(strconv.FormatInt(time.Now().Unix(), 10))\n     if err := data.Set(\"pets\", flattenPets(pets)); err != nil {\n          return diag.FromErr(err)\n     }\n     return nil\n}\n```", "```\n// clientFromMeta casts meta into a Pet Store client or returns an error\nfunc clientFromMeta(meta interface{}) (*client.Client, error) {\n     psClient, ok := meta.(*client.Client)\n     if !ok {\n          return nil, errors.New(\"meta does not contain a Pet Store client\")\n     }\n     return psClient, nil\n}\n```", "```\nfunc resourcePet() *schema.Resource {\n     return &schema.Resource{\n          CreateContext: resourcePetCreate,\n          ReadContext:   resourcePetRead,\n          UpdateContext: resourcePetUpdate,\n          DeleteContext: resourcePetDelete,\n          Schema:        getPetResourceSchema(),\n          Importer: &schema.ResourceImporter{\n               StateContext: schema.ImportStatePassthroughContext,\n          },\n     }\n}\n```", "```\nfunc getPetResourceSchema() map[string]*schema.Schema {\n     return map[string]*schema.Schema{\n          \"id\": {\n               Type:     schema.TypeString,\n               Optional: true,\n               Computed: true,\n          },\n          \"name\": {\n               Type:             schema.TypeString,\n               Required:         true,\n               ValidateDiagFunc: validateName(),\n          },\n          \"type\": {\n               Type:             schema.TypeString,\n               Required:         true,\n               ValidateDiagFunc: validateType(),\n          },\n          \"birthday\": {\n               Type:             schema.TypeString,\n               Required:         true,\n               ValidateDiagFunc: validateBirthday(),\n          },\n     }\n}\n```", "```\nfunc validateType() schema.SchemaValidateDiagFunc {\n     return validateDiagFunc(validation.StringInSlice([]string{\n          string(DogPetType),\n          string(CatPetType),\n          string(ReptilePetType),\n          string(BirdPetType),\n     }, true))\n}\n```", "```\n// resourcePetRead finds a pet in the pet store by ID and populate the resource data\nfunc resourcePetRead(ctx context.Context, data *schema.ResourceData, meta interface{}) diag.Diagnostics {\n     psClient, err := clientFromMeta(meta)\n     if err != nil {\n          return diag.FromErr(err)\n     }\n     pets, err := findPetsInStore(ctx, psClient, findPetsRequest{ID: data.Id()})\n     if err != nil {\n          return diag.FromErr(err)\n     }\n     if len(pets) == 0 {\n          return nil\n     }\n     return setDataFromPet(pets[0], data)\n}\n```", "```\n// resourcePetCreate creates a pet in the pet store\nfunc resourcePetCreate(ctx context.Context, data *schema.ResourceData, meta interface{}) diag.Diagnostics {\n     psClient, err := clientFromMeta(meta)\n     if err != nil {\n          return diag.FromErr(err)\n     }\n     pet := &client.Pet{Pet: &pb.Pet{}}\n     diags := fillPetFromData(pet, data)\n     ids, err := psClient.AddPets(ctx, []*pb.Pet{pet.Pet})\n     if err != nil {\n          return append(diags, diag.FromErr(err)...)\n     }\n     data.SetId(ids[0])\n     return diags\n}\n```", "```\n// resourcePetUpdate updates a pet in the pet store by ID\nfunc resourcePetUpdate(ctx context.Context, data *schema.ResourceData, meta interface{}) diag.Diagnostics {\n     psClient, err := clientFromMeta(meta)\n     if err != nil {\n          return diag.FromErr(err)\n     }\n     pets, err := findPetsInStore(ctx, psClient, findPetsRequest{ID: data.Id()})\n     if err != nil {\n          return diag.FromErr(err)\n     }\n     if len(pets) == 0 {\n          return diag.Diagnostics{\n               {\n                    Severity: diag.Error,\n                    Summary:  \"no pet was found\",\n                    Detail:   \"no pet was found when trying to update the pet by ID\",\n               },\n          }\n     }\n     pet := pets[0]\n     diags := fillPetFromData(pet, data)\n     if diags.HasError() {\n          return diags\n     }\n     if err := psClient.UpdatePets(ctx, []*pb.Pet{pet.Pet}); err != nil {\n          return append(diags, diag.FromErr(err)...)\n     }\n     return diags\n}\n```", "```\n$ docker-compose up -d\n$ make\n$ cd examples\n$ terraform init && terraform apply\n```", "```\nInitializing the backend...\nInitializing provider plugins...\n- Finding example.com/gofordevops/petstore versions matching \"0.1.0\"...\n- Installing example.com/gofordevops/petstore v0.1.0...\n- Installed example.com/gofordevops/petstore v0.1.0 (unauthenticated)\n```", "```\nApply complete! Resources: 2 added, 0 changed, 0 destroyed.\nOutputs:\nall_pets = {\n  \"birthday\" = tostring(null)\n  \"id\" = \"1648955761\"\n  \"name\" = tostring(null)\n  \"pet_id\" = tostring(null)\n  \"pets\" = tolist([\n    {\n      \"birthday\" = \"2020-06-25T00:00:00Z\"\n      \"id\" = \"495b1c94-6f67-46f2-9d4d-e84cc182d523\"\n      \"name\" = \"Tron\"\n      \"type\" = \"cat\"\n    },\n    {\n      \"birthday\" = \"2021-04-01T00:00:00Z\"\n      \"id\" = \"36e65cb2-18ea-4aec-a410-7bad64d7b00d\"\n      \"name\" = \"Thor\"\n      \"type\" = \"dog\"\n    },\n  ])\n  \"type\" = tostring(null)\n}\nthor = {\n  \"36e65cb2-18ea-4aec-a410-7bad64d7b00d\" = {\n    \"birthday\" = \"2021-04-01T00:00:00Z\"\n    \"id\" = \"36e65cb2-18ea-4aec-a410-7bad64d7b00d\"\n    \"name\" = \"Thor\"\n    \"type\" = \"dog\"\n  }\n}\n```", "```\nvariable \"pet_name\" {\n  type    = string\n  default = \"Thor\"\n}\ndata \"petstore_pet\" \"all\" {\n  depends_on = [petstore_pet.thor, petstore_pet.tron]\n}\n# Only returns Thor by name\noutput \"thor\" {\n  value = {\n    for pet in data.petstore_pet.all.pets :\n    pet.id => pet\n    if pet.name == var.pet_name\n  }\n}\n```"]