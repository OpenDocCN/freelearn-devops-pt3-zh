# <st c="0">8</st>

# <st c="2">成本管理和最佳实践</st>

<st c="36">在过去几年里，云迁移一直是许多 IT 组织的首要任务，并且在未来几年仍然是一个战略性、相关的方向。</st> <st c="194">自建数据中心仍然是一个有价值的选择；相比于云，自建数据中心的设计和成本通常经过更深思熟虑。</st> <st c="384">在本章中，我们将深入探讨这一问题，并反思云成本管理</st> <st c="497">和优化的必要性。</st>

<st c="514">你将更多地了解标签策略，以及它们为何是获取云支出可见性和透明度的可行资源。</st> <st c="659">我们还将探讨如何定义标签策略、最佳实践以及实际方法，确保它们得到妥善设置。</st> <st c="770">以此为基础，我们将深入探讨成本优化的四大支柱：</st> *<st c="855">流程</st>*<st c="864">、</st> *<st c="866">定价</st>*<st c="873">、</st> *<st c="875">使用</st>*<st c="880">、</st> <st c="882">以及</st> *<st c="886">设计</st>*<st c="892">。</st>

<st c="893">在本章的最后，我们将分享一些实用的建议，帮助你优化平台并长期降低成本，同时为你的用户提供节省成本的价值。</st> <st c="1069">。</st>

<st c="1080">总体而言，我们将重点讨论有效的成本管理，以及作为平台工程师，如何实现这一目标。</st> <st c="1184">以下是你可以期望学到的内容：</st>

+   <st c="1220">理解成本格局——云是否是最佳选择</st> <st c="1275">？</st>

+   <st c="1281">实施标签策略以揭示</st> <st c="1325">隐藏成本</st>

+   <st c="1337">审视成本</st> <st c="1354">优化策略</st>

+   <st c="1377">自动扩展、冷存储以及其他成本优化</st> <st c="1426">技巧</st>

# <st c="1443">了解成本格局——云是否是最佳选择？</st>

<st c="1506">成本管理</st> <st c="1522">在平台工程中的应用始于对成本驱动因素的深入理解</st> <st c="1595">，特别是了解基础设施中哪些平台组件可能会影响这些因素。</st> <st c="1679">成本驱动因素也是直接影响你运营总成本的因素。</st> <st c="1766">理解并随后识别这些因素，有助于做出明智决策，从而提供以成本为导向的</st> <st c="1875">优化平台</st><st c="1894">。</st>

## <st c="1895">是否选择云——这是一个问题</st>

<st c="1942">过去几年，几乎没有办法绕过云采纳战略。</st> <st c="2030">在这些年里，这一运动面临了来自一些成功进行“反迁移”的公司压力，这些公司声称他们的本地部署比云更便宜、更好，并且满足他们的一切需求。</st> *<st c="2215">反迁移</st>* <st c="2227">就是这个过程的名称。</st> <st c="2252">做这种选择的人数并不十分明确，且很大程度上取决于什么算作其中的一部分。</st> <st c="2357">它变得非常著名，作为</st> *<st c="2382">HEY/Basecamp/37signals</st>*<st c="2404">，他们的首席技术官 David Heinemeier Hansson 曾表示</st> *<st c="2457">如果他们不使用云计算，他们将在未来五年节省超过 700 万美元</st>* <st c="2502">。</st> <st c="2536">他们购买的服务器与每年在云上花费 190 万美元之间进行的愚蠢对比，显示出他们的购买服务器花费了 50 万美元，这让数学变得非常清晰</st> <st c="2709">[1]</st>*<st c="2718">。</st>

<st c="2722">当然，Basecamp 或 HEY 与企业是不具可比性的，对吧？</st> <st c="2789">根据我的经验，我可以告诉你，运行大型公司的硬件在自有数据中心比迁移到云端要便宜。</st> <st c="2930">一个关键因素是数据量以及基础设施需要多么动态和可扩展。</st> <st c="3031">计算以拍字节为单位的数据时，云服务会迅速变成一个无尽的金钱黑洞。</st> <st c="3123">相对静态的工作负载也会大大减少所包含的好处，而且还有许多其他的缺点。</st> <st c="3246">另一方面，云市场每年都在持续增长，似乎没有尽头。</st> <st c="3340">因此，要做出决定，选择正确的方式，你需要考虑许多不断变化的因素，从简单的成本对比到可用技能以及你业务的实际需求。</st> <st c="3528">对云是否适合你的全面评估本身就可能是一个项目。</st> <st c="3621">但我们想给你一些关于应该考虑的标准，以便你能在</st> <st c="3696">这个阶段做出决策：</st>

+   **<st c="3707">成本</st>**<st c="3712">：评估本地部署的初始资本支出（CapEx）或一次性费用，和云服务的运营支出（OpEx）或持续性订阅费用，并考虑长期财务影响，同时还要意识到，如果你提前支付 1 年或 3 年的费用，你在云计算上将节省最多的钱。</st> <st c="3980">这几乎就像是在购买</st> <st c="4007">硬件。</st>

+   **<st c="4020">可扩展性</st>**<st c="4032">：评估你在快速变化情况下动态扩展资源的需求。</st> <st c="4114">这里有个提示：如果峰值增长太快，静态服务器可能比等待几分钟直到新</st> <st c="4246">实例启动更适合用户体验。</st>

+   **<st c="4262">可靠性</st>**<st c="4274">：评估正常运行时间保证、冗余和故障转移能力，以保持持续运营。</st> <st c="4378">查看停机历史。</st> <st c="4417">一些云提供商经常</st> <st c="4449">出现问题。</st>

+   **<st c="4461">合规性</st>**<st c="4472">：确保遵守法律和监管要求，重点关注数据驻留和主权问题。</st> <st c="4574">在决定之前，你必须明确对主权的观点。</st> <st c="4651">不幸的是，这个术语的涵盖面比明确的要求清单</st> <st c="4717">更广泛。</st>

+   **<st c="4733">集成</st>**<st c="4745">：确保与现有系统和软件的兼容性，并提供 API 和集成工具。</st> <st c="4853">提供商应支持</st> **<st c="4881">基础设施即代码</st>** <st c="4903">(</st>**<st c="4905">IaC</st>**<st c="4908">)，尤其是</st> <st c="4922">能够通过编程创建账户、用户</st> <st c="4967">和权限。</st>

+   **<st c="4983">支持</st>**<st c="4991">：评估技术支持的可用性和质量，以及</st> **<st c="5063">服务水平协议</st>** <st c="5087">(</st>**<st c="5089">SLA</st>**<st c="5093">)。</st> <st c="5097">研究其他用户对所提供支持的满意度；仅仅因为你有合同，某人负责保持系统运行并帮助你，并不意味着该服务</st> <st c="5281">也一定好。</st>

+   **<st c="5291">新服务的开发</st>**<st c="5319">：评估提供商向你提供的新功能的速度和数量。</st> <st c="5392">考虑到每月更新过多的情况，也要注意是否几乎没有</st> <st c="5486">新功能。</st>

+   **<st c="5499">地理考虑</st>**<st c="5525">：考虑数据中心与最终用户的距离以及服务的区域可用性。</st> <st c="5623">如果你的公司开发全球</st> <st c="5656">可用的</st> **<st c="5667">软件即服务</st>** <st c="5688">(</st>**<st c="5690">SaaS</st>**<st c="5694">)，那么构建在公共云上可能比集成多个</st> <st c="5770">区域提供商更为容易。</st>

+   **<st c="5789">技能与专业知识</st>**<st c="5809">：评估管理基础设施所需的专业人员和培训要求。</st> <st c="5918">考虑到你仍然需要任何 IT 领域的人才来完成这项工作。</st> <st c="6006">短期计划是什么样的？</st> <st c="6045">长期需要什么？</st> <st c="6077">别再认为云计算很简单了；大多数企业之所以苦苦挣扎，是因为他们没有让</st> <st c="6173">团队接受培训。</st>

+   **<st c="6188">环境影响和可持续性</st>**<st c="6228">：考虑提供商的能源消耗、碳足迹和可持续性实践。</st> <st c="6323">他们如何处理废水？</st> <st c="6360">如果他们购买碳补偿，记住你需要为此付费，因为理论上这会增加</st> <st c="6463">电费。</st>

<st c="6481">云通常有一个非常强大的优势：几乎没有什么能阻止你立刻开始。</st> <st c="6579">你可以找到大量的模板、蓝图和示例。</st> <st c="6637">在短时间内，你就能开始运行，拥有你的第一个环境作为</st> <st c="6729">平台。</st>

## <st c="6741">当我们选择云时——我们必须考虑它的隐藏成本</st>

<st c="6806">由于我们本书主要聚焦云端，我们暂时假设选择裸金属方式的用户本能上具有更高的成本意识</st> <st c="6955">和敏感度。</st>

<st c="6971">云提供商为我们提供了很多即用的服务，</st> <st c="7004">通常带有许多</st> *<st c="7027">内置的功能</st>*<st c="7045">。它们通常包括备份解决方案、可扩展性、</st> **<st c="7099">高可用性</st>** <st c="7116">(</st>**<st c="7118">HA</st>**<st c="7120">)，以及集中管理的服务。</st> <st c="7157">在规划云基础设施时，大多数情况下，我们会发现硬性事实和最佳猜测。</st> <st c="7257">硬性事实是指像需要多少个 CPU 或服务器，应该使用哪种数据库，是否是单节点还是高可用等信息。</st> <st c="7406">然而，你应该意识到，几乎每一个你选择的公共云提供商选项都会对成本产生一些</st> <st c="7513">影响。</st>

<st c="7526">常见的大成本驱动因素包括</st> <st c="7543">以下几点：</st>

+   **<st c="7587">负载均衡器</st>**<st c="7601">：几乎在每个架构中都需要它们，你也不例外。</st> <st c="7612">正如前面所解释的，我们有机会将应用服务从 Kubernetes 命名空间扩展到云端，甚至控制网络——这是一个主要的</st> <st c="7832">成本陷阱。</st>

+   **<st c="7842">API 网关</st>**<st c="7854">：负载均衡器的更为邪恶的双胞胎，作为最佳实践时，变得非常昂贵，特别是对于频繁通信的系统和路由</st> <st c="7992">密集型通信。</st>

+   **<st c="8012">数据</st>**<st c="8017">：无论是静态还是在传输过程中，数据</st> <st c="8047">迅速成为云账单中最大的成本块。</st> <st c="8104">虽然一切都可以扩展，但你的数据必须</st> <st c="8165">存放在某个地方。</st>

+   **<st c="8180">备份和快照</st>**<st c="8202">：它们对于一个成熟的平台非常必要；你需要有一个非常</st> <st c="8214">好的备份策略，既精简</st> <st c="8285">又可靠。</st>

+   **<st c="8333">可扩展的</st>** **<st c="8342">托管服务</st>**<st c="8359">：如果你在使用无服务器架构、消息流或预训练的 AI 模型——任何可以无限扩展的东西——设定限制至关重要，以避免产生</st> <st c="8515">意外成本。</st>

<st c="8532">理想的云项目——我们必须强调的是，我们在谈论的是有截止日期的事情——是非常有明确意见的，遵循云服务提供商的最佳实践。</st> <st c="8711">几乎每个云项目都不理想，因定制实现的需要而导致迁移过程中的摩擦，这些实现必须以某种方式使旧世界和云服务提供商能够互相协作。</st> <st c="8911">这些隐性成本通过技能的缺失而积累，因为所需的技能到底从哪里来呢？</st> <st c="9022">从外部技能提供商那里获得帮助意味着他们必须先了解你，才能真正帮助你。</st> <st c="9145">然而，若没有</st> <st c="9215">外部支持，大多数云项目会在更早的阶段就被认为是失败的。</st>

<st c="9232">简而言之，我们可以说大多数服务在成本方面可能会反过来对你不利。</st> <st c="9305">作为平台工程师，我们必须能够控制这些元素，建立保护措施和限制。</st> <st c="9412">为了实现这一点，我们需要透明度</st> <st c="9448">关于成本。</st>

## <st c="9461">在哪里可以找到透明度</st>

<st c="9488">与此同时，我们有很多选择可以获取关于我们花费在哪些地方的信息，以及这些开销是否基于利用率等指标被认为是浪费。</st> <st c="9662">所有云服务提供商都提供了探索（甚至细分）成本的可能性，但由于重点关注基础设施，尤其是在应用层上，细节往往缺失。</st> <st c="9842">从以下</st> <st c="9867">AWS 成本浏览器的截图来看，我们得到的是不同服务类型的消费图表。</st> <st c="9957">现在我们需要应用过滤器来获得更多见解，并分析这些成本的根源：</st>

![图 8.1：AWS 成本浏览器](img/B31164_08_01.jpg)

<st c="10896">图 8.1：AWS 成本浏览器</st>

<st c="10925">像 Apptio Cloudability 这样的商业解决方案</st> <st c="10974">可以从多个不同账户、云服务提供商和环境中收集成本信息，集中在一个工具中。</st> <st c="11074">它们在给定的数据上应用 FinOps 逻辑，并提供预定义的仪表板，比如以下截图中的单位成本和节省仪表板：</st>

![图 8.2：Apptio Cloudability 详细的单位成本仪表板](img/B31164_08_02.jpg)

<st c="12363">图 8.2：Apptio Cloudability 关于单位成本的详细仪表盘</st>

<st c="12427">微软定义</st> <st c="12445">单位成本如下：“</st>*<st c="12470">衡量单位成本是指计算一个业务单元成本的过程，该业务单元能够展示云计算的业务价值。</st>*<st c="12615">” 单位的具体定义由你决定。</st> <st c="12655">它可以是金融系统中的交易、媒体平台的用户，或你能将不同部分的</st> <st c="12780">基础设施映射到的任何其他内容。</st>

<st c="12798">现在，在我们的平台和开源世界中，我们也可以找到一些解决方案来获得更多的透明度，例如 Kubecost（带有商业计划）和 OpenCost。</st> <st c="12952">两者都可以在集群内分配成本，并与云服务提供商资源结合使用。</st> <st c="13043">不幸的是，两者都缺乏良好的分析能力。</st> <st c="13097">因此，我们常常看到自实施的解决方案与</st> <st c="13163">商业智能</st> **<st c="13168">（BI）</st>** <st c="13189">工具，或 Prometheus 和 Grafana 实现结合，加入一些成本数据。</st> <st c="13275">这些解决方案的效果取决于所投入的时间和</st> <st c="13328">资金。</st>

## <st c="13343">FinOps 和成本管理</st>

<st c="13370">近年来，FinOps 获得了一些</st> <st c="13411">人气，并试图将自己与传统的成本管理区分开。</st> <st c="13490">成本管理通常被描述为一种短期的、孤立的、单一目的的活动，旨在迅速实现成本节省。</st> <st c="13610">当你作为平台团队，具备成本意识并积极管理你的成本时，这也将是一个可持续且持久的解决方案。</st> <st c="13746">但 FinOps 成功之处在于它的整体方法，包括采购部门、</st> **<st c="13841">业务部门</st>** <st c="13855">（</st>**<st c="13857">BUs</st>**<st c="13860">），以及</st> <st c="13868">财务部门，明确目标是实施对云成本及其动态的组织理解。</st> <st c="13971">。</st>

<st c="13986">以下</st> <st c="14001">FinOps 框架概述表明，它采取了与平台工程团队相似的方法。</st> <st c="14121">我们可以看到需要与你的原则对齐的原则；需要集成和启用的能力，这将需要你的输入；以及角色——如平台工程师，他们</st> <st c="14327">合作</st> *<st c="14339">[2]</st>*<st c="14342">：</st>

![图 8.3：由 FinOps 基金会提供的 FinOps 框架](img/B31164_08_03.jpg)

<st c="15554">图 8.3：由 FinOps 基金会提供的 FinOps 框架</st>

<st c="15607">作为平台团队，您应该与 FinOps 团队合作，并积极管理他们对您平台的影响。</st> <st c="15723">潜在的成本节省必须与您的原则、用户满意度和开发者体验相平衡。</st> <st c="15833">基于数据的建议需要具备架构资格，并考虑替代方案和建议以实现</st> <st c="15960">成本节省。</st>

<st c="15973">在接下来的部分，我们将讨论如何实施标签策略。</st> <st c="16053">标签是为云和 Kubernetes 资源提供附加信息的一种简单解决方案，并且能创建某种程度的透明度。</st> <st c="16191">此外，许多成本管理和 FinOps 工具需要标签才能提供</st> <st c="16258">更好的洞察。</st>

# <st c="16275">实施标签策略以揭示隐藏的成本</st>

<st c="16331">标签</st> <st c="16336">和标签</st> <st c="16347">对您来说可能并不陌生，因为它们在各种工具、公有云和 Kubernetes 中都有应用。</st> <st c="16460">我们将使用*标签*这个词来表示标签，但当使用*标签*这个词时，我们实际上是专门指 Kubernetes 标签。</st>

<st c="16597">应用和使用标签本身可以变成一门艺术。</st> <st c="16651">如果标签过多，可能会让它们应附加到服务的哪些信息变得不清楚。</st> <st c="16753">当然，没有标签显然是没有帮助的。</st> <st c="16800">在涉及多个不同业务单元和部门以及复杂发布机制的组织中，标签可能会被过载，或者只是一些缩写的集合。</st> <st c="16964">关键是，我们需要标签来获得服务的透明度，明确它们属于谁，可能还会指示不同的服务级别或安全等级，最终成为将这些服务与成本结构和资源使用情况匹配的锚点。</st> <st c="17215">因此，标签允许更精确地分析与成本相关的资源</st> <st c="17280">和</st> <st c="17288">成本原因。</st>

## <st c="17299">使用标签的目的</st>

<st c="17324">标签</st> <st c="17329">可以针对不同的目标群体和用户。</st> <st c="17376">根据您询问的是哪个子域，它们应该包含组织、操作、安全甚至架构信息。</st> <st c="17521">我们还可以考虑一些对我们作为</st> <st c="17580">平台工程师</st> <st c="17580">可能有帮助的标签。</st>

<st c="17599">组织信息的标签可以定义哪个部门、角色或团队负责该服务，是否是面向内部或外部的解决方案，以及是否存在任何国家、合规或</st> <st c="17817">治理限制。</st>

<st c="17841">在操作层面，常见的属性包括服务级别、调度时间和维护窗口，但也有一些可能由第三方工具引入的非常技术性的资讯；例如，通过实现特定云</st> <st c="18103">策略</st> *<st c="18112">[3]</st>*<st c="18115">。</st>

<st c="18116">对于特定领域，如安全或平台团队，我们可以将标签和标签看作定义所需的隔离或数据保护，或者类似于典型的扩展模式、上下峰值，或识别微服务架构及其归属于某些组件和</st> <st c="18422">结构。</st>

<st c="18434">我们的重点将放在相关的成本</st> <st c="18470">标签上。</st> <st c="18476">这些标签通常与组织标签相似，或与前面提到的操作性或领域特定的标签相关。</st> <st c="18599">明确组织归属或提供有关某事为何如此剧烈扩展的见解是成本管理的关键推动因素。</st> <st c="18735">这些标签有助于为需要提升</st> <st c="18814">成本意识的项目和团队提供清晰的视图。</st>

<st c="18829">一些来源还指出，使用标签进行访问管理。</st> <st c="18897">出于多种原因，这需要谨慎处理。</st> <st c="18951">如果你有</st> **<st c="18963">基于属性的访问控制</st>** <st c="18993">(</st>**<st c="18995">ABAC</st>**<st c="18999">) 和权限</st> <st c="19012">管理，标签可以成为实现这一目标的可行且简单的方式。</st> <st c="19083">但这也带来了一个缺点，即你将一个纯粹的信息源变成了一个安全关键元素，需要在使用时进行保护和双重检查。</st> <st c="19248">将其与信息特性混合使用可能会使标签的使用变得复杂，并且很可能会成为正确使用的障碍。</st> <st c="19378">我们之前说过，标签可以用来传递安全信息。</st> <st c="19446">然而，在提供诸如风险分类或安全级别等信息与提供</st> <st c="19562">访问授权能力</st> <st c="17841">方面，存在差异。</st>

<st c="19589">因此，像我们的平台一样，定义标签的目的至关重要。</st> <st c="19692">随意地使用并设置标签虽然总比什么都不做好，但当标签是否重要变得不清晰时，未来可能会引发问题。</st>

## <st c="19870">标签和标签限制</st>

<st c="19896">不幸的是，我们遇到了两个</st> <st c="19924">普遍存在</st> <st c="19931">的问题：</st>

+   <st c="19948">标签没有标准，这意味着它们的长度、标签数量、允许的字符或</st> <st c="20042">大小写敏感性</st> <st c="20071">等存在很多变体。</st>

+   <st c="20087">组织往往在许多不同的提供商</st> <st c="20169">和平台上拥有多个环境</st>

<st c="20182">所以，在接下来的步骤中，定义标记策略时，你必须了解你可以可靠构建的最小数量。</st> <st c="20299">标记策略将引入一个标准，必须适用于任何平台。</st> <st c="20389">为每个平台定义多种不同的方法将导致混淆</st> <st c="20464">和错误。</st>

<st c="20475">举个例子，我们将</st> <st c="20499">比较不同的提供商</st> <st c="20527">和平台：</st>

|  | **<st c="20541">AWS</st>** | **<st c="20545">GCP</st>** | **<st c="20549">Kubernetes</st>** | **<st c="20560">Azure</st>** |
| --- | --- | --- | --- | --- |
| **<st c="20566">每服务的最大标签数量</st>** **<st c="20590">限制</st>** | <st c="20601">50</st> | <st c="20604">64</st> | <st c="20607">没有</st> <st c="20611">指定限制</st> | <st c="20626">50</st> |
| **<st c="20629">最大</st> <st c="20635">字符标签</st>** **<st c="20650">名称长度</st>** | <st c="20661">128</st> | <st c="20665">63</st> | <st c="20668">63</st> | <st c="20671">512</st> |
| **<st c="20675">最大</st> <st c="20681">字符标签</st>** **<st c="20696">值长度</st>** | <st c="20708">256</st> | <st c="20712">63</st> | <st c="20715">63</st> | <st c="20718">256</st> |
| **<st c="20722">特殊字符</st>** | <st c="20741">字母数字字符、空格以及 + - = .</st> <st c="20786">_ : / @</st> | <st c="20793">字母数字字符、-</st> <st c="20821">和 _</st> | <st c="20826">字母数字字符、- .</st> <st c="20856">_</st> | <st c="20857">字母数字字符、<, >, %, &, \, ?, /</st> <st c="20902">不允许</st> |
| **<st c="20913">区分大小写</st>** | <st c="20928">是</st> | <st c="20932">是</st> | <st c="20936">是</st> | <st c="20940">是</st> |  |

<st c="20944">表 8.1：云提供商和 Kubernetes 的标签限制</st>

<st c="21005">虽然 63 个字符</st> <st c="21026">作为一个常见的方向看起来很好，但我们在实际应用中发现，对于许多组织来说，甚至 256 个字符也不足够。</st> <st c="21151">这只是另一个例子，说明为什么标记策略必须经过</st> <st c="21214">深思熟虑。</st>

<st c="21230">此外，一些结构在不同的提供商之间无法通用。</st> <st c="21296">假设我们的 Financial One ACME 公司使用 AWS 和 GCP，包括其托管的 Kubernetes 服务作为平台，为什么 Financial One ACME 会达到允许的最大标签数量限制呢？</st> <st c="21500">AWS 团队首先发现了这个问题，并发现它可以使用更长的标签和一些特殊字符，从而允许某种嵌套结构。</st> <st c="21645">于是，他们开始将不同的标签合并成一个，得出了</st> <st c="21706">以下结果：</st>

`<st c="21724">department-responsible=financial-one-ACME/domain-sales+marketing/stream-customer-management/squad-frontend/operations-squad-lazy-turtle</st>`

<st c="21860">该值有 112 个字符，包含了</st> `<st c="21903">/</st>` <st c="21904">来表示层次步骤和</st> `<st c="21945">+</st>` <st c="21946">来表示</st> *<st c="21960">和</st>*<st c="21963">。团队对结果感到满意，并将这个新标签推送到共享存储库。</st> <st c="22049">一段时间</st> <st c="22058">后，平台团队收到投诉，在销售和营销 IT 部门中，由于</st> <st c="22177">一些标签的问题，最新的发布没有得到推出。</st>

<st c="22260">此外，您会发现其他限制，如每个账户</st> <st c="22354">或订阅的最大标签数</st><st c="22369">。</st>

## <st c="22370">定义标记策略</st>

<st c="22398">正如</st> <st c="22402">之前所解释的，标签可以具有许多不同的用途；主要是要在技术标签和业务标签之间保持平衡。</st> <st c="22532">业务标签可以分为组织标签和成本标签。</st> <st c="22600">最终，许多标签往往具有重叠的信息。</st> <st c="22660">因此，为了找到正确的方法，通常有必要为定义设定一些基本规则和边界。</st> <st c="22779">在第二步中，您必须在操作、平台和开发之间进行协调，从技术方面找到所需的标签集，然后再设置组织标签。</st> <st c="22974">这个方向是有道理的，因为通常运营所需的标签也包含了关于</st> <st c="23076">组织的信息。</st>

<st c="23093">让我们从一些共同的</st> <st c="23123">基本规则开始：</st>

+   <st c="23136">标签名称和值</st> *<st c="23158">必须</st>* <st c="23162">要短于</st> <st c="23179">63 个字符。</st>

+   <st c="23193">标签只能是</st> <st c="23206">字母数字组合。</st>

+   <st c="23224">标签只能包含</st> `<st c="23244">-</st>` <st c="23245">和</st> `<st c="23249">_</st>`<st c="23250">.</st>

+   <st c="23251">请关注标签值及其内容，因为您通常会对此进行筛选和搜索。</st>

+   <st c="23329">标签名称对于排序</st> <st c="23370">和分组更为相关。</st>

+   <st c="23383">不要将</st> **<st c="23396">个人可识别信息</st>** <st c="23431">（</st>**<st c="23433">PII</st>**<st c="23436">）写入</st> <st c="23443">标签中。</st>

+   <st c="23450">建立一个大小写样式。</st> <st c="23477">企业可能更喜欢帕斯卡样式，而在技术中，烤串样式更为常见。</st>

+   <st c="23565">使用更多的标签比使用更少的标签更好，但尽量保持 10%至 20%的可用</st> <st c="23644">标签。</st>

<st c="23654">根据这些规则，我们可以创建下一个相关的元素。</st> <st c="23719">首先，我们需要考虑为这些元素打上标签，使其比我们之前讨论的更加细化。</st> <st c="23843">一个好的做法是考虑以下分类：</st> <st c="23878">以下分类：</st>

+   <st c="23899">所有权——部门、团队、</st> <st c="23930">组织、流。</st>

+   <st c="23953">环境——无论你们的预发布</st> <st c="23988">环境是什么。</st>

+   <st c="24005">项目或产品——项目或产品集群，用于识别哪些组件</st> <st c="24081">属于同一组。</st>

+   <st c="24097">成本中心——谁是</st> <st c="24116">负责人？</st> <st c="24137">是否有任何共享成本需要</st> <st c="24174">额外考虑？</st>

+   <st c="24181">合规性——监管限制和要求、政策，及</st> <st c="24249">合规规则。</st>

+   <st c="24266">操作——生命周期、备份、</st> <st c="24301">维护窗口。</st>

<st c="24321">从这里开始，我们必须制定命名约定。</st> <st c="24373">如前所述，重要的是不要过度加载单个标签。</st> <st c="24440">遵循给定的规则和限制，并结合许多软件和系统组件的特性，标签约定可能如下：</st> <st c="24576">如下所示：</st>

+   `<st c="24586">department=public-relations-content-management</st>`

+   `<st c="24633">owner=department-public-relations</st>`

+   `<st c="24667">data-classification=personal-identifiable-information</st>`

<st c="24721">在一些语言中，推荐使用 Pascal（</st>`<st c="24777">Hello-My-Name-Is-Pascal</st>`<st c="24801">）或驼峰命名法（</st>`<st c="24820">i-Am-A-Camel</st>`<st c="24833">）。</st> <st c="24837">将所有字母都写成小写的风格称为 kebab 风格。</st> <st c="24913">你需要非常明确地定义这些命名模式。</st> <st c="24973">名字应该有多少个字符？包含多少个单词？</st> <st c="25034">是更具描述性，还是仅仅匹配已经确定的内容？</st> <st c="25098">同样也适用于值。</st> <st c="25129">确保这些约定已被文档化、沟通，并且在工程师的入职或培训中被包括。</st>

<st c="25251">现在，最后一步是开始建立一个</st> *<st c="25297">带有这些基本规则的标签目录</st>*<st c="25332">。建议创建这些目录，以便你有空间描述标签的含义、目的以及面向的群体。</st> <st c="25468">这还可以帮助你保持标签简短，因为你不需要再为标签的值添加更多描述。</st> <st c="25573">下表是一个简单的标签目录示例。</st> <st c="25631">它可以根据组织的独特需求进行扩展。</st> <st c="25693">重要的是将任何你可能需要包含在标签中的信息转移到目录中，以免使标签显得过长</st> <st c="25762">并且难以阅读：</st>

| <st c="25851">#</st> | <st c="25853">标签名称</st> | <st c="25861">预期值</st> | <st c="25876">含义</st> | <st c="25884">目的</st> | <st c="25892">标签利益相关者</st> |
| --- | --- | --- | --- | --- | --- |
| <st c="25908">1</st> | `<st c="25910">部门</st>` | <st c="25920">部门处理或代码；例如，</st> `<st c="25961">DE-22-P</st>` | <st c="25968">应用程序所属的 BU 或区域</st> | <st c="26002">明确应用程序的所有者</st> | <st c="26024">应用程序</st> | <st c="26039">所有者；运营</st> |
| <st c="26069">2</st> | `<st c="26071">应用程序</st>` | <st c="26082">应用程序名称；例如，</st> `<st c="26114">internal-cms</st>` | <st c="26126">应用程序的名称</st> | <st c="26135">识别</st> <st c="26150">该应用程序</st> | <st c="26160">应用程序所有者；</st> <st c="26175">运营；架构师</st> |
| <st c="26216">3</st> | `<st c="26218">维护-允许</st>` | <st c="26237">可以执行维护的日期和时间；例如，</st> `<st c="26298">sunday-0800-1230</st>` | <st c="26314">该标签标识了日期或日期范围，以及以</st> `<st c="26384">0800</st>`<st c="26388">表示的时间段，意味着</st> <st c="26402">上午 08:00</st> | <st c="26412">定义应用程序何时可以关闭以更新/修补或发布</st> <st c="26490">新版本</st> | <st c="26501">运营；</st> <st c="26514">一级支持</st> |

<st c="26533">表 8.2：标签目录示例</st>

## <st c="26564">标签自动化</st>

<st c="26583">这将是不可能的</st> <st c="26607">手动标记所有资源，尤其是在有许多活动组件的 IDP 上。</st> <st c="26688">某些工具可以帮助我们在资源创建时自动标记它们，甚至在事后“修补”它们。</st> <st c="26796">正如我们之前所见，在平台上，我们必须区分平台运行的基础设施和用户在其上运行或管理的工作负载</st> <st c="26982">集群。</st>

<st c="26994">当您使用 Terraform/OpenTofu 等工具管理基础设施时，您可以在代码中给组件打标签</st> <st c="27110">如下所示：</st>

```
 resource "aws_ec2_tag" "example" {
resource_id = aws_vpn_connection.example.transit_gateway_attachment_id
key = "Owner"
value = "Operations" }
```

<st c="27264">对于某些提供商，您甚至可以给所有资源使用相同的标签。</st> <st c="27339">这需要小心处理，因为您不希望错误地标记其他资源，尤其是当这些资源触发第三方集成或导致</st> <st c="27484">错误计费时：</st>

```
 provider "aws" { # ... other configuration ... default_tags {
tags = {
Environment = "Production"
Owner = "Ops" } } }
```

<st c="27616">几乎所有的基础设施即代码（IaC）解决方案都提供这种方法，并且可以适配任何类型的基础设施，无论是云端</st> <st c="27725">还是本地部署。</st>

<st c="27736">这也可以应用于 Kubernetes 资源。</st> <st c="27785">我们在这里跳过常规部署文件，因为这些文件很可能会以不同的方式处理，例如使用 Helm。</st> <st c="27893">以下示例展示了 Helm 如何从 Helm chart 值文件中获取标签的值。</st> <st c="27993">模板</st> <st c="28001">值由一个</st> `<st c="28038">_helper.tpl</st>` <st c="28049">模板文件动态创建，而</st>`<st c="28072">.Release</st>` <st c="28080">值则是内建信息。</st> <st c="28114">另一种选择是从用户提供的</st> `<st c="28158">values.yaml</st>` <st c="28169">文件中读取值：</st>

```
 apiVersion: apps/v1
kind: Deployment
metadata:
 name: {{template "grafana.fullname".}}
 labels:
   app: {{template "grafana.fullname".}}
   chart: {{template "grafana.chart".}}
   release: {{.Release.Name}}
   heritage: {{.Release.Service}}
```

<st c="28433">Helm 的一个优点是我们可以将其与简单的</st> `<st c="28497">if</st>` <st c="28499">语句结合使用。</st> <st c="28511">通过这种方式，我们可以根据部署的目标位置或任何</st> <st c="28639">其他触发条件传递预定义的信息。</st>

<st c="28653">注意</st>

<st c="28658">在您的 Backstage 模板中使用预定义的标签，强制用户至少定义一些基本的</st> <st c="28762">标签。</st>

<st c="28777">这两种方法都是高度声明式的，并且可能会因为实施或被忽视而失败。</st> <st c="28868">当然，您可以在 CI/CD 管道中检查标签的正确使用，但这可能导致许多部署失败。</st> <st c="28995">这引出了策略引擎。</st> <st c="29028">一方面，策略引擎可以用于测试部署中的标签，但像 Kyverno 这样的工具</st> <st c="29125">也可以在需要时添加这些信息。</st> <st c="29169">以下是一个 Kyverno 策略示例，它为任何 Pod</st> `<st c="29216">foo=bar</st>` <st c="29223">添加标签</st> <st c="29242">或服务：</st>

```
 apiVersion: kyverno.io/v1
kind: ClusterPolicy
metadata:
 name: add-labels
 annotations:
   policies.kyverno.io/title: Add Labels
   …
   policies.kyverno.io/subject: Label
spec:
 rules:
 - name: add-labels
   match:
     any:
     - resources:
         kinds:
         - Pod
         - Service
   mutate:
     patchStrategicMerge:
       metadata:
         labels:
           foo: bar
```

<st c="29550">我们可以以非常精细的方式选择并修补这些信息，并且在以后需要时可以随时更新。</st> <st c="29656">如果需要</st><st c="29664">。</st>

## <st c="29667">合并与分开的成本和计费报告</st>

<st c="29722">在许多</st> <st c="29735">组织中，我们看到有合并成本和账单报告的需求。</st> <st c="29811">虽然从组织的角度看，这是理解基础设施支出的最快方式，但它也需要许多标签来确保适当的拆分和细节级别。</st> <st c="30002">当组织规模过大，且业务标签数量大于技术标签时，这是一个明显的信号，表明某些事情出了问题。</st> <st c="30157">从激进的角度来看，此时做合并成本和账单报告就成了一种反模式。</st> <st c="30263">那么我们该怎么办呢？</st> <st c="30289">例如，企业通常使用字母数字编码来识别部门。</st> <st c="30375">因此，部门如果不是叫做</st> *<st c="30416">财务和会计</st>*<st c="30438">，可能会有类似</st> `<st c="30469">B-2-FA-4</st>`<st c="30477">的编码。这种编码是消除许多其他组织或业务标签并将其放入匹配表或数据库的完美基础，尤其是当你希望在其他地方进行编程匹配时。</st> <st c="30691">需要考虑的其他事项包括，例如，暂存环境和集群。</st> <st c="30776">大多数时候，开发、集成和生产系统是独立的。</st> <st c="30859">这意味着，如果你的应用运行在</st> `<st c="30900">曼哈顿</st>` <st c="30909">集群上，这可以被翻译为</st> `<st c="30948">prod-1234-eu</st>`<st c="30960">，那么我就不需要另一个标签来表示</st> `<st c="31002">stage=production</st>` <st c="31018">或</st> `<st c="31022">region=eu</st>`<st c="31031">。需要明确的是，你应该限制自己不要将过多信息添加到</st> <st c="31119">单一值中。</st>

<st c="31132">然而，故事中有一个很大的</st> *<st c="31157">但是</st>* <st c="31160">这让我们回到了话题的起点。</st> <st c="31220">从成本管理的角度来看，你需要拥有许多良好的标签，以便能够进行分析</st> <st c="31330">和研究。</st>

<st c="31343">仅有标签本身是不够的；它们是成本优化的一个重要部分，但你需要采取哪些优化措施呢？</st> <st c="31462">在接下来的部分，我们将探讨一些通用的优化策略，这些策略不仅包括调整规模和</st> <st c="31582">减少基础设施</st><st c="31602">。</st>

# <st c="31607">查看成本优化策略</st>

<st c="31647">减少云和平台成本的最快方法是关闭那些你不需要的部分。</st> <st c="31671">最大的问题是，参与该过程的每个人可能都有一些理由，为什么他们需要现有的基础设施。</st> <st c="31750">但从现在开始，我想要转换你对这个话题的视角：</st> *<st c="31955">成本优化不是我们应该事后引入的东西</st>*<st c="32018">。以下是你应该考虑的另一个原则：</st> *<st c="32070">在平台设计时要具备成本意识和高效性</st>* *<st c="32131">。</st>*

<st c="32144">注意</st>

<st c="32149">平台中发现的成本优化潜力越大，说明我们作为平台工程师</st> <st c="32271">和架构师做得越差。</st>

<st c="32286">我们可以在平台的任何部分发挥潜力。</st> <st c="32342">然而，这本身就可以写成一本书来覆盖所有相关方面。</st> <st c="32410">因此，我们将讨论适用于平台内任何组件的原则。</st>

## <st c="32504">精简流程</st>

<st c="32527">流程、业务和技术方面，都会</st> <st c="32566">导致更高的成本。</st> <st c="32587">我将给你举一个导致不必要成本的模式/反模式的例子。</st> <st c="32673">Kubernetes 的发布分为三个主要版本，在其中的几周里，你会获得补丁、bug 修复和安全补丁。</st> <st c="32821">Kubernetes 发布团队自动化了发布过程中的大部分工作，包括夜间构建，并且持续不断地</st> *<st c="32929">进行所有的测试</st>* <st c="32941">在 Kubernetes 基础设施上运行几千个测试。</st> <st c="32999">当这种方法被引入时，社区将其视为顶级科技公司的圣杯。</st> <st c="33101">突然间，每个人都想要他们容器的夜间构建，常常跳过测试部分，认为测试过程</st> <st c="33219">太过繁琐。</st>

<st c="33231">这种方法的缺点是，大多数夜间构建从未被部署。</st> <st c="33310">它还阻止了构建服务器在晚上关闭。</st> <st c="33370">容器注册表一直保持忙碌，包括 CVE 扫描，企业容器通常较为庞大，增加了传输和存储成本。</st> <st c="33530">大多数组织没有理解的是，Kubernetes 是一个全球性项目。</st> <st c="33613">此外，如果在某个地方是夜晚，其他地方的人仍然在工作，开发新功能并推送到 Kubernetes 仓库。</st> <st c="33758">最终，Kubernetes 是全球最大的开源项目之一，由全球最大的</st> <st c="33858">数字原生公司 Google 发起。</st>

<st c="33881">好好想想！</st>

<st c="33899">仅仅因为别人都在做，考虑清楚它是否真的</st> <st c="33972">有意义！</st>

<st c="33984">回到流程。</st> <st c="34004">几乎每个流程都可以得到改善，因为它们通常是历史上逐步积累的。</st> <st c="34082">在平台空间内，定期引入的工具替代了脚本和自定义开发的工具。</st> <st c="34193">更好的流程不仅可以降低成本，还可以提高</st> <st c="34245">效率，减少风险，最小化错误，并</st> <st c="34293">提供一致性。</st>

<st c="34313">经过验证的流程优化方法可以在</st> *<st c="34377">精益</st>* <st c="34381">和</st> *<st c="34386">六西格玛</st>* <st c="34395">方法论中找到。</st> <st c="34411">为了改善一个流程，它们教你执行以下操作：</st> <st c="34454">以下内容：</st>

1.  <st c="34468">定义/识别</st> <st c="34500">流程的问题。</st>

1.  <st c="34512">衡量</st> <st c="34549">交易的性能和时间。</st>

1.  <st c="34565">分析效率低下</st> <st c="34609">和依赖关系的表现。</st>

1.  <st c="34626">改进流程以</st> <st c="34650">解决效率低下问题。</st>

1.  <st c="34671">通过引入</st> <st c="34722">金丝雀部署</st> <st c="34671">来控制和审查新流程。</st>

<st c="34741">平台的有趣之处在于，大多数流程可以在 CI/CD 流水线和 GitOps 实现中找到。</st> <st c="34855">这些将我们的目标转化为技术步骤，以确保实现预期状态。</st> <st c="34932">复杂的地方在于，当我们在 Kubernetes 内以及其上方的组件中有流程依赖关系时。</st> <st c="35045">作为一个最终一致的事件驱动系统，识别哪些依赖关系导致了哪种行为是一项挑战。</st> <st c="35171">有时候，在不造成</st> <st c="35239">进一步影响的情况下，我们无法改变组件的反应。</st>

<st c="35254">在技术世界中，流程常常听起来像是一堆脚本一起运行。</st> <st c="35340">理想的状态是采用云原生的方法，利用 Kubernetes 标准化的 API、控制器</st> <st c="35440">功能和资源定义。</st> <st c="35480">它解耦了不同的功能，并通过这些流程，使它们更容易优化。</st> <st c="35574">此外，它使得引入新的、历史上积累的</st> <st c="35639">流程垃圾</st><st c="35645">变得困难。</st>

## <st c="35654">寻找最优惠价格的最佳交易</st>

<st c="35697">一种</st> <st c="35699">优化成本的直接方式是比较列表价格，并选择最便宜的选项。</st> *<st c="35794">便宜</st>* <st c="35799">因此是相对的，因为你可能会降低性能、吞吐量、可用的 IP 地址等。</st> <st c="35919">成本和利用率是很好的指标，但必须评估它们的二级影响。</st> <st c="36016">例如，减少实例大小可能会降低吞吐量和性能，这会导致你不得不引入另一个实例。</st> <st c="36158">这样，你可能会用两个实例达到 80%-90% 的利用率，但仍然支付和使用更大实例的费用相同，甚至更多。</st> <st c="36291">即使是利用率更低。</st>

<st c="36310">如果你不受地域限制，某些地区比其他地区便宜；即便如此，它的影响不大。</st> <st c="36416">目前一个强有力的选择是利用 ARM 服务器。</st> <st c="36481">如果你无法在其上运行你自己或用户的工作负载，至少可以将其用于托管服务，例如数据库。</st> <st c="36605">这可以节省 20%-30% 或更多</st> <st c="36633">的成本。</st>

<st c="36642">这些都是非常明显的步骤。</st> <st c="36673">找到并识别在正确区域中不被过度配置的正确资源。</st> <st c="36759">如前所述，当你保持资源精简时，通常能实现更好的成本效益。</st> <st c="36858">并且清晰明了。</st>

<st c="36868">有很多工具，如 Cloudability 或 Flexera，可以帮助你找到更便宜的选项，有些工具甚至建议改变架构来降低成本。</st> <st c="37033">这些工具非常有助于入门，但它们通常也有很高的价格，而它们所编码的知识并不是你不能通过一些自己的研究或参加免费的成本</st> <st c="37247">优化</st> <st c="37259">课程获得的。</st>

## <st c="37268">设计以实现最高利用率和最低需求</st>

<st c="37325">随着平台工程师减少</st> <st c="37351">基础设施，它很可能会影响用户体验。</st> <st c="37385">平台变得越灵活，它就越能适应给定的情况。</st> <st c="37436">你可以引入主动组件，简化系统并在可能的情况下减少系统大小，同时教育用户了解增加或减少工作负载的可能性。</st> <st c="37526">将他们的利用率与账单匹配可以激励用户负责任地使用资源。</st> <st c="37721">责任使用。</st>

<st c="37818">之前，你了解了许多小节点与少数大节点之间的困难。</st> <st c="37914">我们还发现，我们可以轻松支持不同的 CPU 架构，并动态分配资源。</st> <st c="38024">所有这些因素在定义平台核心时都起着重要作用。</st> <st c="38102">我总是脑海中浮现出蚂蚁巢穴的图景。</st> <st c="38154">在它们的中心，有很多活动发生，但核心是一个稳定的结构，里面包含着大部分蚂蚁。</st> <st c="38284">当巢穴，也就是我们的平台，发展壮大时，我们将扩展这一部分。</st> <st c="38352">但有时，我们并不知道这是否只是暂时的。</st> <st c="38409">在整本书中，你已经看到不同的方法来处理动态工作负载，在接下来的章节中，我们将展示一些扩展的最佳实践。</st> <st c="38546">扩展。</st>

<st c="38558">那么，理想的图景是什么样的呢？</st> <st c="38595">除了取决于你的需求之外，平台应尽可能利用其资源，同时没有额外的基础设施开销。</st> <st c="38750">简单来说，作为一个平台，这并不容易做到。</st> <st c="38798">工作负载并不完全掌握在你手中，它可能从静态的长时间运行的资源密集型软件，到成千上万个不断变化的无服务器容器。</st> <st c="38979">我们可以从中得出的结论是，你可以尽情地设计平台，</st> <st c="39045">但最终，一切</st> <st c="39082">都归结为一个持续的工作过程：分析、反应和调整。</st> <st c="39152">随着时间的推移，你可以在平台中构建一个自动反应的基础层，覆盖大多数情况，但你仍然需要继续优化。</st>

<st c="39317">在本章的最后部分，我们将通过一些具体的例子来看一下如何进行扩展和优化。</st> <st c="39422">你将学习到反应性和预测性扩展，以及</st> <st c="39486">成本意识</st> <st c="39496">工程。</st>

# <st c="39509">自动扩展、冷存储和其他成本优化的技巧</st>

<st c="39575">在</st> *<st c="39579">第四章</st>*<st c="39588">中，在</st> *<st c="39597">自动伸缩集群和工作负载</st>* <st c="39631">一节中，我们已经讨论了 Kubernetes 带来的一个关键好处和</st> <st c="39679">核心功能。</st> <st c="39724">K8s 内置了多种不同的工具和机制来实现伸缩，例如配置 ReplicaSets（我们希望每个工作负载的实例数量）或使用可观察性数据来驱动自动伸缩</st> <st c="39925">决策，利用</st> **<st c="39942">水平 Pod 自动伸缩器</st>** <st c="39967">（</st>**<st c="39969">HPA</st>**<st c="39972">），</st> **<st c="39976">垂直 Pod 自动伸缩器</st>** <st c="39999">（</st>**<st c="40001">VPA</st>**<st c="40004">），或</st> **<st c="40011">Kubernetes 事件驱动自动伸缩</st>** <st c="40046">（</st>**<st c="40048">KEDA</st>**<st c="40052">）。</st> <st c="40056">有</st> <st c="40065">一个很棒的免费教程，详细介绍了所有 Kubernetes 提供的自动伸缩选项，</st> *<st c="40171">Is It Observable</st>*<st c="40187"> 提供的。这里是 YouTube 教程链接，里面还包含了 GitHub</st> <st c="40264">教程的链接：</st> [<st c="40274">https://www.youtube.com/watch?v=qMP6tbKioLI</st>](https://www.youtube.com/watch?v=qMP6tbKioLI)<st c="40317">。</st>

<st c="40318">自动伸缩的主要用例</st> <st c="40354">是确保工作负载拥有足够的计算、内存和存储，以实现特定的可用性目标。</st> <st c="40463">以我们的金融公司 ACME 为例，这可能意味着他们使用自动伸缩来确保其金融交易后台能够在 100 毫秒的响应时间内处理 1000 个并发交易。</st> <st c="40680">尽管自动伸缩可以帮助我们实现可用性目标，但它也有成本，因为伸缩资源意味着需要为额外的计算（CPU）或内存付费。</st> <st c="40865">不当的自动伸缩——伸缩过多、从不缩减，或在错误的时间伸缩——也会导致计划外的成本激增，同时无法实现自动伸缩的真正目标！</st>

*<st c="41049">正确的自动伸缩</st>* <st c="41072">是我们所期望的。</st> <st c="41090">正确地做自动伸缩不仅可以帮助我们实现业务和技术目标，还能让我们利用自动伸缩来控制成本。</st> <st c="41245">让我们来看看平台工程师应该了解的几个自动伸缩话题，以及我们还能做些什么来优化成本。</st> <st c="41376">请记住，接下来我们讨论的一些实践也适用于任何类型的工作负载：无论是云工作负载</st><st c="41497">还是其他。</st>

## <st c="41516">自动伸缩的多种形式</st>

<st c="41543">云计算和 Kubernetes 作为核心平台的可扩展性是平台工程师手中非常强大的能力。</st> <st c="41672">然而，扩展的方法有很多种。</st> <st c="41722">有不同的触发点可能导致系统进行扩展，而且，扩展不仅仅是一个方向（通常是向上），我们还必须考虑将系统缩小——甚至缩小到零，以避免浪费资源</st><st c="41950">！</st> <st c="41957">以至于毫无意义！</st>

### <st c="41969">向上扩展——不仅仅是基于 CPU 和内存</st>

<st c="42009">大多数</st> <st c="42015">工程师都熟悉基于 CPU 和内存进行扩展。</st> <st c="42076">你会发现的多数 HPA 示例通常是根据该 Pod 的某个平均 CPU 利用率来扩展 Pod 的副本。</st> <st c="42205">这就是我们通常所说的响应性扩展，因为我们是基于达到某个阈值来进行扩展的</st> <st c="42312">响应。</st>

<st c="42330">然而，基于 CPU 或内存进行扩展并不总是最佳选择。</st> <st c="42402">这也不是我们唯一的选择，尽管大多数扩展框架最初都是基于 CPU 和内存进行扩展的，因为这两个是可以在 Pods</st> <st c="42586">或命名空间中设置的关键限制。</st>

<st c="42600">对于针对特定吞吐量优化的服务来说，例如，基于并发请求来进行扩展会更有意义。</st> <st c="42741">同样，对于 CPU，除了根据平均 CPU 利用率进行扩展，还可以在 Kubernetes 开始限制 Pod 的 CPU 时进行扩展，这可能会更好。</st> <st c="42900">在前面的章节中，我们提到了像</st> <st c="42951">KEDA 以及</st> **<st c="42972">云原生计算基金会</st>** <st c="43005">(</st>**<st c="43007">CNCF</st>**<st c="43011">) Keptn 项目，它们可以提供来自各种可观测性源（如 Prometheus、Dynatrace、Datadog、New Relic）的任何类型的度量，用于事件驱动的自动扩展。</st> <st c="43186">要查看这个如何工作，请查阅 Keptn</st> <st c="43246">文档中的完整示例：</st> [<st c="43262">https://keptn.sh/stable/docs/use-cases/keda</st>](https://keptn.sh/stable/docs/use-cases/keda)<st c="43305">。</st>

<st c="43306">关键要点是，并不是每个工作负载都受限于 CPU 或内存，并且 Kubernetes 不仅仅限制你根据这两个关键属性来定义扩展规则。</st> <st c="43482">根据真正使工作负载更高效地执行的因素来定义扩展规则，还会导致更高效的资源利用，从而带来一个在成本上也得到了</st> <st c="43671">优化</st> <st c="43682">的系统！</st>

### <st c="43692">预测性扩展与响应性扩展</st>

<st c="43727">通常认为</st> <st c="43753">自动扩展是瞬时工作的。</st> <st c="43782">但事实并非如此！</st> <st c="43803">想想金融公司 ACME。</st> <st c="43835">如果在发薪日，每个人都想查看他们的新账户余额，这可能意味着当天前几个小时内流量会激增 10 倍。</st> <st c="43998">然而，云服务提供商不能保证所有这些资源能够立即提供，因为你正在与许多其他组织竞争，这些组织也在尝试同时请求云资源。</st> <st c="44208">此外，工作负载本身也不能立即处理传入的请求，因为许多 Pod 在准备好之前都有一定的启动时间。</st>

<st c="44371">这个问题可以通过预测性扩展来解决。</st> <st c="44427">与反应性扩展——即在达到某个阈值时进行扩展，如前一节所述——相比，预测性扩展是基于潜在的未来情境并在达到阈值之前进行反应。</st> <st c="44654">预测性并不意味着我们需要一个魔法玻璃球来告诉我们未来。</st> <st c="44728">它可以像在我们预期流量激增前几小时启动扩展那样简单；例如，在发薪日之前或在某个特定时间开始的营销活动前。</st> <st c="44921">具体时间。</st>

<st c="44935">其他预测可能更为动态：</st>

+   **<st c="44974">季节性</st>**<st c="44986">：可以通过查看历史数据来基于季节性做出预测。</st> <st c="45054">电子商务是一个很好的例子，一年四季中总会有一些日期流量激增，例如黑色星期五或网络星期一。</st> <st c="45198">这些激增很容易</st> *<st c="45211">预测</st>* <st c="45218">到！</st>

+   **<st c="45232">相关数据源</st>**<st c="45253">：另一个预测方式是查看其他数据源。</st> <st c="45310">保险公司通常会查看恶劣天气数据。</st> <st c="45371">当预报有暴风雨并且这些暴风雨有可能造成损害时，预测性扩展是合理的，特别是对于客户提交保险索赔时所使用的服务。</st> <st c="45566">在这种特定情景下，您甚至可以在接近</st> <st c="45655">暴风雨的特定区域进行扩展。</st>

+   **<st c="45665">系统依赖</st>**<st c="45685">：在复杂系统中，基于系统其他部分的负载行为来扩展依赖组件也是一个可选方案。</st> <st c="45747">以酒店行业为例。</st> <st c="45816">如果我们看到更多人搜索航班，因为他们想在长周末出游，我们也可以预测性地扩展提供酒店、租车或其他可预订活动推荐的后端服务。</st> <st c="46063">前往</st> <st c="46067">旅游目的地的推荐。</st>

### <st c="46086">用例 – 预测性存储扩展以优化成本和可用性</st>

<st c="46158">现在</st> <st c="46163">我们已经了解了不同的预测性扩展方法，接下来让我们将其应用于一个非常高成本的</st> <st c="46268">例子：存储！</st>

<st c="46285">我们的数字系统生成的数据比以往任何时候都要多，而且预计这一趋势将持续下去。</st> <st c="46392">存储 —— 尽管看似有充足的空间 —— 对许多组织来说仍然是一个重要的成本因素。</st> <st c="46488">对我们金融一号 ACME 公司来说也是如此，假设我们需要存储系统处理的每一笔财务交易的所有细节。</st> <st c="46637">作为一个组织，我们需要确保可以始终保存所有记录，但同时我们也希望确保不为目前不需要的存储空间支付费用。</st> <st c="46809">因此，我们希望将空闲磁盘空间保持尽可能小，以避免为不需要的磁盘付费。</st> <st c="46918">另一方面，我们还需要确保有足够的空闲磁盘空间，以防交易量激增，因为我们无法承受交易丢失的风险。</st> <st c="47088">考虑到大规模扩展磁盘不能瞬间完成，可能需要几个小时，我们可以应用预测性存储扩展来满足所有</st> <st c="47246">我们的需求！</st>

<st c="47263">以下截图帮助我们理解这一过程是如何工作的。</st> <st c="47325">它展示了随时间变化的磁盘空闲空间百分比。</st> <st c="47374">我们写入的数据越多，空闲磁盘空间就越少。</st> <st c="47437">与其在某个固定阈值上扩展我们的云存储，我们可以使用预测模型，在预计会在扩展所需的时间内达到某个低阈值时进行扩展——从而确保我们始终拥有足够的空闲磁盘空间，而不会为</st> <st c="47721">过多的空间支付费用：</st>

![图 8.4：云存储的预测性扩展，以优化成本和可用性](img/B31164_08_04.jpg)

<st c="47827">图 8.4：云存储的预测性扩展，以优化成本和可用性</st>

<st c="47912">前面这个例子来自一个真实的使用案例，通过持续根据预测性扩展方法调整存储大小，实现了显著的成本节约！</st>

### <st c="48074">缩放到零——在不需要时关闭系统</st>

<st c="48129">虽然我们运营的许多系统需要 24/7 全天候可用，但有些系统并没有这个要求。</st> <st c="48151">这些可能是仅在正常工作时间由员工使用的系统，或是仅在一天、一个月或一年中特定时间需要执行某些任务的系统。</st> <st c="48229">我敢肯定，我们都能想到一些经常处于空闲状态但仍消耗宝贵资源的系统，尽管它们当前并不</st> <st c="48580">被需要。</st>

**<st c="48591">虚拟机</st>** <st c="48608">(</st>**<st c="48610">VM</st>**<st c="48613">) 是缩放到零的一个很好的例子。</st> <st c="48626">多年来，我们一直在做这件事：在不需要时关闭虚拟机，并在需要继续工作时将其重新启动。</st> <st c="48803">许多组织通过自动化的方式实现这一点：在工作日结束时自动关闭用于日常业务任务的虚拟机，并在第二天早上再次启动它们。</st> <st c="48994">单单这一点就带来了巨大的成本节省机会，因为许多虚拟机可以在晚上</st> <st c="49083">和周末关闭！</st>

<st c="49096">在 Kubernetes 中，我们也有机会将工作负载缩放到零。</st> <st c="49169">我们可以使用前面讨论过的 KEDA，也可以考虑像 Knative（可以运行无服务器工作负载）或</st> `<st c="49290">kube-green</st>`<st c="49300"> 这样的工具。后者旨在减少 K8s 工作负载和集群的 CO2 足迹，并且能够在不需要时将工作负载、节点或集群置于休眠状态。</st> <st c="49458">想了解更多关于</st> `<st c="49478">kube-green</st>`<st c="49488">的信息，请访问以下</st> <st c="49514">网站：</st> [<st c="49523">https://kube-green.dev/</st>](https://kube-green.dev/)<st c="49546">。</st>

<st c="49547">我们仍然需要回答一个问题：哪些工作负载可以缩放到零，以及可以缩放多久？</st> <st c="49643">我们从这些工作负载的所有者那里获得这些数据，明确它们何时以及需要多长时间。</st> <st c="49743">另一种方法是直接利用可观察性数据，查看一天中的哪些时段使用了哪些工作负载，并基于此创建一个</st> `<st c="49894">kube-green</st>` <st c="49904">休眠配置来将工作负载缩放到零。</st> <st c="49953">这种实现的一个示例可以在</st> *<st c="50003">可持续性研讨会</st>* <st c="50030">Henrik Rexed</st> <st c="50043">的讲座中找到：</st> [<st c="50050">https://github.com/henrikrex</st><st c="50078">ed/Sustainability-workshop</st>](https://github.com/henrikrexed/Sustainability-workshop)<st c="50105">。</st>

### <st c="50106">从工作负载扩展到集群</st>

<st c="50141">到目前为止，我们讨论了很多关于调整规模或扩展工作负载的内容，以确保我们拥有足够的资源来满足业务目标，同时也避免过度配置，以便我们可以优化</st> <st c="50326">成本。</st>

<st c="50334">随着我们扩展工作负载的规模，</st> <st c="50368">底层 Kubernetes 集群也需要相应地调整大小。</st> <st c="50444">这时，集群自动扩展功能就派上用场，它会扩大集群的节点数量，确保有足够的资源来运行所有工作负载，同时还会在节点未被充分利用且工作负载能够分配到剩余节点时，缩减节点。</st> <st c="50731">这确保了底层集群节点机器的优化，从而最终</st> <st c="50818">节省了成本。</st>

<st c="50830">Kubernetes 文档网站上已有大量现有文档：</st> [<st c="50913">https://kubernetes.io/docs/concepts/cluster-administration/cluster-autoscaling/</st>](https://kubernetes.io/docs/concepts/cluster-administration/cluster-autoscaling/)<st c="50992">。</st>

<st c="50993">有一些特定的自动扩展工具，比如 Karpenter——最初由 AWS 开发——它帮助调整 Kubernetes 集群的规模，同时控制成本。</st> <st c="51147">Karpenter 与你的云服务提供商的 API 集成，能够配置处理特定工作负载所需的适当节点大小。</st> <st c="51298">如果不再需要，它还会缩减节点。</st>

<st c="51348">除了像</st> `<st c="51378">kube-green</st>` <st c="51388">（之前提到过）这样的工具外，Karpenter</st> <st c="51419">是一个很好的选项，可以在考虑成本的同时扩展你的集群。</st> <st c="51490">要了解更多关于 Karpenter 的信息，请访问</st> [<st c="51531">https://karpenter.sh/</st>](https://karpenter.sh/)<st c="51552">。</st>

<st c="51553">作为平台工程师，</st> <st c="51582">了解所有不同的扩展选项非常重要。</st> <st c="51642">其中许多可以配置来调整工作负载和集群的规模。</st> <st c="51707">对于一些情况，与工程团队和工作负载所有者密切合作，定义适合特定工作负载的扩展策略也非常重要。</st> <st c="51870">总体而言，自动扩展——无论是计算、内存还是存储——是成本效益</st><st c="51973">优化</st> <st c="51983">平台工程的关键推动力之一！</st>

## <st c="52004">成本感知工程</st>

<st c="52027">现在我们已经了解了如何在平台中构建内容，以实现适当规模和自动扩展来节省成本，我们还需要讨论如何让工程团队从一开始就更具成本意识。</st> <st c="52061">最好的成本优化从组织中的每个人意识到他们的行为对成本的影响开始，因此他们会默认地构建和设计更具成本效益的系统。</st> <st c="52244">基于标签的成本报告是一种让团队意识到他们的成本的方法。</st> <st c="52449">这种策略在本章前面已经讨论过。</st>

<st c="52591">让我们来看看一些我们认为每个人都应该考虑的额外选项，因为它们有可能</st> <st c="52691">带来</st> <st c="52700">成本意识的工程实践！</st>

### <st c="52723">只需要你所需的请求方式</st>

<st c="52763">在云计算初期，许多组织给予其工程团队完全访问云门户的权限。</st> <st c="52874">这种便捷的“自助服务”提升了生产力，因为每个人都可以轻松地创建新的虚拟机、存储服务，甚至是 Kubernetes 集群。</st> <st c="53028">然而，这种“西部荒野”式的做法导致了许多组织的成本爆炸，因为用户只是创建新服务，却没有考虑基本问题，例如：我究竟需要多大的虚拟环境，且需要多长时间？</st> <st c="53271">我需要它多久？</st>

<st c="53279">作者曾与之合作的一个组织是一家金融机构。</st> <st c="53368">他们没有给每个人完全访问云门户的权限，而是构建了自己的自助服务门户，允许工程团队创建新的虚拟机、数据库、集群等。</st> <st c="53550">作为自助服务门户的一部分，团队必须定义他们需要资源的*应用程序*和*环境*，以及*需要多长时间*使用这些机器；例如，仅在工作时间内。</st> <st c="53614">该结果是，通过自动关闭不再需要的服务，成本减少了 60%。</st> <st c="53703">下图显示了工程师如何请求他们所需的资源。</st> <st c="53886">右侧还可以看到详细的报告以及该组织正在实现的整体优化目标：</st>

![图 8.5：一款报告并降低成本的自助平台](img/B31164_08_05.jpg)

<st c="54320">图 8.5：一款报告并降低成本的自助平台</st>

<st c="54386">在这个用例中，报告不仅关注成本，还包括碳足迹，这对大多数组织来说是一个重要话题。</st> <st c="54528">通过中央平台提供这一自助服务，使得该组织可以从一开始就让工程师更加关注成本，同时也展示了他们的行动所带来的正面影响。</st> <st c="54700">tive impact their</st> <st c="54719">actions have。</st>

### <st c="54732">租赁模式与固定费用资源</st>

<st c="54764">前面的例子</st> <st c="54785">非常好，但要求团队在一开始就考虑清楚他们确切需要哪些资源、需要多长时间。</st> <st c="54892">另一种做法是采用</st> **<st c="54939">租赁模式</st>**<st c="54950">。这意味着什么呢？</st>

<st c="54972">当 A 开发团队请求一个资源——比如他们需要用来做开发工作的 Kubernetes 集群——他们可以简单地请求一个默认的时间段；例如，1 周。</st> <st c="55160">这个 1 周的时间段就成为了他们对该资源的“初始租期”。</st> <st c="55230">时间段和团队所有权将通过创建的资源标签进行管理。</st> <st c="55319">通过自动化，在租期结束前 1 天，可以通过电子邮件或聊天消息提醒团队他们的租期即将到期。</st> <st c="55473">消息还可以提供给他们一个选项，</st> *<st c="55518">延长租期</st>* <st c="55534">一天或一周，并提醒他们这段额外时间会带来的费用。</st> <st c="55616">

<st c="55628">这种方法已在多个组织中实施，并确保任何团队仍然可以通过自助服务获得他们需要的资源。</st> <st c="55771">它还确保那些被遗忘或不再需要的资源会被关闭，而无需事先指定资源需要的确切时间。</st> <st c="55890">exactly how long a resource will</st> <st c="55932">be needed.</st>

<st c="55942">现在我们已经讨论了如何仅在资源真正需要时运行它们以节省成本，接下来让我们讨论一下工程师如何优化</st> <st c="56101">他们的代码以带来</st> <st c="56122">成本影响！</st>

### <st c="56134">绿色工程 – 优化你的代码</st>

<st c="56175">高效</st> <st c="56185">的代码通常不仅执行更快；它通常还需要更少的 CPU、内存，甚至可能需要更少的磁盘存储或网络带宽。</st> <st c="56325">一切资源的减少也意味着成本的降低。</st> <st c="56367">那么，为什么不是每个人一开始就编写高效的代码呢？</st> <st c="56425">

<st c="56435">工程师们往往面临着时间压力，需要交付新功能，或者组织没有投资能够测试并提供优化建议的工具，作为软件交付生命周期的一部分。</st> <st c="56649">作者们过去曾与许多软件组织合作，识别出一些非常常见的模式，这些模式导致了低效的、因此成本高昂的代码。</st> <st c="56828">以下是</st> <st c="56837">一些例子：</st>

+   **<st c="56851">请求过多数据</st>**<st c="56876">：开发人员不是利用查询语言只请求特定操作所需的数据，而是检索更多数据，然后在内存中进行过滤和处理。</st> <st c="57036">这导致了更多的网络流量来传输数据，更多的内存用于存储数据，以及更多的 CPU 用于在</st> <st c="57172">客户端代码中进行迭代和过滤。</st>

+   **<st c="57184">低效使用库或算法</st>**<st c="57227">：许多软件库存在是为了完成某些任务；例如，</st> **<st c="57299">对象关系映射器</st>** <st c="57324">(</st>**<st c="57326">ORMs</st>**<st c="57330">) 用于将数据库中的数据映射到</st> <st c="57360">开发语言中的对象。</st> <st c="57396">然而，开发团队并不总是有时间来正确测试或配置这些库，以便为特定的使用案例进行优化。</st> <st c="57547">因此，导致了低效的使用，进而导致更高的 CPU、内存、网络和</st> <st c="57640">磁盘访问。</st>

+   **<st c="57652">过度日志记录</st>**<st c="57670">：软件工程师使用日志框架来记录代码执行过程中的信息。</st> <st c="57758">日志通常用于分析、诊断和故障排除失败或有问题的代码执行。</st> <st c="57874">然而，日志经常被过度创建或重复记录，且没有适当的格式或足够的上下文信息；例如，未设置日志级别。</st> <st c="58032">这导致了在创建日志时的开销，同时也导致了当这些日志被摄取、转换和由</st> <st c="58154">可观察性平台分析时的开销。</st>

<st c="58178">在软件工程中，还有许多</st> <st c="58199">模式会导致性能或可扩展性问题。</st> <st c="58280">除了检测这些模式外，应用程序的架构评审还可以通过更高效的架构或重写代码来实现成本降低。</st> <st c="58438">一个显著的例子是亚马逊 Prime Video，它放弃了基于 AWS 的分布式无服务器架构，转而使用被描述为</st> *<st c="58574">单体架构</st>* <st c="58582">的视频质量分析，这样做将基础设施成本降低了 90%</st> *<st c="58657">[4]</st>*<st c="58660">。最终，这些模式也意味着低效的代码执行，从而导致更高的成本。</st> <st c="58758">作为平台工程团队，我们有机会利用现代可观测性工具分析这些模式，并将这些信息反馈给工程师，提醒他们不仅要关注代码带来的成本，还要告诉他们在哪里可以开始进行优化，正如下一张截图所示。</st> <st c="59063">这两张图表展示了每个服务创建了多少日志，并突出了哪些日志没有正确配置；例如，没有设置日志</st> <st c="59208">级别：</st>

![图 8.6：为团队提供关于过度日志等模式的简单洞察](img/B31164_08_06.jpg)

<st c="59585">图 8.6：为团队提供关于过度日志等模式的简单洞察</st>

<st c="59671">这将引导我进入本节的最后部分，即为工程师提供教育机会，让他们从</st> <st c="59796">编写的第一行代码</st> <st c="59820">开始就意识到成本！</st>

### <st c="59831">教育机会</st>

<st c="59857">尽管这可能不会</st> <st c="59876">成为平台工程团队的主要职责，但由于工程团队使用我们的平台作为自助服务来部署他们的应用程序，我们可以利用这个平台来教育每个人，提醒他们在使用平台部署软件</st> <st c="60147">服务时所产生的成本影响。</st>

<st c="60165">在之前的部分中，我们已经强调了使用案例，比如向工程团队发送成本和使用报告，或识别和突出低效的代码模式。</st> <st c="60344">实现这一目标的关键是正确的标签（例如，谁拥有基础设施和应用程序的哪一部分），以及良好的可观测性（例如，哪些系统使用了多少 CPU、内存、网络等）。</st> <st c="60561">拥有这些信息，平台工程团队可以主动将这些数据推送给各团队，并借此持续展示他们的应用程序带来的成本影响。</st> <st c="60739">持续进行这一过程还将产生教育效果，使工程师能够更清楚地了解</st> <st c="60874">他们行为的成本影响。</st> <st c="60896">行为的成本影响。</st>

# <st c="60909">总结</st>

<st c="60917">在本章中，你应该已经培养了对成本的敏感度，并且有了如何在你的平台上处理这个话题的想法。</st> <st c="61044">优秀的平台为用户提供透明度，并提供灵活的选项以根据不同触发条件调整工作负载。</st> <st c="61183">此时，你应该能够结合前几章学到的方法，如动态资源分配与 GPU 配合使用，以实现高利用率和最佳</st> <st c="61361">成本分配。</st>

<st c="61377">记住，仅仅从成本角度来看并不足以降低整体平台成本，因为一些服务器尺寸的减少可能会因为云提供商的其他限制而增加对多个小型服务器的需求。</st> <st c="61602">标签策略为控制和透明度奠定了基础。</st> <st c="61667">看似简单的事情可能最终会导致许多组织讨论。</st> <st c="61728">为了优化成本，你还可以利用其他元素，如流程，并达成长期承诺，以获得更好的</st> <st c="61857">定价优惠。</st>

<st c="61871">最后，我们为你的平台提供了一些实际的示例和最佳实践。</st> <st c="61966">我们回顾了不同的扩展方法，以及预测性扩展与反应性扩展之间的区别，并重点讨论了除 CPU 之外的其他扩展因素，如内存</st> <st c="62149">和存储。</st>

<st c="62161">总结一下，当你理性思考并将你在平台上花费的钱视为自己的钱时，你就能变得非常具有成本效益。</st> <st c="62310">作为一个平台工程团队，你还可以制定一个度量标准，定义平台的效率，以便与你的管理层达成一致，使用这部分免费预算进行进一步的投资和优化。</st> <st c="62524">记住，尽管云给我们提供了一个</st> *<st c="62572">无限的</st>* <st c="62581">资源量，我们不必仅仅因为这些资源</st> <st c="62655">存在就全部使用它们。</st>

<st c="62665">让我们直接进入最后一章。</st> <st c="62709">正如我们之前所说，唯一的不变就是不变。</st> <st c="62774">在我们最后一章中，我们将讨论持续变化以及如何在轻量架构和可持续理念的推动下生存，并探索变革的黄金路径。</st> <st c="62967">为了结束本章，我们敢于展望未来，讨论一些可能或可能不会在</st> <st c="63092">未来几年内变得相关的</st> <st c="63118">技术趋势。</st>

# <st c="63129">进一步阅读</st>

+   <st c="63145">[1] 我们为何离开云端 – 大卫</st> <st c="63180">海内梅尔·汉森：</st>

    +   [<st c="63199">https://world.hey.com/dhh/we-have-left-the-cloud-251760fb</st>](https://world.hey.com/dhh/we-have-left-the-cloud-251760fb)

    +   [<st c="63257">https://world.hey.com/dhh/the-hardware-we-need-for-our-cloud-exit-has-arrived-99d66966</st>](https://world.hey.com/dhh/the-hardware-we-need-for-our-cloud-exit-has-arrived-99d66966)

+   <st c="63344">[2] FinOps 框架高清</st> <st c="63382">海报：</st> [<st c="63390">https://www.finops.org/wp-content/uploads/2024/03/FinOps-Framework-Poster-v4.pdf</st>](https://www.finops.org/wp-content/uploads/2024/03/FinOps-Framework-Poster-v4.pdf)

+   <st c="63470">[3] 云端</st> <st c="63481">托管人：</st> [<st c="63492">https://cloudcustodian.io/</st>](https://cloudcustodian.io/)

+   <st c="63518">[4] Prime Video 成本</st> <st c="63540">优化：</st> [<st c="63554">https://www.thestack.technology/amazon-prime-video-microservices-monolith/</st>](https://www.thestack.technology/amazon-prime-video-microservices-monolith/)
