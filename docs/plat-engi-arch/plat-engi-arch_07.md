# <st c="0">7</st>

# <st c="2">构建安全和合规的产品</st>

<st c="40">在数字化时代，网络犯罪日益增多。</st> <st c="91">虽然并非每个组织都有银行或政府机构那样严格的合规要求，但那些高度监管环境的安全标准和最佳实践可以并应该被推广到你的平台。</st> <st c="327">每一层次的安全性都能帮助防止安全漏洞的发生，</st> <st c="410">从而减少风险。</st>

<st c="419">在本章结束时，你应该能更好地理解安全标准、框架和趋势。</st> <st c="541">这包括理解和</st> <st c="582">利用</st> **<st c="595">软件材料清单</st>** <st c="621">(</st>**<st c="623">SBOM</st>**<st c="627">)，了解开源项目如何提升平台安全，以及理解策略引擎技术（包含示例和用例）。</st> <st c="765">你应该能够利用这些学习，定义正确的行动来保障平台安全，同时不限制你的功能，并确保应用交付过程提供加固且安全的</st> <st c="963">软件/容器包。</st>

<st c="991">因此，本章将涵盖以下主要内容：</st>

+   <st c="1056">调和安全左移与</st> <st c="1094">零信任</st>

+   <st c="1104">理解平台安全——如何构建既安全又灵活和</st> <st c="1178">开放的系统</st>

+   <st c="1189">查看</st> <st c="1201">SBOM 实践</st>

+   <st c="1215">理解流水线安全——你需要考虑的事项，以确保你的</st> **<st c="1291">持续集成/持续交付</st>** <st c="1333">(</st>**<st c="1335">CI/CD</st>**<st c="1340">) 流水线</st>

+   <st c="1352">理解应用安全——制定并</st> <st c="1402">执行策略</st>

+   **<st c="1420">自由和开源软件</st>** <st c="1450">(</st>**<st c="1452">FOSS</st>**<st c="1456">) 在平台安全中的应用以及如何</st> <st c="1492">使用它</st>

# <st c="1498">调和安全左移与零信任</st>

**<st c="1546">安全左移</st>** <st c="1567">和</st> **<st c="1572">零信任</st>** <st c="1582">是当前网络安全领域的</st> <st c="1590">流行术语。</st> <st c="1627">这些术语——或者说是流行短语——无疑会逐渐消失，但它们所代表的实践将在未来几年继续作为最佳实践。</st>

*<st c="1800">安全左移</st>* <st c="1821">将构建和交付软件的过程视为一个从左到右的线性流程图。</st> <st c="1927">该流程图可能会像这样：</st>

![图 7.1: 简单的应用程序开发工作流](img/Figure_7.1.jpg)

<st c="1997">图 7.1: 简单的应用程序开发工作流</st>

<st c="2040">在这个简化的示例中，开发人员编写代码，代码随后被放入源代码管理，最终作为应用程序供用户使用。</st> <st c="2205">查看右侧的这个安全工作流程，尤其是在应用层面本身，虽然重要，但为时已晚。</st> <st c="2318">已经有三个明显的地方，缺乏安全性可能会造成漏洞，这些漏洞可能</st> <st c="2426">被利用。</st>

<st c="2439">在人员层面解决安全问题是向左安全的核心，但这并不是安全的终点；它只是安全的起点。</st> <st c="2583">安全必须贯穿于流程图的每个步骤，以便当我们进入更现实的示例时，能够看到安全如何随</st> <st c="2736">业务范围的扩展而扩展：</st>

![图 7.2：扩展的开发和交付工作流程](img/Figure_7.2.jpg)

<st c="2904">图 7.2：扩展的开发和交付工作流程</st>

<st c="2958">在前面的</st> <st c="2975">图中，你已经可以看到在用户尝试与应用程序及其支持基础设施互动时，实施的一些常见安全最佳实践。</st> <st c="3157">然而，开发团队和开源依赖项层面的安全性，源代码管理中的安全性，CI/CD 中的安全性，以及应用程序本身的安全性并未被解决。</st> <st c="3313">即便是密钥和机密的存储，虽然代表着一种最佳实践，也需要对访问这些密码的过程应用安全措施。</st> <st c="3449">向左的安全帮助你从产品生命周期的开始，到将完成的应用程序交付给最终用户的全过程中构建安全故事。</st> <st c="3624">在平台工程中，这可能会在最安全的平台和实现完美自助服务的平台之间产生不和谐感。</st> <st c="3775">由于平台需要支持开发人员的自助服务，因此平台完全拥有安全故事的做法开始与自助服务所带来的灵活性相冲突。</st> <st c="3956">因此，它可能会施加足够的限制，使得平台显得有很高的准入门槛，从而危及平台的采纳以及</st> <st c="4099">开发人员的幸福感。</st>

<st c="4119">在过去，</st> *<st c="4134">信任，但要验证</st>* <st c="4150">将是解决这个问题的安全模型。</st> <st c="4201">其含义不言自明。</st> <st c="4234">你信任开发人员已经做了所有必要的工作，以维持应用程序所需的安全态势，但在平台团队那边，你并不拥有端到端的安全控制。</st> <st c="4425">该平台会尽最大努力验证所有正确的措施已经到位，而不会干扰</st> <st c="4538">自助服务。</st>

<st c="4554">如今，安全最佳实践发生了变化，</st> *<st c="4609">零信任</st>* <st c="4619">成为了主流。</st> <st c="4645">零信任</st> <st c="4656">本质上假设每个人都是恶意行为者（无论是否故意都不重要）。</st> <st c="4751">为了保持这种安全姿态，平台需要遵循最佳实践，但它不能承担应用程序的责任。</st> <st c="4896">换句话说，平台需要为开发团队和利益相关者提供所有必要的支撑，以支持一个安全且合规的产品。</st> <st c="5042">例如，如果需要使用 Python 语言，那么可以在镜像注册表中提供一个经过安全处理的 Python 二进制文件，无论是内部加固的，还是来自受信任的供应商，所有平台的用户和应用程序都可以访问。</st> <st c="5272">使用来自 Docker 注册表的 Python-Slim 镜像也是一个更安全的选择，并且更容易获得。</st> <st c="5372">对于大多数使用场景，Slim 镜像应该是足够的。</st> <st c="5424">从这里出发，一个合理且自服务的限制是拒绝那些不使用已知安全来源镜像的工作负载。</st> <st c="5563">在 CI 管道中可以处理这个检查。</st> <st c="5607">尽可能将检查推到最左边可以节省每个人的时间，同时也避免了在不符合安全姿态的更改上浪费计算资源。</st> <st c="5769">然而，在这一部分添加检查可能会有点痛苦，因为它需要编写一个作业来扫描、分析，然后根据存储库中所有 Dockerfile 的内容做出决策。</st> <st c="5963">这些文件可能嵌套在子目录中，虽然这不是不可能完成的挑战，但确实可能比较麻烦。</st> <st c="6078">此外，将这种功能写入 CI 管道应该被视为超出普通</st> <st c="6198">平台团队的职责范围。</st>

<st c="6212">从平台的角度来看，另一种方法是使用策略引擎和准入 Webhook 来拒绝任何未使用受信任镜像源的 Pod 定义。</st> <st c="6397">这虽然没有达到理想的最左边，但希望开发团队及其遵循的流程能够避免这种情况的发生。然而，在零信任环境中，这项政策将作为最后的防护措施，确保只有正确的软件被推广到生产环境。</st> <st c="6701">可以认为，来自更多公共来源的镜像对于 IDP 中的原型设计是可接受的，因此，防护措施仅对生产环境是必要的。</st> <st c="6891">这使得平台可以继续为团队服务，而不会不必要地</st> <st c="6980">妨碍他们。</st>

<st c="6992">另一个例子是，只有当提交被签名时，才能接受将提交推送到 GitHub 仓库。</st> <st c="7091">签名表明作者及代码自签名后未被篡改。</st> <st c="7204">这可以通过 GitHub 仓库中的 webhooks 来强制执行，尽管平台团队对任何公司的 GitHub 组织的影响力可能有限；如果有的话，安全团队可能会要求此项操作。</st> <st c="7427">尽管这是“零信任”与左移安全性共同作用的一个很好的例子，但这很可能超出了</st> <st c="7460">平台团队的范围。</st>

<st c="7575">虽然这些短语听起来像是空洞的格言，但如果团队忽视它们所代表的基本原则，就会失败。</st> <st c="7704">做得好的安全性是公司可以做出的最佳投资之一。</st> <st c="7775">将安全性左移意味着尽早进行测试并频繁地进行测试。</st>

<st c="7842">每一个重大的安全漏洞和风险都可以通过测试被发现。</st> <st c="7926">有各种类型的测试，包括一些由安全专业人员执行的测试，但无论是渗透测试还是仅仅是质量工程过程中的基础负面测试，都应该定期测试安全性和合规性，以确保没有意外的表面区域。</st> <st c="8248">这可能表现为以意外的方式使用软件，或者仅仅是验证组织内角色的权限设置</st> <st c="8389">是否正确。</st>

<st c="8401">现在我们已经介绍了左移安全性和“信任但验证”这两个概念，接下来让我们看看如何构建一个既安全又灵活的系统</st> <st c="8543">和灵活的系统。</st>

# <st c="8557">理解平台安全性——如何构建一个既安全又灵活、开放的系统</st>

<st c="8642">平台并不是组织安全态势的全部；它只是方程式的一部分。</st> <st c="8665">在评估如何将网络安全或 DevSecOps 集成到平台时，必须保持平衡。</st> <st c="8748">将安全性左移有助于减少平台团队需要投入的努力，但明确和清晰的安全范围有助于每个人理解自己在</st> <st c="9019">安全故事</st><st c="9030">中的角色。</st>

## <st c="9035">将问题拆解成可消化的小块</st>

<st c="9084">安全性和灵活性也可能让人觉得是两个完全对立的词。</st> <st c="9173">良好的安全性本质上是僵化的；然而，对于 IDP（身份验证平台）的成功来说，平衡这两者是可能且必要的。</st> <st c="9288">我们如何实现这一点呢？</st> <st c="9312">第一步</st> <st c="9321">是</st> **<st c="9324">定义安全范围</st>**<st c="9338">。</st>

<st c="9339">范围界定的第一步是了解所需的最低安全水平。</st> <st c="9438">显然，我们总是应该做得比最低要求更多，因此，如果你想了解最高安全水平可能是什么样的，虽然这不是一个坏主意，但它可能会人为地增加范围，使你无法看到整体的全貌。</st> <st c="9692">因此，我们建议从一个狭窄的重点开始。</st> <st c="9757">一旦你知道平台必须执行的最低安全级别后，就可以开始考虑平台</st> <st c="9923">必须支持的最低安全级别。</st>

<st c="9936">当你走上安全这条道路时，很容易迅速意识到互联网世界有多么危险，从而产生过度修正。</st> <st c="10070">这些过度修正可能会增加认知负担，并为使用平台设置进入障碍。</st> <st c="10172">如果一个优秀的开发人员懒惰，那么平台应当帮助他们懒惰，而不是引入额外的复杂性。</st> <st c="10301">正因为如此，尽管平台不能承担组织整个网络安全姿态的责任，但它在这一姿态中扮演着至关重要的角色。</st> <st c="10451">安全是好的；但安全表演</st> <st c="10486">却不是。</st>

<st c="10493">了解多少是过多，多少是恰到好处，是一种随着时间推移而不断磨练的技能，并且在什么时候一个安全措施过多或恰到好处，没有明确的界限。</st> <st c="10674">答案永远是：</st> *<st c="10701">视情况而定</st>*<st c="10711">。例如，确保一个环境不对公共互联网开放，可能会妨碍项目人员在家办公，但如果这个项目涉及航天飞机或核反应堆，那么这种“空气隔离”环境是正确的，而不是</st> <st c="10992">过度修正。</st>

<st c="11010">许多安全专家花费了多年时间研究安全，并定义了什么是安全和合规的明确标准。</st> <st c="11147">美国</st> **<st c="11151">国家标准与技术研究院</st>** <st c="11197">(</st>**<st c="11199">NIST</st>**<st c="11203">) 是美国商务部下属的一个部门，汇聚了这样的专家，他们定期发布新的标准并随着</st> <st c="11353">行业的发展更新现有标准。</st>

<st c="11370">了解这些组织的工作有助于你在发展对安全性和灵活的</st> **<st c="11510">内部开发者</st>** **<st c="11528">平台</st>** <st c="11537">(</st>**<st c="11539">IDP</st>**<st c="11542">) 交集的理解。</st> <st c="11556">由于这些机构通常发布针对与政府合作的公司的标准，值得注意的是，它们的出版物是针对特定类型的受众，并不能替代与在你</st> <st c="11814">特定行业</st><st c="11827">中有经验的网络安全专家的交流。</st>

### <st c="11833">解决 OWASP 十大安全问题</st>

<st c="11857">如果你仍然不确定从哪里开始，另一个组织发布了可以作为界定安全范围的极好起点的指南。</st> <st c="12000">这个</st> **<st c="12004">开放全球应用安全项目</st>** <st c="12047">(</st>**<st c="12049">OWASP</st>**<st c="12054">)（</st>[<st c="12058">owasp.org</st>](http://owasp.org)<st c="12068">）是一个</st> <st c="12076">专注于网络安全的非盈利组织。</st> <st c="12124">作为一个受人尊敬的安全专家团体，他们的</st> *<st c="12172">十大安全问题</st>* <st c="12179">列表已成为预见并防止软件安全问题的重要指南。</st> <st c="12278">他们会定期重新发布此列表，2021 年出版的版本就是他们的</st> <st c="12367">当前列表：</st>

+   *<st c="12380">A01:2021</st>*<st c="12389">–</st>*<st c="12391">访问控制</st>* *<st c="12398">破坏</st>*

+   *<st c="12412">A02:2021</st>*<st c="12421">–</st>*<st c="12423">加密失败</st>*

+   *<st c="12445">A03:2021</st>*<st c="12454">–</st>*<st c="12456">注入攻击</st>*

+   *<st c="12465">A04:2021</st>*<st c="12474">–</st>*<st c="12476">不安全的设计</st>*

+   *<st c="12491">A05:2021</st>*<st c="12500">–</st>*<st c="12502">安全配置错误</st>*

+   *<st c="12527">A06:2021</st>*<st c="12536">–</st>*<st c="12538">脆弱和</st>* *<st c="12553">过时的组件</st>*

+   *<st c="12572">A07:2021</st>*<st c="12581">–</st>*<st c="12583">身份识别和</st>* *<st c="12602">认证失败</st>*

+   *<st c="12625">A08:2021</st>*<st c="12634">–</st>*<st c="12636">软件和数据</st>* *<st c="12654">完整性失败</st>*

+   *<st c="12672">A09:2021</st>*<st c="12681">–</st>*<st c="12683">安全日志记录和</st>* *<st c="12704">监控失败</st>*

+   *<st c="12723">A10:2021</st>*<st c="12732">–</st>*<st c="12734">服务器端请求</st>* *<st c="12754">伪造（SSRF）</st>*

<st c="12768">OWASP 更进一步，2022 年还推出了针对 Kubernetes 的</st> *<st c="12839">十大安全问题</st>* <st c="12846">列表：</st>

+   *<st c="12863">K01</st>*<st c="12867">:</st> *<st c="12870">不安全的</st>* *<st c="12879">工作负载配置</st>*

+   *<st c="12902">K02</st>*<st c="12906">:</st> *<st c="12909">供应链漏洞</st>* 

+   *<st c="12937">K03</st>*<st c="12941">:</st> *<st c="12944">过于宽松的</st>* *<st c="12962">RBAC 配置</st>*

+   *<st c="12981">K04</st>*<st c="12985">:</st> *<st c="12988">缺乏集中式</st>* *<st c="13008">策略执行</st>*

+   *<st c="13026">K05</st>*<st c="13030">:</st> *<st c="13033">日志记录不足</st>* *<st c="13052">与监控</st>*

+   *<st c="13066">K06</st>*<st c="13070">:</st> *<st c="13073">破损的</st>* *<st c="13080">认证机制</st>*

+   *<st c="13105">K07</st>*<st c="13109">:</st> *<st c="13112">缺失的网络</st>* *<st c="13128">分段控制</st>*

+   *<st c="13149">K08</st>*<st c="13153">:</st> *<st c="13156">机密管理失败</st>*

+   *<st c="13183">K09</st>*<st c="13187">:</st> *<st c="13190">配置错误的</st>* *<st c="13204">集群组件</st>*

+   *<st c="13222">K10</st>*<st c="13226">:</st> *<st c="13229">过时和易受攻击的</st>* *<st c="13253">Kubernetes 组件</st>*

<st c="13274">这些列表大致匹配，但都适用于基于 Kubernetes 的身份提供平台（IDP）。</st> <st c="13292">这些列表不应被视为全面的安全姿态指南，而应被认为是 IDP 安全姿态中需要解决的最基本事项，但仍然是启动你的</st> <st c="13576">范围项目</st>的一个全面起点。

### <st c="13592">实施威胁建模</st>

<st c="13621">在你定义安全范围后，第二步</st> <st c="13656">是</st> **<st c="13660">威胁建模</st>**<st c="13675">。威胁模型是对可能影响你的应用程序或在本案例中平台安全的所有因素的表示。</st> <st c="13803">执行威胁建模是如何得出正确结论的一个典范，这对于组织的安全姿态至关重要。</st> <st c="13943">你可以使用这些</st> *<st c="13961">十大</st>* <st c="13968">列表来引导你关于威胁建模的讨论。</st> <st c="14027">根据</st> <st c="14058">《威胁建模宣言》（</st>[<st c="14086">threatmodelingmanifesto.org</st>](http://threatmodelingmanifesto.org)<st c="14114">）的作者，威胁模型应当回答以下</st> <st c="14161">四个问题：</st>

+   <st c="14176">我们正在</st> <st c="14189">做什么？</st>

+   <st c="14200">可能会</st> <st c="14210">出什么问题？</st>

+   <st c="14219">我们将如何处理</st> <st c="14244">这个问题？</st>

+   <st c="14253">我们做得够好</st> <st c="14271">吗？</st>

<st c="14282">例如，你可以从以下开始：</st> *<st c="14316">我们正在研究用户如何向 IDP 进行身份验证</st>*<st c="14370">。然后，接着讨论</st> *<st c="14395">过于宽松的 RBAC 配置可能会出什么问题？</st>* <st c="14456">并逐一处理 Kubernetes 列表中的每个</st> *<st c="14488">前十名</st>* <st c="14495">项目。</st> <st c="14526">这些问题看似简单，但随着第二个问题（</st>*<st c="14620">可能会出什么问题？</st>*<st c="14639">）和第一个问题（</st>*<st c="14660">我们在做什么？</st>*<st c="14684">）的比例是多对一的，第三个问题（</st>*<st c="14747">我们要如何解决？</st>*<st c="14781">）与第四个问题也有类似的关系。</st> <st c="14811">无论如何，如果</st> *<st c="14844">我们做得够好吗？</st>* <st c="14872">的答案不是一个决定性的“是”，那么这些问题的循环应该继续。</st> <st c="14942">成功的威胁模型和应对计划是通过与所有</st> <st c="15051">平台利益相关者的协作进行的。</st>

<st c="15069">这种在安全方面的协作是成功将安全置于中心的一项重要策略，且不牺牲可用性、接受贡献的能力或自助服务。</st> <st c="15258">正是通过协作的威胁建模过程，可以解决安全方面的社会技术风险。</st> <st c="15373">“安全向左”不仅意味着到达开发者的电脑，甚至包括开发者本人。</st> <st c="15478">确保他们采取适当的预防措施，了解恶意行为者如何试图操控情况以窃取凭证，并且通常遵循最佳实践——例如，不要将公司笔记本电脑留在车里，以免被盗。</st>

## <st c="15724">常见的安全标准和框架</st>

<st c="15765">进入安全标准的世界，首先需要尝试弄清楚一系列缩略语的含义。</st> <st c="15865">目标并不是一夜之间成为安全专家，而是了解自己所需的安全级别，并确保平台做出一切必要措施来符合该安全标准。</st> <st c="16056">解决这个问题的一个简单方法是，查看你所在公司所服务的行业以及相关的安全框架。</st> <st c="16183">例如，美国的医院或大型医疗集团需要</st> <st c="16252">遵守</st> **<st c="16262">健康保险流动性与责任法案</st>** <st c="16313">(</st>**<st c="16315">HIPAA</st>**<st c="16320">)合规性要求。</st> <st c="16335">因此，任何与类似机构合作的供应商，无论其所在地如何，都需要能够遵守相同的标准。</st> <st c="16448">通过了解最终用户和开发团队的需求，平台团队可以确定超越标准最佳实践之外所需的安全性和合规性级别。</st>

<st c="16633">让我们快速概述一些安全标准。</st> <st c="16688">这并不是一个详尽无遗的列表，但涵盖了一些更常见的标准：</st> <st c="16758">常见标准：</st>

| **<st c="16775">标准</st>** | **<st c="16784">地区</st>** | **<st c="16791">级别</st>** | **<st c="16798">描述</st>** | **<st c="16810">备注</st>** |
| --- | --- | --- | --- | --- |
| **<st c="16816">PCI DSS</st>** | <st c="16824">国际</st> | <st c="16838">1-4</st> | **<st c="16842">支付卡行业数据安全标准</st>**<st c="16887">。定义了安全性和合规性要求。</st> <st c="16922">适用于任何处理、传输或存储信用卡信息的公司。</st> <st c="17010">级别基于</st> <st c="17030">交易</st> <st c="17041">量。</st> | <st c="17049">由信用卡品牌创建，而非</st> <st c="17085">政府机构。</st> |
| **<st c="17100">DPDPA</st>** | <st c="17106">印度</st> | <st c="17112">不适用</st> | **<st c="17116">数字个人数据保护法</st>**<st c="17153">。定义了个人数据的处理方式。</st> | <st c="17198">印度政府在 2023 年通过了该法案，虽然它与</st> **<st c="17277">通用数据保护条例</st>** <st c="17311">(</st>**<st c="17313">GDPR</st>**<st c="17317">)相似，但也有显著的差异。</st> |
| **<st c="17353">FedRAMP</st>** | <st c="17361">美国</st> | <st c="17364">中等，</st> <st c="17375">高</st> | **<st c="17379">联邦风险与授权管理程序</st>**<st c="17429">。定义了提供软件和服务给</st> <st c="17452">联邦政府所需的安全性</st> <st c="17516">和合规性。</st> | <st c="17535">美国</st> <st c="17539">联邦政府；与</st> <st c="17574">州政府不同。</st> |
| **<st c="17591">HIPAA</st>** | <st c="17597">美国</st> | <st c="17600">N/A</st> | **<st c="17604">健康保险可携带性与责任法案</st>** **<st c="17638">。</st>** | <st c="17657">这是</st> <st c="17660">90 年代设定的标准，随着技术的发展，必须不断演变</st> <st c="17704">以适应新需求。</st> |
| **<st c="17720">DGA</st>** | **<st c="17724">欧洲</st>** **<st c="17734">联盟</st>** <st c="17739">(</st>**<st c="17741">欧盟</st>**<st c="17743">)</st> | <st c="17745">N/A</st> | **<st c="17748">数据治理法案</st>**<st c="17768">。定义了</st> <st c="17781">欧盟在数据使用</st> <st c="17812">和共享方面的政策。</st> | <st c="17824">适用于</st> <st c="17832">公共部门数据和数据利他主义的背景，以及什么可以共享，什么不能共享。</st> <st c="17923">填补了</st> <st c="17941">GDPR 标准中的空白。</st> |
| **<st c="17955">GDPR</st>** | <st c="17960">欧盟</st> | <st c="17963">N/A</st> | <st c="17967">个人数据如何使用</st> <st c="17972">以及如何不使用。</st> | <st c="18009">这是一次历史性的举措，彻底改变了全球的数据</st> <st c="18062">处理方式。</st> |

<st c="18080">表 7.1：安全性与合规性框架说明</st>

<st c="18136">虽然这些框架有所不同，并且它们旨在实现不同的目标，但从核心上讲，它们是相同的。</st> <st c="18257">由应用程序捕获和存储的数据必须在传输过程中和静止时都得到保护，并且它必须仅进入预期的位置，只有预期的用户可以访问。</st> <st c="18428">这一点部分通过 RBAC 实现，但仅靠 RBAC 不足以保障安全。</st> <st c="18504">诸如 PCI DSS 这样的安全标准包括对硬件、服务器及其物理设备和存放位置的实际检查，才能获得合规认证。</st> <st c="18687">合规性和安全性通常是紧密相关的，但实际上是不同的。</st> <st c="18760">一个系统可以是安全的，但不合规，反之亦然。</st> <st c="18818">尽管我们在此不会深入讨论这些差异，因为它们超出了 IDP 本身的范围，但了解安全性不仅仅是勾选清单上的框是非常重要的。</st> <st c="19004">这些框应该有助于指导威胁建模的工作应在系统中扩展到何种程度，以及你如何在任何</st> <st c="19147">受监管行业中开发平台的角色。</st>

## <st c="19166">资产保护</st>

<st c="19183">坚持数字空间的范式，我们讨论的资产是你服务的数据库。</st> <st c="19279">大多数安全性和合规性法规关注数据处理。</st> <st c="19351">你应当理解为，数据是普通组织最有价值的资产，应该被</st> <st c="19471">珍视。</st>

<st c="19479">你的数据有三种状态：它要么在传输中，要么在使用中，要么处于静止状态。</st> <st c="19552">因此，针对它的安全性必须涵盖所有状态。</st> <st c="19606">由于数据存储在平台上，所以平台有责任确保这一部分的安全性。</st> <st c="19726">这是一个极少数不需要极高安全保护的数据产品，因此，确保数据安全几乎不可能过度。</st>

### <st c="19864">静态数据保护</st>

<st c="19886">你的数据将</st> <st c="19902">大部分时间处于静止状态。</st> <st c="19942">数据设计和整体数据库安全需要非常具体的关注和定期审查，但静态数据的高级概念</st> <st c="20080">归属于</st> <st c="20095">以下几个类别：</st>

+   <st c="20116">分类</st>

    +   <st c="20131">这是什么类型的数据，它包含了什么信息？</st>

    +   <st c="20194">它有多重要？</st> <st c="20209">重要性如何？</st>

    +   <st c="20215">根据监管需求或</st> <st c="20272">业务重要性进行数据的物理隔离</st>

    +   <st c="20287">数据如何与系统交互可以</st> <st c="20331">为分类提供信息</st>

+   <st c="20352">加密</st>

    +   <st c="20363">每一层的加密，包括物理层和</st> <st c="20413">数字层</st>

+   <st c="20424">盐值</st> <st c="20431">和哈希</st>

    +   <st c="20441">不仅仅是加密，</st> <st c="20475">还有压缩</st>

        +   <st c="20490">如果你希望数据</st> <st c="20518">保持人类可读性，这就不太理想</st>

        +   <st c="20537">在内存中可能会大幅扩展，并可能创建</st> <st c="20583">一个意外的</st> **<st c="20597">分布式拒绝服务</st>** **<st c="20619">攻击</st>** <st c="20626">(</st>**<st c="20628">DDOS</st>**<st c="20632">)</st>

+   <st c="20634">限制访问</st>

    +   <st c="20651">可以根据</st> <st c="20677">分类进行调整</st>

    +   <st c="20695">应该有正式的审查流程，</st> <st c="20733">角色与职责</st>

+   <st c="20756">冗余备份</st>

    +   <st c="20774">三是高可用和</st> <st c="20815">低可用系统的魔法数字</st>

    +   <st c="20839">数据的冗余不需要完全一致；可以根据数据丢失的成本来设计策略</st> <st c="20934">数据</st>

+   <st c="20942">数据</st> <st c="20948">保留政策</st>

    +   <st c="20966">你</st> <st c="20970">到底需要它保存多久？</st> <st c="21003">是否有</st> <st c="21007">相关法律</st> <st c="21017">约束？</st>

        +   <st c="21032">那</st> **<st c="21045">监管链</st>** <st c="21061">是什么</st> <st c="21065">关于</st> <st c="21070">那个</st> <st c="21079">决策的？</st>

        +   <st c="21079">与冗余相同；不需要为</st> <st c="21127">所有数据制定统一政策</st>

    +   <st c="21135">你首先需要它吗？</st>

        +   <st c="21170">挑战</st> <st c="21181">每一部分：</st>

            +   <st c="21193">膨胀发生在当人们认为数据</st> <st c="21231">是必要的</st>

            +   <st c="21243">不确定性让人们要求比</st> <st c="21287">他们需要的更多</st>

            +   <st c="21296">展示数据如何增加价值和责任，并使得后续使用和</st> <st c="21383">成本合理化变得容易：</st>

                +   <st c="21394">积极地减少</st> <st c="21416">没有正当理由的部分</st>

                +   <st c="21434">记录系统如何以及为什么被创建的历史</st> <st c="21480">过程</st>

                    +   <st c="21488">员工入职</st> <st c="21507">变得容易</st>

                    +   <st c="21519">回答关于系统的问题变得容易，包括</st> <st c="21581">不公平的问题</st>

                    +   <st c="21592">公共汽车编号失去</st> <st c="21614">其重要性</st>

                +   <st c="21628">保留</st> <st c="21663">这些数据的商业理由是什么？</st>

                    +   <st c="21672">它会</st> <st c="21681">带来利润吗？</st>

                    +   <st c="21692">这能</st> <st c="21701">节省资金吗？</st>

                    +   <st c="21712">我们会从中</st> <st c="21727">学习吗？</st>

                    +   <st c="21735">做这件事</st> <st c="21758">是正确的吗？</st>

                    +   <st c="21764">我们面临哪些风险</st> <st c="21797">如果我们保留它的话？</st>

            +   <st c="21808">操作使用案例是什么？</st> <st c="21843">(例如：故障排除项目、访问日志、</st> <st c="21886">审计跟踪)</st>

+   <st c="21899">热</st> <st c="21904">存储</st> <st c="21908">和</st> <st c="21936">冷存储</st>

    +   <st c="21920">热</st> <st c="21924">存储更</st> <st c="21936">容易访问</st>

        +   <st c="21958">需要</st> <st c="21965">访问规则</st>

    +   <st c="21977">冷存储则不</st> <st c="21997">那么容易访问</st>

        +   <st c="22015">不需要频繁关注但仍然重要的旧数据进入</st> <st c="22097">冷存储</st>

        +   <st c="22109">更难访问，通常由更高级别的</st> <st c="22161">权限</st><st c="22166">控制</st>

### <st c="22176">数据主权</st>

<st c="22193">许多</st> <st c="22199">国家正在采纳数据主权</st> <st c="22238">法律，本质上规定在该国边界内由人们创建的数据不得离开该国的物理边界。</st> <st c="22406">这并不总是意味着数据不能在国外查看（使用中的数据），而是数据存储必须保持在区域边界内。</st> <st c="22564">这解决了静态数据合规性问题，但并没有解决</st> <st c="22627">安全性</st><st c="22633">问题。</st>

### <st c="22645">保障数据在传输中的安全</st>

<st c="22669">当</st> <st c="22674">数据在传输过程中，它正被微服务之间传输，这意味着它暴露在平台的网络和/或外部端点中。</st> <st c="22832">数据在传输过程中需要加密，但最终，数据需要被使用，接收端点将在<st c="22987">某个时刻解压数据：</st>

+   <st c="22998">限制存储在内存中的数据及其存储时间—这能保护平台的健康和数据安全（要聪明地管理</st> <st c="23115">缓存）</st>

+   <st c="23128">不要在广泛开放或特权的端口上传输数据</st>

+   仅记录数据交易中绝对必要的信息，而不是交易本身的数据（参见<st c="23301">日志清理</st>）

+   <st c="23318">通过</st> <st c="23348">清理输入</st> <st c="23365">来防止注入攻击</st>

+   <st c="23365">使用网络安全和加密的最佳实践来防止</st> **<st c="23437">中间人</st>** <st c="23454">(</st>**<st c="23456">MITM</st>**<st c="23460">)攻击</st> <st c="23470">以及其他各种</st><st c="23482">类型</st> <st c="23488">的攻击</st>

### <st c="23498">使用中的数据</st>

<st c="23510">使用中的数据</st> <st c="23525">正如其字面意思所示：系统正在查看或</st> <st c="23589">更改的数据。</st> <st c="23600">数据一旦存储并在使用中，它要么从存储中检索，要么被缓存。</st> <st c="23680">它可能保存在内存中，或者通过各种读取和缓存技术直接读取。</st> <st c="23777">数据在初次进入系统时也会处于使用状态。</st> <st c="23843">这包括注册新用户或存储新的日志行。</st> <st c="23906">通常，处于这种状态的数据也可能正在经历数据转换，如聚合或清理操作，以确保数据不能用于注入攻击，甚至可能被删除。</st> <st c="24106">保护使用中的数据，只是我们在数据传输或静止时所应用的相同原则的另一种体现。</st>

### <st c="24220">保护你的网络安全</st>

<st c="24242">Kubernetes 具有可插拔架构，虽然它默认没有网络栈，但某些 Kubernetes 平台选项会有自己的默认设置。</st> <st c="24393">例如，OpenShift 容器平台采用了默认的</st> **<st c="24453">容器网络接口</st>** <st c="24480">(</st>**<st c="24482">CNI</st>**<st c="24485">)，并称其为</st> **<st c="24497">开放虚拟网络</st>** <st c="24517">(</st>**<st c="24519">OVN</st>**<st c="24522">)。</st> <st c="24526">除了 OVN，还有其他更安全、可观察性更强的解决方案适用于</st> <st c="24599">Kubernetes 网络。</st>

**

<st c="25293">除了网络技术外，网络拓扑在网络安全中也扮演着重要角色。</st> <st c="25409">像防火墙、VPN、VLAN、路由器、交换机等网络工具可能不会直接部署在 Kubernetes 集群上，但它们在集群安全中起着非常重要的作用。</st> <st c="25589">无论最终的网络拓扑如何，集群如何与公共互联网交互（或者可能根本没有交互！），为了进行适当的威胁建模和合规性，你需要能够观察并</st><st c="25809">记录</st> <st c="25821">你的网络。</st>

### <st c="25834">预生产环境与生产环境之间的隔离</st>

<st c="25895">一般的最佳实践</st> <st c="25919">是无论安全性和合规性需求如何，你的系统都应该将生产数据和访问权限与其他环境隔离，以确保数据受到保护。</st> <st c="26080">数据是大多数公司最有价值的资产，因此保护和隔离数据是确保资产安全的最佳方式，能够保证所有公司的安全性和合规性。</st> <st c="26275">数据保护是安全性和合规性的核心。</st> <st c="26335">生产数据绝不能离开生产环境，且必须严格控制对这些数据的访问，确保没有恶意行为者——无论是内部、外部、故意还是意外——能够访问生产数据。</st> <st c="26560">我们再次引用我们的平台架构，来自</st> *<st c="26613">第二章</st>*<st c="26622">：</st>

![图 7.3：平台参考组件](img/Figure_7.3.jpg)

<st c="27459">图 7.3：平台参考组件</st>

<st c="27500">每个白盒，即便</st> <st c="27521">是与安全相关的盒子，都必须有自己的安全网关。</st> <st c="27584">例如，组织的 RBAC 管理能力不能开放给任何人修改。</st> <st c="27689">很容易看出，这种情况如何迅速演变成一个问题，并催生了一个专家领域。</st> <st c="27794">我们不会在本书中取代他们的知识和专业技能；然而，我们会分享一些我们认为最重要的 IDP 安全方面，帮助你走上</st> <st c="27985">正确的道路。</st>

<st c="27996">任何组织的一个简单胜利是将暂存、开发和生产环境完全隔离开来。</st> <st c="28137">这包括拥有完全不同访问规则的独立数据库，而不是一个包含不同表格和不同</st> <st c="28270">访问规则的数据库。</st>

<st c="28283">可以使用单一集群，并通过基于网络策略的隔离、适用于特定命名空间的 RBAC，以及创建类似于多个集群的隔离体验，但集群的 API 服务器、审计日志、</st> `<st c="28556">etcd</st>`<st c="28560">、网络及其他集群范围资源仍然代表着潜在的单点故障，可能影响</st> <st c="28669">隔离的安全性。</st>

<st c="28684">因此，出于</st> <st c="28700">安全和合规性的考虑，最好将环境完全隔离。</st> <st c="28772">通过拥有两个独立的集群，可以保证生产数据的隔离，并减少人为错误对安全性的影响。</st> <st c="28918">从这里开始，你还可以拥有不同的网络配置，例如有不同允许规则的防火墙规则，甚至完全与</st> <st c="29094">公共互联网断开连接的环境。</st>

## <st c="29119">机密和令牌管理</st>

<st c="29147">在 Kubernetes 中，Secret</st> <st c="29171">是应用程序可能需要访问的敏感数据，如密码、认证令牌、环境变量、API 密钥等，以确保其正常功能或完成某项任务。</st> <st c="29367">机密管理</st> <st c="29384">成为在依赖自动化如此重的系统中，像 IDP 一样工作的最关键挑战之一。</st> <st c="29516">幸运的是，有一些设计好的模式和技术可以帮助</st> <st c="29582">应对这一挑战。</st>

<st c="29594">作为一个基于 Kubernetes 的平台，内建的 Kubernetes 功能用于秘密管理的安全性是关键的起点。</st> <st c="29709">需要明确的是，默认行为并不安全。</st> <st c="29771">秘密信息与 ConfigMaps 的存储方式类似，且没有加密。</st> <st c="29837">它们是编码存储的，但编码仅仅是</st> `<st c="29880">base64</st>`<st c="29886">。这种方式适用于开发环境，但对于生产环境并不安全。</st> <st c="29975">然而，你可以在不安装任何第三方应用的情况下对静态的秘密数据进行加密。</st>

<st c="30069">有关静态数据加密的进一步阅读以及可以应用于测试集群的示例，请参阅 Kubernetes 文档中的</st> *<st c="30189">数据加密</st>* <st c="30204">部分：</st> [<st c="30246">https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/</st>](https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/)<st c="30311">。</st>

<st c="30312">秘密管理的范围通常相当广泛，一旦你有多个集群或多个环境，管理支持应用程序所需的所有秘密变得非常困难。</st> <st c="30526">因此，使用诸如 HashiCorp Vault 这样的秘密存储软件，或如 Bitwarden 和 1Password 这样的密码管理器，已经成为行业标准。</st> <st c="30682">一个标准的最佳实践是，将秘密信息在集群中自动部署的方式是：在代码中存储对秘密的引用，然后通过某种逻辑查找该引用并为应用获取相应的秘密。</st> <st c="30925">因此，应用程序通过引用拉取秘密信息的常见模式是利用</st> <st c="31030">侧车模型。</st>

<st c="31044">在侧车模型中，Pod 中的一个容器专门负责在 Pod 启动时获取并提供</st> <st c="31151">供主应用容器使用的秘密信息。</st> <st c="31218">这些秘密信息随后被放入存储卷中，当应用需要时</st> <st c="31304">它会读取这些信息。</st>

<st c="31315">侧车模型</st> <st c="31331">如下所示，其中 Pod 同时包含应用程序和</st> <st c="31402">侧车容器：</st>

![图 7.4：容器侧车模型](img/Figure_7.4.jpg)

<st c="31485">图 7.4：容器侧车模型</st>

<st c="31520">但是，除非</st> <st c="31540">sidecar（或其他服务）在循环中运行，否则这只解决一次，不能解决密钥可能定期更改的环境。</st> <st c="31723">这就是开源软件解决方案是一个绝佳选择的地方。</st> <st c="31777">**<st c="31781">外部秘密操作员</st>** <st c="31806">(</st>**<st c="31808">ESO</st>**<st c="31811">)是一个</st> <st c="31819">开源软件，可以实现这一点。</st> <st c="31852">该项目是 Linux Foundation 的财产。</st> <st c="31896">有关其工作原理的详细概述，请访问</st> [<st c="31939">external-secrets.io</st>](http://external-secrets.io)<st c="31958">。</st>

<st c="31959">他们的参考架构图如下，几乎与我们的</st> <st c="32044">sidecar 参考图几乎完全一样:</st>

![图 7.5：ESO 的参考架构](img/Figure_7.5.jpg)

<st c="32114">图 7.5：ESO 的参考架构</st>

<st c="32156">基本上，秘密</st> <st c="32178">存储在集群外的密码存储中，然后操作员可以访问它们。</st> <st c="32289">秘密引用存在</st> **<st c="32320">自定义资源</st>** <st c="32336">(</st>**<st c="32338">CRs</st>**<st c="32341">)，操作员知道如何解释和执行检索。</st> <st c="32415">如果秘密发生变化，则操作员会自动将新秘密应用于集群，这意味着秘密在</st> **<st c="32546">IDP</st>** <st c="32561">(</st>**<st c="32563">SOT</st>**<st c="32566">)中只有一个</st> <st c="32572">真实来源。</st>

<st c="32592">当然，必须首先提供存储的身份验证秘密给操作员才能工作。</st> <st c="32698">这可能有点困难，因为设置此操作员的人需要能够提供凭据以访问集群外的</st> <st c="32851">秘密存储。</st>

<st c="32866">ESO 在高度监管的环境中特别有用，例如证书和令牌等秘密经常轮换。</st> <st c="33013">这允许在源头进行轮换，但自动传播到</st> <st c="33106">必要的环境。</st>

<st c="33129">ESO 并非集群上秘密管理的唯一开源项目；CNCF 正在孵化其他几个项目，都值得审查。</st> <st c="33279">选择适合您组织的正确工具需要在权衡一系列利弊之后进行，但这些工具利用的模式代表了您应该追求的最佳实践。</st>

### <st c="33483">日志清理</st>

<st c="33499">平台生成的任何日志都应该</st> <st c="33539">进行清理。</st> <st c="33553">应用程序也应该如此；然而，这超出了平台的边界。</st> <st c="33646">日志是数据的一部分，因此是平台安全需要保护的资产。</st> <st c="33747">除了我们之前讨论的存储和传输问题，数据清理是确保即使恶意行为者获得日志数据访问权限，他们也无法利用这些数据进一步危害系统的关键部分。</st> <st c="33972">像</st> <st c="34008">SonarQube（</st>[<st c="34019">https://docs.sonarsource.com/sonarqube/latest/</st>](https://docs.sonarsource.com/sonarqube/latest/)<st c="34066">）这样的代码质量检查工具非常适合检测任何敏感数据是否被发送到错误的位置，从而在发生安全事件之前进行修复。</st> <st c="34210">以防发生安全事件。</st>

<st c="34220">已清理的日志不应包含密码或令牌。</st> <st c="34295">例如，在记录 API 请求时，请求的身份验证方式（例如，持有者令牌）可以被记录，但实际的令牌本身需要被清除。</st> <st c="34470">在捕获或存储敏感数据的地方，应进行加盐</st> <st c="34534">并哈希处理。</st>

<st c="34545">这些平台日志</st> <st c="34566">也应该尽可能避免包含</st> **<st c="34610">个人身份信息</st>** <st c="34645">(</st>**<st c="34647">PII</st>**<st c="34650">)。</st> <st c="34654">这种类型的数据通常不需要，因此存储它会带来不必要的风险</st> <st c="34741">暴露面。</st>

<st c="34754">日志清理也包括保留政策。</st> <st c="34806">就像应用数据在其</st> **<st c="34876">生存时间</st>** <st c="34888">(</st>**<st c="34890">TTL</st>**<st c="34893">) 到期后应进行生命周期管理和销毁一样，日志数据也应如此。</st> <st c="34933">随着平台的不断运行，日志对平台团队的帮助逐渐减少，但其中包含的信息可能在某些情况下仍有价值，尤其是在由于业务需求无法剥离个人身份信息（PII）时。</st> <st c="35152">因此，保留可能对恶意行为者有价值的数据会带来不必要的风险，甚至使用冷存储也无法完全规避这一风险。</st> <st c="35287">何时销毁数据最终是一个业务决策，如果有充分的理由保留平台指标数据，可以对数据进行转换进一步匿名化，以便仅销毁 PII。</st> <st c="35474">保持平台指标</st> <st c="35497">永远存储。</st>

## <st c="35512">安全访问</st>

<st c="35526">我们已经讨论过几次 RBAC 了。</st> <st c="35567">它被明确列为 OWASP</st> *<st c="35609">十大</st>*<st c="35616">之一，因此，确保访问控制正确对组织的安全性至关重要。</st> <st c="35722">确保这一点的方法之一是创建服务账户。</st> <st c="35781">这些账户是非人工身份账户，可以被系统上的工作负载使用。</st> <st c="35878">与人工账户一样，服务账户的认证需要一个令牌，并且这个令牌应定期更换。</st> <st c="36002">通过将访问类型分为人工和非人工，你可以利用</st> <st c="36071">最小权限原则</st> **<st c="36075">（PoLP）</st>**<st c="36103">来确保人工用户或工作负载仅拥有其所需的权限，而不会拥有它们</st> <st c="36209">不需要的权限。</st>

<st c="36218">最小权限不仅应适用于工作负载，也应适用于人员。</st> <st c="36302">在评估用户应该拥有的权限时，有几点需要注意。</st> <st c="36411">接下来，我们将为您定义一些高层次的最佳实践供您调查：</st>

+   <st c="36484">单用户，多 RBAC：</st>

    +   <st c="36509">用户在预备环境和生产环境中有独立的 RBAC 角色。</st>

    +   <st c="36569">预备环境应与生产环境保持一致，以便在一个环境中执行的操作能帮助用户在另一个环境中执行相同的操作。</st>

    +   <st c="36712">可能有破玻璃程序来获取更高的访问权限。</st> <st c="36778">这种访问权限（如果存在）必须是可审计的，这意味着所有相关信息</st> <st c="36855">都必须被记录。</st>

+   <st c="36866">GitOps 用于</st> <st c="36878">安全：</st>

    +   <st c="36888">可以</st> <st c="36893">管理 RBAC。</st>

    +   <st c="36905">减少直接授予访问</st> <st c="36949">集群的需要。</st>

    +   <st c="36961">Doe</st><st c="36965">变成</st> <st c="36975">单点故障（SPOF）。</st>

    +   <st c="36982">中心</st> <st c="36991">的安全性已被移除。</st>

## <st c="37005">审计日志</st>

<st c="37016">什么是审计日志？</st> <st c="37039">审计日志是</st> <st c="37054">Kubernetes API 服务器看到的操作记录。</st> <st c="37109">这意味着 Kubernetes 集群中的每一个变更，无论是自动化的还是人工发起的，从登录到 Pod 调度，都记录在审计日志中。</st> <st c="37253">如果存在标识信息，它将在审计日志中记录。</st> <st c="37326">这是因为审计日志是了解谁在何时、何地做了什么操作的重要路径，审计日志对于事件解决和安全性</st> `<st c="37618">PUT</st>` <st c="37621">或</st> `<st c="37625">PATCH</st>` <st c="37630">等有效载荷也应被记录。</st> <st c="37672">凭据不应作为个人身份信息（PII）记录，应在绝大多数情况下省略。</st> <st c="37755">案例。</st>

<st c="37764">利用审计日志</st> <st c="37786">来确定异常行为可以通过一些基础的可观察性实现和相应的警报来完成。</st> <st c="37911">在定义平台时，你应该已经构思出用户故事和关键用户流程。</st> <st c="38009">在这些练习中，你会分析用户将会做什么并期待成功的操作。</st> <st c="38101">但是你是否考虑过用户不会做或不应做的事情，并期待成功呢？</st>

<st c="38195">审计日志中发现的行为，如果偏离平台用户的正常行为，是定义潜在异常警报的最简单方法。</st> <st c="38334">一个例子是出现大量的</st> `<st c="38384">403</st>` <st c="38387">错误，或者来自于</st> <st c="38462">特定</st> **<st c="38472">无类域间路由</st>** <st c="38502">（</st>**<st c="38504">CIDR</st>**<st c="38508">）范围外的 IP 地址的请求数量显著增加。</st>

<st c="38517">自动化检测可能会查找的其他项目包括</st> <st c="38573">以下内容：</st>

+   <st c="38587">检测异常或无效的用户代理</st> <st c="38629">或机器人</st>

+   <st c="38636">来自</st> <st c="38677">不同位置的多个用户登录或会话</st>

<st c="38696">通常，违反已知规范的事件应该自动地引起人工注意。</st> <st c="38789">然而，大多数情况下，这些事件仍然需要人工审核，因为它们不一定表示安全事件。</st> <st c="38891">它们可能指示一个软件问题或一个必要的事件，但在设计警报时并未考虑到。</st> <st c="39011">警报不应过于频繁。</st> <st c="39050">虚假信号会造成伤害，尤其是当它们在半夜打扰到你的团队时。</st> <st c="39144">如果虚假信号触发得过于频繁，工程师们可能会很快忽视它们，以维持较低的</st> <st c="39243">认知负荷。</st>

<st c="39258">到目前为止，我们已经介绍了安全的基础知识，还有很长的路要走。</st> <st c="39330">现在我们已经学习了一些</st><st c="39361">一般性话题，接下来让我们更具体一点。</st>

# <st c="39405">查看 SBOM 实践</st>

<st c="39431">开源工具、编程语言中的库、包管理器和容器镜像是现代应用程序的构建块，同时在安全</st> <st c="39651">你的</st> **<st c="39657">软件供应链</st>**<st c="39678">方面也带来了独特的挑战。这就是我们亲切地称之为供应链安全难题的原因。</st> <st c="39753">当你并不拥有所有需要</st> <st c="39846">被保护的代码时，你如何保持良好的安全态势呢？</st>

<st c="39857">如果我们以可视化的方式表示供应链，它将包含一些未知的人（我们称之为参与者）为开源依赖项做出贡献，以及另一个可能已知的参与者更直接地为你的代码库做出贡献。</st> <st c="40076">这是一个极度简化的图示（这里可能缺少了 10 个框），但它应该有助于你理解</st> <st c="40186">重点：</st>

![图 7.6：示例供应链](img/Figure_7.6.jpg)

<st c="40263">图 7.6：示例供应链</st>

<st c="40295">你的软件供应链就是一切，所有参与者都在发布你的应用程序中发挥作用。</st> <st c="40385">当我们考虑如何维护安全时，我们必须拆解我们的应用程序和基础设施拓扑结构。</st> <st c="40494">SBOM 是跟踪和管理项目风险的重要工具。</st>

<st c="40572">在美国政府于 2021 年发布行政命令后，这些文档对于许多公司来说变得强制性。</st> <st c="40685">其基本前提是，公司知道它们构建的软件依赖于什么，以及这些软件的依赖项来自何处。</st> <st c="40831">SBOM 会在一款软件及其所有依赖项捆绑发布时生成。</st> <st c="40940">虽然对于每个公司来说并非绝对必要，但作为最佳实践，当与扫描工具配合使用时，它们有助于审计并理解风险的表面区域，特别是在像 Heartbleed 或 Log4j 这样的 Day 0 漏洞再次被发现时。</st>

<st c="41199">SBOM</st> <st c="41207">通常是在 CI 流水线的构建过程中生成的。</st> **<st c="41263">Syft</st>** <st c="41267">是一个</st> <st c="41272">相当常见的 SBOM 生成工具，通常与扫描器</st> **<st c="41345">Grype</st>** <st c="41350">配合使用，</st> <st c="41356">因为它们都是 Anchore 提供的免费开源工具。</st> <st c="41407">思科的开源项目办公室最近还发布了一个</st> <st c="41467">名为</st> **<st c="41485">KubeClarity</st>** <st c="41496">(</st>[<st c="41498">https://github.com/openclarity/kubeclarity</st>](https://github.com/openclarity/kubeclarity)<st c="41540">)，该工具可以协同使用多个 SBOM 和扫描工具，提供软件及其表面区域的最完整视图</st> <st c="41675">以便于风险评估。</st>

<st c="41685">SBOM 生成工具仍然相对较新，因此它们还不完美。</st> <st c="41762">可能某个工具未能检测到一个包，而另一个工具则能检测到，反之亦然。</st> <st c="41846">为了了解你的安全态势，少即不等于多，因此获得尽可能最完整的视图是保持安全的最重要部分。</st> <st c="41996">安全优先。</st>

## <st c="42008">如何使用 SBOM</st>

<st c="42027">SBOM 不仅仅是客户或美国政府要求清单上的一个勾选项。</st> <st c="42038">它还是一个有效的漏洞检测和响应工具。</st> <st c="42130">在</st> *<st c="42203">图 7</st>**<st c="42211">.6</st>*<st c="42213">中，我们展示了你的应用程序如何继承代码，从而继承了可能利用的开源依赖和库中的漏洞。</st> <st c="42366">这些依赖关系很难跟踪，这也是为什么 SBOM 可以作为你系统的账本。</st> <st c="42469">这意味着，如果后续发布了重大安全漏洞通报，你可以快速将该通报与 SBOM 进行交叉引用，并及时了解你的软件是否存在漏洞。</st> <st c="42685">这可以通过查看已创建的报告，也可以通过重新生成报告来完成。</st> <st c="42787">如果报告生成与扫描工具配合使用，扫描工具应该在漏洞被录入到关键</st> <st c="42938">漏洞注册表后立即检测到新的漏洞。</st>

### <st c="42961">获取 GitHub 仓库的 SBOM</st>

<st c="42995">查看 GitHub 仓库的 SBOM 的一种简单方法是使用 curl 命令调用你要调查的仓库的 GitHub API。</st> <st c="43018">为了快速演示，我们将介绍如何执行此操作以及如何解读</st> <st c="43193">结果。</st>

<st c="43205">GitHub SBOM</st> <st c="43218">采用一种被称为 SPDX 的格式；你可以在</st> <st c="43264">这里了解更多关于该格式的信息</st> <st c="43287">：</st> [<st c="43293">https://spdx.github.io/spdx-spec/v2.3/introduction/</st>](https://spdx.github.io/spdx-spec/v2.3/introduction/)<st c="43344">。</st>

<st c="43345">要获取 SBOM，请在终端中使用以下代码块来调用 GitHub API。</st> <st c="43432">你不需要进行身份验证就可以运行此命令，但如果需要的话，也可以进行身份验证。</st> <st c="43506">将</st> `<st c="43518">$REPOSITORY</st>` <st c="43529">和</st> `<st c="43534">$OWNER</st>` <st c="43540">变量替换为你所需的仓库信息。</st> <st c="43575">为了示例，我们将查看</st> `<st c="43622">tag-security</st>` <st c="43634">CNCF 仓库：</st>

```
 curl -L \
-H "Accept: application/vnd.github+json" \
-H "X-GitHub-Api-Version: 2022-11-28" \
https://api.github.com/repos/$OWNER/$REPOSITORY/dependency-graph/sbom
```

<st c="43814">返回的 JSON 会比较长，所以我们只看从</st> <st c="43920">curl 请求中收到的 SBOM 的一部分（</st>[<st c="43929">https://api.github.com/repos/cncf/tag-security/dependency-graph/sbom</st>](https://api.github.com/repos/cncf/tag-security/dependency-graph/sbom)<st c="43998">）：</st>

```
 {
  "sbom": {
    "SPDXID": "SPDXRef-DOCUMENT",
    "spdxVersion": "SPDX-2.3",
    "creationInfo": {
      "created": "2024-08-16T05:37:53Z",
      "creators": [
        "Tool: GitHub.com-Dependency-Graph"
      ]
    },
    "name": "com.github.cncf/tag-security",
    "dataLicense": "CC0-1.0",
    "documentDescribes": [
      "SPDXRef-com.g<st c="44282">ithub.cncf-tag-security"</st>
 <st c="44307">],</st>
 <st c="44310">"documentNamespace": https://github.com</st>/cncf/tag-security/dependency_graph/sbom-0a6b74785f7954ee,
```

<st c="44409">输出的顶部包含了一些关于 SBOM 的基本信息，包括它是如何生成的、何时生成的以及相关的数据许可信息。</st> <st c="44541">这只是告诉你关于你分析的仓库的高层次信息。</st> <st c="44609">接下来的部分是</st> `<st c="44629">包</st>`<st c="44637">，它包含了所有的软依赖项以及它们的关系：</st>

```
 "packages": [
      {
        "SPDXID": "SPDXRef-npm-babel-helper-validator-identifier-7.22.20",
        "name": "npm:@babel/helper-validator-identifier",
        "versionInfo": "7.22.20",
        "downloadLocation": "NOASSERTION",
        "filesAnalyzed": false,
        "licenseConcluded": "MIT",
        "supplier": "NOASSERTION",
        "externalRefs": [
          {
            "referenceCategory": "PACKAGE-MANAGER",
            "referenceLocator": "pkg:npm/%40babel/helper-validator-identifier@7.22.20",
            "referenceType": "purl"
          }
        ],
        "copyrightText": "Copyright (c) 2014-present Sebastian McKenzie and other contributors"
      },
```

<st c="45246">只看</st> <st c="45262">SBOM 中的一个包，你可以看到包信息、使用的版本、许可和版权信息。</st> <st c="45391">MIT 许可证意味着该包是开源的，但版权信息表明谁在维护该包，并且从本质上防止其他软件项目使用该包的名称。</st> <st c="45620">IBM 在此解释了版权的原因：</st> [<st c="45664">https://www.ibm.com/topics/open-source</st>](https://www.ibm.com/topics/open-source)<st c="45702">。输出中还包括了标签供应商和下载位置。</st> <st c="45778">在这个示例中，这两个字段的元数据显示</st> `<st c="45846">NOASSERTION</st>`<st c="45857">。正如 SPDX 文档中所解释的那样（</st>[<st c="45899">https://spdx.github.io/spdx-spec/v2.3/package-information/</st>](https://spdx.github.io/spdx-spec/v2.3/package-information/)<st c="45958">），这应该在以下情况下使用：</st> <st c="45989">以下情况：</st>

+   <st c="46013">SPDX 文档创建者已尝试但无法做出合理的</st> <st c="46087">客观判断</st>

+   <st c="46110">SPDX 文档创建者未尝试确定</st> <st c="46170">此字段</st>

+   <st c="46180">SPDX 文档创建者有意没有提供任何信息（不应因此而意味着任何含义）</st> <st c="46282">。</st>

<st c="46291">对于其他软件包，这些字段可能包含有关软件包的其他数据，也可能没有任何断言。</st> <st c="46400">在软件包列表之后，按照相同顺序列出软件包与</st> <st c="46487">存储库的关系：</st>

```
 "relationships": [
      {
        "relationshipType": "DEPENDS_ON",
        "spdxElementId": "SPDXRef-com.github.cncf-tag-security",
        "relatedSpdxElement": "SPDXRef-npm-babel-helper-validator-identifier-7.22.20"
```

<st c="46692">在这个例子中，这是</st> <st c="46700">非常直接的，因为它说主要元素，标签安全库，依赖于</st> `<st c="46814">npm:@babel/helper-validator-identifier</st>` <st c="46852">软件包版本</st> `<st c="46872">7.22.20</st>`<st c="46879">。在这种情况下，SBOM 创建者可以提供更多元数据，但目前没有。</st> <st c="46969">有关这些关系的更多信息可以在这里找到：</st> [<st c="47028">https://spdx.github.io/spdx-spec/v2.3/relationships-between-SPDX-elements/#111-relationship-field</st>](https://spdx.github.io/spdx-spec/v2.3/relationships-between-SPDX-elements/#111-relationship-field)<st c="47125">。</st>

<st c="47126">再次提醒，SBOM 是一个非常简单的工具；它创建一个分类账，列出应用程序或代码库的组成部分。</st> <st c="47248">单独使用时，它并没有太多作用，但作为工具链的一部分，它对理解系统及其依赖的漏洞风险表面有很大帮助。</st> <st c="47411">依赖。</st>

## <st c="47432">保持在漏洞的顶端</st>

<st c="47466">软件漏洞</st> <st c="47492">通常称为</st> **<st c="47513">公共漏洞及曝光</st>**<st c="47549">，或</st> **<st c="47554">CVEs</st>**<st c="47558">。美国</st> **<st c="47567">国土安全部</st>** <st c="47598">(</st>**<st c="47600">DHS</st>**<st c="47603">) 维护公共 CVE 注册表 (</st>[<st c="47639">https://www.cve.org</st>](https://www.cve.org)<st c="47659">)，您可以了解已知的曝光情况，并可与您的软件和应用进行对比，检查已知的 CVE 和您的风险。</st> <st c="47827">尽管平台团队可以构建专门服务来确定系统中是否存在 CVEs，但无需如此，因为存在大量的 FOSS 工具可以为您完成这项工作。</st>

<st c="48000">您可以通过 GitHub 检查 CVEs，方式如下：</st> <st c="48038">以下：</st>

+   **<st c="48052">Dependabot</st>**<st c="48063">，一个</st> <st c="48066">GitHub 机器人，扫描您的存储库，并提出拉取请求，通过提升软件包到已知的安全版本来积极解决 CVE</st> <st c="48180">问题</st>

+   **<st c="48193">Snyk</st>**<st c="48198">，验证拉取请求以确保不引入任何</st> <st c="48206">新的漏洞</st>

+   **<st c="48285">CodeQL</st>**<st c="48292">，类似于</st> <st c="48305">Snyk，评估拉取请求的内容，确保它们不会</st> <st c="48372">引入漏洞</st>

<st c="48397">为了跟踪运行时的漏洞，定期扫描图像注册中心，如 Harbor，或使用 Trivy 等工具，至少针对你最关键的环境进行扫描，将帮助你及时掌握环境中的漏洞。</st>

<st c="48650">由于 SBOM 生成和漏洞检测通常是 CI 管道的一部分，我们接着讨论管道的其余部分，及如何确保你的</st><st c="48780">CI/CD 过程中的安全性。</st>

# <st c="48841">理解管道安全——你需要考虑的事项，以确保你的 CI/CD 管道的安全</st>

<st c="48932">假设平台团队对 GitHub 或公司使用的其他源代码控制仓库具有影响力或管辖权，那么 CI/CD 管道的安全性</st> <st c="49112">从头到尾将成为身份提供平台（IDP）</st> <st c="49155">安全态势的关键部分。</st>

## <st c="49172">保护你的仓库</st>

<st c="49191">代码仓库的安全性</st> <st c="49227">是“安全向左移”的一个很好的例子。</st> <st c="49277">通过早期强制执行安全规范并将其融入项目的工作方式，组织可以防止问题在后续发生。</st> <st c="49428">一个安全的仓库采用了多个</st> <st c="49467">最佳实践：</st>

+   **<st c="49482">写保护</st>** **<st c="49497">主分支</st>**

    +   <st c="49510">如果需要额外的安全性，你可以使用私有 Git 仓库和自托管的 Git</st> <st c="49580">来增强安全性</st>

+   **<st c="49594">要求</st>** **<st c="49603">签名提交</st>**

    +   <st c="49617">这验证了</st> <st c="49653">提交作者的身份</st>

+   **<st c="49666">提交前 Webhook</st>**

    +   <st c="49686">用于验证没有机密被</st> <st c="49724">意外提交</st>

+   **<st c="49746">强制性</st>** **<st c="49757">同行评审</st>**

    +   <st c="49768">包括由</st> <st c="49790">代码所有者的签字</st>

+   **<st c="49801">自动验证</st>** **<st c="49826">拉取请求</st>**

    +   <st c="49839">依赖</st> <st c="49851">安全扫描</st>

    +   <st c="49865">测试——应包括安全性</st> <st c="49912">和访问权限的验证</st>

+   **<st c="49922">持续扫描</st>**

    +   <st c="49942">扫描</st> <st c="49949">以防止密码、令牌或其他</st> <st c="50003">机密数据的意外提交</st>

<st c="50014">这份清单并非详尽无遗，但它应该为任何组织提供最佳的起点，以确保其</st><st c="50121">源代码能防止恶意行为者和</st> <st c="50172">人为错误的风险。</st>

## <st c="50184">保护 GitOps</st>

<st c="50200">GitOps 已在</st> <st c="50222">第</st> *<st c="50232">第五章</st>*<st c="50241">中详细介绍，因此由于其对平台安全的重要性，我们将简要回顾一下。</st> <st c="50327">GitOps 被松散地定义为一种自动化过程，用于验证 SOT（Git 或其他版本控制系统），以确保期望状态与实际状态匹配。</st> <st c="50492">它通过一次性部署或更改来完成此操作，但也通过一个自动化的调和循环，主动检查期望状态的变化，并对实际状态采取行动，使其与期望状态匹配，或检测到实际状态的变化并对系统进行更改，将其恢复到期望状态。</st> <st c="50802">当前最大的开源 GitOps 项目是 Argo CD，这是一个属于 CNCF 的 CD 工具。</st> <st c="50899">在 Argo CD 和其他 GitOps 模式中，有一些最佳实践需要注意，以确保更</st> <st c="51005">安全的环境。</st>

<st c="51024">对于 GitOps，有两种传播更改的模型；一种是推送模型，另一种是拉取模型。</st> <st c="51133">在推送模型中，GitOps 系统将更改作为推送到其 API 端点的方式接收。</st> <st c="51216">不言而喻，这些推送应当经过适当认证，但我们还是要强调，以确保没有混淆。</st> <st c="51347">接收到推送后，GitOps 系统处理更改，然后采取行动。</st> <st c="51436">这个行动可能是将新的软件包推向生产环境，但也可能是配置更改。</st> <st c="51551">然而，在这种模型中，推送源通常不会被验证，Argo CD 也没有配置来验证它。</st> <st c="51684">这就创建了一个攻击向量，因为如果凭证被泄露，攻击者可以通过 CD 系统推送更改，这可能会打开额外的</st> <st c="51839">入口点。</st>

<st c="51852">拉取方法正好相反。</st> <st c="51889">GitOps 系统使用其认证机制访问 SOT，然后从端点读取更改。</st> <st c="52004">由于源是已知的安全源，通过自动化应用这些更改被认为是一个安全的操作。</st> <st c="52122">这并不是说拉取模型没有风险。</st> <st c="52175">推送和拉取模型都可能遭受 MITM 攻击，但在正确安全的网络和适当的加密实现下，这些风险应该</st> <st c="52339">被大大限制。</st>

<st c="52361">当你的 GitOps 系统采取行动时，它应该以最安全的方式进行。</st> <st c="52444">我们已经讨论过服务账户的使用和价值，因此你应该不会感到惊讶，GitOps 系统应该利用服务账户。</st> <st c="52616">这些服务账户应当只具备完成 GitOps 实施目标所需的最小访问权限，</st> <st c="52773">同时仍能在平台上执行任务。</st>

<st c="52786">安全性和</st> <st c="52800">GitOps 可能是选择适合你 IDP 的 GitOps 工作模式时一个重要的因素，我们希望这些指南在为你的组织构建 GitOps 时能发挥作用。</st>

<st c="52973">现在我们已经覆盖了应用交付的安全性，让我们在</st> <st c="53054">安全基础上继续深入，看看</st> <st c="53096">应用安全。</st>

# <st c="54011">理解应用安全性——设定并执行政策</st>

<st c="53185">安全性是一个动态目标，随着技术的进步，攻击方式增多，攻击者变得越来越复杂。</st> <st c="53317">因此，团队在安全方面保持的流程和仪式比技术本身还要重要。</st> <st c="53440">这并不是因为技术不重要，而是因为良好的纪律和强有力的流程习惯能够使技术根据行业的发展灵活地替换和调整。</st>

<st c="53610">良好纪律的一部分是维护准确的文档和架构图。</st> <st c="53720">如果应用架构发生了重大变更，那么这可能会改变风险面和攻击向量。</st> <st c="53849">例如，对一个库或网络端口的未记录或记录不全的依赖，可能导致暴露在一个更难以识别的漏洞面前。</st><st c="53960">从而增加发现的难度。</st>

## <st c="54024">基础应用安全</st>

<st c="54058">在</st> *<st c="54062">第五章</st>*<st c="54071">中，我们讨论了</st> <st c="54085">构建和交付镜像及工件的方法。</st> <st c="54132">所描述的应用程序语义版本方法代表了创建软件的最佳实践，但不适用于其使用。</st> <st c="54266">当使用 Git 进行源代码控制构建发布时，发布除了一个人为定义的版本外，实际上还会获得一个 SHA-256 签名，这得益于 Git 的现代功能。</st> <st c="54469">与可以重复使用的版本号不同，**<st c="54522">安全哈希算法</st>** <st c="54543">(</st>**<st c="54545">SHA</st>**<st c="54548">)是该软件确切构建的签名，并且它始终是唯一的。</st> <st c="54555">因此，对于安全最佳实践来说，使用平台所使用的镜像的完整 SHA 地址，而不是</st> <st c="54762">镜像版本，是非常重要的。</st>

<st c="54776">以下是使用镜像版本</st> `<st c="54802">docker pull</st>` <st c="54813">命令的示例，以及 SHA：</st>

```
 docker pull quay.io/keycloak/keycloak@sha256:520021b1917c54f899540afcb0126a2c90f12b828f25c91969688610f1bdf949
```

<st c="54964">除了镜像版本，还有一种称为</st> `<st c="55185">latest</st>`<st c="55191">的标识方法，但它们几乎可以是任何东西，因为只有行业规范，没有技术限制。</st> <st c="55296">由于标签可以稍后重新指向任何发布镜像，因此这不是拉取依赖项的安全方法。</st> <st c="55401">使用浮动标签的风险</st> <st c="55429">包括</st> <st c="55438">以下几点：</st>

+   <st c="55452">无意的</st> <st c="55467">和未经测试/审查的更新至</st> <st c="55498">应用程序组件。</st>

+   <st c="55521">限制了立刻了解正在运行的内容以及运行地点的能力</st> <st c="55582">和时间。</st>

+   <st c="55591">未经审查的外部软件包可能会自动传播，为恶意行为者创建可利用的后门。</st> <st c="55704">如果一个 Pod 重启并且</st> `<st c="55741">latest</st>` <st c="55747">被用于该 Pod 的 Dockerfile 中</st> <st c="55778">，这种情况是常见的。</st>

<st c="55786">有几个原因可以选择使用浮动标签，或者使用语义版本发布标签，而不是精确的 SHA。</st> <st c="55900">如果你定期测试最新版本的构建，测试依赖项的持续可支持性会更容易。</st> <st c="56019">在开发环境中，始终使用已知良好包的最新版本所带来的灵活性可能是需要的，然后在转向生产环境时，可以将其固定到精确的版本标签或 SHA。</st> <st c="56237">针对浮动标签进行验证，还可以使团队在应对安全漏洞时更加灵活，因此应该对每个依赖项进行风险评估，并制定政策以确定应用程序的规范</st> <st c="56460">是什么。</st>

<st c="56468">设置策略的典型方式是使用开源策略代理等工具来捕捉任何偏离已定义规范的行为，并防止这些偏离进入受限</st> <st c="56659">环境。</st> **<st c="56673">开放策略代理</st>** <st c="56690">(</st>**<st c="56692">OPA</st>**<st c="56695">)和</st> **<st c="56702">Kyverno</st>** <st c="56709">都是免费使用的开源选项。</st> <st c="56761">对于这两个工具，你可以利用</st> **<st c="56790">代码即策略</st>** <st c="56804">(</st>**<st c="56806">PaC</st>**<st c="56809">)，它可以方便地审查并保存在</st> <st c="56850">源代码管理中。</st>

<st c="56865">OPA 和 Kyverno 是两个可以用于安全的开源软件示例，但它们并不是开源生态系统中唯一的工具。</st>

# <st c="57004">用于平台安全的 FOSS 及其使用方式</st>

<st c="57049">FOSS 项目，无论是在 Linux 基金会还是 CNCF 内部外部，都有大量的项目可以帮助你管理平台的安全态势。</st> <st c="57205">前面提到的项目如 Harbor 和 Trivy 只是其中的两个。</st> <st c="57276">它们只是众多项目中的一部分。</st>

<st c="57289">在比较你的安全需求时，比如确保已涵盖 OWASP</st> *<st c="57353">十大</st>* <st c="57360">针对可用的开源项目，你会发现有工具可以帮助你解决列表上的每一项。</st>

## <st c="57472">管理安全的模式与工具</st>

<st c="57513">平台的作用仅限于管理公司安全态势。</st> <st c="57594">因此，它需要通过提供有用的集成、采取安全优先的策略，并且如前几章所讨论的，保持对支持的开发者社区的贡献开放，来为安全提供坚实的基础。</st> <st c="57837">当你确定了所需的合规级别后，就可以开始查看哪些错误可能导致合规性和安全态势的失败，通过进行基于流程的安全审查和基于技术的</st> <st c="58075">安全审查：</st>

+   <st c="58092">一个</st> **<st c="58095">基于流程的审查</st>** <st c="58115">意味着有人在审查和评估合规性与安全性。</st> <st c="58193">这可能是为了寻求认证而进行的审计，也可能是定期进行的内部审查，以确保最佳实践仍在实施，并且指南是最新的。</st> <st c="58365">。</st>

+   <st c="58373">一个</st> **<st c="58376">基于技术的审查</st>** <st c="58399">将</st> <st c="58406">利用软件自动并可能持续地审查和验证安全性与合规性。</st> <st c="58510">SBOM 和 CVE 扫描是基于技术的软件构建审查的例子，像 OPA 或 Kyverno 这样的策略引擎可以帮助自动治理 IDP。</st> <st c="58687">技术解决方案还可以进一步帮助检测可能代表安全事件的异常和事件。</st> <st c="58825">CNCF 项目</st> **<st c="58842">Falco</st>** <st c="58847">(</st>[<st c="58849">https://falco.org</st>](https://falco.org)<st c="58866">) 就是这样做的。</st> <st c="58880">它有几个关键的</st> <st c="58898">特点，但</st> <st c="58913">重要的是，它能检测是否存在权限提升，这可能代表着不良的安全和合规态势，或者可能代表一个已经获得系统访问权限的不法分子。</st> <st c="59083">该系统的安全性可能已经被破坏。</st>

<st c="59094">任何公司如果希望展示符合某一治理框架的安全性和合规性，那么该合规框架将有助于定义过程执行的频率，并将</st> <st c="59305">这些指导与定期审计相结合，以帮助确保平台</st> <st c="59367">不会出现任何问题。</st>

## <st c="59382">我们的虚构公司会怎么做呢？</st>

<st c="59420">我们的虚构公司“Financial One ACME”是一家长期存在的金融机构，正在进行云原生转型，以便在与年轻的金融科技公司竞争中保持竞争力。</st> <st c="59624">作为一家金融机构，他们有一个固有的目标——最小化风险。</st> <st c="59697">他们还受到监管限制，包括</st> <st c="59757">PCI DSS。</st>

<st c="59765">此外，由于他们是一家银行，必须保护货币资产和客户数据，他们已经建模了可能威胁到其系统的潜在风险。</st> <st c="59910">在众多物理和非物理风险中，许多安全行动项目被交给平台团队，在 IDP 的实施过程中解决。</st> <st c="60072">这些问题可能已经得到解决，但由于这个 IDP 是一个全新的应用程序（或者是一个全新的项目），它需要重新处理合规性</st> <st c="60218">要求。</st>

<st c="60238">平台团队需要实施的一个事项是确保他们所有新版本的软件包都已</st> <st c="60367">妥善安全。</st>

<st c="60384">妥善安全意味着</st> <st c="60408">以下内容：</st>

+   <st c="60422">签名</st> <st c="60430">并验证</st>

+   <st c="60443">安全存储</st>

+   <st c="60459">安全地检索</st>

+   <st c="60478">严格的</st> <st c="60486">变更控制</st>

+   <st c="60500">审计跟踪</st>

<st c="60512">平台团队采取了之前概述的步骤来确保他们的代码库和 GitOps 系统的安全，但这些措施不足以满足这一要求。</st> <st c="60672">因此，平台团队决定利用一个内部镜像注册表，其中所有软件提交和包都会进行签名。</st> <st c="60806">CI/CD 管道基于这些工件创建镜像，并将它们放入私有注册表中，平台应用程序</st> <st c="60933">从中获取镜像。</st>

<st c="60946">镜像注册表的选择可能看起来像是以下几种选项之一：</st>

+   <st c="61013">支付给一个镜像注册表供应商，帮助他们通过扫描来维持安全姿态，并为他们提供</st> <st c="61130">可信</st> **<st c="61139">通用基础</st>** **<st c="61154">镜像</st>** <st c="61160">(</st>**<st c="61162">UBI</st>**<st c="61166">)</st>

+   <st c="61168">托管他们自己的镜像注册表，如</st> <st c="61206">Harbor，这是一个 CNCF 毕业项目，拥有一个镜像注册表，该注册表</st> *<st c="61267">签名</st>*<st c="61272">、</st> *<st c="61274">存储</st>*<st c="61280">和</st> *<st c="61286">扫描</st>* <st c="61291">容器镜像（</st>[<st c="61310">https://goharbor.io/</st>](https://goharbor.io/)<st c="61331">），并且它们将被填充为</st> <st c="61364">已批准的镜像</st>

+   <st c="61379">如果他们使用的是 OpenShift，那么集群拓扑中已经有一个镜像注册表，平台团队会用</st> <st c="61524">扫描工具</st> 来补充它。

<st c="61538">他们进一步添加了一个准入 webhook，以确保没有容器基于未批准的镜像。</st> <st c="61643">这个用例非常简单：一个验证 webhook 检查容器镜像是否符合定义的预期。</st> <st c="61774">如果不符合，工作负载将被拒绝，Pod 将无法启动。</st> <st c="61835">虽然团队可以自己构建一个准入 webhook 服务，但他们可能会选择 OPA。</st> <st c="61929">虽然它不是唯一提供此功能的开源项目，但它是唯一一个毕业项目，使其成为生产环境中最安全的选择。</st> <st c="62074">在生产中使用。</st>

<st c="62088">Sysdig</st> <st c="62095">创建了一个开源版本的此类 webhook，它还会更改或修改 Pod 配置，以便其镜像使用完整的镜像 SHA，而不是发布标签，详细信息见：</st> [<st c="62282">https://github.com/sysdiglabs/opa-image-scanner</st>](https://github.com/sysdiglabs/opa-image-scanner)<st c="62329">。这两个 webhook 都代表了安全性和合规性的最佳实践，是任何平台</st> <st c="62479">工程团队在安全方面轻松获胜的明智之选。</st>

<st c="62496">然而，尽管这些限制至关重要，它们可能通过限制 IDP 能力的灵活性而对创新产生负面影响。</st> <st c="62635">因此，平台团队决定将这些限制限制在生产环境中。</st> <st c="62741">这样做允许开发团队在其开发环境中进行实验，而无需担心任何不应意外进入</st> <st c="62885">生产环境。</st>

<st c="62909">管理依赖项的一种策略是使用供应。</st> <st c="63033">供应是将代码从你原本会导入代码库的开源库复制过来的过程。</st> <st c="63160">在供应过程中，可能会对该代码进行更改以</st> <st c="63213">增强其安全性，例如启用</st> **<st c="63252">联邦信息处理标准</st>** <st c="63292">(</st>**<st c="63294">FIPS</st>**<st c="63298">) 模式。</st> <st c="63307">FIPS 合规性规定了数据通过</st> <st c="63367">安全套接层</st> **<st c="63377">(</st>**<st c="63398">SSL</st>**<st c="63401">) 的加密强度，通常是最佳实践。</st>

<st c="63437">平台团队可能会有的另一个行动项目是在疑似安全漏洞事件中成为第一联系点。</st> <st c="63582">这意味着需要立即对问题报告做出反应。</st> <st c="63651">由于平台对公司基础架构的责任很大，从开发到生产能力，团队需要能够迅速响应，以减轻</st> <st c="63862">恶意行为者造成的损害。</st>

<st c="63872">应当制定并定期测试这样的</st> **<st c="63878">IR 计划</st>** <st c="63886">(</st>**<st c="63888">IRPs</st>**<st c="63892">)。</st> <st c="63901">与</st> **<st c="63948">灾难恢复计划</st>** <st c="63970">(</st>**<st c="63972">DRP</st>**<st c="63975">) 类似，定期</st> <st c="63986">测试计划及其响应真实安全漏洞的能力可以</st> <st c="64064">减轻损害。</st>

<st c="64081">早期检测是该平台所需的另一个关键能力。</st> <st c="64150">对审计日志的分析是理解谁进入了系统（或谁的凭证被泄露）以及恶意行为者在获得访问权限后进行了什么操作的关键。</st> <st c="64317">审计日志还可以用于主动检测，因为它们可以被</st> <st c="64393">用于</st> **<st c="64397">机器学习</st>** <st c="64413">(</st>**<st c="64415">ML</st>**<st c="64417">)模型进行异常检测，这可以比人类更快地发现安全漏洞。</st> <st c="64521">此外，使用像 Cilium 这样具有高度可观察性的云原生网络解决方案可以帮助识别和追踪恶意行为者。</st> <st c="64652">尽管一些硬编码的可观察性实现能够达到相同的结果，但它们需要手动维护，而机器学习模型由于其</st> <st c="64853">自学习的特性，可能具有更多的内在灵活性。</st>

<st c="64874">两种方法都不是完美的，因此，在决定如何围绕威胁检测实现自动化时，组织需要对收益、权衡和团队能力做出判断。</st> <st c="65073">在我们虚构公司的情况下，选择前进的路径将是一个关于“自建与购买”的讨论，这可能会因为任务的规模和复杂性以及它们所需维护的高度安全环境而最终做出购买的决策。</st> <st c="65310">为了维持这一点。</st>

<st c="65322">谈到这个高度安全的环境，为了向审计员展示组织使用新 IDP 的 PCI 合规性，我们的平台团队需要能够提供网络架构图，并向</st> <st c="65595">审计员解释该图的内容。</st>

<st c="65607">任何合规性审计员都希望验证开发和生产环境是否得到充分隔离，无论这是否在物理上得到实现，或者通过</st> <st c="65757">网络实现来完成。</st>

<st c="65784">最后，虽然 Financial One ACME 平台团队将确保他们遵循所有已知的构建时最佳实践，但他们也会实施工具，确保他们的运行时同样安全。</st> <st c="65984">很可能，生产环境中唯一有权限创建 Pod 的用户将是那些服务帐户用户，确保 Git 保持为 SOT，并且可以利用 GitOps 来规范平台的</st> <st c="66209">安全态势。</st>

<st c="66226">这些示例响应仅涵盖了金融机构（如银行）所需的一部分安全性和合规性要求；它们还可能会受到额外政府法规的约束，这将需要进一步的安全性和合规性风险缓解措施。</st> <st c="66518">正如您的团队所需要的，我们虚构的公司也需要解决其所遵循的合规框架中的每一项条目，并且最</st> <st c="66673">重要的是，创建协作仪式来维持最佳安全性</st> <st c="66748">他们可以达到的水平。</st>

# <st c="66757">总结</st>

<st c="66765">总之，安全性和合规性是一个广阔的领域，许多专家已经发布了专门的著作。</st> <st c="66888">本章不应被视为包罗万象，但应帮助您迈出正确的步伐，为您的 IDP 定义并执行网络安全策略。</st> <st c="67058">了解如何追踪漏洞并在您的组织中建立仪式和工具，以便捕捉和发现 IDP 及其所承载的应用程序中的漏洞是非常重要的。</st> <st c="67252">它所托管的应用程序。</st>

<st c="67261">尽管安全性和灵活性并非天生是合作伙伴，但专注于关键安全需求而不阻碍创新的智能实现是为开发人员提供他们成功所需工具和他们所需保护的关键。</st> <st c="67522">保持安全。</st>

<st c="67532">请记住——安全事件的成本可能极其昂贵，甚至可能导致破产或诉讼。</st> <st c="67655">虽然日志存储和其他安全要求可能需要费用，但这些费用是可以管理的，并且永远不会比未能保护系统所带来的成本更高。</st> <st c="67804">关于如何管理平台成本的更多信息，我们继续阅读</st> *<st c="67876">第八章</st>*<st c="67885">。</st>
