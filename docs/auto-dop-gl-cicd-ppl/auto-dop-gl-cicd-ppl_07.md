

# 第七章：保护你的代码

现在你已经知道如何配置 GitLab CI/CD 管道，以验证项目代码是否满足其要求，构建管道的下一步是添加检查安全漏洞的任务。这是一个可选步骤，但由于 GitLab 使得将安全扫描添加到管道变得简单，而且除了增加几分钟的管道运行时间外几乎没有任何缺点，*我们建议你启用所有与* *项目相关的* 安全扫描器。

我们将从概述 GitLab 在使用安全扫描器方面的总体策略开始本章；在开始了解各个扫描器之前，理解安全扫描的几个方面是很有帮助的。接下来，我们将解释 GitLab 提供的七种安全测试类型的目的：**静态应用安全测试**（**SAST**）、**密钥检测**、**动态应用安全测试**（**DAST**）、**依赖扫描**、**容器扫描**、**许可证合规性**和**基础设施即代码**（**IaC**）**扫描**。我们将向你展示如何在管道中启用每种类型的扫描器，然后讨论一些配置选项和技术，你可以用来调整它们的行为，以最适合你的需求。最后，我们将介绍 GitLab 的三个附加功能，使安全扫描器更易用、更强大：阅读扫描报告、通过漏洞管理跟踪扫描结果，以及集成外部安全扫描器。

本章结束时，你将掌握一些关键技能，帮助你保持代码安全并保护数据安全。你将了解如何识别哪些 GitLab 提供的安全扫描器与项目相关。你将知道如何将它们添加到 CI/CD 管道中，并配置它们的行为以满足你的需求。你将牢牢掌握 GitLab 提供的不同类型的安全报告。你还将能够跟踪团队在修复安全漏洞方面的进展。最后，你将了解如何将第三方安全扫描器添加到管道中。简而言之，你会对自己的代码安全性充满信心。

本章将涵盖以下主题：

+   了解 GitLab 的安全扫描策略

+   使用 SAST 扫描源代码中的漏洞

+   使用密钥检测来查找存储库中的私人信息

+   使用 DAST 查找 Web 应用程序中的漏洞

+   使用依赖扫描来查找依赖项中的漏洞

+   使用容器扫描来查找 Docker 镜像中的漏洞

+   使用许可证合规性来管理依赖项的许可证

+   使用 IaC 扫描来查找基础设施配置文件中的问题

+   了解不同类型的安全报告

+   管理安全漏洞

+   集成外部安全扫描器

GitLab 对所有安全扫描器使用相同的一些配置技巧。为了避免重复，我们将在专门讨论第一个扫描器类型（SAST）的章节中详细讨论这些技巧。讨论其他扫描器的配置技巧时，我们会参考 SAST 章节。

在讨论扫描器配置时，重要的是要理解这些扫描器大多数提供 *许多* 配置选项，而在本书中讨论所有这些选项——甚至大多数选项——是不可能的。相反，我们会向你展示如何以一种相对简单的方式启动并运行每个扫描器，给你一个关于每个扫描器存在的配置选项的示例，并将你指向官方 GitLab 文档，作为每种扫描器类型配置设置的最新信息的最佳来源。幸运的是，关于这个主题的文档既清晰又全面。

最后，请注意，这些扫描器中的许多仅对拥有 GitLab Ultimate 许可证的用户可用。然而，GitLab 有将仅限 Ultimate 用户使用的扫描器在后续版本中提供给 Premium 或 Free 许可证用户的历史。截至撰写本文时，SAST、Secret Detection、容器扫描和基础设施即代码扫描对所有用户开放，无论其许可证级别如何，尽管有时这些功能会以功能受限（但仍然有用）的形式提供。因此，如果你发现自己喜欢的扫描器尚未对你的许可证开放，那么即使你没有升级许可证，它在未来可能会变得可用。

# 技术要求

和前几章一样，如果你拥有一个可以登录并用于实践和实验的 GitLab 实例账户（无论是自托管的还是 **软件即服务** (**SaaS**))，你会从本章中获得最大的收获。

# 了解 GitLab 的安全扫描策略

在学习每个扫描器的功能之前，有一些 GitLab 安全扫描器的基本原则你需要了解，这些原则会对你有所帮助。我们现在就来看看这些原则。

## GitLab 使用开源扫描器

你可能会感到惊讶，了解到本章讨论的所有安全扫描器都是 **第三方开源工具**；其中没有任何一个是 GitLab 内部开发的。例如，基础设施即代码扫描是由开源工具 **Keeping Infrastructure as Code Secure** (**KICS**) 执行的，依赖性扫描则由开源工具 **Gemnasium** 处理。

这并不意味着这些第三方扫描器在任何方面都比 GitLab 开发的软件差。它们都经过 GitLab 的严格研究和审查，才被采用为官方 GitLab 扫描器。此外，GitLab 还会定期审查新的开源安全扫描器，看看它们是否应当替代或补充现有产品的扫描器。因此，不用担心——这些扫描器都是你管道中的一流补充，尽管它们的代码不是由 GitLab 开发者编写的。

由专注于安全的组织或公司开发的安全扫描器，通常比那些由非专注于安全的公司开发的专有软件出现的漏洞更少。正如关于开源代码的说法：“*只要有足够多的眼睛，所有的漏洞都浅显易懂*。” 使漏洞变浅——然后修复它们——对于与安全相关的工具尤其重要：使用设计不良的安全扫描器，给你一个错误的印象，让你以为代码是安全的，比完全不了解产品安全更糟糕。

由于这些扫描器是开源软件，难道没有什么可以阻止你自己下载它们并独立于 GitLab 运行它们吗？没有！但很难理解为什么你会想这样做。GitLab 认证的扫描器非常容易集成到 GitLab CI/CD 管道中，而且 GitLab 会自动更新它们，以确保你的管道始终运行最新版本（除非你另行指定），而你无需采取任何行动。如果你已经在 GitLab 中设置了 CI/CD 管道，并且你的 GitLab 许可证级别允许你访问所需的扫描器，我们建议你在 GitLab 内使用这些工具，而不是独立运行它们。如果你自行下载并运行它们，你不会获得任何好处，反而会因为额外的系统管理和维护而失去不少。

GitLab 的安全扫描器支持哪些语言？

要查看每种类型的 GitLab 安全扫描器支持的所有语言的列表，以及所使用的开源工具的名称，请参阅官方 GitLab 文档（[`docs.gitlab.com/ee/user/application_security/sast/#supported-languages-and-frameworks`](https://docs.gitlab.com/ee/user/application_security/sast/#supported-languages-and-frameworks)）。请记住，这些细节会不时发生变化，因此建议定期重新查看文档，了解不同扫描器类型支持的新语言。

## 扫描器被打包为 Docker 镜像

当安全扫描器在 GitLab CI/CD 管道中运行时，它会在 Docker 容器内运行。对于大多数 GitLab 用户来说，这一点无关紧要，但有三个影响你应该知道。

第一点，因为运行扫描器的流水线任务需要拉取该扫描器的 Docker 镜像，所以这会增加任务运行时间大约一分钟左右。当然，具体的延迟取决于你的网络速度，以及镜像是否已经被缓存。这通常不是大问题，因为许多扫描器即使在其 Docker 镜像下载后，仍需要几分钟才能完成扫描。此外，大多数复杂的流水线任务是以分钟为单位运行的，而不是秒，所以你可能不会注意到因拉取安全扫描器 Docker 镜像而产生的短暂延迟。

第二，任何安全扫描任务必须在使用 Docker 或 Kubernetes 执行器的 GitLab Runner 上运行。如果你不确定这是什么意思，可以参考前一章节来回顾 GitLab Runner 执行器的相关内容。如果你的组织使用 GitLab 的 SaaS 版本（即你使用的是 `gitlab.com` 上的实例），那么这个问题已经为你解决：所有 SaaS 提供的 GitLab Runners 都使用这两种执行器之一。如果你使用的是自托管的 GitLab 实例，那么你可能有一个 GitLab 管理员负责设置你团队所需的所有 GitLab Runners。只需要确保他们明白，至少一些 Runner 必须使用 Docker 或 Kubernetes 执行器，如果你打算在流水线中添加安全扫描的话。

第三，因为你的任务每次运行时都会下载安全扫描器的 Docker 镜像，所以你无需担心更新安全扫描器。GitLab 会确保每个扫描器的最新版本包含在每次任务拉取的 Docker 镜像中。这意味着你少了一项需要跟踪的维护任务。

## 一些扫描器会为不同的编程语言使用不同的分析器。

一些扫描器，如 SAST 和依赖扫描，依赖于不同的开源工具来扫描用不同编程语言编写的代码。GitLab 称这些语言特定的工具为**分析器**。例如，当你在一个仅包含 Go 代码的项目中启用 SAST 时，GitLab 会运行一个开源的、支持 Go 的 SAST 分析器，名为**Semgrep**。但当你在一个基于 Ruby 的项目中启用 SAST 时，GitLab 会运行另一个名为**Brakeman**的开源分析器，它能够扫描 Ruby 代码。

你无需告诉 GitLab 运行哪些分析器——它会自动检测项目中的编程语言，并仅运行与这些语言兼容的分析器。GitLab 通过查找 `.py` 文件来推测项目包含 Python 代码，并为你启用的任何安全扫描器运行基于 Python 的分析器。它还会查找某些传统上与各种语言一起使用的配置文件，如 Ruby 项目中的 `Gemfile` 或 `Gemfile.lock`，Python 项目中的 `requirements.txt`，以及使用 Maven 构建工具的 Java 项目中的 `pom.xml`。大多数情况下，你不需要担心让 GitLab 容易检测到你的编程语言——它几乎能自动正确处理所有项目。但如果你发现 GitLab 无法正确识别语言，你可以在 GitLab 官方文档中查找每种安全扫描器类型的触发文件列表，并确保项目中每种语言至少有一个触发文件。

在同一个项目中使用多种编程语言是完全没问题的。GitLab 会检测项目仓库中的所有语言，并为每种语言运行相应的分析器，前提是该扫描器类型和语言都有可用的分析器。

对于某些扫描器类型和语言的组合，GitLab 提供了多个可用的分析器。在这种情况下，它会运行所有相关的分析器。例如，如果你在一个包含 Python 代码的项目上启用 SAST，它会同时运行 **Semgrep** 和 **Bandit** 分析器。如果这两个分析器检测到相同的问题，你可能会在扫描报告中看到重复的结果，每个分析器都有一条结果。虽然这可能会让报告稍显杂乱，但宁可多做一些也不愿疏漏任何问题。此外，由于每个开源分析器都是由不同的开发团队编写，具有不同的关注点或专注领域，并且不同的分析器在全面性或成熟度上有所不同，运行多个分析器是发现更多漏洞的好方法。

如果在运行针对特定语言的多个分析器时产生了过多的噪声，你可以配置大多数扫描器来禁用某些单独的分析器。例如，你可以告诉 GitLab 在对 Python 代码执行 SAST 扫描时，仅运行 Bandit 分析器，而不运行 Semgrep 分析器。然而，我们通常建议你保持尽可能多的分析器启用，以减少漏洞漏网的机会。对于不在项目中的语言，也没有必要禁用分析器：GitLab 足够智能，只会运行支持其检测到的语言的分析器。

并非所有针对特定扫描器类型的分析器都会发现相同的问题。例如，如果你在 Go 代码中有一个除以零的漏洞，而在 Ruby 代码中有相同的漏洞，其中一个分析器可能会将其报告为潜在问题，而另一个分析器可能会忽略它。同样，这是因为不同的开源分析器是由不同的开发团队编写和维护的。

## 漏洞不会阻止流水线继续运行

对于大多数 GitLab 作业，默认行为是当包含失败作业的阶段完成时，中止流水线。毕竟，如果你的测试在早期阶段失败，那么在后续阶段就没有必要部署代码。GitLab 的安全扫描器在某种程度上遵循这个标准……但也有不遵循的地方。让我们来解释一下这意味着什么。

每个成功运行的安全扫描器都会将其流水线作业标记为*通过*，无论它是否检测到任何漏洞。换句话说，看到安全扫描器的流水线作业状态为*通过*，只是意味着扫描器已完成运行——它并不告诉你扫描器是否发现了漏洞。因此，即使流水线中的扫描器在你的代码中发现了大量漏洞，它们的作业状态仍会被标记为*通过*，并且流水线会继续进入后续阶段。

这可能看起来不太符合直觉。检测到漏洞不就像自动化测试失败一样吗？嗯，是的，也不是。漏洞通常是团队应该仔细检查的内容，但正如你将在后面了解的，当我们讨论 GitLab 的漏洞管理功能时，你可能会决定不修复这个漏洞。GitLab 不想假设你会在将代码部署到生产环境之前修复所有漏洞，因此即使发现漏洞，流水线仍会继续运行。这种做法为开发团队提供了关于代码安全的所有信息，而不要求工具评估代码是否适合部署。

## 发现结果出现在三个不同的报告中

GitLab 的安全扫描器发现的任何漏洞或其他问题，都会出现在整合了所有不同扫描器结果的报告中。GitLab 界面中有三个这样的报告，分别位于不同的位置。每个报告显示的信息略有不同，理解每个报告的目的非常重要，这样你就不会误解结果。我们将在本章后面详细讨论这个话题，但现在，我们先简单介绍一下漏洞报告，你可以通过点击左侧导航栏中的**Security & Compliance**，然后点击**Vulnerability report**来查看。当我们在本章的其余部分讨论安全扫描器时，我们会展示每个扫描器的示例结果截图，它们会出现在漏洞报告中。

## 流水线可以使用非 GitLab 提供的扫描器

尽管 GitLab 内置的扫描工具可能为你提供所需的所有安全漏洞保护，但你仍然可以通过向管道中添加许多其他第三方扫描工具来补充安全测试。我们将在本章末尾的专门部分（*集成外部安全扫描器*）中讨论如何配置这种集成。

现在你已经理解了一些 GitLab 安全扫描器的基本概念，让我们来看一下每个扫描器，了解它们能够发现哪些问题以及如何使用它们。

# 使用 SAST 扫描源代码中的漏洞

让我们从**SAST**开始介绍扫描工具。*即使你不打算使用 SAST，也建议你仔细阅读本节内容*，因为使用 SAST 所涉及的许多原则和实践同样适用于其他扫描工具。了解如何使用 SAST 可以让你在启用、配置和解读其他扫描工具的结果时占得先机。

## 理解 SAST

SAST 查看的是项目的源代码，而不是在代码运行时与其交互。有时，这种方法被称为*白盒扫描*，意味着扫描器查看应用程序的*内部*以检查其代码，而不是待在应用程序*外部*仅分析其行为。

该扫描器会查找不良编码实践、反模式或设计不良、结构不佳的代码特征，这些有时被称为*代码异味*，可能会导致可被利用的安全问题。例如，考虑以下这一行 Python 代码：

```
temp_dir = '/tmp'
```

它看起来无害，但非 Python 程序员可能会惊讶地发现，它被认为是一个安全漏洞。Python 的最佳实践是使用语言内置的 `tempfile` 模块来创建和管理临时目录和文件。通过该模块创建的任何目录或文件在程序执行完毕后会自动删除，确保没有敏感数据被意外地留在计算机的文件系统中。创建用于存放临时文件的目录是危险的，因为很容易忘记在程序不再需要时删除该目录。这正是 SAST 设计用来检测的问题。

正如上一节所提到的，不同计算机语言的 SAST 分析器会寻找不同的安全漏洞。GitLab 针对其他语言的 SAST 分析器可能无法检测出该语言代码中的类似问题，这可能是因为该语言中的代码不被认为是漏洞，或者分析器的成熟度和稳定性不如 GitLab 的 Python SAST 分析器。

## 启用 SAST

有两种方法可以在 GitLab 项目的流水线中启用 SAST：手动启用或通过 GitLab GUI 启用。它们最终是一样的，因为它们都会导致向 `.gitlab-ci.yml` 文件中添加几行配置 CI/CD 流水线的内容。让我们来看一下这两种方法。

### 手动启用 SAST

要手动启用 SAST，你需要对项目的 `.gitlab-ci.yml` 文件进行两项操作：

+   确保流水线已经定义了 `test` 阶段

+   包含名为 `Security/SAST.gitlab-ci.yml` 的模板

代码如下所示：

```
stages:
  - test
include:
  - template: Security/SAST.gitlab-ci.yml
```

这些步骤中的第一步很简单，因为流水线通常在你必须添加安全扫描时，已经定义了 `test` 阶段。但如果你在添加任何其他测试相关的作业之前就要添加安全扫描，只需添加前面片段中的前两行。当然，如果你已经定义了其他阶段，在添加 `test` 阶段时不要删除它们——只需将 `test` 添加到现有的阶段中。

注意

请记住，列出阶段的顺序很重要，因为 GitLab 会按照这个顺序在流水线中执行它们。

第二步是将一个模板添加到你的 CI/CD 配置中。模板是 GitLab 提供的文件，包含定义新作业定义或添加其他功能的 CI/CD 代码。通过在你的 CI/CD 配置文件中包含一个模板，你可以添加执行任务（例如 SAST 扫描）的作业定义，而无需了解这些作业的工作原理。

在这种情况下，模板为每个 GitLab SAST 分析器添加了一个作业定义。它还添加了检测项目中存在哪些语言的逻辑，以便它知道要运行哪些与 SAST 相关的作业。如果你假设你的 `hats-for-cats` 项目仅包含 Python 代码，你会期望此模板在项目的流水线中运行两个新作业：一个是 Bandit，另一个是 Semgrep，它们是 GitLab 的两个 Python SAST 分析器。

结果果然如此，如果你将此更改提交到 `.gitlab-ci.yml` 文件，并查看由该提交触发的流水线的详细信息，你会看到这些作业现在已经包含在你的流水线中，位于 `test` 阶段下：

![图 7.1 – 流水线详细信息页面上的 Python SAST 作业](img/B18073_07_1.jpg)

图 7.1 – 流水线详细信息页面上的 Python SAST 作业

请记住，如果你的项目包含 Python 以外的其他语言的代码，你将在此页面上看到不同的作业名称，并可能会看到不同数量的作业。如果你的项目同时包含 Python 和其他语言的代码，你将看到每种语言的 SAST 分析器的作业。

### 通过 GitLab GUI 启用 SAST

奇怪的是，通过 GUI 向流水线添加 SAST 扫描比手动添加要复杂：

1.  通过导航到左侧面板中的 **安全与合规性** 选项，然后选择 **配置**，开始这个过程。这将引导你进入一个控制面板，用于启用和配置 GitLab 的大部分（但不是全部）安全扫描器。

1.  精确的 GUI 控件有时会随着 GitLab 版本更新而变化，但会有一个按钮让你启用 SAST。点击该按钮会带你到一个新的页面用于配置 SAST。

1.  通常，你可以将所有选项保持为默认值，然后点击底部的按钮来创建合并请求。这将带你到一个合并请求创建页面。

1.  再次提醒，你通常可以将所有字段保持为默认值，然后点击底部的按钮来创建合并请求。

1.  导航到合并请求并进行合并以完成过程。如果你的 `.gitlab-ci.yml` 文件之前没有包含 `test` 阶段，现在它应该包括该阶段，并包含前一节中描述的 SAST 模板。你可以看到，手动编辑该文件可能会更加简单！

一旦你通过 GUI 启用了 SAST，你应该会看到与手动启用 SAST 时相同的结果：每次运行管道时，将会添加两个新任务，分别对应 GitLab 支持的两个基于 Python 的分析器。

## 配置 SAST

现在，你已经知道如何将 SAST 添加到你的 GitLab 管道中。但如果你想改变 SAST 的默认行为怎么办？用于配置 SAST 的技术也适用于配置大多数其他安全扫描器。我们将在这里详细讨论这些技术，并在介绍其他扫描器时，直接参考本节，而不是重复这些信息。

配置 SAST 或其他任何安全扫描器的方式有三种：

+   在 `.gitlab-ci.yml` 中，设置全局变量

+   在 `.gitlab-ci.yml` 中，重写由你包含的模板原本添加的任务定义，并为该任务设置一个任务范围的变量。

+   使用 GitLab GUI

你使用哪种技术来配置 SAST 或其他扫描器，取决于你想要设置的配置选项。不幸的是，你无法选择使用哪种技术来设置特定的配置选项——你必须参考 GitLab 文档，查看你感兴趣的配置选项需要使用哪种技术或哪几种技术。

让我们看一些配置 SAST 的示例。

### 使用全局变量配置 SAST

首先，假设你想禁用 Python 的 Semgrep SAST 分析器。你可以通过在 `.gitlab-ci.yml` 中设置一个全局变量来做到这一点：

```
variables:
  SAST_EXCLUDED_ANALYZERS: "semgrep"
```

如果你将此变量添加到你的 CI/CD 配置文件中并重新运行管道，你会注意到在前面截图中看到的 `semgrep-sast` 任务现在已经消失了。

当然，如果你的 CI/CD 配置文件已经有 `variables` 部分，你应该将这个新变量添加到现有的变量中，而不是创建一个全新的 `variables` 部分。

### 通过重写任务定义并设置任务范围变量来配置 SAST

接下来，假设你希望 Bandit SAST 分析器不扫描某些目录，比如包含测试代码的目录。也许你知道你的测试中充满了安全漏洞，但你不在乎，因为客户永远不会使用这些代码。你可以通过编辑 `.gitlab-ci.yml` 来设置这个配置选项，以覆盖触发 Bandit 的作业定义，并在新的作业定义中设置一个作业范围的变量：

```
bandit-sast:
  variables:
    SAST_BANDIT_EXCLUDED_PATHS: "*/my_tests/*"
```

不要被变量的奇怪值吓到。这个特殊的变量期望一个使用稍微不同的 `fnmatch` 语法写成的值。这就是你在查阅 GitLab 文档以了解更多关于这个和其他扫描器的各种配置选项时学到的细节。

如果你将这段代码添加到你的 CI/CD 配置文件并重新运行管道，Bandit 分析器将停止报告在 `my_tests` 目录中发现的任何漏洞。我们还没有讨论如何查看这些分析器的结果，但别担心 —— 这些内容将在本章稍后部分介绍。

### 使用 GUI 配置 SAST

最后，你可以使用 GitLab 的 GUI 设置某些扫描器的配置选项。例如，在同一 GUI 页面上，你可以配置 SAST 使用来自其他 Docker 镜像的分析器、更改它运行的管道阶段，或更改它在检测项目中的语言时搜索的目录深度。如果你发现某些特定语言的 SAST 分析器没有帮助，或者生成的结果与其他分析器重复，你也可以在该 GUI 页面上禁用这些分析器。

与其他扫描器类型相比，SAST 提供了异常多的配置选项，可以通过图形用户界面（GUI）进行设置。GitLab 文档可以为你提供更多关于其他扫描器在 GUI 中可用选项的信息，以及哪些选项必须通过编辑 `.gitlab-ci.yml` 文件来设置。

## 查看 SAST 的发现

一旦启用了 SAST，并且可以选择进行配置，它将根据项目中检测到的语言运行相应的分析器，并在 GitLab 的三个安全报告中显示其结果。例如，这里是 GitLab **漏洞** **报告** 区域中描述的与临时目录相关的漏洞的发现：

![图 7.2 – SAST 发现](img/B18073_07_2.jpg)

图 7.2 – SAST 发现

这就是我们对 SAST 的总结。接下来，让我们讨论一个相关但独立的安全扫描器：秘密检测（Secret Detection）。

# 使用秘密检测在你的代码库中查找私人信息

你可以将秘密检测（Secret Detection）看作是 SAST（静态应用安全测试）的一种特殊、专注的版本，专门用于发现那些意外出现在源代码中的秘密，例如美国社会保障号码或 AWS 部署密钥。它的工作方式与 SAST 相同——也就是通过扫描源代码，而不是通过与正在运行的应用程序进行交互。

秘密检测曾经是 GitLab SAST 功能的一部分，但最终被单独分离出来，成为一个独立的一级安全扫描器。我们提到这一点是为了避免你在遇到旧文档或博客文章中的引用时感到困惑，因为这些资料可能会提到秘密检测是由 GitLab 的 SAST 扫描器执行的。

## 理解秘密检测

秘密检测会寻找各种各样的字符串，这些字符串代表了那些通常不应存储在 Git 仓库文件中的秘密。除了前面提到的社会保障号码和 AWS 部署密钥，下面是它寻找的 50 多种秘密中的一些：

+   短期和长期有效的 Dropbox API 令牌

+   GitLab 个人访问令牌

+   Heroku API 密钥

+   私有 SSH 密钥

+   Stripe 访问令牌

例如，秘密检测应该能找到并报告以下 Python 代码片段中包含的所有三个秘密：

```
MY_SSN = '123-45-6789'
MY_GITLAB_ACCESS_TOKEN = 'glpat-txQxy1frpAJodkxJYL8U'
MY_PRIVATE_SSH_KEY = '''
-----BEGIN OPENSSH PRIVATE KEY-----
b3BlbnNzbmUAAAAEbm9uZAwAAAAtzc2gt==
-----END OPENSSH PRIVATE KEY-----
'''
```

秘密检测基于**正则表达式**（或**regexes**）：扫描器为每种类型的字符串创建了一个正则表达式，用于检测并报告任何与这些正则表达式匹配的字符串字面量。

正则表达式的使用意味着秘密检测完全与编程语言无关。由于它只是扫描文件，看是否有任何字符串与正则表达式匹配，它并不关心你的仓库中使用的是哪种计算机语言。这意味着，与 SAST 不同，秘密检测不需要针对不同语言的单独分析器：它使用一个分析器来处理所有源代码文件。秘密检测甚至不依赖于文件类型：它可以扫描配置文件、README 文件、纯文本文件以及仓库中的任何其他非二进制文件。它可以像在 Go 源代码文件中查找字符串一样，轻松地在 JSON 配置文件中查找匹配正则表达式的字符串。

虽然正则表达式是一个强大的工具，但秘密检测依赖它们也意味着扫描器有一个重要的限制：它无法检测密码。这个限制一开始可能让人惊讶，但一旦你意识到一个设计良好的密码应该很难用正则表达式捕捉到，这就能理解了。很难设计一个能够捕捉任何可能的密码的正则表达式，而不会同时匹配到像文档中的一句话或图形用户界面元素中的一系列词语这样的非秘密文本。除了这个特定的情况，秘密检测在发现那些应该存储在比 Git 仓库更安全位置的字符串方面表现出色。

有一个极好的功能是 Secret Detection 是唯一提供的 GitLab 扫描器功能：**历史模式**。如果启用此模式，Secret Detection 将扫描您仓库中的所有提交，查看是否曾经有任何秘密被提交到其中。

为什么历史模式很重要？由于 Git 等版本控制系统的目标之一是允许您回到任何时刻文件的状态，因此即使秘密在下一个提交中被立即删除，也可以很容易地看到任何曾经被提交的秘密。一旦秘密进入 Git 仓库，它始终是可恢复的。因此，每当 Secret Detection 发现一个秘密时，它在任何安全扫描报告中创建的条目总是会提到该秘密不仅应该被删除，还应该被 *撤销*。任何进入 Git 仓库的秘密都应该被认为已经暴露给了全世界，应该不再使用。

这是一个非常重要的观点！如果 Secret Detection 找到一个密码，您应该立即停用该密码并设置一个新密码（当然，您不应该将新密码提交到 Git）。如果它检测到一个部署密钥，您应该取消该密钥并创建一个新的。这一原则适用于任何类型的秘密。如果 Secret Detection 发现了它，单纯从仓库中删除它是不够的。它应该被认为不再可用，并应尽快更换。

## 启用和配置 Secret Detection

由于 Secret Detection 以前是 SAST 的一部分，因此您可以使用相同的手动或基于 GUI 的方法来启用这两个扫描器，这一点并不令人惊讶。

要手动启用 Secret Detection，请确保在您的管道中定义了一个 `test` 阶段。然后，包含 GitLab 提供的模板，其中包含与 Secret Detection 相关的作业定义：

```
stages:
  - test
include:
  - template: Security/Secret-Detection.gitlab-ci.yml
```

就是这么简单！下次触发管道时，您会注意到一个 Secret Detection 作业现在在 `test` 阶段下运行。

要通过图形界面启用 Secret Detection，您可以使用与启用 SAST 相同的过程：点击 `.gitlab-ci.yml` 文件，包含之前描述的 Secret Detection 模板。如果您合并请求并触发新的管道运行，您会发现 Secret Detection 已经在您的管道中启用。与 SAST 一样，许多人发现这个过程比直接手动编辑 `.gitlab-ci.yml` 更繁琐，但您的体验可能有所不同。

与大多数 GitLab 安全扫描器一样，Secret Detection 有多个可配置选项。您可以在 GitLab 文档中了解所有选项及其设置方法，但这里有两个特别值得强调。

首先，您可能想要启用特定的 `test/` 目录，并将假的部署密钥存储在 `docs/` 目录中。您可能希望通过排除这些目录，防止 Secret Detection 将它们标记为安全漏洞。

您可以通过覆盖由秘密检测 CI/CD 模板提供的 `secret_detection` 作业定义，然后设置作业范围的变量来设置这两个配置选项。

```
secret_detection:
  variables:
    SECRET_DETECTION_HISTORIC_SCAN: "true"
    SECRET_DETECTION_EXCLUDED_PATHS: "tests,docs"
```

已配置并启用秘密检测，现在让我们查看其发现。

## 查看秘密检测的发现

一旦您根据喜好启用和配置了秘密检测，并且它在流水线中成功运行，您可以像在 SAST 结果中一样在**漏洞报告**区域看到结果。例如，这些是在之前提供的 Python 代码上运行秘密检测生成的结果：

![图 7.3 - 秘密检测发现](img/B18073_07_3.jpg)

图 7.3 - 秘密检测发现

现在您已经掌握了秘密检测，是时候看看 GitLab 兵器库中的下一个安全扫描器：DAST。

# 使用 DAST 查找 Web 应用程序中的漏洞

让我们继续下一个类型的安全扫描器：**DAST**。此扫描器与您的代码交互运行，而不是查看您的源代码。如果 SAST 和秘密检测是“白盒”测试的例子 - 它们查看您的应用程序内部的工作方式 - 那么 DAST 是“黑盒”测试的一种形式 - 它只发送输入并查找输出中的潜在问题或安全漏洞，而不知道您的应用程序如何执行输入到输出的转换。

## 理解 DAST

DAST 测试**Web 应用程序 URL**或**Web API 端点**。如果您向 DAST 提供网站主页的 URL，它将访问该页面，识别页面上的任何链接或可点击的 GUI 元素，跟随这些链接或点击这些元素，并重复此过程。它将继续执行此“爬行”过程，直到访问您的应用程序内可达到的每个页面。在每个步骤中，它检查 Web 应用程序返回的结果，以查看是否存在任何问题。以下是它寻找的问题类型的三个示例：

+   暴露私人个人信息

+   缺少跨站请求伪造令牌

+   通过查询字符串接受敏感信息，如密码

如果您告诉 DAST 扫描 Web API 端点，它会向端点发送信息并分析响应，寻找相同类型的问题。

无论是针对 URL 还是 Web API 端点，DAST 都可以在 **被动** 或 **主动** 模式下运行。每次 DAST 运行时，它都会执行被动扫描，这意味着它会发送类似真实用户请求的良性、无害的请求。如果你想对你的 Web 应用进行更深入的分析，可以启用所谓的 **完整扫描**，它会在通常发送的被动请求基础上添加主动攻击。这些主动攻击更具攻击性，如果它们被指向你不拥有的网站或 Web API，可能会被视为恶意攻击。然而，这些攻击非常宝贵，因为它们模拟了实际黑客可能使用的攻击类型，因此揭示了许多可能被恶意行为者利用的弱点。

## 启用和配置 DAST

DAST 提供了大量的配置选项。我们将介绍一些最常用的选项，这些足以帮助你快速开始使用 DAST。像往常一样，GitLab 官方文档提供了关于如何以非默认方式配置 DAST 的完整细节。

使用 GUI 启用和配置 DAST 是最简单的。这个过程的具体细节可能会在未来的 GitLab 版本中有所变化，因此我们将介绍高层次的概念，而不深入探讨具体的细节。

你可以通过访问你为 SAST 和秘密检测使用的相同安全扫描器配置页面来开始启用和配置 DAST：点击左侧导航栏中的 **安全性与合规性** 选项，并选择 **配置**。从那里，你将能够点击一个按钮来启用 DAST，尽管该按钮首先会将你引导到另一个页面，让你设置 DAST 需要通过的一些配置选项。

首先，你需要设置一个 **扫描器配置文件**。该配置文件告诉 DAST 是否只使用被动扫描，还是同时执行主动扫描。你还可以设置超时值，以限制 DAST 在爬取网站时的时间。GitLab 会让你为此配置文件命名，以便以后可以将同一个配置文件用于多个不同的 URL 或 Web API 目标。

其次，GitLab 会引导你创建一个 **站点配置文件**。该配置文件包含你想要扫描的网站首页或 Web API 端点的 URL。如果你扫描的是一个网站，你可以选择性地向站点配置文件添加身份验证凭据。这允许 DAST 像用户一样登录到网站，通常会暴露出更多需要扫描的 URL。

在你创建了这两个配置文件后，GUI 会呈现一个代码片段，你可以将其复制并粘贴到项目的 `.gitlab-ci.yml` 文件中。这与通过 GUI 启用 SAST 或秘密检测的合并请求驱动工作流稍有不同，但结果是一样的：你只需向 CI/CD 配置文件中添加几行代码，指示 DAST 在你的流水线中运行。

你可以通过 DAST 目标哪些 URL？

尽管你可以使用任何网站或 Web API 的 URL 创建站点配置文件，但我们强烈建议你仅针对自己拥有和管理的网站以及 API 端点进行扫描。如果你使用的是 DAST 的**全面扫描**选项，该选项会进行更具侵略性的扫描，尤其如此。此外，我们建议你仅在应用程序处于审查、暂存或预生产环境中时运行 DAST。将 DAST 用于生产版本的应用程序可能会导致其不稳定，降低真实用户的性能，甚至可能完全使其崩溃。

如果你更喜欢手动启用和配置 DAST，你需要在管道中`deploy`阶段*之后*添加一个`dast`阶段。你还必须包括 DAST 模板，设置一个包含你希望 DAST 扫描的 URL 的全局变量，并设置任何需要修改 DAST 行为的其他全局或作业范围的变量：

```
stages:
  - deploy
  - dast
include:
  - template: DAST.gitlab-ci.yml
variables:
  DAST_WEBSITE: https://example.com
  DAST_FULL_SCAN_ENABLED: "true"
```

你可能已经注意到，DAST 是我们遇到的第一个需要在专用阶段运行的扫描器。之所以如此，一旦你记住 DAST 扫描的是执行中的代码而不是源代码，这个原因就变得显而易见：它不能在代码构建和部署之前执行你的代码。这些任务通常发生在`build`和`deploy`阶段，因此 DAST 必须在这些阶段之后的一个阶段中进行。

由于 DAST 有时需要很长时间才能遍历网站的所有页面，而且你通常不希望在 DAST 执行时阻塞管道，因此 GitLab 还允许你按需运行 DAST 扫描或根据计划运行。触发按需扫描或创建扫描计划的过程非常简单：在左侧导航窗格的**安全与合规**选项中，选择**按需扫描**，然后让图形界面向导引导你完成整个过程。

如前所述，DAST 提供了种类繁多的可配置选项。这里无法一一列举，但到目前为止我们讨论的选项已经足够让你在大多数情况下获得有用的漏洞发现。如果你需要为蜘蛛过程设置超时值、禁用特定的漏洞检查、为目标网站设置登录凭证，或以其他方式调整 DAST 的行为，你可以在官方 GitLab 文档中找到所有需要的信息。

## 查看 DAST 的发现

DAST 扫描的结果会显示在**漏洞报告**区域，就像 SAST 和秘密检测的结果一样。由于我们没有完整的**Hats for Cats**应用可供运行 DAST，这里是运行 DAST 被动扫描 [`example.com`](https://example.com) 的一些示例结果。你可以看到，所有的结果都涉及标题字段，这是被动扫描最常见的发现类型：

![图 7.4 – DAST 发现](img/B18073_07_4.jpg)

图 7.4 – DAST 发现

这就是你对 DAST 的介绍。现在，让我们转换一下话题，研究一下依赖扫描，这是一个安全扫描类型，它检查你从外部来源导入到项目中的代码。

# 使用依赖扫描来发现依赖中的漏洞

为什么要自己编写函数，而别人已经编写、测试并文档化了一个库，可以完美地完成你所需的功能呢？通常，找到第三方的 Python 模块、Ruby gem、Java JAR 或其他开源软件包是很容易的，它们能加速项目的开发。不幸的是，这些第三方依赖可能包含安全漏洞，如果你将它们引入到项目中，你也会继承这些问题。GitLab 的依赖扫描功能就是在这个时候发挥作用——它确保你使用的任何依赖都是没有已知漏洞的。

## 理解依赖扫描

像 SAST 一样，依赖扫描支持许多语言——包括你期待的所有主流语言——但并不是所有语言都支持。你可以查阅 GitLab 文档，查看支持的语言的最新列表。

依赖扫描知道如何解析每种支持语言的包管理器所使用的配置文件，并利用这些信息来确定项目依赖哪些库。例如，它可能会扫描 Ruby 项目的 `Gemfile.lock`、Python 项目的 `requirements.txt` 或 `requirements.pip`，或者使用 Maven 构建工具的 Java 项目的 `pom.xml` 文件。正如你从我们提到的两个不同的 Python 配置文件中看到的那样，扫描器足够智能，知道某些语言使用多个文件来列出它们的配置，它可以解析每种语言中最常用的文件。就像 SAST 一样，依赖扫描能够处理包含多种不同计算机语言的项目。它会解析它检测到的任何语言的依赖配置文件，并在所有这些文件中寻找漏洞。

例如，如果你的网站 “Hats for Cats” 是建立在旧版本的 Django Web 框架上的，项目中可能会有一个 `requirements.txt` 文件，其中只有一行内容：

```
django==4.0
```

扫描器不仅会查找项目显式声明的依赖的名称和版本号，还会查找这些依赖的任何子依赖的名称和版本号。换句话说，它会递归地遍历依赖树，检测传递性依赖以及直接依赖。它会报告在依赖树中的*任何*依赖中发现的漏洞，这意味着你可能会看到一些你甚至不知道项目使用的依赖中存在的漏洞。

一旦依赖扫描知道了项目中每个依赖的名称和版本号，它会在数据库中查找每个依赖的名称和版本号，查看该版本的特定库是否存在已知漏洞。需要理解的是，依赖扫描并不会像 SAST 那样扫描依赖代码——也就是说，它不会分析依赖中的代码，试图发现新的漏洞。相反，它采用了一种更加直接的策略。它只是确定数据库中是否包含有关该版本依赖库中*已知漏洞*的信息。这听起来可能是一个不太复杂的方法，但事实证明它非常有用，并且在揭示常用库中存在的问题方面表现得相当出色。

依赖扫描有一个特殊功能，虽然并不总是可用，但在可用时可以节省不少时间。如果扫描器检测到库的旧版本中存在漏洞，并且知道该漏洞在同一库的后续版本中已被修复，它有时会提供创建一个合并请求的选项，重新编写项目的依赖配置文件，使其使用后续版本的已修复库。这只在某些情况下和某些语言中发生，但在提供此选项时，值得利用。

## 启用和配置依赖扫描

您可以像在 SAST、Secret Detection 或 DAST 中那样，通过图形界面或手动方式将依赖扫描添加到项目的流水线中。通过图形界面启用它，只需点击`.gitlab-ci.yml`文件，该文件启用扫描器。合并合并请求，操作完成。

手动启用更为简单。只需确保您的流水线已定义`test`阶段，并将依赖扫描模板添加到`.gitlab-ci.yml`中：

```
stages:
  - test
include:
  - template: Security/Dependency-Scanning.gitlab-ci.yml
```

与其他扫描器一样，依赖扫描有多个可配置选项。同样，像其他扫描器一样，这些选项可以通过在`.gitlab-ci.yml`中设置全局变量，或通过重写作业定义并在该文件中设置作业范围的变量来控制。

例如，以下代码设置了一个作业范围的变量，告诉依赖扫描的 Python 分析器查找一个非标准名称的依赖配置文件，而不是传统的`requirements.txt`文件：

```
gemnasium-python-dependency_scanning:
  variables:
    PIP_REQUIREMENTS_FILE: "hats-for-cats-requirements.txt"
```

## 查看依赖扫描结果

漏洞报告显示了在项目依赖中检测到的任何潜在安全问题。例如，以下是来自《Hats for Cats》项目中依赖于旧版本 Django 库的五个关键和高严重性的漏洞，正如示例中的`requirements.txt`文件所指定的那样：

![图 7.5 – 依赖扫描发现](img/B18073_07_5.jpg)

图 7.5 – 依赖扫描发现

到现在为止，你应该已经牢牢掌握了依赖扫描的功能和使用方法。接下来，我们来看看一个以 Docker 为中心的安全扫描工具：容器扫描。

# 使用容器扫描查找 Docker 镜像中的漏洞

容器扫描对 Docker 镜像的作用类似于依赖扫描对项目依赖的作用：它检查你的项目在构建 Docker 镜像时使用的特定版本的 Linux 发行版中已知的漏洞。

## 理解容器扫描

如果你将应用程序打包并部署为 Docker 镜像——或者更严格地说，是一个符合开放容器倡议（OCI）标准的镜像——你应该使用 GitLab 的容器扫描功能来查找镜像构建所基于的基础 Linux 发行版中的已知漏洞。

如果你之前没有使用过 Docker 镜像，这听起来可能有些神秘，但其实并不复杂。可以把 Docker 镜像想象成类似于虚拟机的东西。它有一个特殊的文件叫做`Dockerfile`，它作为创建该虚拟机的“配方”。这个`Dockerfile`文件指定了使用哪个 Linux 发行版作为虚拟机的操作系统，应该在 Linux 上安装哪些额外的软件包来支持你的应用程序，以及最终要在虚拟机上安装的应用程序是什么。操作系统、依赖项和你的应用程序组成了整个 Docker 镜像。

容器扫描会寻找漏洞，既包括在基础 Linux 操作系统中默认安装的软件包，也包括你在`Dockerfile`中指定的任何额外软件包。正如你所料，Linux 发行版越旧，安装的依赖越多，容器扫描可能发现的问题就越多。

尽管容器扫描不能找到所有 Linux 发行版的所有版本中的漏洞包，但它支持最常用的发行版的最后两个或三个版本。除非你使用了一个非常特殊的发行版作为应用程序 Docker 镜像的基础，否则应该能够使用容器扫描。如果你想确保你的镜像是可以扫描的，GitLab 文档中有一个支持的发行版列表。

容器扫描有一个默认禁用的可选功能：它还可以查找“语言包”中的漏洞，语言包是由语言的包管理器添加的库。例如，你可能使用 Ruby 的`bundler`工具安装`Ruby on Rails` gem，或者使用 Python 的`pip`工具安装`Flask`模块。你可能会注意到，这个功能与 GitLab 的依赖扫描功能覆盖了相同的领域——因此，通常会产生重复的结果。因为这个原因，许多 GitLab 用户更倾向于使用依赖扫描，而不是启用容器扫描中的这个功能。

尽管容器扫描可以查找任何它能够通过网络访问的 Docker 镜像中的问题，但其默认行为是扫描在你项目的**容器注册表**中找到的任何镜像。容器注册表是 GitLab 项目提供的一项功能，允许你将 Docker 镜像存储在一个安全的、受访问控制的位置，而不是存储在像 Docker Hub 这样的公开站点，或像 Artifactory 这样的工具实例中。要使用容器扫描检查容器注册表中的镜像，你需要让你的管道构建一个 Docker 镜像并将其推送到注册表。我们将在下一章讨论有关部署策略的内容。

## 启用和配置容器扫描

你可以通过手动编辑 `.gitlab-ci.yml` 或使用 GitLab 图形界面来启用容器扫描。若手动启用，确保你的管道包含一个 `test` 阶段，并添加容器扫描模板：

```
stages:
  - test
include:
  - template: Security/Container-Scanning.gitlab-ci.yml
```

要使用图形界面配置容器扫描，你可以使用与目前为止讨论的其他扫描器相同的技术：点击左侧导航栏中的**安全与合规**选项，选择**配置**，然后找到启用容器扫描的控件。这样会生成一个合并请求（MR），将前述模板添加到你的 CI/CD 配置文件中。合并这个 MR 后，你就完成了。

如果你希望容器扫描检查项目的容器注册表中的 Docker 镜像，那么这些手动或图形界面启用扫描器的方法就是你需要执行的唯一步骤。但是，如果你需要更改其默认行为，你可以使用你已用于配置其他扫描器的两种方法：设置全局变量或覆盖作业定义并设置作业作用域变量。此扫描器的一些可配置选项包括将扫描器指向存储在你项目容器注册表以外位置的 Docker 镜像、启用语言包扫描，或设置漏洞必须具备的最低严重性级别，才能包含在容器扫描的结果中。

## 查看容器扫描的结果

在你构建的 Docker 镜像中，容器扫描发现数十个漏洞并不罕见，尤其是当你使用的基础镜像是较旧的 Linux 发行版时。考虑到每个 Linux 发行版默认安装的大量软件包，以及在开源软件包中发现漏洞的速度，这并不令人惊讶。

例如，Alpine Linux 作为一个小巧的主要发行版而著名，这意味着它安装的包比其他流行发行版（如 Ubuntu 或 Debian）少。这使得它成为 Docker 镜像的基础发行版之一。如果您基于 Alpine Linux 版本 3.14.1（在撰写本文时仅有 10 个月的历史）构建 Docker 镜像，容器扫描会发现其默认包中至少有 30 个漏洞。您可以看到在基于该发行版构建的 Docker 镜像中发现的一些最高严重性漏洞，如**漏洞** **报告**区域所显示：

![图 7.6 – 容器扫描结果](img/B18073_07_6.jpg)

图 7.6 – 容器扫描结果

现在我们已经介绍了容器扫描的基础知识，让我们来看看另一个安全扫描工具：许可证合规性。

# 使用许可证合规性来管理依赖项的许可证

很容易忽视项目中各种依赖项所使用的软件许可证，也容易忘记哪些许可证与项目的总体许可证兼容，哪些许可证因各种原因应被排除在外。在这方面，GitLab 的许可证合规性功能可以提供帮助。

## 理解许可证合规性

大多数开源库都发布在某种软件许可证下。虽然有数百种许可证可供选择，但通常只有大约 20 种常用许可证，而且每种许可证的法律细节差异较大。如果在项目中使用了第三方库，必须确保该库的许可证与您打算发布软件的许可证兼容。如果它们不兼容，您必须将该依赖项替换为使用更友好许可证的替代库。

当我们谈论许可证时，什么是“兼容”的意思？大多数许可证被认为是**宽松的**，这意味着您可以几乎出于任何目的使用该许可证下发布的软件。两种广为人知的宽松许可证例子是 MIT 许可证和 BSD 许可证。如果您使用的是宽松许可证的依赖项，通常不会遇到兼容性问题。其他许可证则是**保护性的**，而非宽松的，这意味着它们限制了您如何使用根据这些许可证发布的软件。以下是保护性许可证所施加的一些限制示例：

+   一些开源许可证，如 GPL 或 AGPL，属于一种非正式的类别，通常称为**反向版权**。根据这些许可证发布的软件可以作为依赖项在其他项目中使用，但前提是这些其他项目本身也必须使用相同的反向版权许可证。例如，如果您的《猫帽子》应用使用了一个基于 GPL 许可证发布的开源 Python 排序库，那么*整个《猫帽子》项目也必须使用 GPL 许可证*。如果您打算销售软件而不是将其作为开源发布，这可能会成为一个问题。

使用一些更具争议性的术语，copyleft（版权左）许可证有时被称为“病毒性”许可证，因为它们可以被认为是“感染”父项目。这个疾病隐喻可能不公平，许多优秀的软件都是通过 copyleft 许可证发布的，但事实依然是，你需要小心使用这些许可证。

+   一些许可证明确*禁止某些行业使用*，比如军事行业。例如，基于军事排除许可证发布的代码不能作为导弹制导软件的依赖项使用。

+   一些许可证可能*排除某些国家/地区使用该软件*。这种情况并不常见，但许可证包含此类限制是合法的。

如你所见，理解你的项目依赖项使用的许可证非常重要，这样你就可以意识到这些许可证可能带来的任何限制，并且避免使用那些发布在限制你以预期方式使用或销售软件的许可证下的依赖项。

GitLab 的 License Compliance 功能分为三个阶段：

+   扫描器会查看项目的依赖项，并生成所有使用的许可证的列表。

+   软件开发团队或公司法务部门会创建**许可证政策**，明确允许或拒绝项目依赖项中找到的每个许可证。或者，如果你已经知道哪些许可证与你的主项目的整体许可证不兼容，可以在添加任何依赖项之前预先创建许可证政策。

+   如果开发者在分支上引入了一个新的依赖项，而该依赖项使用了一个被拒绝的许可证，那么 License Compliance 功能会阻止该分支的合并请求，直到移除许可证或解除阻止。

从这个工作流中，你可以看出，创建许可证政策是使用 License Compliance 功能的重要部分。要查看、创建、删除或编辑许可证政策，请点击左侧导航窗格中的**安全与合规性**，然后点击**许可证合规性**。以下是当你批准了两个许可证并拒绝了两个其他许可证时，该屏幕的显示效果：

![图 7.7 – 许可证政策](img/B18073_07_7.jpg)

图 7.7 – 许可证政策

工作流描述提到，License Compliance（许可证合规性）具有阻止任何引入依赖项且使用被许可证政策明确拒绝的许可证的合并请求（MR）的能力。为了阻止 MR，License Compliance 会停用或隐藏**合并**按钮，使其无法点击。以下是一个被阻止的 MR，显示了在 MR 分支上引入的新依赖项（及其依赖项）所使用的许可证列表：

![图 7.8 – 被拒绝许可证阻止的合并请求](img/B18073_07_8.jpg)

图 7.8 – 被拒绝许可证阻止的合并请求

### 使用 GitLab 规则集解除 MR 阻止

除了您刚刚看到的情况，GitLab 还有几个其他触发器，导致合并请求（MR）被阻止，直到采取某种纠正措施为止。举一个例子，当开发者编写新产品代码时，如果没有为该代码编写自动化测试，GitLab 可以配置为注意到开发者分支上的“代码覆盖率”下降，并且该分支的 MR 会被阻止，直到开发者添加自动化测试来测试他们的新代码。

任何被自动阻止的 MR 都可以通过 GitLab 的 **审批规则** 功能解锁。这些规则允许特定人员仅通过**批准**该 MR 来解锁。每个审批规则都有一个名称；允许您覆盖由被拒绝许可证引起的阻止的规则称为 **License-Check**。我们没有足够的篇幅在这里详细介绍审批规则，但它们的设置和使用非常简单。GitLab 文档可以为您提供更多细节。

## 启用和配置许可证合规性

您无法使用 GUI 启用许可证合规性，但启用它的手动方法现在应该很熟悉了。只需确保在您的流水线中定义了 `test` 阶段，并包含许可证合规性模板：

```
stages:
  - test
include:
  - template: Security/License-Scanning.gitlab-ci.yml
```

配置许可证合规性可以像配置其他扫描工具一样完成：编辑 `.gitlab-ci.yml` 文件，设置全局变量或覆盖作业定义并设置作业范围的变量。

如前所述，配置许可证合规性的重要部分是创建许可证政策，规定哪些开源许可证可以或不可以用于项目的依赖项。要创建或编辑这些政策，请导航到左侧导航窗格中的**安全与合规性**选项，点击**许可证合规性**，然后点击**政策**标签。在那里，您可以添加政策来允许或拒绝 GitLab 识别的数百种许可证中的任何一种。无论项目是否包含这些许可证的依赖项，您都可以为许可证创建政策。在项目开发开始之前，您的法务团队可能需要为任何被拒绝的许可证创建政策，这样如果合并请求引入了使用被拒绝许可证的依赖项，就会立即被阻止。

编辑许可证政策的先决条件

GitLab 并没有很好地记录这部分内容，但要添加、删除或编辑许可证政策，您必须首先运行至少一个包含许可证扫描作业的流水线实例。这样做会“解锁”允许和拒绝的许可证列表，并允许您编辑政策。

## 查看许可证合规性的发现

与我们迄今为止查看的其他扫描工具不同，许可证合规性不会在 **漏洞报告** 窗口中显示其发现的内容。要查看它在*项目默认分支的依赖项*中识别出的许可证，点击左侧导航窗格中的**安全与合规性**选项，然后点击**许可证合规性**。

要查看*依赖项在功能或 bug 修复分支上的许可证*，请导航到该分支上运行的流水线详情页并点击 **Licenses** 标签。此视图还会显示哪些许可证是允许的，哪些是被拒绝的，哪些尚未分类。

现在你已经具备了将许可证合规性应用于项目的能力。是时候处理 GitLab 提供的最后一个安全扫描工具：基础设施即代码扫描（IaC）。

# 使用 IaC 扫描来查找基础设施配置文件中的问题

在过去十年左右，“把硬件当作牲畜，而非宠物”这句话被用来描述一种新的计算机管理方法。通过将硬件视为一种可替代的商品，而不是一堆特殊的“雪花”计算机，开发和运维团队可以摆脱仔细配置和维护用于托管部署环境、运行数据库、提供 Web 应用或进行软件开发与部署中涉及的其他无数任务的计算机的困扰。通过使用像 Ansible 或 Terraform 这样的 IaC 工具来配置和维护硬件（无论是实际的还是虚拟的，本地的还是基于云的）上的配置状态，系统管理员可以调整服务器容量、创建新环境或实验硬件配置，而无需担心如果出现问题或实验失败，恢复系统的难度。要恢复正常，他们只需抹掉旧机器，并使用已经证明有效的设置通过 IaC 工具自动重新配置这些机器。这样为开发团队节省的时间和获得的自由是巨大的。

但这种新自由带来了新的漏洞类型。很容易创建会导致安全漏洞的 IaC 工具配置文件，这些漏洞会影响使用这些文件配置的机器。GitLab 的 IaC 扫描工具正是用来发现这种类型的漏洞。一旦识别出这些漏洞，团队可以在配置文件中修复它们，然后轻松地重新配置机器，使用更新且更安全的设置。

## 理解 IaC 扫描

GitLab 的 IaC 扫描是一种专门的 SAST 形式。它会浏览项目的仓库，查看是否能找到任何来自支持的 IaC 工具的配置文件（GitLab 文档可以为你提供这个扫描工具支持的 IaC 工具的最新列表）。然后，它会识别这些配置文件中的漏洞或不良编程实践。

下面是一个简单的 Terraform 配置文件，用于创建一个 S3 存储桶：

```
resource "aws_s3_bucket" "testBucket" {
    bucket = "myBucket"
    acl = "authenticatedRead"
}
```

这段代码看起来足够简单，但它引入了几个安全漏洞，并未遵循 Terraform 配置文件的一些最佳实践，正如你将在本章后面的 IaC 扫描报告中看到的那样。

## 启用和配置 IaC 扫描

与许多其他扫描器一样，你可以通过 GUI 或手动编辑 `.gitlab-ci.yml` 来启用 IaC 扫描。要通过 GitLab GUI 启用，可以使用你启用其他扫描器时相同的技巧：在左侧导航栏的 **安全与合规** 选项下，点击 **配置**，告诉 GUI 创建合并请求并合并该请求。

要手动启用 IaC 扫描，如果项目的管道中尚未包含 `test` 阶段，请添加一个，并包含扫描器模板：

```
stages:
  - test
include:
  - template: SAST-IaC.latest.gitlab-ci.yml
```

当前，IaC 扫描并不提供任何配置选项，但未来可能会提供。

## 查看 IaC 扫描的结果

前面展示的用于创建 S3 桶的 Terraform 配置在短短几行代码中就包含了不少问题。存在一些安全漏洞以及在创建 S3 资源时没有遵循最佳实践。漏洞报告中展示的发现对帮助你了解需要在哪里加强 Terraform 代码，消除这些问题非常有价值：

![图 7.9 – IaC 扫描结果](img/B18073_07_9.jpg)

图 7.9 – IaC 扫描结果

通过查看漏洞报告中**工具**栏的发现，你会看到所有 IaC 扫描的发现都列为来自 SAST，而不是 IaC 扫描器。这是因为 IaC 扫描器在 GitLab 中被归类为 SAST 工具组的一部分。要在漏洞报告中仅查看 IaC 发现，你需要在**工具**下拉菜单中选择 **SAST**——即使这样，你仍然会看到来自 SAST 工具以及任何你已集成到 SAST 工具组中的第三方扫描器的发现。

这就结束了我们对 GitLab 七大安全扫描器的概览。接下来，让我们讨论 GitLab 提供的两个功能，这些功能能让其安全扫描器更易于使用、更强大：报告和漏洞管理。

# 理解不同类型的安全报告

所有 GitLab 安全扫描器都会将其结果显示在三个独立的报告中。因为每个报告都显示了所有扫描器的结果，所以无需在 GitLab GUI 中来回跳转，收集来自不同扫描器的信息。然而，这三个报告位置展示的扫描结果略有不同。了解这三份报告的区别非常重要，下面我们逐一了解：

+   `main` 或 `master`。如果你想了解你稳定代码库的安全性，请查看漏洞报告。它不会告诉你任何关于功能或 bugfix 分支的安全状态——仅仅是默认分支的情况。

+   每个运行的流水线的**流水线详细信息页面**会告诉你该流水线运行所在分支上存在的安全问题。因此，如果流水线运行在默认分支上，它的流水线详细信息页面将包含与漏洞报告相同的信息。但对于运行在功能或 bug 修复分支上的流水线，其流水线详细信息页面会提醒你该分支上存在的漏洞，无论它们是否也存在于默认分支上。如果启用了许可证合规性并且检测到具有许可证的依赖项，该页面将显示一个名为**许可证**的标签；如果该页面有其他扫描器的检测结果，它将显示一个名为**安全性**的标签。流水线详细信息页面上显示的信息类型与漏洞报告中显示的相同，尽管格式稍有不同。

+   每个**合并请求**都会显示来自最近一次运行于 MR 源分支的流水线的扫描结果。然而，MR 报告与漏洞报告和流水线详细信息报告有一个重要区别：MR 报告只显示最近一次在 MR 源分支上运行的流水线所发现的漏洞与 MR 目标分支上漏洞之间的*差异*。换句话说，它显示的是差异视图，而不是该分支上所有漏洞的完整列表。

让我们通过一个示例来说明这三种报告之间的区别：

1.  假设 Hats for Cats 的`main`分支上有一个 SAST 漏洞和一个被 Secret Detection 发现的问题。

1.  开发人员从`main`分支创建了一个名为`make-hats-sortable`的分支。

1.  遵循 GitLab Flow 的最佳实践，开发人员创建了一个 MR，`make-hats-sortable`作为源分支，`main`作为目标分支。

1.  开发人员向`make-hats-sortable`分支提交了代码。假设此次提交修复了 SAST 漏洞，但引入了一个新的 DAST 漏洞。

以下是目前每个报告所显示的内容：

+   `main` 分支。

+   `make-hats-sortable`分支（即合并请求的源分支）仅显示 Secret Detection 和 DAST 发现的漏洞，因为 SAST 漏洞已在该分支上修复。

+   `make-hats-sortable`和`main`分支。

这就是我们关于不同类型 GitLab 安全报告的讨论。阅读这些报告并了解你的安全漏洞所在之后，如何追踪解决这些漏洞的进展呢？这是下一个章节的主题。

# 管理安全漏洞

每当除许可证合规性之外的任何扫描器发现漏洞时，它会将该漏洞标记为**需要分类**状态。此状态会出现在漏洞报告中的漏洞条目和流水线详细信息页面报告中。

你应当决定对每个具有该状态的漏洞打算如何处理，并相应地更改其状态。以下是可能的状态值：

+   **已忽略**表示你不打算修复这个漏洞。也许你已经确定这是一个误报，或者你认为这是一个真实的问题，但不值得修复，或者你意识到这个漏洞与你的产品或用户无关。

+   **已确认**表示这是一个真实的问题，并且你确实打算修复它。在将问题设置为此状态后，你通常会创建一个问题来跟踪进展，以便团队在修复漏洞时进行追踪。GitLab 在报告的图形界面中提供了一些快捷方式，甚至会自动填充问题的标题和描述，从发现中提取信息，以便尽可能简化修复过程。

+   **已解决**意味着你已经修复了该问题，因此它不再出现在你的项目中。此状态需要手动设置。*GitLab 不会自动解决漏洞*。这是因为它不希望不小心解决仍然存在的问题，从而给你带来虚假的安全感。

GitLab 的漏洞管理功能基本上就是设置漏洞的状态，然后可选地使用 GitLab 问题来跟踪修复该漏洞的进展。一个典型的漏洞管理工作流可能是这样的：

1.  扫描器报告一个漏洞，将其状态设置为**需要** **处理**。

1.  开发团队评估漏洞并决定不修复它，这时你将其状态设置为**已忽略**，并停止流程。

或者，团队对漏洞进行优先级评估，决定它确实需要修复，在这种情况下，你可以将其状态设置为**已确认**。

1.  可选择创建一个包含漏洞信息以及可能的修复指南的问题。这个问题会像其他问题一样被讨论、添加到冲刺中并分配给开发者。

1.  分配给该问题的开发者创建一个分支，为该分支创建一个合并请求，并在该分支上修复问题。

1.  合并请求的“增量”安全报告显示该问题存在于默认分支中，但在开发者的分支中不再存在。

1.  你的团队合并了合并请求。漏洞现在在默认分支中已得到修复。

1.  你关闭该问题。

1.  在漏洞报告中，你必须将漏洞的状态设置为**已解决**。

当你看到这个过程按步骤展示时，可能会觉得有些繁琐，但大多数人很快会习惯这种流程，并开始欣赏它给项目的安全状态提供的可见性。

现在，你知道如何跟踪团队修复代码中的安全漏洞。该章节的最后一个话题是：使用 GitLab 提供以外的安全扫描器。

# 集成外部安全扫描器

许多团队致力于使用一个或多个不属于 GitLab 安全产品的安全扫描器。别担心——通常可以将外部扫描器集成到您的 GitLab CI/CD 管道中。

集成分为两个部分。首先，您需要告诉您的管道触发外部扫描器。这很简单，只要您的扫描器以 Docker 镜像的形式打包，并且可以通过命令行运行：

1.  在`test`阶段创建一个新的管道作业（除非有理由在其他地方运行它）。

1.  在作业定义中使用`images`关键字来指定包含您希望添加到管道中的扫描器的 Docker 镜像的位置。

1.  在作业定义的`script`部分，使用您手动运行扫描器时所使用的 CLI 命令来触发扫描器。您可能需要传递一些选项给 CLI 命令，以控制它生成结果文件的位置以及使用什么格式。

1.  在您的作业定义中添加`allow_failure: true`，这样即使外部扫描器发现漏洞，管道仍然会继续运行。

集成外部扫描器的第二部分是告诉 GitLab 如何将扫描器的结果包含到我们在本章讨论的三个标准 GitLab 安全报告中。如果结果文件写入 JSON 文件，并符合特定的 JSON 模式，GitLab 才能将这些结果整合进去。每种扫描器类型（SAST、DAST 等）都有一个单独的模式。每种扫描器类型的文档提供了有关这些模式的更多信息。

集成生成非标准结果文件的第三方扫描器

如果您的第三方扫描器无法生成与适当模式验证的结果文件，您需要编写一个简短的脚本来解析结果并创建一个符合模式的新结果文件。您需要在扫描器运行后在管道中的某个地方触发此脚本。

在您为第三方扫描器创建的作业定义中，您必须声明扫描器的结果文件为一个工件，特别是包含某种类型安全报告结果的工件。例如，如果您正在集成一个额外的 SAST 扫描器，并且它生成名为`my_scanner/results.json`的结果文件，您需要在运行该扫描器的作业定义中包含以下代码：

```
  artifacts:
    reports:
      sast: my_scanner/results.json
```

这个高级别的描述可能是您集成第三方扫描器所需要的全部内容，但如果您需要更详细的配置说明——包括有关结果模式的指导、命名管道作业和结果文件的最佳实践等——GitLab 官方文档有一篇非常详尽的页面专门介绍这个话题。

# 总结

安全是本书中最复杂且最重要的话题之一，因此恭喜您完成了这一部分！让我们回顾一下本章所学内容。

首先，我们介绍了所有 GitLab 安全扫描器的基本原理。我们讨论了所有扫描器都是由 GitLab 外部开发的开源工具，以及这一点为什么是好事。我们看到一些扫描器使用不同的分析器来支持不同的计算机语言，尽管所有扫描器都支持最常用的语言，有些扫描器则完全不依赖语言。我们了解了将扫描器打包为 Docker 镜像的含义。我们看到扫描器在发现漏洞时不会停止 CI/CD 流水线，我们还了解到，如果 GitLab 提供的扫描器不足以满足需求，通常可以将外部扫描器集成到流水线中。

然后，我们逐一了解了 GitLab 安全扫描器的功能，学习了每个扫描器查找的漏洞类型，如何通过 GUI 或手动启用它们，如何配置它们的行为，以及如何查看它们的发现结果。我们看到如下内容：

+   静态应用安全测试（SAST）查找源代码中的漏洞

+   秘密检测（Secret Detection）查找不应存储在 Git 仓库中的敏感信息

+   DAST（动态应用安全测试）发现运行中的 Web 应用或 Web API 中的漏洞

+   依赖项扫描（Dependency Scanning）发现你项目中第三方库的已知漏洞

+   容器扫描（Container Scanning）发现构成你 Docker 镜像基础的 Linux 发行版中的已知问题

+   许可证合规（License Compliance）识别与整体项目许可证不兼容的依赖项

+   基础设施即代码扫描（IaC Scanning）查找可能会将漏洞引入你管理的计算机的基础设施配置文件

最后，我们探讨了与扫描器本身相关的三个话题：GitLab 提供的三种不同安全报告之间的区别、管理扫描器识别出的安全漏洞，以及将外部扫描器集成到你的流水线中，以便为需要更多保护的项目提供帮助。

不幸的是，安全问题已经成为软件开发中一个庞大且重要的部分。但正如我们在本章中所看到的，GitLab 提供的一整套检测和修复安全漏洞的工具是其最强大、最有价值的功能之一。我们可以稍微松一口气，因为现在很多潜在问题可以在开发过程早期被识别出来，这时仍然有足够的时间在生产环境中出现尴尬、昂贵或损害声誉的安全漏洞之前解决它们。

到此为止，你的代码已经编写完成、验证无误并且得到了安全保障。软件开发生命周期的下一步是打包和部署它。我们将在下一章中处理这些任务。
