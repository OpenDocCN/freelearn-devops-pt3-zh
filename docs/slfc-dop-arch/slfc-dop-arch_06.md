

# 探索打包

有许多方法可以在不同环境之间传递 Salesforce 更改，同时遵循 DevOps 原则。使用 Salesforce 包是其中一种流行的机制，包可以是托管的、非托管的或解锁的包。

在本章中，我们将讨论这三种类型的 Salesforce 包，它们的使用场景以及相关注意事项：

+   **非托管包** – 用于与其他组织或用户共享自定义或应用程序，但没有内建的版本控制或升级功能。

+   **解锁包** – 旨在实现高效的应用生命周期管理、模块化开发和单一组织中的版本控制。它们也是在 Salesforce 平台上分发开源解决方案的流行方式。

+   **托管包** – 旨在将基于 Salesforce 平台构建的自定义应用程序、扩展或集成分发给多个组织或客户，提供对构建代码的保护、版本控制和可升级性。

本章结束时，您不仅会清楚了解这些不同类型包之间的区别，还能明白何时使用它们以及如何在 Salesforce 中构建它们。

# 技术要求

对于非托管包、解锁包和 2GP 托管包，除了 Salesforce 环境外不应该有其他额外的要求——理想情况下是使用**沙盒**或**开发者**版。

对于 1GP 托管包，您在开发要分发的托管包时，需要一个独立的打包组织。打包组织是一个独立的 Salesforce 组织，用于开发、打包和分发托管包。

对于 Salesforce ISV 合作伙伴来说，通常会使用**合作伙伴开发者版**组织，它相较于普通开发者版组织，具有更多功能和更高的限制。这些包适用于 Salesforce 注册合作伙伴，而不是大多数 Salesforce 客户的日常使用。

用于测试包命令的示例项目可在与本书关联的 GitHub 仓库的 `Chapter6` 文件夹中找到。

# 非托管包

非托管包是 Salesforce 最初实现打包的一部分，因此也属于现在所称的**第一代打包**（**1GP**）。它们用于在不同组织或用户之间捆绑和共享自定义内容、应用程序或模板。非托管包提供了一种分发组件的方式，允许开发者在安装后根据需要进行修改或扩展。

由于未管理包是 1GP 的一部分，它们遵循的开发和打包流程很少是由源代码驱动的。这意味着包内的组件通常是从一个组织中选择的，而不是从版本控制系统中的分支选择的。未管理包缺乏源代码驱动的开发，这使得涉及版本控制、持续集成和持续部署的精简高效的 DevOps 流程变得困难。

这种方法的另一个限制是未管理包不支持包本身的版本控制或就地升级。对未管理包内组件的任何更新或更改都必须在安装后手动在目标组织中进行。这可能导致在长期管理和维护自定义功能时出现挑战，特别是在更大和更复杂的 Salesforce 实施中。

在未管理包中缺少特定于包的命名空间也意味着其组件会与目标组织的元数据合并，没有任何隔离。这可能导致命名冲突和部署时的潜在问题，使得管理依赖关系和维护目标组织中清晰的元数据结构变得更加困难。如果一个未管理包被安装到一个有命名空间的组织中，组件将继承该组织的命名空间。

如您所见，原始的 1GP 方法存在多个限制，这就是 Salesforce 将其替换为**第二代打包**（**2GP**）的原因，而这也是当前推荐的方法。

正如我们所讨论的，未管理包并不完全适合用作您的 DevOps 策略的一部分，因此让我们来看看解锁包，它是在 Salesforce 的 2GP 实施中引入的。

# 解锁包

Salesforce 解锁包是一种现代、灵活且模块化的打包解决方案，允许开发人员和管理员打包、部署和管理在 Salesforce 平台上构建的自定义功能和应用程序。它们是 Salesforce 源代码驱动开发方法的一部分，强调使用版本控制系统和持续集成管道来实现高效的开发和部署过程。

解锁包解决了在大规模和复杂的 Salesforce 实施中管理和部署自定义功能的挑战。通过将应用程序和自定义功能拆分为模块化单元，它们使团队能够更有效地管理和分发这些组件。这种模块化的方法促进了更好的协作、更容易的版本控制和精简的开发过程。解锁包面向那些希望利用最佳实践进行应用程序生命周期管理、精简部署过程并减少与元数据部署相关复杂性的开发人员和管理员。

与主要用于将应用程序分发到多个公司或客户的托管包不同，解锁包是为单一公司内部使用而设计的。它们尤其适用于拥有大规模 Salesforce 团队的企业，这些团队需要一种结构化且可维护的方式来管理和部署跨不同环境（如开发、测试和生产）的定制功能。通过提供一种可扩展且模块化的方法来进行 Salesforce 开发，解锁包帮助组织优化其 Salesforce 实施并推动更好的业务成果。

由于解锁包是一种基于源代码的方法进行打包，因此在创建它们时更依赖于使用命令行。你需要使用**Salesforce DX**（**SFDX**）方法来管理你的元数据，因此必须启用 Dev Hub。为此，请按照以下步骤操作：

1.  登录到你的 Salesforce 组织。

1.  点击右上角的齿轮图标并选择**设置**。

1.  在`Dev Hub`中选择并点击它。

1.  将**启用 Dev Hub**切换为**开启**，并在同一页面启用**解锁包**。

启用此功能后，你就可以通过命令行与 Dev Hub 组织进行交互，无论是独立的还是 VS Code 中嵌入的终端。要创建新的解锁包，请运行以下命令：

```
sf package create --name MyPackageName –t Unlocked --path force-app -v MyDevHub
```

将`MyPackageName`替换为你的包名，将`MyDevHub`替换为你在 Dev Hub 组织认证时使用的别名。

此时，假设你已经有一个本地项目，并且已将代码提交到 Git。虽然源代码控制在创建包时不是必需的，但作为 DevOps 流程的一部分，现在正是确保 Git 仓库是最新的好时机，然后再创建新包。在本地项目中更新了元数据组件后，你可以使用以下命令创建新包：

```
sf package version create -p MyPackageName -d force-app -k MyPassword --wait 10 -v MyDevHub
```

将`MyPackageName`替换为你的包名，`MyPassword`替换为包的密码（可选），将`MyDevHub`替换为你在 Dev Hub 组织认证时使用的别名。

创建新包版本后，添加的元数据组件将包含在解锁包中。你可以使用以下命令在目标 Salesforce 组织中安装此包：

```
sf package install --package MyPackageName@1.0.0 -o MyTargetOrg -w 10
```

再次，你需要将`MyPackageName@1.0.0`替换为包名和版本，将`MyTargetOrg`替换为目标组织的用户名或别名。值得注意的是，如果在前一个版本创建时设置了密码，则必须在这里使用`-k`标志提供密码才能完成安装。

由于解锁包采用的是源驱动开发方法，而非基于组织的开发方法，因此它与整个过程中的 DevOps 使用更加契合。通过利用源代码控制，并将较大的代码库拆分成可以独立存在于不同 Git 仓库中的功能模块，你可以在使用解锁包进行交付时，更加灵活地调整方法。

然而，这种模块化的一个潜在问题是，有时会出现某些元数据同时属于多个包的情况。例如，如果你有两个独立的功能模块，它们都使用或依赖于 `Opportunity` 对象，你可能会遇到一个情况，即跨包的更改之间存在循环依赖关系。

解决这个问题的一种方法是拥有一个集中式的 `core` 包，其他包都引用它。在开发此包以外的新功能时，你需要确保在开发环境中安装了该核心包的最新版本。

更好的方法是，在解锁包开发中充分利用命名空间。命名空间应该是创建 Salesforce 解锁包的核心部分。它们确保唯一性——如果某人已经有一个名为 `MyClass` 的 Apex 类，你的 `MyClass` 不会与之冲突，从而避免了棘手的命名冲突。

命名空间还可以有效地进行包的版本管理。Salesforce 使用命名空间来管理包的多个版本，知道哪些版本是兼容的，以及如何处理升级或回滚。

此外，命名空间提供了另一种清晰分隔包代码的方式。它可以明确哪些组件属于特定包，将其代码与组织的其他元数据隔离开来。这有助于调试和维护。

在代码层面，而非在打包时，命名空间还带来了一些额外的好处。当第三方系统与你的包的 API 和组件进行集成时，命名空间消除了歧义。即使是在动态 SOQL 或 REST 调用中，引用也变得清晰，并且命名空间允许控制哪些组件是全局可访问的，哪些是私有的。可以设定公开使用的边界。

在创建包时，第一步是注册一个唯一的命名空间标识符。这将所有组件与该命名空间绑定。接下来，在构建新版本时，命名空间会包含在包的元数据中——在安装过程中，Salesforce 使用命名空间来分隔传入的组件，避免冲突。在代码和配置中，组件可以通过命名空间前缀来引用，例如 `namespace__MyClass`。

然而，命名空间也有一些缺点。它们将您锁定到一个永久的标识符，这个标识符之后无法轻松更改。引用命名空间组件会增加复杂性。迁移现有的`未命名空间`代码可能需要繁琐的调整。直观命名空间的可用性可能有限。跨多个命名空间包进行调试可能变得复杂。

总体来说，优点大于局限性，特别是在可管理性和版本控制方面。但重要的是要意识到这些缺点，并根据这些缺点来规划您的命名和开发。

幸运的是，Salesforce 也认识到这个挑战，并提供了另一种包类型来应对这种情况。让我们进一步探讨这些依赖于组织的包。

# 依赖于组织的包

Salesforce 提供的另一种解锁包类型——依赖于组织的包，通过推迟在安装时进行更改的编译和验证，解决了依赖问题。这意味着这些依赖项不一定需要存在于您的开发组织中或您的源控制中，您可以依赖目标组织中存在的元数据。

这种类型的解锁包非常适合大型、复杂并且已经使用了很长时间的 Salesforce 组织，因此积累了大量的更改。将这些更改拆解为独立模块是一项漫长且具有挑战性的工作，但通过拥有能够依赖目标组织中未打包元数据的包类型，您可以推迟（甚至避免）重新构建整个组织的需求。

创建一个依赖于组织的包也是非常简单的——命令与创建解锁包时相同，只需指定`--orgdependent`标志，如下例所示：

```
sf package create --name MyPackageName -t Unlocked --path force-app -v MyDevHub --org-dependent
```

您可能会想把所有的解锁包都做成依赖于组织的包，以便获得即时验证的优势，但依赖于组织的包也有一些关键的缺点，最终意味着您应该始终评估适合您用例的正确包类型：

| **特性** | **解锁包** | **依赖于组织的包** |
| --- | --- | --- |
| **安装灵活性** | 您可以在任何组织中安装这些包，无论它们包含什么元数据。 | 您只能在包含包依赖的特定元数据的组织中安装这些包。 |
| **依赖** **验证时间** | 在创建包版本时，包的依赖项会被检查。 | 在安装包到组织时，包的依赖项会被检查。 |
| **依赖于** **其他包** | 这些包可以依赖于其他包。 | 这些包不能依赖于其他包。 |
| **依赖解析** | 在创建包之前，您需要解析所有的依赖关系。 | 在创建包之前，您无需解析任何依赖关系。 |
| **支持的** **元数据类型** | 请参阅“元数据覆盖报告”的解锁打包通道，查看支持的元数据类型列表。 | 请参阅“元数据覆盖报告”的解锁打包通道，查看支持的元数据类型列表。 |
| **开发和** **测试环境** | 使用 Scratch Org 来开发和测试你的解锁包。 | 使用包含依赖元数据的沙箱。你也可以在沙箱中启用源跟踪，以便开发你的组织依赖的解锁包。在将包安装到生产环境之前，在沙箱组织中测试包。 |
| **代码** **覆盖要求** | 在你可以推广并发布包之前，必须确保你的 Apex 代码的代码覆盖率至少达到 75%。 | 这里没有代码覆盖率的计算要求，但你应该充分测试你的 Apex 代码。 |

表 6.1 – 解锁包和组织依赖包的比较

在下一节中，我们将讨论 Salesforce 中的最终打包类型：托管包。

# 托管包

Salesforce 托管包由 Salesforce 合作伙伴（也称为**独立软件供应商**（**ISV**））开发、打包并分发。这些包提供了一种扩展 Salesforce 功能的方式，通过添加新功能、流程或应用，而无需从头开始构建。托管包通过 Salesforce AppExchange 分发，AppExchange 是一个在线市场，提供 Salesforce 应用、组件和服务。AppExchange 允许开发者和合作伙伴发布他们的托管包，供 Salesforce 客户发现、评估并直接安装到他们的 Salesforce 环境中。

托管包通常可以根据特定的业务需求进行定制，同时保持包提供的核心功能，但可定制的程度会根据包内包含的元数据有所不同。Salesforce DX 开发者指南中有一节内容，讲解了托管包中可以或不能更改的部分，可以在[`developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/packaging_packageable_components.htm`](https://developer.salesforce.com/docs/atlas.en-us.sfdx_dev.meta/sfdx_dev/packaging_packageable_components.htm)找到。

包提供者负责维护和升级包，确保其与最新的 Salesforce 版本和行业标准兼容。这减轻了使用该包的组织的负担，特别是当该组织使用的是安装包且没有进一步定制或更改包内的元数据时。

Salesforce 与 Java 或 C# 等其他开发平台的最大不同在于，它对开发者的向后兼容性和 API 稳定性有着强烈的强调。当你在 Salesforce 平台上构建应用时，你可以放心，依赖的核心 API 不会突然被弃用或意外更改。

对于像 Java 或 C# 这样的语言，核心库或方法可以通过通知的方式被弃用，提醒它们将在未来的版本中移除。这迫使你作为开发者，持续重构代码以保持更新。但 Salesforce 采取了非常不同的方式来管理升级，并确保客户满意。

一旦某个 Apex API 作为托管包的一部分在 Salesforce 上发布，其方法签名将被锁定。API 功能可能会随着时间的推移发生变化，甚至可能会抛出新的异常，但原始的方法和签名将保持不变。这可以防止开发者在安装依赖包的升级时，因而匆忙重构自己的自定义代码。

此外，托管包还需经过 Salesforce 的严格安全审查，以确保它们符合性能、数据保护和隐私等必要标准。这为使用这些包的组织提供了额外的信任保障。

通常，托管包的生命周期仅在审批和分发阶段有所不同。托管包是在 scratch orgs 中开发，并通过 Salesforce AppExchange 分发。参与该市场需要你作为 ISV 合作伙伴在 Salesforce 注册，并为你的包提供有效的商业案例。一旦获得批准，你就可以开始制作你的包。

以下是分发过程的典型流程：

1.  开发

1.  测试

1.  打包

1.  安全审查

1.  AppExchange 列表

1.  安装和配置

1.  持续支持和升级

## 开发

包创建者使用 Salesforce 工具（如 Apex、Visualforce、Lightning 组件等）开发托管包，确保与 Salesforce 的兼容性。

## 测试

与 Salesforce 的任何其他开发工作一样，包的元数据和代码应该经过充分的测试，不仅要确保其功能完整，还要符合 ISV 合作伙伴应遵守的严格安全要求。

Salesforce 提供了多个工具，帮助开发者引导完成这一过程，例如 Salesforce 代码分析器。该工具利用 Salesforce 图形引擎深入分析代码，跟踪依赖关系，查找常见的安全问题，特别是记录访问相关的问题，采用一种叫做**数据流分析**（**DFA**）的技术。DFA 是一种帮助你更好理解复杂计算机代码的方法。它通过一次性查看整个代码，弄清楚代码的工作原理。它通过分解代码的步骤来实现这一点，包括评估条件、创建类、调用方法和静态调用等内容。它还会尝试在每一步中猜测变量和字段的值。这一切都有助于更好地了解代码的工作方式。

分析器还利用其他开源分析引擎，如 PMD 和 ESLint，来完善这些检查的覆盖范围。

## 打包。

历史上，受管包遵循一个较长的过程，类似于之前讨论的 1GP，这包括以下内容：

+   选择要包括的组件，如 Apex 类、Visualforce 页面、Lightning 组件、自定义对象等。

+   设置包的属性，例如包名、命名空间、版本号和描述。

+   如果有的话，定义对其他包或 Salesforce 特性的依赖关系。

+   将包指定为受管包，以确保版本管理、可升级性和知识产权保护。

然后，可以将该包上传到 Salesforce 环境中，生成安装 URL 以供分发。

随着 2GP 的出现，这一过程变得更加简化。首先，确保你的包所需的所有组件都在项目目录中（通常位于 `force-app` 文件夹内）。该项目应与相应的 Scratch Org 相关联，并且在 `sfdx-project.json` 文件中指定所需的命名空间。

创建实际包的过程比旧的 1GP 方法更直接，与解锁包的区别仅在于一个简单的命令行参数，`-t Managed`，如下所示：

```
sf force package create –n "My Managed Package" -t Managed –r force-app
```

## 安全审查。

在受管包能够在 AppExchange 上列出之前，它必须经过安全审查过程。该过程包括以下内容：

+   对包的代码和组件进行全面评估，以识别潜在的安全漏洞，如注入攻击、敏感数据的非安全存储和不当的访问控制。

+   确保包符合 Salesforce 的安全指南、最佳实践和合规要求。

+   向 Salesforce 提交安全审查请求，并提供相关文档和测试用例。

+   解决 Salesforce 在审查过程中识别的任何安全问题，并重新提交包以供审批。

一旦包通过安全审查，它将获得**通过安全审查**的状态，向客户表明它符合 Salesforce 的安全标准。

## AppExchange 列表。

安全审查通过后，该包可以在 Salesforce AppExchange 上列出。列出包的过程包括以下步骤：

+   创建一个包含包的基本信息的 AppExchange 列表，如名称、描述、功能、定价和支持详情。

+   添加屏幕截图、视频或其他媒体，展示包的功能和优势。

+   使用在打包过程中生成的安装 URL，将该列表与受管包关联起来。

+   向 Salesforce 提交列表进行审批，Salesforce 将审查其质量、品牌和内容指南。

一旦列表获得批准，它将在 AppExchange 上公开发布，允许客户发现并评估该包。

## 安装与配置

Salesforce 客户可以通过以下步骤在 AppExchange 中查找、评估并安装托管包：

+   浏览 AppExchange，使用搜索、筛选器和分类来发现满足特定需求的包

+   通过查看包的描述、功能、定价、客户评价以及任何可用的演示或试用来评估该包

+   通过点击 AppExchange 列表中的 **立即获取** 按钮来安装包，启动客户 Salesforce 环境中的安装过程

+   在安装过程中授予访问权限并设置包的安全设置，确保其与组织的安全政策一致

+   安装后通过定制设置、调整布局或设置任何必需的集成来配置包

一旦安装并配置完成，托管包就会成为客户 Salesforce 环境的一个重要组成部分，扩展平台的功能以满足他们的特定需求和要求。

## 持续支持和升级

安装并配置完包后，包提供商负责提供持续的支持和更新。这确保了该包与最新的 Salesforce 版本、行业标准和客户期望保持兼容。持续的支持和升级过程通常包括以下内容：

+   通过支持渠道（如电子邮件、电话或在线论坛）监控并处理客户反馈、问题和疑问。

+   定期发布包更新，以修复 bug、增强功能并添加新功能。这些更新作为新包版本发布，客户可以根据自己的需要选择安装。

+   确保与最新的 Salesforce 版本兼容，进行必要的调整以保持与平台的无缝集成。

+   跟进行业趋势、客户需求和技术进展，确保包对客户仍然具有相关性和价值。

+   通过通讯渠道（如新闻通讯、网络研讨会或应用内通知）向客户告知重要更新、新功能和最佳实践。

包提供商提供的持续支持和升级有助于包的长期成功、客户满意度和整体价值。

# 打包模型的优缺点

打包作为 DevOps 过程中开发更新的分发方式，符合源驱动的软件开发原则。由于不同类型的包提供了不同的使用场景和优势，选择最合适的交付模型对于优化 DevOps 生命周期中的工作流程至关重要。

让我们回顾一下差异：

| **包类型** | **优点** | **缺点** | **主要用途** |
| --- | --- | --- | --- |
| **非托管** | 易于定制 | 无版本控制 | 用于学习目的的代码和配置共享 |
|  | 允许进行代码编辑 | 无自动升级 | 共享示例解决方案 |
|  | 无命名空间要求 | 由于可编辑代码存在安全隐患 | 协作开发 |
|  |  | 不支持托管包功能 | 可供专业服务团队使用，其中有一些常见的定制化需求，许多客户都需要，但每个客户可能需要进行少许调整 |
| **解锁** | 易于定制 | 无自动升级 | 在多个组织之间部署可重用组件 |
|  | 版本控制 | 手动升级过程 | 共享模块化解决方案 |
|  | 允许进行代码编辑 | 由于可编辑代码存在安全隐患 | 促进内部协作和开发 |
|  | 支持托管包功能（例如，命名空间） | 需要 Salesforce DX 和源驱动开发 |  |
| **托管** | 自动升级 | 定制化有限 | 商业应用分发 |
|  | 版本控制 | 代码不可编辑 | 在 AppExchange 上分发应用程序 |
|  | 由于代码不可编辑增强了安全性 | 需要命名空间 | 保护知识产权 |
|  | 支持托管包功能（例如，命名空间） | 2GP 要求 Salesforce DX 和源驱动开发（尽管 1GP 仍可在没有 DX 模式的情况下完成） |  |

表 6.2 – 每种包类型的优缺点

# 拆分现有的单体应用程序

将一个成熟的单体应用程序迁移到 Salesforce 的包开发模型可能是一项重大的工作，充满了复杂性和挑战。

在复杂性方面，通常需要对代码进行重构，以打破紧耦合并将组件适配到模块化包中。依赖管理变得至关重要，以解开相互关联的组件。引入命名空间可能会增加更新所有引用的复杂性。数据模型可能需要重新设计，以适应新的包化架构。权限集和配置文件可能需要重新定义。自动化和 CI/CD 流水线需要适应以处理打包、版本控制和依赖关系。保持各个组织环境与正确的包版本同步非常复杂。

就挑战而言，转型将需要大量的资源和时间投入。随着团队学习新模型，知识差距会产生。测试策略需要彻底改革，可能包括重写测试和脚本，并设置新的测试环境。保持向后兼容性可能会限制变更，迫使需要对旧系统进行支持。一旦转型完成，跨包和客户的版本管理将增加复杂性。习惯于快速部署的利益相关者可能会抵制更慢、更受控制的包生命周期。除了人员成本外，培训、停机时间和工具等费用将逐渐累积。

为了顺利过渡，分阶段的逐步方法可以提供帮助。广泛的培训和专家咨询将培养必要的技能。详细的文档提供了知识库。反馈渠道让问题早期显现。风险评估和回滚计划可以规避陷阱。合理的资源分配，无论是人力还是计算资源，奠定了基础。

虽然困难，将单体应用程序迁移到包模型最终可以实现模块化、可扩展的开发和更容易的维护。通过仔细的规划和执行，长期的好处可能会超过达到目标的复杂性。

# 总结

在本章中，我们探讨了将代码更改打包作为部署技术，并比较了不同类型的包。对于每种类型的包，我们已经看到了将 Salesforce 更改捆绑成这些包以便进一步分发的步骤。

我们还看到，如果选择适当类型的包，这些更改可以遵循源驱动的 DevOps 流程。打包绝不是替代 DevOps 流程的手段；相反，它是 Salesforce 平台上 DevOps 的一部分技术。同样，它也不是在 ISV 合作伙伴空间以外的场景中交付更改的唯一方式。

在下一章中，我们将开始探讨如何将源驱动工作流的所有元素结合起来，并在我们研究 CI/CD 自动化流程时加入一些自动化。这代表了一种不需要打包的替代交付机制。
