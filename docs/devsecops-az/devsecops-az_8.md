# <st c="0">8</st>

# <st c="2">Azure 上的持续安全监控</st>

<st c="41">在前几章中，我们强调了 DevSecOps 的主要目标是将安全性作为软件开发过程每个阶段的常规部分。</st> <st c="202">其结果是，我们可以在软件部署到生产环境并投入使用之前，捕获并修复大多数安全问题。</st> <st c="325">那么，软件发布后的安全性如何呢？</st> <st c="381">一个完整的 DevSecOps 策略应当在开发过程早期实施的安全措施基础上，补充运行时安全。</st>

<st c="520">在本章中，我们将</st> <st c="546">讨论在 DevOps 的</st> **<st c="601">操作</st>** <st c="608">和</st> **<st c="613">监控</st>** <st c="620">阶段实施安全性的一些关键方面，包括实施运行时漏洞管理、威胁检测和威胁防护。</st> <st c="737">在本章结束时，你将对以下内容有一个坚实的理解：</st>

+   <st c="818">理解 DevOps 中的持续监控</st> <st c="855">概念</st>

+   <st c="864">实施运行时安全门以防止</st> <st c="912">关键风险</st>

+   <st c="926">为</st> <st c="975">运行时环境实施持续安全监控</st>

+   <st c="995">现代云环境中运行时保护的挑战</st> <st c="1043">问题</st>

+   <st c="1061">保护在 Azure 中运行的应用</st> <st c="1103">App Service</st>

+   <st c="1114">在 Azure 中保护容器工作负载</st>

<st c="1154">让我们</st> <st c="1161">开始吧。</st>

# <st c="1173">技术要求</st>

<st c="1196">要跟随本章中的指引，你将需要</st> <st c="1266">以下资源：</st>

+   <st c="1280">一台具有</st> <st c="1294">互联网连接的 PC</st>

+   <st c="1313">一个有效的</st> <st c="1324">Azure 订阅</st>

+   <st c="1342">一个 Azure</st> <st c="1352">DevOps 组织</st>

+   <st c="1371">一个 GitHub</st> <st c="1381">企业组织</st>

# <st c="1404">理解 DevOps 中的持续监控</st>

<st c="1450">我们在本书开篇介绍的 DevOps 第五个实践是</st> **<st c="1538">持续监控</st>** <st c="1559">（</st>**<st c="1561">CM</st>**<st c="1563">）</st>。<st c="1567">CM 涉及两个主要任务——</st> **<st c="1596">收集用户反馈</st>** <st c="1619">和</st> **<st c="1624">收集实时遥测数据</st>**<st c="1659">。用户反馈用于设定未来的</st> <st c="1697">优先事项。</st> <st c="1709">遥测数据用于快速检测并解决操作问题，减少停机时间，维护服务的可靠性</st> <st c="1830">和可用性。</st>

<st c="1847">为了实现</st> <st c="1859">这一目标，CM 依赖于跨应用、基础设施和网络的数据收集监控工具。</st> <st c="1966">在 Azure 中，应用洞察是 CM 的关键服务。</st> <st c="2022">它具有类似的</st> **<st c="2037">应用性能管理</st>** <st c="2071">(</st>**<st c="2073">APM</st>**<st c="2076">) 功能，类似于 Dynatrace 和 Datadog APM。</st> <st c="2122">它可以用于从运行中的应用收集数据，可以使用无代码或基于代码的方法。</st> <st c="2228">然后可以分析这些数据，以提供有关应用健康、实时指标、事务搜索和用户行为的洞察（</st>*<st c="2357">图 8</st>**<st c="2366">.1</st>*<st c="2368">）。</st>

![图 8.1 – Azure 应用洞察概述](img/B19710_08_1.jpg)

<st c="2742">图 8.1 – Azure 应用洞察概述</st>

<st c="2793">在此阶段实施安全性涉及扩展数据收集，包含安全日志和指标。</st> <st c="2903">这些日志和指标可以分析以检测未经授权的访问尝试、潜在的安全漏洞和弱点。</st> <st c="3032">这一过程可能很复杂，因为在像 Azure 这样的云平台上运行的现代云原生应用</st> <st c="3128">通常使用托管服务（例如 App Service、Function Apps、Container Instances 和 Container Apps）。</st> <st c="3246">这些</st> <st c="3252">服务可能对安全团队的操作有所限制。</st> <st c="3313">传统方法，如基于代理的运行时监控，往往在这些环境中无效。</st> <st c="3419">另一个挑战是这些应用的分布式特性，这可能使安全团队不确定从哪里开始进行</st> <st c="3544">安全防护。</st>

## <st c="3558">理解 Azure 和云原生应用的相互关联风险</st>

<st c="3636">现代云原生应用是分布式和复杂的，涉及多个技术</st> <st c="3729">堆栈、微服务和外部 API 交互。</st> <st c="3783">在云原生</st> <st c="3799">环境中，通过 CI/CD 管道的代码会作为容器交付运行（尽管一些组织仍然直接在主机上运行代码）。</st> <st c="3958">该容器在节点内部运行，由集群协调器管理，例如 Kubernetes、Service Fabric 或 OpenShift，或由平台服务管理，如 Azure Web Apps、Azure 容器实例或 Azure Functions。</st> <st c="4182">所有这些都运行在 Azure 云平台上（</st>*<st c="4232">图 8</st>**<st c="4241">.2</st>*<st c="4243">）。</st>

![图 8.2 – 云原生应用的风险交集](img/B19710_08_2.jpg)

<st c="4337">图 8.2 – 云原生应用的风险交集</st>

<st c="4404">保护现代云原生应用程序的复杂性在于，每个部分的安全模型都不同。</st> <st c="4547">例如，容器编排工具如 Kubernetes 和 OpenShift 的安全模型与云服务</st> <st c="4683">（如函数应用和容器应用）的安全模型不同，而后者又与 Windows 和 Linux 节点的安全模型不同。</st> <st c="4805">云的规模和快速发展的步伐使这一复杂性进一步加剧。</st> <st c="4885">Azure 中的运行时云原生应用安全必须考虑其互联性，从而形成一个</st> **<st c="5009">风险交集</st>** **<st c="5022">。</st>**

<st c="5031">恶意</st> <st c="5044">用户通过在运行中的容器中获取 shell 访问权限，可能会窃取源代码、密钥、令牌和凭证，进而可能危及云平台中的其他服务。</st> <st c="5215">他们还可能利用容器权限来破坏集群节点并访问其他工作负载。</st> <st c="5317">相反，弱云凭证可能被用来破坏注册表中的容器并访问源代码、加密密钥及用于</st> <st c="5481">工作负载的敏感数据。</st>

<st c="5494">为了减轻这些风险，我们的安全工作必须集中在两个关键方面——保护运行时环境和在运行时实现应用安全。</st> <st c="5654">让我们详细探讨这两个方面，从</st> <st c="5715">第一个方面开始。</st>

# <st c="5725">保护应用程序运行时环境</st>

<st c="5769">尽管我们尽最大努力在早期解决安全问题，但在</st> <st c="5870">软件生产中，无法预见的漏洞可能会出现。</st> <st c="5894">此外，现代应用程序的复杂性意味着一些风险可能只在</st> <st c="5992">实际运行时才会显现。</st>

<st c="6009">如果我们</st> <st c="6016">采纳</st> **<st c="6026">零信任</st>** <st c="6036">的思维方式（而我们应该采纳），我们需要接受没有任何系统或过程是完美安全的，并为可能的安全漏洞做好准备。</st> <st c="6167">这被称为“假设入侵”心态。</st> <st c="6214">这也是为什么 DevSecOps 不仅仅停留在部署阶段。</st> <st c="6265">运行时安全应作为最后一道防线整合进来，以便在实时应用程序中发生安全问题时进行管理、识别、保护、检测和响应，并从中恢复。</st> <st c="6457">这一整合的首要点是实施运行时门控和保护措施，以防止在早期检查点被绕过的情况下部署最关键的风险。</st> <st c="6625">。</st>

## <st c="6638">实施运行时安全门控以阻止关键风险</st>

<st c="6697">安全</st> <st c="6707">门在 DevSecOps 中起着重要作用。</st> <st c="6754">它们防止了最严重的</st> <st c="6784">软件风险被部署到我们的生产云环境中。</st> <st c="6856">在</st> *<st c="6859">第七章</st>*<st c="6868">中，我们介绍了如何在发布流水线中设置安全门（流水线安全门）。</st> <st c="6962">然而，也可以在运行时实现安全门（运行时安全门），但它们有一定的局限性。</st> <st c="7083">与流水线安全门相比，运行时安全门适用的场景较少。</st> <st c="7139">以下是在 Azure 中运行时安全门可能有效的一些例子：</st>

+   **<st c="7239">Azure 策略</st>**<st c="7252">：在 Azure</st> <st c="7292">云平台上创建资源时</st>

+   **<st c="7306">Kubernetes 入驻控制器</st>**<st c="7342">：在将容器化解决方案/应用程序部署到 Kubernetes 集群（自管理或托管）</st> <st c="7446">时</st>

+   **<st c="7454">反恶意软件</st>**<st c="7467">：当将打包应用程序部署到安装了反恶意软件/反漏洞解决方案的 Azure 虚拟机时</st> <st c="7574">解决方案已安装</st>

![图 8.3 – 流水线安全门与运行时安全门](img/B19710_08_3.jpg)

<st c="7895">图 8.3 – 流水线安全门与运行时安全门</st>

<st c="7961">对于</st> <st c="7966">其他 Azure 服务，运行时安全门不原生支持，除非我们部署第三方</st> <st c="8073">安全解决方案或创建自己的自定义方法。</st> <st c="8127">例如，当将 Web 应用程序部署到 Azure App Service，将微服务部署到 Azure Functions 应用，或将容器化服务部署到 Azure 容器实例时，发布流水线安全门是我们防御关键风险部署的主要防线。</st> <st c="8383">所有这些操作都在 Azure 云平台上运行（</st>*<st c="8433">图 8</st>**<st c="8442">.3</st>*<st c="8444">）。</st>

## <st c="8447">使用 Azure 策略实现运行时安全门</st>

<st c="8502">Azure 策略是 Azure 中的一项配置评估和执行服务。</st> <st c="8580">它可用于</st> <st c="8595">在 API 请求被 Azure 管理平面处理之前审查它们。</st> <st c="8668">它还可以</st> <st c="8675">审查在 Azure 中创建的资源的设置。</st> <st c="8687">对于我们的用例作为运行时安全门，它可以用于执行以下操作：</st>

+   <st c="8818">如果新的 Azure 资源违反我们的</st> <st c="8883">安全策略</st>，请阻止其被创建

+   <st c="8900">如果现有资源违反我们的</st> <st c="8959">安全策略</st>，请阻止其更改

<st c="8976">备注</st>

<st c="8981">我们的目标不是重复介绍 Azure Policy 或 Microsoft Defender for Cloud 的基础知识。</st> <st c="9075">相反，我们将重点讨论与我们讨论内容相关的具体用例。</st> <st c="9154">如果你想了解更多关于这些服务的信息，可以查看这本书</st> *<st c="9221">《Microsoft Azure 安全技术认证与实践》</st>* <st c="9283">，由</st> <st c="9287">Packt Publishing 出版。</st>

<st c="9304">我们可以在 Azure 层级的不同级别上应用政策——管理组、订阅和资源组。</st> <st c="9424">为了简化政策的分配，Azure 允许你将政策分组为</st> **<st c="9497">倡议</st>**<st c="9508">。倡议只是一个可以作为一个整体分配的政策组。</st> <st c="9559">微软提供了一个内置的倡议，叫做</st> **<st c="9642">微软云安全基准</st>** <st c="9676">(</st>*<st c="9678">图 8</st>**<st c="9686">.4</st>*<st c="9688">)，包含了 241 个与安全相关的政策（截至撰写时）。</st> <st c="9752">该倡议中的大部分政策都设置为</st> **<st c="9807">审计</st>** <st c="9812">效果，这意味着它们会观察并报告违规行为，但不会</st> <st c="9879">阻止操作。</st>

![图 8.4 – 微软云安全 Azure Policy 倡议](img/B19710_08_4.jpg)

<st c="10344">图 8.4 – 微软云安全 Azure Policy 倡议</st>

<st c="10409">首先</st> <st c="10416">回顾此倡议中的政策。</st> <st c="10462">识别出那些带来最大</st> <st c="10499">风险的政策。</st> <st c="10518">然后，评估</st> <st c="10533">通过将这些政策设置为</st> **<st c="10620">拒绝</st>** <st c="10624">效果来防止这些风险的影响。</st> <st c="10633">将政策更改为</st> **<st c="10654">拒绝</st>** <st c="10658">意味着它将阻止不符合要求的操作，而不仅仅是</st> <st c="10723">报告这些操作。</st>

## <st c="10738">使用 Kubernetes 入驻控制器实施运行时安全门控</st>

<st c="10816">Admission 控制器是一个 Kubernetes 组件，拦截</st> <st c="10821">对 Kubernetes API 服务器的请求，</st> <st c="10884">在它们被处理之前进行干预。</st> <st c="10949">它通常</st> <st c="10964">用于执行安全性和合规性检查。</st> <st c="11012">为了简化实施 Admission</st> <st c="11047">控制器，CNCF 提供了</st> **<st c="11086">Open Policy Agent</st>** <st c="11103">（</st>**<st c="11105">OPA</st>**<st c="11108">），一个开源策略引擎。</st> <st c="11142">OPA 使用 Rego 语言来定义规则，从简单的检查（例如确保所有容器都有资源限制）到复杂的多步骤评估。</st> <st c="11296">OPA Gatekeeper 库提供了常见场景的示例模板，例如强制执行容器镜像来源、限制特权容器以及确保正确的标签。</st> <st c="11477">这些模板可以在</st> <st c="11497">OPA 网站上查看</st> <st c="11516">，网址如下：</st> [<st c="11522">https://open-policy-agent.github.io/gatekeeper-library/website</st>](https://open-policy-agent.github.io/gatekeeper-library/website)<st c="11584">。</st>

<st c="11585">Azure</st> <st c="11592">Policy 与 OPA 集成，以管理和执行</st> **<st c="11653">Azure Kubernetes Service</st>** <st c="11677">（</st>**<st c="11679">AKS</st>**<st c="11682">）集群中的策略。</st> <st c="11695">这种集成使得在 Azure 层面定义的策略能够在 Kubernetes 环境中强制执行，提供了一种在 Azure 和 Kubernetes 中跨平台管理策略的统一方式。</st> <st c="11874">要使用此功能，我们需要在 Kubernetes 集群中部署 Azure Policy 插件。</st> <st c="11968">可以在订阅级别或单个集群上执行此操作。</st> <st c="12039">要在订阅级别启用它，我们可以将</st> **<st c="12097">Azure Kubernetes Service 集群应安装 Azure Policy 插件</st>** <st c="12191">Azure Policy 推荐分配给我们的订阅或管理组。</st> <st c="12261">最好在更广泛的层级应用治理</st> <st c="12301">策略，例如管理组或订阅，以确保新集群会自动安装该插件。</st>

<st c="12443">截至本文写作时，已经有 79 个内置的 Kubernetes 相关策略，涵盖了</st> <st c="12451">如安全性、身份验证和访问控制、资源管理、配置管理、合规性和治理等领域。</st> <st c="12661">例如，</st> `<st c="13049">^[^/]+.azurecr.io/.+$</st>` <st c="13070">确保只有来自 Azure 容器注册表（</st>`<st c="13130">.azurecr.io/</st>`<st c="13142">）的镜像可以部署到受覆盖的</st> <st c="13176">Kubernetes 集群中。</st>

![图 8.5 – 为限制集群中允许的容器注册表或镜像分配 Azure 策略](img/B19710_08_5.jpg)

<st c="13474">图 8.5 – 为限制集群中允许的容器注册表或镜像分配 Azure 策略</st>

<st c="13581">对于</st> <st c="13586">我们分配的每个策略，我们可以指定排除的命名空间、镜像和容器。</st> <st c="13674">建议与具有详细</st> <st c="13677">应用程序和 Kubernetes 操作知识的开发和 DevOps 团队合作，以确保</st> <st c="13759">适当的排除。</st>

<st c="13848">注意</st>

<st c="13853">具有</st> **<st c="13872">拒绝</st>** <st c="13876">效果的策略不会追溯影响已部署的容器或资源。</st> <st c="13956">现有的容器将继续运行，直到它们被重启、更新</st> <st c="14032">或替换。</st>

<st c="14044">除了前述策略之外，以下是建议至少考虑实施的四个额外策略：</st>

+   *<st c="14154">策略</st>*<st c="14161">:</st> **<st c="14164">Kubernetes 集群中的 Pod FlexVolume 卷应该仅使用</st>** **<st c="14222">允许的驱动程序</st>**<st c="14237">。</st>

    *<st c="14238">背景</st>*<st c="14249">: 在 Kubernetes 中，FlexVolume 是一种插件机制，允许用户使用不同的存储驱动程序为他们的 Pod 添加存储。</st> <st c="14380">这些驱动程序负责</st> <st c="14398">将 Pod 连接到存储后端。</st> <st c="14457">然而，如果</st> <st c="14469">使用不受信任或恶意的驱动程序，可能会带来安全</st> <st c="14533">风险。</st> <st c="14540">例如，恶意驱动程序可能允许攻击者未经授权访问敏感数据，或者利用</st> <st c="14650">系统资源。</st>

    *<st c="14667">该策略的作用</st>*<st c="14688">: 如果分配了</st> **<st c="14710">拒绝</st>** <st c="14714">效果，任何使用未经批准的 FlexVolume 驱动程序的应用程序 Pod 部署将被阻止</st> <st c="14808">部署。</st>

+   *<st c="14824">策略</st>*<st c="14831">:</st> `<st c="14938">/proc</st>` <st c="14943">文件系统为内核提供了一种机制，使其能够向用户空间暴露关于系统和正在运行的进程的信息。</st> <st c="15066">它不是包含“真实”文件，</st> `<st c="15102">/proc</st>` <st c="15107">包含的是运行时系统信息（例如，系统内存、已挂载设备和硬件配置）以及关于系统上每个进程的详细信息。</st> <st c="15265">暴露过多的信息或允许不受限制的访问可能会导致信息泄露并为恶意用户提供潜在的利用机会。</st> <st c="15406">例如，恶意进程可能会更改内核参数以破坏系统稳定性或削弱其</st> <st c="15507">安全性。</st>

    `<st c="15524">在 Kubernetes 中，在</st>` `<st c="15551">SecurityContext</st>` `<st c="15566">定义中，我们可以使用</st>` `<st c="15594">ProcMount</st>` `<st c="15603">类型来指定</st>` `<st c="15628">/proc</st>` `<st c="15633">文件系统如何在应用容器中挂载（参见以下示例）。</st>` `<st c="15711">有三种主要的 ProcMount</st>` `<st c="15742">类型 -</st>` `<st c="15807">Unmasked</st>` `<st c="15815">选项风险最大，因为它提供了对</st>` `<st c="15859">/proc</st>` `<st c="15878">文件系统的完全访问权限，允许容器查看并操作所有进程信息。</st>` `<st c="15963">这可能被利用来暴露敏感信息</st>` `<st c="15974">和系统细节，并且在最坏的情况下，操纵</st>` `<st c="16019">内核参数：</st>`

    ```
     apiVersion: v1
    kind: Pod
    metadata:
      name: unmasked-procmount
    spec:
      containers:
      - name: mycontainer
        image: myimage
        securityContext:
          procMount: Unmasked
    ```

    `<st c="16248">The</st>` `<st c="16253">/proc</st>` `<st c="16258">文件系统</st>` `<st c="16270">包含了关于系统上运行的进程的各种信息。</st>` `<st c="16324">如果容器使用不当的</st>` `<st c="16345">ProcMount</st>` `<st c="16380">类型，可能会将敏感信息或系统细节暴露给未经授权的用户。</st>` `<st c="16475">例如，一个</st>` `<st c="16491">ProcMount</st>` `<st c="16500">类型，允许对</st>` `<st c="16533">/proc</st>` `<st c="16538">的完全访问，可能导致信息泄漏和潜在的</st>` `<st c="16585">安全漏洞。</st>`

    *`<st c="16603">策略的作用</st>`* `<st c="16624">: 该策略确保容器只能使用指定的 ProcMount 类型，例如</st>` `<st c="16715">Default</st>` `<st c="16722">ProcMount 类型，该类型限制了访问。</st>` `<st c="16763">如果容器尝试使用未经批准的 ProcMount 类型，例如</st>` `<st c="16828">Unmasked</st>` `<st c="16836">(如前面示例所示)，则部署将</st>` `<st c="16894">被阻止。</st>`

+   *`<st c="16905">策略</st>`* `<st c="16912">:</st>` `<st c="17624">runAsUser</st>` `<st c="17633">和</st>` `<st c="17638">runAsGroup</st>` `<st c="17648">字段确保容器以特定的批准用户和组 ID 运行（参见以下示例）。</st>` `<st c="17757">这种做法限制了攻击者如果获得容器访问权限时可能造成的潜在损害。</st>` `<st c="17857">例如，使用非 root UID 和 GID 运行容器可以降低特权提升的风险，并保护敏感</st>` `<st c="17982">系统资源：</st>`

    ```
     apiVersion: v1
    kind: Pod
    metadata:
      name: non-root-pod
    spec:
      containers:
      - name: mycontainer
        image: myimage
        securityContext:
          runAsUser: 1000
          runAsGroup: 3000
    ```

    *<st c="18156">该策略的作用</st>*<st c="18177">：此策略确保 Kubernetes 中的 Pod 和容器只能使用</st> <st c="18245">批准的用户和组 ID。</st> <st c="18279">它强制使用非 root UID 和 GID，例如</st> `<st c="18334">1000</st>` <st c="18338">和</st> `<st c="18343">3000</st>`<st c="18347">，分别在前面的示例中体现。</st> <st c="18389">如果容器尝试使用未批准的</st> <st c="18436">UID 或 GID，部署将</st> <st c="18468">被阻止。</st>

+   *<st c="18479">策略</st>*<st c="18486">：</st> `<st c="18925">CAP_SYS_ADMIN</st>` <st c="18938">权限对系统具有广泛的控制，包括修改系统配置和</st> <st c="19047">挂载文件系统的能力。</st>

    <st c="19065">在 Kubernetes 中，</st> `<st c="19085">securityContext</st>` <st c="19100">定义允许你指定容器可以添加或移除的权限（参见以下示例）。</st> <st c="19209">主要有两个操作——</st> `<st c="19241">添加</st>` <st c="19244">和</st> `<st c="19249">移除</st>`<st c="19253">。向容器添加权限会增加其特权，这可能被恶意进程利用来危害系统。</st> <st c="19398">相反，移除权限通过限制</st> <st c="19475">容器的特权来减少攻击面：</st>

    ```
     apiVersion: v1
    kind: Pod
    metadata:
      name: restricted-capabilities
    spec:
      containers:
      - name: mycontainer
        image: myimage
        securityContext:
          capabilities:
            drop: [«ALL»]
            add: [«NET_BIND_SERVICE»]
    ```

    <st c="19687">在</st> <st c="19695">前面的示例中，所有权限都被移除，且</st> <st c="19748">仅添加了</st> `<st c="19757">NET_BIND_SERVICE</st>` <st c="19773">权限，允许容器绑定到特权端口（即</st> <st c="19857">低于</st> `<st c="19863">1024</st>`<st c="19867">的端口）。</st>

    <st c="19870">授予不必要的权限可能会导致重大的安全风险。</st> <st c="19945">例如，具有</st> `<st c="19975">CAP_NET_ADMIN</st>` <st c="19988">权限的容器可以操控网络配置，可能会破坏网络流量或窃取敏感数据。</st> <st c="20098">通过控制可以使用的权限，我们可以减轻特权提升和</st> <st c="20194">系统受损的风险。</st>

    *<st c="20212">该策略的作用</st>*<st c="20233">：此策略确保容器只能使用指定的权限，从而防止使用危险或不必要的特权。</st> <st c="20373">如果容器尝试添加未批准的权限，部署将</st> <st c="20447">被阻止。</st>

<st c="20458">我们强烈</st> <st c="20469">建议您查看 79 个内置策略，识别出对贵组织构成最严重风险的策略，并以</st> **<st c="20625">拒绝</st>** <st c="20629">效果实施它们。</st> <st c="20638">如果内置策略无法覆盖您的使用场景，还可以创建自定义策略。</st> <st c="20728">现在我们已经了解了</st> <st c="20765">如何实施运行时安全门控，让我们来回顾一下如何实施对我们</st> <st c="20871">运行时环境的持续安全监控。</st>

## <st c="20892">实施针对运行时环境的持续安全监控</st>

<st c="20961">现代</st> <st c="20969">云运行时环境不是静态的；一个简单的 API 调用可能会引入配置错误，导致运行关键应用的资源暴露</st> <st c="21125">并且易受攻击。</st> <st c="21141">为了保护这些资源，必须持续监控运行时资源配置的可见性</st> <st c="21242">并且不依赖代理。</st> **<st c="21257">云安全态势管理</st>** <st c="21290">(</st>**<st c="21292">CSPM</st>**<st c="21296">) 是业内用于描述帮助组织持续监控云资源配置的工具的术语，以检测可能带来</st> <st c="21449">安全风险的变化。</st>

<st c="21464">然而，挑战比仅仅识别配置错误更为复杂。</st> <st c="21547">并非所有暴露的资源都是配置错误或易受攻击的。</st> <st c="21606">有效的安全性需要提供上下文，以优先考虑风险，识别可能创建攻击路径的有害组合，并理解更广泛的安全态势。</st> <st c="21770">第一代 CSPM 解决方案主要集中在可见性和配置评估上，这常常导致噪音过大，却没有解决现代云安全的复杂性。</st> <st c="21974">更新的 CSPM 解决方案旨在解决更复杂的挑战，如优先排序、攻击路径检测和上下文</st> <st c="22094">风险评估。</st>

<st c="22110">在 Azure 云中实现运行时环境持续安全可见性和监控的核心</st> <st c="22210">是微软的</st> **<st c="22244">云原生应用保护平台</st>** <st c="22288">(</st>**<st c="22290">CNAPP</st>**<st c="22295">) 解决方案 –</st> **<st c="22309">Microsoft Defender for</st>** **<st c="22332">Cloud</st>** <st c="22337">(</st>**<st c="22339">MDC</st>**<st c="22342">)。</st>

<st c="22345">注意</st>

<st c="22350">CNAPP 是</st> <st c="22360">一种旨在保护云原生应用程序整个生命周期的安全解决方案。</st> <st c="22458">它将多个安全功能集成到一个平台中，防止工具过载。</st> <st c="22543">CNAPP 的主要使用场景是为云原生应用程序提供安全功能，从开发到部署到云中运行（也称为</st> <st c="22734">*代码到云*</st>）</st>。

<st c="22753">MDC</st> <st c="22758">目前提供 10 种保护计划，客户可以根据自己的</st> <st c="22837">安全需求和预算来启用（</st>*<st c="22865">图 8</st>**<st c="22874">.6</st>*<st c="22876">）。</st>

![图 8.6 – MDC 计划](img/B19710_08_6.jpg)

<st c="23211">图 8.6 – MDC 计划</st>

<st c="23233">对于运行环境的持续安全监控，MDC 的 Defender CSPM 计划是一个很好的解决方案，能够应对以下</st> <st c="23365">新挑战：</st>

+   **<st c="23382">攻击路径管理</st>**<st c="23405">：单个云资源的配置错误是有风险的，但</st> <st c="23467">相关联的多个配置错误组合可能会创建出关键的攻击路径，从而使整个应用程序面临风险。</st> <st c="23579">MDC 的攻击路径管理功能通过分析我们的云</st> <st c="23654">资源，识别攻击者可能利用的配置错误链条来应对此问题。</st> <st c="23744">例如，MDC 可能会检测到一个数据库的明文凭证，该数据库运行在提供公共 Web 服务的虚拟机上。</st> <st c="23860">这为攻击者提供了一个路径，能够访问关键数据库中的敏感数据。</st> <st c="23942">通过突出显示这些互相关联的风险，MDC 使安全团队能够优先修复能够破坏整个攻击路径的问题，而不仅仅是解决</st> <st c="24095">孤立的配置错误。</st>

+   **<st c="24122">风险优先级排序</st>**<st c="24142">：安全团队在启用 CSPM 解决方案后，通常会面临大量的警报</st> <st c="24204">和建议。</st> <st c="24255">如果没有适当的优先级排序，他们可能会在对少数业务效益不大的小问题上浪费时间，同时忽略关键漏洞。</st> <st c="24395">MDC 的风险优先级排序通过根据建议的潜在影响及其被利用的可能性来排序，帮助解决这一问题。</st> <st c="24543">MDC 使用上下文感知的风险优先级排序引擎来确定每个安全建议的风险等级。</st> <st c="24656">该风险等级取决于资源配置、网络连接和安全态势等因素。</st> <st c="24766">例如，暴露的存储帐户如果存储有敏感数据，其优先级将高于存储有</st> <st c="24867">普通数据的存储帐户。</st>

+   **<st c="24880">基础设施即代码 (IaC) 模板映射</st>**<st c="24926">：安全配置错误</st> <st c="24956">通常起源于 IaC 模板。</st> <st c="24990">如果不解决</st> <st c="25013">根源问题，这些问题可能会在重新部署后再次出现。</st> <st c="25068">MDC 的 IaC 模板映射通过将云资源与其原始 IaC 模板关联来解决这一问题。</st> <st c="25170">当 MDC 检测到已部署资源中的安全问题时，它会识别相应的 IaC 模板，从而让开发人员修复根本原因。</st> <st c="25317">例如，如果 MDC 发现一个过于宽松的网络安全组，它可以指向 Terraform 模板中需要更新的确切行，防止该问题在未来的</st> <st c="25512">部署中再次发生。</st> <st c="25525">它依赖</st> <st c="25535">于流行的开源 IaC 模板扫描工具 Checkov 的能力</st> <st c="25615">来实现这一点。</st>

+   **<st c="25624">数据安全态势管理</st>**<st c="25657">：有效的风险管理要求你</st> <st c="25699">不仅要了解漏洞的存在位置，还要了解风险数据的敏感性。</st> <st c="25796">MDC 的数据安全</st> <st c="25816">态势管理功能通过扫描和分类云环境中的数据来解决这一问题。</st> <st c="25922">然后，它将这些信息与安全评估集成，提供更全面的风险视图。</st> <st c="26034">例如，如果 MDC 检测到两个配置错误的数据库，其中一个包含客户财务数据，而另一个包含非敏感的营销材料，它会优先关注财务数据库进行处理。</st> <st c="26269">这种情境感知的方法确保安全团队将工作重点放在优先保护最关键数据上，从而显著改善整体</st> <st c="26425">安全态势。</st>

<st c="26442">MDC 具有</st> <st c="26451">比这些更多的功能，包括最近新增的功能，如</st> **<st c="26519">AI 安全态势管理 (AI-SPM)</st>**<st c="26558">。要了解</st> <st c="26568">更多关于这些功能的信息，请参阅以下文档：</st> [<st c="26623">https://learn.microsoft.com/en-us/azure/defender-for-cloud/defender-for-cloud-introduction</st>](https://learn.microsoft.com/en-us/azure/defender-for-cloud/defender-for-cloud-introduction)<st c="26713">。稍后，在本章的动手操作中，你将实施 MDC 的 Defender CSPM 计划</st> <st c="26809">。</st>

# <st c="26816">在 Azure 中保护应用程序运行时</st>

<st c="26860">确保</st> <st c="26870">应用程序在部署到 Azure 服务后仍然安全，与传统的本地运行时安全不同。</st> <st c="26991">云服务引入了新的挑战，需要转变策略，采用一种与</st> <st c="27096">DevOps 实践相辅相成的方式。</st>

<st c="27113">在 Azure 的共享责任模型中，微软负责保护底层基础设施，但开发人员和运维团队必须保护应用程序和数据。</st> <st c="27278">这要求</st> <st c="27292">理解 Azure 的安全功能，并将其与应用层保护措施集成。</st> <st c="27389">在本节中，我们将探讨在 Azure 中保护运行时应用程序的挑战，并讨论如何使用 Azure 原生工具作为</st> <st c="27531">起点。</st>

## <st c="27546">现代云环境中运行时保护的挑战</st><st c="27577"> </st>

<st c="27613">Azure 云环境提供了多种计算选项，用于托管应用程序和服务，从传统的虚拟机到无服务器计算功能。</st> *<st c="27764">图 8</st>**<st c="27772">.7</st>* <st c="27774">展示了这一范围</st> <st c="27792">以及客户在这些选项之间的控制差异。</st> <st c="27838">例如，虚拟机提供完全的操作系统控制，而 Azure Functions 提供最小的操作系统交互。</st> <st c="27960">这种多样性使得持续的安全性</st> <st c="27999">措施变得具有挑战性。</st>

<st c="28020">一个主要的挑战是支持组织中使用的各种应用程序和服务运行时选项。</st> <st c="28132">当前的解决方案可能能够通过安装的代理来保护虚拟机上的应用程序，但容器中的服务怎么办？</st> <st c="28260">它可能能够保护在 Azure App Service 上运行的 Linux 容器中的应用程序，但它是否支持 Windows 容器？</st> <st c="28393">您的解决方案不需要覆盖所有使用场景，但您需要确保在运行时保护您的关键资产</st> <st c="28509">。</st>

![图 8.7 – Azure 计算选项](img/B19710_08_7.jpg)

<st c="29365">图 8.7 – Azure 计算选项</st>

<st c="29399">随着更多</st> <st c="29408">组织将其应用程序从虚拟机迁移到容器服务和无服务器计算，必须调整其应用程序运行时保护策略，原因在于这些环境的运作方式差异以及它们所带来的独特挑战。</st> <st c="29676">以下是一些需要考虑的额外挑战</st> <st c="29712">：</st>

+   **<st c="29724">有限的操作系统访问权限</st>**<st c="29742">：大多数 Azure 计算服务（虚拟机除外）将底层操作系统从客户面前抽象化。</st> <st c="29858">这使得安装依赖于操作系统级代理的传统安全解决方案变得困难。</st> <st c="29954">这些基于代理的安全解决方案在虚拟机上的应用程序中工作良好，但可能不支持容器化应用程序或无服务器功能。</st> <st c="30097">能够保护在这些环境中运行的应用程序的有效安全解决方案必须能够做到这一点，而不需要</st> <st c="30216">持久化代理。</st>

+   **<st c="30234">自动扩展挑战</st>**<st c="30257">：某些计算服务可以根据需求自动添加新的实例来处理请求。</st> <st c="30349">如 App Service、Function Apps、Container Apps 和 Kubernetes Services 等服务可以自动添加数百个实例，有时在几分钟内就能处理请求。</st> <st c="30525">当负载消失时，这些实例会被终止，以节省成本。</st> <st c="30596">有效的安全解决方案必须能够保护在这种环境中运行的应用程序，并能够处理快速扩展，具备几乎即时启动和</st> <st c="30744">停止的能力。</st>

+   **<st c="30770">容器化复杂性</st>**<st c="30800">：容器因其可移植性和高效性而广受欢迎，但它们也带来了独特的安全挑战。</st> <st c="30914">安全解决方案必须具备容器感知能力，以保护主机和各个容器。</st> <st c="31013">许多传统安全供应商才刚开始将容器感知能力添加到他们的解决方案中。</st> <st c="31098">这些解决方案正在逐步发展。</st>

+   **<st c="31114">无服务器挑战</st>**<st c="31136">：无服务器计算，如 Azure Functions，改变了应用程序的运行方式，从而也改变了我们如何保护它们。</st> <st c="31252">例如，一家金融服务公司可能在 Azure 容器实例上运行其实时欺诈检测微服务。</st> <st c="31375">这些容器可能在毫秒级别内启动以处理事务，然后终止。</st> <st c="31468">假设有长期运行的服务器的传统安全模型在这种环境下面临困难。</st> <st c="31539">这个环境下的安全挑战很大。</st>

<st c="31556">这些挑战凸显了为现代云架构设计的新型安全工具的需求。</st> <st c="31657">随着越来越多的公司采用这些技术，安全行业正快速发展，以应对这些</st> <st c="31760">独特的安全问题。</st>

## <st c="31774">保护运行在 Azure App Service 中的应用程序</st>

<st c="31827">Azure</st> <st c="31834">App Service 是一种托管服务，用于在 Azure 云中托管 Web 应用程序、API 和移动后端服务。</st> <st c="31952">通过使用 CI/CD 管道，开发人员可以将 Web 或 API 服务作为代码或容器直接部署到服务中。</st> *<st c="32069">图 8</st>**<st c="32077">.8</st>* <st c="32079">展示了在 GitHub Actions（标记为</st> **<st c="32190">1</st>**<st c="32191">）和 Azure Pipelines（标记为</st> **<st c="32224">2</st>**<st c="32225">）中实现 Azure App Service 部署操作/任务的示例。</st>

![图 8.8 – GitHub Actions 和 Azure Pipelines 中的 Azure App Service 部署任务](img/B19710_08_8.jpg)

<st c="33140">图 8.8 – GitHub Actions 和 Azure Pipelines 中的 Azure App Service 部署任务</st>

<st c="33228">对于</st> <st c="33233">在 Azure App Service 部署的 Web 和 API 应用程序的运行时保护，实施</st> **<st c="33328">Defender for App Service</st>** <st c="33352">的 MDC 计划是一个很好的起点。</st> <st c="33392">该计划提供运行时威胁检测功能，主要通过行为分析技术来实现，涵盖以下五个类别，详见</st> *<st c="33529">表 8.1</st>*<st c="33538">。</st>

| **<st c="33539">MITRE 威胁</st>** **<st c="33557">ATT&CK 战术</st>** | **<st c="33571">描述</st>** |
| --- | --- |
| **<st c="33583">攻击前</st>** **<st c="33595">威胁检测</st>** | <st c="33611">检测扫描程序扫描我们运行中的应用程序以寻找已知漏洞 – 例如，使用 Nmap、BlindElephant、WPScan、Joomla Scanner 和</st> <st c="33804">Drupal Scanner 等工具进行 Web 指纹识别的尝试。</st> |

| **<st c="33819">初始访问</st>** **<st c="33835">威胁检测</st>** | <st c="33851">检测来自已知恶意 IP 地址或可疑端点的恶意网络连接尝试，例如：</st> <st c="33965">例如：</st>

+   <st c="33979">已知恶意 IP 地址连接到我们的</st> <st c="34047">App Service</st><st c="34058">的 FTP 端点。</st>

+   <st c="34059">应用服务解析已知恶意</st> <st c="34103">DNS 主机名</st><st c="34115">。</st>

+   <st c="34116">从不寻常的 IP 地址或</st> <st c="34207">用户代理</st><st c="34218">连接到托管在 App Service 中的敏感网页。</st>

<st c="34219">Defender for App Service 通过分析</st> <st c="34281">各种服务日志，例如 DNS 和 FTP 日志，并将其与 Microsoft 威胁情报源中的已知恶意 IP 地址和域名进行比较，从而检测这些尝试。</st> <st c="34425">。</st> |

| **<st c="34443">攻击执行</st>** **<st c="34461">威胁检测</st>** | <st c="34477">检测攻击者利用漏洞获得访问权限后，在我们应用服务的虚拟机实例上执行恶意或可疑命令和进程的尝试。</st> <st c="34666">这通过分析运行中的进程、文件系统和内存行为来完成。</st> <st c="34780">这可以检测到如下事件：</st> <st c="34808">例如：</st>

+   <st c="34822">可疑的远程文件下载 – 例如，使用</st> `<st c="34883">curl</st>` <st c="34887">从像 Pastebin 这样的站点下载代码并保存到磁盘。</st> <st c="34947">。</st>

+   <st c="34955">下载可疑文件，如加密矿工可执行文件或</st> <st c="35025">Web Shell</st><st c="35035">。</st>

+   <st c="35036">可疑进程或命令的执行——例如，挖矿程序、反向 Shell 工具、凭证访问工具、已知攻击者工具名称的进程、恶意 PowerShell PowerSploit cmdlets、尝试利用 PHP 进程执行操作系统命令，以及从异常路径执行的</st> `<st c="35324">SVCHOST</st>` <st c="35331">进程（恶意软件通常利用</st> `<st c="35389">SVCHOST</st>` <st c="35396">来隐藏</st> <st c="35405">恶意活动）。</st>

+   <st c="35425">滥用内置管理员工具，如</st> `<st c="35472">certutil.exe</st>` <st c="35484">来解码可执行文件或下载二进制文件，而不是其通常用于管理证书的功能。</st> <st c="35584">攻击者通常滥用合法的管理员工具以达到</st> <st c="35642">恶意目的。</st>

+   <st c="35661">执行</st> <st c="35672">各种无文件攻击技术</st> <st c="35711">和工具包。</st>

+   <st c="35724">在</st> `<st c="35749">/upload</st>` <st c="35756">文件夹中发现一个 PHP 文件。</st> <st c="35765">该文件夹通常不包含 PHP 文件，这表明可能存在利用任意文件</st> <st c="35880">上传漏洞的攻击。</st>

+   <st c="35903">主机/设备数据分析，检测可能的外部数据</st> <st c="35960">流出情况。</st>

|

| **<st c="35977">悬挂</st>** **<st c="35987">DNS 检测</st>** | <st c="36000">当应用服务网站已退役但其自定义域名（DNS 记录）</st> <st c="36091">未被删除时，发出警报。</st> |
| --- | --- |

| **<st c="36103">后渗透检测</st>** | <st c="36129">检测我们托管的应用程序是否在实际攻击中被发现，如</st> <st c="36221">以下内容：</st>

+   <st c="36235">我们的应用 URL 曾被用于针对 Microsoft 365 客户的钓鱼攻击，该攻击已被 Microsoft 威胁</st> <st c="36359">情报团队</st><st c="36376">识别。</st>

+   <st c="36377">由于 Microsoft 威胁</st> <st c="36498">情报团队</st><st c="36515">的监测，我们的 Web 应用 URL 被 Windows SmartScreen 标记为恶意。</st>

|

<st c="36516">表 8.1 – 应用服务计划的威胁检测类别</st>

<st c="36590">尽管应用服务的 Defender 是一个很好的起点，但它也有其局限性。</st> <st c="36678">例如，它侧重于检测威胁，而不是阻止威胁。</st> <st c="36750">部分原因在于</st> <st c="36773">它分析日志而不是使用代理。</st> <st c="36817">当安全解决方案仅检测威胁而不阻止它们时，响应时间会增加。</st> <st c="36913">检测威胁与人工干预之间的延迟使威胁有更多时间造成损害，可能导致数据泄露或系统被攻陷。</st> <st c="37075">这还增加了安全团队的工作量，因为他们需要调查和响应</st> <st c="37162">每个检测到的事件。</st>

<st c="37178">另一个 App Service 的 Defender 限制是，它无法识别我们应用程序在运行时已知的漏洞。</st> <st c="37312">这种能力至关重要。</st> <st c="37348">手动追踪哪些正在运行的应用程序受到下一个重大漏洞（如 Log4j）影响并不是最优选择。</st> <st c="37493">为了解决这些问题，我们可以使用定制的开源工具或第三方安全解决方案。</st> <st c="37591">例如，一些第三方解决方案可以作为 RASP 代理与我们的应用程序一起运行，以提供额外的功能，如阻止主动威胁和识别运行中的应用程序中已知的漏洞。</st> <st c="37788">在运行的应用程序中。</st> <st c="37813">您需要解决的挑战是如何大规模地推广这一解决方案。</st>

<st c="37879">什么是 RASP？</st>

**<st c="37893">运行时应用程序安全保护</st>** <st c="37933">(</st>**<st c="37935">RASP</st>**<st c="37939">) 是一种在应用程序内部运行的安全技术，用于实时检测和防止攻击。</st> <st c="37981">它监控应用程序在运行时的行为，并能对潜在威胁采取即时行动。</st> <st c="38054">RASP 提供了在生产环境中的持续保护，补充了其他部署前的安全措施，如 SAST 和 DAST。</st> <st c="38161">根据安全供应商的实现，RASP 有时可能比较复杂，且可能存在性能影响方面的担忧。</st>

<st c="38448">Azure App Service 提供了更简单的方式，通过扩展来推出诸如 Tinfoil Security（现已成为 Synopsys 的一部分）和 Signal Sciences WAF（现已成为 Fastly 的一部分）等安全解决方案。</st> <st c="38631">您可以通过以下步骤进行安装：前往您的 App Service 实例 →</st> **<st c="38692">开发工具</st>** <st c="38709">→</st> **<st c="38712">扩展</st>** <st c="38722">→</st> **<st c="38725">添加</st>** <st c="38728">(</st>*<st c="38730">图 8.9</st>**<st c="38738">.)</st>

![图 8.9 – 向 Azure App Service 添加一些安全扩展](img/B19710_08_9.jpg)

<st c="39664">图 8.9 – 向 Azure App Service 添加一些安全扩展</st>

<st c="39729">Tinfoil Security 提供漏洞管理功能，而 Signal Sciences WAF 提供针对 Web 应用程序攻击的威胁预防和检测。</st>

## <st c="39870">保护 Azure 中的无服务器工作负载在运行时的安全性</st>

<st c="39942">无服务器</st> <st c="39954">工作负载，如 Azure Functions，以及运行在</st> **<st c="40032">容器即服务（CaaS）</st>** <st c="40054">资源上的容器化</st> <st c="40008">应用程序，例如</st> **<st c="40082">Azure 容器应用</st>** <st c="40102">(</st>**<st c="40104">ACA</st>**<st c="40107">)，由于其短暂的特性，面临独特的运行时安全挑战。</st> <st c="40126">例如，Azure Functions 的消费计划没有预留实例；相反，实例会根据请求按需动态分配。</st> <st c="40185">对于 HTTP 触发的函数，Azure 的规模控制器每秒可以分配一个实例，并且实例在处理完成后会被移除。</st> <st c="40347">这种瞬态特性使得传统的安全措施效果较差，因此需要专门的安全方法来保护</st> <st c="40630">无服务器环境。</st>

<st c="40654">目前，Azure 没有为无服务器工作负载提供专门的运行时漏洞评估、威胁检测和防护的原生解决方案。</st> <st c="40815">然而，第三方</st> <st c="40836">安全供应商通过提供类似 RASP 的解决方案填补了这些空白。</st> <st c="40904">这些解决方案允许组织将安全直接嵌入到其无服务器函数代码或容器中。</st> <st c="41019">这样，运行时安全跟随应用程序，无论它被部署到哪个环境。</st> <st c="41125">这种方法通常需要代码更改或定制化的容器</st> <st c="41197">构建过程。</st>

<st c="41211">例如，Palo Alto Networks 的 Prisma Cloud 提供了 Serverless Defender，可以嵌入到函数代码中，以便在运行时监控和保护该函数。</st> <st c="41383">以下代码示例展示了如何将 Serverless Defender 库添加到 C# 函数代码中，创建一个新的受保护处理程序，该处理程序包装了原始处理程序。</st> <st c="41561">当函数在云端运行时被调用时，受保护的处理程序会被调用，进而调用函数代码。</st> <st c="41684">受保护的处理程序将提供运行时漏洞评估、威胁检测以及</st> <st c="41796">威胁防护等功能：</st>

```
 using Twistlock;
public class Function
{
    // Original handler
    public static async Task<IActionResult> Run(
        [HttpTrigger(AuthorizationLevel.Function, "get", "post", Route = null)] HttpRequest req,
        ILogger log, ExecutionContext context)
    {
        Twistlock.Serverless.Init(log, context);
        // Function logic
    }
}
```

<st c="42113">对于</st> <st c="42118">无服务器容器化工作负载，工作流可以自动化，使得运行时安全处理程序可以直接嵌入容器镜像中，从而建立控制点。</st> <st c="42307">为了让这一过程更容易被采用，一些服务提供商可能会提供将</st> <st c="42393">此过程自动化</st> **<st c="42422">持续部署</st>** <st c="42444">(</st>**<st c="42445">CD</st>**<st c="42447">)流水线的能力。</st> *<st c="42460">图 8</st>**<st c="42468">.10</st>* <st c="42471">展示了一个在 Azure DevOps 流水线中自动化此类安全嵌入的 Palo Alto Prisma Cloud 任务示例。</st>

![图 8.10 – Prisma Cloud Serverless Defender 嵌入任务示例](img/B19710_08_10.jpg)

<st c="43068">图 8.10 – Prisma Cloud Serverless Defender 嵌入任务示例</st>

<st c="43143">任务将接受一个用于容器化应用程序的 Dockerfile 输入</st> <st c="43237">并重新构建它，将 Prisma Cloud 的运行时安全性嵌入容器镜像中。</st> <st c="43319">当容器启动时，Prisma Cloud 应用内嵌的 Defender 会作为父进程在容器中启动，并立即调用程序作为</st> <st c="43474">它的子进程。</st>

## <st c="43484">保护 Azure 中的容器工作负载</st>

<st c="43524">Azure</st> <st c="43535">云提供</st> <st c="43548">多种服务来运行容器化应用程序</st> <st c="43600">和服务。</st> <st c="43614">其中一些是容器专用的，意味着</st> <st c="43652">它们仅运行</st> <st c="43666">容器工作负载：</st>

+   **<st c="43686">Azure 容器</st>** **<st c="43703">实例</st>** <st c="43712">(</st>**<st c="43714">ACI</st>**<st c="43717">)</st>

+   **<st c="43719">Azure 容器</st>** **<st c="43735">应用</st>** <st c="43739">(</st>**<st c="43741">ACA</st>**<st c="43744">)</st>

+   **<st c="43746">Azure Kubernetes</st>** **<st c="43763">服务</st>** <st c="43770">(</st>**<st c="43772">AKS</st>**<st c="43775">)</st>

+   **<st c="43777">Azure Red Hat</st>** **<st c="43791">OpenShift</st>** <st c="43800">(</st>**<st c="43802">ARO)</st>**

<st c="43806">其他</st> <st c="43814">是兼容容器的，这意味着它们可以运行代码和</st> <st c="43875">容器应用程序：</st>

+   <st c="43898">Azure</st> <st c="43905">应用服务</st>

+   <st c="43916">Azure 函数</st>

+   <st c="43932">Azure</st> <st c="43939">服务网格</st>

+   <st c="43953">Azure 批处理</st>

+   <st c="43965">Azure</st> <st c="43972">Spring 应用</st>

<st c="43983">开发人员可以通过 CI/CD 管道将容器化应用程序部署到这些服务中。</st> *<st c="44074">图 8</st>**<st c="44082">.11</st>* <st c="44085">展示了在 GitHub Actions（标记为</st> **<st c="44198">1</st>**<st c="44199">）和 Azure Pipelines（标记为</st> **<st c="44232">2</st>**<st c="44233">）中实现 Kubernetes 工作负载部署操作/任务的示例。</st>

![图 8.11 – GitHub Actions 和 Azure Pipelines 中的 Kubernetes 工作负载部署任务](img/B19710_08_11.jpg)

<st c="45457">图 8.11 – GitHub Actions 和 Azure Pipelines 中的 Kubernetes 工作负载部署任务</st>

<st c="45548">对于</st> <st c="45553">工作负载的漏洞管理和运行时保护，我们可以从实施 MDC 的容器防护计划开始。</st> <st c="45684">该计划结合了无代理和基于代理的方法，以检测容器工作负载的漏洞和威胁。</st> <st c="45803">然而，这些功能目前仅限于部署在 AKS 上的工作负载。</st> <st c="45883">对于 Kubernetes 工作负载中的威胁检测，容器防护会收集并分析以下数据（</st>*<st c="45995">图 8</st>**<st c="46004">.12</st>*<st c="46007">）：</st>

+   <st c="46010">来自</st> <st c="46051">API 服务器的审计日志和安全事件</st>

+   <st c="46061">来自</st> <st c="46095">工作节点的安全信号和事件</st>

+   <st c="46107">来自</st> <st c="46151">控制平面的集群配置信息</st>

+   <st c="46164">来自 Azure 策略的工作负载配置（我们在</st> <st c="46236">本章中已讨论过这一点）</st>

![图 8.12 – 容器防护架构](img/B19710_08_12.jpg)

<st c="46575">图 8.12 – 容器防护架构</st>

*<st c="46629">表 8.2</st>* <st c="46639">详细描述了该计划的功能</st> <st c="46650">：</st>

| **<st c="46694">功能</st>** | **<st c="46705">描述</st>** |
| --- | --- |
| **<st c="46717">漏洞评估</st>** | <st c="46742">对存储在</st> **<st c="46789">Azure 容器注册表</st>** <st c="46814">(</st>**<st c="46815">ACR</st>**<st c="46818">) 中的镜像进行漏洞评估，</st> <st c="46847">以及对 AKS 集群中运行的镜像进行评估。</st><st c="46860">对于 ACR，评估可以通过无代理的方式进行。</st> <st c="46926">对于 AKS 中运行的镜像，我们也可以通过配置 Kubernetes 的无代理发现来实现此功能，或者我们</st> <st c="47062">也可以安装</st> **<st c="47083">Defender</st>** **<st c="47092">传感器</st>** <st c="47098">代理。</st><st c="47105">此功能由 Microsoft Defender 漏洞管理解决方案提供支持。</st> <st c="47194">它支持 Linux 和 Windows 容器（这很少见），并支持扫描特定语言的包，包括 Python、Node.js、.NET、Java、</st> <st c="47349">和 Go。</st><st c="47356">漏洞扫描每天至少运行一次，适用于过去 90 天内推送或过去</st> <st c="47475">30 天内拉取的镜像。</st><st c="47483">Defender for Containers 还支持保护 AWS 和 GCP 上的容器工作负载，但这超出了</st> <st c="47608">本主题的范围。</st> |
| **<st c="47619">运行时</st>** **<st c="47628">保护（Kubernetes 控制平面</st>** **<st c="47665">威胁检测）</st>** | <st c="47682">基于 Kubernetes 审计</st> <st c="47758">日志分析，检测 Kubernetes 中的可疑活动</st><st c="47770">。</st> |
| **<st c="47771">运行时保护（Kubernetes 工作负载</st>** **<st c="47812">威胁检测）</st>** | <st c="47829">在集群、节点和</st> <st c="47891">工作负载级别检测可疑活动。</st><st c="47907">这需要部署 Defender 传感器代理。</st> <st c="47964">这可以在订阅级别或单个集群级别启用。</st> |

<st c="48037">表 8.2 – Defender for Containers 功能</st>

<st c="48090">如在</st> *<st c="48109">表 8.2</st>*<st c="48118">中强调的那样，计划中的某些功能需要在 Kubernetes 集群上安装 Defender 传感器代理，而其他功能则不需要（这些称为无代理模式）。</st> <st c="48278">例如，存储在 ACR 中的镜像的漏洞评估不需要传感器。</st> <st c="48370">然而，要映射 AKS 集群中运行的容器的漏洞评估，我们</st> <st c="48455">需要部署传感器或启用 Kubernetes 的无代理发现</st> <st c="48519">功能。</st>

<st c="48533">备注</st>

<st c="48538">在 AKS 中对运行中的容器进行漏洞评估时传感器不会直接扫描运行中的容器。</st> <st c="48653">相反，它们会收集 Kubernetes 集群中容器工作负载的清单。</st> <st c="48739">然后，Defender for Containers 会将此清单与 ACR 中镜像的漏洞评估报告进行匹配。</st> <st c="48854">因此，报告只会显示来自已扫描 ACR 的运行容器的漏洞。</st> <st c="48978">如果运行的镜像来自未扫描的注册表，Defender for Containers 将无法显示其漏洞，从而可能产生一个安全漏洞，您需要</st> <st c="49149">考虑此问题。</st>

### <st c="49161">了解 Defender for Containers 的 Kubernetes 控制平面威胁检测能力</st>

<st c="49261">Defender for</st> <st c="49275">Containers 提供运行时威胁检测</st> <st c="49318">覆盖两个主要领域 – 在警报中带有`<st c="49747">K8S_</st>`前缀，并详细列出在</st> *<st c="49793">表 8.3</st>*<st c="49802">。</st>

| **<st c="49803">威胁检测类别 –</st>** **<st c="49832">暴露服务</st>** |
| --- |
| <st c="49848">在 Kubernetes 中暴露的带信任身份验证配置的 Postgres 服务</st> <st c="49931">检测到（</st>`<st c="49941">K8S_ExposedPostgresTrustAuth</st>`<st c="49970">）</st> |
| <st c="49972">Kubernetes 中暴露的 Postgres 服务，配置存在风险</st> <st c="50039">检测到（</st>`<st c="50049">K8S_ExposedPostgresBroadIPRange</st>`<st c="50081">）</st> |
| <st c="50083">暴露的 Kubeflow 仪表盘</st> <st c="50113">检测到（</st>`<st c="50123">K8S_ExposedKubeflow</st>`<st c="50143">）</st> |
| <st c="50145">暴露的 Kubernetes 仪表盘</st> <st c="50177">检测到（</st>`<st c="50187">K8S_ExposedDashboard</st>`<st c="50208">）</st> |
| <st c="50210">暴露的 Kubernetes 服务</st> <st c="50240">检测到（</st>`<st c="50250">K8S_ExposedService</st>`<st c="50269">）</st> |
| <st c="50271">在 AKS 中暴露的 Redis 服务</st> <st c="50303">检测到（</st>`<st c="50313">K8S_ExposedRedis</st>`<st c="50330">）</st> |
| **<st c="50332">威胁检测类别 –</st>** **<st c="50360">异常活动</st>** |
| <st c="50379">与 Kubernetes 关联的托管身份的</st> <st c="50383">异常活动（</st><st c="50451">预览）（</st>`<st c="50462">K8S_AbnormalMiActivity</st>`<st c="50485">）</st> |
| <st c="50487">异常的 Kubernetes 服务账户操作</st> <st c="50536">检测到（</st>`<st c="50546">K8S_ServiceAccountRareOperation</st>`<st c="50578">）</st> |
| <st c="50580">来自代理 IP 地址的 K8S API 请求</st> <st c="50619">检测到（</st>`<st c="50629">K8S_TI_Proxy</st>`<st c="50642">）</st> |
| <st c="50644">向 Kubernetes</st> <st c="50683">API 发出的可疑请求（</st>`<st c="50688">K8S.NODE_KubernetesAPI</st>`<st c="50711">）</st> |
| <st c="50713">对 Kubernetes</st> <st c="50752">仪表盘的可疑请求（</st>`<st c="50763">K8S.NODE_KubernetesDashboard</st>`<st c="50792">）</st> |
| <st c="50794">检测到 Kubernetes 渗透测试工具（</st>`<st c="50842">K8S_PenTestToolsKubeHunter</st>`<st c="50869">）</st> |
| **<st c="50871">威胁检测类别 – 特权提升</st>** **<st c="50920">和访问</st>** |
| <st c="50930">检测到带有敏感卷挂载的容器（</st>`<st c="50983">K8S_SensitiveMount</st>`<st c="51002">）</st> |
| <st c="51004">检测到新高</st> <st c="51013">特权角色</st> <st c="51029">（</st>`<st c="51039">K8S_HighPrivilegesRole</st>`<st c="51062">）</st> |
| <st c="51064">检测到特权容器（</st>`<st c="51097">K8S_PrivilegedContainer</st>`<st c="51121">）</st> |
| <st c="51123">检测到对</st> `<st c="51143">cluster-admin</st>` <st c="51156">角色的角色绑定（</st>`<st c="51172">K8S_ClusterAdminBinding</st>`<st c="51196">）</st> |
| <st c="51198">检测到</st> <st c="51207">创建了一个 Admission Webhooks 配置（</st>`<st c="51256">K8S_AdmissionController</st>`<st c="51280">）</st> |
| **<st c="51282">威胁检测类别 – 配置和</st>** **<st c="51328">资源修改</st>** |
| <st c="51350">Kubernetes 中的 CoreDNS 修改</st> <st c="51386">检测到（</st>`<st c="51396">K8S_CoreDnsModification</st>`<st c="51420">）</st> |
| <st c="51422">删除了 Kubernetes 事件（</st>`<st c="51449">K8S_DeleteEvents</st>`<st c="51466">）</st> |
| <st c="51468">在</st> `<st c="51491">kube-system</st>` <st c="51502">命名空间</st> <st c="51513">检测到新容器（</st>`<st c="51523">K8S_KubeSystemContainer</st>`<st c="51547">）</st> |
| **<st c="51549">威胁检测类别 –</st>** **<st c="51577">恶意活动</st>** |
| <st c="51597">检测到数字货币挖掘容器（</st>`<st c="51642">K8S_MaliciousContainerImage</st>`<st c="51670">）</st> |

<st c="51672">表 8.3 – 容器防护（Kubernetes 控制平面威胁检测）</st>

### <st c="51752">理解 Defender for Containers 的 Kubernetes 工作负载威胁检测能力</st>

<st c="51847">工作负载威胁检测使用在工作节点上的 Defender Sensor 代理收集安全</st> <st c="51941">事件进行分析。</st> <st c="51962">在撰写时，它可以检测 34 种威胁，范围包括对敏感数据的访问和可疑工具检测。</st> <st c="52082">这些检测的警报前缀为</st> `<st c="52116">K8S.NODE_</st>` <st c="52125">，并列在</st> *<st c="52158">表 8.4</st>*<st c="52167">中。</st>

| **<st c="52168">威胁检测类别 – 特权提升和</st>** **<st c="52222">高特权</st>** |
| --- |
| 从容器中尝试创建新的 Linux 命名空间</st> <st c="52298">检测到（</st>`<st c="52308">K8S.NODE_NamespaceCreation</st>`<st c="52335">）</st> |
| 容器内部运行具有高</st> <st c="52384">特权的命令（</st>`<st c="52396">K8S.NODE_PrivilegedExecutionInContainer</st>`<st c="52436">）</st> |
| 在特权容器中运行</st> `<st c="52472">模式（</st>`<st c="52478">K8S.NODE_PrivilegedContainerArtifacts</st>`<st c="52516">）</st> |
| **威胁检测类别 - 异常行为和</st>** **可疑活动</st>** |
| 清除了历史文件</st> <st c="52613">（</st>`<st c="52622">K8S.NODE_HistoryFileCleared</st>`<st c="52650">）</st> |
| 检测到不常见的连接尝试</st> <st c="52683">（</st>`<st c="52693">K8S.NODE_SuspectConnection</st>`<st c="52720">）</st> |
| 尝试停止</st> `<st c="52745">apt-daily-upgrade.timer</st>` <st c="52768">服务</st> <st c="52777">检测到（</st>`<st c="52787">K8S.NODE_TimerServiceDisabled</st>`<st c="52817">）</st> |
| 检测到可疑使用</st> `<st c="52850">nohup</st>` <st c="52855">命令（</st>`<st c="52865">K8S.NODE_SuspectNohup</st>`<st c="52887">）</st> |
| 检测到可疑使用</st> `<st c="52920">useradd</st>` <st c="52927">命令（</st>`<st c="52937">K8S.NODE_SuspectUserAddition</st>`<st c="52966">）</st> |
| 检测到可疑文件下载</st> <st c="52995">（</st>`<st c="53005">K8S.NODE_SuspectDownloadArtifacts</st>`<st c="53039">）</st> |
| 从已知恶意来源下载文件</st> <st c="53089">（</st>`<st c="53097">K8S.NODE_SuspectDownload</st>`<st c="53122">）</st> |
| 检测到可疑文件时间戳</st> <st c="53152">修改（</st>`<st c="53166">K8S.NODE_TimestampTampering</st>`<st c="53194">）</st> |
| 检测到可疑下载后运行</st> <st c="53227">活动（</st>`<st c="53237">K8S.NODE_DownloadAndRunCombo</st>`<st c="53266">）</st> |
| 使用</st> `<st c="53301">crypt-method</st>` <st c="53313">可能的密码更改检测到（</st>`<st c="53324">K8S.NODE_SuspectPasswordChange</st>`<st c="53355">）</st> |
| 潜在的端口转发到外部 IP</st> <st c="53401">地址（</st>`<st c="53410">K8S.NODE_SuspectPortForwarding</st>`<st c="53441">）</st> |
| 检测到潜在的反向 Shell</st> <st c="53469">（</st>`<st c="53479">K8S.NODE_ReverseShell</st>`<st c="53501">）</st> |
| 检测到与安全相关的进程终止</st> <st c="53542">（</st>`<st c="53552">K8S.NODE_SuspectProcessTermination</st>`<st c="53587">）</st> |
| 向 Kubernetes API 发出可疑请求</st> <st c="53628">（</st>`<st c="53633">K8S.NODE_KubernetesAPI</st>`<st c="53656">）</st> |
| <st c="53658">检测到对 Kubernetes 仪表盘的可疑请求</st> <st c="53693">（</st>`<st c="53704">K8S.NODE_KubernetesDashboard</st>`<st c="53733">）</st> |
| <st c="53735">在 Kubernetes 节点上检测到 Docker 构建操作</st> <st c="53785">（</st>`<st c="53791">K8S.NODE_ImageBuildOnNode</st>`<st c="53817">）</st> |
| **<st c="53819">威胁检测类别 – 恶意活动和</st>** **<st c="53870">已知威胁</st>** |
| <st c="53883">检测到类似常见 Linux 机器人行为（</st><st c="53932">预览）</st>（`<st c="53943">K8S.NODE_CommonBot</st>`<st c="53962">）</st> |
| <st c="53964">检测到与数字货币挖掘相关的行为</st> <st c="53972">（</st>`<st c="54015">K8S.NODE_DigitalCurrencyMining</st>`<st c="54046">）</st> |
| <st c="54048">检测到与数字货币挖掘相关的进程</st> <st c="54098">（</st>`<st c="54108">K8S.NODE_CryptoCoinMinerArtifacts</st>`<st c="54142">）</st> |
| <st c="54144">检测到可能的加密货币矿工下载</st> <st c="54180">（</st>`<st c="54190">K8S.NODE_CryptoCoinMinerDownload</st>`<st c="54223">）</st> |
| <st c="54225">检测到可能的后门</st> <st c="54245">（</st>`<st c="54255">K8S.NODE_LinuxBackdoorArtifact</st>`<st c="54286">）</st> |
| <st c="54288">检测到可能的命令行利用尝试</st> <st c="54325">（</st>`<st c="54334">K8S.NODE_ExploitAttempt</st>`<st c="54358">）</st> |
| <st c="54360">检测到以异常方式访问 SSH 授权密钥文件的进程</st> <st c="54427">（</st>`<st c="54432">K8S.NODE_SshKeyAccess</st>`<st c="54454">）</st> |
| <st c="54456">检测到可能的日志篡改活动</st> <st c="54490">（</st>`<st c="54500">K8S.NODE_SystemLogRemoval</st>`<st c="54526">）</st> |
| **<st c="54528">威胁检测类别 – 可疑</st>** **<st c="54567">工具检测</st>** |
| <st c="54582">检测到一个可能的恶意 Web Shell</st> <st c="54614">（</st>`<st c="54624">K8S.NODE_Webshell</st>`<st c="54642">）</st> |
| <st c="54644">检测到可能的攻击工具</st> <st c="54667">（</st>`<st c="54677">K8S.NODE_KnownLinuxAttackTool</st>`<st c="54707">）</st> |
| <st c="54709">检测到与 DDOS 工具包相关的指标</st> <st c="54751">（</st>`<st c="54761">K8S.NODE_KnownLinuxDDoSToolkit</st>`<st c="54792">）</st> |
| <st c="54794">检测到一个 MITRE Caldera 代理</st> <st c="54816">（</st>`<st c="54826">K8S.NODE_MitreCalderaTools</st>`<st c="54853">）</st> |
| <st c="54855">检测到一个</st> <st c="54857">可能的凭证访问工具</st> <st c="54889">（</st>`<st c="54899">K8S.NODE_KnownLinuxCredentialAccessTool</st>`<st c="54939">）</st> |
| **<st c="54941">威胁检测类别 – 访问</st>** **<st c="54979">敏感数据</st>** |
| <st c="54993">检测到对</st> `<st c="55008">kubelet kubeconfig</st>` <st c="55026">文件的访问</st> <st c="55032">（</st>`<st c="55042">K8S.NODE_KubeConfigAccess</st>`<st c="55068">）</st> |
| 访问云元数据服务已检测到（`K8S.NODE_ImdsCall`） |

表 8.4 – Defender for Containers（Kubernetes 工作负载威胁检测）

### 在大规模实施 Defender for Containers 计划

实施 Defender for Containers 是一个两步过程。

首先，我们需要在 MDC 环境设置中启用计划，方法是转到**Microsoft Defender for Cloud** → **管理** → **环境设置** → 选择您的管理组或订阅 → **设置** → **Defender 计划** → **云工作负载保护（CWP）**，然后切换**容器**为**开启**（*图 8.13*）。

![图 8.13 – 启用 Defender for Containers 计划](img/B19710_08_13.jpg)

图 8.13 – 启用 Defender for Containers 计划

启用计划后，我们需要启用漏洞管理并将 Defender Sensor 代理部署到我们的 Kubernetes 集群中。可以在订阅或管理组级别启用，使用自动配置选项，或者为单个集群启用。 在订阅级别启用它可以让我们大规模强制实施保护——启用后，所有现有的和新的 AKS 集群将自动**受到保护**。

要配置无代理漏洞评估和自动配置，请按照以下步骤操作：

1.  转到**Microsoft Defender for Cloud**。

1.  导航到**管理** → **环境设置**。

1.  选择您的管理组或订阅。

1.  转到**设置** → **Defender 计划** → **云工作负载保护（CWP）** → **容器**。

1.  在**监控****覆盖**栏目下选择**设置**。

1.  设置**Azure 中的 Defender 传感器**为**开启**（*图 8.14*）。

1.  <st c="57153">设置</st> **<st c="57158">无代理容器漏洞评估</st>** <st c="57202">为</st> **<st c="57206">开启</st>** <st c="57208">(</st>*<st c="57210">图 8</st>**<st c="57218">.14</st>*<st c="57221">)。</st>

![图 8.14 – 启用无代理漏洞管理和 Defender 传感器自动配置](img/B19710_08_14.jpg)

<st c="58414">图 8.14 – 启用无代理漏洞管理和 Defender 传感器自动配置</st>

<st c="58509">启用</st> <st c="58519">此功能将为 Azure 策略分配</st> **<st c="58553">应启用 Azure Kubernetes Service 集群的 Defender 配置文件</st>** <st c="58623">建议，并应用于</st> <st c="58646">所选范围。</st>

<st c="58661">如前所述，实施此计划是一个很好的起点，但请牢记其局限性。</st> <st c="58771">例如，该计划不涵盖其他 Azure 服务（如应用服务、容器实例、容器应用或函数应用）中运行的容器的漏洞管理或运行时安全性。</st> <st c="58977">此外，针对 AKS 集群的漏洞评估不会针对运行时检测到的容器映像执行单独的扫描。</st> <st c="59104">相反，它将已识别的运行时容器映像与从扫描的 Azure 容器注册表中获取的漏洞报告进行匹配。</st> <st c="59232">如果您的团队从公共或其他未经扫描的注册表部署映像，则需要使用</st> <st c="59340">其他方法解决这些问题。</st>

<st c="59354">容器的 Defender 的 Kubernetes 工作负载威胁检测能力主要集中于检测而不是阻止威胁。</st> <st c="59485">它主要依赖于基于行为的技术，专注于监视系统活动并将其与已知攻击模式进行比较。</st> <st c="59619">这种方法在识别已知的攻击指标方面非常有效，但面对新的和以前未见的攻击模式时可能无效，因为它严重依赖预定义的行为。</st> <st c="59823">基于行为的技术如果基线不能准确反映</st> <st c="59926">合法行为，也可能触发误报。</st>

<st c="59947">其他第三方安全解决方案提供商支持基于工作负载的基于 AI 的检测，有更好的机会检测不匹配任何已知模式的新和不断发展的威胁，提供了行为基础系统所缺乏的适应性水平。</st> <st c="60200">例如，Palo Alto Network 的 Prisma Cloud 使用此技术来学习部署容器的预期行为，并自动警报或阻止任何超出</st> <st c="60376">预期操作的行为。</st>

<st c="60393">另一个</st> <st c="60402">需要考虑的限制是 Windows 容器工作负载。</st> <st c="60457">在 34 项工作负载威胁检测中，仅有三项支持 Windows 节点。</st> <st c="60543">如果您的组织有大量 Windows 容器，您需要使用</st> <st c="60660">其他方法来解决运行时安全问题。</st>

<st c="60674">理论部分完成后，让我们进入 Azure 门户进行</st> <st c="60747">一些实现。</st>

# <st c="60767">动手练习 – 在 Azure 上进行持续安全监控</st>

<st c="60827">在本</st> <st c="60836">练习中，我们将完成以下任务：</st>

+   **<st c="60883">任务 1</st>** <st c="60890">– 实现和</st> <st c="60910">操作化 CSPM</st>

+   **<st c="60931">任务 2</st>** <st c="60938">– 实现和操作化持续容器</st> <st c="60996">工作负载保护</st>

## <st c="61015">任务 1 – 实现和操作化 CSPM</st>

<st c="61063">在本</st> <st c="61072">任务中，我们将涵盖 MDC，其中一个主要支柱是 CSPM。</st> <st c="61136">MDC</st> <st c="61140">是一个</st> **<st c="61145">云原生应用保护平台</st>** <st c="61189">(</st>**<st c="61191">CNAPP</st>**<st c="61196">)，它通过以下功能</st> <st c="61204">从端到端保护您的云应用</st> <st c="61237">：</st> <st c="61248">使用</st> <st c="61258">以下能力：</st>

+   **<st c="61281">DevSecOps</st>**<st c="61291">：在代码层面统一多云和多管道环境中的安全管理</st><st c="61380">。</st>

+   **<st c="61391">CSPM</st>**<st c="61396">：识别并共享云基础设施中的风险修复</st><st c="61445">。</st>

+   **<st c="61466">云工作负载姿态平台 (CWPP)</st>**<st c="61505">：为服务器、容器、存储及</st> <st c="61570">其他工作负载提供保护功能</st><st c="61585">。</st>

<st c="61586">Defender for Cloud 提供以下</st> <st c="61629">CSPM 服务：</st>

+   **<st c="61644">基础 CSPM</st>**<st c="61662">：对于已加入 Defender for Cloud 的订阅和帐户，默认启用此功能。</st> <st c="61723">此 CSPM 功能是免费的。</st> <st c="61773">包括安全建议、资产清单、安全评分、使用 Azure 工作簿的数据可视化和报告、数据导出、工作流自动化、修复工具以及 Microsoft 云</st> <st c="62030">安全基准等功能。</st>

+   **<st c="62049">Defender CSPM</st>**<st c="62063">：在现有的基础 CSPM 功能之上提供更先进的安全姿态功能。</st> <st c="62184">此计划需要付费，并且</st> <st c="62215">是可选的。</st>

<st c="62227">让我们</st> <st c="62234">在 Microsoft Azure 上启用 CSPM 功能：</st>

1.  <st c="62278">首先，登录</st> <st c="62291">到 Azure 门户。</st>

1.  <st c="62314">确认</st> <st c="62323">你的订阅至少有以下其中一个角色 – 所有者、贡献者，</st> <st c="62408">或阅读者。</st>

1.  <st c="62418">在 Microsoft Azure 搜索栏上搜索</st> **<st c="62430">Microsoft Defender for Cloud</st>** <st c="62458">然后</st> <st c="62503">选择它。</st>

1.  <st c="62513">Defender for Cloud</st> **<st c="62518">概述页面将会打开，并且已经启用在你的订阅中具备基础功能，包括基础 CSPM、建议、资产清单、Workbooks、安全评分以及符合微软云安全基准的法规合规性。</st>**

1.  <st c="62795">浏览各种功能，强调风险和建议</st> <st c="62872">每个资产。</st>

1.  <st c="62882">要启用 Defender CSPM，请导航到</st> **<st c="62920">管理下的环境设置</st>** <st c="62940">左侧。</st>

![图 8.15 – 在 MDC 上选择环境设置](img/B19710_08_15.jpg)

<st c="63131">图 8.15 – 在 MDC 上选择环境设置</st>

1.  <st c="63182">选择</st> <st c="63190">你想要保护的订阅。</st> <st c="63207">这将带你进入</st> <st c="63254">Defender</st> <st c="63263">计划。</st>

1.  <st c="63269">在</st> **<st c="63276">云安全姿势管理 (CSPM)</st>**<st c="63316">下，切换</st> **<st c="63329">Defender CSPM</st>** <st c="63342">状态到</st> **<st c="63353">开启</st>**<st c="63355">。</st>

![图 8.16 – 启用 Defender CSPM](img/B19710_08_16.jpg)

<st c="64135">图 8.16 – 启用 Defender CSPM</st>

1.  <st c="64171">点击</st> **<st c="64181">设置</st>** <st c="64189">在</st> **<st c="64196">Defender CSPM 监控覆盖下</st>** <st c="64229">并启用所有的扩展，如下面的屏幕截图所示。</st> <st c="64299">花些时间去浏览所有组件、描述和</st> <st c="64366">Defender 计划。</st>

![图 8.17 – 启用 Defender CSPM 扩展](img/B19710_08_17.jpg)

<st c="66172">图 8.17 – 启用 Defender CSPM 扩展</st>

1.  <st c="66223">选择</st> **<st c="66231">保存</st>**<st c="66235">。</st>

<st c="66236">我们已经</st> <st c="66245">看到如何</st> <st c="66254">启用 CSPM。</st> <st c="66274">花些时间去检查启用后的额外</st> <st c="66315">发现</st> <st c="66324">Defender CSPM。</st>

## <st c="66353">任务 2 – 实施和运营持续的容器工作负载保护</st>

<st c="66437">在这个</st> <st c="66446">任务中，我们希望</st> <st c="66463">利用 Defender CSPM</st> <st c="66486">来启用</st> <st c="66496">无代理容器安全，并识别容器注册表和 Kubernetes 中的风险。</st> <st c="66592">在上一个任务中，我们启用了</st> **<st c="66629">Kubernetes 的无代理发现</st>** <st c="66663">和</st> **<st c="66668">无代理容器漏洞评估</st>** <st c="66712">扩展。</st> <st c="66725">这就是启用 Defender CSPM 中的无代理容器安全所需要的全部步骤。</st>

<st c="66802">让我们在</st> <st c="66837">Microsoft Azure 上启用 CSPM 功能：</st>

1.  <st c="66853">首先，让我们通过使用云命令行在 AKS 集群中集成我们的 Azure 容器注册表</st> <st c="66949">命令：</st>

    ```
    <st c="66962">az aks update -n <AKSCluster> -g <ResourceGroup> --attach-acr <your-acr-name></st>
    ```

1.  <st c="67040">导航</st> <st c="67050">到 Azure 门户中的 Kubernetes 服务，并在</st> **<st c="67108">Kubernetes 资源</st>** <st c="67128">|</st> **<st c="67131">命名空间</st>** <st c="67141">下确认命名空间是否存在。</st>

1.  <st c="67172">返回</st> <st c="67181">到 MDC，查看所有安全发现，位于</st> **<st c="67229">推荐</st>**<st c="67244">下，然后查看在</st> **<st c="67288">Cloud</st>** **<st c="67294">Security Explorer</st>**<st c="67311">中的查询。</st>

1.  <st c="67312">最后，让我们</st> <st c="67327">点击</st> **<st c="67336">工作负载保护</st>** <st c="67356">在</st> **<st c="67363">Cloud Security</st>**<st c="67377">下；然后我们可以看到 Defender</st> <st c="67426">for Cloud 的所有覆盖范围。</st>

![图 8.18 – 审查 Defender for Cloud 覆盖范围](img/B19710_08_18.jpg)

<st c="67797">图 8.18 – 审查 Defender for Cloud 覆盖范围</st>

1.  <st c="67848">在</st> **<st c="67855">高级保护</st>**<st c="67874">下，点击</st> **<st c="67885">容器镜像扫描</st>**<st c="67909">。容器</st> <st c="67923">镜像漏洞评估</st> <st c="67954">会扫描你的注册表，查找</st> **<st c="67978">常见已知漏洞</st>** <st c="68008">（</st>**<st c="68010">CVE</st>**<st c="68014">）并为</st> <st c="68066">每个镜像提供详细的漏洞报告。</st>

![图 8.19 – 审查容器镜像扫描](img/B19710_08_19.jpg)

<st c="68428">图 8.19 – 审查容器镜像扫描</st>

1.  <st c="68476">向下滚动，查看受影响的资源并探索</st> <st c="68531">发现的漏洞。</st>

<st c="68553">在</st> <st c="68561">练习中，我们已经</st> <st c="68580">学习了如何利用 Defender for Cloud 的各种功能来保护我们的资源，使用</st> <st c="68676">Defender CSPM。</st>

# <st c="68690">总结</st>

<st c="68698">恭喜！</st> <st c="68716">你已经成功地完成了本书的学习。</st> <st c="68768">在本章中，我们讨论了如何使用 Azure 策略实现运行时安全门控，并介绍了与 Kubernetes 准入控制器集成的 Azure 策略。</st> <st c="68933">我们还讨论了保护现代云应用的挑战，以及 Azure 所提供的一些本地能力。</st>

<st c="69066">展望未来，以下是我们认为将塑造 DevSecOps 未来的一些趋势：</st>

+   **<st c="69155">自动化</st>**<st c="69166">：自动化结合 AI 将推动操作效率。</st> <st c="69233">安全团队将专注于战略性任务，而自动化系统将处理操作性职能。</st> <st c="69338">“从设计开始就确保安全”这一概念将会得到广泛推行，确保安全从</st> <st c="69427">一开始就被纳入设计。</st>

+   **<st c="69438">工具整合</st>**<st c="69457">：组织将整合安全工具，以简化流程并降低成本。</st> <st c="69548">将可观察性和监控功能合并到一个平台中，将提供一个全面的安全态势视图。</st> <st c="69649">

+   **<st c="69668">基础设施即代码（IaC）</st>**<st c="69672">：IaC 将在其中扮演至关重要的角色，传统的手动 IT 基础设施管理将让位于更高效、基于代码的方式，尤其是随着</st> <st c="69842">云计算的增长。</st>

+   **<st c="69858">修复</st>**<st c="69870">：迅速解决漏洞和安全问题将成为重点，防止风险在</st> <st c="69976">升级之前蔓延。</st>

+   **<st c="69990">软件材料清单（SBOMs）</st>**<st c="70025">：SBOM 的演进将通过提供关于软件组件</st> <st c="70137">和依赖关系的详细信息，增强透明度。</st>

<st c="70154">这些趋势已经被一些前沿组织采纳，但我们认为它们将会被更广泛地应用。</st> <st c="70286">保持领先于这些趋势将帮助组织为应对不断变化的网络安全挑战做好准备。</st> <st c="70416">特别是在 DevOps 领域。</st>

# <st c="70426">进一步阅读</st>

<st c="70442">想了解更多关于本章讨论的主题，请查看以下内容：</st> 

+   <st c="70538">MDC</st> <st c="70543">文档：</st> [<st c="70558">https://learn.microsoft.com/en-us/azure/defender-for-cloud/</st>](https://learn.microsoft.com/en-us/azure/defender-for-cloud/)<st c="70617">。</st>
