# <st c="0">5</st>

# <st c="2">实施源代码控制安全</st>

<st c="38">在前一章中，我们将 DevOps 代码开发过程分为两个关键阶段：提交前阶段和源代码管理阶段。</st> <st c="194">这种划分是为了简化我们关于安全集成的讨论。</st> <st c="269">我们已经讨论了提交前阶段的安全实践。</st> <st c="341">接下来，我们将把焦点转向</st> <st c="402">源代码控制中的安全方面。</st>

<st c="417">源代码控制在 DevOps 中是通过</st> **<st c="505">源代码管理</st>** <st c="530">(</st>**<st c="532">SCM</st>**<st c="535">) 系统（如</st> <st c="553">Git 或</st> **<st c="560">团队基础版本控制</st>** <st c="591">(</st>**<st c="593">TFVC</st>**<st c="597">））来组织和跟踪项目代码的方式。</st> <st c="601">在源代码控制中实施 DevSecOps 时，重要的是要考虑如何管理和保护代码仓库。</st> <st c="724">如果代码仓库的访问被破坏，或保护措施容易被绕过，那么很难信任其中存储的代码。</st> <st c="854">本章结束时，你将对以下关键领域有一个深入的了解：</st> <st c="942">关键领域：</st>

+   <st c="952">理解 DevOps 的提交后阶段</st> <st c="989">的内容</st>

+   <st c="998">保障源代码</st> <st c="1019">环境的安全</st>

+   <st c="1035">解决源代码控制中的常见编码安全问题</st> <st c="1080">源代码控制</st>

<st c="1094">这些主题将为你提供必要的知识和技能，以将安全实践集成到 DevOps 工作流的源代码控制阶段。</st> <st c="1247">让我们</st> <st c="1253">深入了解吧！</st>

# <st c="1261">技术要求</st>

<st c="1284">要跟随本章的指示，你将需要</st> <st c="1354">以下资源：</st>

+   <st c="1368">一台带有</st> <st c="1379">互联网连接的 PC</st>

+   <st c="1398">一个活跃的</st> <st c="1409">Azure 订阅</st>

+   <st c="1427">一个 Azure</st> <st c="1437">DevOps 组织</st>

+   <st c="1456">一个 GitHub</st> <st c="1466">企业组织</st>

# <st c="1489">理解 DevOps 的提交后阶段</st>

<st c="1535">在本地提交代码更改后，开发者的下一步是将这些更改同步到</st> <st c="1638">中央远程代码库，如</st> *<st c="1685">图 5</st>**<st c="1693">.1</st>* <st c="1695">(</st>`<st c="1730">git push</st>` <st c="1738">操作。</st> <st c="1750">中央代码库作为所有参与项目的开发者共同存储代码的地方：</st>

![图 5.1 – DevOps 的代码开发阶段](img/B19710_05_01.jpg)

<st c="2059">图 5.1 – DevOps 的代码开发阶段</st>

<st c="2108">中央仓库可以托管在自托管或云托管的源代码管理平台上。</st> <st c="2219">根据 2022 年 Stack Overflow 开发者调查，GitHub 在个人和专业项目中都是最受欢迎的源代码管理平台。</st> <st c="2376">其他平台，如 GitLab、Bitbucket 和 Azure Repos，在专业环境中更为常见（</st>*<st c="2481">图 5</st>**<st c="2490">.2</st>*<st c="2492">）。</st> <st c="2496">在</st> *<st c="2499">第一章</st>*<st c="2508">中，我们提供了微软两个 DevOps 平台的概述：GitHub 和 Azure DevOps。</st> <st c="2596">这两个平台都提供源代码管理</st> <st c="2632">服务。</st> <st c="2653">在 GitHub 中，我们有</st> **<st c="2672">GitHub 仓库</st>**<st c="2691">，而在 Azure DevOps 中，我们</st> <st c="2717">有</st> **<st c="2722">Azure Repos</st>**<st c="2733">。GitHub 仓库和 Azure Repos 都提供自托管和云托管选项。</st> <st c="2819">自托管版本提供更多控制权，但需要更多管理，而云托管版本管理开销较小，但在</st> <st c="2909">某些情况下可能会提供较少的控制。</st> <st c="2978">这些场景包括：</st>

![图 5.2 – Stack Overflow 的源代码管理平台调查（2022）](img/B19710_05_02.jpg)

<st c="3183">图 5.2 – Stack Overflow 的源代码管理平台调查（2022）</st>

<st c="3250">注意</st>

<st c="3255">你可能会</st> <st c="3266">遇到</st> *<st c="3286">版本控制</st>* <st c="3301">和</st> *<st c="3306">源代码管理</st>* <st c="3320">这两个术语在各种</st> <st c="3332">文档和文章中。</st> <st c="3360">这两个术语指的是同一件事，可以互换使用。</st> <st c="3428">在本书中，我们将使用术语</st> *<st c="3471">源代码管理</st>* <st c="3485">以保持一致性。</st>

## <st c="3502">了解源代码管理阶段的安全措施</st>

<st c="3577">鉴于其</st> <st c="3588">作为将要部署到生产环境的代码的</st> *<st c="3609">真相来源</st>* <st c="3624">的关键作用，确保代码在源代码管理中得到保护并经过安全性测试是至关重要的。</st> <st c="3763">在这个阶段，我们将关注两类主要的安全措施：</st>

+   **<st c="3854">保护 SCM 环境的安全</st>**<st c="3883">：这一类措施强调保护存储代码的环境。</st> <st c="3966">它涉及确保源代码管理本身的完整性和安全，防止未经授权的访问、数据泄露以及其他潜在的安全威胁。</st> <st c="4146">SCM 系统的安全。</st>

+   **<st c="4157">解决常见的编码安全问题</st>**<st c="4198">：这与前一章讨论的目标类似，但应用于源代码控制的背景。</st> <st c="4312">它重点识别并纠正代码中常见的安全漏洞，无论是在代码合并到主代码库之前还是之后。</st> <st c="4453">这包括定期审查代码中的安全缺陷（无论是第三方还是第一方的），实施自动化安全扫描，并确保遵循最佳编码实践以</st> <st c="4638">最小化风险。</st>

<st c="4653">下图展示了我们已经讨论过的两个类别：</st>

![图 5.3 – DevOps 源代码控制阶段的两大安全措施类别](img/B19710_05_03.jpg)

<st c="4795">图 5.3 – DevOps 源代码控制阶段的两大安全措施类别</st>

<st c="4893">让我们从</st> <st c="4906">解决第一类问题——保护源代码管理环境</st> <st c="4966">开始。</st>

# <st c="4989">保护源代码管理环境</st>

<st c="5037">在 DevOps 工作流中，保护源代码管理平台对于维护</st> <st c="5134">软件发布的完整性至关重要。</st> <st c="5170">为了实现这一点，我们强烈建议遵循</st> *<st c="5252">源代码</st>* <st c="5263">部分中概述的指导方针</st> <st c="5272">，这些指导方针来自</st> *<st c="5279">互联网安全中心（CIS）软件供应链</st>* *<st c="5336">安全指南</st>*<st c="5350">。</st>

<st c="5351">CIS 软件供应链安全指南</st>

<st c="5392">《</st> *<st c="5397">CIS 软件供应链安全指南</st>* <st c="5437">提供了一个全面的框架</st> <st c="5473">用于安全的软件供应链管理。</st> <st c="5518">截至写作时，该指南包含 100 多条建议，分为五大类：源代码、构建流水线、依赖关系、工件和部署。</st> <st c="5693">要访问完整指南，你可以从</st> <st c="5739">下载</st> [<st c="5744">https://www.cisecurity.org/insights/white-papers/cis-software-supply-chain-security-guide</st>](https://www.cisecurity.org/insights/white-papers/cis-software-supply-chain-security-guide)<st c="5833">。</st>

<st c="5834">该指南</st> <st c="5845">提供了一系列建议，涵盖</st> *<st c="5884">五个关键领域</st>* <st c="5898">以安全地管理源代码平台：</st>

+   **<st c="5940">安全地管理代码仓库</st>**<st c="5976">：本节包括 7 条建议，重点关注代码仓库的安全性，确保它们得到正确设置、维护，并防止未经授权的访问</st> <st c="6157">或泄露。</st>

+   **<st c="6169">安全管理代码贡献</st>**<st c="6206">：本节包括 13 项建议，重点关注如何安全地处理代码贡献。</st> <st c="6300">这些建议包括审查、接受和合并来自不同开发者/贡献者的贡献的安全指导方针。</st> <st c="6419">这些操作应以安全的方式进行。</st>

+   **<st c="6433">安全管理代码更改</st>**<st c="6464">：本节包括 19 项建议，指导如何安全地管理代码库中的代码更改。</st> <st c="6561">它包括审查、测试和批准更改的指导方针，以确保这些更改不会</st> <st c="6653">引入漏洞。</st>

+   **<st c="6679">安全管理代码风险</st>**<st c="6708">：本节包括 6 项建议，提供了识别、评估和缓解与代码开发相关的风险的指导方针。</st> <st c="6849">其中包括定期进行安全审计和</st> <st c="6903">风险评估的做法。</st>

+   **<st c="6920">安全管理第三方集成</st>**<st c="6963">：最后一节包含 3 项建议，专注于如何安全地将第三方工具集成到源代码控制库中。</st> <st c="7093">该部分强调了对这些集成进行安全漏洞审查并维护其更新的重要性。</st> <st c="7197">确保其安全性。</st>

<st c="7211">由于本书篇幅有限，我们无法涵盖所有建议的实施细节。</st> <st c="7306">然而，我们将重点介绍一些</st> <st c="7338">关键建议。</st>

## <st c="7347">安全管理代码库</st>

<st c="7383">确保代码库的安全的起点是确保这些库在创建和维护过程中都是安全的，保护代码的整个生命周期。</st> <st c="7481">与其强制执行一个适用于所有情况的代码库生命周期模型（这种模型很少有效），不如更加有效地专注于定义组织</st> *<st c="7706">标准</st>* <st c="7715">，明确如何安全地设置和操作代码库。</st> <st c="7777">为了达到最佳的安全效果，工程团队和安全团队需要共同合作，制定这些标准。</st> <st c="7896">他们应该考虑不同团队的工作方式，以确保这些标准既切实可行又有效。</st> <st c="7976">确保在实施过程中可以真正发挥作用。</st>

<st c="7990">随着组织的成熟，这些标准应转化为自动化流程。</st> <st c="8079">这样，新的安全代码库可以快速建立，并与组织的安全需求保持一致，同时减少手动操作中常出现的错误。</st> <st c="8262">这种方法不仅可以提升安全性，还能使设置代码库的过程</st> <st c="8355">更加高效。</st>

<st c="8370">以下是该领域的一些指导方针。</st> <st c="8429">我们将讨论如何在 GitHub 和</st> <st c="8486">Azure DevOps 中实施这些指导方针。</st>

## <st c="8499">推荐 1 – 确保仓库创建仅限于特定成员</st>

<st c="8578">在 GitHub 中，当</st> <st c="8595">在组织内设置仓库时，有三种可见性选项：</st> **<st c="8679">公开</st>**<st c="8685">，</st> **<st c="8687">私有</st>**<st c="8694">，和</st> **<st c="8700">内部</st>**<st c="8708">。</st> **<st c="8710">公开</st>** <st c="8716">仓库对所有人可见，包括非组织成员。</st> **<st c="8791">私有</st>** <st c="8798">仓库仅对已授权的组织成员可见。</st> <st c="8881">最后，</st> **<st c="8890">内部</st>** <st c="8898">仓库对同一企业内任何组织的所有成员可见。</st> <st c="8987">无论使用哪种可见性选项，保护代码安全非常重要，以确保只有授权用户能够访问并</st> <st c="9110">修改它。</st>

<st c="9120">默认情况下，所有组织成员都可以创建任何类型的仓库（</st>*<st c="9211">图 5</st>**<st c="9220">.4</st>*<st c="9222">）。</st> <st c="9226">然而，修改此默认设置以</st> <st c="9289">增强安全性是一个好做法：</st>

![图 5.4 – GitHub 组织中的默认仓库创建权限](img/B19710_05_04.jpg)

<st c="9477">图 5.4 – GitHub 组织中的默认仓库创建权限</st>

<st c="9553">我们可以</st> <st c="9561">要么完全禁止成员创建仓库，要么限制他们可以创建的仓库类型。</st> <st c="9707">此更改可以在组织级别进行，也可以在企业级别进行，如果您有企业账户并希望在多个组织中应用更改。</st>

+   `<st c="9936">https://github.com/enterprises/{ENTERPRISE_NAME}</st>`<st c="9985">) 访问</st> `<st c="10051">ENTERPRISE_NAME</st>` <st c="10066">是您有效的 GitHub</st> <st c="10106">企业名称的占位符。</st>

+   **<st c="10122">组织级别</st>**<st c="10141">：在</st> **<st c="10153">组织设置</st>** <st c="10174">页面，访问</st> **<st c="10187">成员权限</st>** <st c="10204">|</st> **<st c="10207">仓库创建</st>**<st c="10226">：</st>

![图 5.5 – 修改成员的默认仓库创建权限](img/B19710_05_05.jpg)

<st c="10656">图 5.5 – 修改成员的默认仓库创建权限</st>

<st c="10733">无论此设置如何，某些组织级别的角色仍然保留创建仓库的权限。</st> <st c="10854">这些角色包括</st> **<st c="10874">所有者</st>**<st c="10880">、</st> **<st c="10882">版主</st>**<st c="10892">和</st> **<st c="10898">安全管理员</st>** <st c="10915">(</st>*<st c="10917">图 5</st>**<st c="10925">.4</st>*<st c="10927">)。</st> <st c="10931">此外，在企业级别，</st> **<st c="10974">企业所有者</st>** <st c="10990">角色具有修改组织级别权限的特权，因此可以作为创建仓库的路径。</st>

<st c="11114">在 Azure DevOps 中，管理仓库创建权限的流程与 GitHub 略有不同，这是由于平台结构的原因。</st> <st c="11255">Azure Repos 中的仓库可以设置为</st> **<st c="11297">公开</st>** <st c="11303">或</st> **<st c="11307">私有</st>**<st c="11314">。一个</st> **<st c="11318">公开</st>** <st c="11324">仓库对所有人开放，包括组织外的人。</st> <st c="11407">另一方面，</st> **<st c="11428">私有</st>** <st c="11435">仓库仅对已被特别授权的组织成员可见。</st> <st c="11530">Azure DevOps 没有</st> <st c="11557">像 GitHub 那样的</st> *<st c="11560">内部</st>* <st c="11568">可见性选项，主要是因为它不支持企业账户结构。</st> <st c="11667">为了增强安全性，你可以通过禁用在 Azure DevOps 组织内创建公开项目的选项来限制公开仓库的创建。</st> <st c="11830">此更改会影响组织中的所有成员，无论其角色或权限级别如何，从而阻止任何人创建公开仓库。</st> <st c="11982">要实现这一点，我们可以导航至</st> **<st c="12020">Azure DevOps</st>** <st c="12032">|</st> **<st c="12035">组织设置</st>** <st c="12056">|</st> **<st c="12059">安全</st>** <st c="12067">|</st> **<st c="12070">策略</st>** <st c="12078">|</st> **<st c="12081">安全策略</st>** <st c="12098">|</st> **<st c="12101">允许公开项目</st>**<st c="12122">。微软最近宣布此选项已默认禁用</st> <st c="12179">。</st>

<st c="12190">默认情况下，只有被分配以下角色的用户才能在</st> <st c="12278">Azure DevOps</st> <st c="12278">中创建仓库：</st>

+   **<st c="12291">组织级别</st>**<st c="12310">：项目集合管理员；项目集合服务账户；项目集合有效用户；项目集合构建管理员；项目集合构建服务账户；项目集合代理服务账户；项目集合测试服务账户</st>

+   **<st c="12584">项目级别</st>**<st c="12598">：</st> <st c="12601">项目管理员</st>

<st c="12623">我们可以通过严格控制角色分配来实施</st> <st c="12687">此推荐。</st>

## <st c="12707">推荐 2 – 确保敏感仓库操作仅限特定成员执行</st>

<st c="12799">某些</st> <st c="12808">仓库操作因其潜在的恶意攻击风险，被认为是高风险或敏感的。</st> <st c="12966">这包括如删除仓库、分叉仓库和更改仓库可见性等操作。</st> <st c="13052">建议限制允许执行</st> <st c="13132">这些操作的成员数量。</st>

<st c="13149">要限制谁可以删除仓库并更改其在 GitHub 上的可见性，请前往</st> **<st c="13235">组织</st>** <st c="13247">|</st> **<st c="13250">设置</st>** <st c="13258">|</st> **<st c="13261">访问</st>** <st c="13267">|</st> **<st c="13270">成员权限</st>** <st c="13287">|</st> **<st c="13290">管理员仓库权限</st>**<st c="13318">。取消勾选</st> **<st c="13344">允许成员删除或转移该组织的仓库</st>** <st c="13414">和</st> **<st c="13419">允许成员更改该组织仓库的可见性</st>**<st c="13488">，然后保存</st> <st c="13500">您的更改。</st>

<st c="13513">要</st> <st c="13517">限制谁可以在 Azure DevOps 项目中删除仓库，请前往</st> **<st c="13588">项目设置</st>** <st c="13604">|</st> **<st c="13607">仓库</st>** <st c="13612">|</st> **<st c="13615">仓库</st>** <st c="13627">|</st> **<st c="13630">安全</st>** <st c="13638">并编辑该用户或组的权限（</st>*<st c="13687">图 5</st>**<st c="13696">.6</st>*<st c="13698">）：</st>

![图 5.6 – 配置删除仓库的权限](img/B19710_05_06.jpg)

<st c="14423">图 5.6 – 配置删除仓库的权限</st>

<st c="14485">默认情况下，Azure DevOps 项目中的贡献者角色可以</st> <st c="14551">分叉仓库。</st>

## <st c="14569">推荐 3 – 确保定期审查和归档非活动仓库</st>

<st c="14658">非活动仓库可能成为安全隐患或杂乱无章。</st> <st c="14725">例如，它们可能会导致</st> <st c="14754">误报，使安全团队花费宝贵时间处理无关紧要的问题。</st> <st c="14828">建议定期审查此类仓库，以确定是否应该将其归档。</st> <st c="14925">这样做不仅能提高安全性，还能帮助保持监控环境的清洁，避免</st> <st c="15023">不必要的干扰。</st>

<st c="15048">要审查 GitHub 中最近的仓库相关活动，请进入仓库，然后点击</st> **<st c="15143">洞察</st>**<st c="15151">。审查</st> **<st c="15164">脉冲</st>**<st c="15169">、</st> **<st c="15171">提交</st>**<st c="15178">和</st> **<st c="15184">代码</st>** **<st c="15189">频率</st>** <st c="15198">区域：</st>

![图 5.7 – 审查 GitHub 最近的代码仓库活动](img/B19710_05_07.jpg)

<st c="15585">图 5.7 – 审查 GitHub 最近的代码仓库活动</st>

<st c="15649">要审查 Azure DevOps 项目的最近仓库相关活动，请导航到 Azure DevOps 项目，选择</st> **<st c="15770">概览</st>** <st c="15778">|</st> **<st c="15781">摘要</st>**<st c="15788">，并审查</st> **<st c="15805">项目统计信息</st>** <st c="15818">区域，特别是最近的提交和</st> <st c="15859">拉取请求：</st>

![图 5.8 – Azure DevOps 项目概览](img/B19710_05_08.jpg)

<st c="16301">图 5.8 – Azure DevOps 项目概览</st>

<st c="16342">这些</st> <st c="16348">信息也可以通过 API 获取，用于生成自动化报告，虽然你也可以实施第三方解决方案，以更</st> <st c="16513">简化的方式呈现这些信息。</st>

## <st c="16529">推荐 4 – 应创建启用审计的仓库</st>

<st c="16601">在发生安全漏洞时，审计对识别和分析攻击者在我们环境中的</st> <st c="16704">行为至关重要。</st> <st c="16736">从主动的角度来看，我们可以利用日志监控可疑的访问模式，这些模式可能是恶意活动的迹象，或违反了关键的</st> <st c="16887">组织政策。</st>

<st c="16909">要在 GitHub Enterprise 中启用仓库活动的事件日志，请按照</st> <st c="16989">以下步骤操作：</st>

1.  <st c="17001">进入你的 GitHub</st> <st c="17020">组织的</st> **<st c="17035">设置</st>**<st c="17043">。</st>

1.  <st c="17044">选择</st> **<st c="17056">归档</st>** <st c="17063">|</st> **<st c="17066">日志</st>** <st c="17070">|</st> **<st c="17073">审计</st>** **<st c="17079">日志</st>** <st c="17082">部分。</st>

1.  <st c="17091">审计日志默认启用。</st> <st c="17129">但是，为了确保源 IP 信息也被记录，请点击</st> **<st c="17197">设置</st>** <st c="17205">并启用</st> **<st c="17221">启用源 IP</st>** **<st c="17238">披露</st>** <st c="17248">选项：</st>

![图 5.9 – 审查 GitHub 审计日志设置](img/B19710_05_09.jpg)

<st c="17815">图 5.9 – 审查 GitHub 审计日志设置</st>

<st c="17863">默认情况下，GitHub 跟踪各种仓库事件，包括创建、修改、删除以及其他重要操作。</st> <st c="17992">要全面了解 GitHub 审计日志中记录的事件，请参考 GitHub 官方文档中的</st> *<st c="18116">审计日志事件</st>* <st c="18132">，链接如下：</st> <st c="18139">https://docs.github.com/en/enterprise-cloud@latest/organizations/keeping-your-organization-secure/managing-security-settings-for-your-organization/audit-log-events-for-your-organization</st><st c="18324">。</st>

<st c="18325">要为 Azure Repos 中与仓库相关的活动设置事件日志，请按照</st> <st c="18407">以下步骤操作：</st>

1.  <st c="18419">前往</st> **<st c="18432">组织设置</st>**<st c="18453">。</st>

1.  <st c="18454">选择</st> **<st c="18462">安全性</st>**<st c="18470">。</st>

1.  <st c="18471">前往</st> <st c="18475">**政策**</st> <st c="18486">。</st>

1.  <st c="18487">启用</st> **<st c="18499">审计日志</st>** **<st c="18509">事件</st>** <st c="18515">选项：</st>

![图 5.10 – 在 Azure DevOps 中启用审计日志](img/B19710_05_10.jpg)

<st c="18856">图 5.10 – 在 Azure DevOps 中启用审计日志</st>

<st c="18905">开启此功能后，我们将能够记录与仓库相关的各种事件，如创建、分叉、修改、启用、禁用、删除和恢复删除。</st> <st c="19085">有关 Azure DevOps 审计的所有事件的完整列表，请参阅官方</st> <st c="19183">文档：</st> [<st c="19198">https://learn.microsoft.com/en-us/azure/devops/organizations/audit/auditing-events?view=azure-devops</st>](https://learn.microsoft.com/en-us/azure/devops/organizations/audit/auditing-events?view=azure-devops)<st c="19298">。</st>

<st c="19299">注意</st>

<st c="19304">许多组织将这些日志发送到 SIEM 解决方案中，以便进一步汇总和分析。</st> <st c="19397">例如，可以使用 GitHub 的 Sentinel 连接器将 GitHub 审计日志</st> <st c="19484">导入 Microsoft Sentinel。</st> <st c="19509">更多信息，请参阅</st> <st c="19539">此处：</st> [<st c="19545">https://learn.microsoft.com/en-us/azure/sentinel/data-connectors/github-enterprise-audit-log</st>](https://learn.microsoft.com/en-us/azure/sentinel/data-connectors/github-enterprise-audit-log)<st c="19637">。</st>

# <st c="19638">解决源代码管理中的常见编码安全问题</st>

<st c="19697">保护</st> <st c="19707">我们的源代码管理平台至关重要，但同样重要的是在源代码管理系统中持续测试代码的安全性和合规性。</st> <st c="19860">即使我们已经有了预提交或 IDE 安全集成，也需要这样做。</st> <st c="19952">原因很简单：预提交的代码安全措施可能被绕过；开发人员可能禁用 Git 钩子或通过修改</st> <st c="20070">配置来绕过</st> <st c="20108">**<st c="20111">静态应用程序安全测试</st>** </st> <st c="20146">(</st>**<st c="20148">SAST</st>**<st c="20152">) 或</st> **<st c="20158">软件组成分析</st>** <st c="20187">(</st>**<st c="20189">SCA</st>**<st c="20192">) 工具的检查。</st> <st c="20202">然而，源代码管理系统中的安全集成提供了更具执行力和</st> <st c="20289">更可靠的保护。</st>

<st c="20309">此外，在源代码管理系统中扫描代码比在 IDE 中扫描提供了更广泛的覆盖。</st> <st c="20398">它</st> <st c="20401">捕获了在开发者的工作空间中可能不存在的提交，尤其是在预提交时。</st> <st c="20488">这增加了发现预提交扫描中遗漏的漏洞的机会。</st> <st c="20587">第三个原因是漏洞具有动态性。</st> <st c="20639">例如，一个依赖项可能在开发和预提交阶段通过了安全检查，但此后却发现了新的漏洞。</st> <st c="20792">我们需要定期扫描源代码管理系统中的代码，以检测和解决</st> <st c="20910">这些问题。</st>

<st c="20923">当涉及到在源代码管理中处理常见的编码安全问题时，重点通常是我们在预提交阶段讨论过的相同问题：</st> *<st c="21081">检测第一方代码和第三方依赖项中的漏洞</st>* <st c="21160">(直接和传递的依赖)以及</st> *<st c="21189">识别/防止代码提交中的密钥</st>*<st c="21235">。如果你需要回顾这些问题，请随时查阅</st> *<st c="21302">处理常见开发安全错误</st>* <st c="21349">部分</st> *<st c="21361">第四章</st>*<st c="21370">。</st>

<st c="21371">然而，我们集成这些安全措施的具体位置有所不同，使用的工具也可能不同。</st> <st c="21481">以下图展示了我们将在本章中介绍的四个集成点：</st>

![图 5.11 – 代码安全集成点在源代码管理中的位置](img/B19710_05_11.jpg)

<st c="21936">图 5.11 – 代码安全集成点在源代码管理中的位置</st>

<st c="22000">说到工具，GitHub Enterprise 平台有一套出色的工具套件（</st>**<st c="22081">GitHub 代码安全</st>**<st c="22102">），用于在其源代码控制系统中集成安全扫描。</st> <st c="22170">它包括各种工具，用于识别和解决源代码控制中的代码安全问题。</st>

## <st c="22265">理解 GitHub 代码安全</st>

<st c="22300">GitHub</st> <st c="22308">代码安全不是工具；它是 GitHub 平台提供的一组功能，用于识别和修复源代码控制中的代码安全问题。</st> <st c="22460">下图概述了</st> <st c="22505">这些功能：</st>

![图 5.12 – GitHub 代码安全功能](img/B19710_05_12.jpg)

<st c="22707">图 5.12 – GitHub 代码安全功能</st>

<st c="22750">注意</st>

<st c="22755">在上图中，星号表示适用于 GitHub Enterprise 和</st> <st c="22861">Azure DevOps 的功能。</st>

<st c="22874">在接下来的几节中，我们将介绍一些可以在源代码控制中实现的代码安全集成。</st> <st c="22995">其中一些集成可以使用 GitHub 的代码安全功能来实现。</st> <st c="23082">我们将在相关章节中进一步展开讨论。</st>

## <st c="23135">建议 1 – 在源代码控制中实施依赖跟踪</st>

<st c="23205">在源代码控制中集成代码安全的起点之一是持续评估和跟踪组织中项目中使用的依赖关系。</st> <st c="23384">在安全事件期间，拥有一个集中的位置来检查包是否在组织的各个项目中使用，对于快速确定我们是否受到新披露的漏洞的影响非常有益，例如 Log4j 漏洞披露的情况（</st>**<st c="23661">CVE-2021-44228</st>**<st c="23676">）。</st> <st c="23680">GitHub 平台具有我们可以用于此的本地能力，称为</st> **<st c="23756">依赖图</st>**<st c="23772">。不幸的是，Azure DevOps 尚未直接提供此功能。</st> <st c="23851">但是，可以使用多种第三方解决方案来实现类似的功能。</st>

### <st c="23938">理解并实现 GitHub Enterprise 中的依赖图</st>

<st c="24011">依赖图提供了在 GitHub</st> <st c="24099">代码仓库中引用的直接和传递依赖的摘要。</st> <st c="24122">它通过分析每个仓库中清单文件和锁定文件中列出的依赖关系来实现这一点。</st>

<st c="24246">如前所述，通过清单文件分析检测依赖关系有其局限性，包括未清理的未使用依赖项带来的噪声以及可能在代码中使用但未在清单文件中列出的虚假依赖项。</st> <st c="24502">如果需要回顾此内容，请参见</st> *<st c="24546">SCA 工具的挑战</st>* <st c="24573">章节</st> *<st c="24585">第四章</st>*<st c="24594">。</st>

<st c="24595">截至写作时，依赖关系图支持 13 种语言中的 14 种包管理器类型。</st> <st c="24696">这包括 NuGet（.NET）、pip（Python）和 npm（JavaScript）。</st> <st c="24760">完整且最新的列表可以在</st> <st c="24799">以下位置查看：</st> [<st c="24802">https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph#supported-package-ecosystems</st>](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/about-the-dependency-graph#supported-package-ecosystems)<st c="24961">。</st>

<st c="24962">依赖关系图会自动为 GitHub 企业版组织中的所有公共仓库生成。</st> <st c="25076">它也可以在组织级别或直接在仓库级别为私有仓库和派生仓库启用。</st> <st c="25205">要在组织级别启用，组织管理员可以导航到</st> **<st c="25281">组织</st>** <st c="25293">|</st> **<st c="25296">设置</st>** <st c="25304">|</st> **<st c="25307">安全</st>** <st c="25315">|</st> **<st c="25318">代码安全</st>** <st c="25331">|</st> **<st c="25334">配置</st>**<st c="25348">|</st> **<st c="25351">新建配置</st>** <st c="25368">|</st> **<st c="25371">依赖关系图</st>**<st c="25387">：</st>

![图 5.13 – 在组织级别为私有仓库启用依赖关系图](img/B19710_05_13.jpg)

<st c="25535">图 5.13 – 在组织级别为私有仓库启用依赖关系图</st>

<st c="25629">创建新的代码安全配置后，我们可以将其应用于单个仓库、所有仓库，或没有现有配置的仓库，方法是前往</st> **<st c="25801">组织</st>** <st c="25813">|</st> **<st c="25816">设置</st>** <st c="25824">|</st> **<st c="25827">安全</st>** <st c="25835">|</st> **<st c="25838">代码安全</st>** <st c="25851">|</st> **<st c="25854">配置</st>** <st c="25867">然后选择</st> **<st c="25886">应用配置</st>** <st c="25905">或</st> **<st c="25909">应用至</st>**<st c="25917">：</st>

![图 5.14 – 将代码安全配置应用于仓库](img/B19710_05_14.jpg)

<st c="26512">图 5.14 – 将代码安全配置应用于仓库</st>

<st c="26578">启用后，我们可以通过导航到</st> **<st c="26672">仓库</st>** <st c="26682">|</st> **<st c="26685">洞察</st>** <st c="26693">|</st> **<st c="26696">依赖图</st>** <st c="26712">|</st> **<st c="26715">依赖项</st>**<st c="26727">，在仓库级别查看发现的依赖项。在组织级别，我们可以通过导航到</st> **<st c="26788">组织</st>** <st c="26800">|</st> **<st c="26803">洞察</st>** <st c="26811">|</st> **<st c="26814">依赖项</st>**<st c="26826">：</st>

![图 5.15 – 审查依赖项洞察](img/B19710_05_15.jpg)

<st c="27333">图 5.15 – 审查依赖项洞察</st>

<st c="27376">对于</st> <st c="27381">每个依赖项，我们可以</st> <st c="27405">查看许可证信息和漏洞的严重性。</st> <st c="27470">我们还可以通过提供的</st> <st c="27534">搜索框</st> <st c="27333">来搜索特定的依赖项。</st>

<st c="27545">注意</st>

<st c="27550">依赖图还提供了一个 API，可以用来提交项目的依赖关系。</st> <st c="27637">通常用于提交未通过标准扫描清单和锁定文件流程识别的依赖项。</st> <st c="27774">这些可能是直接在代码中引用的依赖项，或来自不支持的清单文件类型或语言。</st> <st c="27890">通过这种方式，依赖图将能更准确地反映项目中使用的依赖项。</st> <st c="28011">有关如何使用 API 的更多信息，请访问</st> <st c="28049">这里</st> [<st c="28052">https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/using-the-dependency-submission-api</st>](https://docs.github.com/en/code-security/supply-chain-security/understanding-your-software-supply-chain/using-the-dependency-submission-api)<st c="28191">。</st>

## <st c="28192">建议 2 – 在源代码控制中实施依赖漏洞评估和管理</st>

<st c="28293">识别</st> <st c="28306">我们项目中使用的包是一个重要的第一步。</st> <st c="28377">然而，我们还需要</st> <st c="28399">实施流程来检测包中的漏洞，优先处理这些漏洞，并在可能的情况下自动修复它们。</st> <st c="28539">即使我们已经有了</st> <st c="28573">预提交检查，如上一章所讨论的那样，这一点仍然很重要。</st> <st c="28639">预提交检查可以被绕过，因此在源代码管理中实施类似的检查</st> <st c="28710">可以作为另一层安全防护。</st> <st c="28765">此外，漏洞是动态变化的。</st> <st c="28800">一个在开发过程中通过了漏洞检查的包，可能会在之后被发现有新的漏洞。</st> <st c="28931">定期在源代码管理中进行依赖项漏洞检查，确保我们能够领先于</st> <st c="29027">这些问题。</st>

<st c="29040">GitHub Enterprise 提供了如 Dependabot 警报、Dependabot 安全更新、依赖项版本更新和 Dependabot 自动分类规则等功能，可以解决其中的一些需求，尽管可能会有一些空白和限制。</st> <st c="29274">不幸的是，这些功能目前在 Azure DevOps 中尚不可用，但有多种第三方 SCA 解决方案可以直接与 Azure Repos 集成，实现类似的功能。</st> <st c="29479">最重要的是，你需要使用适合你</st> <st c="29567">使用场景的工具来实施这些流程。</st>

### <st c="29577">在 GitHub Enterprise 中理解和实现 Dependabot 警报</st>

<st c="29647">识别</st> <st c="29660">我们项目中的包使用依赖项图是一个重要的第一步。</st> <st c="29676">然而，Dependabot 更进一步，通过在检测到已识别的包中存在漏洞时提醒并通知我们。</st> <st c="29739">Dependabot 提供了三种功能来管理项目依赖项中的漏洞：</st>

+   **<st c="29966">Dependabot 警报</st>**<st c="29984">：此</st> <st c="29992">功能</st> <st c="30000">会生成关于我们仓库依赖项中发现的漏洞的警报和通知。</st>

+   **<st c="30099">Dependabot 安全更新</st>**<st c="30127">：此</st> <st c="30135">功能会自动创建拉取请求以更新具有已知</st> <st c="30202">安全漏洞的</st> <st c="30213">依赖项。</st>

+   **<st c="30238">Dependabot 版本更新</st>**<st c="30265">：此</st> <st c="30273">功能</st> <st c="30281">会自动创建拉取请求，以将你的依赖项更新到</st> <st c="30352">最新版本。</st>

<st c="30368">注意</st>

<st c="30373">Dependabot 功能需要启用依赖项图</st> <st c="30426">。</st>

要接收来自 Dependabot 警报的通知，必须启用该功能。您可以在企业、组织或仓库级别启用。要为未来的仓库启用 Dependabot 警报，请按照以下步骤操作：

1.  **企业级**：前往**企业** | **设置** | **代码安全与分析** | **Dependabot** | **Dependabot 警报**：

    1.  要为所有现有仓库启用此功能，请点击**启用全部**（*图 5.16*）。

    1.  要为在您的企业中创建的所有新仓库自动启用此功能，请切换**自动为新** **仓库**启用：

![图 5.16 – 在组织级别启用 Dependabot 警报](img/B19710_05_16.jpg)

图 5.16 – 在组织级别启用 Dependabot 警报

1.  要在仓库级别启用 Dependabot 警报，请导航到**仓库** | **设置** | **安全性** | **代码安全与分析** | **Dependabot** | **Dependabot 警报** | **启用**。

1.  一旦**Dependabot 警报**启用，我们可以在任意一个范围内审查触发的警报——企业、组织和仓库：

    +   要在企业级别审查 Dependabot 警报，我们可以导航到**企业** | **代码安全** | **Dependabot 警报**。

    +   要在组织级别进行审查，请导航到**组织** | **安全性** | **警报** | **Dependabot**（*图 5.17*）：

![图 5.17 – 在组织级别审查 Dependabot 警报](img/B19710_05_17.jpg)

图 5.17 – 在组织级别审查 Dependabot 警报

+   <st c="32533">要在仓库级别进行审查，请导航到</st> **<st c="32581">仓库</st>** <st c="32591">|</st> **<st c="32594">安全</st>** <st c="32602">|</st> **<st c="32605">漏洞警报</st>** <st c="32625">|</st> **<st c="32628">Dependabot</st>**<st c="32638">。</st>

1.  <st c="32639">要查看在企业或组织内跨多个仓库的 Dependabot 功能（警报、安全更新等）的状态，可以导航到</st> **<st c="32804">企业</st>** <st c="32814">|</st> **<st c="32817">代码安全</st>** <st c="32830">|</st> **<st c="32833">覆盖情况</st>** *<st c="32841">或</st>* **<st c="32844">组织</st>** <st c="32857">|</st> **<st c="32860">安全</st>** <st c="32868">|</st> **<st c="32871">覆盖情况</st>** <st c="32879">(</st>*<st c="32881">图 5</st>**<st c="32889">.18</st>*<st c="32892">)：</st>

![图 5.18 – 审查组织中的 Dependabot 覆盖情况](img/B19710_05_18.jpg)

<st c="34034">图 5.18 – 审查组织中的 Dependabot 覆盖情况</st>

### <st c="34096">理解漏洞优先级排序</st>

<st c="34139">仅仅识别漏洞并不能解决它们。</st> <st c="34194">将未经优先排序的漏洞扫描报告呈现给工程团队，并指示他们</st> *<st c="34311">紧急修复这些问题</st>* <st c="34336">并不是一种有效的安全策略，在 DevSecOps 框架下也无法奏效。</st> <st c="34419">同样，" </st>*<st c="34448">只关注所有关键性和高危漏洞</st>*<st c="34500">" 这种做法也不可行，因为通常这些漏洞数量较多。</st> <st c="34537">根据</st> [<st c="34550">https://www.cvedetails.com/</st>](https://www.cvedetails.com/)<st c="34577">，55%的 CVE 的 CVSS 评分为 7 分及以上。</st>

<st c="34624">当在软件堆栈中的开源软件包（OSS）中发现漏洞时，进行风险评估是很重要的，以确定该漏洞是否构成真实威胁。</st> <st c="34787">此评估应指导开发人员如何优先处理该问题。</st> <st c="34860">然而，准确的优先级排序通常依赖于对软件运行环境及其与其他组件交互的深入理解。</st> <st c="35021">在开发的早期、提交前阶段，这些信息可能是有限的，因此很难全面评估漏洞的影响和紧迫性。</st>

<st c="35182">在一个 DevSecOps 工作流中，速度是一个关键因素，因此此风险评估应该是快速的，并且最好是自动化的。</st> <st c="35307">这就是一个好的 SCA 工具价值所在。</st> <st c="35367">一个好的 SCA 工具不仅仅是识别漏洞；它还应该提供有意义的风险评估，帮助开发人员在继续之前优先处理需要修复的部分，即使在此早期阶段上下文信息有限。</st> <st c="35612">SCA 工具在此阶段优先排序已发现漏洞的风险时使用了几种方法。</st> <st c="35724">接下来，我们将总结一些这些方法及其所提供的价值。</st> <st c="35797">提供的价值如下。</st>

### <st c="35810">理解漏洞严重性评分</st>

<st c="35855">严重性</st> <st c="35865">评分方法提供了评估已知漏洞影响和紧急性的标准化方式。</st> <st c="35968">最广泛使用的框架是**<st c="36006">Common Vulnerability Scoring System</st>** <st c="36041">(**<st c="36043">CVSS</st>**<st c="36047">)版本 3.1。</st> <st c="36063">它根据不同的指标组（基本评分指标、时间评分指标和环境评分指标）为漏洞分配分数。</st> <st c="36210">基本评分指标（最广泛使用的指标）衡量漏洞的技术严重性，</st> <st c="36316">而不是风险。</st>

<st c="36325">然而，CVSS 3.1 框架的基本评分指标有一个局限性，即它侧重于技术严重性，而非实际的利用风险。</st> <st c="36477">例如，开源库中只有 10%的漏洞是可被利用的。</st> <st c="36560">为什么开发人员要花费宝贵的时间关注那些不可利用的漏洞呢？</st> <st c="36661">这就是为什么像**<st c="36709">Exploit Prediction Scoring System</st>** <st c="36742">(**<st c="36744">EPSS</st>**<st c="36748">)这样更新的评分方法变得有价值。</st> <st c="36768">EPSS 旨在预测漏洞被利用的可能性，依托于各种数据源，如网络安全建议、社交媒体和公开提及。</st> <st c="36941">这一预测至关重要，因为两个具有相同 CVSS 分数的漏洞，在实际被利用的可能性上可能会有显著差异。</st> <st c="37093">基于 EPSS 优先进行修复工作，在管理实际风险方面可能更为有效。</st> <st c="37166">实际风险。</st>

<st c="37179">实际上，结合 CVSS 和 EPSS 提供了一种全面的漏洞优先排序方法。</st> <st c="37282">虽然 CVSS 提供了严重性的基准理解，EPSS 则增加了漏洞被利用可能性的维度。</st> <st c="37387">这种双重视角帮助开发人员在继续提交之前，确定需要优先处理的事项。</st> <st c="37487">他们的提交。</st>

### <st c="37501">理解依赖路径分析和漏洞上下文分析</st>

<st c="37575">虽然 CVSS</st> <st c="37587">和 EPSS 提供了一个可靠的起点来优先排序</st> <st c="37644">漏洞，但它们应当作为更大策略的一部分。</st> <st c="37703">CVSS 和 EPSS 帮助对安全漏洞进行评分，但它们都侧重于开源软件包漏洞的内在和外部属性，而没有考虑这些脆弱功能是否在您的代码中被使用，或如何被使用。</st> <st c="37935">例如，许多开发者导入的开源包可能在最终的应用中没有被使用，从而不会立即构成被利用的风险。</st> <st c="38099">然而，漏洞排名分数并没有捕捉或考虑到这一点。</st>

<st c="38172">所以，即使 EPSS 将漏洞评分为可能被利用，而 CVSS 将其评分为严重漏洞，如果您的代码没有调用脆弱的功能，这可能并不重要。</st> <st c="38344">没有这种优先排序技术，开发者可能会花费过多时间修复那些在</st> <st c="38499">您的代码上下文中无法被利用的漏洞。</st>

<st c="38509">依赖路径分析和漏洞上下文分析都是基于您的软件项目如何使用脆弱的开源软件包来优先排序漏洞的高级技术。</st> <st c="38714">它们的工作原理如下：</st> <st c="38725">它们是如何工作的：</st>

1.  **<st c="38735">依赖路径分析</st>**<st c="38760">：该方法检查您的项目的依赖树。</st> <st c="38812">依赖树是一个展示不同软件组件（如库和包）如何在您的应用中相互连接和依赖的图谱。</st> <st c="38821">通过分析这棵树，您可以看到一个脆弱组件如何融入到整个</st> <st c="39066">应用结构中。</st>

1.  **<st c="39088">了解漏洞路径</st>**<st c="39125">：这部分分析查看漏洞可能被利用的路径。</st> <st c="39177">它就像是追踪攻击者可能通过互联组件进入</st> <st c="39327">您的软件的路径。</st>

1.  **<st c="39341">漏洞上下文分析</st>**<st c="39372">：这一步骤深入到漏洞的具体细节。</st> <st c="39436">它</st> <st c="39439">考虑到漏洞在代码库中的位置、哪些函数受影响，以及您的应用如何使用该脆弱组件。</st> <st c="39589">这个上下文非常重要，因为代码中某部分的漏洞如果从未被使用或执行，可能就不会构成</st> <st c="39704">真正的威胁。</st>

1.  **<st c="39716">影响评估</st>**<st c="39734">：在分析了依赖路径和上下文之后，你能清楚地了解漏洞是否仅仅是理论上危险，还是在</st> <st c="39908">你的应用程序中实际存在的风险。</st>

<st c="39925">需要注意的主要问题是，许多 SCA 工具（包括 Dependabot）并未实现这些技术，因为它们可能复杂且耗时，尤其是在依赖关系多的大型项目中。</st> <st c="40137">一种供应商实现这种优先级排序技术的例子是</st> *<st c="40215">可达性分析</st>* <st c="40236">方法，Endor Labs 就使用了这种方法。</st>

<st c="40263">无论你的工具使用哪种技术组合，我们都不能过分强调与开发团队合作的重要性，以确保这一过程尽可能顺利。</st> <st c="40451">理想情况下，你的 SCA 工具或流程应专注于清晰地向开发团队呈现需要修复的优先级风险，而不会因为不必要的信息而使他们不堪重负。</st> <st c="40640">这些优先级风险需要与你组织的风险承受度相一致，并平衡修复漏洞对</st> <st c="40772">开发者生产力的影响。</st>

### <st c="40795">修复优先级漏洞</st>

<st c="40830">当一个漏洞被 CVSS 评定为高危/严重漏洞，EPSS 评估为可利用，且进一步</st> <st c="40925">分析确认该漏洞的函数在代码中被调用时，下一步是开发人员修复漏洞并重新提交代码。</st> <st c="41065">这取决于是否有官方修复。</st> <st c="41118">大多数 SCA 工具会在扫描结果中突出显示这一点。</st> <st c="41181">它们甚至会突出显示包含安全修复的包版本。</st> <st c="41260">如果有官方修复，开发团队可以将其包升级到带有安全修复的新版本（</st>*<st c="41382">图 5</st>**<st c="41391">.19</st>*<st c="41394">）：</st>

![图 5.19 – 修复优先级漏洞的决策过程](img/B19710_05_19.jpg)

<st c="41761">图 5.19 – 修复优先级漏洞的决策过程</st>

<st c="41828">然而，这个新版本可能会带来一系列问题，比如错误、兼容性问题、性能下降，甚至新的漏洞。</st> <st c="41982">这可能导致之前稳定的代码出现意外</st> <st c="42010">行为。</st> <st c="42046">因此，在应用新版本之前，进行基本的自动化构建测试是很重要的。</st>

<st c="42131">另一方面，如果没有官方修复，你的处理方式取决于 OSS 包是否</st> <st c="42232">仍在维护：</st>

+   **<st c="42249">对于仍在维护的包</st>**<st c="42273">：获取项目维护者的指导非常重要。</st> <st c="42340">他们可能会提供修复的预计时间表，或建议采取临时措施来缓解安全漏洞。</st> <st c="42452">在这种情况下，开发者可以将其标记为工作项，并继续</st> <st c="42528">进行其他工作。</st>

+   **<st c="42539">对于不再维护的包</st>**<st c="42565">：这种情况更为棘手。</st> <st c="42596">如果原开发者没有提供预期的更新，你有</st> <st c="42662">几种选择：</st>

    +   **<st c="42678">分叉依赖</st>**<st c="42698">：你可以创建并维护自己的依赖版本，应用必要的安全修复。</st> <st c="42800">然而，这需要</st> <st c="42823">持续的维护。</st>

    +   **<st c="42846">缓解风险</st>**<st c="42864">：寻求不更新</st> <st c="42872">库的替代方案以降低风险。</st>

    +   **<st c="42935">替换依赖</st>**<st c="42958">：寻找并切换到一个积极维护的替代品。</st> <st c="43016">依赖一个不再维护的组件通常不是一个可行的</st> <st c="43097">长期策略。</st>

### <st c="43116">在 GitHub Enterprise 中理解并实现 Dependabot 安全与版本更新</st>

<st c="43208">在本章前面，我们讨论了如何实现 Dependabot 警报，以获取项目中所用包的漏洞通知。</st> <st c="43303">对于每个警报，我们可以手动创建一个 Dependabot 安全更新拉取请求（</st>*<st c="43447">图 5</st>**<st c="43456">.20</st>*<st c="43459">）。</st> <st c="43463">此操作会生成一个拉取请求，并触发 GitHub Actions 工作流。</st> <st c="43541">该工作流会测试修补后的包版本与我们的代码库的兼容性，确保合并前无问题。</st> <st c="43651">虽然这是一个不错的功能，但需要手动管理项目中多个包的更新可能会拖慢开发效率，并且给开发过程带来摩擦。</st> <st c="43835">这时，Dependabot 的其他功能就派上用场了——</st> **<st c="43892">Dependabot 安全更新</st>** <st c="43919">和</st> **<st c="43924">Dependabot</st>** **<st c="43935">版本更新</st>**<st c="43950">：</st>

![图 5.20 – 手动创建 Dependabot 安全更新拉取请求](img/B19710_05_20.jpg)

<st c="44334">图 5.20 – 手动创建 Dependabot 安全更新拉取请求</st>

**<st c="44407">Dependabot 安全更新</st>** <st c="44435">可以通过自动创建</st> <st c="44495">拉取请求来更新具有已知安全漏洞的依赖项，从而自动化这一过程。</st> <st c="44569">要在仓库级别启用此功能，请导航到</st> **<st c="44629">仓库</st>** <st c="44639">|</st> **<st c="44642">设置</st>** <st c="44650">|</st> **<st c="44653">代码安全与分析</st>** <st c="44679">|</st> **<st c="44682">Dependabot 安全更新</st>** <st c="44709">|</st> **<st c="44712">启用所有</st>**<st c="44722">:</st>

![图 5.21 – 在组织级别启用 Dependabot 安全更新](img/B19710_05_21.jpg)

<st c="45079">图 5.21 – 在组织级别启用 Dependabot 安全更新</st>

**<st c="45155">Dependabot 版本更新</st>** <st c="45182">可以进一步通过自动创建拉取请求来更新依赖项，即使它们没有安全漏洞。</st> <st c="45318">要启用此功能，请导航到</st> **<st c="45354">仓库</st>** <st c="45364">|</st> **<st c="45367">设置</st>** <st c="45375">|</st> **<st c="45378">安全</st>** <st c="45386">|</st> **<st c="45389">代码安全与分析</st>** <st c="45415">|</st> **<st c="45418">Dependabot 版本更新</st>** <st c="45444">|</st> **<st c="45447">启用所有</st>**<st c="45457">。</st>

## <st c="45458">建议 3 – 实施开源许可证合规扫描</st>

<st c="45529">开源许可证是任何软件项目中的一个关键方面。</st> <st c="45598">当在你的项目中使用开源软件包时，定期评估它们的许可证风险等级是一种良好的做法。</st> <st c="45624">这个风险等级应考虑包的许可证条款对你组织合规性、知识产权和独占权的影响。</st> <st c="45720">你可以将风险从低到高进行评级，高风险意味着可能对你组织的合规性产生影响。</st> <st c="45870">如前所述，依赖图显示了每个已识别依赖项的许可证信息，但为了强制执行特定类型的许可证，我们需要实施</st> **<st c="46159">依赖审查操作</st>**<st c="46183">。我们将在下一章中讨论如何在 DevOps 的构建和测试阶段实现安全性时介绍这一点。</st> <st c="46306">现在，让我们来看看各种开源许可证类别及其管理规则。</st> *<st c="46395">图 5</st>**<st c="46403">.22</st>* <st c="46406">展示了一个开源许可证的范围：</st>

![图 5.22 – 开源许可证类别](img/B19710_05_22.jpg)

<st c="46547">图 5.22 – 开源许可证类别</st>

<st c="46591">左侧是</st> **<st c="46613">署名</st>** <st c="46624">许可证，它们更为宽松；而右侧是</st> **<st c="46690">copyleft</st>** <st c="46698">许可证，它们更为严格。</st> <st c="46737">让我们更详细地探索这些许可证类型：</st>

+   **<st c="46786">署名许可证</st>**<st c="46807">：这些</st> <st c="46816">许可证非常灵活。</st> <st c="46835">我们可以将库用于任何目的，包括商业软件。</st> <st c="46917">主要要求是给予原始包创建者署名。</st> <st c="46989">这种类型的许可证在合规性和知识产权方面通常具有</st> **<st c="47028">较低的风险</st>** <st c="47036">。</st> <st c="47094">值得注意的是，并非所有的宽松许可证仅仅是署名许可证。</st> <st c="47179">例如，MIT 许可证和 Apache 许可证是宽松的，但它们包含了比简单署名更多的额外条款。</st>

+   **<st c="47301">Copyleft 许可证</st>**<st c="47319">：这些许可证更加严格。</st> <st c="47350">你只能在具有相同许可证条款的项目中使用这些库。</st> <st c="47395">这对于商业软件来说可能会很棘手。</st> <st c="47429">它们通常被称为“病毒”许可证，因为它们可以</st> <st c="47529">将条款扩展到你项目中使用的其他软件组件。</st> <st c="47599">GNU</st> **<st c="47607">通用公共许可证</st>** <st c="47629">(</st>**<st c="47631">GPL</st>**<st c="47634">) 就是一个著名的例子。</st> <st c="47662">如果你实现了一个使用 GPL 许可证的软件包，那么任何派生作品也必须在 GPL 许可证条款下分发。</st> <st c="47782">这确保了 GPL 的自由在所有派生作品中得以保持。</st> <st c="47864">这些许可证</st> <st c="47879">通常具有</st> **<st c="47896">较高的风险评级</st>** <st c="47912">，因为它们可能对合规性、知识产权和</st> <st c="47985">独占权产生影响。</st>

+   **<st c="48002">下游或弱复制左许可证</st>**<st c="48039">：这些是中间地带。</st> <st c="48069">它们比强复制左许可证更宽松。</st> <st c="48129">与复制左许可证不同，它们</st> *<st c="48164">不</st>* <st c="48170">要求整个衍生项目采用相同的许可证</st> <st c="48234">条款。</st> <st c="48241">一个常见的例子是 GNU</st> **<st c="48269">较宽松通用公共许可证</st>** <st c="48298">(</st>**<st c="48300">LGPL</st>**<st c="48304">)。</st> <st c="48308">与 GPL 不同，LGPL 允许你将库与非 LGPL 软件链接，而无需将整个合并作品以 LGPL 许可证发布。</st> <st c="48439">然而，对 LGPL 许可证组件的任何更改必须以 LGPL 发布。</st> <st c="48520">这使得 LGPL 更适合与专有软件混合使用，同时仍保持对 LGPL 组件的改进开放。</st> <st c="48649">这些</st> <st c="48655">许可证具有</st> **<st c="48671">中等风险评级</st>** <st c="48691">因为它们对于专有集成更加宽松，但仍确保 LGPL 许可证组件的开放性。</st>

## <st c="48807">推荐 4 – 在源代码控制中实施机密保护</st>

<st c="48875">我们之前</st> <st c="48890">讨论了 GitHub 高级安全性。</st> <st c="48926">它提供的其中一个功能是机密扫描。</st> <st c="48985">这意味着我们可以实施此功能来持续扫描我们的代码库，以检测暴露的凭证。</st> <st c="49097">此外</st> <st c="49109">它还提供了</st> **<st c="49133">推送保护</st>**<st c="49148">，该功能可为 GitHub 企业版和 Azure DevOps 平台启用接收前机密扫描。</st> <st c="49247">该功能会阻止包含机密的代码提交，以防止意外</st> <st c="49330">机密泄露。</st>

<st c="49346">推送保护应自动启用在所有仓库中。</st> <st c="49417">为了审计该功能是否</st> <st c="49448">在我们的 GitHub 组织中启用，我们可以使用 Microsoft Defender for Cloud 的 DevOps 安全功能，其中包含对此的推荐（</st>*<st c="49602">图 5</st>**<st c="49611">.23</st>*<st c="49614">）。</st> <st c="49618">在撰写本文时（2024 年 4 月），还未为</st> <st c="49707">Azure DevOps 添加等效的推荐：</st>

![图 5.23 – Microsoft Defender for Cloud 推送保护推荐](img/B19710_05_23.jpg)

<st c="50367">图 5.23 – Microsoft Defender for Cloud 推送保护推荐</st>

# <st c="50440">实操练习 – 执行接收前检查和依赖项审核</st>

<st c="50513">在本次练习中，我们将在 GitHub 和 Azure DevOps 上执行预接收检查。</st> <st c="50601">我们还将审查</st> `<st c="50645">eShopOnWeb</st>` <st c="50655">应用程序的依赖关系，查找任何</st> <st c="50676">安全漏洞。</st>

<st c="50701">我们将执行以下任务：</st>

+   **<st c="50738">任务 1</st>**<st c="50745">：在 Azure DevOps 上启用推送保护</st>

+   **<st c="50788">任务 2</st>**<st c="50795">：在 GitHub 上启用推送保护</st>

+   **<st c="50832">任务 3</st>**<st c="50839">：审查 GitHub 上的依赖关系</st>

<st c="50874">让我们开始吧！</st>

## <st c="50887">任务 1 – 在 Azure DevOps 上启用推送保护</st>

<st c="50937">此任务</st> <st c="50948">旨在配置预接收条件，以便在推送被接受到仓库之前，强制执行仓库或组织的政策。</st> <st c="51085">在本任务中，我们将启用推送保护，以阻止包含机密的提交：</st>

1.  <st c="51170">在 Azure 门户主页上，在搜索框中输入</st> `<st c="51226">Azure DevOps Organizations</st>` <st c="51252">并选择</st> **<st c="51268">Azure DevOps Organizations</st>**<st c="51294">。选择你现有的组织之一，或者</st> **<st c="51341">创建</st>** **<st c="51348">新组织</st>**<st c="51364">。</st>

1.  <st c="51365">创建一个私有项目，并命名为</st> `<st c="51403">eShopOnWeb</st>`<st c="51413">：</st>

![图 5.24 – 在 Azure DevOps 上创建私有项目](img/B19710_05_24.jpg)

<st c="51784">图 5.24 – 在 Azure DevOps 上创建私有项目</st>

1.  <st c="51840">点击左侧的</st> **<st c="51850">Repos</st>** <st c="51855">，然后选择</st> **<st c="51879">Import</st>** <st c="51885">，位于</st> **<st c="51895">Import a</st>** **<st c="51904">repository</st>** <st c="51914">部分。</st>

1.  <st c="51923">在</st> `<st c="51992">.git</st>`<st c="51996">中，然后点击</st> **<st c="52009">Import</st>**<st c="52015">：</st>

![图 5.25 – 克隆 eShopOnWeb](img/B19710_05_25.jpg)

<st c="52157">图 5.25 – 克隆 eShopOnWeb</st>

1.  <st c="52189">我们将使用</st> **<st c="52260">GitHub 高级安全</st>** <st c="52284">的秘密扫描推送保护功能，</st> <st c="52302">推送保护可以防止凭证首次被提交到源代码中。</st> <st c="52399">另一个功能是</st> **<st c="52418">GitHub 高级安全</st>** <st c="52442">中的</st> **<st c="52446">秘密扫描</st>**<st c="52461">，它可以扫描你现有的</st> <st c="52508">源代码中的机密信息。</st>

1.  <st c="52520">当</st> **<st c="52526">GitHub 高级安全功能</st>** <st c="52550">为 Azure DevOps 启用时，秘密扫描会在后台启动，并生成秘密扫描警报。</st> <st c="52663">你可以通过进入</st> **<st c="52698">高级安全</st>** <st c="52715">标签下的</st> **<st c="52722">仓库</st>** <st c="52727">|</st> **<st c="52730">高级安全</st>** <st c="52747">区域，然后点击</st> **<st c="52772">秘密</st>** <st c="52779">标签来查看这些警报。</st>

1.  <st c="52784">首先，我们需要启用</st> **<st c="52810">GitHub 高级安全功能</st>**<st c="52834">。你可以在组织、项目或仓库级别启用</st> **<st c="52851">高级安全功能</st>** <st c="52868">。我们将通过导航到</st> **<st c="52974">项目设置</st>** <st c="52990">|</st> **<st c="52993">仓库</st>** <st c="52998">|</st> **<st c="53001">Repositories</st>** <st c="53013">并选择</st> **<st c="53032">eShopOnWeb</st>** <st c="53042">仓库来启用它。</st> <st c="53055">在</st> **<st c="53061">设置</st>**<st c="53069">下，切换</st> **<st c="53082">高级安全功能</st>** <st c="53099">按钮。</st> <st c="53108">一个启用并开始计费的弹出窗口将出现。</st> <st c="53157">点击</st> **<st c="53167">开始</st>** **<st c="53173">计费</st>** <st c="53180">按钮：</st>

![图 5.26 – 启用高级安全功能](img/B19710_05_26.jpg)

<st c="54052">图 5.26 – 启用高级安全功能</st>

<st c="54092">秘密</st> <st c="54100">扫描推送保护和仓库扫描现已自动启用：</st>

![图 5.27 – 启用高级安全功能后，推送保护和仓库扫描中的秘密扫描功能会被激活](img/B19710_05_27.jpg)

<st c="54574">图 5.27 – 启用高级安全功能后，推送保护和仓库扫描中的秘密扫描功能会被激活</st>

<st c="54722">当秘密在提交之前被识别时，推送保护会发出警报。</st> <st c="54825">这些警报通过命令行、Azure DevOps Web 界面，甚至通过</st> <st c="54916">你的 IDE</st> <st c="54916">发出。</st>

<st c="54925">让我们尝试提交一个包含秘密的文件，看看它是否会被阻止：</st>

1.  <st c="54990">导航到</st> **<st c="55003">仓库</st>**<st c="55008">，选择右上角的三个点，并选择</st> **<st c="55061">新建</st>** <st c="55064">|</st> **<st c="55067">文件</st>**<st c="55071">：</st>

![图 5.28 – 创建新文件](img/B19710_05_28.jpg)

<st c="55223">图 5.28 – 创建新文件</st>

1.  <st c="55256">将文件命名为</st> `<st c="55271">secrets.txt</st>` <st c="55282">并点击</st> **<st c="55297">创建</st>** <st c="55303">按钮。</st>

1.  <st c="55311">将以下内容添加到新创建的文件中，然后点击</st> **<st c="55378">提交</st>** <st c="55385">按钮：</st>

    ```
     SLACK_API_TOKEN = 'xoxp-6597890047-3599393255-7878181812-f140b8'
    ```

    *<st c="55457">图 5</st>**<st c="55466">.29</st>* <st c="55469">展示了创建的秘密文件。</st> <st c="55502">添加 Slack</st> <st c="55516">API 令牌。</st>

![图 5.29 – 向 secrets.txt 文件添加秘密](img/B19710_05_29.jpg)

<st c="55650">图 5.29 – 向 secrets.txt 文件添加秘密</st>

1.  <st c="55702">我们将看到推送被拒绝，因为它</st> <st c="55751">包含了秘密：</st>

![图 5.30 – 被高级安全阻止的秘密文件](img/B19710_05_30.jpg)

<st c="56208">图 5.30 – 被高级安全阻止的秘密文件</st>

<st c="56268">现在，让我们</st> <st c="56280">学习如何在 GitHub 上启用推送保护。</st>

## <st c="56326">任务 2 – 在 GitHub 上启用推送保护</st>

<st c="56370">在此</st> <st c="56379">时，我们需要学习如何通过推送保护防止在 GitHub 仓库中提交秘密。</st> <st c="56495">让我们</st> <st c="56501">开始吧：</st>

1.  <st c="56513">导航到 GitHub 仓库</st> <st c="56548">网址</st> [<st c="56552">https://github.com/PacktPublishing/eShopContainers</st>](https://github.com/PacktPublishing/eShopContainers)<st c="56602">。</st>

1.  <st c="56603">将仓库 Fork 到你的 GitHub。</st> <st c="56640">确保仓库</st> <st c="56665">是公开的。</st>

1.  <st c="56675">现在，选择</st> **<st c="56692">设置</st>** <st c="56700">选项卡。</st> <st c="56706">在左侧边栏中，点击</st> **<st c="56733">安全</st>**<st c="56741">，然后点击</st> **<st c="56749">代码安全</st>** **<st c="56763">与分析</st>**<st c="56775">。</st>

1.  <st c="56776">在</st> **<st c="56783">秘密扫描</st>**<st c="56798">下，启用</st> **<st c="56807">推送保护</st>** <st c="56822">，点击</st> **<st c="56835">启用</st>**<st c="56841">：</st>

![图 5.31 – 在 GitHub 上启用推送保护](img/B19710_05_31.jpg)

<st c="57131">图 5.31 – 在 GitHub 上启用推送保护</st>

<st c="57179">秘密</st> <st c="57187">扫描作为推送保护可在企业、组织和</st> <st c="57265">仓库级别启用。</st>

1.  <st c="57283">现在，让我们尝试提交一个包含秘密的文件，看看它是否会</st> <st c="57348">被拒绝。</st>

1.  <st c="57360">点击</st> **<st c="57388">添加文件</st>** <st c="57396">|</st> **<st c="57399">创建</st>** **<st c="57406">新文件</st>**<st c="57414">：</st>

![图 5.32 – 在 GitHub 上添加新文件](img/B19710_05_32.jpg)

<st c="57886">图 5.32 – 在 GitHub 上添加新文件</st>

1.  <st c="57927">命名文件为</st> `<st c="57942">secrets.txt</st>`<st c="57953">，添加以下秘密内容，然后点击</st> **<st c="57997">提交更改…</st>**<st c="58012">：</st>

    ```
     AWS_ACCESS_KEY_ID = 'AKIAYVP4CIPPERUVIFXG'
    AWS_SECRET_ACCESS_KEY = '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'
    SLACK_API_TOKEN = 'xoxp-4797898847-4799393255-4778181812-f140b6'
    ```

    *<st c="58189">图 5</st>**<st c="58198">.33</st>* <st c="58201">展示了带有机密信息的文件。</st>

![图 5.33 – 向新文件中添加机密信息](img/B19710_05_33.jpg)

<st c="58520">图 5.33 – 向新文件中添加机密信息</st>

1.  <st c="58564">提交</st> <st c="58576">将被拒绝，因为使用</st> <st c="58633">推送保护检测到了机密信息：</st>

![图 5.34 – 因源代码中的机密信息而被拒绝的提交](img/B19710_05_34.jpg)

<st c="59457">图 5.34 – 因源代码中的机密信息而被拒绝的提交</st>

<st c="59520">您现在可以尝试使用其他平台进行提交，例如 VS Code。</st> <st c="59587">提交将</st> <st c="59604">被拒绝。</st>

## <st c="59616">任务 3 – 审查 GitHub 上的依赖项</st>

<st c="59658">对于这个</st> <st c="59668">任务，我们将检查依赖项中存在的安全漏洞。</st> <st c="59749">我们将</st> <st c="59757">审查依赖关系图，导出依赖项为</st> **<st c="59815">软件材料清单</st>** <st c="59841">(</st>**<st c="59843">SBOM</st>**<st c="59847">)，并使用 Dependabot 执行依赖项审查。</st> <st c="59901">请按照</st> <st c="59908">以下步骤进行操作：</st>

<st c="59920">注意</st>

<st c="59925">我们将用于此任务的工具适用于 GitHub 平台。</st> <st c="60000">对于其他 SCM 平台，微软有一个公共工具用于 SBOM 生成，您可以通过以下链接访问</st> <st c="60093">这里：</st> [<st c="60099">https://github.com/microsoft/sbom-tool</st>](https://github.com/microsoft/sbom-tool)<st c="60137">。</st>

1.  <st c="60138">首先，让我们配置依赖关系图，以便它能够识别我们所有的项目依赖关系和依赖者。</st> <st c="60252">每个依赖项将具有许可证信息和指定的漏洞严重性。</st> <st c="60340">该依赖关系图会自动为所有公共仓库生成，也可以为私有仓库启用</st> <st c="60460">。</st>

1.  <st c="60468">要在私有仓库上启用依赖关系图，请导航至</st> **<st c="60537">设置</st>** <st c="60545">|</st> **<st c="60548">代码安全性与分析</st>** <st c="60574">(在</st> **<st c="60582">安全</st>** <st c="60590">下)</st> **<st c="60595">依赖关系图</st>** <st c="60611">并</st> <st c="60616">点击</st> **<st c="60622">启用</st>** <st c="60628">：</st>

![图 5.35 – 依赖关系图](img/B19710_05_35.jpg)

<st c="60685">图 5.35 – 依赖关系图</st>

1.  <st c="60715">您可以通过导航到</st> <st c="60764">**Insights**</st> <st c="60775">来查看依赖关系图：</st>

![图 5.36 – Insights](img/B19710_05_36.jpg)

<st c="60863">图 5.36 – Insights</st>

1.  <st c="60885">然后，点击</st> **<st c="60898">依赖关系图</st>**<st c="60914">：</st>

![图 5.37 – Insights 下的依赖关系图](img/B19710_05_37.jpg)

<st c="61078">图 5.37 – Insights 下的依赖关系图</st>

1.  <st c="61123">点击</st> <st c="61130">侧边栏中的</st> **<st c="61143">依赖关系图</st>** <st c="61159">选项后，依赖项列表将显示其版本和安全严重性详情。</st> <st c="61277">每个依赖项都会列出其所在的清单文件的详情，以及</st> <st c="61378">其许可证：</st>

![图 5.38 – 依赖关系图详情](img/B19710_05_38.jpg)

<st c="62145">图 5.38 – 依赖关系图详情</st>

1.  <st c="62183">您还可以从依赖关系图导出您的仓库的 SBOM。</st> <st c="62210">SBOM 显示开源使用和供应链漏洞。</st> <st c="62260">SBOM 将通过 GitHub 用户界面或</st> <st c="62323">REST API 生成，并采用 SPDX 格式。</st>

    <st c="62411">SBOM 是一个结构化且机器可读的列表，详细列出了项目的依赖关系，以及版本、包标识符和许可证等相关信息。</st> <st c="62583">SBOM 在通过以下方式减轻供应链风险中起着至关重要的作用：</st>

    +   <st c="62665">增强关于在</st> <st c="62737">您的仓库中使用的依赖关系的透明度</st>

    +   <st c="62752">促进在</st> <st c="62812">开发过程中的早期漏洞检测</st>

    +   <st c="62831">提供关于代码库中潜在许可证合规性、安全性或质量问题的见解</st> <st c="62929">代码库</st>

    +   <st c="62938">帮助遵守各种数据保护标准，以提高</st> <st c="63001">合规性</st>

1.  <st c="63020">要生成 SBOM，请点击</st> **<st c="63049">导出 SBOM</st>**<st c="63060">：</st>

![图 5.39 – 导出 SBOM](img/B19710_05_39.jpg)

<st c="63852">图 5.39 – 导出 SBOM</st>

<st c="63877">导出将采用机器可读格式，以便数据可以进一步</st> <st c="63950">处理。</st>

1.  <st c="63968">最后，让我们启用 Dependabot。</st> <st c="64002">您可以通过访问</st> **<st c="64032">设置</st>** <st c="64040">|</st> **<st c="64043">代码安全性和分析</st>** <st c="64069">|</st> **<st c="64072">依赖项警报</st>** <st c="64089">并选择</st> **<st c="64103">启用全部或直接</st>** <st c="64125">从</st> **<st c="64135">依赖关系图</st>** <st c="64151">页面启用，如下所示：</st>

![图 5.40 – 从依赖关系图页面启用 Dependabot](img/B19710_05_40.jpg)

<st c="64411">图 5.40 – 从依赖关系图页面启用 Dependabot</st>

1.  <st c="64475">这两种选项都有效。</st> <st c="64508">这将触发一个新的工作流，并且来自 Dependabot 的安全漏洞将在</st> **<st c="64614">安全性</st>** <st c="64622">标签页中可见：</st>

![图 5.41 – GitHub 上的 Dependabot 警报（左侧有 126 个 Dependabot 警报）](img/B19710_05_41.jpg)

<st c="65335">图 5.41 – GitHub 上的 Dependabot 警报（左侧为 126 个 Dependabot 警报）</st>

<st c="65412">查看</st> <st c="65424">Dependabot 发现的问题并审查这些安全漏洞的严重性。</st>

# <st c="65511">总结</st>

<st c="65519">在本章中，我们讨论了 DevOps 源代码控制阶段的两个主要安全问题。</st> <st c="65619">首先，我们查看了可以遵循的指南，以实现受保护的源代码控制环境。</st> <st c="65722">其次，我们探讨了如何整合安全工具来识别和修复可能导致</st> <st c="65837">安全问题的常见编码错误。</st>

<st c="65853">在接下来的章节中，我们将讨论如何在 DevOps 的构建和测试阶段</st> <st c="65946">实施安全性。</st>

# <st c="0">第三部分：确保 DevOps 构建、测试、发布和操作阶段的安全性</st>

<st c="72">在本部分中，你将探索在 Azure 云中构建、测试、发布和操作阶段的最佳安全实践。</st>

<st c="199">本部分包含以下章节：</st>

+   *<st c="242">第六章</st>*<st c="252">,</st> *<st c="254">在 DevOps 的构建阶段实施安全性</st>*

+   *<st c="304">第七章</st>*<st c="314">,</st> *<st c="316">在 DevOps 的测试和发布阶段实施安全性</st>*

+   *<st c="378">第八章</st>*<st c="388">,</st> *<st c="390">在 Azure 上进行持续安全监控</st>*
